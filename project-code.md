# PWA-TorServe Project Source Code

Generated on: 2026-01-16T19:56:01.633Z

## Project Statistics

- Total files included: 65
- Date: 1/16/2026

## Table of Contents

- [Dockerfile](#Dockerfile)
- [README.md](#README-md)
- [claude.md](#claude-md)
- [client/README.md](#client-README-md)
- [client/capacitor.config.json](#client-capacitor-config-json)
- [client/eslint.config.js](#client-eslint-config-js)
- [client/package.json](#client-package-json)
- [client/postcss.config.js](#client-postcss-config-js)
- [client/public/manifest.json](#client-public-manifest-json)
- [client/src/App.jsx](#client-src-App-jsx)
- [client/src/components/AutoDownloadPanel.jsx](#client-src-components-AutoDownloadPanel-jsx)
- [client/src/components/DiagnosticsPanel.jsx](#client-src-components-DiagnosticsPanel-jsx)
- [client/src/components/Poster.jsx](#client-src-components-Poster-jsx)
- [client/src/components/SearchPanel.jsx](#client-src-components-SearchPanel-jsx)
- [client/src/components/SettingsPanel.jsx](#client-src-components-SettingsPanel-jsx)
- [client/src/components/StatusBanners.jsx](#client-src-components-StatusBanners-jsx)
- [client/src/components/TorrentModal.jsx](#client-src-components-TorrentModal-jsx)
- [client/src/main.jsx](#client-src-main-jsx)
- [client/src/utils/helpers.js](#client-src-utils-helpers-js)
- [client/tailwind.config.js](#client-tailwind-config-js)
- [client/vite.config.js](#client-vite-config-js)
- [db.json](#db-json)
- [docker-compose.synology.yml](#docker-compose-synology-yml)
- [docker-compose.yml](#docker-compose-yml)
- [docs/API_SECURITY.md](#docs-API_SECURITY-md)
- [docs/CLOUDFLARE_WORKER_SETUP.md](#docs-CLOUDFLARE_WORKER_SETUP-md)
- [docs/LAMPAC_FULL_PROJECT_CODE.md](#docs-LAMPAC_FULL_PROJECT_CODE-md)
- [docs/MATRIX_FULL_PROJECT_CODE.md](#docs-MATRIX_FULL_PROJECT_CODE-md)
- [docs/POSTER_BATTLE_HISTORY.md](#docs-POSTER_BATTLE_HISTORY-md)
- [docs/TMDB_CENSORSHIP_ANALYSIS.md](#docs-TMDB_CENSORSHIP_ANALYSIS-md)
- [docs/alt_search.js](#docs-alt_search-js)
- [docs/cloudflare_worker.js](#docs-cloudflare_worker-js)
- [docs/deno_apn.js](#docs-deno_apn-js)
- [docs/deno_worker.js](#docs-deno_worker-js)
- [docs/kp_source.js](#docs-kp_source-js)
- [docs/tmdb_proxy.js](#docs-tmdb_proxy-js)
- [generate-docs.js](#generate-docs-js)
- [package.json](#package-json)
- [roadmap.md](#roadmap-md)
- [server/__tests__/logger.test.js](#server-__tests__-logger-test-js)
- [server/__tests__/run-tests.js](#server-__tests__-run-tests-js)
- [server/__tests__/test-runner.js](#server-__tests__-test-runner-js)
- [server/__tests__/torrent.test.js](#server-__tests__-torrent-test-js)
- [server/__tests__/watchdog.test.js](#server-__tests__-watchdog-test-js)
- [server/aggregator.js](#server-aggregator-js)
- [server/autodownloader.js](#server-autodownloader-js)
- [server/db.js](#server-db-js)
- [server/dbQueue.js](#server-dbQueue-js)
- [server/index.js](#server-index-js)
- [server/jacred.js](#server-jacred-js)
- [server/providers/BaseProvider.js](#server-providers-BaseProvider-js)
- [server/providers/JacredProvider.js](#server-providers-JacredProvider-js)
- [server/providers/ProviderManager.js](#server-providers-ProviderManager-js)
- [server/providers/RuTrackerProvider.js](#server-providers-RuTrackerProvider-js)
- [server/providers/RutorProvider.js](#server-providers-RutorProvider-js)
- [server/providers/TorLookProvider.js](#server-providers-TorLookProvider-js)
- [server/providers/index.js](#server-providers-index-js)
- [server/rutracker.js](#server-rutracker-js)
- [server/searchCache.js](#server-searchCache-js)
- [server/torrent.js](#server-torrent-js)
- [server/utils/doh.js](#server-utils-doh-js)
- [server/utils/lag-monitor.js](#server-utils-lag-monitor-js)
- [server/utils/logger.js](#server-utils-logger-js)
- [server/utils/retry.js](#server-utils-retry-js)
- [server/watchdog.js](#server-watchdog-js)

---

### Dockerfile

```text
# PWA-TorServe Docker Image
# Multi-stage build: Client + Server

# ‚îÄ‚îÄ‚îÄ Stage 1: Build Client ‚îÄ‚îÄ‚îÄ
# ‚îÄ‚îÄ‚îÄ Stage 1: Client Builder ‚îÄ‚îÄ‚îÄ
FROM node:20-slim AS client-builder
WORKDIR /app/client
COPY client/package*.json ./
RUN npm ci
COPY client/ ./
RUN npm run build

# ‚îÄ‚îÄ‚îÄ Stage 2: Server Dependency Builder ‚îÄ‚îÄ‚îÄ
FROM node:20-slim AS server-builder
WORKDIR /app
# Install build tools for native modules (python3, make, g++)
RUN apt-get update && apt-get install -y python3 make g++ && rm -rf /var/lib/apt/lists/*
COPY package*.json ./
# Install ALL dependencies (including devDependencies if needed for build, but usually --only=production is fine if no build steps)
# We use --only=production to avoid dev deps, but we need build tools.
RUN npm ci --only=production

# ‚îÄ‚îÄ‚îÄ Stage 3: Final Production Image ‚îÄ‚îÄ‚îÄ
FROM node:20-slim

# Install runtime dependencies (ffmpeg only)
RUN apt-get update && \
    apt-get install -y ffmpeg curl && \
    rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy built node_modules from builder
COPY --from=server-builder /app/node_modules ./node_modules
# Copy built client from client-builder
COPY --from=client-builder /app/client/dist ./client/dist
# Copy project files
COPY package*.json ./
COPY server/ ./server/

# Create directories
RUN mkdir -p /app/downloads /app/data && \
    echo '{"serverStatus":"ok","lastStateChange":0,"storageFailures":0,"progress":{}}' > /app/data/db.json

# Expose port
EXPOSE 3000

# Environment defaults
ENV DOWNLOAD_PATH=/app/downloads
ENV DB_PATH=/app/data/db.json
ENV NODE_ENV=production

# Health check (using curl)
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s \
    CMD curl -f http://localhost:3000/api/health || exit 1

# Start server
CMD ["node", "server/index.js"]

```

---

### README.md

```md
# üì∫ PWA-TorServe
**Self-Healing Streaming Torrent Server for Home**

Listen to audiobooks, watch movies and TV shows **online without full downloading** on Android TV, phone, browser, or any device. Works on Synology NAS, Raspberry Pi, home server, or in Docker. Starts in seconds.

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

### ‚ú® Why PWA-TorServe?
- **Instant Start** ‚Äî Video plays in 5‚Äì10 seconds (even 4K HDR)
- **Self-Healing** ‚Äî Watchdog + Circuit Breaker + RAM monitoring to prevent crashes
- **Turbo Mode** ‚Äî Automatically boosts connections during playback
- **Smart Priority** ‚Äî Prioritizes first video chunks for instant start
- **Native Players** ‚Äî Vimu, VLC, MX Player launch directly from PWA (Capacitor)
- **TV-Friendly UI** ‚Äî Netflix-like interface with remote control/focus support
- **Docker-First** ‚Äî Single `docker-compose up` ‚Üí ready on NAS

### üöÄ Features
| Feature | Description |
| :--- | :--- |
| üì∫ **Streaming** | Stream without full download (torrent-stream + on-demand priority) |
| üîç **Search** | Jacred (multi-mirror) + TMDB/Kinopoisk posters |
| üé¨ **Turbo & Priority** | Auto-boost peers + prioritize required chunks for playback start |
| üñºÔ∏è **Posters & Metadata** | TMDB/Kinopoisk with DoH bypass for blocks |
| üìã **M3U Playlist** | For Kodi, Plex, VLC integration |
| üßπ **File Hygiene** | Auto-delete files when removing torrents |
| üõ°Ô∏è **Watchdog** | RAM/Storage monitoring, auto-pause, circuit breaker |
| ‚ö° **PWA + Native** | Installable as an app on Android TV/Phone |
| üì• **Auto-Downloader** | Automatic series tracking with customizable rules (6h/12h/24h intervals) |
| üéÆ **TV Remote Support** | Full D-pad navigation with focus trap in modals |

### üõ† Tech Stack
- **Backend**: Node.js, Express, torrent-stream, lowdb
- **Frontend**: React 19, Vite 7, TailwindCSS 4
- **Mobile/TV**: Capacitor 6 (APK + native intents)
- **DevOps**: Docker multi-stage, docker-compose
- **Bypass**: DoH, insecureAgent, Cloudflare Worker (optional)

### üì¶ Installation (1 Minute)
**Docker (Synology / Raspberry Pi / Any NAS)**
```bash
# Create download folder
mkdir -p /volume1/docker/pwa-torserve/downloads

# Start container
docker-compose up -d
```

**Access:** `http://your-nas-ip:3000`

### üì± Android TV / Mobile Client
1. Open `http://your-nas-ip:3000` in Chrome
2. Tap "Add to Home Screen" (PWA)
3. **Or build native APK:**
   ```bash
   cd client && npm install && npm run build
   npx cap sync
   cd android && ./gradlew assembleDebug
   ```

### ‚ö° Usage
1. Open the app
2. Paste **magnet link** ‚Üí **Add**
3. Wait for metadata (5-10 sec)
4. Press **‚ñ∂ WATCH** ‚Üí Video opens in Vimu/VLC/MX Player

### ‚ùì FAQ
**Q: Does it work on Android TV?**
A: Yes! Use the PWA or build the APK. Supports Vimu/VLC/MX Player via native intents.

**Q: How much RAM is needed?**
A: 512MB‚Äì1GB is sufficient. The watchdog prevents OOM issues.

**Q: TMDB is blocked?**
A: Use Cloudflare Worker or Kinopoisk API (see `.env.example`).

---

### üìÑ License
MIT License ‚Äî Free to use, modify, and distribute.

### ‚ù§Ô∏è Contribute
If this project helped you, please star it on GitHub!

**Made with ‚ù§Ô∏è for home cinema.**
```

---

### claude.md

```md
# Code Review: PWA-TorServe
**–î–∞—Ç–∞ –Ω–∞—á–∞–ª–∞:** 2026-01-14

## –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–æ–µ–∫—Ç–µ
- **–ù–∞–∑–≤–∞–Ω–∏–µ**: PWA-TorServe
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –î–æ–º–∞—à–Ω–∏–π –º–µ–¥–∏–∞-—Å–µ—Ä–≤–µ—Ä –¥–ª—è —Å—Ç—Ä–∏–º–∏–Ω–≥–∞ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤
- **–°—Ç–µ–∫**: Node.js, Express, React 19, torrent-stream, lowdb
- **–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è**: 512MB RAM (—Å–ª–∞–±–æ–µ –∂–µ–ª–µ–∑–æ)
- **–í–µ—Ä—Å–∏—è**: v2.3.2 (—Å–æ–≥–ª–∞—Å–Ω–æ –ø–æ—Å–ª–µ–¥–Ω–µ–º—É –∫–æ–º–º–∏—Ç—É)

---

## –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞

```
PWA-TorServe/
‚îú‚îÄ‚îÄ server/                    # Backend (Node.js + Express)
‚îÇ   ‚îú‚îÄ‚îÄ index.js              # –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ —Å–µ—Ä–≤–µ—Ä–∞ (20KB)
‚îÇ   ‚îú‚îÄ‚îÄ torrent.js            # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞–º–∏ (26KB) ‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ù–´–ô
‚îÇ   ‚îú‚îÄ‚îÄ watchdog.js           # Watchdog/–º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ (12KB) ‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ù–´–ô
‚îÇ   ‚îú‚îÄ‚îÄ db.js                 # –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö lowdb (1.3KB)
‚îÇ   ‚îú‚îÄ‚îÄ dbQueue.js            # –û—á–µ—Ä–µ–¥—å –∑–∞–ø–∏—Å–∏ –≤ –ë–î (955B)
‚îÇ   ‚îú‚îÄ‚îÄ autodownloader.js     # –ê–≤—Ç–æ–∑–∞–≥—Ä—É–∑—á–∏–∫ (12KB)
‚îÇ   ‚îú‚îÄ‚îÄ jacred.js             # Jacred API –∫–ª–∏–µ–Ω—Ç (5.9KB)
‚îÇ   ‚îú‚îÄ‚îÄ rutracker.js          # RuTracker –ø–∞—Ä—Å–µ—Ä (6KB)
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ logger.js         # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
‚îÇ       ‚îú‚îÄ‚îÄ doh.js            # DNS over HTTPS
‚îÇ       ‚îî‚îÄ‚îÄ lag-monitor.js    # –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ª–∞–≥–æ–≤
‚îú‚îÄ‚îÄ client/                    # Frontend (React 19 + Vite)
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îú‚îÄ‚îÄ App.jsx
‚îÇ       ‚îú‚îÄ‚îÄ main.jsx
‚îÇ       ‚îî‚îÄ‚îÄ components/
‚îú‚îÄ‚îÄ db.json                    # –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö lowdb
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ docker-compose.yml
```

---

## –õ–æ–≥ –∏–∑–º–µ–Ω–µ–Ω–∏–π

### [2026-01-14 19:00] - –ù–∞—á–∞–ª–æ –∞–Ω–∞–ª–∏–∑–∞
- –°–æ–∑–¥–∞–Ω —Ñ–∞–π–ª claude.md
- –ò–∑—É—á–µ–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞
- –û–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –∫—Ä–∏—Ç–∏—á–Ω—ã–µ –º–æ–¥—É–ª–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞

### [2026-01-14 19:05] - Priority 1: –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏
- –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã —Ñ–∞–π–ª—ã: torrent.js, watchdog.js, db.js, dbQueue.js, index.js
- –ù–∞–π–¥–µ–Ω–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–±–ª–µ–º: **4**

### [2026-01-14 19:10] - Priority 2: –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å
- –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã —Ñ–∞–π–ª—ã: jacred.js, doh.js, rutracker.js, index.js
- –ù–∞–π–¥–µ–Ω–æ –ø—Ä–æ–±–ª–µ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏: **3** (1 –∑–∞–¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω –∫–∞–∫ –æ—Å–æ–∑–Ω–∞–Ω–Ω—ã–π –∫–æ–º–ø—Ä–æ–º–∏—Å—Å)

### [2026-01-14 19:15] - Priority 3: –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
- –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã –≤—Å–µ —Ñ–∞–π–ª—ã
- –ù–∞–π–¥–µ–Ω–æ –ø—Ä–æ–±–ª–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏: **3**

---

## –ù–∞–π–¥–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã

### üõë –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï (Priority 1)

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #1: Memory Leak - –¢–∞–π–º–∞—É—Ç –Ω–µ –æ—á–∏—â–∞–µ—Ç—Å—è –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏

- **–§–∞–π–ª**: `server/torrent.js:268-274`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Memory Leak / Logic Error
- **–û–ø–∏—Å–∞–Ω–∏–µ**: setTimeout –¥–ª—è 90-—Å–µ–∫—É–Ω–¥–Ω–æ–≥–æ —Ç–∞–π–º–∞—É—Ç–∞ —Å–æ–∑–¥–∞—ë—Ç—Å—è, –Ω–æ –ù–ï –æ—á–∏—â–∞–µ—Ç—Å—è –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞. –≠—Ç–æ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ —Ç–æ–º—É, —á—Ç–æ —á–µ—Ä–µ–∑ 90 —Å–µ–∫—É–Ω–¥ –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–æ—Ä—Ä–µ–Ω—Ç–∞ —Ç–∞–π–º–∞—É—Ç –≤—Å—ë —Ä–∞–≤–Ω–æ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –ø–æ–ø—ã—Ç–∞–µ—Ç—Å—è —É–Ω–∏—á—Ç–æ–∂–∏—Ç—å —É–∂–µ —Ä–∞–±–æ—Ç–∞—é—â–∏–π engine.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**:
  - –ß–µ—Ä–µ–∑ 90 —Å–µ–∫—É–Ω–¥ –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–æ—Ä—Ä–µ–Ω—Ç –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω–æ —É–Ω–∏—á—Ç–æ–∂–µ–Ω
  - –£—Ç–µ—á–∫–∞ –ø–∞–º—è—Ç–∏ –æ—Ç –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è —Ç–∞–π–º–∞—É—Ç–æ–≤
  - –ù–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ –≤–∏–¥–µ–æ
- **–†–∏—Å–∫**: üî¥ –í—ã—Å–æ–∫–∏–π

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// torrent.js:267-274
// üî• STRATEGY 3: Increased Timeout (90s)
setTimeout(() => {
    if (!engines.has(magnetURI)) {
        console.warn('[Torrent] Timeout: no peers found')
        engine.destroy()
        reject(new Error('Torrent timeout: no peers found within 90 seconds'))
    }
}, 90000)
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
// –°–æ–∑–¥–∞—ë–º —Ç–∞–π–º–∞—É—Ç –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –µ–≥–æ ID –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–π –æ—á–∏—Å—Ç–∫–∏
const timeoutId = setTimeout(() => {
    if (!engines.has(magnetURI)) {
        console.warn('[Torrent] Timeout: no peers found')
        engine.destroy()
        reject(new Error('Torrent timeout: no peers found within 90 seconds'))
    }
}, 90000)

engine.on('ready', () => {
    // ‚úÖ –û—á–∏—â–∞–µ–º —Ç–∞–π–º–∞—É—Ç –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
    clearTimeout(timeoutId)

    console.log('[Torrent] Engine ready:', engine.infoHash)
    // ... –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥
})

engine.on('error', (err) => {
    // ‚úÖ –û—á–∏—â–∞–µ–º —Ç–∞–π–º–∞—É—Ç –ø—Ä–∏ –æ—à–∏–±–∫–µ
    clearTimeout(timeoutId)

    console.error('[Torrent] Engine error:', err.message)
    engine.destroy()
    reject(err)
})
```

**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**:
1. –î–æ–±–∞–≤–∏—Ç—å —Ç–æ—Ä—Ä–µ–Ω—Ç —Å —Ö–æ—Ä–æ—à–∏–º–∏ —Å–∏–¥–∞–º–∏ (–±—ã—Å—Ç—Ä–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ)
2. –ü–æ–¥–æ–∂–¥–∞—Ç—å 90+ —Å–µ–∫—É–Ω–¥
3. –£–±–µ–¥–∏—Ç—å—Å—è —á—Ç–æ —Ç–æ—Ä—Ä–µ–Ω—Ç –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å (—Ä–∞–Ω—å—à–µ –º–æ–≥ –±—ã—Ç—å —É–Ω–∏—á—Ç–æ–∂–µ–Ω)

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #2: Memory Leak - setInterval –Ω–µ –æ—á–∏—â–∞–µ—Ç—Å—è –ø—Ä–∏ shutdown

- **–§–∞–π–ª**: `server/torrent.js:31-52`, `server/index.js:43-50`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Memory Leak
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –ì–ª–æ–±–∞–ª—å–Ω—ã–µ setInterval –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ frozen torrents –∏ rateLimitMap –Ω–µ –∏–º–µ—é—Ç –º–µ—Ö–∞–Ω–∏–∑–º–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏. –ü—Ä–∏ graceful shutdown –æ–Ω–∏ –ø—Ä–æ–¥–æ–ª–∂–∞—é—Ç —Ä–∞–±–æ—Ç–∞—Ç—å.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**:
  - –£—Ç–µ—á–∫–∞ –ø–∞–º—è—Ç–∏ –ø—Ä–∏ –≥–æ—Ä—è—á–µ–π –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–µ –≤ dev —Ä–µ–∂–∏–º–µ
  - –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã –ø—Ä–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
- **–†–∏—Å–∫**: üü° –°—Ä–µ–¥–Ω–∏–π (–≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ —Å–µ—Ä–≤–µ—Ä –æ–±—ã—á–Ω–æ –Ω–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è —á–∞—Å—Ç–æ)

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// torrent.js:31 - –Ω–µ—Ç —Å–ø–æ—Å–æ–±–∞ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —ç—Ç–æ—Ç –∏–Ω—Ç–µ—Ä–≤–∞–ª
setInterval(() => {
    // cleanup frozen torrents
}, 2 * 60 * 1000)

// index.js:43 - –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ
setInterval(() => {
    // cleanup rate limit map
}, 5 * 60 * 1000)
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
// torrent.js - —Å–æ—Ö—Ä–∞–Ω—è–µ–º ID –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞
let frozenCleanupInterval = null

export function startFrozenCleanup() {
    if (frozenCleanupInterval) return

    frozenCleanupInterval = setInterval(() => {
        // ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–¥ –æ—á–∏—Å—Ç–∫–∏
    }, 2 * 60 * 1000)
}

export function stopFrozenCleanup() {
    if (frozenCleanupInterval) {
        clearInterval(frozenCleanupInterval)
        frozenCleanupInterval = null
    }
}

// –í destroyAllTorrents –¥–æ–±–∞–≤–∏—Ç—å:
export const destroyAllTorrents = () => {
    stopFrozenCleanup()  // ‚úÖ –î–æ–±–∞–≤–∏—Ç—å
    // ... –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥
}
```

**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**:
1. –ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–µ—Ä–≤–µ—Ä
2. –í—ã–ø–æ–ª–Ω–∏—Ç—å graceful shutdown (Ctrl+C)
3. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –≤—Å–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã –æ—á–∏—â–µ–Ω—ã (–≤ –ª–æ–≥–∞—Ö –Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø–æ—Å–ª–µ shutdown)

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #3: Race Condition - –£–¥–∞–ª–µ–Ω–∏–µ –∏–∑ Map –≤–æ –≤—Ä–µ–º—è –∏—Ç–µ—Ä–∞—Ü–∏–∏

- **–§–∞–π–ª**: `server/torrent.js:296-298`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Race Condition
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –í —Ñ—É–Ω–∫—Ü–∏–∏ removeTorrent –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –∏—Ç–µ—Ä–∞—Ü–∏—è –ø–æ Map —Å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–º —É–¥–∞–ª–µ–Ω–∏–µ–º —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –≠—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –ø—Ä–æ–ø—É—Å–∫—É —ç–ª–µ–º–µ–Ω—Ç–æ–≤.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**:
  - –ù–µ –≤—Å–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ engine –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã –∏–∑ Map
  - –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —É—Ç–µ—á–∫–∞ –ø–∞–º—è—Ç–∏
- **–†–∏—Å–∫**: üü° –°—Ä–µ–¥–Ω–∏–π

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// torrent.js:296-298
for (const [key, val] of engines.entries()) {
    if (val === engine) engines.delete(key)  // ‚ùå –£–¥–∞–ª–µ–Ω–∏–µ –≤–æ –≤—Ä–µ–º—è –∏—Ç–µ—Ä–∞—Ü–∏–∏
}
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
// –°–æ–±–∏—Ä–∞–µ–º –∫–ª—é—á–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤
const keysToDelete = []
for (const [key, val] of engines.entries()) {
    if (val === engine) keysToDelete.push(key)
}
// –£–¥–∞–ª—è–µ–º –ø–æ—Å–ª–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏
for (const key of keysToDelete) {
    engines.delete(key)
}
```

**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**:
1. –î–æ–±–∞–≤–∏—Ç—å —Ç–æ—Ä—Ä–µ–Ω—Ç (—Å–æ–∑–¥–∞—ë—Ç—Å—è 2 –∫–ª—é—á–∞: magnetURI –∏ infoHash)
2. –£–¥–∞–ª–∏—Ç—å —Ç–æ—Ä—Ä–µ–Ω—Ç
3. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ engines.size === 0 (–æ–±–∞ –∫–ª—é—á–∞ —É–¥–∞–ª–µ–Ω—ã)

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #4: –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —É—Ç–µ—á–∫–∞ —Å—Ç—Ä–∏–º–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ –¥–æ pipe

- **–§–∞–π–ª**: `server/index.js:512-526`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Resource Leak
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ stream –ø–æ—Å–ª–µ –µ–≥–æ —Å–æ–∑–¥–∞–Ω–∏—è, –Ω–æ –¥–æ pipe(), stream –º–æ–∂–µ—Ç –æ—Å—Ç–∞—Ç—å—Å—è –æ—Ç–∫—Ä—ã—Ç—ã–º. –û–±—Ä–∞–±–æ—Ç—á–∏–∫ `res.on('close')` –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç –µ—Å–ª–∏ –∫–ª–∏–µ–Ω—Ç –Ω–µ –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**:
  - –£—Ç–µ—á–∫–∞ file descriptors –ø—Ä–∏ —á–∞—Å—Ç—ã—Ö –æ—à–∏–±–∫–∞—Ö
  - –í–æ–∑–º–æ–∂–Ω–æ–µ –∏—Å—á–µ—Ä–ø–∞–Ω–∏–µ –ª–∏–º–∏—Ç–∞ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Ñ–∞–π–ª–æ–≤
- **–†–∏—Å–∫**: üü° –°—Ä–µ–¥–Ω–∏–π

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// index.js:512-526
const stream = file.createReadStream({ start, end })

stream.on('error', (err) => {
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏
    stream.destroy()
})

res.on('close', () => {
    stream.destroy()
})
stream.pipe(res)  // –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ –¥–æ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–∏, res.on('close') –º–æ–∂–µ—Ç –Ω–µ —Å—Ä–∞–±–æ—Ç–∞—Ç—å
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
const stream = file.createReadStream({ start, end })

// ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º pipeline –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –æ—á–∏—Å—Ç–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤
const { pipeline } = await import('stream/promises')

try {
    await pipeline(stream, res)
} catch (err) {
    if (!res.headersSent) {
        res.status(500).send('Stream error')
    }
    // pipeline –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–Ω–∏—á—Ç–æ–∂–∞–µ—Ç –≤—Å–µ —Å—Ç—Ä–∏–º—ã –ø—Ä–∏ –æ—à–∏–±–∫–µ
}

// –ò–ª–∏ –±–æ–ª–µ–µ –ø—Ä–æ—Å—Ç–æ–π –≤–∞—Ä–∏–∞–Ω—Ç (–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è):
const stream = file.createReadStream({ start, end })

const cleanup = () => {
    if (!stream.destroyed) stream.destroy()
}

stream.on('error', (err) => {
    console.error(`[Stream] Error:`, err.message)
    cleanup()
    if (!res.headersSent) {
        res.status(500).send('Stream error')
    }
})

res.on('close', cleanup)
res.on('error', cleanup)

stream.pipe(res)
```

**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**:
1. –ù–∞—á–∞—Ç—å —Å—Ç—Ä–∏–º–∏–Ω–≥ —Ñ–∞–π–ª–∞
2. –ü—Ä–µ—Ä–≤–∞—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ –∫–ª–∏–µ–Ω—Ç–∞
3. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤ –ª–æ–≥–∞—Ö —á—Ç–æ stream.destroy() –≤—ã–∑–≤–∞–Ω
4. –ú–æ–Ω–∏—Ç–æ—Ä–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö file descriptors (lsof | wc -l)

---

### üõ° –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨ (Priority 2)

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #5: SSL Validation –æ—Ç–∫–ª—é—á–µ–Ω–∞ (–ó–ê–î–û–ö–£–ú–ï–ù–¢–ò–†–û–í–ê–ù–û)

- **–§–∞–π–ª**: `server/jacred.js:78`, `server/utils/doh.js:13`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: SSL/TLS Security
- **–û–ø–∏—Å–∞–Ω–∏–µ**: `rejectUnauthorized: false` –æ—Ç–∫–ª—é—á–∞–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫—É SSL —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**: –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å MITM-–∞—Ç–∞–∫–∏
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ó–ê–î–û–ö–£–ú–ï–ù–¢–ò–†–û–í–ê–ù–û –∫–∞–∫ –æ—Å–æ–∑–Ω–∞–Ω–Ω—ã–π –∫–æ–º–ø—Ä–æ–º–∏—Å—Å (—Å–º. –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –≤ jacred.js:1-24)
- **–†–∏—Å–∫**: üü° –°—Ä–µ–¥–Ω–∏–π (—Å–º—è–≥—á–µ–Ω–æ: —Ç–æ–ª—å–∫–æ –ø–æ–∏—Å–∫–æ–≤—ã–µ –∑–∞–ø—Ä–æ—Å—ã, –±–µ–∑ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏, magnet-—Å—Å—ã–ª–∫–∏ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ –∑–∞—â–∏—â–µ–Ω—ã)

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è**: –û—Å—Ç–∞–≤–∏—Ç—å –∫–∞–∫ –µ—Å—Ç—å. –≠—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Å–∞–º–æ–ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–º–∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞–º–∏ Jacred-–∑–µ—Ä–∫–∞–ª.

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #6: –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π Path Traversal –≤ TMDB Image Proxy

- **–§–∞–π–ª**: `server/index.js:197-198`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Path Traversal
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –ü–∞—Ä–∞–º–µ—Ç—Ä `imagePath` –∏–∑ URL –Ω–∞–ø—Ä—è–º—É—é –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –±–µ–∑ –≤–∞–ª–∏–¥–∞—Ü–∏–∏. –•–æ—Ç—è —ç—Ç–æ –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –≤ TMDB API (–Ω–µ –≤ —Ñ–∞–π–ª–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É), –∑–ª–æ—É–º—ã—à–ª–µ–Ω–Ω–∏–∫ –º–æ–∂–µ—Ç –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –º–∞–Ω–∏–ø—É–ª–∏—Ä–æ–≤–∞—Ç—å –∑–∞–ø—Ä–æ—Å–∞–º–∏.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ (TMDB API —Å–∞–º –≤–∞–ª–∏–¥–∏—Ä—É–µ—Ç –ø—É—Ç–∏), –Ω–æ –Ω–∞—Ä—É—à–∞–µ—Ç –ø—Ä–∏–Ω—Ü–∏–ø defense in depth
- **–†–∏—Å–∫**: üü¢ –ù–∏–∑–∫–∏–π

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// index.js:197-198
app.get('/api/tmdb/image/:size/:path', async (req, res) => {
    const { size, path: imagePath } = req.params
    const url = `https://image.tmdb.org/t/p/${size}/${imagePath}`
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
app.get('/api/tmdb/image/:size/:path', async (req, res) => {
    const { size, path: imagePath } = req.params

    // ‚úÖ –í–∞–ª–∏–¥–∞—Ü–∏—è size (—Ç–æ–ª—å–∫–æ —Ä–∞–∑—Ä–µ—à—ë–Ω–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã)
    const allowedSizes = ['w92', 'w154', 'w185', 'w342', 'w500', 'w780', 'original']
    if (!allowedSizes.includes(size)) {
        return res.status(400).send('Invalid size')
    }

    // ‚úÖ –í–∞–ª–∏–¥–∞—Ü–∏—è imagePath (—Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã, —Ü–∏—Ñ—Ä—ã, —Ç–æ—á–∫–∏, –¥–µ—Ñ–∏—Å—ã)
    if (!/^[a-zA-Z0-9._-]+$/.test(imagePath)) {
        return res.status(400).send('Invalid path')
    }

    const url = `https://image.tmdb.org/t/p/${size}/${imagePath}`
```

**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**:
1. –ó–∞–ø—Ä–æ—Å–∏—Ç—å `/api/tmdb/image/w500/abc123.jpg` - –¥–æ–ª–∂–µ–Ω —Ä–∞–±–æ—Ç–∞—Ç—å
2. –ó–∞–ø—Ä–æ—Å–∏—Ç—å `/api/tmdb/image/w500/../../../etc/passwd` - –¥–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å 400

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #7: –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π XSS –≤ M3U Playlist

- **–§–∞–π–ª**: `server/index.js:378`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: XSS (Cross-Site Scripting)
- **–û–ø–∏—Å–∞–Ω–∏–µ**: `file.name` –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä–æ–≤–∞–Ω—ã –ø–ª–µ–µ—Ä–æ–º –∏–ª–∏ –±—Ä–∞—É–∑–µ—Ä–æ–º
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –¥–ª—è M3U —Ñ–æ—Ä–º–∞—Ç–∞, –Ω–æ –ª—É—á—à–µ —Å–∞–Ω–∏—Ç–∏–∑–∏—Ä–æ–≤–∞—Ç—å
- **–†–∏—Å–∫**: üü¢ –ù–∏–∑–∫–∏–π

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// index.js:378
m3u += `#EXTINF:-1,${file.name}\n`
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
// –ü—Ä–æ—Å—Ç–∞—è —Å–∞–Ω–∏—Ç–∏–∑–∞—Ü–∏—è –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
const safeName = file.name
    .replace(/[\r\n]/g, ' ')  // –£–±–∏—Ä–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥—ã —Å—Ç—Ä–æ–∫
    .replace(/,/g, ';')        // –ó–∞–º–µ–Ω—è–µ–º –∑–∞–ø—è—Ç—ã–µ (—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –≤ EXTINF)
    .substring(0, 200)         // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É

m3u += `#EXTINF:-1,${safeName}\n`
```

---

### ‚ö° –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–¨ (Priority 3)

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #8: –°–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π fs.existsSync –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ

- **–§–∞–π–ª**: `server/index.js:533`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Event Loop Blocking
- **–û–ø–∏—Å–∞–Ω–∏–µ**: `fs.existsSync()` - –±–ª–æ–∫–∏—Ä—É—é—â–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è. –•–æ—Ç—è –æ–Ω–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ, —ç—Ç–æ –Ω–∞—Ä—É—à–∞–µ—Ç –ø—Ä–∏–Ω—Ü–∏–ø –Ω–µ–±–ª–æ–∫–∏—Ä—É—é—â–µ–≥–æ I/O.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ (—Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ), –Ω–æ –ª—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å async
- **–†–∏—Å–∫**: üü¢ –ù–∏–∑–∫–∏–π

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// index.js:532-534
let indexHtmlExists = false
try {
    indexHtmlExists = fs.existsSync(path.join(distPath, 'index.html'))
} catch (e) { }
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
–û—Å—Ç–∞–≤–∏—Ç—å –∫–∞–∫ –µ—Å—Ç—å - —ç—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ —Å–µ—Ä–≤–µ—Ä–∞ –∏ –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ runtime –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å. –ü–µ—Ä—Ñ–µ–∫—Ü–∏–æ–Ω–∏–∑–º –∑–¥–µ—Å—å –Ω–µ –æ–ø—Ä–∞–≤–¥–∞–Ω.

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #9: Dynamic import –≤ hot path

- **–§–∞–π–ª**: `server/index.js:429`, `server/torrent.js:421`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Performance
- **–û–ø–∏—Å–∞–Ω–∏–µ**: `import('fs/promises')` –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∫–∞–∂–¥—ã–π —Ä–∞–∑ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∫–µ—à–∞. Dynamic import –∫–µ—à–∏—Ä—É–µ—Ç—Å—è Node.js, –Ω–æ –≤—Å—ë —Ä–∞–≤–Ω–æ —Å–æ–∑–¥–∞—ë—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π overhead.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**: –ù–µ–±–æ–ª—å—à–æ–µ –∑–∞–º–µ–¥–ª–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π
- **–†–∏—Å–∫**: üü¢ –ù–∏–∑–∫–∏–π

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// index.js:429 - –∫–∞–∂–¥—ã–π —Ä–∞–∑ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞
import('fs/promises').then(fsPromises => {
    fsPromises.rm(fullPath, { recursive: true, force: true })
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
// –í –Ω–∞—á–∞–ª–µ —Ñ–∞–π–ª–∞ (static import)
import fsPromises from 'fs/promises'

// –í –∫–æ–¥–µ:
fsPromises.rm(fullPath, { recursive: true, force: true })
```

**–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ**: Node.js –∫–µ—à–∏—Ä—É–µ—Ç dynamic imports, –ø–æ—ç—Ç–æ–º—É —ç—Ç–æ —Å–∫–æ—Ä–µ–µ –≤–æ–ø—Ä–æ—Å —á–∏—Å—Ç–æ—Ç—ã –∫–æ–¥–∞, —á–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #10: Logger –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —É—Ä–æ–≤–µ–Ω—å –Ω–µ–æ–ø—Ç–∏–º–∞–ª—å–Ω–æ

- **–§–∞–π–ª**: `server/utils/logger.js:48-51`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Minor Performance
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –£—Å–ª–æ–≤–∏–µ `LOG_LEVELS.debug >= currentLevel` –≤—Å–µ–≥–¥–∞ false –∫–æ–≥–¥–∞ currentLevel = info (1), –ø–æ—Ç–æ–º—É —á—Ç–æ debug = 0. –õ–æ–≥–∏–∫–∞ –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**: Debug –ª–æ–≥–∏ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –≤—ã–≤–æ–¥—è—Ç—Å—è –¥–∞–∂–µ —Å LOG_LEVEL=debug
- **–†–∏—Å–∫**: üü° –°—Ä–µ–¥–Ω–∏–π (–≤–ª–∏—è–µ—Ç –Ω–∞ –æ—Ç–ª–∞–¥–∫—É)

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// logger.js:47-51
debug: (message, data = {}) => {
    if (LOG_LEVELS.debug >= currentLevel) {  // ‚ùå 0 >= 1 = false
        console.log(formatMessage('debug', moduleName, message, data))
    }
},
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
debug: (message, data = {}) => {
    if (currentLevel <= LOG_LEVELS.debug) {  // ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞
        console.log(formatMessage('debug', moduleName, message, data))
    }
},
```

---

### üßπ –ö–û–î-–°–¢–ê–ô–õ (Priority 4)

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #11: –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞ –ø–æ–∏—Å–∫–∞ –ø–æ hash –≤ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞—Ö

- **–§–∞–π–ª**: `server/torrent.js` (–Ω–µ—Å–∫–æ–ª—å–∫–æ –º–µ—Å—Ç)
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: DRY Violation
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –ü–æ–∏—Å–∫ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞ –ø–æ hash —Å toLowerCase() –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è –≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –º–µ—Å—Ç–∞—Ö
- **–†–∏—Å–∫**: üü¢ –ù–∏–∑–∫–∏–π

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è**: –°–æ–∑–¥–∞—Ç—å –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é `findTorrentByHash(hash)`.

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #12: Magic Numbers

- **–§–∞–π–ª**: –†–∞–∑–ª–∏—á–Ω—ã–µ —Ñ–∞–π–ª—ã
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Code Style
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –ß–∏—Å–ª–∞ –∫–∞–∫ 90000, 2 * 60 * 1000 –∏ —Ç.–¥. –ª—É—á—à–µ –≤—ã–Ω–µ—Å—Ç–∏ –≤ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
- **–†–∏—Å–∫**: üü¢ –ù–∏–∑–∫–∏–π

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è**: –£–∂–µ —á–∞—Å—Ç–∏—á–Ω–æ —Å–¥–µ–ª–∞–Ω–æ (CONFIG –≤ watchdog.js). –ú–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å –Ω–∞ –¥—Ä—É–≥–∏–µ –º–æ–¥—É–ª–∏.

---

## –°–≤–æ–¥–∫–∞

**–í—Å–µ–≥–æ –Ω–∞–π–¥–µ–Ω–æ –ø—Ä–æ–±–ª–µ–º**: 12
- üõë –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ: **4**
- üõ° –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å: **3** (1 –∑–∞–¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω –∫–∞–∫ –æ—Å–æ–∑–Ω–∞–Ω–Ω—ã–π –∫–æ–º–ø—Ä–æ–º–∏—Å—Å)
- ‚ö° –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: **3**
- üßπ –ö–æ–¥-—Å—Ç–∞–π–ª: **2**

---

## –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π

### üî¥ –ò–°–ü–†–ê–í–ò–¢–¨ –°–ï–ô–ß–ê–° (–≤–ª–∏—è–µ—Ç –Ω–∞ —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å):

1. **–ü—Ä–æ–±–ª–µ–º–∞ #1**: Memory Leak - –¢–∞–π–º–∞—É—Ç –≤ addTorrent
   - –°–∞–º–∞—è –∫—Ä–∏—Ç–∏—á–Ω–∞—è: –º–æ–∂–µ—Ç —É–Ω–∏—á—Ç–æ–∂–∏—Ç—å —Ä–∞–±–æ—Ç–∞—é—â–∏–π —Ç–æ—Ä—Ä–µ–Ω—Ç —á–µ—Ä–µ–∑ 90 —Å–µ–∫—É–Ω–¥

2. **–ü—Ä–æ–±–ª–µ–º–∞ #3**: Race Condition –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∏–∑ Map
   - –ú–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ —É—Ç–µ—á–∫–µ –ø–∞–º—è—Ç–∏

### üü° –ò–°–ü–†–ê–í–ò–¢–¨ –°–ö–û–†–û (—É–ª—É—á—à–∏—Ç –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç—å):

3. **–ü—Ä–æ–±–ª–µ–º–∞ #4**: –£—Ç–µ—á–∫–∞ —Å—Ç—Ä–∏–º–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ
4. **–ü—Ä–æ–±–ª–µ–º–∞ #10**: –õ–æ–≥–≥–µ—Ä –Ω–µ –≤—ã–≤–æ–¥–∏—Ç debug –ª–æ–≥–∏ (–≤–∞–∂–Ω–æ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏!)

### üü¢ –ò–°–ü–†–ê–í–ò–¢–¨ –ü–û –í–û–ó–ú–û–ñ–ù–û–°–¢–ò:

5. **–ü—Ä–æ–±–ª–µ–º–∞ #2**: setInterval –ø—Ä–∏ shutdown
6. **–ü—Ä–æ–±–ª–µ–º–∞ #6**: –í–∞–ª–∏–¥–∞—Ü–∏—è TMDB –ø—É—Ç–µ–π
7. **–ü—Ä–æ–±–ª–µ–º–∞ #7**: –°–∞–Ω–∏—Ç–∏–∑–∞—Ü–∏—è –∏–º—ë–Ω –≤ M3U
8. **–ü—Ä–æ–±–ª–µ–º–∞ #9**: Static import –≤–º–µ—Å—Ç–æ dynamic

---

## –û–±—â–∏–π —Ä–∏—Å–∫ –∏–∑–º–µ–Ω–µ–Ω–∏–π: üü° –°–†–ï–î–ù–ò–ô

–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ª–æ–∫–∞–ª—å–Ω—ã –∏ –Ω–µ –º–µ–Ω—è—é—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É. –ú–æ–∂–Ω–æ –ø—Ä–∏–º–µ–Ω—è—Ç—å –ø–æ –æ–¥–Ω–æ–º—É —Å —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º.

---

## –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è

**–ù–∞—á–∞—Ç—å —Å –ü—Ä–æ–±–ª–µ–º—ã #1** - –æ–Ω–∞ –Ω–∞–∏–±–æ–ª–µ–µ –∫—Ä–∏—Ç–∏—á–Ω–∞ –∏ –º–æ–∂–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å —Å–ø–æ–Ω—Ç–∞–Ω–Ω—ã–µ –æ–±—Ä—ã–≤—ã –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è.

–ó–∞—Ç–µ–º –∏—Å–ø—Ä–∞–≤–∏—Ç—å **–ü—Ä–æ–±–ª–µ–º—É #10** (–ª–æ–≥–≥–µ—Ä) —á—Ç–æ–±—ã debug –ª–æ–≥–∏ —Ä–∞–±–æ—Ç–∞–ª–∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º.

---

## ‚úÖ –ü–†–ò–ú–ï–ù–Å–ù–ù–´–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø (2026-01-14)

–í—Å–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω—ã. –ù–∏–∂–µ —Å–ø–∏—Å–æ–∫ –∏–∑–º–µ–Ω–µ–Ω–∏–π:

### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ü—Ä–æ–±–ª–µ–º–∞ #1 - Memory Leak –≤ addTorrent
- **–§–∞–π–ª**: `server/torrent.js`
- **–ò–∑–º–µ–Ω–µ–Ω–∏–µ**: –î–æ–±–∞–≤–ª–µ–Ω–æ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ `timeoutId` –∏ `clearTimeout()` –≤ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞—Ö `engine.on('ready')` –∏ `engine.on('error')`
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û

### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ü—Ä–æ–±–ª–µ–º–∞ #2 - setInterval –ø—Ä–∏ shutdown
- **–§–∞–π–ª—ã**: `server/torrent.js`, `server/index.js`
- **–ò–∑–º–µ–Ω–µ–Ω–∏–µ**:
  - torrent.js: –î–æ–±–∞–≤–ª–µ–Ω—ã —Ñ—É–Ω–∫—Ü–∏–∏ `startFrozenCleanup()` –∏ `stopFrozenCleanup()` —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º ID –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞. –í—ã–∑–æ–≤ `stopFrozenCleanup()` –≤ `destroyAllTorrents()`
  - index.js: –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ `rateLimitCleanupId` –∏ –µ–≥–æ –æ—á–∏—Å—Ç–∫–∞ –≤ `gracefulShutdown()`
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û

### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ü—Ä–æ–±–ª–µ–º–∞ #3 - Race Condition –≤ removeTorrent
- **–§–∞–π–ª**: `server/torrent.js`
- **–ò–∑–º–µ–Ω–µ–Ω–∏–µ**: –°–±–æ—Ä –∫–ª—é—á–µ–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤ `keysToDelete` –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û

### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ü—Ä–æ–±–ª–µ–º–∞ #4 - –£—Ç–µ—á–∫–∞ —Å—Ç—Ä–∏–º–∞
- **–§–∞–π–ª**: `server/index.js`
- **–ò–∑–º–µ–Ω–µ–Ω–∏–µ**: –î–æ–±–∞–≤–ª–µ–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è `cleanup()` —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π `stream.destroyed`, –ø–æ–¥–∫–ª—é—á–µ–Ω–∞ –∫ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞–º `res.on('close')` –∏ `res.on('error')`
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û

### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ü—Ä–æ–±–ª–µ–º–∞ #7 - –°–∞–Ω–∏—Ç–∏–∑–∞—Ü–∏—è M3U
- **–§–∞–π–ª**: `server/index.js`
- **–ò–∑–º–µ–Ω–µ–Ω–∏–µ**: –î–æ–±–∞–≤–ª–µ–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è `sanitizeM3U()` –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –∏–º—ë–Ω —Ñ–∞–π–ª–æ–≤ –æ—Ç –ø–µ—Ä–µ–≤–æ–¥–æ–≤ —Å—Ç—Ä–æ–∫ –∏ —É–ø—Ä–∞–≤–ª—è—é—â–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û

### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ü—Ä–æ–±–ª–µ–º–∞ #9 - Static import –≤–º–µ—Å—Ç–æ dynamic
- **–§–∞–π–ª—ã**: `server/torrent.js`, `server/index.js`
- **–ò–∑–º–µ–Ω–µ–Ω–∏–µ**: –ó–∞–º–µ–Ω—ë–Ω `await import('fs/promises')` –Ω–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π `import fsPromises from 'fs/promises'` –≤ –Ω–∞—á–∞–ª–µ —Ñ–∞–π–ª–æ–≤
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û

### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ü—Ä–æ–±–ª–µ–º–∞ #10 - –õ–æ–≥–≥–µ—Ä –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞
- **–§–∞–π–ª**: `server/utils/logger.js`
- **–ò–∑–º–µ–Ω–µ–Ω–∏–µ**: –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ª–æ–≤–∏–µ —Å `LOG_LEVELS.debug >= currentLevel` –Ω–∞ `currentLevel <= LOG_LEVELS.debug` –¥–ª—è –≤—Å–µ—Ö —É—Ä–æ–≤–Ω–µ–π –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û

---

## –ù–ï –ò–°–ü–†–ê–í–õ–ï–ù–û (–æ—Å–æ–∑–Ω–∞–Ω–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è)

### –ü—Ä–æ–±–ª–µ–º–∞ #5 - SSL Validation
- **–ü—Ä–∏—á–∏–Ω–∞**: –î–æ–º–∞—à–Ω–∏–π –ø—Ä–æ–µ–∫—Ç, –∑–µ—Ä–∫–∞–ª–∞ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ
- **–°—Ç–∞—Ç—É—Å**: ‚è≠Ô∏è –ü–†–û–ü–£–©–ï–ù–û (–ø–æ –∑–∞–ø—Ä–æ—Å—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)

### –ü—Ä–æ–±–ª–µ–º–∞ #6 - Path Traversal –≤ TMDB
- **–ü—Ä–∏—á–∏–Ω–∞**: –ù–∏–∑–∫–∏–π —Ä–∏—Å–∫, –¥–æ–º–∞—à–Ω—è—è —Å–µ—Ç—å
- **–°—Ç–∞—Ç—É—Å**: ‚è≠Ô∏è –ü–†–û–ü–£–©–ï–ù–û

### –ü—Ä–æ–±–ª–µ–º–∞ #8 - –°–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π fs.existsSync
- **–ü—Ä–∏—á–∏–Ω–∞**: –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ, –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –≤–ª–∏—è–Ω–∏–µ
- **–°—Ç–∞—Ç—É—Å**: ‚è≠Ô∏è –ü–†–û–ü–£–©–ï–ù–û

### –ü—Ä–æ–±–ª–µ–º—ã #11, #12 - –ö–æ–¥-—Å—Ç–∞–π–ª
- **–ü—Ä–∏—á–∏–Ω–∞**: –ù–µ –≤–ª–∏—è—é—Ç –Ω–∞ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
- **–°—Ç–∞—Ç—É—Å**: ‚è≠Ô∏è –ü–†–û–ü–£–©–ï–ù–û

---

## –ò—Ç–æ–≥–æ–≤—ã–π —Å—Ç–∞—Ç—É—Å

| –ö–∞—Ç–µ–≥–æ—Ä–∏—è | –ù–∞–π–¥–µ–Ω–æ | –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ | –ü—Ä–æ–ø—É—â–µ–Ω–æ |
|-----------|---------|------------|-----------|
| üõë –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ | 4 | 4 | 0 |
| üõ° –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å | 3 | 1 | 2 |
| ‚ö° –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å | 3 | 2 | 1 |
| üßπ –ö–æ–¥-—Å—Ç–∞–π–ª | 2 | 0 | 2 |
| **–í—Å–µ–≥–æ** | **12** | **7** | **5** |

**–í–µ—Ä—Å–∏—è –ø–æ—Å–ª–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π**: v2.3.3 (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)

```

---

### client/README.md

```md
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.

```

---

### client/capacitor.config.json

```json
{
    "appId": "com.torserve.pwa",
    "appName": "MediaBox",
    "webDir": "dist",
    "server": {
        "androidScheme": "https",
        "cleartext": true,
        "allowNavigation": [
            "192.168.1.70",
            "192.168.1.*",
            "*"
        ]
    },
    "android": {
        "allowMixedContent": true
    }
}
```

---

### client/eslint.config.js

```js
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

```

---

### client/package.json

```json
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@capacitor/app": "^6.0.3",
    "@capacitor/browser": "^6.0.6",
    "@capacitor/core": "^6.2.1",
    "@capacitor/preferences": "^6.0.3",
    "react": "^19.2.0",
    "react-dom": "^19.2.0"
  },
  "devDependencies": {
    "@capacitor/android": "^6.2.1",
    "@capacitor/cli": "^6.2.1",
    "@eslint/js": "^9.39.1",
    "@tailwindcss/postcss": "^4.1.17",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.22",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.17",
    "vite": "^7.2.4"
  }
}
```

---

### client/postcss.config.js

```js
export default {
    plugins: {
        '@tailwindcss/postcss': {},
        autoprefixer: {},
    },
}

```

---

### client/public/manifest.json

```json
{
    "name": "MediaBox",
    "short_name": "MediaBox",
    "description": "Home Media Streaming Server",
    "start_url": "/",
    "display": "standalone",
    "background_color": "#141E30",
    "theme_color": "#00c6ff",
    "icons": [
        {
            "src": "/icon-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "any maskable"
        },
        {
            "src": "/icon-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "any maskable"
        }
    ]
}
```

---

### client/src/App.jsx

```javascript
/**
 * PWA-TorServe - Main Application
 * Refactored for maintainability - components extracted to /components
 */
import { useState, useEffect } from 'react'
import { registerPlugin } from '@capacitor/core'
import { App as CapacitorApp } from '@capacitor/app'
import { Capacitor } from '@capacitor/core'
import { Preferences } from '@capacitor/preferences'

// Components
import Poster from './components/Poster'
import { DegradedBanner, ErrorScreen, BufferingBanner, ServerStatusBar } from './components/StatusBanners'
import DiagnosticsPanel from './components/DiagnosticsPanel'
import SettingsPanel from './components/SettingsPanel'
import SearchPanel from './components/SearchPanel'
import TorrentModal from './components/TorrentModal'
import AutoDownloadPanel from './components/AutoDownloadPanel'

// Helpers
import { cleanTitle } from './utils/helpers'

// Register Custom Java Bridge
const TVPlayer = registerPlugin('TVPlayer')

// Constants
const PLAYERS = [
  { id: 'net.gtvbox.videoplayer', name: 'Vimu Player (–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º)' },
  { id: 'org.videolan.vlc', name: 'VLC for Android' },
  { id: 'com.mxtech.videoplayer.ad', name: 'MX Player' },
  { id: '', name: 'System Chooser (–°–ø—Ä–∞—à–∏–≤–∞—Ç—å –≤—Å–µ–≥–¥–∞)' }
]

const CATEGORIES = [
  { id: 'all', name: '–í—Å–µ', icon: 'üìö' },
  { id: 'movie', name: '–§–∏–ª—å–º—ã', icon: 'üé¨' },
  { id: 'series', name: '–°–µ—Ä–∏–∞–ª—ã', icon: 'üì∫' },
  { id: 'music', name: '–ú—É–∑—ã–∫–∞', icon: 'üéµ' },
  { id: 'other', name: '–î—Ä—É–≥–æ–µ', icon: 'üìÅ' }
]

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Main App
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function App() {
  // State: Server & Settings
  const [serverUrl, setServerUrl] = useState(() => {
    if (Capacitor.isNativePlatform()) {
      return localStorage.getItem('serverUrl') || 'http://192.168.1.70:3000'
    }
    return ''
  })

  // üî• v2.3: Use Capacitor Preferences for Android 9 compatibility
  const [preferredPlayer, setPreferredPlayer] = useState('net.gtvbox.videoplayer')
  const [prefsLoaded, setPrefsLoaded] = useState(false)

  const [tmdbProxyUrl, setTmdbProxyUrl] = useState(
    localStorage.getItem('tmdbProxyUrl') || ''
  )

  // Load preferences on mount (async for Capacitor Preferences)
  useEffect(() => {
    const loadPreferences = async () => {
      try {
        if (Capacitor.isNativePlatform()) {
          const { value } = await Preferences.get({ key: 'preferredPlayer' })
          if (value) {
            console.log('[Prefs] Loaded player:', value)
            setPreferredPlayer(value)
          }
        } else {
          const stored = localStorage.getItem('preferredPlayer')
          if (stored) setPreferredPlayer(stored)
        }
      } catch (e) {
        console.warn('[Prefs] Failed to load:', e)
      } finally {
        setPrefsLoaded(true)
      }
    }
    loadPreferences()
  }, [])

  // State: Torrents
  const [torrents, setTorrents] = useState([])
  const [magnet, setMagnet] = useState('')
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)

  // State: UI
  const [showSettings, setShowSettings] = useState(false)
  const [showServerInput, setShowServerInput] = useState(false)
  const [selectedTorrent, setSelectedTorrent] = useState(null)
  const [buffering, setBuffering] = useState(null)
  const [showDiagnostics, setShowDiagnostics] = useState(false)

  // State: Server Health
  const [serverStatus, setServerStatus] = useState('ok')
  const [lastStateChange, setLastStateChange] = useState(null)
  const [retryAfter, setRetryAfter] = useState(null)

  // State: Sorting & Filtering
  const [sortBy, setSortBy] = useState(localStorage.getItem('sortBy') || 'name')
  const [categoryFilter, setCategoryFilter] = useState('all')

  // State: Search
  const [showSearch, setShowSearch] = useState(false)
  const [searchQuery, setSearchQuery] = useState('')
  const [searchResults, setSearchResults] = useState([])
  const [searchLoading, setSearchLoading] = useState(false)

  // State: Auto-Download
  const [showAutoDownload, setShowAutoDownload] = useState(false)

  // State: Last Played (for auto-continue)
  const [lastPlayed, setLastPlayed] = useState(() => {
    try {
      return JSON.parse(localStorage.getItem('lastPlayed')) || null
    } catch { return null }
  })

  // ‚îÄ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ
  const getCategory = (torrent) => {
    const files = torrent.files || []
    const videos = files.filter(f => /\.(mp4|mkv|avi|webm|mov)$/i.test(f.name))
    const audio = files.filter(f => /\.(mp3|flac|m4a|ogg|wav)$/i.test(f.name))

    if (audio.length > 0 && videos.length === 0) return 'music'
    if (videos.length > 1) return 'series'
    if (videos.length === 1) return 'movie'
    return 'other'
  }

  const getFilteredAndSortedTorrents = () => {
    let result = [...torrents]

    if (categoryFilter !== 'all') {
      result = result.filter(t => getCategory(t) === categoryFilter)
    }

    result.sort((a, b) => {
      switch (sortBy) {
        case 'name': return (a.name || '').localeCompare(b.name || '')
        case 'size':
          const sizeA = a.files?.reduce((sum, f) => sum + (f.length || 0), 0) || 0
          const sizeB = b.files?.reduce((sum, f) => sum + (f.length || 0), 0) || 0
          return sizeB - sizeA
        case 'peers': return (b.numPeers || 0) - (a.numPeers || 0)
        default: return 0
      }
    })

    return result
  }

  const displayTorrents = getFilteredAndSortedTorrents()

  // ‚îÄ‚îÄ‚îÄ Settings Handlers ‚îÄ‚îÄ‚îÄ
  // üî• v2.3: Use Capacitor Preferences for Android 9 compatibility
  const savePreferredPlayer = async (playerId) => {
    setPreferredPlayer(playerId)
    try {
      if (Capacitor.isNativePlatform()) {
        await Preferences.set({ key: 'preferredPlayer', value: playerId })
        console.log('[Prefs] Saved player:', playerId)
      } else {
        localStorage.setItem('preferredPlayer', playerId)
      }
    } catch (e) {
      console.warn('[Prefs] Failed to save:', e)
      localStorage.setItem('preferredPlayer', playerId) // Fallback
    }
  }

  const saveSortBy = (sort) => {
    setSortBy(sort)
    localStorage.setItem('sortBy', sort)
  }

  const handleServerUrlChange = (url, save = false) => {
    setServerUrl(url)
    if (save) {
      localStorage.setItem('serverUrl', url)
      setShowSettings(false)
      fetchStatus()
    }
  }

  const handleTmdbProxyUrlChange = (url, save = false) => {
    setTmdbProxyUrl(url)
    if (save) {
      localStorage.setItem('tmdbProxyUrl', url)
    }
  }

  // ‚îÄ‚îÄ‚îÄ API Helpers ‚îÄ‚îÄ‚îÄ
  const getApiUrl = (path) => {
    if (serverUrl) {
      const base = serverUrl.replace(/\/$/, '')
      return `${base}${path}`
    }
    return path
  }

  const fetchStatus = async () => {
    try {
      const res = await fetch(getApiUrl('/api/status'))
      if (res.status === 503) {
        setRetryAfter(300)
      }
      const data = await res.json()
      setServerStatus(data.serverStatus || 'ok')
      setLastStateChange(data.lastStateChange || null)
      setTorrents(data.torrents || [])
      setError(null)
    } catch (err) {
      console.error('Error fetching status:', err)
      if (torrents.length === 0) {
        setError(`Connection Error: ${err.message}`)
      }
    }
  }

  // ‚îÄ‚îÄ‚îÄ Torrent Actions ‚îÄ‚îÄ‚îÄ
  const addMagnet = async (magnetLink) => {
    if (!magnetLink) return
    setLoading(true)
    try {
      await fetch(getApiUrl('/api/add'), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ magnet: magnetLink })
      })
      setMagnet('')
      fetchStatus()
    } catch (err) {
      setError(err.message)
    } finally {
      setLoading(false)
    }
  }

  const addTorrent = (e) => {
    e.preventDefault()
    addMagnet(magnet)
  }

  const deleteTorrent = async (infoHash) => {
    if (!confirm('Remove this torrent?')) return
    try {
      await fetch(getApiUrl(`/api/delete/${infoHash}`), { method: 'DELETE' })
      setSelectedTorrent(null)
      fetchStatus()
    } catch (err) {
      alert('Delete failed')
    }
  }

  const getStreamUrl = (infoHash, fileIndex) => {
    if (serverUrl) {
      return `${serverUrl.replace(/\/$/, '')}/stream/${infoHash}/${fileIndex}`
    }
    return `${window.location.protocol}//${window.location.host}/stream/${infoHash}/${fileIndex}`
  }

  const copyUrl = (infoHash, fileIndex) => {
    const url = getStreamUrl(infoHash, fileIndex)
    navigator.clipboard?.writeText(url)
      .then(() => alert('URL copied!'))
      .catch(() => alert('Failed to copy'))
  }

  // ‚îÄ‚îÄ‚îÄ Playback ‚îÄ‚îÄ‚îÄ
  const handlePlay = async (infoHash, fileIndex, fileName) => {
    const streamUrl = getStreamUrl(infoHash, fileIndex)
    const title = cleanTitle(fileName)
    const pkg = preferredPlayer

    // üé• Save lastPlayed for Continue feature
    const torrent = torrents.find(t => t.infoHash === infoHash)
    if (torrent) {
      const videoFiles = torrent.files?.filter(f => /\.(mp4|mkv|avi|webm|mov)$/i.test(f.name)) || []
      const currentIdx = videoFiles.findIndex(f => f.index === fileIndex)
      const nextFile = videoFiles[currentIdx + 1]
      const playData = {
        infoHash,
        fileIndex,
        fileName,
        torrentName: torrent.name,
        nextFile: nextFile ? { index: nextFile.index, name: nextFile.name } : null,
        timestamp: Date.now()
      }
      localStorage.setItem('lastPlayed', JSON.stringify(playData))
      setLastPlayed(playData)
    }

    console.log(`[Play] URL: ${streamUrl} | Package: ${pkg} | Title: ${title}`)

    if (pkg && Capacitor.isNativePlatform()) {
      try {
        const { installed } = await TVPlayer.isPackageInstalled({ package: pkg })
        if (!installed) {
          const playerName = PLAYERS.find(p => p.id === pkg)?.name || pkg
          alert(`${playerName} –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–π –ø–ª–µ–µ—Ä –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.`)
          return
        }
      } catch (e) {
        console.warn('[Play] isPackageInstalled check failed:', e)
      }
    }

    setBuffering({ name: title, progress: 10 })
    setSelectedTorrent(null)

    try {
      await TVPlayer.play({ url: streamUrl, package: pkg, title: title })
      setBuffering(null)
    } catch (e) {
      console.error(`[Play] Failed with ${pkg}, trying system chooser...`)
      try {
        await TVPlayer.play({ url: streamUrl, package: "", title: title })
        setBuffering(null)
      } catch (err) {
        setBuffering(null)
        alert("Error launching player: " + err.message)
      }
    }
  }

  const handlePlayAll = async (torrent, startIndex = 0) => {
    const videoFiles = torrent.files?.filter(f =>
      /\.(mp4|mkv|avi|webm|mov)$/i.test(f.name)
    ) || []

    if (videoFiles.length <= 1) {
      const file = videoFiles[0] || torrent.files?.[0]
      if (file) handlePlay(torrent.infoHash, file.index, file.name)
      return
    }

    const pkg = preferredPlayer
    const title = cleanTitle(torrent.name)
    const urls = videoFiles.map(f => getStreamUrl(torrent.infoHash, f.index))
    const names = videoFiles.map(f => cleanTitle(f.name) || f.name)

    console.log(`[PlayAll] ${urls.length} files | Package: ${pkg}`)

    if (pkg && Capacitor.isNativePlatform()) {
      try {
        const { installed } = await TVPlayer.isPackageInstalled({ package: pkg })
        if (!installed) {
          const playerName = PLAYERS.find(p => p.id === pkg)?.name || pkg
          alert(`${playerName} –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–π –ø–ª–µ–µ—Ä –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.`)
          return
        }
      } catch (e) {
        console.warn('[PlayAll] isPackageInstalled check failed:', e)
      }
    }

    setBuffering({ name: `${title} (${urls.length} files)`, progress: 10 })
    setSelectedTorrent(null)

    try {
      await TVPlayer.playList({
        package: pkg,
        title: title,
        urls: urls,
        names: names,
        startIndex: startIndex
      })
      setBuffering(null)
    } catch (e) {
      console.error('[PlayAll] Playlist failed, falling back to single play:', e)
      setBuffering(null)
      handlePlay(torrent.infoHash, videoFiles[startIndex]?.index || 0, videoFiles[startIndex]?.name)
    }
  }

  // ‚îÄ‚îÄ‚îÄ Search ‚îÄ‚îÄ‚îÄ
  const searchRuTracker = async () => {
    if (!searchQuery.trim()) return
    setSearchLoading(true)
    setSearchResults([])
    try {
      const res = await fetch(getApiUrl(`/api/rutracker/search?query=${encodeURIComponent(searchQuery)}`))
      const data = await res.json()
      setSearchResults(data.results || [])
    } catch (err) {
      console.error('[Search] Error:', err)
      setError('–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: ' + err.message)
    } finally {
      setSearchLoading(false)
    }
  }

  const addFromSearch = async (magnetOrId, title) => {
    setSearchLoading(true)
    try {
      if (magnetOrId && magnetOrId.startsWith('magnet:')) {
        await addMagnet(magnetOrId)
        setShowSearch(false)
        setSearchResults([])
        setSearchQuery('')
      } else {
        const res = await fetch(getApiUrl(`/api/rutracker/magnet/${encodeURIComponent(magnetOrId)}`))
        const data = await res.json()
        if (data.magnet) {
          await addMagnet(data.magnet)
          setShowSearch(false)
          setSearchResults([])
          setSearchQuery('')
        } else {
          setError('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å magnet-—Å—Å—ã–ª–∫—É')
        }
      }
    } catch (err) {
      setError('–û—à–∏–±–∫–∞: ' + err.message)
    } finally {
      setSearchLoading(false)
    }
  }

  // ‚îÄ‚îÄ‚îÄ Effects ‚îÄ‚îÄ‚îÄ
  useEffect(() => {
    fetchStatus()
    const interval = setInterval(fetchStatus, 5000)

    // Warmup external services
    const warmUpTargets = ['https://apn-latest.onrender.com/ping']
    warmUpTargets.forEach(url => fetch(url, { method: 'HEAD', mode: 'no-cors' }).catch(() => { }))

    return () => clearInterval(interval)
  }, [serverUrl])

  useEffect(() => {
    if (!Capacitor.isNativePlatform()) return
    const handleAppUrlOpen = async (event) => {
      if (event.url?.startsWith('magnet:')) {
        addMagnet(event.url)
      }
    }
    CapacitorApp.addListener('appUrlOpen', handleAppUrlOpen)
    return () => CapacitorApp.removeAllListeners()
  }, [serverUrl])

  useEffect(() => {
    const handleBack = () => {
      if (selectedTorrent) {
        setSelectedTorrent(null)
      } else if (showSettings) {
        setShowSettings(false)
      } else {
        CapacitorApp.exitApp()
      }
    }

    const backListener = CapacitorApp.addListener('backButton', () => {
      console.log('Native Back Button')
      handleBack()
    })

    const keyListener = (e) => {
      // üî• v2.3: Don't intercept backspace when typing in input/textarea
      const isTyping = ['INPUT', 'TEXTAREA'].includes(document.activeElement?.tagName)

      if (e.key === 'Escape' || e.keyCode === 10009) {
        handleBack()
      } else if (e.key === 'Backspace' && !isTyping) {
        // Only trigger back on Backspace if NOT typing
        handleBack()
      }
    }
    window.addEventListener('keydown', keyListener)

    return () => {
      backListener.then(h => h.remove())
      window.removeEventListener('keydown', keyListener)
    }
  }, [selectedTorrent, showSettings])

  // ‚îÄ‚îÄ‚îÄ Render: Critical Error ‚îÄ‚îÄ‚îÄ
  if (serverStatus === 'circuit_open' || serverStatus === 'error') {
    return <ErrorScreen status={serverStatus} retryAfter={retryAfter} onRetry={fetchStatus} />
  }

  // ‚îÄ‚îÄ‚îÄ Render ‚îÄ‚îÄ‚îÄ
  return (
    <div className="min-h-screen bg-[#141414] text-white font-sans selection:bg-red-500 selection:text-white pb-20">

      {/* Navbar */}
      <div className="sticky top-0 z-30 bg-[#141414]/90 backdrop-blur-md px-6 py-4 flex justify-between items-center shadow-lg border-b border-gray-800">
        <h1 className="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-500 to-purple-500">
          PWA-TorServe
        </h1>
        <div className="flex gap-3 items-center">
          <ServerStatusBar status={serverStatus} onDiagnosticsClick={() => setShowDiagnostics(true)} />
          <button onClick={() => setShowAutoDownload(true)} className="p-2 hover:bg-gray-800 rounded-full transition-colors" title="–ê–≤—Ç–æ-–∑–∞–≥—Ä—É–∑–∫–∞">üì∫</button>
          <button onClick={fetchStatus} className="p-2 hover:bg-gray-800 rounded-full transition-colors">üîÑ</button>
          <button onClick={() => setShowSettings(!showSettings)} className="p-2 hover:bg-gray-800 rounded-full transition-colors">‚öôÔ∏è</button>
        </div>
      </div>

      {/* Diagnostics Modal */}
      {showDiagnostics && (
        <DiagnosticsPanel
          serverUrl={getApiUrl('')}
          onClose={() => setShowDiagnostics(false)}
        />
      )}

      {/* Auto-Download Panel */}
      {showAutoDownload && (
        <AutoDownloadPanel
          serverUrl={getApiUrl('')}
          torrents={torrents}
          onClose={() => setShowAutoDownload(false)}
        />
      )}

      {/* Status Banner */}
      {serverStatus === 'degraded' && <DegradedBanner lastStateChange={lastStateChange} />}

      {/* Settings Panel */}
      {showSettings && (
        <SettingsPanel
          preferredPlayer={preferredPlayer}
          onPlayerChange={savePreferredPlayer}
          serverUrl={serverUrl}
          onServerUrlChange={handleServerUrlChange}
          tmdbProxyUrl={tmdbProxyUrl}
          onTmdbProxyUrlChange={handleTmdbProxyUrlChange}
          torrents={torrents}
        />
      )}

      {/* Content Grid */}
      <div className="px-6 py-4">

        {/* Continue Watching Banner */}
        {lastPlayed?.nextFile && torrents.find(t => t.infoHash === lastPlayed.infoHash) && (
          <div className="mb-6 bg-gradient-to-r from-purple-900/50 to-blue-900/50 border border-purple-500/30 rounded-xl p-4">
            <div className="flex items-center justify-between">
              <div className="flex-1 min-w-0">
                <div className="text-xs text-purple-300 uppercase tracking-wide mb-1">‚ñ∂ Continue Watching</div>
                <div className="text-white font-bold truncate">{cleanTitle(lastPlayed.torrentName)}</div>
                <div className="text-gray-400 text-sm truncate">Next: {cleanTitle(lastPlayed.nextFile.name)}</div>
              </div>
              <button
                onClick={() => handlePlay(
                  lastPlayed.infoHash,
                  lastPlayed.nextFile.index,
                  lastPlayed.nextFile.name
                )}
                className="ml-4 bg-purple-600 hover:bg-purple-500 px-5 py-3 rounded-lg font-bold text-white flex items-center gap-2 transition-colors"
              >
                ‚ñ∂ Play Next
              </button>
            </div>
          </div>
        )}

        {/* Header */}
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold text-gray-200">My List</h2>
          <div className="flex gap-2">
            <button
              onClick={() => setShowSearch(!showSearch)}
              className="bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded-full text-sm font-bold transition-transform hover:scale-105"
            >
              üîç –ü–æ–∏—Å–∫
            </button>
            {!showServerInput && (
              <button
                onClick={() => setShowServerInput(true)}
                className="bg-gray-800 hover:bg-gray-700 px-4 py-2 rounded-full text-sm font-bold border border-gray-600 transition-transform hover:scale-105"
              >
                + Magnet
              </button>
            )}
          </div>
        </div>

        {/* Search Panel */}
        {showSearch && (
          <SearchPanel
            searchQuery={searchQuery}
            onSearchQueryChange={setSearchQuery}
            onSearch={searchRuTracker}
            onClose={() => { setShowSearch(false); setSearchResults([]) }}
            onAddTorrent={addFromSearch}
            searchResults={searchResults}
            searchLoading={searchLoading}
          />
        )}

        {/* Magnet Input */}
        {showServerInput && (
          <form onSubmit={addTorrent} className="mb-6">
            <div className="flex gap-2">
              <input
                value={magnet}
                onChange={(e) => setMagnet(e.target.value)}
                placeholder="–í—Å—Ç–∞–≤—å—Ç–µ Magnet-—Å—Å—ã–ª–∫—É..."
                className="flex-1 bg-gray-800 border border-gray-700 rounded-lg px-4 py-3 focus:ring-2 focus:ring-blue-500 outline-none"
              />
              <button
                type="submit"
                disabled={loading || !magnet}
                className="bg-blue-600 px-6 py-3 rounded-lg font-bold hover:bg-blue-700 disabled:opacity-50"
              >
                {loading ? '...' : 'Add'}
              </button>
              <button
                type="button"
                onClick={() => setShowServerInput(false)}
                className="bg-gray-800 px-4 rounded-lg"
              >
                ‚úï
              </button>
            </div>
          </form>
        )}

        {/* Error */}
        {error && (
          <div className="bg-red-900/30 border border-red-700 text-red-400 px-4 py-3 rounded-lg mb-4">
            {error}
          </div>
        )}

        {/* Category Tabs */}
        <div className="flex gap-2 mb-4 overflow-x-auto pb-3 pt-1 px-1 -mx-1">
          {CATEGORIES.map(cat => (
            <button
              key={cat.id}
              onClick={() => setCategoryFilter(cat.id)}
              className={`
                px-4 py-2 rounded-full text-sm font-medium whitespace-nowrap transition-all
                focus:ring-2 focus:ring-blue-400 focus:ring-offset-2 focus:ring-offset-[#141414] focus:outline-none
                ${categoryFilter === cat.id
                  ? 'bg-blue-600 text-white'
                  : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}
              `}
            >
              {cat.icon} {cat.name}
            </button>
          ))}
        </div>

        {/* Sort Buttons */}
        <div className="flex gap-2 mb-6 text-xs px-1 -mx-1">
          <span className="text-gray-500 self-center">–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞:</span>
          {[{ id: 'name', label: '–ò–º—è' }, { id: 'size', label: '–†–∞–∑–º–µ—Ä' }, { id: 'peers', label: '–ü–∏—Ä—ã' }].map(s => (
            <button
              key={s.id}
              onClick={() => saveSortBy(s.id)}
              className={`
                px-3 py-1 rounded transition-all
                focus:ring-2 focus:ring-blue-400 focus:outline-none
                ${sortBy === s.id
                  ? 'bg-gray-700 text-white'
                  : 'bg-gray-800/50 text-gray-500 hover:text-white'}
              `}
            >
              {s.label}
            </button>
          ))}
        </div>

        {/* Torrent Grid */}
        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">
          {displayTorrents.map(t => (
            <Poster
              key={t.infoHash}
              name={t.name}
              progress={t.progress || 0}
              peers={t.numPeers || 0}
              isReady={t.isReady}
              size={t.files?.reduce((sum, f) => sum + (f.length || 0), 0) || 0}
              downloadSpeed={t.downloadSpeed || 0}
              downloaded={t.downloaded || 0}
              eta={t.eta || 0}
              newFilesCount={t.newFilesCount || 0}
              onClick={() => setSelectedTorrent(t)}
            />
          ))}

          {/* Empty State */}
          {displayTorrents.length === 0 && !loading && (
            <div className="col-span-full py-20 text-center text-gray-600">
              <div className="text-6xl mb-4">{categoryFilter === 'all' ? 'üçø' : CATEGORIES.find(c => c.id === categoryFilter)?.icon}</div>
              <p className="text-lg">{categoryFilter === 'all' ? 'Your list is empty.' : '–ù–µ—Ç —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤ –≤ —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏'}</p>
            </div>
          )}
        </div>
      </div>

      {/* Torrent Modal */}
      {selectedTorrent && (
        <TorrentModal
          torrent={selectedTorrent}
          onClose={() => setSelectedTorrent(null)}
          onPlay={handlePlay}
          onPlayAll={handlePlayAll}
          onCopyUrl={copyUrl}
          onDelete={deleteTorrent}
        />
      )}

      {/* Buffering Overlay */}
      {buffering && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur-sm">
          <div className="text-center">
            <div className="text-6xl mb-4 animate-pulse">‚è≥</div>
            <h2 className="text-xl font-bold text-white mb-2">–ë—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è...</h2>
            <p className="text-gray-400">{buffering.name}</p>
            <div className="mt-4 w-48 h-2 bg-gray-700 rounded-full overflow-hidden mx-auto">
              <div
                className="h-full bg-blue-500 transition-all duration-300"
                style={{ width: `${buffering.progress || 10}%` }}
              />
            </div>
            <button
              onClick={() => setBuffering(null)}
              className="mt-6 text-gray-500 hover:text-white"
            >
              –û—Ç–º–µ–Ω–∞
            </button>
          </div>
        </div>
      )}
    </div>
  )
}

export default App

```

---

### client/src/components/AutoDownloadPanel.jsx

```javascript
/**
 * Auto-Download Panel v3
 * UI for managing auto-download rules (series tracking)
 * 
 * Features:
 * - Pick from loaded torrents
 * - TV remote (D-pad) full navigation support
 * - Focus trap to prevent background scrolling
 * - Proper tabIndex on all interactive elements
 */

import { useState, useEffect, useRef } from 'react'

// TV Remote focusable button component with tabIndex
function FocusableButton({ onClick, disabled, className, children, autoFocus, tabIndex = 0 }) {
    return (
        <button
            onClick={onClick}
            disabled={disabled}
            autoFocus={autoFocus}
            tabIndex={disabled ? -1 : tabIndex}
            className={`
                focus:ring-4 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900
                focus:outline-none focus:scale-105 transition-all
                ${className}
            `}
        >
            {children}
        </button>
    )
}

export default function AutoDownloadPanel({ serverUrl, torrents = [], onClose }) {
    const [settings, setSettings] = useState({ enabled: false, intervalMinutes: 720 })
    const [rules, setRules] = useState([])
    const [loading, setLoading] = useState(false)
    const [checking, setChecking] = useState(false)
    const [lastResult, setLastResult] = useState(null)
    const [showPicker, setShowPicker] = useState(false)

    // Form state for new rule
    const [newRule, setNewRule] = useState({
        query: '',
        resolution: '2160',
        group: '',
        lastEpisode: 0
    })

    // Refs for focus management
    const panelRef = useRef(null)
    const firstFocusableRef = useRef(null)

    const getApiUrl = (path) => serverUrl ? `${serverUrl}${path}` : path

    // Extract series from loaded torrents
    const getSeriesFromTorrents = () => {
        return torrents
            .filter(t => {
                const videos = t.files?.filter(f => /\.(mp4|mkv|avi|webm|mov)$/i.test(f.name)) || []
                return videos.length > 1
            })
            .map(t => {
                const videos = t.files?.filter(f => /\.(mp4|mkv|avi|webm|mov)$/i.test(f.name)) || []
                let maxEpisode = 0

                videos.forEach(f => {
                    const match = f.name.match(/[ES](\d{1,3})|[-‚Äì]\s*(\d{1,3})(?:\s|$|\[|\()/i)
                    if (match) {
                        const ep = parseInt(match[1] || match[2], 10)
                        if (ep > maxEpisode) maxEpisode = ep
                    }
                })

                const resMatch = t.name.match(/\b(2160p?|1080p?|720p?)\b/i)
                const resolution = resMatch ? resMatch[1].replace('p', '') : ''

                return {
                    name: t.name,
                    episodeCount: videos.length,
                    lastEpisode: maxEpisode,
                    resolution
                }
            })
    }

    const seriesList = getSeriesFromTorrents()

    // Prevent background scrolling when panel is open
    useEffect(() => {
        // Lock body scroll
        const originalStyle = window.getComputedStyle(document.body).overflow
        document.body.style.overflow = 'hidden'
        document.documentElement.style.overflow = 'hidden'

        return () => {
            document.body.style.overflow = originalStyle
            document.documentElement.style.overflow = ''
        }
    }, [])

    // D-pad / Arrow key navigation handler
    useEffect(() => {
        const getFocusableElements = () => {
            return Array.from(panelRef.current?.querySelectorAll(
                'button:not([disabled]), input:not([disabled]), select:not([disabled]), [tabindex="0"]'
            ) || [])
        }

        const handleKeyDown = (e) => {
            const key = e.key
            const keyCode = e.keyCode

            // ESC or Back button to close
            if (key === 'Escape' || key === 'Backspace' || keyCode === 10009) {
                e.preventDefault()
                e.stopPropagation()
                if (showPicker) {
                    setShowPicker(false)
                } else {
                    onClose()
                }
                return
            }

            // Arrow keys / D-pad navigation
            if (key === 'ArrowUp' || key === 'ArrowDown' || keyCode === 38 || keyCode === 40) {
                e.preventDefault()
                e.stopPropagation()

                const focusable = getFocusableElements()
                if (!focusable.length) return

                const currentIndex = focusable.indexOf(document.activeElement)
                let nextIndex

                if (key === 'ArrowDown' || keyCode === 40) {
                    nextIndex = currentIndex < focusable.length - 1 ? currentIndex + 1 : 0
                } else {
                    nextIndex = currentIndex > 0 ? currentIndex - 1 : focusable.length - 1
                }

                focusable[nextIndex]?.focus()
                focusable[nextIndex]?.scrollIntoView({ block: 'nearest', behavior: 'smooth' })
                return
            }

            // Left/Right for horizontal navigation
            if (key === 'ArrowLeft' || key === 'ArrowRight' || keyCode === 37 || keyCode === 39) {
                // Allow default behavior for inputs
                if (document.activeElement?.tagName === 'INPUT') {
                    return
                }
                e.preventDefault()
                e.stopPropagation()
            }

            // Tab key - focus trap
            if (key === 'Tab') {
                e.preventDefault()
                e.stopPropagation()

                const focusable = getFocusableElements()
                if (!focusable.length) return

                const currentIndex = focusable.indexOf(document.activeElement)
                let nextIndex

                if (e.shiftKey) {
                    nextIndex = currentIndex > 0 ? currentIndex - 1 : focusable.length - 1
                } else {
                    nextIndex = currentIndex < focusable.length - 1 ? currentIndex + 1 : 0
                }

                focusable[nextIndex]?.focus()
            }
        }

        // Block ALL scroll events from reaching background
        const blockScroll = (e) => {
            e.preventDefault()
            e.stopPropagation()
        }

        // Capture phase to intercept before anything else
        window.addEventListener('keydown', handleKeyDown, true)
        document.addEventListener('scroll', blockScroll, true)

        // Focus first element
        setTimeout(() => {
            firstFocusableRef.current?.focus()
        }, 50)

        return () => {
            window.removeEventListener('keydown', handleKeyDown, true)
            document.removeEventListener('scroll', blockScroll, true)
        }
    }, [showPicker, onClose])

    // Fetch rules and settings
    const fetchRules = async () => {
        setLoading(true)
        try {
            const res = await fetch(getApiUrl('/api/autodownload/rules'))
            const data = await res.json()
            setSettings(data.settings || { enabled: false, intervalMinutes: 720 })
            setRules(data.rules || [])
        } catch (err) {
            console.error('[AutoDownload] Fetch error:', err)
        } finally {
            setLoading(false)
        }
    }

    useEffect(() => {
        fetchRules()
    }, [serverUrl])

    // Toggle global enable/disable
    const toggleEnabled = async () => {
        try {
            const res = await fetch(getApiUrl('/api/autodownload/settings'), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: !settings.enabled })
            })
            const data = await res.json()
            setSettings(data)
        } catch (err) {
            console.error('[AutoDownload] Toggle error:', err)
        }
    }

    // Update interval
    const updateInterval = async (minutes) => {
        try {
            const res = await fetch(getApiUrl('/api/autodownload/settings'), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ intervalMinutes: parseInt(minutes, 10) })
            })
            const data = await res.json()
            setSettings(data)
        } catch (err) {
            console.error('[AutoDownload] Interval error:', err)
        }
    }

    // Add new rule
    const addRule = async () => {
        if (!newRule.query.trim()) return
        try {
            const res = await fetch(getApiUrl('/api/autodownload/rules'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(newRule)
            })
            await res.json()
            setNewRule({ query: '', resolution: '2160', group: '', lastEpisode: 0 })
            fetchRules()
        } catch (err) {
            console.error('[AutoDownload] Add rule error:', err)
        }
    }

    // Add rule from torrent picker
    const addFromTorrent = (series) => {
        setNewRule({
            query: series.name.replace(/\./g, ' ').split(/[-\[\(]/)[0].trim(),
            resolution: series.resolution || '2160',
            group: '',
            lastEpisode: series.lastEpisode
        })
        setShowPicker(false)
    }

    // Delete rule
    const deleteRule = async (id) => {
        if (!confirm('–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ –ø—Ä–∞–≤–∏–ª–æ?')) return
        try {
            await fetch(getApiUrl(`/api/autodownload/rules/${id}`), { method: 'DELETE' })
            fetchRules()
        } catch (err) {
            console.error('[AutoDownload] Delete error:', err)
        }
    }

    // Toggle rule enabled
    const toggleRule = async (rule) => {
        try {
            await fetch(getApiUrl(`/api/autodownload/rules/${rule.id}`), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: !rule.enabled })
            })
            fetchRules()
        } catch (err) {
            console.error('[AutoDownload] Toggle rule error:', err)
        }
    }

    // Manual check
    const runCheck = async () => {
        setChecking(true)
        setLastResult(null)
        try {
            const res = await fetch(getApiUrl('/api/autodownload/check'), { method: 'POST' })
            const data = await res.json()
            setLastResult(data)
            fetchRules()
        } catch (err) {
            console.error('[AutoDownload] Check error:', err)
            setLastResult({ error: err.message })
        } finally {
            setChecking(false)
        }
    }

    return (
        <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4"
            onClick={(e) => e.target === e.currentTarget && onClose()}
        >
            <div
                ref={panelRef}
                className="bg-gray-900 rounded-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col"
                onClick={(e) => e.stopPropagation()}
            >
                {/* Header */}
                <div className="flex justify-between items-center p-4 border-b border-gray-800">
                    <h2 className="text-xl font-bold text-white flex items-center gap-2">
                        üì∫ –ê–≤—Ç–æ-–∑–∞–≥—Ä—É–∑–∫–∞ —Å–µ—Ä–∏–∞–ª–æ–≤
                    </h2>
                    <FocusableButton
                        onClick={onClose}
                        className="text-gray-400 hover:text-white text-2xl p-2 rounded-lg"
                        tabIndex={0}
                    >
                        ‚úï
                    </FocusableButton>
                </div>

                {/* Content - scrollable */}
                <div className="flex-1 overflow-y-auto p-4 space-y-4">
                    {/* Global Settings */}
                    <div className="bg-gray-800/50 rounded-xl p-4">
                        <div className="flex items-center justify-between mb-3">
                            <div>
                                <div className="font-bold text-white">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞</div>
                                <div className="text-sm text-gray-400">
                                    –ü–æ–∏—Å–∫ –Ω–æ–≤—ã—Ö —Å–µ—Ä–∏–π –∫–∞–∂–¥—ã–µ {settings.intervalMinutes >= 60
                                        ? `${Math.round(settings.intervalMinutes / 60)} —á`
                                        : `${settings.intervalMinutes} –º–∏–Ω`}
                                </div>
                            </div>
                            <FocusableButton
                                ref={firstFocusableRef}
                                onClick={toggleEnabled}
                                className={`w-14 h-8 rounded-full transition-colors relative ${settings.enabled ? 'bg-green-600' : 'bg-gray-600'
                                    }`}
                                tabIndex={0}
                            >
                                <div className={`absolute w-6 h-6 bg-white rounded-full top-1 transition-all ${settings.enabled ? 'left-7' : 'left-1'
                                    }`} />
                            </FocusableButton>
                        </div>

                        {/* Interval Selector */}
                        <div className="flex items-center gap-2 text-sm flex-wrap">
                            <span className="text-gray-400">–ò–Ω—Ç–µ—Ä–≤–∞–ª:</span>
                            {[
                                { value: 360, label: '6 —á' },
                                { value: 720, label: '12 —á' },
                                { value: 1440, label: '24 —á' }
                            ].map(opt => (
                                <FocusableButton
                                    key={opt.value}
                                    onClick={() => updateInterval(opt.value)}
                                    className={`px-3 py-1 rounded ${settings.intervalMinutes === opt.value
                                        ? 'bg-blue-600 text-white'
                                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                        }`}
                                    tabIndex={0}
                                >
                                    {opt.label}
                                </FocusableButton>
                            ))}
                        </div>
                    </div>

                    {/* Manual Check Button */}
                    <FocusableButton
                        onClick={runCheck}
                        disabled={checking}
                        className="w-full bg-purple-600 hover:bg-purple-500 disabled:opacity-50 text-white font-bold py-3 rounded-xl flex items-center justify-center gap-2"
                        tabIndex={0}
                    >
                        {checking ? (
                            <>
                                <span className="animate-spin">‚è≥</span>
                                –ü—Ä–æ–≤–µ—Ä—è–µ–º...
                            </>
                        ) : (
                            <>üîç –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–µ–π—á–∞—Å</>
                        )}
                    </FocusableButton>

                    {/* Last Result */}
                    {lastResult && (
                        <div className={`rounded-xl p-3 text-sm ${lastResult.downloaded > 0
                            ? 'bg-green-900/50 text-green-300'
                            : lastResult.error
                                ? 'bg-red-900/50 text-red-300'
                                : 'bg-gray-800 text-gray-400'
                            }`}>
                            {lastResult.error
                                ? `‚ùå –û—à–∏–±–∫–∞: ${lastResult.error}`
                                : lastResult.downloaded > 0
                                    ? `‚úÖ –ù–∞–π–¥–µ–Ω–æ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–æ: ${lastResult.downloaded} —Å–µ—Ä–∏–π`
                                    : '‚úì –ù–æ–≤—ã—Ö —Å–µ—Ä–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ'
                            }
                        </div>
                    )}

                    {/* Add New Rule */}
                    <div className="bg-gray-800/50 rounded-xl p-4">
                        <div className="flex items-center justify-between mb-3">
                            <h3 className="font-bold text-white">‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–µ—Ä–∏–∞–ª</h3>
                            {seriesList.length > 0 && (
                                <FocusableButton
                                    onClick={() => setShowPicker(!showPicker)}
                                    className="bg-purple-600/30 hover:bg-purple-600/50 text-purple-300 px-3 py-1 rounded-lg text-sm"
                                    tabIndex={0}
                                >
                                    üìã –í—ã–±—Ä–∞—Ç—å ({seriesList.length})
                                </FocusableButton>
                            )}
                        </div>

                        {/* Picker Modal */}
                        {showPicker && (
                            <div className="mb-4 bg-gray-700/50 rounded-xl p-3 max-h-48 overflow-y-auto space-y-2">
                                <div className="text-sm text-gray-400 mb-2">–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–∏–∞–ª:</div>
                                {seriesList.map((series, idx) => (
                                    <FocusableButton
                                        key={idx}
                                        onClick={() => addFromTorrent(series)}
                                        className="w-full text-left bg-gray-800 hover:bg-gray-700 rounded-lg p-3"
                                        tabIndex={0}
                                        autoFocus={idx === 0}
                                    >
                                        <div className="font-medium text-white truncate">{series.name}</div>
                                        <div className="text-xs text-gray-400">
                                            {series.episodeCount} —Å–µ—Ä–∏–π ‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω—è—è: {series.lastEpisode}
                                            {series.resolution && ` ‚Ä¢ ${series.resolution}p`}
                                        </div>
                                    </FocusableButton>
                                ))}
                            </div>
                        )}

                        <div className="grid grid-cols-2 gap-3">
                            <input
                                value={newRule.query}
                                onChange={(e) => setNewRule({ ...newRule, query: e.target.value })}
                                placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ —Å–µ—Ä–∏–∞–ª–∞..."
                                tabIndex={0}
                                className="col-span-2 bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white placeholder-gray-500 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 outline-none"
                            />
                            <select
                                value={newRule.resolution}
                                onChange={(e) => setNewRule({ ...newRule, resolution: e.target.value })}
                                tabIndex={0}
                                className="bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:border-blue-500 focus:ring-2 focus:ring-blue-500 outline-none"
                            >
                                <option value="">–õ—é–±–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ</option>
                                <option value="2160">4K (2160p)</option>
                                <option value="1080">1080p</option>
                                <option value="720">720p</option>
                            </select>
                            <input
                                type="number"
                                min="0"
                                value={newRule.lastEpisode}
                                onChange={(e) => setNewRule({ ...newRule, lastEpisode: parseInt(e.target.value, 10) || 0 })}
                                placeholder="–ü–æ—Å–ª–µ–¥–Ω—è—è —Å–µ—Ä–∏—è"
                                tabIndex={0}
                                className="bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:border-blue-500 focus:ring-2 focus:ring-blue-500 outline-none"
                            />
                        </div>
                        <FocusableButton
                            onClick={addRule}
                            disabled={!newRule.query.trim()}
                            className="mt-3 w-full bg-blue-600 hover:bg-blue-500 disabled:opacity-50 text-white font-bold py-2 rounded-lg"
                            tabIndex={0}
                        >
                            –î–æ–±–∞–≤–∏—Ç—å
                        </FocusableButton>
                    </div>

                    {/* Rules List */}
                    <div className="space-y-2">
                        <h3 className="font-bold text-white">üìã –ú–æ–∏ —Å–µ—Ä–∏–∞–ª—ã ({rules.length})</h3>
                        {loading ? (
                            <div className="text-center text-gray-500 py-8">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
                        ) : rules.length === 0 ? (
                            <div className="text-center text-gray-500 py-8">
                                –î–æ–±–∞–≤—å—Ç–µ —Å–µ—Ä–∏–∞–ª –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
                            </div>
                        ) : (
                            rules.map((rule) => (
                                <div
                                    key={rule.id}
                                    className={`bg-gray-800 rounded-xl p-3 flex items-center gap-3 ${!rule.enabled ? 'opacity-50' : ''
                                        }`}
                                >
                                    <FocusableButton
                                        onClick={() => toggleRule(rule)}
                                        className={`w-10 h-10 rounded-full flex items-center justify-center text-lg ${rule.enabled ? 'bg-green-600' : 'bg-gray-600'
                                            }`}
                                        tabIndex={0}
                                    >
                                        {rule.enabled ? '‚úì' : '‚óã'}
                                    </FocusableButton>
                                    <div className="flex-1 min-w-0">
                                        <div className="font-medium text-white truncate">{rule.query}</div>
                                        <div className="text-xs text-gray-400">
                                            {rule.resolution && `${rule.resolution}p ‚Ä¢ `}
                                            –°–µ—Ä–∏—è: {rule.lastEpisode}
                                        </div>
                                    </div>
                                    <FocusableButton
                                        onClick={() => deleteRule(rule.id)}
                                        className="text-red-500 hover:text-red-400 p-2 text-xl"
                                        tabIndex={0}
                                    >
                                        üóëÔ∏è
                                    </FocusableButton>
                                </div>
                            ))
                        )}
                    </div>
                </div>
            </div>
        </div>
    )
}

```

---

### client/src/components/DiagnosticsPanel.jsx

```javascript
/**
 * DiagnosticsPanel Component - Debug information display
 * Shows RAM, lag events, active engines, frozen torrents, watchdog status
 */
import { useState, useEffect } from 'react'

const DiagnosticsPanel = ({ serverUrl, onClose }) => {
    const [data, setData] = useState(null)
    const [loading, setLoading] = useState(true)
    const [error, setError] = useState(null)

    const fetchDiagnostics = async () => {
        setLoading(true)
        setError(null)

        try {
            // Fetch both status and lag-stats
            const [statusRes, lagRes] = await Promise.all([
                fetch(`${serverUrl}/api/status`),
                fetch(`${serverUrl}/api/lag-stats`)
            ])

            if (!statusRes.ok) throw new Error(`Status API: ${statusRes.status}`)
            if (!lagRes.ok) throw new Error(`Lag API: ${lagRes.status}`)

            const statusData = await statusRes.json()
            const lagData = await lagRes.json()

            setData({
                serverStatus: statusData.serverStatus,
                torrentsCount: statusData.torrents?.length || 0,
                lagStats: lagData,
                ram: lagData.recentLags?.[0]?.memory || 'N/A'
            })
        } catch (e) {
            setError(e.message)
        } finally {
            setLoading(false)
        }
    }

    useEffect(() => {
        fetchDiagnostics()
        const interval = setInterval(fetchDiagnostics, 5000) // Refresh every 5s
        return () => clearInterval(interval)
    }, [serverUrl])

    return (
        <div
            className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur-sm animate-fade-in"
            onClick={onClose}
        >
            <div
                className="bg-[#181818] rounded-2xl w-full max-w-md overflow-hidden shadow-2xl"
                onClick={e => e.stopPropagation()}
            >
                {/* Header */}
                <div className="bg-gradient-to-r from-purple-900 to-gray-900 p-4 flex items-center justify-between">
                    <h2 className="text-xl font-bold flex items-center gap-2">
                        üîß Diagnostics
                    </h2>
                    <button
                        onClick={onClose}
                        className="bg-black/40 rounded-full p-2 text-white hover:bg-black/60"
                    >
                        ‚úï
                    </button>
                </div>

                <div className="p-6 space-y-4">
                    {loading && !data && (
                        <div className="text-center text-gray-400 py-8">
                            <span className="animate-pulse">Loading...</span>
                        </div>
                    )}

                    {error && (
                        <div className="bg-red-900/30 border border-red-700 rounded-lg p-4 text-red-300 text-sm">
                            ‚ùå Error: {error}
                        </div>
                    )}

                    {data && (
                        <>
                            {/* Server Status */}
                            <div className="grid grid-cols-2 gap-4">
                                <div className="bg-gray-800 rounded-lg p-4">
                                    <div className="text-gray-400 text-xs uppercase mb-1">Status</div>
                                    <div className="text-xl font-bold">
                                        {data.serverStatus === 'ok' && 'üü¢ OK'}
                                        {data.serverStatus === 'degraded' && 'üü° Degraded'}
                                        {data.serverStatus === 'circuit_open' && 'üî¥ Circuit Open'}
                                        {data.serverStatus === 'error' && 'üî¥ Error'}
                                    </div>
                                </div>
                                <div className="bg-gray-800 rounded-lg p-4">
                                    <div className="text-gray-400 text-xs uppercase mb-1">Torrents</div>
                                    <div className="text-xl font-bold">{data.torrentsCount}</div>
                                </div>
                            </div>

                            {/* Lag Stats */}
                            <div className="bg-gray-800 rounded-lg p-4">
                                <div className="text-gray-400 text-xs uppercase mb-3">Event Loop Lag (last 60s)</div>
                                <div className="grid grid-cols-3 gap-3 text-center">
                                    <div>
                                        <div className="text-2xl font-bold text-blue-400">{data.lagStats.recentLags || 0}</div>
                                        <div className="text-xs text-gray-500">Spikes</div>
                                    </div>
                                    <div>
                                        <div className="text-2xl font-bold text-yellow-400">{data.lagStats.avgLag || 0}ms</div>
                                        <div className="text-xs text-gray-500">Avg Lag</div>
                                    </div>
                                    <div>
                                        <div className="text-2xl font-bold text-red-400">{data.lagStats.maxLag || 0}ms</div>
                                        <div className="text-xs text-gray-500">Max Lag</div>
                                    </div>
                                </div>
                            </div>

                            {/* Total Lags */}
                            <div className="bg-gray-800 rounded-lg p-4 flex justify-between items-center">
                                <span className="text-gray-400 text-sm">Total Lag Events</span>
                                <span className="font-mono text-lg">{data.lagStats.totalLags || 0}</span>
                            </div>

                            {/* üî• v2.3: Enhanced Server Diagnostics */}
                            {data.lagStats.server && (
                                <div className="bg-gray-800 rounded-lg p-4">
                                    <div className="text-gray-400 text-xs uppercase mb-3">Server Info</div>
                                    <div className="grid grid-cols-2 gap-3 text-sm">
                                        <div className="flex justify-between">
                                            <span className="text-gray-500">Uptime:</span>
                                            <span className="text-white font-mono">
                                                {Math.floor(data.lagStats.server.uptime / 60)}m
                                            </span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span className="text-gray-500">RAM:</span>
                                            <span className="text-white font-mono">
                                                {data.lagStats.server.ram?.rss || 0}MB
                                            </span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span className="text-gray-500">Active:</span>
                                            <span className="text-green-400 font-mono">
                                                {data.lagStats.server.torrents?.active || 0}
                                            </span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span className="text-gray-500">Frozen:</span>
                                            <span className="text-blue-400 font-mono">
                                                {data.lagStats.server.torrents?.frozen || 0}
                                            </span>
                                        </div>
                                        <div className="flex justify-between col-span-2">
                                            <span className="text-gray-500">Heap:</span>
                                            <span className="text-white font-mono">
                                                {data.lagStats.server.ram?.heapUsed || 0}/{data.lagStats.server.ram?.heapTotal || 0}MB
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {/* Refresh button */}
                            <button
                                onClick={fetchDiagnostics}
                                className="w-full bg-gray-700 hover:bg-gray-600 text-white py-3 rounded-lg font-medium transition-colors"
                            >
                                üîÑ Refresh
                            </button>
                        </>
                    )}
                </div>
            </div>
        </div>
    )
}

export default DiagnosticsPanel

```

---

### client/src/components/Poster.jsx

```javascript
/**
 * Poster Component - Torrent card with dynamic poster loading
 */
import { useState, useEffect } from 'react'
import { CapacitorHttp } from '@capacitor/core'
import { Capacitor } from '@capacitor/core'
import { cleanTitle, formatSize, formatSpeed, formatEta, getGradient } from '../utils/helpers'

const Poster = ({ name, onClick, progress, peers, isReady, size, downloadSpeed, downloaded, eta, newFilesCount }) => {
    const [bgImage, setBgImage] = useState(null)
    const cleanedName = cleanTitle(name)

    useEffect(() => {
        if (!cleanedName) return

        const cacheKey = `poster_v3_${cleanedName}` // Bump cache version
        const cached = localStorage.getItem(cacheKey)
        if (cached) {
            setBgImage(cached)
            return
        }

        const fetchPoster = async () => {
            try {
                let result = null
                const query = encodeURIComponent(cleanedName)
                const TMDB_API_KEY = import.meta.env.VITE_TMDB_API_KEY
                const KP_API_KEY = import.meta.env.VITE_KP_API_KEY
                const CUSTOM_PROXY = import.meta.env.VITE_TMDB_PROXY_URL

                // 1Ô∏è‚É£ Custom Cloudflare Worker (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–π, –≤–∞—à –ª–∏—á–Ω—ã–π –ø—Ä–æ–∫—Å–∏)
                if (!result && CUSTOM_PROXY) {
                    try {
                        // Worker format: /search/multi?api_key=...&query=... (Worker adds /3 prefix)
                        const proxyUrl = `${CUSTOM_PROXY}/search/multi?api_key=${TMDB_API_KEY}&query=${query}&language=ru-RU`
                        console.log('[Poster] Custom Proxy:', cleanedName)

                        const res = await fetch(proxyUrl)
                        if (res.ok) {
                            const data = await res.json()
                            result = data.results?.find(r => r.poster_path)
                        }
                    } catch (customErr) {
                        console.warn('[Poster] Custom proxy failed:', customErr)
                    }
                }

                // 2Ô∏è‚É£ Lampa Proxy (apn-latest.onrender.com) ‚Äî fallback
                if (!result) {
                    try {
                        // Lampa proxy expects: https://proxy/https://api.themoviedb.org/...
                        const targetUrl = `https://api.themoviedb.org/3/search/multi?api_key=${TMDB_API_KEY}&query=${query}&language=ru-RU`
                        const lampaUrl = `https://apn-latest.onrender.com/${targetUrl}`
                        console.log('[Poster] Lampa Proxy:', cleanedName)

                        const res = await fetch(lampaUrl)
                        if (res.ok) {
                            const data = await res.json()
                            result = data.results?.find(r => r.poster_path)
                        }
                    } catch (lampaErr) {
                        console.warn('[Poster] Lampa proxy failed:', lampaErr)
                    }
                }

                // 3Ô∏è‚É£ Fallback: CapacitorHttp (Android, —Ç—Ä–µ–±—É–µ—Ç VPN/DNS)
                if (!result && Capacitor.isNativePlatform()) {
                    try {
                        const searchUrl = `https://api.themoviedb.org/3/search/multi?api_key=${TMDB_API_KEY}&query=${query}&language=ru-RU`
                        console.log('[Poster] Native Search:', cleanedName)
                        const response = await CapacitorHttp.get({ url: searchUrl })
                        if (response.data && response.data.results) {
                            result = response.data.results.find(r => r.poster_path)
                        }
                    } catch (nativeErr) {
                        console.warn('[Poster] Native request failed:', nativeErr)
                    }
                }

                // 4Ô∏è‚É£ Fallback: corsproxy.io (–±—Ä–∞—É–∑–µ—Ä)
                if (!result) {
                    try {
                        const searchUrl = `https://api.themoviedb.org/3/search/multi?api_key=${TMDB_API_KEY}&query=${query}&language=ru-RU`
                        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(searchUrl)}`
                        console.log('[Poster] CorsProxy:', cleanedName)
                        const res = await fetch(proxyUrl)
                        if (res.ok) {
                            const data = await res.json()
                            result = data.results?.find(r => r.poster_path)
                        }
                    } catch (proxyErr) {
                        console.warn('[Poster] CorsProxy failed:', proxyErr)
                    }
                }

                // 5Ô∏è‚É£ Fallback: –ö–∏–Ω–æ–ø–æ–∏—Å–∫ API (–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ TMDB)
                let kpPoster = null
                if (!result && KP_API_KEY) {
                    try {
                        const kpProxy = 'https://cors.kp556.workers.dev:8443/'
                        const kpUrl = `${kpProxy}https://kinopoiskapiunofficial.tech/api/v2.1/films/search-by-keyword?keyword=${query}`
                        console.log('[Poster] Kinopoisk:', cleanedName)

                        const res = await fetch(kpUrl, {
                            headers: { 'X-API-KEY': KP_API_KEY }
                        })
                        if (res.ok) {
                            const data = await res.json()
                            const kpFilm = data.films?.find(f => f.posterUrlPreview)
                            if (kpFilm) {
                                kpPoster = kpFilm.posterUrlPreview
                                console.log('[Poster] Kinopoisk Found:', cleanedName, kpFilm.nameRu || kpFilm.nameEn)
                            }
                        }
                    } catch (kpErr) {
                        console.warn('[Poster] Kinopoisk failed:', kpErr)
                    }
                }

                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ—Å—Ç–µ—Ä (TMDB —á–µ—Ä–µ–∑ wsrv.nl –∏–ª–∏ –ö–∏–Ω–æ–ø–æ–∏—Å–∫ –Ω–∞–ø—Ä—è–º—É—é)
                if (result) {
                    const directUrl = `https://wsrv.nl/?url=ssl:image.tmdb.org/t/p/w500${result.poster_path}&output=webp`
                    localStorage.setItem(cacheKey, directUrl)
                    setBgImage(directUrl)
                    console.log('[Poster] Found:', cleanedName, result.title || result.name)
                } else if (kpPoster) {
                    const kpUrl = `https://wsrv.nl/?url=${encodeURIComponent(kpPoster)}&output=webp`
                    localStorage.setItem(cacheKey, kpUrl)
                    setBgImage(kpUrl)
                } else {
                    console.log('[Poster] Not found:', cleanedName)
                }
            } catch (err) {
                console.warn('[Poster] Error:', cleanedName, err)
            }
        }

        // –†–∞–Ω–¥–æ–º–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ (0-2 —Å–µ–∫) —á—Ç–æ–±—ã –Ω–µ –±–æ–º–±–∏—Ç—å API –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–ø–∏—Å–∫–∞
        const timer = setTimeout(fetchPoster, Math.random() * 2000)
        return () => clearTimeout(timer)
    }, [cleanedName])

    return (
        <button
            onClick={onClick}
            className={`
          relative group aspect-[2/3] rounded-xl overflow-hidden shadow-xl
          transition-all duration-300
          focus:scale-105 focus:ring-4 focus:ring-blue-500 focus:z-20 outline-none
          hover:scale-105
          bg-gray-800
        `}
            style={{ background: !bgImage ? getGradient(name) : undefined }}
        >
            {/* If we have an image, show it. Otherwise show decorative gradient elements. */}
            {bgImage ? (
                <img
                    src={bgImage}
                    alt={name}
                    className="w-full h-full object-cover transition-opacity duration-500"
                    onError={() => setBgImage(null)} // Revert to gradient on load error
                />
            ) : (
                <>
                    <div className="absolute -top-10 -right-10 w-32 h-32 bg-white/5 rounded-full blur-2xl pointer-events-none" />
                    <div className="absolute bottom-10 -left-10 w-24 h-24 bg-black/20 rounded-full blur-xl pointer-events-none" />
                    <div className="absolute inset-0 flex items-center justify-center p-4 text-center">
                        <h3 className="text-gray-100 font-bold text-lg leading-snug drop-shadow-lg line-clamp-4 font-sans tracking-wide">
                            {cleanedName || name}
                        </h3>
                    </div>
                </>
            )}

            {/* Overlay for Stats */}
            <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-transparent to-black/10 flex flex-col justify-end p-3 text-left">
                {/* Status Badge */}
                <div className="absolute top-2 right-2 flex gap-1">
                    {newFilesCount > 0 && (
                        <span className="bg-purple-500 text-white text-[10px] font-black tracking-wider px-2 py-0.5 rounded shadow-sm animate-pulse">
                            üÜï {newFilesCount} NEW
                        </span>
                    )}
                    {isReady ? (
                        <span className="bg-green-500 text-white text-[10px] font-black tracking-wider px-2 py-0.5 rounded shadow-sm">READY</span>
                    ) : (
                        <span className="bg-yellow-500 text-black text-[10px] font-black tracking-wider px-2 py-0.5 rounded shadow-sm">{Math.round(progress * 100)}%</span>
                    )}
                </div>

                {/* Footer Stats */}
                <div className="text-xs text-gray-400 flex flex-col gap-1 mt-auto">
                    {/* Download progress info */}
                    {!isReady && downloaded > 0 && (
                        <div className="flex items-center justify-between gap-2">
                            <span className="text-blue-400">
                                {formatSize(downloaded)} / {formatSize(size)}
                            </span>
                            {eta > 0 && (
                                <span className="text-yellow-400">‚è± {formatEta(eta)}</span>
                            )}
                        </div>
                    )}

                    {/* Stats row */}
                    <div className="flex items-center gap-2">
                        <span className="flex items-center gap-1">
                            <svg className="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3zM6 8a2 2 0 11-4 0 2 2 0 014 0zM16 18v-3a5.972 5.972 0 00-.75-2.906A3.005 3.005 0 0119 15v3h-3zM4.75 12.094A5.973 5.973 0 004 15v3H1v-3a3 3 0 013.75-2.906z"></path></svg>
                            {peers}
                        </span>
                        {isReady && size > 0 && (
                            <span className="text-gray-500">{formatSize(size)}</span>
                        )}
                        {!isReady && downloadSpeed > 0 && (
                            <span className="text-green-400">‚Üì{formatSpeed(downloadSpeed)}</span>
                        )}
                    </div>

                    {/* Progress bar */}
                    {!isReady && progress > 0 && (
                        <div className="w-full h-1.5 bg-gray-700 rounded-full overflow-hidden">
                            <div style={{ width: `${progress * 100}%` }} className="h-full bg-gradient-to-r from-blue-500 to-green-500 transition-all duration-300" />
                        </div>
                    )}
                </div>
            </div>
        </button>
    )
}

export default Poster

```

---

### client/src/components/SearchPanel.jsx

```javascript
/**
 * SearchPanel Component - RuTracker/Jacred search UI
 */

const SearchPanel = ({
    searchQuery,
    onSearchQueryChange,
    onSearch,
    onClose,
    onAddTorrent,
    searchResults,
    searchLoading
}) => {
    const handleKeyPress = (e) => {
        if (e.key === 'Enter') onSearch()
    }

    return (
        <div className="mb-6 p-4 bg-gray-900 rounded-xl border border-purple-600/50 animate-fade-in">
            {/* Search Input */}
            <div className="flex gap-2 mb-4">
                <input
                    value={searchQuery}
                    onChange={(e) => onSearchQueryChange(e.target.value)}
                    onKeyPress={handleKeyPress}
                    placeholder="–ü–æ–∏—Å–∫ –Ω–∞ RuTracker..."
                    className="flex-1 bg-gray-800 border border-gray-700 rounded-lg px-4 py-3 focus:ring-2 focus:ring-purple-500 outline-none"
                    autoFocus
                />
                <button
                    onClick={onSearch}
                    disabled={searchLoading}
                    className="bg-purple-600 px-6 py-3 rounded-lg font-bold hover:bg-purple-700 disabled:opacity-50"
                >
                    {searchLoading ? '...' : 'üîç'}
                </button>
                <button
                    onClick={onClose}
                    className="bg-gray-800 px-4 rounded-lg"
                >
                    ‚úï
                </button>
            </div>

            {/* Search Results */}
            {searchResults.length > 0 && (
                <div className="max-h-64 overflow-y-auto space-y-2">
                    {searchResults.map((r, i) => (
                        <div
                            key={r.id || i}
                            className="flex items-center justify-between p-3 bg-gray-800 rounded-lg hover:bg-gray-700 transition-colors"
                        >
                            <div className="flex-1 min-w-0">
                                <div className="text-sm font-medium text-white truncate">{r.title}</div>
                                <div className="text-xs text-gray-400 flex gap-3 mt-1">
                                    <span>üìÄ {r.size}</span>
                                    <span className="text-green-400">‚¨Ü {r.seeders}</span>
                                    {r.tracker && <span className="text-purple-400">{r.tracker}</span>}
                                </div>
                            </div>
                            <button
                                onClick={() => onAddTorrent(r.magnet || r.id, r.title)}
                                disabled={searchLoading}
                                className="ml-3 bg-green-600 hover:bg-green-700 px-3 py-1.5 rounded text-sm font-bold disabled:opacity-50"
                            >
                                + Add
                            </button>
                        </div>
                    ))}
                </div>
            )}

            {/* Loading State */}
            {searchLoading && (
                <div className="text-center text-gray-400 py-4">
                    <span className="animate-pulse">–ü–æ–∏—Å–∫...</span>
                </div>
            )}
        </div>
    )
}

export default SearchPanel

```

---

### client/src/components/SettingsPanel.jsx

```javascript
/**
 * SettingsPanel Component - App configuration UI
 */
import { useState } from 'react'
import { CapacitorHttp } from '@capacitor/core'
import { Capacitor } from '@capacitor/core'
import { cleanTitle } from '../utils/helpers'

// Player list
const PLAYERS = [
    { id: 'net.gtvbox.videoplayer', name: 'Vimu Player (–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º)' },
    { id: 'org.videolan.vlc', name: 'VLC for Android' },
    { id: 'com.mxtech.videoplayer.ad', name: 'MX Player' },
    { id: '', name: 'System Chooser (–°–ø—Ä–∞—à–∏–≤–∞—Ç—å –≤—Å–µ–≥–¥–∞)' }
]

const SettingsPanel = ({
    preferredPlayer,
    onPlayerChange,
    serverUrl,
    onServerUrlChange,
    tmdbProxyUrl,
    onTmdbProxyUrlChange,
    torrents = []
}) => {
    const [showAdvanced, setShowAdvanced] = useState(false)
    const [showPosterTest, setShowPosterTest] = useState(false)
    const [testResult, setTestResult] = useState(null)
    const [testLoading, setTestLoading] = useState(false)
    const [speedMode, setSpeedModeState] = useState(localStorage.getItem('speedMode') || 'balanced')
    const [speedLoading, setSpeedLoading] = useState(false)

    const handleClearCache = () => {
        const keys = Object.keys(localStorage).filter(k => k.startsWith('poster_'))
        keys.forEach(k => localStorage.removeItem(k))
        alert(`–û—á–∏—â–µ–Ω–æ ${keys.length} –ø–æ—Å—Ç–µ—Ä–æ–≤. –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.`)
        window.location.reload()
    }

    const runPosterTest = async (testName) => {
        setTestLoading(true)
        setTestResult(null)

        const query = encodeURIComponent(testName)
        const TMDB_API_KEY = import.meta.env.VITE_TMDB_API_KEY || ''
        const KP_API_KEY = import.meta.env.VITE_KP_API_KEY || ''
        const CUSTOM_PROXY = import.meta.env.VITE_TMDB_PROXY_URL || ''

        let results = []

        // 1Ô∏è‚É£ Custom Cloudflare Worker
        if (CUSTOM_PROXY) {
            try {
                const proxyUrl = `${CUSTOM_PROXY}/search/multi?api_key=${TMDB_API_KEY}&query=${query}&language=ru-RU`
                const res = await fetch(proxyUrl, { signal: AbortSignal.timeout(8000) })
                if (res.ok) {
                    const data = await res.json()
                    const r = data.results?.find(x => x.poster_path)
                    results.push({ name: 'Custom Worker', status: r ? '‚úÖ' : '‚ö†Ô∏è', detail: r?.title || r?.name || '–ù–µ—Ç –ø–æ—Å—Ç–µ—Ä–æ–≤' })
                } else {
                    results.push({ name: 'Custom Worker', status: '‚ùå', detail: `HTTP ${res.status}` })
                }
            } catch (e) {
                results.push({ name: 'Custom Worker', status: '‚ùå', detail: e.message })
            }
        } else {
            results.push({ name: 'Custom Worker', status: '‚è≠Ô∏è', detail: '–Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω' })
        }

        // 2Ô∏è‚É£ Lampa Proxy
        try {
            const targetUrl = `https://api.themoviedb.org/3/search/multi?api_key=${TMDB_API_KEY}&query=${query}&language=ru-RU`
            const lampaUrl = `https://apn-latest.onrender.com/${targetUrl}`
            const res = await fetch(lampaUrl, { signal: AbortSignal.timeout(15000) })
            if (res.ok) {
                const data = await res.json()
                const r = data.results?.find(x => x.poster_path)
                results.push({ name: 'Lampa Proxy', status: r ? '‚úÖ' : '‚ö†Ô∏è', detail: r?.title || r?.name || '–ù–µ—Ç –ø–æ—Å—Ç–µ—Ä–æ–≤' })
            } else {
                results.push({ name: 'Lampa Proxy', status: '‚ùå', detail: `HTTP ${res.status}` })
            }
        } catch (e) {
            results.push({ name: 'Lampa Proxy', status: '‚ùå', detail: e.message })
        }

        // 3Ô∏è‚É£ CapacitorHttp (native Android)
        if (Capacitor.isNativePlatform()) {
            try {
                const searchUrl = `https://api.themoviedb.org/3/search/multi?api_key=${TMDB_API_KEY}&query=${query}&language=ru-RU`
                const response = await CapacitorHttp.get({ url: searchUrl })
                if (response.data?.results?.length > 0) {
                    const r = response.data.results.find(x => x.poster_path)
                    results.push({ name: 'CapacitorHttp', status: r ? '‚úÖ' : '‚ö†Ô∏è', detail: r?.title || r?.name || '–ù–µ—Ç –ø–æ—Å—Ç–µ—Ä–æ–≤' })
                } else {
                    results.push({ name: 'CapacitorHttp', status: '‚ö†Ô∏è', detail: '–ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç' })
                }
            } catch (e) {
                if (e.message?.includes('127.0.0.1')) {
                    results.push({ name: 'CapacitorHttp', status: 'üö´', detail: 'DNS POISONING!' })
                } else {
                    results.push({ name: 'CapacitorHttp', status: '‚ùå', detail: e.message })
                }
            }
        } else {
            results.push({ name: 'CapacitorHttp', status: '‚è≠Ô∏è', detail: '—Ç–æ–ª—å–∫–æ Android' })
        }

        // 4Ô∏è‚É£ corsproxy.io
        try {
            const searchUrl = `https://api.themoviedb.org/3/search/multi?api_key=${TMDB_API_KEY}&query=${query}&language=ru-RU`
            const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(searchUrl)}`
            const res = await fetch(proxyUrl, { signal: AbortSignal.timeout(10000) })
            if (res.ok) {
                const data = await res.json()
                const r = data.results?.find(x => x.poster_path)
                results.push({ name: 'corsproxy.io', status: r ? '‚úÖ' : '‚ö†Ô∏è', detail: r?.title || r?.name || '–ù–µ—Ç –ø–æ—Å—Ç–µ—Ä–æ–≤' })
            } else {
                results.push({ name: 'corsproxy.io', status: '‚ùå', detail: `HTTP ${res.status}` })
            }
        } catch (e) {
            results.push({ name: 'corsproxy.io', status: '‚ùå', detail: e.message })
        }

        // 5Ô∏è‚É£ Kinopoisk API
        if (KP_API_KEY) {
            try {
                const kpProxy = 'https://cors.kp556.workers.dev:8443/'
                const kpUrl = `${kpProxy}https://kinopoiskapiunofficial.tech/api/v2.1/films/search-by-keyword?keyword=${query}`
                const res = await fetch(kpUrl, {
                    headers: { 'X-API-KEY': KP_API_KEY },
                    signal: AbortSignal.timeout(8000)
                })
                if (res.ok) {
                    const data = await res.json()
                    const kp = data.films?.find(f => f.posterUrlPreview)
                    results.push({ name: '–ö–∏–Ω–æ–ø–æ–∏—Å–∫', status: kp ? '‚úÖ' : '‚ö†Ô∏è', detail: kp?.nameRu || kp?.nameEn || '–ù–µ—Ç –ø–æ—Å—Ç–µ—Ä–æ–≤' })
                } else {
                    results.push({ name: '–ö–∏–Ω–æ–ø–æ–∏—Å–∫', status: '‚ùå', detail: `HTTP ${res.status}` })
                }
            } catch (e) {
                results.push({ name: '–ö–∏–Ω–æ–ø–æ–∏—Å–∫', status: '‚ùå', detail: e.message })
            }
        } else {
            results.push({ name: '–ö–∏–Ω–æ–ø–æ–∏—Å–∫', status: '‚è≠Ô∏è', detail: '–Ω–µ—Ç API –∫–ª—é—á–∞' })
        }

        setTestResult({ name: testName, results })
        setTestLoading(false)
    }

    const cacheCount = Object.keys(localStorage).filter(k => k.startsWith('poster_')).length

    return (
        <div className="mx-6 mb-6 p-6 bg-gray-900 rounded-xl border border-gray-800 shadow-2xl animate-fade-in relative z-20">
            <h2 className="text-xl font-bold mb-4 text-gray-200">Settings</h2>

            {/* Player Selection */}
            <div className="mb-6">
                <label className="text-gray-400 text-sm mb-3 block">Default Video Player</label>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                    {PLAYERS.map(p => (
                        <button
                            key={p.id}
                            onClick={() => onPlayerChange(p.id)}
                            className={`
                p-4 rounded-lg border text-left transition-all
                ${preferredPlayer === p.id
                                    ? 'bg-blue-600 border-blue-500 text-white shadow-lg scale-[1.02]'
                                    : 'bg-gray-800 border-gray-700 text-gray-300 hover:bg-gray-700'}
              `}
                        >
                            <div className="font-bold">{p.name}</div>
                            <div className="text-xs opacity-75 mt-1">{p.id || 'System Default'}</div>
                        </button>
                    ))}
                </div>
            </div>

            {/* Speed Mode Toggle */}
            <div className="mb-6">
                <label className="text-gray-400 text-sm mb-3 block">‚ö° Speed Mode</label>
                <div className="grid grid-cols-3 gap-2">
                    {[{ id: 'eco', name: 'üå± Eco', desc: '20 peers' }, { id: 'balanced', name: '‚öñÔ∏è Balance', desc: '40 peers' }, { id: 'turbo', name: 'üöÄ Turbo', desc: '65 peers' }].map(m => (
                        <button
                            key={m.id}
                            disabled={speedLoading}
                            onClick={async () => {
                                setSpeedLoading(true)
                                try {
                                    const baseUrl = serverUrl || ''
                                    const res = await fetch(`${baseUrl}/api/speed-mode`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ mode: m.id })
                                    })
                                    if (res.ok) {
                                        setSpeedModeState(m.id)
                                        localStorage.setItem('speedMode', m.id)
                                    }
                                } catch (e) {
                                    console.error('Speed mode error:', e)
                                } finally {
                                    setSpeedLoading(false)
                                }
                            }}
                            className={`p-3 rounded-lg border text-center transition-all disabled:opacity-50 ${speedMode === m.id
                                ? 'bg-green-600 border-green-500 text-white'
                                : 'bg-gray-800 border-gray-700 text-gray-300 hover:bg-gray-700'
                                }`}
                        >
                            <div className="font-bold text-sm">{m.name}</div>
                            <div className="text-xs opacity-75 mt-1">{m.desc}</div>
                        </button>
                    ))}
                </div>
            </div>

            {/* Advanced Section */}
            <div className="border-t border-gray-800 pt-4">
                <button
                    onClick={() => setShowAdvanced(!showAdvanced)}
                    className="text-gray-500 text-sm hover:text-white flex items-center gap-2"
                >
                    {showAdvanced ? '‚ñº' : '‚ñ∂'} Advanced: Server Connection
                </button>

                {showAdvanced && (
                    <div className="mt-3 animate-fade-in">
                        {/* Server URL */}
                        <label className="text-gray-400 text-sm mb-2 block">Server URL</label>
                        <div className="flex gap-2">
                            <input
                                value={serverUrl}
                                onChange={e => onServerUrlChange(e.target.value, false)}
                                onBlur={e => onServerUrlChange(e.target.value, true)}
                                placeholder="http://192.168.1.70:3000"
                                className="bg-gray-800 text-white px-4 py-2 rounded flex-1 border border-gray-700 focus:border-blue-500 outline-none"
                            />
                        </div>
                        <p className="text-xs text-gray-600 mt-1">Change only if moving to a new server IP.</p>

                        {/* TMDB Proxy URL */}
                        <label className="text-gray-400 text-sm mb-2 block mt-4">TMDB API Proxy (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</label>
                        <div className="flex gap-2">
                            <input
                                value={tmdbProxyUrl}
                                onChange={e => onTmdbProxyUrlChange(e.target.value, false)}
                                onBlur={e => onTmdbProxyUrlChange(e.target.value, true)}
                                placeholder="https://your-proxy.com/3"
                                className="bg-gray-800 text-white px-4 py-2 rounded flex-1 border border-gray-700 focus:border-purple-500 outline-none"
                            />
                        </div>
                        <p className="text-xs text-gray-600 mt-1">
                            –û–±—Ö–æ–¥ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ TMDB. –§–æ—Ä–º–∞—Ç: <code>https://proxy/3</code>
                        </p>
                        <p className="text-xs text-gray-600">
                            üîó –ü—Ä–∏–º–µ—Ä—ã: api.themoviedb.org, tmdb.apps.lol, apitmdb.example.com
                        </p>
                    </div>
                )}

                {/* Clear Poster Cache Button */}
                <button
                    onClick={handleClearCache}
                    className="mt-4 text-red-400 text-sm hover:text-red-300 flex items-center gap-2"
                >
                    üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à –ø–æ—Å—Ç–µ—Ä–æ–≤ ({cacheCount} —à—Ç.)
                </button>

                {/* TV-Friendly Poster Test */}
                <button
                    onClick={() => setShowPosterTest(!showPosterTest)}
                    className="mt-2 text-blue-400 text-sm hover:text-blue-300 flex items-center gap-2"
                >
                    üß™ –¢–µ—Å—Ç –ø–æ—Å—Ç–µ—Ä–æ–≤ {showPosterTest ? '‚ñº' : '‚ñ∂'}
                </button>

                {showPosterTest && (
                    <div className="mt-3 p-4 bg-gray-800 rounded-lg border border-gray-700 animate-fade-in">
                        <p className="text-gray-400 text-sm mb-3">–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–ª—å–º –¥–ª—è —Ç–µ—Å—Ç–∞:</p>

                        {/* Torrent List - TV-friendly buttons with D-pad navigation */}
                        <div className="max-h-48 overflow-y-auto space-y-2 mb-4" role="listbox">
                            {torrents.length === 0 ? (
                                <p className="text-gray-500 text-sm">–ù–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤</p>
                            ) : (
                                torrents.map((t, idx) => (
                                    <button
                                        key={t.infoHash}
                                        tabIndex={0}
                                        autoFocus={idx === 0}
                                        onClick={() => runPosterTest(cleanTitle(t.name) || t.name)}
                                        disabled={testLoading}
                                        className="w-full text-left p-3 bg-gray-700 hover:bg-gray-600 focus:bg-blue-600 focus:ring-2 focus:ring-blue-500 focus:outline-none rounded-lg transition-all text-sm truncate disabled:opacity-50"
                                        onKeyDown={(e) => {
                                            if (e.key === 'ArrowDown') {
                                                e.preventDefault()
                                                e.target.nextElementSibling?.focus()
                                            } else if (e.key === 'ArrowUp') {
                                                e.preventDefault()
                                                e.target.previousElementSibling?.focus()
                                            }
                                        }}
                                    >
                                        üé¨ {cleanTitle(t.name) || t.name}
                                    </button>
                                ))
                            )}
                        </div>

                        {/* Loading State */}
                        {testLoading && (
                            <div className="text-center py-4">
                                <span className="animate-pulse text-blue-400">‚è≥ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ...</span>
                            </div>
                        )}

                        {/* Test Results */}
                        {testResult && (
                            <div className="mt-4 p-3 bg-gray-900 rounded-lg border border-gray-600">
                                <h4 className="font-bold text-white mb-2 text-sm">
                                    üé¨ "{testResult.name}"
                                </h4>
                                <div className="space-y-1">
                                    {testResult.results.map((r, i) => (
                                        <div key={i} className="flex items-center gap-2 text-xs">
                                            <span>{r.status}</span>
                                            <span className="text-gray-400">{r.name}:</span>
                                            <span className="text-gray-300 truncate">{r.detail}</span>
                                        </div>
                                    ))}
                                </div>
                                <p className="text-xs text-gray-500 mt-3">
                                    üí° –í—Å–µ ‚ùå ‚Üí VPN | DNS Poison ‚Üí 1.1.1.1
                                </p>
                            </div>
                        )}
                    </div>
                )}
            </div>
        </div>
    )
}

export default SettingsPanel

```

---

### client/src/components/StatusBanners.jsx

```javascript
/**
 * Status Banner Components - Error states and loading indicators
 */
import { useState, useEffect } from 'react'

/**
 * DegradedBanner - Shows when server is in degraded mode (high memory)
 */
export const DegradedBanner = ({ lastStateChange }) => {
    const [elapsed, setElapsed] = useState(0)

    useEffect(() => {
        if (!lastStateChange) return
        const interval = setInterval(() => {
            setElapsed(Math.floor((Date.now() - lastStateChange) / 1000))
        }, 1000)
        return () => clearInterval(interval)
    }, [lastStateChange])

    const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60)
        const secs = seconds % 60
        return mins > 0 ? `${mins}m ${secs}s` : `${secs}s`
    }

    return (
        <div className="bg-yellow-600/90 text-yellow-100 p-4 rounded-lg mb-6 border border-yellow-500 animate-pulse mx-4">
            <div className="flex items-center gap-3">
                <span className="text-2xl">‚ùÑÔ∏è</span>
                <div>
                    <div className="font-bold text-lg">Cooling Down</div>
                    <div className="text-sm opacity-90">
                        High memory usage detected. Service may be slower.
                        <span className="ml-2 font-mono">{formatTime(elapsed)}</span>
                    </div>
                </div>
            </div>
        </div>
    )
}

/**
 * ErrorScreen - Full-screen error for circuit breaker / critical errors
 */
export const ErrorScreen = ({ status, retryAfter, onRetry }) => {
    const [countdown, setCountdown] = useState(retryAfter || 300)

    useEffect(() => {
        if (countdown <= 0) {
            onRetry()
            return
        }
        const timer = setTimeout(() => setCountdown(c => c - 1), 1000)
        return () => clearTimeout(timer)
    }, [countdown, onRetry])

    const isCircuitOpen = status === 'circuit_open'
    const icon = isCircuitOpen ? 'üîå' : '‚ö†Ô∏è'
    const title = isCircuitOpen ? 'Storage Unavailable' : 'Server Error'
    const message = isCircuitOpen
        ? 'NFS/Storage is not responding. The server will retry automatically.'
        : 'A critical error occurred. Please wait for recovery.'

    return (
        <div className="min-h-screen bg-gray-900 flex items-center justify-center p-6">
            <div className="bg-red-900/30 border border-red-700 rounded-2xl p-8 max-w-md text-center">
                <div className="text-6xl mb-4">{icon}</div>
                <h1 className="text-2xl font-bold text-red-400 mb-2">{title}</h1>
                <p className="text-gray-300 mb-6">{message}</p>
                <button
                    onClick={onRetry}
                    className="mt-6 bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg font-bold transition-colors"
                >
                    Retry Now
                </button>
            </div>
        </div>
    )
}

/**
 * BufferingBanner - Shows loading progress when starting playback
 */
export const BufferingBanner = ({ name, progress }) => {
    if (!name) return null

    return (
        <div className="fixed top-16 left-0 right-0 z-50 mx-4">
            <div className="bg-blue-900/95 backdrop-blur-md border border-blue-500 rounded-xl p-4 shadow-2xl animate-pulse">
                <div className="flex items-center gap-3">
                    <div className="animate-spin">
                        <svg className="w-6 h-6 text-blue-400" fill="none" viewBox="0 0 24 24">
                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                        </svg>
                    </div>
                    <div className="flex-1">
                        <div className="font-bold text-white">Buffering...</div>
                        <div className="text-sm text-blue-200 truncate">{name}</div>
                    </div>
                    {progress > 0 && (
                        <div className="text-blue-300 font-mono">{progress}%</div>
                    )}
                </div>
            </div>
        </div>
    )
}

/**
 * ServerStatusBar - Small indicator showing server health
 */
export const ServerStatusBar = ({ status, onDiagnosticsClick }) => {
    const getStatusInfo = () => {
        switch (status) {
            case 'ok':
                return { icon: 'üü¢', text: 'Server OK', color: 'bg-green-900/50 border-green-700 text-green-300' }
            case 'degraded':
                return { icon: 'üü°', text: 'High RAM', color: 'bg-yellow-900/50 border-yellow-700 text-yellow-300' }
            case 'circuit_open':
                return { icon: 'üî¥', text: 'Storage Error', color: 'bg-red-900/50 border-red-700 text-red-300' }
            case 'error':
                return { icon: 'üî¥', text: 'Server Error', color: 'bg-red-900/50 border-red-700 text-red-300' }
            default:
                return { icon: '‚ö™', text: 'Connecting...', color: 'bg-gray-800/50 border-gray-600 text-gray-400' }
        }
    }

    const info = getStatusInfo()

    return (
        <button
            onClick={onDiagnosticsClick}
            className={`px-3 py-1.5 rounded-lg border text-xs font-medium flex items-center gap-2 transition-colors hover:opacity-80 ${info.color}`}
        >
            <span>{info.icon}</span>
            <span>{info.text}</span>
        </button>
    )
}

```

---

### client/src/components/TorrentModal.jsx

```javascript
/**
 * TorrentModal Component - File list and playback controls
 */
import { cleanTitle, formatSize } from '../utils/helpers'

const TorrentModal = ({
    torrent,
    onClose,
    onPlay,
    onPlayAll,
    onCopyUrl,
    onDelete
}) => {
    if (!torrent) return null

    const videoFiles = torrent.files?.filter(f => /\.(mp4|mkv|avi|mov|webm)$/i.test(f.name)) || []
    const firstVideo = videoFiles[0] || torrent.files?.[0]

    return (
        <div
            className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur-sm animate-fade-in"
            onClick={onClose}
        >
            <div
                className="bg-[#181818] rounded-2xl w-full max-w-lg max-h-[85vh] overflow-hidden shadow-2xl relative flex flex-col"
                onClick={e => e.stopPropagation()}
            >
                {/* Modal Header */}
                <div className="h-32 bg-gradient-to-br from-blue-900 to-gray-900 p-6 flex items-end relative">
                    <button
                        onClick={onClose}
                        className="absolute top-4 right-4 bg-black/40 rounded-full p-2 text-white hover:bg-black/60 transition-colors"
                    >
                        ‚úï
                    </button>
                    <h2 className="text-2xl font-bold leading-tight shadow-black drop-shadow-lg line-clamp-2">
                        {cleanTitle(torrent.name)}
                    </h2>
                </div>

                <div className="p-6 overflow-y-auto flex-1">
                    {/* Original name */}
                    <div className="text-sm text-gray-400 mb-6 font-mono break-all text-xs border-l-2 border-gray-700 pl-3">
                        {torrent.name}
                    </div>

                    <div className="space-y-3">
                        {/* Play button */}
                        <button
                            autoFocus
                            onClick={() => {
                                if (firstVideo) onPlay(torrent.infoHash, firstVideo.index, firstVideo.name)
                                else alert("No video files recognized")
                            }}
                            className="w-full bg-white text-black py-4 rounded font-bold hover:bg-gray-200 focus:bg-yellow-400 text-lg transition-colors flex items-center justify-center gap-2"
                        >
                            ‚ñ∂ Play
                        </button>

                        {/* Play All button - only show if multiple video files */}
                        {videoFiles.length > 1 && (
                            <button
                                onClick={() => onPlayAll(torrent)}
                                className="w-full bg-blue-600 text-white py-3 rounded font-bold hover:bg-blue-700 focus:bg-blue-500 transition-colors flex items-center justify-center gap-2"
                            >
                                üì∫ Play All ({videoFiles.length} episodes)
                            </button>
                        )}

                        {/* Episode List - TV Remote Friendly (no scroll container) */}
                        {videoFiles.length > 1 && (
                            <div className="bg-gray-900 rounded-lg overflow-hidden">
                                <div className="px-3 py-2 bg-gray-800 text-gray-400 text-sm font-medium">
                                    üìã –í—ã–±–æ—Ä —Å–µ—Ä–∏–∏ ({videoFiles.length})
                                </div>
                                {videoFiles
                                    .sort((a, b) => a.name.localeCompare(b.name))
                                    .slice(0, 20) // Limit to 20 to avoid huge lists
                                    .map((file, idx) => (
                                        <button
                                            key={file.index}
                                            onClick={() => onPlay(torrent.infoHash, file.index, file.name)}
                                            className="w-full px-3 py-3 text-left border-t border-gray-800 hover:bg-gray-800 focus:bg-blue-600 focus:text-white focus:outline-none transition-colors flex items-center gap-3"
                                        >
                                            <span className="text-blue-400 font-mono text-sm w-8 focus:text-white">{idx + 1}</span>
                                            <span className="flex-1 text-sm text-gray-300 truncate">{cleanTitle(file.name) || file.name}</span>
                                            <span className="text-xs text-gray-500">{formatSize(file.length)}</span>
                                        </button>
                                    ))}
                            </div>
                        )}

                        {/* Action buttons */}
                        <div className="flex gap-2">
                            <button
                                onClick={() => {
                                    if (firstVideo) onCopyUrl(torrent.infoHash, firstVideo.index)
                                }}
                                className="flex-1 bg-gray-800 text-gray-300 py-3 rounded font-medium hover:bg-gray-700"
                            >
                                Copy Link
                            </button>
                            <button
                                onClick={() => onDelete(torrent.infoHash)}
                                className="flex-1 bg-gray-800 text-red-400 py-3 rounded font-medium hover:bg-red-900/20"
                            >
                                Delete
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    )
}

export default TorrentModal

```

---

### client/src/main.jsx

```javascript
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

```

---

### client/src/utils/helpers.js

```js
/**
 * Utility helpers for PWA-TorServe
 */

/**
 * Clean torrent/file name for display and poster search
 * Removes technical tags, year suffixes, season markers, and garbage characters
 */
export const cleanTitle = (rawName) => {
    if (!rawName) return ''

    // 1. –ë–∞–∑–æ–≤–∞—è —á–∏—Å—Ç–∫–∞: —Ç–æ—á–∫–∏, –Ω–∏–∂–Ω–∏–µ –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏—è, —Å–∫–æ–±–∫–∏
    let name = rawName
        .replace(/\./g, ' ')
        .replace(/_/g, ' ')
        .replace(/\[.*?\]/g, '') // –£–¥–∞–ª—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö —Å–∫–æ–±–æ–∫
        .replace(/\(.*?\)/g, '') // –£–¥–∞–ª—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫—Ä—É–≥–ª—ã—Ö —Å–∫–æ–±–æ–∫
        .trim()

    // 2. üî• –í–ê–ñ–ù–û: –û–±—Ä–µ–∑–∞–µ–º –ø–æ –°–µ–∑–æ–Ω—É (S01, s01e01), –µ—Å–ª–∏ –≥–æ–¥–∞ –Ω–µ—Ç
    // –≠—Ç–æ —Å–ø–∞—Å–µ—Ç "IT Welcome to Derry S01..." -> "IT Welcome to Derry"
    const seasonMatch = name.match(/\b(S\d{2}|s\d{2})\b/i)
    if (seasonMatch) {
        const index = name.indexOf(seasonMatch[0])
        name = name.substring(0, index)
    }

    // 3. –û–±—Ä–µ–∑–∞–µ–º –ø–æ –ì–æ–¥—É (–∫–∞–∫ –∏ –±—ã–ª–æ)
    const yearMatch = name.match(/\b(19\d{2}|20\d{2})\b/)
    if (yearMatch) {
        const index = name.indexOf(yearMatch[0])
        name = name.substring(0, index)
    }

    // 4. üî• –î–æ–ø–æ–ª–Ω–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ –º—É—Å–æ—Ä–Ω—ã—Ö —Ç–µ–≥–æ–≤
    const tags = [
        // –ö–∞—á–µ—Å—Ç–≤–æ –∏ —Ä–∏–ø—ã
        '1080p', '720p', '2160p', '4k', 'WEB-DL', 'WEBRip', 'BluRay', 'HDR',
        'H.264', 'H264', 'x264', 'x265', 'HEVC', 'AAC', 'AC3', 'DTS', 'HDTV', 'DV', 'DoVi',
        'SDR', 'BDRemux', 'Remux', 'TYMBLER', 'AKTEP', 'SOFCJ',
        'CHDRip', 'HDRip', 'DVDRip', 'BDRip', 'CAMRip', 'TS', 'TC',
        'DD5', 'DD51', 'DD', 'Atmos',
        // –í–µ—Ä—Å–∏–∏ –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è
        'v2', 'v3', 'v4', 'mkv', 'avi', 'mp4',
        // –Ø–∑—ã–∫–∏ –∏ –ø—Ä–æ—á–µ–µ
        'rus', 'eng', 'torrent', 'stream', 'dub', 'sub', 'extended',
        // –°—Ç—Ä–∏–º–∏–Ω–≥–∏
        'HMAX', 'ATVP', 'AMZN', 'NF', 'DSNP', 'HULU', 'OKKO', 'OM'
    ]

    // –£–¥–∞–ª—è–µ–º —Ç–µ–≥–∏ (–Ω–∞ —Å–ª—É—á–∞–π –µ—Å–ª–∏ –æ–Ω–∏ —Å—Ç–æ—è—Ç –î–û —Å–µ–∑–æ–Ω–∞/–≥–æ–¥–∞)
    tags.forEach(tag => {
        // –£–¥–∞–ª—è–µ–º —Ç–µ–≥ –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω–æ–µ —Å–ª–æ–≤–æ
        const regex = new RegExp(`\\b${tag}\\b`, 'gi')
        name = name.replace(regex, '')
    })

    return name
        .replace(/[^\w\s\u0400-\u04FF:\-]/g, '') // –û—Å—Ç–∞–≤–ª—è–µ–º –±—É–∫–≤—ã, —Ü–∏—Ñ—Ä—ã, –¥–≤–æ–µ—Ç–æ—á–∏–µ –∏ –¥–µ—Ñ–∏—Å
        .replace(/\s+/g, ' ') // –£–±–∏—Ä–∞–µ–º –¥–≤–æ–π–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã
        .trim()
}

/**
 * Format bytes to human readable size
 */
export const formatSize = (bytes) => {
    if (!bytes) return ''
    const units = ['B', 'KB', 'MB', 'GB', 'TB']
    let i = 0
    let size = bytes
    while (size >= 1024 && i < units.length - 1) {
        size /= 1024
        i++
    }
    return `${size.toFixed(1)} ${units[i]}`
}

/**
 * Format download speed (bytes/sec to human readable)
 */
export const formatSpeed = (bytesPerSec) => {
    if (!bytesPerSec || bytesPerSec < 1024) return ''
    const kbps = bytesPerSec / 1024
    if (kbps < 1024) return `${kbps.toFixed(0)} KB/s`
    return `${(kbps / 1024).toFixed(1)} MB/s`
}

/**
 * Format ETA (seconds to human readable)
 */
export const formatEta = (seconds) => {
    if (!seconds || seconds <= 0) return ''
    if (seconds < 60) return `${seconds}—Å`
    if (seconds < 3600) return `${Math.floor(seconds / 60)}–º`
    const hours = Math.floor(seconds / 3600)
    const mins = Math.floor((seconds % 3600) / 60)
    return `${hours}—á ${mins}–º`
}

/**
 * Generate gradient based on string hash (for fallback poster background)
 */
export const getGradient = (str) => {
    let hash = 0
    for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash)
    const h1 = Math.abs(hash % 360)
    const h2 = Math.abs((hash * 13) % 360)
    return `linear-gradient(135deg, hsl(${h1}, 70%, 20%), hsl(${h2}, 80%, 15%))`
}

```

---

### client/tailwind.config.js

```js
/** @type {import('tailwindcss').Config} */
export default {
    content: [
        "./index.html",
        "./src/**/*.{js,ts,jsx,tsx}",
    ],
    theme: {
        extend: {},
    },
    plugins: [],
}

```

---

### client/vite.config.js

```js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

---

### db.json

```json
{
  "serverStatus": "circuit_open",
  "lastStateChange": 1768589331075,
  "storageFailures": 4,
  "progress": {},
  "seenFiles": {},
  "torrents": [],
  "autoDownloadSettings": {
    "enabled": false,
    "intervalMinutes": 720
  },
  "autoDownloadRules": [],
  "autoDownloadHistory": []
}
```

---

### docker-compose.synology.yml

```yaml
version: '3.8'

services:
  torserve:
    # Use the image built previously or build it here if you transfer the source.
    # Assuming user might build on NAS or pull from a registry. If building on NAS:
    build: .
    image: pwa-torserve:latest
    container_name: torserve
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DOWNLOAD_PATH=/app/downloads
      - DB_PATH=/app/data/db.json
    volumes:
      # Downloads folder (map to your NAS media folder)
      - /volume1/docker/pwa-torserve/downloads:/app/downloads
      # [HOTFIX] Map source code for easy updates without rebuild
      - ./server:/app/server
      # Utils folder (for DoH and other utilities)
      - ./server/utils:/app/server/utils
      # Environment file with API keys
      - ./.env:/app/.env:ro
      # Persistence for DB
      - ./data:/app/data
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"


```

---

### docker-compose.yml

```yaml
version: '3.8'

services:
  pwa-torserve:
    build: .
    image: pwa-torserve:latest
    container_name: pwa-torserve
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DOWNLOAD_PATH=/app/downloads
      - DB_PATH=/app/data/db.json
    volumes:
      # Persistent data (database, settings)
      - ./data:/app/data
      # Downloads folder (map to your NAS media folder)
      - /volume1/docker/pwa-torserve/downloads:/app/downloads
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

```

---

### docs/API_SECURITY.md

```md
# –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å API –∫–ª—é—á–µ–π

## –ß—Ç–æ –±—ã–ª–æ —Å–¥–µ–ª–∞–Ω–æ (–î–µ–∫–∞–±—Ä—å 2025)
–í —Ü–µ–ª—è—Ö –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –≤—Å–µ API –∫–ª—é—á–∏ (TMDB, Kinopoisk) –±—ã–ª–∏ —É–¥–∞–ª–µ–Ω—ã –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞ –ø—Ä–æ–µ–∫—Ç–∞. –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ –ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –∫–æ–¥ –Ω–∞ GitHub, –Ω–µ –±–æ—è—Å—å —É—Ç–µ—á–∫–∏ –ø–ª–∞—Ç–Ω—ã—Ö –∏–ª–∏ –ª–∏—á–Ω—ã—Ö –∫–ª—é—á–µ–π.

### –¢–µ–∫—É—â–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
1. **–•—Ä–∞–Ω–µ–Ω–∏–µ –∫–ª—é—á–µ–π**: –ö–ª—é—á–∏ —Ö—Ä–∞–Ω—è—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ —Ñ–∞–π–ª–µ `.env` –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞. –≠—Ç–æ—Ç —Ñ–∞–π–ª –¥–æ–±–∞–≤–ª–µ–Ω –≤ `.gitignore` –∏ –Ω–µ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π.
2. **–ö–ª–∏–µ–Ω—Ç (Frontend)**: –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è `VITE_TMDB_API_KEY` –∏ `VITE_KP_API_KEY`.
    - –ü—Ä–∏ —Å–±–æ—Ä–∫–µ –ø—Ä–æ–µ–∫—Ç–∞ (`npm run build`) Vite –ø–æ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Ä–µ–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ `.env` –≤ –∫–æ–¥.
    - –í –∏—Å—Ö–æ–¥–Ω–∏–∫–∞—Ö (`App.jsx`) –∫–ª—é—á–µ–π –Ω–µ—Ç, —Ç–∞–º —Ç–æ–ª—å–∫–æ —Å—Å—ã–ª–∫–∏ `import.meta.env...`.

## –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –Ω–∞ –±—É–¥—É—â–µ–µ

### –ï—Å–ª–∏ –≤—ã –ø–µ—Ä–µ—É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç–µ –ø—Ä–æ–µ–∫—Ç –∏–ª–∏ –º–µ–Ω—è–µ—Ç–µ —Å–µ—Ä–≤–µ—Ä
1. –°–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª `.env` –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞ (–º–æ–∂–Ω–æ —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∏–∑ `.env.example`).
2. –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –∫–ª—é—á–∏:
   ```env
   VITE_TMDB_API_KEY=–≤–∞—à_–∫–ª—é—á
   VITE_KP_API_KEY=–≤–∞—à_–∫–ª—é—á
   ```
3. –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ —Å–µ—Ä–≤–µ—Ä (—á—Ç–æ–±—ã –æ–Ω —É–≤–∏–¥–µ–ª —Ñ–∞–π–ª).

### –ï—Å–ª–∏ –≤—ã –≤–Ω–æ—Å–∏—Ç–µ –ø—Ä–∞–≤–∫–∏ –≤ Frontend (–ø–∞–ø–∫–∞ client)
–¢–∞–∫ –∫–∞–∫ –∫–ª—é—á–∏ "–≤–ø–µ–∫–∞—é—Ç—Å—è" –≤ —Å—Ç–∞—Ç–∏–∫—É –ø—Ä–∏ —Å–±–æ—Ä–∫–µ, –µ—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –æ–±–Ω–æ–≤–∏—Ç—å –∫–æ–¥ –∫–ª–∏–µ–Ω—Ç–∞ –∏–ª–∏ –ø–æ–º–µ–Ω—è–ª–∏ –∫–ª—é—á–∏:
1. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–∞–π–ª `.env` —Å –∫–ª—é—á–∞–º–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.
2. –ó–∞–ø—É—Å—Ç–∏—Ç–µ —Å–±–æ—Ä–∫—É:
   ```bash
   cd client
   npm run build
   ```
   –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Å–æ–∑–¥–∞—Å—Ç –Ω–æ–≤—É—é –≤–µ—Ä—Å–∏—é —Å–∞–π—Ç–∞ –≤ –ø–∞–ø–∫–µ `dist`, —É–∂–µ —Å –≤–∞—à–∏–º–∏ –∫–ª—é—á–∞–º–∏.

```

---

### docs/CLOUDFLARE_WORKER_SETUP.md

```md
# üöÄ –ö–∞–∫ —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å —Å–≤–æ–π CORS Proxy –Ω–∞ Cloudflare Workers

–≠—Ç–æ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π –ø—Ä–æ–∫—Å–∏ –¥–ª—è –æ–±—Ö–æ–¥–∞ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫ TMDB –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–º.

## –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞
- ‚úÖ **–ë–µ—Å–ø–ª–∞—Ç–Ω–æ** ‚Äî 100,000 –∑–∞–ø—Ä–æ—Å–æ–≤/–¥–µ–Ω—å
- ‚úÖ **–í–∞—à –ª–∏—á–Ω—ã–π** ‚Äî –Ω–µ –∑–∞–≤–∏—Å–∏—Ç–µ –æ—Ç —á—É–∂–∏—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
- ‚úÖ **–ë—ã—Å—Ç—Ä—ã–π** ‚Äî –≥–ª–æ–±–∞–ª—å–Ω–∞—è CDN Cloudflare
- ‚úÖ **–ù–∞–¥—ë–∂–Ω—ã–π** ‚Äî –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä—É—é—Ç

## –®–∞–≥–∏

### 1. –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
1. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –Ω–∞ [dash.cloudflare.com](https://dash.cloudflare.com)
2. –°–æ–∑–¥–∞–π—Ç–µ –∞–∫–∫–∞—É–Ω—Ç (–±–µ—Å–ø–ª–∞—Ç–Ω–æ)

### 2. –°–æ–∑–¥–∞–Ω–∏–µ Worker
1. –í –º–µ–Ω—é —Å–ª–µ–≤–∞: **Workers & Pages**
2. –ù–∞–∂–º–∏—Ç–µ **Create application** ‚Üí **Create Worker**
3. –ò–º—è: `tmdb-proxy` (–∏–ª–∏ –ª—é–±–æ–µ –¥—Ä—É–≥–æ–µ)
4. –ù–∞–∂–º–∏—Ç–µ **Deploy**

### 3. –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞
1. –ù–∞–∂–º–∏—Ç–µ **Edit code**
2. –ó–∞–º–µ–Ω–∏—Ç–µ –≤–µ—Å—å –∫–æ–¥ –Ω–∞ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞ `cloudflare_worker.js`
3. –ù–∞–∂–º–∏—Ç–µ **Save and Deploy**

### 4. –ü–æ–ª—É—á–µ–Ω–∏–µ URL
–ü–æ—Å–ª–µ –¥–µ–ø–ª–æ—è –≤—ã –ø–æ–ª—É—á–∏—Ç–µ URL –≤–∏–¥–∞:
```
https://tmdb-proxy.YOUR-USERNAME.workers.dev
```

### 5. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ PWA-TorServe
–í –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏: **Settings ‚Üí Advanced ‚Üí TMDB API Proxy**

–í–≤–µ–¥–∏—Ç–µ:
```
https://tmdb-proxy.YOUR-USERNAME.workers.dev/api.themoviedb.org/3
```

## –§–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–æ–≤
Worker –ø—Ä–∏–Ω–∏–º–∞–µ—Ç URL –≤ —Ñ–æ—Ä–º–∞—Ç–µ:
```
https://YOUR-WORKER.workers.dev/https://api.themoviedb.org/3/search/multi?api_key=...
```

## –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞: Deno Deploy
–ï—Å–ª–∏ –Ω–µ —Ö–æ—Ç–∏—Ç–µ Cloudflare ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ [Deno Deploy](https://deno.com/deploy):
1. –°–æ–∑–¥–∞–π—Ç–µ –ø—Ä–æ–µ–∫—Ç
2. –ó–∞–≥—Ä—É–∑–∏—Ç–µ `deno_apn.js`
3. –ü–æ–ª—É—á–∏—Ç–µ URL –≤–∏–¥–∞ `https://your-app.deno.dev`

---

## –ì–æ—Ç–æ–≤—ã–µ –ø—Ä–æ–∫—Å–∏ (–µ—Å–ª–∏ –ª–µ–Ω—å —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å)
- `https://apn-latest.onrender.com/` ‚Äî —É–∂–µ –≤—Å—Ç—Ä–æ–µ–Ω –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
- `https://cors.kp556.workers.dev:8443/` ‚Äî –¥–ª—è –ö–∏–Ω–æ–ø–æ–∏—Å–∫–∞


```

---

### docs/LAMPAC_FULL_PROJECT_CODE.md

```md
# Project: Lampac

## File: install.sh
```
#!/usr/bin/env bash
DEST="/home/lampac"

# Become root
# sudo su -
apt-get update
apt-get install -y unzip curl libicu-dev
apt-get install -y libnss3-dev libgtk-3-dev libxss-dev libasound2
apt-get install -y libgdk-pixbuf2.0-dev
apt-get install -y libnspr4
apt-get install -y libatk1.0-0
apt-get install -y xvfb
apt-get install -y coreutils

# chromium
apt-get install -y libnss3 libatk-bridge2.0-0 libdrm-dev libxkbcommon-dev libxcomposite-dev libxdamage-dev libxrandr-dev libgbm-dev libasound2-dev libpangocairo-1.0-0 libpango-1.0-0 libcairo2-dev

# Install .NET
if ! curl -L -k -o dotnet-install.sh https://dot.net/v1/dotnet-install.sh; then
   echo "Failed to download dotnet-install.sh. Exiting."
   exit 1
fi

chmod 755 dotnet-install.sh
./dotnet-install.sh --channel 9.0 --runtime aspnetcore --install-dir /usr/share/dotnet
ln -s /usr/share/dotnet/dotnet /usr/bin/dotnet

# Download zip
mkdir $DEST -p 
cd $DEST
if ! curl -L -k -o publish.zip https://github.com/immisterio/Lampac/releases/latest/download/publish.zip; then
   echo "Failed to download publish.zip. Exiting."
   exit 1
fi

unzip -o publish.zip
rm -f publish.zip

# automatic updates
curl -k -s https://api.github.com/repos/immisterio/Lampac/releases/latest | grep tag_name | sed s/[^0-9]//g > $DEST/data/vers.txt
curl -k -s https://raw.githubusercontent.com/immisterio/lampac/main/update.sh > $DEST/update.sh
chmod 755 $DEST/update.sh
#crontab -l | { cat; echo "$(shuf -i 10-55 -n 1) * * * * /bin/bash $DEST/update.sh"; } | crontab -

CRON_JOB="$(shuf -i 10-55 -n 1) * * * * /bin/bash $DEST/update.sh"
(crontab -l | grep -vF "/bin/bash $DEST/update.sh"; echo "$CRON_JOB") | crontab -

# Create service
echo ""
echo "Install service to /etc/systemd/system/lampac.service ..."
touch /etc/systemd/system/lampac.service && chmod 664 /etc/systemd/system/lampac.service
cat <<EOF > /etc/systemd/system/lampac.service
[Unit]
Description=Lampac
Wants=network.target
After=network.target
[Service]
WorkingDirectory=$DEST
ExecStart=/usr/bin/dotnet Lampac.dll
#ExecReload=/bin/kill -s HUP $MAINPID
#ExecStop=/bin/kill -s QUIT $MAINPID
Restart=always
LimitNOFILE=32000
[Install]
WantedBy=multi-user.target
EOF

if [ ! -f "$DEST/init.conf" ]; then
random_port=$(shuf -i 9000-12999 -n 1)
cat <<EOF > $DEST/init.conf
"listen": {
  "port": $random_port
}
EOF
fi

# Enable service
systemctl daemon-reload
systemctl enable lampac

# update minor
echo -n "1" > $DEST/data/vers-minor.txt
/bin/bash $DEST/update.sh
cd $DEST

# done
systemctl start lampac

# iptables drop
cat <<EOF > iptables-drop.sh
#!/bin/sh
echo "Stopping firewall and allowing everyone..."
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT
EOF

get_external_ip() {
   local ip
   ip=$(curl -s --connect-timeout 5 https://api.ipify.org 2>/dev/null)
   if [ -z "$ip" ]; then
      ip=$(curl -s --connect-timeout 5 https://icanhazip.com 2>/dev/null)
   fi
   if [ -z "$ip" ]; then
      ip=$(curl -s --connect-timeout 5 https://ifconfig.me 2>/dev/null)
   fi
   echo "${ip:-IP}"
}

# Note
echo ""
echo "################################################################"
echo ""
echo "Have fun!"
echo ""
echo "http://$(get_external_ip):$random_port"
echo ""
echo "Please check/edit $DEST/init.conf params and configure it"
echo ""
echo "Then [re]start it as systemctl [re]start lampac"
echo ""
echo "Clear iptables if port $random_port is not available"
echo "bash $DEST/iptables-drop.sh"
echo ""

```

## File: README.md
```
# Telegram –≥—Ä—É–ø–ø–∞
https://t.me/+TIXtgvGBBOc3ZTUy

# AI –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
[![DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/immisterio/Lampac)

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞ linux
—Å–ø–∞—Å–∏–±–æ @nikk, @Denis
```bash
curl -L -k -s https://lampac.sh | bash
```
* –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è: 1 CPU, 1GB RAM, 2GB HDD
* –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è: 1 CPU, 2GB RAM, 5GB SSD
* –ü–æ—Ä—Ç –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è —Ä–∞–Ω–¥–æ–º–Ω–æ –∏ –≤—ã–≤–æ–¥–∏—Ç—Å—è –≤ –∫–æ–Ω—Ü–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å–∫—Ä–∏–ø—Ç–∞
* –ò–∑–º–µ–Ω–∏—Ç—å –∏–ª–∏ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø–æ—Ä—Ç –º–æ–∂–Ω–æ –≤ init.conf - 
```grep "port" /home/lampac/init.conf```

# –î–æ–º–∞—à–Ω—è—è (–æ–±–ª–µ–≥—á–µ–Ω–Ω–∞—è) - linux
```bash
curl -L -k -s https://lampac.sh/home | bash
```
* –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è: 1 CPU, 500Mb RAM, 1GB HDD
* –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è: 1 CPU, 1GB RAM, 1GB SSD
* DLNA/Chromium/Firefox –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –æ—Ç–∫–ª—é—á–µ–Ω, –≤–∫–ª—é—á–∞–µ—Ç—Å—è –≤ init.conf
* TorrServer –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –æ—Ç–∫–ª—é—á–µ–Ω, –≤–∫–ª—é—á–∞–µ—Ç—Å—è –≤ module/manifest.json

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞ Windows
1. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å ".NET Core 9 (SDK Installer)" https://github.com/dotnet/core/blob/main/release-notes/9.0/9.0.9/9.0.110.md
2. –†–∞—Å–ø–∞–∫–æ–≤–∞—Ç—å https://github.com/immisterio/Lampac/releases/latest/download/publish.zip
3. –ó–∞–ø—É—Å—Ç–∏—Ç—å Lampac.exe

# –ó–∞–ø—É—Å–∫ –≤ Docker
```bash
docker run -d -p 9118:9118 --restart always --name lampac immisterio/lampac
```
__tags__: latest (linux/amd64) / arm32 (linux/arm/v7) / arm64 (linux/arm64/v8)

# –ó–∞–ø—É—Å–∫ –≤ Android
1. Termux - https://github.com/immisterio/Lampac/blob/main/Termux/README.md
2. BWA - https://bwa.to

# –¢–µ—Å—Ç–∏—Ä—É–µ–º—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
* Debian 11/12 x64
* Windows 10 x64
* Raspberry arm64 (Debian 11)

# –ê–¥–º–∏–Ω–∫–∞
ip:9118/admin

# –ü–ª–∞–≥–∏–Ω—ã –¥–ª—è Lampa
1. –í—Å–µ –ø–ª–∞–≥–∏–Ω—ã —Å—Ä–∞–∑—É - http://IP:9118/on.js
2. –æ–Ω–ª–∞–π–Ω   - http://IP:9118/online.js
3. xxx      - http://IP:9118/sisi.js
4. DLNA     - http://IP:9118/dlna.js
5. Tracks   - http://IP:9118/tracks.js
6. Backup   - http://IP:9118/backup.js
7. –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è   - http://IP:9118/sync.js
8. TorrServer      - http://IP:9118/ts.js
9. –ü–∞—Ä—Å–µ—Ä Jackett  - IP:9118

# –ü–ª–∞–≥–∏–Ω—ã –¥–ª—è Lampa Lite
1. –æ–Ω–ª–∞–π–Ω/jackett  - http://IP:9118/lite.js
2. xxx     - http://IP:9118/sisi.js

# –û–±—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
1. –û—Ç–∫–ª—é—á–∏—Ç—å TorrServer/DNLA/Jackett/etc –º–æ–∂–Ω–æ –≤ module/manifest.json
2. –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Jackett –≤ module/JacRed.conf (–ø—Ä–∏–º–µ—Ä JacRed.example.conf)
3. –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤ init.conf (–ø—Ä–∏–º–µ—Ä example.conf)

# –ò—Å—Ç–æ—á–Ω–∏–∫–∏ –æ–Ω–ª–∞–π–Ω
Filmix, KinoPub, Alloha, Rezka, GetsTV, iptv.online, Kinobase, Zetflix, Collaps, Lumex, VDBmovies, VideoDB, Vibix, Videoseed, VeoVeo, HDVB, Kodik, Ashdi (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π), Eneyida (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π), KinoUKR (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π), FanCDN, Kinotochka, CDNmovies, Redheadsound, VoKino, Rutube, VK –í–∏–¥–µ–æ, Plvideo, Anilibria, AniLiberty, AniMedia, AnimeLib, MoonAnime (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π), Animevost, Animebesst, AnimeGo, HydraFlix (ENG), VidSrc (ENG), MovPI (ENG), Videasy (ENG), 2Embed (ENG), VidLink (ENG), AutoEmbed (ENG), SmashyStream (ENG), PlayEmbed (ENG), RgShows (ENG)

# –ò—Å—Ç–æ—á–Ω–∏–∫–∏ 18+
PornHub, PornHubPremium, Bongacams, Chaturbate, Cam4, Ebalovo, Eporner, HQporner, Porntrex, Spankbang, Xhamster, Xnxx, Xvideos, Lenporno, Porno365, Vtrahe, RUSporno, ProstoPorno, PornOne, Brazzrus, FilmAdult, Sosushka, Youjizz, NoodleMagazine, Veporn, XXXperevod, Huyamba, Pornk, PornoAkt, Porn4days, Beeg, Porndig, 24video, yaeby, trahkino, sex-studentki, hochu.tv, oxax.tv, Rusvideos, Porno666, Pornobolt, JopaOnline, Ebun, Pornobriz, 24rolika, SemBatsa, Lenkino, Ebasos, Vporno, BigBoss, GayPornTube

# –¢–æ—Ä—Ä–µ–Ω—Ç—ã
Kinozal, NNM-Club, Rutor, Rutracker, Megapeer, Torrentby, Bitru, Toloka (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π), BigFanGroup, Selezen, LostFilm, Anilibria, Animelayer, Anifilm

# –ò—Å—Ç–æ—á–Ω–∏–∫–∏ —Å API –¥–ª—è –ø–æ—Ä—Ç–∞–ª–æ–≤
* Filmix, Alloha, Lumex (VideoCDN), Kodik

# –ü—Ä–∏–≤—è–∑–∫–∞ PRO –∞–∫–∫–∞—É–Ω—Ç–æ–≤
* Filmix - http://IP:9118/lite/filmixpro
* KinoPub - http://IP:9118/lite/kinopubpro
* VoKino - http://IP:9118/lite/vokinotk
* HDRezka - http://IP:9118/lite/rhs/bind
* GetsTV - http://IP:9118/lite/getstv/bind
* iptv.online - http://IP:9118/lite/iptvonline/bind

# Remote Control Hub
–î–ª—è –±–∞–ª–∞–Ω—Å–µ—Ä–æ–≤ –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã –Ω–∞ VPS –Ω–æ –¥–æ—Å—Ç—É–ø–Ω—ã –≤ –≤–∞—à–µ–π —Å–µ—Ç–∏, –º–æ–∂–Ω–æ –≤–∫–ª—é—á–∏—Ç—å rhub –∏ –ø–∞—Ä—Å–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Å–∞–º–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ android/smart
```json
"Ashdi": {
  "rhub": true
},
"BongaCams": {
  "rhub": true
}
```

# –ü–ª–∞–≥–∏–Ω DLNA.js
* –ü—Ä–æ—Å–º–æ—Ç—Ä –º–µ–¥–∏–∞ —Ñ–∞–π–ª–æ–≤ —Å –ø–∞–ø–∫–∏ dlna
* –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —É–¥–∞–ª—è—Ç—å –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω—ã–µ –ø–∞–ø–∫–∏/—Ñ–∞–π–ª—ã
* –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤ –≤ –ø–∞–ø–∫—É dlna

–ó–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É "OK" –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–º —Ç–æ—Ä—Ä–µ–Ω—Ç–µ/–ø–∞–ø–∫–µ/—Ñ–∞–π–ª–µ –¥–ª—è –≤—ã–∑–æ–≤–∞ —Å–ø–∏—Å–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π

# –ü–ª–∞–≥–∏–Ω Sync.js
–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –º–µ–∂–¥—É —Ä–∞–∑–Ω—ã–º–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º–∏
* –î–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤—Å–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –≤ cub.red –ø–æ–¥ –æ–¥–Ω–∏–º –∞–∫–∫–∞—É–Ω—Ç–æ–º, –ª–∏–±–æ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö –≤–º–µ—Å—Ç–æ –ø–ª–∞–≥–∏–Ω–∞ IP:9118/sync.js, –¥–æ–ª–∂–µ–Ω –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è IP:9118/sync/js/{uid}, –≥–¥–µ {uid} —ç—Ç–æ –ª—é–±—ã–µ —Å–∏–º–≤–æ–ª—ã, –ª–∏–±–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –≤ accsdb, –Ω–∞–ø—Ä–∏–º–µ—Ä IP:9118/sync/js/myhome
* email –∏–ª–∏ {uid} –¥–æ–ª–∂–µ–Ω —Å–æ–≤–ø–∞–¥–∞—Ç—å –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö –∫–æ—Ç–æ—Ä—ã–µ –≤—ã —Ö–æ—Ç–∏—Ç–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–æ–≤–∞—Ç—å –º–µ–∂–¥—É —Å–æ–±–æ–π 
* –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∫—É–±–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç–∫–ª—é—á–µ–Ω–∞

# –ü–ª–∞–≥–∏–Ω Tracks.js
–ó–∞–º–µ–Ω—è–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ –∞—É–¥–∏–æ–¥–æ—Ä–æ–∂–µ–∫ –∏ —Å—É–±—Ç–∏—Ç—Ä–æ–≤ –≤ –ø–ª–µ–µ—Ä–µ

–ê–≤—Ç–æ—Ä: @aabytt

1. –î–æ–±–∞–≤–∏—Ç—å –ø–ª–∞–≥–∏–Ω "http://IP:9118/tracks.js" 
2. –í init.conf –∑–∞–º–µ–Ω–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ "ffprobe.os" –Ω–∞ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ "win", "linux"

# –ü–ª–∞–≥–∏–Ω TmdbProxy.js
–ü—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Å—Ç–µ—Ä–æ–≤ –¥–ª—è —Å–∞–π—Ç–∞ TMDB

1. –î–æ–±–∞–≤–∏—Ç—å –ø–ª–∞–≥–∏–Ω "http://IP:9118/tmdbproxy.js" 
2. –í –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö TMDB –≤–∫–ª—é—á–∏—Ç—å –ø—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ

# –ü–ª–∞–≥–∏–Ω Catalog.js
–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –∫–∞—Ç–∞–ª–æ–≥–∞ cub –∏ tmdb 

1. –î–æ–±–∞–≤–∏—Ç—å –ø–ª–∞–≥–∏–Ω "http://IP:9118/catalog.js" 
2. –í—ã–±—Ä–∞—Ç—å –∫–∞—Ç–∞–ª–æ–≥ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ª–∞–º–ø—ã "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ - –û—Å—Ç–∞–ª—å–Ω–æ–µ - –û—Å–Ω–æ–≤–Ω–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫"

# –î–æ—Å—Ç—É–ø –∫ –¥–æ–º–µ–Ω–∞–º .onion
1. –ó–∞–ø—É—Å—Ç–∏—Ç—å tor –Ω–∞ –ø–æ—Ä—Ç—É 9050
2. –í init.conf —É–∫–∞–∑–∞—Ç—å .onion –¥–æ–º–µ–Ω –≤ host

# Media Station X
1. Settings -> Start Parameter -> Setup
2. Enter current ip address and port "IP:9118"

–£–±—Ä–∞—Ç—å/–î–æ–±–∞–≤–∏—Ç—å –∞–¥—Ä–µ—Å–∞ –º–æ–∂–Ω–æ –≤ msx.json

# –í–∏–¥–∂–µ—Ç—ã
1. –î–ª—è Samsung "IP:9118/samsung.wgt"

# –†–∞–±–æ—Ç–∞ —Å –±–∞–∑–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö
* Microsoft.EntityFrameworkCore 9.0.8 - MS SQL Server, SQLite
* Npgsql 9.0.3 - PostgreSQL
* Pomelo.EntityFrameworkCore.MySql 9.0.0 - MariaDB, MySQL
* MongoDB.Driver 3.4.3 - MongoDB
* StackExchange.Redis 2.9.11 - Redis

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã init.conf
* checkOnlineSearch - –î–µ–ª–∞—Ç—å –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ —Å–∫—Ä—ã–≤–∞—è –±–∞–ª–∞–Ω—Å–µ—Ä—ã –±–µ–∑ –æ—Ç–≤–µ—Ç–∞
* multiaccess - –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–µ—à–∞ –≤ –æ–Ω–ª–∞–π–Ω —Å —É—á–µ—Ç–æ–º –º–Ω–æ–≥–æ–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
* accsdb - –î–æ—Å—Ç—É–ø –∫ API —á–µ—Ä–µ–∑ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é (–¥–ª—è jackett –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è apikey)
* useproxy - –ü–∞—Ä—Å–∏—Ç –∏—Å—Ç–æ—á–Ω–∏–∫ —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏ —É–∫–∞–∑–∞–Ω–Ω—ã–µ –≤ "proxy"
* streamproxy - –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç –≤–∏–¥–µ–æ —á–µ—Ä–µ–∑ "http://IP:9118/proxy/{uri}" 
* localip - –ó–∞–º–µ–Ω–∏—Ç—å –Ω–∞ "false" –µ—Å–ª–∏ —Å–∫—Ä–∏–ø—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π —Å–µ—Ç–∏
* findkp - –ö–∞—Ç–∞–ª–æ–≥ –¥–ª—è –ø–æ–∏—Å–∫ kinopoisk_id (alloha|tabus|vsdn)
* corseu - –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–æ–∫—Å–∏ cloudflare

# –ü—Ä–∏–º–µ—Ä init.conf
* –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, –∞ —Ç–∞–∫ –∂–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å–º–æ—Ç—Ä–µ—Ç—å –≤ current.conf –∏ example.conf 
* –í init.conf –Ω—É–∂–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã, –∫–æ—Ç–æ—Ä—ã–µ —Ö–æ—Ç–∏—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å
* –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å init.conf –º–æ–∂–Ω–æ —Ç–∞–∫ –∂–µ —á–µ—Ä–µ–∑ ip:9118/admin

```
{
  "listenport": 9120, // –∏–∑–º–µ–Ω–∏–ª–∏ –ø–æ—Ä—Ç
  "dlna": {
    "downloadSpeed": 25000000 // –æ–≥—Ä–∞–Ω–∏—á–∏–ª–∏ —Å–∫–æ—Ä–æ—Å—Ç—å –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ 200 Mbit/s
  },
  "Rezka": {
    "streamproxy": true // –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ –≤–∏–¥–µ–æ–ø–æ—Ç–æ–∫ —á–µ—Ä–µ–∑ "http://IP:9118/proxy/{uri}" 
  },
  "Zetflix": {
    "displayname": "Zetflix - 1080p", // –∏–∑–º–µ–Ω–∏–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ
    "geostreamproxy": ["UA"], // –ø–æ—Ç–æ–∫ –¥–ª—è UA –±—É–¥–µ—Ç –∏–¥—Ç–∏ —á–µ—Ä–µ–∑ "http://IP:9118/proxy/{uri}" 
    "apn": "http://apn.cfhttp.top" // –∑–∞–º–µ–Ω—è–µ–º –ø—Ä–æ–∫—Å–∏ "http://IP:9118/proxy/{uri}" –Ω–∞ "http://apn.cfhttp.top/{uri}"
  },
  "Kodik": {
    "useproxy": true, // –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–æ–∫—Å–∏
    "proxy": {        // –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å 91.1.1.1 –∏ 92.2.2.2
      "list": [
        "socks5://91.1.1.1:5481", // socks5
        "91.2.2.2:5481" // http
      ]
    }
  },
  "Ashdi": {
    "useproxy": true // –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–æ–∫—Å–∏ 93.3.3.3
  },
  "Filmix": {
    "token": "protoken" // –¥–æ–±–∞–≤–∏–ª–∏ —Ç–æ–∫–µ–Ω –æ—Ç PRO –∞–∫–∫–∞—É–Ω—Ç–∞
  },
  "PornHub": {
    "enable": false // –æ—Ç–∫–ª—é—á–∏–ª–∏ PornHub
  },
  "proxy": {
    "list": [
      "93.3.3.3:5481"
    ]
  },
  "globalproxy": [
    {
      "pattern": "\\.onion",  // –∑–∞–ø—Ä–æ—Å—ã –Ω–∞ –¥–æ–º–µ–Ω—ã .onion –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏
      "list": [
        "socks5://127.0.0.1:9050" // –ø—Ä–æ–∫—Å–∏ —Å–µ—Ä–≤–µ—Ä tor
      ]
    }
  ],
  "overrideResponse": [ // –ó–∞–º–µ–Ω–∏–ª–∏ –æ—Ç–≤–µ—Ç –Ω–∞ –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ñ–∞–π–ª–∞ myfile.json
    {
      "pattern": "/msx/start.json",
      "action": "file",
      "type": "application/json; charset=utf-8",
      "val": "myfile.json"
    }
  ]
}
```

# –û—à–∏–±–∫–∞: Illegal instruction
–ü—Ä–æ—Ü–µ—Å—Å–æ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ AVX

1. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ ImageMagick
```bash
apt install -y imagemagick libpng-dev libjpeg-dev libwebp-dev
```

2. –í init.conf –¥–æ–±–∞–≤—å—Ç–µ
```json
"imagelibrary": "ImageMagick"
```

3. –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è, –∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞
```json
"imagelibrary": "none"
```

```

## File: update.sh
```
#!/usr/bin/env bash
DEST="/home/lampac"
cd $DEST

VERSION=$1
if [ -n "$VERSION" ]; then
    echo "update lampac to version $VERSION"
    rm -f update.zip
    if ! curl -L -k -o update.zip "http://noah.lampac.sh/update/$VERSION.zip"; then
        echo "Failed to download update.zip. Exiting."
        exit 1
    fi
    if ! unzip -t update.zip; then
        echo "Failed to test update.zip. Exiting."
        exit 1
    fi
    systemctl stop lampac
    unzip -o update.zip
    rm -f update.zip
    echo -n $VERSION > data/vers-minor.txt
    systemctl start lampac
    exit
fi

ver=$(cat data/vers.txt)
gitver=$(curl --connect-timeout 10 -m 20 -k -s https://api.github.com/repos/immisterio/Lampac/releases/latest | grep tag_name | sed s/[^0-9]//g)
if [ $gitver -gt $ver ]; then
    echo "update lampac to version $gitver"
    rm -f update.zip
    if ! curl -L -k -o update.zip https://github.com/immisterio/Lampac/releases/latest/download/update.zip; then
        echo "Failed to download update.zip. Exiting."
        exit 1
    fi
    if ! unzip -t update.zip; then
        echo "Failed to test update.zip. Exiting."
        exit 1
    fi
    systemctl stop lampac
    unzip -o update.zip
    rm -f update.zip
    echo -n $gitver > data/vers.txt
    systemctl start lampac
else
    check_ping() {
        response=$(curl --connect-timeout 5 -m 10 -k -s "$1/ping")
        if [[ "$response" == *"pong"* ]]; then
            return 0
        else
            return 1
        fi
    }

    if check_ping "http://noah.lampac.sh"; then
        BASE_URL="http://noah.lampac.sh"
    elif check_ping "https://lampac.sh"; then
        BASE_URL="https://lampac.sh"
    else
        echo "minor updates are not available"
        exit 1
    fi

    mver=$(cat data/vers-minor.txt)
    dver=$(curl -k -s $BASE_URL/update/$ver.txt)
	
    if [[ ${#dver} -eq 8 && $dver != $mver ]]; then
        echo "update lampac to version $gitver.$mver"
        rm -f update.zip
        if ! curl -L -k -o update.zip "$BASE_URL/update/$dver.zip"; then
            echo "Failed to download update.zip. Exiting."
            exit 1
        fi
        if ! unzip -t update.zip; then
            echo "Failed to test update.zip. Exiting."
            exit 1
        fi
        systemctl stop lampac
        unzip -o update.zip
        rm -f update.zip
        echo -n $dver > data/vers-minor.txt
        systemctl start lampac
    else
        echo "lampac already current version $ver"
    fi
fi


# clear
rm -rf runtimes/wi*
rm -rf runtimes/os*

```

## File: install_home.sh
```
#!/usr/bin/env bash
DEST="/home/lampac"

# Become root
# sudo su -
apt-get update
apt-get install -y unzip curl coreutils libicu-dev

# Install .NET
if ! curl -L -k -o dotnet-install.sh https://dot.net/v1/dotnet-install.sh; then
   echo "Failed to download dotnet-install.sh. Exiting."
   exit 1
fi

chmod 755 dotnet-install.sh
./dotnet-install.sh --channel 9.0 --runtime aspnetcore --install-dir /usr/share/dotnet
ln -s /usr/share/dotnet/dotnet /usr/bin/dotnet

# Download zip
mkdir $DEST -p 
cd $DEST
if ! curl -L -k -o publish.zip https://github.com/immisterio/Lampac/releases/latest/download/publish.zip; then
   echo "Failed to download publish.zip. Exiting."
   exit 1
fi

unzip -o publish.zip
rm -f publish.zip

# automatic updates
curl -k -s https://api.github.com/repos/immisterio/Lampac/releases/latest | grep tag_name | sed s/[^0-9]//g > $DEST/data/vers.txt
curl -k -s https://raw.githubusercontent.com/immisterio/lampac/main/update.sh > $DEST/update.sh
chmod 755 $DEST/update.sh
#crontab -l | { cat; echo "$(shuf -i 10-55 -n 1) * * * * /bin/bash $DEST/update.sh"; } | crontab -

CRON_JOB="$(shuf -i 10-55 -n 1) * * * * /bin/bash $DEST/update.sh"
(crontab -l | grep -vF "/bin/bash $DEST/update.sh"; echo "$CRON_JOB") | crontab -

# init.conf
random_port=$(shuf -i 9000-12999 -n 1)
cat <<EOF > $DEST/init.conf
"listen": {
  "port": $random_port
},
"typecache": "mem",
"mikrotik": true,
"chromium": {
  "enable": false
},
"firefox": {
  "enable": false
},
"dlna": {
  "cover": {
    "enable": false
  }
},
"serverproxy": {
  "verifyip": false,
  "image": {
    "cache": false,
    "cache_rsize": false
  },
  "buffering": {
    "enable": false
  }
},
"Spankbang": {
  "rhub": true
},
"BongaCams": {
  "rhub": true
},
"Runetki": {
  "rhub": true
},
"VDBmovies": {
  "rhub": true,
  "spider": false
},
"VideoDB": {
  "rhub": true
},
"FanCDN": {
  "rhub": true
},
"Lumex": {
  "spider": false
}
EOF

# manifest.json
cat <<EOF > $DEST/module/manifest.json
[
  {
    "enable": true,
    "dll": "SISI.dll"
  },
  {
    "enable": true,
    "dll": "Online.dll"
  },
  {
    "enable":true,
    "initspace":"Catalog.ModInit",
    "dll":"Catalog.dll"
  },
  {
    "enable": true,
    "dll": "DLNA.dll"
  },
  {
    "enable": true,
    "initspace": "Jackett.ModInit",
    "dll": "JacRed.dll"
  },
  {
    "enable": false,
    "initspace": "TorrServer.ModInit",
    "dll": "TorrServer.dll"
  }
]
EOF

# Lampac.runtimeconfig.json
cat <<EOF > $DEST/Lampac.runtimeconfig.json
{
  "runtimeOptions": {
    "tfm": "net9.0",
    "frameworks": [
      {
        "name": "Microsoft.NETCore.App",
        "version": "9.0.0"
      },
      {
        "name": "Microsoft.AspNetCore.App",
        "version": "9.0.0"
      }
    ],
    "configProperties": {
      "System.GC.Server": false,
      "System.Reflection.Metadata.MetadataUpdater.IsSupported": false,
      "System.Reflection.NullabilityInfoContext.IsSupported": true,
      "System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization": false
    }
  }
}
EOF

# Create service
echo ""
echo "Install service to /etc/systemd/system/lampac.service ..."
touch /etc/systemd/system/lampac.service && chmod 664 /etc/systemd/system/lampac.service
cat <<EOF > /etc/systemd/system/lampac.service
[Unit]
Description=Lampac
Wants=network.target
After=network.target
[Service]
WorkingDirectory=$DEST
ExecStart=/usr/bin/dotnet Lampac.dll
#ExecReload=/bin/kill -s HUP $MAINPID
#ExecStop=/bin/kill -s QUIT $MAINPID
Restart=always
[Install]
WantedBy=multi-user.target
EOF

# Enable service
systemctl daemon-reload
systemctl enable lampac

# update minor
echo -n "1" > $DEST/data/vers-minor.txt
/bin/bash $DEST/update.sh

# clear
cd $DEST
rm -f data/*.json
rm -rf merchant wwwroot/bwa
rm -rf runtimes/wi*
rm -rf runtimes/os*
rm -rf runtimes/linux-m*

# clear runtimes
case $(uname -m) in
    x86_64)
        rm -rf runtimes/linux-a*
        ;;
    armv7l)
        rm -rf runtimes/linux-arm64
		rm -rf runtimes/linux-x64
        ;;
    aarch64)
        rm -rf runtimes/linux-arm
		rm -rf runtimes/linux-x64
        ;;
    *)
        echo ""
        ;;
esac

# done
systemctl start lampac

# iptables drop
cat <<EOF > iptables-drop.sh
#!/bin/sh
echo "Stopping firewall and allowing everyone..."
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT
EOF

get_external_ip() {
   local ip
   ip=$(curl -s --connect-timeout 5 https://api.ipify.org 2>/dev/null)
   if [ -z "$ip" ]; then
      ip=$(curl -s --connect-timeout 5 https://icanhazip.com 2>/dev/null)
   fi
   if [ -z "$ip" ]; then
      ip=$(curl -s --connect-timeout 5 https://ifconfig.me 2>/dev/null)
   fi
   echo "${ip:-IP}"
}

# Note
echo ""
echo "################################################################"
echo ""
echo "Have fun!"
echo ""
echo "http://$(get_external_ip):$random_port"
echo ""
echo "Please check/edit $DEST/init.conf params and configure it"
echo ""
echo "Then [re]start it as systemctl [re]start lampac"
echo ""
echo "Clear iptables if port $random_port is not available"
echo "bash $DEST/iptables-drop.sh"
echo ""

```

## File: Termux/install.sh
```
#!/bin/bash

pkg install tmux proot-distro -y
proot-distro install debian

# Start Debian
proot-distro login debian

# Install packages
apt-get update
apt-get install -y curl unzip
apt-get install -y libicu-dev
apt-get install -y libicu72
apt-get install -y libicu76

# Install .NET 9
curl -L -k -o dotnet-install.sh https://dot.net/v1/dotnet-install.sh
chmod 755 dotnet-install.sh
./dotnet-install.sh --channel 9.0 --runtime aspnetcore --install-dir /usr/share/dotnet
ln -s /usr/share/dotnet/dotnet /usr/bin/dotnet
rm dotnet-install.sh

# clear .NET 6
rm -f *.dll
rm -f *.pdb
rm -f GeoLite2-Country.mmdb vers-minor.txt
rm -rf runtimes nginx
rm -rf .playwright

for lang in cs de es fr it ja ko pl pt-BR ru tr zh-Hans zh-Hant; do
    rm -rf $lang
done

# Download zip
curl -L -k -o publish.zip https://github.com/immisterio/Lampac/releases/latest/download/publish.zip
unzip -o publish.zip
rm -f publish.zip

echo -n "termux" > passwd

# init.conf
cat <<EOF > init.conf
{
  "typecache": "mem",
  "mikrotik": true,
  "pirate_store": false,
  "listen": {
    "compression": false
  },
  "chromium": {
    "enable": false
  },
  "firefox": {
    "enable": false
  },
  "dlna": {
    "enable": false,
    "autoupdatetrackers": false
  },
  "cub": {
    "enable": false
  },
  "tmdb": {
    "enable": false
  },
  "weblog": {
    "enable": true
  },
  "LampaWeb": {
    "initPlugins": {
      "dlna": false,
      "tracks": false,
      "tmdbProxy": false,
      "online": true,
      "sisi": true,
      "timecode": true,
      "torrserver": false,
      "backup": true,
      "sync": false
    }
  },
  "serverproxy": {
    "enable": true,
    "verifyip": false,
    "encrypt_aes": true,
    "image": {
      "cache": false,
      "cache_rsize": false
    },
    "buffering": {
      "enable": false
    }
  },
  "online": {
    "checkOnlineSearch": false
  },
  "sisi": {
    "rsize": false
  },
  "Spankbang": {
    "rhub": true
  },
  "BongaCams": {
    "rhub": true
  },
  "Runetki": {
    "rhub": true
  },
  "VDBmovies": {
    "rhub": true,
    "spider": false
  },
  "VideoDB": {
    "rhub": true
  },
  "FanCDN": {
    "rhub": true
  }
}
EOF

# manifest.json
cat <<EOF > module/manifest.json
[
  {
    "enable": true,
    "dll": "SISI.dll"
  },
  {
    "enable": true,
    "dll": "Online.dll"
  }
]
EOF

# update info
curl -k -s https://api.github.com/repos/immisterio/Lampac/releases/latest | grep tag_name | sed s/[^0-9]//g > data/vers.txt
echo -n "1" > data/vers-minor.txt

# update.sh
cat <<EOF > update.sh
#!/usr/bin/env bash

ver=$(cat data/vers.txt)
gitver=$(curl --connect-timeout 10 -m 20 -k -s https://api.github.com/repos/immisterio/Lampac/releases/latest | grep tag_name | sed s/[^0-9]//g)
if [ $gitver -gt $ver ]; then
    echo "update lampac to version $gitver"
    rm -f update.zip
    if ! curl -L -k -o update.zip https://github.com/immisterio/Lampac/releases/latest/download/update.zip; then
        echo "Failed to download update.zip. Exiting."
        exit 1
    fi
    if ! unzip -t update.zip; then
        echo "Failed to test update.zip. Exiting."
        exit 1
    fi
    unzip -o update.zip
    rm -f update.zip
    echo -n $gitver > data/vers.txt
else
    check_ping() {
        response=$(curl --connect-timeout 5 -m 10 -k -s "$1/ping")
        if [[ "$response" == *"pong"* ]]; then
            return 0
        else
            return 1
        fi
    }

    if check_ping "http://noah.lampac.sh"; then
        BASE_URL="http://noah.lampac.sh"
    elif check_ping "https://lampac.sh"; then
        BASE_URL="https://lampac.sh"
    else
        echo "minor updates are not available"
        exit 1
    fi

    mver=$(cat data/vers-minor.txt)
    dver=$(curl -k -s $BASE_URL/update/$ver.txt)
	
    if [[ ${#dver} -eq 8 && $dver != $mver ]]; then
        echo "update lampac to version $gitver.$mver"
        rm -f update.zip
        if ! curl -L -k -o update.zip "$BASE_URL/update/$dver.zip"; then
            echo "Failed to download update.zip. Exiting."
            exit 1
        fi
        if ! unzip -t update.zip; then
            echo "Failed to test update.zip. Exiting."
            exit 1
        fi
        unzip -o update.zip
        rm -f update.zip
        echo -n $dver > data/vers-minor.txt
    else
        echo "lampac already current version $ver"
    fi
fi

rm -f data/GeoLite2-Country.mmdb
rm -rf .playwright merchant torrserver wwwroot/bwa
rm -rf data/widgets
rm -rf runtimes/wi*
rm -rf runtimes/os*
rm -rf runtimes/linux-m*
rm -rf runtimes/linux-arm
rm -rf runtimes/linux-x64
EOF

# update minor
/bin/bash update.sh

# Lampac.runtimeconfig.json
cat <<EOF > Lampac.runtimeconfig.json
{
  "runtimeOptions": {
    "tfm": "net9.0",
    "frameworks": [
      {
        "name": "Microsoft.NETCore.App",
        "version": "9.0.0"
      },
      {
        "name": "Microsoft.AspNetCore.App",
        "version": "9.0.0"
      }
    ],
    "configProperties": {
      "System.GC.Server": false,
      "System.Reflection.Metadata.MetadataUpdater.IsSupported": false,
      "System.Reflection.NullabilityInfoContext.IsSupported": true,
      "System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization": false
    }
  }
}
EOF

# clear
rm -f data/GeoLite2-Country.mmdb
rm -rf .playwright merchant torrserver wwwroot/bwa
rm -rf data/widgets
rm -rf runtimes/wi*
rm -rf runtimes/os*
rm -rf runtimes/linux-m*
rm -rf runtimes/linux-arm
rm -rf runtimes/linux-x64

# Clean packages cache
apt-get clean && rm -rf /var/lib/apt/lists/*

#exit from Debian
exit

cat <<EOF > start.sh
#!/bin/bash

tmux new-session -d -s Lampac "proot-distro login debian -- dotnet Lampac.dll"
EOF

cat <<EOF > stop.sh
#!/bin/bash

tmux kill-session -a -t Lampac
EOF

cat <<EOF > restart.sh
#!/bin/bash

bash stop.sh
bash start.sh
EOF

cat <<EOF > update.sh
#!/bin/bash

proot-distro login debian
bash update.sh
exit
EOF

# Run Motherfucker Run 
ln -s /data/data/com.termux/files/usr/var/lib/proot-distro/installed-rootfs/debian/ debian
tmux new-session -d -s Lampac "proot-distro login debian -- dotnet Lampac.dll"

# Note
echo ""
echo "################################################################"
echo ""
echo "Have fun!"
echo ""
echo "http://127.0.0.1:9118"
echo ""
echo "Please check/edit http://127.0.0.1:9118/admin/init params and configure it"
echo ""

```

## File: Termux/README.md
```
<b>Supports:</b> smartphone, tablet, tv-box aosp
<br><b>Note:</b> Android TV (ATV) not support! 

# Download Termux
–°–∫–∞—á–∞–π—Ç–µ –∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ Termux —Å <a href="https://play.google.com/store/apps/details?id=com.termux&hl=ru" target="_blank">Google Play</a> or <a href="https://github.com/termux/termux-app/releases" target="_blank">GitHub official</a>  or  <a href="https://f-droid.org/ru/packages/com.termux/" target="_blank">F-Droid</a>

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ Lampac
–ó–∞–ø—É—Å—Ç–∏—Ç–µ Termux –∏ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É
```
curl -L -k -s https://lampac.sh/termux | bash
```
–°–ø–∞—Å–∏–±–æ @bbk14

# –ü–ª–∞–≥–∏–Ω—ã
http://127.0.0.1:9118 - –ª–∞–º–ø–∞ –±–µ–∑ —Ä–µ–∫–ª–∞–º—ã<br>
http://127.0.0.1:9118/online.js - –æ–Ω–ª–∞–π–Ω <br>
http://127.0.0.1:9118/sisi.js - 18+

# –ò—Å—Ç–æ—á–Ω–∏–∫–∏
https://github.com/immisterio/Lampac?tab=readme-ov-file#%D0%B8%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8
* Zetflix –∏ ENG —Å–∞–π—Ç—ã –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤ Termux 

# –ö–æ–º–∞–Ω–¥—ã –≤ Termux
```
bash stop.sh
bash start.sh
bash restart.sh
bash update.sh # –æ–±–Ω–æ–≤–∏—Ç—å –≤–µ—Ä—Å–∏—é lampac
```

# –í–∞–∂–Ω–æ
* –ò–∑–º–µ–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ –ø—Ä–∏–≤—è–∑–∞—Ç—å pro –∞–∫–∫–∞—É–Ω—Ç—ã –º–æ–∂–Ω–æ —á–µ—Ä–µ–∑ http://127.0.0.1:9118/admin
* –ò–∑ –∑–∞ –Ω–∏–∑–∫–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ termux, –≤–∫–ª—é—á–∞—Ç—å chrome/firefox/torrserver/proxy/jacred/dlna –Ω–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –æ—Ç —Å–ª–æ–º–∞ —Å–æ–≤—Å–µ–º
* –ù–∞ –±–∞–ª–∞–Ω—Å–µ—Ä–∞—Ö —Å –æ—Ç–∫–ª—é—á—ë–Ω–Ω—ã–º streamproxy –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ –≤–Ω–µ—à–Ω–∏–π –ø–ª–µ–µ—Ä Vimu, MPV, MX player —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π headers, –∏–Ω–∞—á–µ –≤–∏–¥–µ–æ –Ω–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∞–ª–∞–Ω—Å–µ—Ä–∞—Ö –±—É–¥–µ—Ç –≤—ã–¥–∞–≤–∞—Ç—å –æ—à–∏–±–∫—É –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è

```

## File: SISI/SisiApi.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Base;
using Shared.Models.Events;
using Shared.Models.Module;
using Shared.Models.Module.Entrys;
using Shared.PlaywrightCore;
using System.Reflection;
using System.Text;
using System.Web;
using IO = System.IO;

namespace SISI
{
    public class SisiApiController : BaseController
    {
        #region sisi.js
        [HttpGet]
        [AllowAnonymous]
        [Route("sisi.js")]
        [Route("sisi/js/{token}")]
        public ContentResult Sisi(string token, bool lite)
        {
            if (lite)
                return Content(FileCache.ReadAllText("plugins/sisi.lite.js").Replace("{localhost}", host), "application/javascript; charset=utf-8");

            var init = AppInit.conf.sisi;
            var apr = init.appReplace ?? InvkEvent.conf?.Controller?.AppReplace?.sisi?.regex;

            string memKey = $"sisi.js:{apr?.Count ?? 0}:{init.component}:{init.iconame}:{host}:{init.push_all}:{init.forced_checkRchtype}";
            if (!memoryCache.TryGetValue(memKey, out (string file, string filecleaer) cache))
            {
                cache.file = FileCache.ReadAllText("plugins/sisi.js", saveCache: false)
                    .Replace("{rch_websoket}", FileCache.ReadAllText($"plugins/rch_{AppInit.conf.rch.websoket}.js", saveCache: false));

                #region appReplace
                if (apr != null)
                {
                    foreach (var r in apr)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        cache.file = Regex.Replace(cache.file, r.Key, val, RegexOptions.IgnoreCase);
                    }
                }

                if (InvkEvent.conf?.Controller?.AppReplace?.sisi?.list != null)
                {
                    foreach (var r in InvkEvent.conf.Controller.AppReplace.sisi.list)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        cache.file = cache.file.Replace(r.Key, val);
                    }
                }
                #endregion

                var bulder = new StringBuilder(cache.file);

                if (!init.spider)
                    bulder = bulder.Replace("Lampa.Search.addSource(Search);", "");

                if (init.component != "sisi")
                {
                    bulder = bulder.Replace("use_api: 'lampac'", $"use_api: '{init.component}'");
                    bulder = bulder.Replace("'plugin_sisi_'", $"'plugin_{init.component}_'");
                }

                if (!string.IsNullOrEmpty(init.vipcontent))
                    bulder = bulder.Replace("var content = [^\n\r]+", init.vipcontent);

                if (!string.IsNullOrEmpty(init.iconame))
                {
                    bulder = bulder.Replace("Defined.use_api == 'pwa'", "true")
                                   .Replace("'<div>p</div>'", $"'<div>{init.iconame}</div>'");
                }

                bulder = bulder
                    .Replace("{invc-rch}", FileCache.ReadAllText("plugins/invc-rch.js", saveCache: false))
                    .Replace("{invc-rch_nws}", FileCache.ReadAllText("plugins/invc-rch_nws.js", saveCache: false))
                    .Replace("{push_all}", init.push_all.ToString().ToLower())
                    .Replace("{localhost}", host)
                    .Replace("{historySave}", AppInit.conf.sisi.history.enable.ToString().ToLower());

                if (init.forced_checkRchtype)
                    bulder = bulder.Replace("window.rchtype", "Defined.rchtype");

                cache.file = bulder.ToString();
                cache.filecleaer = cache.file.Replace("{token}", string.Empty);

                if (AppInit.conf.mikrotik == false)
                    memoryCache.Set(memKey, cache, DateTime.Now.AddMinutes(1));
            }

            if (InvkEvent.conf?.Controller?.AppReplace?.sisi?.eval != null)
            {
                string source = InvkEvent.AppReplace("sisi", new EventAppReplace(cache.file, token, null, host, requestInfo, HttpContext.Request, hybridCache));
                return Content(source.Replace("{token}", HttpUtility.UrlEncode(token)), "application/javascript; charset=utf-8");
            }

            return Content(token != null ? cache.file.Replace("{token}", HttpUtility.UrlEncode(token)) : cache.filecleaer, "application/javascript; charset=utf-8");
        }
        #endregion

        #region modification.js
        [HttpGet]
        [AllowAnonymous]
        [Route("sisi/plugins/modification.js")]
        public ActionResult SisiModification()
        {
            string file = FileCache.ReadAllText("wwwroot/sisi/plugins/modification.js");

            if (!AppInit.conf.sisi.xdb)
                file = file.Replace("addId();", "");

            file = Regex.Replace(file, "\\{localhost\\}/?", $"{host}/sisi");
            return Content(file, contentType: "application/javascript; charset=utf-8");
        }
        #endregion


        [Route("sisi")]
        async public ValueTask<JsonResult> Index(string rchtype, string account_email, string uid, string token, bool spder)
        {
            var conf = AppInit.conf;
            JObject kitconf = await loadKitConf();

            var channels = new List<ChannelItem>(conf.sisi.NextHUB ? 50 : 20) 
            {
                new ChannelItem("–ó–∞–∫–ª–∞–¥–∫–∏", $"{host}/sisi/bookmarks", 0)
            };

            if (conf.sisi.history.enable)
                channels.Add(new ChannelItem("–ò—Å—Ç–æ—Ä–∏—è", $"{host}/sisi/historys", 1));

            #region modules
            SisiModuleEntry.EnsureCache();

            if (SisiModuleEntry.sisiModulesCache != null && SisiModuleEntry.sisiModulesCache.Count > 0)
            {
                var args = new SisiEventsModel(rchtype, account_email, uid, token);

                foreach (var entry in SisiModuleEntry.sisiModulesCache)
                {
                    try
                    {
                        if (entry.Invoke != null)
                        {
                            try
                            {
                                var result = entry.Invoke(HttpContext, memoryCache, requestInfo, host, args);
                                if (result != null && result.Count > 0)
                                    channels.AddRange(result);
                            }
                            catch { }
                        }

                        if (entry.InvokeAsync != null)
                        {
                            try
                            {
                                var result = await entry.InvokeAsync(HttpContext, memoryCache, requestInfo, host, args);
                                if (result != null && result.Count > 0)
                                    channels.AddRange(result);
                            }
                            catch { }
                        }

                        if (entry.Events != null)
                        {
                            try
                            {
                                var result = entry.Events(host);
                                if (result != null && result.Count > 0)
                                    channels.AddRange(result);
                            }
                            catch { }
                        }
                    }
                    catch (Exception ex) { Console.WriteLine($"Modules {entry.mod?.NamespacePath(entry.mod.sisi)}: {ex.Message}\n\n"); }
                }
            }
            #endregion

            #region send
            void send(string name, BaseSettings _init, string plugin = null, string rch_access = null, int displayindex = -1)
            {
                var init = loadKit(_init, kitconf);
                bool enable = init.enable && !init.rip;
                if (!enable)
                    return;

                if (spder == true && init.spider != true)
                    return;

                if (init.rhub && !init.rhub_fallback)
                {
                    if (rch_access != null && rchtype != null)
                    {
                        enable = rch_access.Contains(rchtype);
                        if (enable && init.rhub_geo_disable != null)
                        {
                            if (requestInfo.Country != null && init.rhub_geo_disable.Contains(requestInfo.Country))
                                enable = false;
                        }
                    }
                }

                if (!enable)
                    return;

                if (init.client_type != null && rchtype != null)
                    enable = init.client_type.Contains(rchtype);

                if (init.geo_hide != null)
                {
                    if (requestInfo.Country != null && init.geo_hide.Contains(requestInfo.Country))
                        enable = false;
                }

                if (enable)
                {
                    if (init.group > 0 && init.group_hide)
                    {
                        var user = requestInfo.user;
                        if (user == null || init.group > user.group)
                            return;
                    }

                    string url = string.Empty;

                    if (string.IsNullOrEmpty(init.overridepasswd))
                    {
                        url = init.overridehost;
                        if (string.IsNullOrEmpty(url) && init.overridehosts != null && init.overridehosts.Length > 0)
                            url = init.overridehosts[Random.Shared.Next(0, init.overridehosts.Length)];
                    }

                    string displayname = init.displayname ?? name;

                    if (string.IsNullOrEmpty(url))
                        url = $"{host}/{plugin ?? name.ToLower()}";

                    if (displayindex == -1)
                    {
                        displayindex = init.displayindex;
                        if (displayindex == 0)
                            displayindex = 20 + channels.Count;
                    }

                    channels.Add(new ChannelItem(init.displayname ?? name, url, displayindex));
                }
            }
            #endregion

            #region NextHUB
            if (conf.sisi.NextHUB)
            {
                foreach (string inFile in Directory.GetFiles("NextHUB/sites", "*.yaml"))
                {
                    try
                    {
                        if (inFile.Contains(".my."))
                            continue;

                        string plugin = Path.GetFileNameWithoutExtension(inFile);
                        if (!conf.sisi.lgbt && plugin == "gayporntube")
                            continue;

                        var init = Controllers.NextHUB.Root.goInit(plugin);
                        if (init == null)
                            continue;

                        if (init.debug)
                            Console.WriteLine("\n" + JsonConvert.SerializeObject(init, Formatting.Indented));

                        if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                        {
                            if (init.priorityBrowser != "http" || (init.view != null && init.view.viewsource == false))
                            {
                                if (AppInit.conf.multiaccess == false)
                                    Console.WriteLine($"NextHUB: {plugin} - Playwright is disabled, skipping.");
                                continue;
                            }
                        }

                        send(Regex.Replace(init.host, "^https?://", ""), init, $"nexthub?plugin={plugin}", init.client_type);
                    }
                    catch (YamlDotNet.Core.YamlException ex)
                    {
                        Console.WriteLine($"\n–û—à–∏–±–∫–∞: {ex.Message}\n—Ñ–∞–π–ª: {Path.GetFileName(inFile)}\n—Å—Ç—Ä–æ–∫–∞: {ex.Start.Line}");
                    }
                    catch (Exception ex) { Console.WriteLine($"NextHUB: error DeserializeObject {inFile}\n {ex.Message}"); }
                }
            }
            #endregion

            send("pornhubpremium.com", conf.PornHubPremium, "phubprem"); // !rhub
            send("pornhub.com", conf.PornHub, "phub", "apk,cors");
            send("xvideos.com", conf.Xvideos, "xds", "apk,cors");
            send("xhamster.com", conf.Xhamster, "xmr", "apk,cors");
            send("ebalovo.porn", conf.Ebalovo, "elo", "apk");
            send("hqporner.com", conf.HQporner, "hqr", "apk,cors");

            if (conf.Spankbang.priorityBrowser == "http" || conf.Spankbang.rhub || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Spankbang.overridehost) || conf.Spankbang.overridehosts?.Length > 0)
                send("spankbang.com", conf.Spankbang, "sbg");

            send("eporner.com", conf.Eporner, "epr", "apk,cors");
            send("porntrex.com", conf.Porntrex, "ptx", "apk");
            send("xdsred", conf.XvideosRED, "xdsred");  // !rhub
            send("xnxx.com", conf.Xnxx, "xnx", "apk,cors");
            send("tizam.pw", conf.Tizam, "tizam", "apk,cors");

            if (conf.BongaCams.priorityBrowser == "http" || conf.BongaCams.rhub || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.BongaCams.overridehost) || conf.BongaCams.overridehosts?.Length > 0)
                send("bongacams.com", conf.BongaCams, "bgs", "apk");

            if (conf.Runetki.priorityBrowser == "http" || conf.Runetki.rhub || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Runetki.overridehost) || conf.Runetki.overridehosts?.Length > 0)
                send("runetki.com", conf.Runetki, "runetki", "apk");

            send("chaturbate.com", conf.Chaturbate, "chu", "apk,cors");

            if (conf.sisi.lgbt)
            {
                send("phubgay", conf.PornHub, "phubgay", "apk,cors", 10_100);
                send("phubtrans", conf.PornHub, "phubsml", "apk,cors", 10_101);
                send("xdsgay", conf.Xvideos, "xdsgay", "apk,cors", 10_102);
                send("xdstrans", conf.Xvideos, "xdssml", "apk,cors", 10_103);
                send("xmrgay", conf.Xhamster, "xmrgay", "apk,cors", 10_104);
                send("xmrtrans", conf.Xhamster, "xmrsml", "apk,cors", 10_105);
            }

            if (conf.sisi.xdb)
            {
                try
                {
                    var ch = await Http.Get<JObject>("https://vi.sisi.am", timeoutSeconds: 4);

                    foreach (var pl in ch.GetValue("channels"))
                    {
                        string title = pl.Value<string>("title").Replace("pornhubpremium.com", "phubprem.com");
                        string playlist_url = pl.Value<string>("playlist_url");

                        if (playlist_url.Contains("/bookmarks"))
                            continue;

                        if (channels.FirstOrDefault(i => i.title == title).title != null)
                            continue;

                        channels.Add(new ChannelItem(title, playlist_url, 20 + channels.Count));
                    }
                }
                catch { }
            }

            return Json(new
            {
                title = "sisi",
                channels = channels.OrderBy(i => i.displayindex)
            });
        }
    }
}

```

## File: SISI/ModInit.cs
```
Ôªøusing Microsoft.EntityFrameworkCore;
using Shared.Models.SQL;
using System.Threading;

namespace SISI
{
    public class ModInit
    {
        private static Timer cleanupTimer;

        public static void loaded()
        {
            Directory.CreateDirectory("wwwroot/bookmarks/img");
            Directory.CreateDirectory("wwwroot/bookmarks/preview");

            cleanupTimer = new Timer(_ => CleanupHistory(), null, TimeSpan.FromMinutes(20), TimeSpan.FromHours(1));
        }

        private static void CleanupHistory()
        {
            try
            {
                var threshold = DateTime.UtcNow.AddDays(-AppInit.conf.sisi.history.days);

                using (var sqlDb = new SisiContext())
                {
                    sqlDb.historys
                        .AsNoTracking()
                        .Where(i => i.created < threshold)
                        .ExecuteDelete();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[SISI] Cleanup history failed: {ex.Message}");
            }
        }
    }
}

```

## File: SISI/BookmarkController.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Newtonsoft.Json;
using Shared.Models.SQL;
using System.Web;

namespace SISI
{
    public class BookmarkController : BaseSisiController
    {
        [Route("sisi/bookmarks")]
        public ActionResult List(string search, string model, int pg = 1, int pageSize = 36)
        {
            string md5user = getuser();
            if (md5user == null)
                return OnError("access denied");

            var menu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = $"{host}/sisi/bookmarks",
                }
            };

            #region bookmarks
            var bookmarks = new List<PlaylistItem>();
            var bookmarksQuery = new List<SisiBookmarkSqlModel>();

            using (var sqlDb = new SisiContext())
            {
                bookmarksQuery = sqlDb.bookmarks
                    .AsNoTracking()
                    .Where(i => i.user == md5user)
                    .ToList();
            }

            int total_pages = Math.Max(0, bookmarksQuery.Count / pageSize) + 1;

            #region –ú–æ–¥–µ–ª—å
            var menu_models = new MenuItem()
            {
                title = $"–ú–æ–¥–µ–ª—å: {model ?? "–≤—ã–±—Ä–∞—Ç—å"}",
                playlist_url = "submenu",
                submenu = new List<MenuItem>(20)
            };

            foreach (var m in bookmarksQuery.OrderByDescending(i => i.created).Select(i => i.model).ToHashSet())
            {
                if (string.IsNullOrEmpty(m))
                    continue;

                menu_models.submenu.Add(new MenuItem()
                {
                    title = m,
                    playlist_url = $"{host}/sisi/bookmarks?model={HttpUtility.UrlEncode(m)}"
                });
            }

            if (menu_models.submenu.Count > 0)
                menu.Add(menu_models);
            #endregion

            var items = bookmarksQuery
                .OrderByDescending(i => i.created)
                .Skip((pg * pageSize) - pageSize)
                .Take(pageSize);

            if (!string.IsNullOrEmpty(search))
            {
                string _s = StringConvert.SearchName(search);
                items = items.Where(i => i.name != null && StringConvert.SearchName(i.name).Contains(_s));
            }

            if (!string.IsNullOrEmpty(model))
                items = items.Where(i => i.model == model);

            if (items.Any())
            {
                foreach (var json in items.Select(i => i.json))
                {
                    if (string.IsNullOrEmpty(json))
                        continue;

                    try
                    {
                        var bookmark = JsonConvert.DeserializeObject<PlaylistItem>(json);
                        if (bookmark != null)
                            bookmarks.Add(bookmark);
                    }
                    catch { }
                }
            }
            #endregion

            #region getvideLink
            string getvideLink(PlaylistItem pl)
            {
                if (pl.bookmark.site is "phub" or "phubprem")
                    return $"{host}/{pl.bookmark.site}/vidosik?vkey={HttpUtility.UrlEncode(pl.bookmark.href)}";

                return $"{host}/{pl.bookmark.site}/vidosik?uri={HttpUtility.UrlEncode(pl.bookmark.href)}";
            }
            #endregion

            string localhost = $"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}";

            return new JsonResult(new
            {
                menu,
                list = bookmarks.Select(pl => new
                {
                    pl.name,
                    video = getvideLink(pl),
                    picture = HostImgProxy(pl.bookmark.image.StartsWith("bookmarks/") ? $"{localhost}/{pl.bookmark.image}" : pl.bookmark.image, plugin: pl.bookmark.site),
                    pl.time,
                    pl.json,
                    related = pl.related || Regex.IsMatch(pl.bookmark.site, "^(elo|epr|fph|phub|sbg|xmr|xnx|xds)"),
                    pl.quality,
                    preview = pl.preview != null && pl.preview.StartsWith("bookmarks/") ? $"{host}/{pl.preview}" : null,
                    pl.model,
                    bookmark = new Bookmark() { uid = pl.bookmark.uid }
                }).ToArray(),
                total_pages
            });
        }


        [HttpPost]
        [Route("sisi/bookmark/add")]
        public async Task<ActionResult> Add([FromBody] PlaylistItem data)
        {
            string md5user = getuser();
            if (md5user == null || data == null || string.IsNullOrEmpty(data?.bookmark?.site) || string.IsNullOrEmpty(data?.bookmark?.href))
                return OnError("access denied");

            string uid = CrypTo.md5($"{data.bookmark.site}:{data.bookmark.href}");

            using (var sqlDb = new SisiContext())
            {
                if (!sqlDb.bookmarks.AsNoTracking().Any(i => i.user == md5user && i.uid == uid))
                {
                    string newimage = null;

                    #region download image
                    if (AppInit.conf.sisi.bookmarks.saveimage)
                    {
                        string pimg = $"bookmarks/img/{uid.Substring(0, 2)}/{uid.Substring(2)}.jpg";

                        if (System.IO.File.Exists($"wwwroot/{pimg}"))
                        {
                            newimage = pimg;
                        }
                        else
                        {
                            var image = await Http.Download(data.bookmark.image, timeoutSeconds: 7);
                            if (image != null)
                            {
                                Directory.CreateDirectory($"wwwroot/bookmarks/img/{uid.Substring(0, 2)}");
                                System.IO.File.WriteAllBytes($"wwwroot/{pimg}", image);
                                newimage = pimg;
                            }
                        }
                    }
                    #endregion

                    #region download preview
                    if (AppInit.conf.sisi.bookmarks.savepreview)
                    {
                        if (data.preview != null)
                        {
                            string path = $"bookmarks/preview/{uid.Substring(0, 2)}/{uid.Substring(2)}.{(data.preview.Contains(".webm") ? "webm" : "mp4")}";

                            if (System.IO.File.Exists($"wwwroot/{path}"))
                            {
                                data.preview = path;
                            }
                            else
                            {
                                var preview = await Http.Download(data.preview, timeoutSeconds: 8);
                                if (preview != null)
                                {
                                    Directory.CreateDirectory($"wwwroot/bookmarks/preview/{uid.Substring(0, 2)}");
                                    System.IO.File.WriteAllBytes($"wwwroot/{path}", preview);
                                    data.preview = path;
                                }
                            }
                        }
                    }
                    #endregion

                    var b = data.bookmark;
                    data.bookmark = new Bookmark()
                    {
                        href = b.href,
                        image = newimage ?? b.image,
                        site = b.site,
                        uid = uid
                    };

                    sqlDb.bookmarks.Add(new SisiBookmarkSqlModel
                    {
                        user = md5user,
                        uid = uid,
                        created = DateTime.UtcNow,
                        json = JsonConvert.SerializeObject(data),
                        name = data.name,
                        model = data.model?.name
                    });

                    await sqlDb.SaveChangesLocks();
                }
            }

            return Json(new
            {
                result = true
            });
        }


        [Route("sisi/bookmark/remove")]
        async public Task<ActionResult> Remove(string id)
        {
            string md5user = getuser();
            if (md5user == null || string.IsNullOrEmpty(id))
                return OnError("access denied");

            try
            {
                await SisiContext.semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                using (var sqlDb = new SisiContext())
                {
                    sqlDb.bookmarks
                        .Where(i => i.user == md5user && i.uid == id)
                        .ExecuteDelete();
                }
            }
            catch { }
            finally
            {
                SisiContext.semaphore.Release();
            }

            return Json(new
            {
                result = true,
            });
        }



        string getuser()
        {
            string user_id = requestInfo.user_uid;
            if (string.IsNullOrEmpty(user_id))
                return null;

            string profile_id = getProfileid();
            if (!string.IsNullOrEmpty(profile_id))
                return CrypTo.md5($"{user_id}_{profile_id}");

            return CrypTo.md5(user_id);
        }

        string getProfileid()
        {
            if (HttpContext.Request.Query.TryGetValue("profile_id", out var profile_id) && !string.IsNullOrEmpty(profile_id) && profile_id != "0")
                return profile_id;

            return string.Empty;
        }
    }
}

```

## File: SISI/HistoryController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Newtonsoft.Json;
using Shared.Models.SQL;
using System.Web;

namespace SISI
{
    public class HistoryController : BaseSisiController
    {
        [Route("sisi/historys")]
        public ActionResult List(int pg = 1, int pageSize = 36)
        {
            string md5user = getuser();
            if (md5user == null || !AppInit.conf.sisi.history.enable)
                return OnError("access denied");

            #region historys
            var historys = new List<PlaylistItem>();
            var historysQuery = new List<SisiHistorySqlModel>();

            using (var sqlDb = new SisiContext())
            {
                historysQuery = sqlDb.historys
                    .AsNoTracking()
                    .Where(i => i.user == md5user)
                    .Take(pageSize * 20)
                    .ToList();
            }

            int total_pages = Math.Max(0, historysQuery.Count / pageSize) + 1;

            var items = historysQuery
                .OrderByDescending(i => i.created)
                .Skip((pg * pageSize) - pageSize)
                .Take(pageSize);

            if (items.Any())
            {
                foreach (var json in items.Select(i => i.json))
                {
                    if (string.IsNullOrEmpty(json))
                        continue;

                    try
                    {
                        var history = JsonConvert.DeserializeObject<PlaylistItem>(json);
                        if (history != null)
                            historys.Add(history);
                    }
                    catch { }
                }
            }
            #endregion

            #region getvideLink
            string getvideLink(PlaylistItem pl)
            {
                if (pl.bookmark.site is "phub" or "phubprem")
                    return $"{host}/{pl.bookmark.site}/vidosik?vkey={HttpUtility.UrlEncode(pl.bookmark.href)}";

                return $"{host}/{pl.bookmark.site}/vidosik?uri={HttpUtility.UrlEncode(pl.bookmark.href)}";
            }
            #endregion

            string localhost = $"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}";

            return new JsonResult(new
            {
                list = historys.Select(pl => new
                {
                    pl.name,
                    video = getvideLink(pl),
                    picture = HostImgProxy(pl.bookmark.image, plugin: pl.bookmark.site),
                    pl.time,
                    pl.json,
                    related = pl.related || Regex.IsMatch(pl.bookmark.site, "^(elo|epr|fph|phub|sbg|xmr|xnx|xds)"),
                    pl.quality,
                    pl.preview,
                    pl.model,
                    pl.bookmark,
                    pl.history_uid
                }).ToArray(),
                total_pages
            });
        }


        [HttpPost]
        [Route("sisi/history/add")]
        async public Task<ActionResult> Add([FromBody] PlaylistItem data)
        {
            string md5user = getuser();
            if (md5user == null || !AppInit.conf.sisi.history.enable || data == null || string.IsNullOrEmpty(data?.bookmark?.site) || string.IsNullOrEmpty(data?.bookmark?.href))
                return OnError("access denied");

            string uid = CrypTo.md5($"{data.bookmark.site}:{data.bookmark.href}");

            using (var sqlDb = new SisiContext())
            {
                if (!sqlDb.historys.AsNoTracking().Any(i => i.user == md5user && i.uid == uid))
                {
                    data.history_uid = uid;

                    sqlDb.historys.Add(new SisiHistorySqlModel
                    {
                        user = md5user,
                        uid = uid,
                        created = DateTime.UtcNow,
                        json = JsonConvert.SerializeObject(data)
                    });

                    await sqlDb.SaveChangesLocks();
                }
            }

            return Json(new
            {
                result = true
            });
        }


        [Route("sisi/history/remove")]
        async public Task<ActionResult> Remove(string id)
        {
            string md5user = getuser();
            if (md5user == null || !AppInit.conf.sisi.history.enable || string.IsNullOrEmpty(id))
                return OnError("access denied");

            try
            {
                await SisiContext.semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                using (var sqlDb = new SisiContext())
                {
                    sqlDb.historys
                        .Where(i => i.user == md5user && i.uid == id)
                        .ExecuteDelete();
                }
            }
            catch { }
            finally
            {
                SisiContext.semaphore.Release();
            }

            return Json(new
            {
                result = true,
            });
        }



        string getuser()
        {
            string user_id = requestInfo.user_uid;
            if (string.IsNullOrEmpty(user_id))
                return null;

            string profile_id = getProfileid();
            if (!string.IsNullOrEmpty(profile_id))
                return CrypTo.md5($"{user_id}_{profile_id}");

            return CrypTo.md5(user_id);
        }

        string getProfileid()
        {
            if (HttpContext.Request.Query.TryGetValue("profile_id", out var profile_id) && !string.IsNullOrEmpty(profile_id) && profile_id != "0")
                return profile_id;

            return string.Empty;
        }
    }
}

```

## File: SISI/GlobalUsings.cs
```
Ôªøglobal using System;
global using System.Threading.Tasks;
global using System.Collections.Generic;
global using System.Text.RegularExpressions;
global using System.IO;
global using System.Linq;
global using Shared;
global using Shared.Models;
global using Shared.Engine;
global using Shared.Engine.SISI;
global using Shared.Models.SISI.Base;
global using Shared.Models.SISI.OnResult;
```

## File: SISI/Models/BongaCams/Listing.cs
```
Ôªønamespace SISI.Models.BongaCams
{
    public class Listing
    {
        public List<Model> models { get; set; }

        public int online_count { get; set; }
    }
}

```

## File: SISI/Models/BongaCams/LocalData.cs
```
Ôªønamespace SISI.Models.BongaCams
{
    public class LocalData
    {
        public string videoServerUrl { get; set; }
    }
}

```

## File: SISI/Models/BongaCams/Amf.cs
```
Ôªønamespace SISI.Models.BongaCams
{
    public class Amf
    {
        public LocalData localData { get; set; }
    }
}

```

## File: SISI/Models/BongaCams/Model.cs
```
Ôªønamespace SISI.Models.BongaCams
{
    public class Model
    {
        public bool online { get; set; }

        public string username { get; set; }

        public string display_name { get; set; }

        public string topic { get; set; }

        public string thumb_image { get; set; }

        public string room { get; set; }

        public int hd_cam { get; set; }

        public int hd_plus { get; set; }

        public bool is_away { get; set; }
    }
}

```

## File: SISI/Controllers/Xhamster/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Xhamster
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("xmr")]
        [Route("xmrgay")]
        [Route("xmrsml")]
        async public ValueTask<ActionResult> Index(string search, string c, string q, string sort = "newest", int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Xhamster);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            pg++;
            string plugin = Regex.Match(HttpContext.Request.Path.Value, "^/([a-z]+)").Groups[1].Value;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"{plugin}:{search}:{sort}:{c}:{q}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    string html = await XhamsterTo.InvokeHtml(init.corsHost(), plugin, search, c, q, sort, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), httpversion: 2, timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    playlists = XhamsterTo.Playlist("xmr/vidosik", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(playlists, string.IsNullOrEmpty(search) ? XhamsterTo.Menu(host, plugin, c, q, sort) : null, plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Xhamster/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Xhamster
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("xmr/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            var init = await loadKit(AppInit.conf.Xhamster);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"xhamster:view:{uri}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    reset:
                    stream_links = await XhamsterTo.StreamLinks("xmr/vidosik", init.corsHost(), uri, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), httpversion: 2, timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/Runetki/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.PlaywrightCore;

namespace SISI.Controllers.Runetki
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("runetki")]
        async public ValueTask<ActionResult> Index(string search, string sort, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Runetki);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (!string.IsNullOrEmpty(search))
                return OnError("no search", false);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return OnError(rch_error);

            string memKey = $"{init.plugin}:list:{sort}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out (List<PlaylistItem> playlists, int total_pages) cache, inmemory: false))
                {
                    reset:
                    string html = await RunetkiTo.InvokeHtml(init.corsHost(), sort, pg, url =>
                    {
                        if (rch.enable)
                            return rch.Get(init.cors(url), httpHeaders(init));

                        if (init.priorityBrowser == "http")
                            return Http.Get(url, httpversion: 2, timeoutSeconds: 8, headers: httpHeaders(init), proxy: proxy.proxy);

                        return PlaywrightBrowser.Get(init, url, httpHeaders(init), proxy.data);
                    });

                    cache.playlists = RunetkiTo.Playlist(html, out int total_pages);
                    cache.total_pages = total_pages;

                    if (cache.playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, cache, cacheTime(5, init: init), inmemory: false);
                }

                return OnResult(cache.playlists, init, RunetkiTo.Menu(host, sort), proxy: proxy.proxy, total_pages: cache.total_pages);
            });
        }
    }
}

```

## File: SISI/Controllers/Xnxx/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Xnxx
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("xnx")]
        async public ValueTask<ActionResult> Index(string search, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Xnxx);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"xnx:list:{search}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    string html = await XnxxTo.InvokeHtml(init.corsHost(), search, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    playlists = XnxxTo.Playlist("xnx/vidosik", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10), inmemory: false);
                }

                return OnResult(playlists, string.IsNullOrEmpty(search) ? XnxxTo.Menu(host) : null, plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Xnxx/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Xnxx
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("xnx/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            var init = await loadKit(AppInit.conf.Xnxx);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"xnxx:view:{uri}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    reset:
                    stream_links = await XnxxTo.StreamLinks("xnx/vidosik", init.corsHost(), uri, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/Xvideos/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Xvideos
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("xds")]
        [Route("xdsgay")]
        [Route("xdssml")]
        async public ValueTask<ActionResult> Index(string search, string sort, string c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Xvideos);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string plugin = Regex.Match(HttpContext.Request.Path.Value, "^/([a-z]+)").Groups[1].Value;
            string memKey = $"{plugin}:list:{search}:{sort}:{c}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    string html = await XvideosTo.InvokeHtml(init.corsHost(), plugin, search, sort, c, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    playlists = XvideosTo.Playlist("xds/vidosik", $"{plugin}/stars", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(playlists, string.IsNullOrEmpty(search) ? XvideosTo.Menu(host, plugin, sort, c) : null, plugin: init.plugin);
            });
        }


        [HttpGet]
        [Route("xds/stars")]
        [Route("xdsgay/stars")]
        [Route("xdssml/stars")]
        async public ValueTask<ActionResult> Pornstars(string uri, string sort, int pg = 0)
        {
            var init = await loadKit(AppInit.conf.Xvideos);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string plugin = Regex.Match(HttpContext.Request.Path.Value, "^/([a-z]+)").Groups[1].Value;
            string memKey = $"{plugin}:stars:{uri}:{sort}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    playlists = await XvideosTo.Pornstars("xds/vidosik", $"{plugin}/stars", init.corsHost(), plugin, uri, sort, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    if (playlists == null || playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }


                // XvideosTo.PornstarsMenu(host, plugin, sort)
                return OnResult(playlists, null, plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Xvideos/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Xvideos
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("xds/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            var init = await loadKit(AppInit.conf.Xvideos);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"xvideos:view:{uri}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    reset:
                    stream_links = await XvideosTo.StreamLinks("xds/vidosik", $"{host}/xds/stars", init.corsHost(), uri, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(url, timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/PornHub/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.PornHub
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("phub")]
        [Route("phubgay")]
        [Route("phubsml")]
        async public ValueTask<ActionResult> Index(string search, string model, string sort, int c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.PornHub);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string plugin = Regex.Match(HttpContext.Request.Path.Value, "^/([a-z]+)").Groups[1].Value;
            string memKey = $"{plugin}:list:{search}:{model}:{sort}:{c}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out (int total_pages, List<PlaylistItem> playlists) cache, inmemory: false))
                {
                    reset:
                    string html = await PornHubTo.InvokeHtml(init.corsHost(), plugin, search, model, sort, c, null, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, httpversion: 2, headers: httpHeaders(init))
                    );

                    cache.total_pages = rch.enable ? 0 : PornHubTo.Pages(html);
                    cache.playlists = PornHubTo.Playlist("phub/vidosik", "phub", html, IsModel_page: !string.IsNullOrEmpty(model));

                    if (cache.playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, cache, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(cache.playlists, string.IsNullOrEmpty(model) ? PornHubTo.Menu(host, plugin, search, sort, c) : null, plugin: init.plugin, total_pages: cache.total_pages);
            });
        }


        [HttpGet]
        [Route("phubprem")]
        async public ValueTask<ActionResult> Prem(string search, string model, string sort, string hd, int c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.PornHubPremium);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string memKey = $"phubprem:list:{search}:{model}:{sort}:{hd}:{pg}";
            if (!hybridCache.TryGetValue(memKey, out (int total_pages, List<PlaylistItem> playlists) cache, inmemory: false))
            {
                var proxyManager = new ProxyManager(init);
                var proxy = proxyManager.Get();

                string html = await PornHubTo.InvokeHtml(init.corsHost(), "phubprem", search, model, sort, c, hd, pg, url => Http.Get(init.cors(url), timeoutSeconds: 14, proxy: proxy, httpversion: 2, headers: httpHeaders(init, HeadersModel.Init("cookie", init.cookie))));
                if (html == null)
                    return OnError("html", proxyManager, string.IsNullOrEmpty(search));

                cache.total_pages = PornHubTo.Pages(html);
                cache.playlists = PornHubTo.Playlist("phubprem/vidosik", "phubprem", html, prem: true);

                if (cache.playlists.Count == 0)
                    return OnError("playlists", proxyManager, pg > 1 && string.IsNullOrEmpty(search));

                proxyManager.Success();
                hybridCache.Set(memKey, cache, cacheTime(10, init: init), inmemory: false);
            }

            return OnResult(cache.playlists, string.IsNullOrEmpty(model) ? PornHubTo.Menu(host, "phubprem", search, sort, c, hd) : null, plugin: "phubprem", total_pages: cache.total_pages);
        }
    }
}

```

## File: SISI/Controllers/PornHub/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.PornHub
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("phub/vidosik")]
        async public ValueTask<ActionResult> Index(string vkey, bool related)
        {
            var init = await loadKit(AppInit.conf.PornHub);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"phub:vidosik:{vkey}";
            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    reset:
                    stream_links = await PornHubTo.StreamLinks("phub/vidosik", "phub", init.corsHost(), vkey, url =>
                        rch.enable 
                            ? rch.Get(init.cors(url), httpHeaders(init)) 
                            : Http.Get(init.cors(url), httpversion: 2, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init))
                    );

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy);
            });
        }


        [HttpGet]
        [Route("phubprem/vidosik")]
        async public ValueTask<ActionResult> Prem(string vkey, bool related)
        {
            var init = await loadKit(AppInit.conf.PornHubPremium);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            string memKey = $"phubprem:vidosik:{vkey}";
            if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
            {
                stream_links = await PornHubTo.StreamLinks("phubprem/vidosik", "phubprem", init.corsHost(), vkey, url => Http.Get(init.cors(url), httpversion: 2, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init, HeadersModel.Init("cookie", init.cookie))));

                if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    return OnError("stream_links", proxyManager);

                proxyManager.Success();
                hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
            }

            if (related)
                return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

            return OnResult(stream_links, init, proxy);
        }
    }
}

```

## File: SISI/Controllers/Tizam/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using System.Web;

namespace SISI.Controllers.Tizam
{
    public class ListController : BaseSisiController
    {
        [Route("tizam")]
        async public ValueTask<ActionResult> Index(string search, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Tizam);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (!string.IsNullOrEmpty(search))
                return OnError("no search", false);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"tizam:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    string uri = $"{init.corsHost()}/fil_my_dlya_vzroslyh/s_russkim_perevodom/";

                    int page = pg - 1;
                    if (page > 0)
                        uri += $"?p={page}";

                    reset:
                    string html = rch.enable ? await rch.Get(init.cors(uri), httpHeaders(init)) :
                                               await Http.Get(init.cors(uri), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init));

                    playlists = Playlist(html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(60, init: init), inmemory: false);
                }

                return OnResult(playlists, null, plugin: init.plugin);
            });
        }


        static List<PlaylistItem> Playlist(string html)
        {
            var playlists = new List<PlaylistItem>() { Capacity = 25 };
            if (string.IsNullOrEmpty(html))
                return playlists;

            foreach (string row in Regex.Split(html.Split("id=\"pagination\"")[0], "video-item").Skip(1))
            {
                if (row.Contains("pin--premium"))
                    continue;

                string title = Regex.Match(row, "-name=\"name\">([^<]+)<").Groups[1].Value;
                string href = Regex.Match(row, "href=\"/([^\"]+)\" itemprop=\"url\"").Groups[1].Value;

                if (!string.IsNullOrEmpty(href) && !string.IsNullOrWhiteSpace(title))
                {
                    string duration = Regex.Match(row, "itemprop=\"duration\" content=\"([^<]+)\"").Groups[1].Value;

                    string img = Regex.Match(row, "class=\"item__img\" src=\"/([^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(img))
                        continue;

                    var pl = new PlaylistItem()
                    {
                        name = title,
                        video = $"tizam/vidosik?uri={HttpUtility.UrlEncode(href)}",
                        picture = $"{AppInit.conf.Tizam.host}/{img}",
                        time = duration?.Trim(),
                        json = true,
                        bookmark = new Bookmark()
                        {
                            site = "tizam",
                            href = href,
                            image = $"{AppInit.conf.Tizam.host}/{img}"
                        }
                    };

                    playlists.Add(pl);
                }
            }

            return playlists;
        }
    }
}

```

## File: SISI/Controllers/Tizam/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Tizam
{
    public class ViewController : BaseSisiController
    {
        [Route("tizam/vidosik")]
        async public ValueTask<ActionResult> Index(string uri)
        {
            var init = await loadKit(AppInit.conf.Tizam);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"tizam:view:{uri}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    reset:
                    string html = rch.enable ? await rch.Get($"{init.corsHost()}/{uri}", httpHeaders(init)) :
                                               await Http.Get($"{init.corsHost()}/{uri}", timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init));

                    string location = Regex.Match(html ?? string.Empty, "src=\"(https?://[^\"]+\\.mp4)\" type=\"video/mp4\"").Groups[1].Value;

                    if (string.IsNullOrEmpty(location))
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("location", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    stream_links = new StreamItem()
                    {
                        qualitys = new Dictionary<string, string>()
                        {
                            ["auto"] = location
                        }
                    };

                    hybridCache.Set(memKey, stream_links, cacheTime(180, init: init));
                }

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/Spankbang/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.PlaywrightCore;

namespace SISI.Controllers.Spankbang
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("sbg")]
        async public ValueTask<ActionResult> Index(string search, string sort, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Spankbang);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string memKey = $"sbg:{search}:{sort}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    string html = await SpankbangTo.InvokeHtml(init.corsHost(), search, sort, pg, url =>
                    {
                        if (rch.enable)
                            return rch.Get(init.cors(url), httpHeaders(init));

                        if (init.priorityBrowser == "http")
                            return Http.Get(url, httpversion: 2, timeoutSeconds: 8, headers: httpHeaders(init), proxy: proxy.proxy);

                        return PlaywrightBrowser.Get(init, url, httpHeaders(init), proxy.data);
                    });

                    playlists = SpankbangTo.Playlist("sbg/vidosik", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(playlists, string.IsNullOrEmpty(search) ? SpankbangTo.Menu(host, sort) : null, plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Spankbang/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.PlaywrightCore;

namespace SISI.Controllers.Spankbang
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("sbg/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            var init = await loadKit(AppInit.conf.Spankbang);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string memKey = $"spankbang:view:{uri}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    reset:
                    stream_links = await SpankbangTo.StreamLinks("sbg/vidosik", init.corsHost(), uri, url =>
                    {
                        if (rch.enable)
                            return rch.Get(init.cors(url), httpHeaders(init));

                        if (init.priorityBrowser == "http")
                            return Http.Get(url, httpversion: 2, timeoutSeconds: 8, headers: httpHeaders(init), proxy: proxy.proxy);

                        return PlaywrightBrowser.Get(init, url, httpHeaders(init), proxy.data);
                    });

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy.proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/HQporner/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.HQporner
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("hqr")]
        async public ValueTask<ActionResult> Index(string search, string sort, string c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.HQporner);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"hqr:{search}:{sort}:{c}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    string html = await HQpornerTo.InvokeHtml(init.corsHost(), search, sort, c, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    playlists = HQpornerTo.Playlist("hqr/vidosik", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(playlists, string.IsNullOrEmpty(search) ? HQpornerTo.Menu(host, sort, c) : null, plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/HQporner/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.HQporner
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("hqr/vidosik")]
        async public ValueTask<ActionResult> Index(string uri)
        {
            var init = await loadKit(AppInit.conf.HQporner);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;


            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = rch.ipkey($"HQporner:view:{uri}", proxyManager);

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out Dictionary<string, string> stream_links))
                {
                    reset:
                    stream_links = await HQpornerTo.StreamLinks(init.corsHost(), uri,
                                   htmlurl => rch.enable ? rch.Get(init.cors(htmlurl), httpHeaders(init)) : Http.Get(init.cors(htmlurl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
                                   iframeurl => rch.enable ? rch.Get(init.cors(iframeurl), httpHeaders(init)) : Http.Get(init.cors(iframeurl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)));

                    if (stream_links == null || stream_links.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/NextHUB/ListController.cs
```
Ôªøusing HtmlAgilityPack;
using Microsoft.AspNetCore.Mvc;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Scripting;
using Microsoft.Playwright;
using Shared.Models.CSharpGlobals;
using Shared.Models.SISI.NextHUB;
using Shared.PlaywrightCore;
using System.Web;

namespace SISI.Controllers.NextHUB
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("nexthub")]
        async public ValueTask<ActionResult> Index(string plugin, string search, string sort, string cat, string model, int pg = 1)
        {
            if (!AppInit.conf.sisi.NextHUB)
                return OnError("disabled");

            var init = Root.goInit(plugin)?.Clone();
            if (init == null)
                return OnError("init not found", rcache: false);

            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (!string.IsNullOrEmpty(search) && string.IsNullOrEmpty(init.search?.uri))
                return OnError("search disable");

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string memKey = $"nexthub:{plugin}:{search}:{sort}:{cat}:{model}:{pg}";
            if (init.menu?.customs != null)
            {
                foreach (var item in init.menu.customs)
                    memKey += $":{HttpContext.Request.Query[item.arg]}";
            }

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    #region contentParse
                    var contentParse = init.list.contentParse ?? init.contentParse;

                    if (!string.IsNullOrEmpty(search) && init.search?.contentParse != null)
                        contentParse = init.search.contentParse;

                    if (!string.IsNullOrEmpty(model) && init.model?.contentParse != null)
                        contentParse = init.model.contentParse;
                    #endregion

                    #region html
                    string url = $"{init.host}/{(pg == 1 && init.list.firstpage != null ? init.list.firstpage : init.list.uri)}";
                    if (!string.IsNullOrEmpty(search))
                    {
                        string uri = pg == 1 && init.search?.firstpage != null ? init.search.firstpage : init.search?.uri;
                        url = $"{init.host}/{uri}".Replace("{search}", HttpUtility.UrlEncode(search));
                    }
                    else
                    {
                        if (!string.IsNullOrEmpty(sort))
                            url = $"{init.host}/{sort}";
                        else if (!string.IsNullOrEmpty(cat))
                            url = $"{init.host}/{init.menu.formatcat(cat)}";
                        else if (!string.IsNullOrEmpty(model))
                        {
                            url = $"{init.host}/{model}";
                            if (init.model?.uri != null)
                                url = init.model.uri.Replace("{host}", init.host).Replace("{model}", model);
                            else if (init.model?.format != null)
                            {
                                string eval = $"return $\"{init.model.format}\";";
                                url = CSharpEval.BaseExecute<string>(eval, new NxtMenuRoute(init.host, plugin, url, search, cat, sort, model, HttpContext.Request.Query, pg));
                            }
                        }
                        else if (init.menu?.customs != null)
                        {
                            foreach (var c in init.menu.customs)
                            {
                                if (HttpContext.Request.Query.ContainsKey(c.arg))
                                    url = $"{init.host}/{c.format.Replace("{value}", HttpContext.Request.Query[c.arg])}";
                            }
                        }

                        if (init.menu?.route != null)
                        {
                            string goroute(string name)
                            {
                                if (init.menu.route.TryGetValue(name, out string value))
                                    return value;

                                if (init.menu.route.TryGetValue("-", out value))
                                    return value;

                                return string.Empty;
                            }

                            string eval = $"return (cat != null && sort != null) ? $\"{goroute("catsort")}\" : (model != null && sort != null) ? $\"{goroute("modelsort")}\" : model != null ? $\"{goroute("model")}\" : cat != null ? $\"{goroute("cat")}\" : sort != null ? $\"{goroute("sort")}\" : \"{url}\";";
                            url = CSharpEval.BaseExecute<string>(eval, new NxtMenuRoute(init.host, plugin, url, search, cat, sort, model, HttpContext.Request.Query, pg));
                        }
                    }

                    if (init.route?.eval != null)
                        url = CSharpEval.Execute<string>(init.route.eval, new NxtMenuRoute(init.host, plugin, url, search, cat, sort, model, HttpContext.Request.Query, pg));

                    reset:
                    string html = rch.enable ? await rch.Get(url.Replace("{page}", pg.ToString()), httpHeaders(init)) :
                               init.priorityBrowser == "http" ? await Http.Get(url.Replace("{page}", pg.ToString()), headers: httpHeaders(init), proxy: proxy.proxy, timeoutSeconds: init.timeout) :
                               init.list.viewsource ? await PlaywrightBrowser.Get(init, url.Replace("{page}", pg.ToString()), httpHeaders(init), proxy.data, cookies: init.cookies) :
                                                      await ContentAsync(init, url.Replace("{page}", pg.ToString()), httpHeaders(init), proxy.data, search, sort, cat, model, pg);
                    #endregion

                    playlists = goPlaylist(requestInfo, host, contentParse, init, html, plugin);

                    if (playlists == null || playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, rcache: !(init.debug || rch.enable));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(init.cache_time, init: init), inmemory: false);
                }

                var menu = new List<MenuItem>(3);
                bool usedRoute = init.menu?.route != null || init.route?.eval != null;

                #region search
                if (string.IsNullOrEmpty(model) && init.search?.uri != null)
                {
                    menu.Add(new MenuItem()
                    {
                        title = "–ü–æ–∏—Å–∫",
                        search_on = "search_on",
                        playlist_url = $"{host}/nexthub?plugin={plugin}",
                    });
                }
                #endregion

                #region sort
                if (string.IsNullOrEmpty(search) && init.menu?.sort != null)
                {
                    var msort = new MenuItem()
                    {
                        title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {init.menu.sort.FirstOrDefault(i => i.Value.Trim() == sort).Key ?? init.menu.sort.First().Key}",
                        playlist_url = "submenu",
                        submenu = new List<MenuItem>()
                    };

                    string arg = usedRoute && init.menu.bind ? $"&cat={HttpUtility.UrlEncode(cat)}&model={HttpUtility.UrlEncode(model)}" : string.Empty;

                    foreach (var s in init.menu.sort)
                    {
                        msort.submenu.Add(new MenuItem()
                        {
                            title = s.Key,
                            playlist_url = $"{host}/nexthub?plugin={plugin}&sort={HttpUtility.UrlEncode(s.Value.Trim())}" + arg,
                        });
                    }

                    if (msort.submenu.Count > 0)
                        menu.Add(msort);
                }
                #endregion

                #region categories
                if (string.IsNullOrEmpty(search) && string.IsNullOrEmpty(model) && init.menu?.categories != null)
                {
                    var categories = init.menu.categories.Where(i => i.Key != "format");

                    var mcat = new MenuItem()
                    {
                        title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏–∏: {categories.FirstOrDefault(i => i.Value.Trim() == cat).Key ?? "–í—ã–±—Ä–∞—Ç—å"}",
                        playlist_url = "submenu",
                        submenu = new List<MenuItem>()
                    };

                    string arg = usedRoute && init.menu.bind ? $"&sort={HttpUtility.UrlEncode(sort)}" : string.Empty;

                    foreach (var s in categories)
                    {
                        mcat.submenu.Add(new MenuItem()
                        {
                            title = s.Key,
                            playlist_url = $"{host}/nexthub?plugin={plugin}&cat={HttpUtility.UrlEncode(s.Value.Trim())}" + arg,
                        });
                    }

                    if (mcat.submenu.Count > 0)
                        menu.Add(mcat);
                }
                #endregion

                #region custom categories
                if (string.IsNullOrEmpty(search) && string.IsNullOrEmpty(model) && init.menu?.customs != null)
                {
                    foreach (var custom in init.menu.customs)
                    {
                        string argvalue = HttpContext.Request.Query[custom.arg];

                        var mcat = new MenuItem()
                        {
                            title = $"{custom.name}: {custom.submenu.FirstOrDefault(i => i.Value.Trim() == argvalue).Key ?? "–í—ã–±—Ä–∞—Ç—å"}",
                            playlist_url = "submenu",
                            submenu = new List<MenuItem>()
                        };

                        foreach (var s in custom.submenu)
                        {
                            mcat.submenu.Add(new MenuItem()
                            {
                                title = s.Key,
                                playlist_url = $"{host}/nexthub?plugin={plugin}&{custom.arg}={HttpUtility.UrlEncode(s.Value.Trim())}",
                            });
                        }

                        if (mcat.submenu.Count > 0)
                            menu.Add(mcat);
                    }
                }
                #endregion

                #region total_pages
                int total_pages = init.list.total_pages;

                if (search != null && init.search != null)
                    total_pages = init.search.total_pages;

                if (model != null && init.model != null)
                    total_pages = init.model.total_pages;
                #endregion

                return OnResult(playlists, menu.Count == 0 ? null : menu, plugin: init.plugin, total_pages: total_pages);
            });
        }


        #region goPlaylist
        public static List<PlaylistItem> goPlaylist(in RequestModel requestInfo, string host, ContentParseSettings parse, NxtSettings init, in string html, string plugin)
        {
            if (parse == null || string.IsNullOrEmpty(html))
                return null;

            if (init.debug)
                Console.WriteLine(html);

            var doc = new HtmlDocument();
            doc.LoadHtml(html);

            string eval = parse.eval;
            if (!string.IsNullOrEmpty(eval) && eval.EndsWith(".cs"))
                eval = FileCache.ReadAllText($"NextHUB/sites/{eval}");

            if (string.IsNullOrEmpty(parse.nodes))
            {
                if (string.IsNullOrEmpty(eval))
                    return null;

                var options = ScriptOptions.Default
                    .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                    .AddImports("Shared.Models.SISI.Base")
                    .AddImports("Shared.Models.SISI")
                    .AddReferences(CSharpEval.ReferenceFromFile("HtmlAgilityPack.dll"))
                    .AddImports("HtmlAgilityPack");

                return CSharpEval.Execute<List<PlaylistItem>>(eval, new NxtPlaylist(init, plugin, host, html, doc, new List<PlaylistItem>()), options);
            }

            var nodes = doc.DocumentNode.SelectNodes(parse.nodes);
            if (nodes == null || nodes.Count == 0)
                return null;

            var playlists = new List<PlaylistItem>(nodes.Count);

            foreach (var row in nodes)
            {
                #region nodeValue
                string nodeValue(SingleNodeSettings nd)
                {
                    string value = null;

                    if (nd != null)
                    {
                        if (string.IsNullOrEmpty(nd.node) && (!string.IsNullOrEmpty(nd.attribute) || nd.attributes != null))
                        {
                            if (nd.attributes != null)
                            {
                                foreach (var attr in nd.attributes)
                                {
                                    var attrValue = row.GetAttributeValue(attr, null);
                                    if (!string.IsNullOrEmpty(attrValue))
                                    {
                                        value = attrValue;
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                value = row.GetAttributeValue(nd.attribute, null);
                            }
                        }
                        else
                        {
                            var inNode = row.SelectSingleNode(nd.node);
                            if (inNode != null)
                            {
                                if (nd.attributes != null)
                                {
                                    foreach (var attr in nd.attributes)
                                    {
                                        var attrValue = inNode.GetAttributeValue(attr, null);
                                        if (!string.IsNullOrEmpty(attrValue))
                                        {
                                            value = attrValue;
                                            break;
                                        }
                                    }
                                }
                                else
                                {
                                    value = (!string.IsNullOrEmpty(nd.attribute) ? inNode.GetAttributeValue(nd.attribute, null) : inNode.InnerText)?.Trim();
                                }
                            }
                        }
                    }

                    if (string.IsNullOrEmpty(value))
                        return null;

                    if (nd.format != null)
                        return CSharpEval.BaseExecute<string>($"return $\"{nd.format}\";", new NxtNodeValue(value, host));

                    return value;
                }
                #endregion

                string name = nodeValue(parse.name);
                string href = nodeValue(parse.href);
                string img = nodeValue(parse.img);
                string duration = nodeValue(parse.duration);
                string quality = nodeValue(parse.quality);
                string preview = nodeValue(parse.preview);

                #region model
                ModelItem? model = null;
                if (parse.model != null)
                {
                    string mname = nodeValue(parse.model.name);
                    string mhref = nodeValue(parse.model.href);

                    if (!string.IsNullOrEmpty(mname) && !string.IsNullOrEmpty(mhref))
                    {
                        model = new ModelItem()
                        {
                            name = mname,
                            uri = $"nexthub?plugin={plugin}&model={HttpUtility.UrlEncode(mhref)}"
                        };
                    }
                }
                #endregion

                #region args
                string args = string.Empty;

                if (parse.args != null)
                {
                    foreach (var a in parse.args)
                    {
                        string arg = nodeValue(a);
                        if (!string.IsNullOrEmpty(arg))
                            args += $"&{a.name}={HttpUtility.UrlEncode(arg)}";
                    }
                }
                #endregion

                if (init.debug)
                    Console.WriteLine($"\n\nname: {name}\nhref: {href}\nimg: {img}\nduration: {duration}\nquality: {quality}\nmyarg: {args}\n\n{row.OuterHtml}");

                if (!string.IsNullOrWhiteSpace(name) && !string.IsNullOrWhiteSpace(href))
                {
                    #region href
                    if (href.StartsWith("../"))
                        href = $"{init.host}/{href.Replace("../", "")}";
                    else if (href.StartsWith("//"))
                        href = $"https:{href}";
                    else if (href.StartsWith("/"))
                        href = init.host + href;
                    else if (!href.StartsWith("http"))
                        href = $"{init.host}/{href}";
                    #endregion

                    #region img
                    if (img != null)
                    {
                        img = img.Replace("&amp;", "&").Replace("\\", "");

                        if (img.StartsWith("../"))
                            img = $"{init.host}/{img.Replace("../", "")}";
                        else if (img.StartsWith("//"))
                            img = $"https:{img}";
                        else if (img.StartsWith("/"))
                            img = init.host + img;
                        else if (!img.StartsWith("http"))
                            img = $"{init.host}/{img}";
                    }
                    #endregion

                    if (!init.ignore_no_picture && string.IsNullOrEmpty(img))
                        continue;

                    #region preview
                    if (preview != null)
                    {
                        preview = preview.Replace("&amp;", "&").Replace("\\", "");

                        if (preview.StartsWith("../"))
                            preview = $"{init.host}/{preview.Replace("../", "")}";
                        else if (preview.StartsWith("//"))
                            preview = $"https:{preview}";
                        else if (preview.StartsWith("/"))
                            preview = init.host + preview;
                        else if (!preview.StartsWith("http"))
                            preview = $"{init.host}/{preview}";

                        if (init.streamproxy_preview)
                            preview = $"{host}/proxy/{ProxyLink.Encrypt(preview, string.Empty, verifyip: false, ex: DateTime.Now.AddHours(1))}";
                    }
                    #endregion

                    string clearText(string text)
                    {
                        if (string.IsNullOrEmpty(text))
                            return text;

                        text = text.Replace("&nbsp;", "");
                        return Regex.Replace(text, "<[^>]+>", "");
                    }

                    var pl = new PlaylistItem()
                    {
                        name = clearText(name),
                        video = $"nexthub/vidosik?uri={HttpUtility.UrlEncode($"{plugin}_-:-_{href}")}" + args,
                        preview = preview,
                        picture = img,
                        time = clearText(duration),
                        quality = clearText(quality),
                        myarg = args,
                        json = parse.json,
                        related = init.view != null ? init.view.related : false,
                        model = model,
                        bookmark = new Bookmark()
                        {
                            site = "nexthub",
                            href = $"{plugin}_-:-_{href}",
                            image = img
                        }
                    };

                    if (eval != null)
                    {
                        var options = ScriptOptions.Default
                            .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                            .AddImports("Shared.Models.SISI.Base")
                            .AddImports("Shared.Models.SISI")
                            .AddReferences(CSharpEval.ReferenceFromFile("HtmlAgilityPack.dll"))
                            .AddImports("HtmlAgilityPack");

                        pl = CSharpEval.Execute<PlaylistItem>(eval, new NxtChangePlaylis(init, plugin, host, html, nodes, pl, row), options);
                    }

                    if (pl.json == false && (init.streamproxy || (init.geostreamproxy != null && init.geostreamproxy.Contains(requestInfo.Country))))
                        pl.video = $"{host}/proxy/{ProxyLink.Encrypt(pl.video, requestInfo.IP, HeadersModel.Init(init.headers_stream))}";

                    if (pl != null)
                        playlists.Add(pl);
                }
            }

            return playlists;
        }
        #endregion

        #region ContentAsync
        async Task<string> ContentAsync(NxtSettings init, string url, List<HeadersModel> headers, (string ip, string username, string password) proxy, string search, string sort, string cat, string model, int pg)
        {
            try
            {
                var conf = string.IsNullOrEmpty(search) ? init.list : init.search;

                using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                {
                    var page = await browser.NewPageAsync(init.plugin, headers?.ToDictionary(), proxy: proxy, keepopen: init.keepopen).ConfigureAwait(false);
                    if (page == default)
                        return null;

                    if (init.cookies != null)
                        await page.Context.AddCookiesAsync(init.cookies).ConfigureAwait(false);

                    string routeEval = conf.routeEval;
                    if (!string.IsNullOrEmpty(routeEval) && routeEval.EndsWith(".cs"))
                        routeEval = FileCache.ReadAllText($"NextHUB/sites/{routeEval}");

                    await page.RouteAsync("**/*", async route =>
                    {
                        try
                        {
                            #region routeEval
                            if (routeEval != null)
                            {
                                var options = ScriptOptions.Default
                                    .AddReferences(CSharpEval.ReferenceFromFile("Microsoft.Playwright.dll"))
                                    .AddImports("Microsoft.Playwright");

                                bool _next = await CSharpEval.ExecuteAsync<bool>(routeEval, new NxtRoute(route, HttpContext.Request.Query, url, search, sort, cat, model, pg), options);
                                if (!_next)
                                    return;
                            }
                            #endregion

                            if (conf.patternAbort != null && Regex.IsMatch(route.Request.Url, conf.patternAbort, RegexOptions.IgnoreCase))
                            {
                                PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                await route.AbortAsync();
                                return;
                            }

                            if (init.abortMedia || init.fullCacheJS)
                            {
                                if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: init.abortMedia, fullCacheJS: init.fullCacheJS))
                                    return;
                            }
                            else
                            {
                                PlaywrightBase.ConsoleLog($"Playwright: {route.Request.Method} {route.Request.Url}");
                            }

                            await browser.ClearContinueAsync(route, page);
                        }
                        catch (Exception ex) { PlaywrightBase.ConsoleLog(ex.Message); }
                    });

                    string content = null;
                    PlaywrightBase.GotoAsync(page, url);

                    if (!string.IsNullOrEmpty(conf.waitForSelector))
                    {
                        try
                        {
                            await page.WaitForSelectorAsync(conf.waitForSelector, new PageWaitForSelectorOptions
                            {
                                Timeout = conf.waitForSelector_timeout

                            }).ConfigureAwait(false);
                        }
                        catch { }

                        content = await page.ContentAsync().ConfigureAwait(false);
                    }
                    else
                    {
                        await page.WaitForLoadStateAsync(LoadState.NetworkIdle, new PageWaitForLoadStateOptions() { Timeout = 20_000 }).ConfigureAwait(false);
                        content = await page.ContentAsync().ConfigureAwait(false);
                    }

                    PlaywrightBase.WebLog("GET", url, content, proxy);
                    return content;
                }
            }
            catch
            {
                return null;
            }
        }
        #endregion
    }
}

```

## File: SISI/Controllers/NextHUB/Root.cs
```
Ôªøusing Microsoft.CodeAnalysis.Scripting;
using YamlDotNet.Serialization;
using Shared.Models.SISI.NextHUB;

namespace SISI.Controllers.NextHUB
{
    public static class Root
    {
        #region evalOptionsFull
        public static ScriptOptions evalOptionsFull = ScriptOptions.Default

            .AddReferences(CSharpEval.ReferenceFromFile("Microsoft.Playwright.dll"))
            .AddImports("Microsoft.Playwright")

            .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
            .AddImports("Shared.PlaywrightCore")
            .AddImports("Shared.Engine")
            .AddImports("Shared.Models.SISI.Base")
            .AddImports("Shared.Models.SISI")

            .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll"))
            .AddImports("Newtonsoft.Json")
            .AddImports("Newtonsoft.Json.Linq");
        #endregion

        public static NxtSettings goInit(string plugin)
        {
            if (string.IsNullOrEmpty(plugin))
                return null;

            if (AppInit.conf.sisi.NextHUB_sites_enabled != null && !AppInit.conf.sisi.NextHUB_sites_enabled.Contains(plugin))
                return null;

            if (!File.Exists($"NextHUB/sites/{plugin}.yaml"))
                return null;

            var hybridCache = new HybridCache();

            string memKey = $"NextHUB:goInit:{plugin}";
            if (!hybridCache.TryGetValue(memKey, out NxtSettings init))
            {
                var deserializer = new DeserializerBuilder().Build();

                // –ß—Ç–µ–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ YAML-—Ñ–∞–π–ª–∞
                string yaml = File.ReadAllText($"NextHUB/sites/{plugin}.yaml");
                var target = deserializer.Deserialize<Dictionary<object, object>>(yaml);

                foreach (string y in new string[] { "_", plugin })
                {
                    if (File.Exists($"NextHUB/override/{y}.yaml"))
                    {
                        // –ß—Ç–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ YAML-—Ñ–∞–π–ª–∞
                        string myYaml = File.ReadAllText($"NextHUB/override/{y}.yaml");
                        var mySource = deserializer.Deserialize<Dictionary<object, object>>(myYaml);

                        // –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–ª–æ–≤–∞—Ä–µ–π
                        foreach (var property in mySource)
                        {
                            if (!target.ContainsKey(property.Key))
                            {
                                target[property.Key] = property.Value;
                                continue;
                            }

                            if (property.Value is IDictionary<object, object> sourceDict &&
                                target[property.Key] is IDictionary<object, object> targetDict)
                            {
                                // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö —Å–ª–æ–≤–∞—Ä–µ–π
                                foreach (var item in sourceDict)
                                    targetDict[item.Key] = item.Value;
                            }
                            else
                            {
                                target[property.Key] = property.Value;
                            }
                        }
                    }
                }

                // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å–ª–æ–≤–∞—Ä—è –≤ –æ–±—ä–µ–∫—Ç NxtSettings
                var serializer = new SerializerBuilder().Build();

                var yamlResult = serializer.Serialize(target);
                init = deserializer.Deserialize<NxtSettings>(yamlResult);

                if (string.IsNullOrEmpty(init.plugin))
                    init.plugin = init.displayname;

                if (!init.debug || !AppInit.conf.multiaccess)
                {
                    init = ModuleInvoke.Init(plugin, init);
                    hybridCache.Set(memKey, init, DateTime.Now.AddMinutes(1), inmemory: true);
                }
            }

            return init;
        }
    }
}

```

## File: SISI/Controllers/NextHUB/ViewController.cs
```
Ôªøusing HtmlAgilityPack;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Routing;
using Microsoft.CodeAnalysis.Scripting;
using Microsoft.Playwright;
using Newtonsoft.Json;
using Shared.Models.CSharpGlobals;
using Shared.PlaywrightCore;
using System.Net;
using Shared.Models.SISI.NextHUB;

namespace SISI.Controllers.NextHUB
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("nexthub/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            if (!AppInit.conf.sisi.NextHUB)
                return OnError("disabled");

            string plugin = uri.Split("_-:-_")[0];
            string url = uri.Split("_-:-_")[1];

            var init = Root.goInit(plugin)?.Clone();
            if (init == null)
                return OnError("init not found");

            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (init.view.initUrlEval != null)
                url = CSharpEval.Execute<string>(init.view.initUrlEval, new NxtUrlRequest(init.host, plugin, url, HttpContext.Request.Query, related));

            return await InvkSemaphore($"nexthub:InvkSemaphore:{url}", async () =>
            {
                (string file, List<HeadersModel> headers, List<PlaylistItem> recomends) video = default;
                if ((init.view.priorityBrowser ?? init.priorityBrowser) == "http" && init.view.viewsource &&
                    (init.view.nodeFile != null || init.view.eval != null || init.view.regexMatch != null) &&
                     init.view.routeEval == null && init.cookies == null && init.view.evalJS == null)
                {
                    reset: video = await goVideoToHttp(rch, plugin, url, init, proxyManager, proxy.proxy);
                    if (string.IsNullOrEmpty(video.file))
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("file", rcache: !rch.enable);
                    }
                }
                else
                {
                    video = await goVideoToBrowser(plugin, url, init, proxyManager, proxy.data);
                    if (string.IsNullOrEmpty(video.file))
                        return OnError("file");
                }

                var stream_links = new StreamItem()
                {
                    qualitys = new Dictionary<string, string>()
                    {
                        ["auto"] = video.file
                    },
                    recomends = video.recomends
                };

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy.proxy, headers_stream: httpHeaders(init.host, init.headers_stream != null ? init.headers_stream : init.headers_stream));
            });
        }


        #region goVideoToBrowser
        async ValueTask<(string file, List<HeadersModel> headers, List<PlaylistItem> recomends)> goVideoToBrowser(string plugin, string url, NxtSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(url))
                return default;

            try
            {
                string memKey = $"nexthub:view18:goVideo:{url}";
                if (init.view.bindingToIP)
                    memKey += $":{proxyManager.CurrentProxyIp}";

                if (!hybridCache.TryGetValue(memKey, out (string file, List<HeadersModel> headers, List<PlaylistItem> recomends) cache))
                {
                    using (var browser = new PlaywrightBrowser(init.view.priorityBrowser ?? init.priorityBrowser))
                    {
                        var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy, keepopen: init.view.keepopen, deferredDispose: init.view.playbtn != null).ConfigureAwait(false);
                        if (page == default)
                            return default;

                        if (init.cookies != null)
                            await page.Context.AddCookiesAsync(init.cookies).ConfigureAwait(false);

                        if (!string.IsNullOrEmpty(init.view.addInitScript))
                            await page.AddInitScriptAsync(init.view.addInitScript).ConfigureAwait(false);

                        string routeEval = init.view.routeEval;
                        if (!string.IsNullOrEmpty(routeEval) && routeEval.EndsWith(".cs"))
                            routeEval = FileCache.ReadAllText($"NextHUB/sites/{routeEval}");

                        #region RouteAsync
                        await page.RouteAsync("**/*", async route =>
                        {
                            try
                            {
                                if (browser.IsCompleted || (init.view.patternAbort != null && Regex.IsMatch(route.Request.Url, init.view.patternAbort, RegexOptions.IgnoreCase)))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }

                                #region routeEval
                                if (routeEval != null)
                                {
                                    var options = ScriptOptions.Default
                                        .AddReferences(CSharpEval.ReferenceFromFile("Microsoft.Playwright.dll"))
                                        .AddImports("Microsoft.Playwright");

                                    bool _next = await CSharpEval.ExecuteAsync<bool>(routeEval, new NxtRoute(route, HttpContext.Request.Query, url, null, null, null, null, 0), options);
                                    if (!_next)
                                        return;
                                }
                                #endregion

                                #region patternFile
                                if (init.view.patternFile != null && Regex.IsMatch(route.Request.Url, init.view.patternFile, RegexOptions.IgnoreCase))
                                {
                                    if (init.view.waitForResponse)
                                    {
                                        string result = null;
                                        await browser.ClearContinueAsync(route, page);
                                        var response = await page.WaitForResponseAsync(route.Request.Url);
                                        if (response != null)
                                            result = await response.TextAsync().ConfigureAwait(false);

                                        PlaywrightBase.ConsoleLog($"\nPlaywright: {result}\n");
                                        browser.SetPageResult(result);
                                    }
                                    else
                                    {
                                        void setHeaders(Dictionary<string, string> _headers)
                                        {
                                            if (_headers != null && _headers.Count > 0)
                                            {
                                                cache.headers = new List<HeadersModel>(_headers.Count);
                                                foreach (var item in _headers)
                                                {
                                                    if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                                        continue;

                                                    cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                                }
                                            }
                                        }

                                        setHeaders(route.Request.Headers);

                                        if (init.view.waitLocationFile)
                                        {
                                            await browser.ClearContinueAsync(route, page);
                                            string setUri = route.Request.Url;

                                            var response = await page.WaitForResponseAsync(route.Request.Url);
                                            if (response != null && response.Headers.ContainsKey("location"))
                                            {
                                                setHeaders(response.Request.Headers);
                                                setUri = response.Headers["location"];
                                            }

                                            if (setUri.StartsWith("//"))
                                                setUri = $"{(init.host.StartsWith("https") ? "https" : "http")}:{setUri}";

                                            PlaywrightBase.ConsoleLog($"\nPlaywright: SET {setUri}\n{JsonConvert.SerializeObject(cache.headers.ToDictionary(), Formatting.Indented)}\n");
                                            browser.SetPageResult(setUri);
                                        }
                                        else
                                        {
                                            PlaywrightBase.ConsoleLog($"\nPlaywright: SET {route.Request.Url}\n{JsonConvert.SerializeObject(cache.headers.ToDictionary(), Formatting.Indented)}\n");
                                            browser.SetPageResult(route.Request.Url);
                                            await route.AbortAsync();
                                        }
                                    }

                                    return;
                                }
                                #endregion

                                #region patternAbortEnd
                                if (init.view.patternAbortEnd != null && Regex.IsMatch(route.Request.Url, init.view.patternAbortEnd, RegexOptions.IgnoreCase))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }
                                #endregion

                                #region patternWhiteRequest
                                if (init.view.patternWhiteRequest != null && route.Request.Url != url && !Regex.IsMatch(route.Request.Url, init.view.patternWhiteRequest, RegexOptions.IgnoreCase))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }
                                #endregion

                                #region abortMedia
                                if (init.view.abortMedia || init.view.fullCacheJS)
                                {
                                    if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: init.view.abortMedia, fullCacheJS: init.view.fullCacheJS))
                                        return;
                                }
                                else
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: {route.Request.Method} {route.Request.Url}");
                                }
                                #endregion

                                await browser.ClearContinueAsync(route, page);
                            }
                            catch { }
                        });
                        #endregion

                        #region GotoAsync
                        resetGotoAsync: string html = null;
                        var responce = await page.GotoAsync(init.view.viewsource ? $"view-source:{url}" : url, new PageGotoOptions() 
                        {
                            Timeout = 10_000,
                            WaitUntil = WaitUntilState.DOMContentLoaded 
                        }).ConfigureAwait(false);

                        if (responce != null)
                            html = await responce.TextAsync().ConfigureAwait(false);
                        #endregion

                        if (init.view.waitForResponse)
                            html = await browser.WaitPageResult().ConfigureAwait(false);

                        #region WaitForSelector
                        if (!string.IsNullOrEmpty(init.view.waitForSelector) || !string.IsNullOrEmpty(init.view.playbtn))
                        {
                            try
                            {
                                await page.WaitForSelectorAsync(init.view.waitForSelector ?? init.view.playbtn, new PageWaitForSelectorOptions
                                {
                                    Timeout = init.view.waitForSelector_timeout

                                }).ConfigureAwait(false);
                            }
                            catch { }

                            html = await page.ContentAsync().ConfigureAwait(false);
                        }
                        #endregion

                        #region iframe
                        if (init.view.iframe != null && url.Contains(init.host))
                        {
                            string iframeUrl = CSharpEval.Execute<string>(evalCodeToRegexMatch(init.view.iframe), new NxtRegexMatch(html, init.view.iframe));
                            if (!string.IsNullOrEmpty(iframeUrl) && iframeUrl != url)
                            {
                                url = init.view.iframe.format != null ? init.view.iframe.format.Replace("{value}", iframeUrl) : iframeUrl;
                                goto resetGotoAsync;
                            }
                        }
                        #endregion

                        if (!string.IsNullOrEmpty(init.view.playbtn))
                            await page.ClickAsync(init.view.playbtn).ConfigureAwait(false);

                        if (init.view.nodeFile != null)
                        {
                            #region nodeFile
                            string goFile(string _content)
                            {
                                if (!string.IsNullOrEmpty(_content))
                                {
                                    var doc = new HtmlDocument();
                                    doc.LoadHtml(_content);
                                    var videoNode = doc.DocumentNode.SelectSingleNode(init.view.nodeFile.node);
                                    if (videoNode != null)
                                        return (!string.IsNullOrEmpty(init.view.nodeFile.attribute) ? videoNode.GetAttributeValue(init.view.nodeFile.attribute, null) : videoNode.InnerText)?.Trim();
                                }

                                return null;
                            }

                            if (init.view.NetworkIdle)
                            {
                                for (int i = 0; i < 10; i++)
                                {
                                    cache.file = goFile(await page.ContentAsync().ConfigureAwait(false));
                                    if (!string.IsNullOrEmpty(cache.file))
                                        break;

                                    PlaywrightBase.ConsoleLog("ContentAsync: " + (i + 1));
                                    await Task.Delay(800).ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                cache.file = goFile(html);
                            }

                            PlaywrightBase.ConsoleLog($"Playwright: SET {cache.file}");
                            #endregion
                        }
                        else if (init.view.regexMatch != null)
                        {
                            #region regexMatch
                            if (init.view.NetworkIdle)
                            {
                                for (int i = 0; i < 10; i++)
                                {
                                    cache.file = CSharpEval.Execute<string>(evalCodeToRegexMatch(init.view.regexMatch), new NxtRegexMatch(html, init.view.regexMatch));
                                    if (!string.IsNullOrEmpty(cache.file) && init.view.regexMatch.format != null)
                                        cache.file = init.view.regexMatch.format.Replace("{value}", cache.file).Replace("{host}", init.host);

                                    if (!string.IsNullOrEmpty(cache.file))
                                        break;

                                    PlaywrightBase.ConsoleLog("ContentAsync: " + (i + 1));
                                    await Task.Delay(800).ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                cache.file = CSharpEval.Execute<string>(evalCodeToRegexMatch(init.view.regexMatch), new NxtRegexMatch(html, init.view.regexMatch));
                                if (!string.IsNullOrEmpty(cache.file) && init.view.regexMatch.format != null)
                                    cache.file = init.view.regexMatch.format.Replace("{value}", cache.file).Replace("{host}", init.host);
                            }

                            PlaywrightBase.ConsoleLog($"Playwright: SET {cache.file}");
                            #endregion
                        }
                        else if (string.IsNullOrEmpty(init.view.eval ?? init.view.evalJS))
                        {
                            cache.file = await browser.WaitPageResult().ConfigureAwait(false);
                        }

                        cache.file = cache.file?.Replace("\\", "")?.Replace("&amp;", "&");

                        #region eval
                        if (!string.IsNullOrEmpty(init.view.eval ?? init.view.evalJS))
                        {
                            Task<string> goFile(string _content)
                            {
                                if (!string.IsNullOrEmpty(_content))
                                {
                                    string infile = $"NextHUB/sites/{init.view.eval ?? init.view.evalJS}";
                                    if ((infile.EndsWith(".cs") || infile.EndsWith(".js")) && System.IO.File.Exists(infile))
                                    {
                                        string evaluate = FileCache.ReadAllText(infile);

                                        if (infile.EndsWith(".js"))
                                            return page.EvaluateAsync<string>($"(html, plugin, url, file) => {{ {evaluate} }}", new { _content, plugin, url, cache.file });

                                        var nxt = new NxtEvalView(init, HttpContext.Request.Query, _content, plugin, url, cache.file, cache.headers, proxyManager);
                                        return CSharpEval.ExecuteAsync<string>(goEval(evaluate), nxt, Root.evalOptionsFull);
                                    }
                                    else
                                    {
                                        if (init.view.evalJS != null)
                                            return page.EvaluateAsync<string>($"(html, plugin, url, file) => {{ {init.view.evalJS} }}", new { _content, plugin, url, cache.file });

                                        var nxt = new NxtEvalView(init, HttpContext.Request.Query, _content, plugin, url, cache.file, cache.headers, proxyManager);
                                        return CSharpEval.ExecuteAsync<string>(goEval(init.view.eval), nxt, Root.evalOptionsFull);
                                    }
                                }

                                return null;
                            }

                            if (init.view.NetworkIdle)
                            {
                                for (int i = 0; i < 10; i++)
                                {
                                    cache.file = await goFile(await page.ContentAsync().ConfigureAwait(false)).ConfigureAwait(false);
                                    if (!string.IsNullOrEmpty(cache.file))
                                        break;

                                    PlaywrightBase.ConsoleLog("ContentAsync: " + (i + 1));
                                    await Task.Delay(800).ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                cache.file = await goFile(html).ConfigureAwait(false);
                            }

                            PlaywrightBase.ConsoleLog($"Playwright: SET {cache.file}");
                        }
                        #endregion

                        if (string.IsNullOrEmpty(cache.file))
                        {
                            proxyManager.Refresh();
                            return default;
                        }

                        if (cache.file.StartsWith("GotoAsync:"))
                        {
                            url = cache.file.Replace("GotoAsync:", "").Trim();
                            goto resetGotoAsync;
                        }

                        #region related
                        if (init.view.related && cache.recomends == null)
                        {
                            if (init.view.NetworkIdle)
                            {
                                string contetnt = await page.ContentAsync().ConfigureAwait(false);
                                cache.recomends = ListController.goPlaylist(requestInfo, host, init.view.relatedParse ?? init.contentParse, init, contetnt, plugin);
                            }
                            else
                            {
                                cache.recomends = ListController.goPlaylist(requestInfo, host, init.view.relatedParse ?? init.contentParse, init, html, plugin);
                            }
                        }
                        #endregion
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(init.view.cache_time, init: init));
                }

                return cache;
            }
            catch (Exception ex)
            {
                if (init.debug)
                    Console.WriteLine(ex);

                return default; 
            }
        }
        #endregion

        #region goVideoToHttp
        async ValueTask<(string file, List<HeadersModel> headers, List<PlaylistItem> recomends)> goVideoToHttp(RchClient rch, string plugin, string url, NxtSettings init, ProxyManager proxyManager, WebProxy proxy)
        {
            if (string.IsNullOrEmpty(url))
                return default;

            try
            {
                string memKey = $"nexthub:view18:goVideo:{url}";

                if (init.view.bindingToIP)
                    memKey = rch.ipkey(memKey, proxyManager);

                if (!hybridCache.TryGetValue(memKey, out (string file, List<HeadersModel> headers, List<PlaylistItem> recomends) cache))
                {
                    resetGotoAsync:
                    string html = rch.enable ? await rch.Get(url, httpHeaders(init)) :
                                               await Http.Get(url, headers: httpHeaders(init), proxy: proxy, timeoutSeconds: 8);

                    if (string.IsNullOrEmpty(html))
                        return default;

                    #region iframe
                    if (init.view.iframe != null && url.Contains(init.host))
                    {
                        string iframeUrl = CSharpEval.Execute<string>(evalCodeToRegexMatch(init.view.iframe), new NxtRegexMatch(html, init.view.iframe));
                        if (!string.IsNullOrEmpty(iframeUrl) && iframeUrl != url)
                        {
                            url = init.view.iframe.format != null ? init.view.iframe.format.Replace("{value}", iframeUrl) : iframeUrl;
                            goto resetGotoAsync;
                        }
                    }
                    #endregion

                    if (init.view.nodeFile != null)
                    {
                        #region nodeFile
                        string goFile(string _content)
                        {
                            var doc = new HtmlDocument();
                            doc.LoadHtml(_content);
                            var videoNode = doc.DocumentNode.SelectSingleNode(init.view.nodeFile.node);
                            if (videoNode != null)
                                return (!string.IsNullOrEmpty(init.view.nodeFile.attribute) ? videoNode.GetAttributeValue(init.view.nodeFile.attribute, null) : videoNode.InnerText)?.Trim();

                            return null;
                        }

                        cache.file = goFile(html);

                        PlaywrightBase.ConsoleLog($"Playwright: SET {cache.file}");
                        #endregion
                    }
                    else if (init.view.regexMatch != null)
                    {
                        #region regexMatch
                        cache.file = CSharpEval.Execute<string>(evalCodeToRegexMatch(init.view.regexMatch), new NxtRegexMatch(html, init.view.regexMatch));
                        if (!string.IsNullOrEmpty(cache.file) && init.view.regexMatch.format != null)
                            cache.file = init.view.regexMatch.format.Replace("{value}", cache.file).Replace("{host}", init.host);

                        PlaywrightBase.ConsoleLog($"Playwright: SET {cache.file}");
                        #endregion
                    }

                    cache.file = cache.file?.Replace("\\", "")?.Replace("&amp;", "&");

                    #region eval
                    if (!string.IsNullOrEmpty(init.view.eval))
                    {
                        var nxt = new NxtEvalView(init, HttpContext.Request.Query, html, plugin, url, cache.file, cache.headers, proxyManager);
                        cache.file = await CSharpEval.ExecuteAsync<string>(goEval(init.view.eval), nxt, Root.evalOptionsFull).ConfigureAwait(false);

                        PlaywrightBase.ConsoleLog($"Playwright: SET {cache.file}");
                    }
                    #endregion

                    if (string.IsNullOrEmpty(cache.file))
                    {
                        if (!rch.enable)
                            proxyManager.Refresh();

                        return default;
                    }

                    if (cache.file.StartsWith("GotoAsync:"))
                    {
                        url = cache.file.Replace("GotoAsync:", "").Trim();
                        goto resetGotoAsync;
                    }

                    if (init.view.related && cache.recomends == null)
                        cache.recomends = ListController.goPlaylist(requestInfo, host, init.view.relatedParse ?? init.contentParse, init, html, plugin);

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, cache, cacheTime(init.view.cache_time, init: init));
                }

                return cache;
            }
            catch (Exception ex)
            {
                if (init.debug)
                    Console.WriteLine(ex);

                return default;
            }
        }
        #endregion


        #region evalCodeToRegexMatch
        static string evalCodeToRegexMatch(RegexMatchSettings rm)
        {
            return @"if (m.matches != null && m.matches.Length > 0)
            {
                foreach (string q in m.matches)
                {
                    string file = Regex.Match(html, m.pattern.Replace(""{value}"", $""{q}""), RegexOptions.IgnoreCase).Groups[m.index].Value;
                    if (!string.IsNullOrEmpty(file))
                        return file;
                }
                return null;
            }

            return Regex.Match(html, m.pattern, RegexOptions.IgnoreCase).Groups[m.index].Value;";
        }
        #endregion

        #region goEval
        static string goEval(string evalcode)
        {
            string infile = $"NextHUB/sites/{evalcode}";
            if (infile.EndsWith(".cs") && System.IO.File.Exists(infile))
                evalcode = FileCache.ReadAllText(infile);

            if (evalcode.Contains("{include:"))
            {
                string includePattern = @"{include:(?<file>[^}]+)}";
                var matches = Regex.Matches(evalcode, includePattern);
                foreach (Match match in matches)
                {
                    string file = match.Groups["file"].Value.Trim();
                    if (System.IO.File.Exists($"NextHUB/utils/{file}"))
                    {
                        string includeCode = FileCache.ReadAllText($"NextHUB/utils/{file}");
                        evalcode = evalcode.Replace(match.Value, includeCode);
                    }
                }
            }

            return evalcode;
        }
        #endregion
    }
}

```

## File: SISI/Controllers/BongaCams/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.PlaywrightCore;

namespace SISI.Controllers.BongaCams
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("bgs")]
        async public ValueTask<ActionResult> Index(string search, string sort, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.BongaCams);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (!string.IsNullOrEmpty(search))
                return OnError("no search", false);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return OnError(rch_error);

            string memKey = $"BongaCams:list:{sort}:{pg}";

            return await InvkSemaphore(memKey, async () => 
            {
                if (!hybridCache.TryGetValue(memKey, out (List<PlaylistItem> playlists, int total_pages) cache, inmemory: false))
                {
                    reset: string html = await BongaCamsTo.InvokeHtml(init.corsHost(), sort, pg, url =>
                    {
                        if (rch.enable)
                            return rch.Get(init.cors(url), httpHeaders(init));

                        if (init.priorityBrowser == "http")
                            return Http.Get(url, httpversion: 2, timeoutSeconds: 8, headers: httpHeaders(init), proxy: proxy.proxy);

                        return PlaywrightBrowser.Get(init, url, httpHeaders(init), proxy.data);
                    });

                    cache.playlists = BongaCamsTo.Playlist(html, out int total_pages);
                    cache.total_pages = total_pages;

                    if (cache.playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, cache, cacheTime(5, init: init), inmemory: false);
                }

                return OnResult(cache.playlists, init, BongaCamsTo.Menu(host, sort), proxy: proxy.proxy, total_pages: cache.total_pages);
            });
        }
    }
}

```

## File: SISI/Controllers/BongaCams/StreamController.cs
```
Ôªø//using System;
//using System.Collections.Generic;
//using System.Threading.Tasks;
//using Lampac.Engine;
//using Lampac.Engine.CORE;
//using Lampac.Model.SISI.BongaCams;
//using Microsoft.AspNetCore.Mvc;
//using Microsoft.Extensions.Caching.Memory;

//namespace SISI.Controllers.BongaCams
//{
//    public class StreamController : BaseController
//    {
//        [HttpGet]
//        [Route("bgs/potok.m3u8")]
//        async public Task<ActionResult> Index(string baba)
//        {
//            if (!AppInit.conf.BongaCams.enable)
//                return OnError("disable");

//            string memKey = $"bongacams:stream:{baba}";
//            if (memoryCache.TryGetValue(memKey, out string hls))
//                return Redirect(HostStreamProxy(AppInit.conf.BongaCams.streamproxy, hls));

//            var root = await HttpClient.Post<Amf>(
//                       $"{AppInit.conf.BongaCams.host}/tools/amf.php?x-country=ua&res=1061112?{DateTimeOffset.UtcNow.ToUnixTimeSeconds()}", $"method=getRoomData&args%5B%5D={baba}&args%5B%5D=&args%5B%5D=",
//                       useproxy: AppInit.conf.BongaCams.useproxy,
//                       addHeaders: new List<(string name, string val)>()
//            {
//                ("dnt", "1"),
//                //("referer", AppInit.conf.BongaCams.host),
//                ("sec-fetch-dest", "empty"),
//                ("sec-fetch-mode", "cors"),
//                ("sec-fetch-site", "same-origin"),
//                ("x-requested-with", "XMLHttpRequest"),
//                ("x-ab-split-group", "5645da7355b7d0ac0590e38a54d1d996f6754e425c1709e4420e1c68d90620315932e5bef13fd38e"),
//                //("cookie", "bonga20120608=dcf21cf81fc13991e8f999c26126a857; ts_type2=1; fv=ZGR5BGL0AGV2ZD==; uh=GH5AAJMvIy9bLzkmDaSZsyOTsxg6Zt==; sg=501; BONGA_REF=https%3A%2F%2Fwww.google.com%2F; reg_ver2=3; warning18=%5B%22ru_RU%22%5D; __ti=H4sIAAAAAAACAyWIOw6AIBBEr2KmJ9ldIcbZ05BIQa3BgnB3Fav3GcNhymQUXZKETYKaGLgrT8cBTt6lNjB-ev3LWB1teufK7FGVtb-dHxKMhapUAAAA; __asc=6527103917a758e97aa2f42fa81; __auc=6527103917a758e97aa2f42fa81; _ga=GA1.2.901307154.1625469917; _gid=GA1.2.1041270203.1625469917; _gat_gtag_UA_10874655_24=1; _gat_gtag_UA_10874655_62=1; tj0ffcjy9e=1802827793"),
//            });

//            if (string.IsNullOrWhiteSpace(root?.localData?.videoServerUrl))
//                return OnError("baba");

//            hls = $"http:{root.localData.videoServerUrl}/hls/stream_{baba}/public-aac/stream_{baba}/chunks.m3u8";
//            memoryCache.Set(memKey, hls, DateTime.Now.AddMinutes(AppInit.conf.multiaccess ? 10 : 5));

//            return Redirect(HostStreamProxy(AppInit.conf.BongaCams.streamproxy, hls));
//        }
//    }
//}

```

## File: SISI/Controllers/Porntrex/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Porntrex
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("ptx")]
        async public ValueTask<ActionResult> Index(string search, string sort, string c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Porntrex);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return OnError(rch_error);

            string memKey = $"ptx:{search}:{sort}:{c}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    string html = await PorntrexTo.InvokeHtml(init.corsHost(), search, sort, c, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    playlists = PorntrexTo.Playlist("ptx/vidosik", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(playlists, PorntrexTo.Menu(host, search, sort, c), headers: HeadersModel.Init("referer", $"{init.host}/"), plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Porntrex/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using System.Web;

namespace SISI.Controllers.Porntrex
{
    public class ViewController : BaseSisiController
    {
        ProxyManager proxyManager = new ProxyManager("ptx", AppInit.conf.Porntrex);

        [HttpGet]
        [Route("ptx/vidosik")]
        async public ValueTask<ActionResult> vidosik(string uri)
        {
            var init = await loadKit(AppInit.conf.Porntrex);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: init.apnstream ? -1 : null);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return OnError(rch_error);

            string memKey = rch.ipkey($"porntrex:view:{uri}", proxyManager);

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out (Dictionary<string, string> links, bool userch) cache))
                {
                    reset:
                    cache.links = await PorntrexTo.StreamLinks(init.corsHost(), uri, url =>
                    {
                        if (rch.enable)
                            return rch.Get(init.cors(url), httpHeaders(init));

                        return Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxyManager.Get(), headers: httpHeaders(init));
                    });

                    if (cache.links == null || cache.links.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    cache.userch = rch.enable;
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                if (cache.userch)
                {
                    var hdstr = httpHeaders(init.host, init.headers_stream);
                    return OnResult(cache.links, init, proxyManager.Get(), headers_stream: hdstr);
                }

                return Json(cache.links.ToDictionary(k => k.Key, v => $"{host}/ptx/strem?link={HttpUtility.UrlEncode(v.Value)}"));
            });
        }


        [HttpGet]
        [Route("ptx/strem")]
        async public ValueTask<ActionResult> strem(string link)
        {
            var init = await loadKit(AppInit.conf.Porntrex);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (init.rhub && !init.rhub_fallback)
                return OnError("rhub_fallback");

            var proxy = proxyManager.Get();

            string memKey = $"Porntrex:strem:{link}:{proxyManager.CurrentProxyIp}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out string location))
                {
                    location = await Http.GetLocation(link, timeoutSeconds: 10, httpversion: 2, proxy: proxy, headers: httpHeaders(init, HeadersModel.Init(
                        ("sec-fetch-dest", "document"),
                        ("sec-fetch-mode", "navigate"),
                        ("sec-fetch-site", "none")
                    )));

                    if (string.IsNullOrEmpty(location) || link == location)
                        return OnError("location", proxyManager);

                    proxyManager.Success();
                    hybridCache.Set(memKey, location, cacheTime(40, init: init));
                }

                return Redirect(HostStreamProxy(init, location, proxy: proxy));
            });
        }
    }
}

```

## File: SISI/Controllers/Ebalovo/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Ebalovo
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("elo")]
        async public ValueTask<ActionResult> Index(string search, string sort, string c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Ebalovo);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"elo:{search}:{sort}:{c}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    var headers = httpHeaders(init, HeadersModel.Init(
                        ("sec-fetch-dest", "document"),
                        ("sec-fetch-mode", "navigate"),
                        ("sec-fetch-site", "same-origin"),
                        ("sec-fetch-user", "?1"),
                        ("upgrade-insecure-requests", "1")
                    ));

                    string ehost = await RootController.goHost(init.corsHost(), proxy);

                    reset:
                    string html = await EbalovoTo.InvokeHtml(ehost, search, sort, c, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), headers) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: headers)
                    );

                    playlists = EbalovoTo.Playlist("elo/vidosik", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(playlists, string.IsNullOrEmpty(search) ? EbalovoTo.Menu(host, sort, c) : null, plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Ebalovo/RootController.cs
```
Ôªøusing System.Net;

namespace SISI.Controllers.Ebalovo
{
    public static class RootController
    {
        async public static ValueTask<string> goHost(string host, WebProxy proxy = null)
        {
            if (!Regex.IsMatch(host, "^https?://www\\."))
                return host;

            var hybridCache = new HybridCache();
            string backhost = "https://web.epalovo.com";

            string memkey = $"ebalovo:gohost:{host}";
            if (hybridCache.TryGetValue(memkey, out string _host, inmemory: true))
                return _host;

            _host = await Http.GetLocation(host, timeoutSeconds: 5, proxy: proxy, allowAutoRedirect: true);
            if (_host != null && !Regex.IsMatch(_host, "^https?://www\\."))
            {
                _host = Regex.Replace(_host, "/$", "");
                hybridCache.Set(memkey, _host, DateTime.Now.AddHours(1), inmemory: true);
                return _host;
            }
            else
            {
                hybridCache.Set(memkey, backhost, DateTime.Now.AddMinutes(20), inmemory: true);
                return backhost;
            }
        }
    }
}

```

## File: SISI/Controllers/Ebalovo/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Ebalovo
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("elo/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            var init = await loadKit(AppInit.conf.Ebalovo);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return OnError(rch_error);

            if (rch.enable && 484 > rch.InfoConnected()?.apkVersion)
            {
                rch.Disabled(); // –Ω–∞ –≤–µ—Ä—Å–∏—è—Ö –Ω–∏–∂–µ java.lang.OutOfMemoryError
                if (!init.rhub_fallback)
                    return OnError("apkVersion", false);
            }

            string memKey = rch.ipkey($"ebalovo:view:{uri}", proxyManager);

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    string ehost = await RootController.goHost(init.corsHost());

                    reset:
                    stream_links = await EbalovoTo.StreamLinks("elo/vidosik", ehost, uri,
                        url =>
                        {
                            var headers = httpHeaders(init, HeadersModel.Init(
                                ("sec-fetch-dest", "document"),
                                ("sec-fetch-mode", "navigate"),
                                ("sec-fetch-site", "same-origin"),
                                ("sec-fetch-user", "?1"),
                                ("upgrade-insecure-requests", "1")
                            ));

                            return rch.enable ? rch.Get(init.cors(url), headers) : Http.Get(init.cors(url), timeoutSeconds: 8, proxy: proxy, headers: headers);
                        },
                        async location =>
                        {
                            var headers = httpHeaders(init, HeadersModel.Init(
                                ("referer", $"{ehost}/"),
                                ("sec-fetch-dest", "video"),
                                ("sec-fetch-mode", "no-cors"),
                                ("sec-fetch-site", "same-origin")
                            ));

                            if (rch.enable)
                            {
                                var res = await rch.Headers(init.cors(location), null, headers);
                                return res.currentUrl;
                            }

                            return await Http.GetLocation(init.cors(location), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));
                        }
                    );

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: "elo", total_pages: 1);

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/Chaturbate/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Chaturbate
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("chu")]
        async public ValueTask<ActionResult> Index(string search, string sort, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Chaturbate);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (!string.IsNullOrEmpty(search))
                return OnError("no search", false);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"Chaturbate:list:{sort}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset: string html = await ChaturbateTo.InvokeHtml(init.corsHost(), sort, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    playlists = ChaturbateTo.Playlist("chu/potok", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(5, init: init), inmemory: false);
                }

                return OnResult(playlists, ChaturbateTo.Menu(host, sort), plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Chaturbate/StreamController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Chaturbate
{
    public class StreamController : BaseSisiController
    {
        [HttpGet]
        [Route("chu/potok")]
        async public ValueTask<ActionResult> Index(string baba)
        {
            var init = await loadKit(AppInit.conf.Chaturbate);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"chaturbate:stream:{baba}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out Dictionary<string, string> stream_links))
                {
                    reset:
                    stream_links = await ChaturbateTo.StreamLinks(init.corsHost(), baba, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    if (stream_links == null || stream_links.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!init.rhub)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(10, init: init));
                }

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/XvideosRED/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using System.Web;

namespace SISI.Controllers.XvideosRED
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("xdsred")]
        async public ValueTask<ActionResult> Index(string search, string sort, string c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.XvideosRED);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string plugin = init.plugin;
            bool ismain = sort != "like" && string.IsNullOrEmpty(search) && string.IsNullOrEmpty(c);
            string memKey = $"{plugin}:list:{search}:{c}:{sort}:{(ismain ? 0 : pg)}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    var proxyManager = new ProxyManager(init);
                    var proxy = proxyManager.Get();

                    #region –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º url
                    string url;

                    if (!string.IsNullOrEmpty(search))
                    {
                        url = $"{init.corsHost()}/?k={HttpUtility.UrlEncode(search)}&p={pg}&premium=1";
                    }
                    else
                    {
                        if (sort == "like")
                        {
                            url = $"{init.corsHost()}/videos-i-like/{pg - 1}";
                        }
                        else if (!string.IsNullOrEmpty(c))
                        {
                            url = $"{init.corsHost()}/c/s:{(sort == "top" ? "rating" : "uploaddate")}/p:1/{c}/{pg}";
                        }
                        else
                        {
                            url = $"{init.corsHost()}/red/videos/{DateTime.Today.AddDays(-1):yyyy-MM-dd}";
                        }
                    }
                    #endregion

                    string html = await Http.Get(init.cors(url), cookie: init.cookie, timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init));
                    if (html == null)
                        return OnError("html", proxyManager, string.IsNullOrEmpty(search));

                    playlists = XvideosTo.Playlist("xdsred/vidosik", $"{plugin}/stars", html, site: plugin);

                    if (playlists.Count == 0)
                        return OnError("playlists", proxyManager, pg > 1 && string.IsNullOrEmpty(search));

                    proxyManager.Success();
                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                if (ismain)
                    playlists = playlists.Skip((pg * 36) - 36).Take(36).ToList();

                return OnResult(playlists, string.IsNullOrEmpty(search) ? XvideosTo.Menu(host, plugin, sort, c) : null, plugin: plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/XvideosRED/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.XvideosRED
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("xdsred/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            var init = await loadKit(AppInit.conf.XvideosRED);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            string memKey = $"xdsred:view:{uri}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    stream_links = await XvideosTo.StreamLinks("xdsred/vidosik", "xdsred/stars", init.corsHost(), uri,
                        url => Http.Get(url, cookie: init.cookie, timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                        return OnError("stream_links", proxyManager);

                    proxyManager.Success();
                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/Eporner/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Eporner
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("epr")]
        async public ValueTask<ActionResult> Index(string search, string sort, string c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Eporner);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            pg += 1;

            string memKey = $"epr:{search}:{sort}:{c}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    string html = await EpornerTo.InvokeHtml(init.corsHost(), search, sort, c, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    playlists = EpornerTo.Playlist("epr/vidosik", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(playlists, EpornerTo.Menu(host, search, sort, c), plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Eporner/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Eporner
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("epr/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            var init = await loadKit(AppInit.conf.Eporner);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"eporner:view:{uri}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    reset:
                    stream_links = await EpornerTo.StreamLinks("epr/vidosik", init.corsHost(), uri,
                                   htmlurl => rch.enable ? rch.Get(init.cors(htmlurl), httpHeaders(init)) : Http.Get(init.cors(htmlurl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
                                   jsonurl => rch.enable ? rch.Get(init.cors(jsonurl), httpHeaders(init)) : Http.Get(init.cors(jsonurl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)));

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: Catalog/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.PlaywrightCore;
using System.Net.Http;

namespace Catalog.Controllers
{
    public class ListController : BaseController
    {
        [HttpGet]
        [Route("catalog/list")]
        async public ValueTask<ActionResult> Index(string query, string plugin, string cat, string sort, int page = 1)
        {
            var init = ModInit.goInit(plugin)?.Clone();
            if (init == null || !init.enable)
                return BadRequest("init not found");

            if (!string.IsNullOrEmpty(query) && string.IsNullOrEmpty(init.search?.uri))
                return BadRequest("search disable");

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected())
                rch.Disabled();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string search = query;
            string memKey = $"catalog:{plugin}:{search}:{sort}:{cat}:{page}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out (List<PlaylistItem> playlists, int total_pages) cache, inmemory: false))
                {
                    #region contentParse
                    var contentParse = init.list?.contentParse ?? init.content;

                    if (!string.IsNullOrEmpty(search) && init.search?.contentParse != null)
                        contentParse = init.search.contentParse;
                    #endregion

                    #region html
                    var headers = httpHeaders(init);
                    var parse = init.list;

                    string url = $"{init.host}/{(page == 1 && init.list?.firstpage != null ? init.list?.firstpage : init.list?.uri)}";
                    string data = init.list?.postData;

                    if (!string.IsNullOrEmpty(search))
                    {
                        string uri = page == 1 && init.search?.firstpage != null ? init.search.firstpage : init.search?.uri;
                        url = $"{init.host}/{uri}".Replace("{search}", HttpUtility.UrlEncode(search));

                        data = init.search?.postData?.Replace("{search}", HttpUtility.UrlEncode(search));
                        parse = init.search;
                    }
                    else if (!string.IsNullOrEmpty(cat))
                    {
                        var menu = init.menu.FirstOrDefault(i => i.categories.Values.Contains(cat));
                        if (menu == null)
                            return BadRequest("menu");

                        string getFormat(string key)
                        {
                            if (menu.format.TryGetValue(key, out string _f))
                                return _f;

                            return string.Empty;
                        }

                        string eval = (cat != null && sort != null) ? getFormat("sort") : getFormat("-");
                        if (!string.IsNullOrEmpty(eval))
                        {
                            if (!eval.Contains("$\"") && eval.Contains("{") && eval.Contains("}"))
                                eval = $"return $\"{eval}\";";

                            url = CSharpEval.BaseExecute<string>(eval, new CatalogGlobalsMenuRoute(init.host, plugin, init.args, url, search, cat, sort, HttpContext.Request.Query, page));
                        }

                        if (!url.StartsWith("http"))
                            url = $"{init.host}/{url}";
                    }

                    if (init.args != null)
                        url = url.Contains("?") ? $"{url}&{init.args}" : $"{url}?{init.args}";

                    if (parse?.initUrl != null)
                        url = CSharpEval.Execute<string>(parse.initUrl, new CatalogGlobalsMenuRoute(init.host, plugin, init.args, url, search, cat, sort, HttpContext.Request.Query, page));

                    if (parse?.initHeader != null)
                        headers = CSharpEval.Execute<List<HeadersModel>>(parse.initHeader, new CatalogInitHeader(url, headers));

                    reset:
                    string html = null;

                    if (!string.IsNullOrEmpty(data))
                    {
                        string mediaType = data.StartsWith("{") || data.StartsWith("[") ? "application/json" : "application/x-www-form-urlencoded";
                        var httpdata = new StringContent(data, Encoding.UTF8, mediaType);

                        html = rch.enable
                            ? await rch.Post(url.Replace("{page}", page.ToString()), data, headers, useDefaultHeaders: init.useDefaultHeaders)
                            : await Http.Post(url.Replace("{page}", page.ToString()), httpdata, headers: headers, proxy: proxy.proxy, timeoutSeconds: init.timeout, useDefaultHeaders: init.useDefaultHeaders);
                    }
                    else
                    {
                        html = rch.enable
                            ? await rch.Get(url.Replace("{page}", page.ToString()), headers, useDefaultHeaders: init.useDefaultHeaders)
                            : init.priorityBrowser == "playwright" ? await PlaywrightBrowser.Get(init, url.Replace("{page}", page.ToString()), headers, proxy.data, cookies: init.cookies)
                            : await Http.Get(url.Replace("{page}", page.ToString()), headers: headers, proxy: proxy.proxy, timeoutSeconds: init.timeout, useDefaultHeaders: init.useDefaultHeaders);
                    }
                    #endregion

                    bool? jsonPath = contentParse.jsonPath;
                    if (jsonPath == null)
                        jsonPath = init.jsonPath;

                    #region parse doc/json
                    HtmlDocument doc = null;
                    JToken json = null;

                    if (jsonPath == true)
                    {
                        try
                        {
                            json = JToken.Parse(html);
                        }
                        catch
                        {
                            json = null;
                        }
                    }
                    else
                    {
                        doc = new HtmlDocument();

                        if (html != null)
                            doc.LoadHtml(html);
                    }
                    #endregion

                    cache.playlists = jsonPath == true
                        ? goPlaylistJson(cat, json, requestInfo, host, contentParse, init, html, plugin)
                        : goPlaylist(cat, doc, requestInfo, host, contentParse, init, html, plugin);

                    if (cache.playlists == null || cache.playlists.Count == 0)
                    {
                        if (ModInit.IsRhubFallback(init))
                            goto reset;

                        if (!rch.enable)
                            proxyManager.Refresh();

                        return BadRequest("playlists");
                    }

                    if (contentParse.total_pages != null)
                    {
                        string _p = jsonPath == true
                            ? ModInit.nodeValue(json, contentParse.total_pages, host)?.ToString() ?? ""
                            : ModInit.nodeValue(doc.DocumentNode, contentParse.total_pages, host)?.ToString() ?? "";

                        if (int.TryParse(_p, out int _pages) && _pages > 0)
                            cache.total_pages = _pages;
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, cache, cacheTime(init.cache_time, init: init), inmemory: false);
                }

                #region total_pages
                int? total_pages = init.list?.total_pages ?? 0;

                if (search != null && init.search != null)
                    total_pages = init.search.total_pages;

                if (total_pages == 0)
                    total_pages = cache.total_pages;
                #endregion

                #region next_page
                bool? next_page = null;

                if (search != null)
                {
                    if (init.search != null && init.search.count_page > 0 && cache.playlists.Count >= init.search.count_page)
                        next_page = true;
                }
                else
                {
                    if (init.list != null && init.list.count_page > 0 && cache.playlists.Count >= init.list.count_page)
                        next_page = true;
                }

                if (next_page == true && total_pages == 0)
                    total_pages = null;
                #endregion

                #region results
                var results = new JArray();

                foreach (var pl in cache.playlists)
                {
                    var jo = new JObject()
                    {
                        ["id"] = pl.id,
                        ["img"] = pl.img
                    };

                    if (pl.is_serial)
                    {
                        jo["first_air_date"] = pl.year;
                        jo["name"] = pl.title;
                        jo["original_name"] = string.IsNullOrWhiteSpace(pl.original_title) ? pl.title : pl.original_title;
                    }
                    else
                    {
                        jo["release_date"] = pl.year;
                        jo["title"] = pl.title;
                        jo["original_title"] = string.IsNullOrWhiteSpace(pl.original_title) ? pl.title : pl.original_title;
                    }

                    if (pl.args != null)
                    {
                        foreach (var a in pl.args)
                            jo[a.Key] = JToken.FromObject(a.Value);
                    }

                    results.Add(jo);
                }
                #endregion

                return ContentTo(JsonConvert.SerializeObject(new 
                {
                    page,
                    results,
                    total_pages,
                    next_page

                }, new JsonSerializerSettings
                {
                    NullValueHandling = NullValueHandling.Ignore,
                    DefaultValueHandling = DefaultValueHandling.Ignore
                }));
            });
        }


        #region goPlaylistJson
        static List<PlaylistItem> goPlaylistJson(string cat, JToken json, in RequestModel requestInfo, string host, ContentParseSettings parse, CatalogSettings init, in string html, string plugin)
        {
            if (parse == null || json == null)
                return null;

            if (init.debug)
                Console.WriteLine(html);

            string eval = parse.eval;
            if (!string.IsNullOrEmpty(eval) && eval.EndsWith(".cs"))
                eval = FileCache.ReadAllText($"catalog/sites/{eval}");

            if (string.IsNullOrEmpty(parse.nodes))
            {
                if (string.IsNullOrEmpty(eval))
                    return null;

                var options = ScriptOptions.Default
                    .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                    .AddImports("Shared")
                    .AddImports("Shared.Models")
                    .AddImports("Shared.Engine")
                    .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll"))
                    .AddImports("Newtonsoft.Json")
                    .AddImports("Newtonsoft.Json.Linq");

                return CSharpEval.Execute<List<PlaylistItem>>(eval, new CatalogPlaylistJson(init, plugin, host, html, json, new List<PlaylistItem>()), options);
            }

            var nodes = json.SelectTokens(parse.nodes)?.ToList();
            if (nodes == null || nodes.Count == 0)
                return null;

            var playlists = new List<PlaylistItem>(nodes.Count);

            foreach (var node in nodes)
            {
                string name = ModInit.nodeValue(node, parse.name, host)?.ToString();
                string original_name = ModInit.nodeValue(node, parse.original_name, host)?.ToString();
                string href = ModInit.nodeValue(node, parse.href, host)?.ToString();
                string img = ModInit.nodeValue(node, parse.image, host)?.ToString();
                string year = ModInit.nodeValue(node, parse.year, host)?.ToString();

                if (init.debug)
                    Console.WriteLine($"\n\nname: {name}\noriginal_name: {original_name}\nhref: {href}\nimg: {img}\nyear: {year}\n\n{node.ToString(Formatting.None)}");

                if (!string.IsNullOrWhiteSpace(name) && !string.IsNullOrWhiteSpace(href))
                {
                    #region href
                    if (href.StartsWith("../"))
                        href = href.Replace("../", "");
                    else if (href.StartsWith("//"))
                        href = Regex.Replace(href, "//[^/]+/", "");
                    else if (href.StartsWith("http"))
                        href = Regex.Replace(href, "https?://[^/]+/", "");
                    else if (href.StartsWith("/"))
                        href = href.Substring(1);
                    #endregion

                    #region img
                    if (img != null)
                    {
                        img = img.Replace("&amp;", "&").Replace("\\", "");

                        if (img.StartsWith("../"))
                            img = $"{init.host}/{img.Replace("../", "")}";
                        else if (img.StartsWith("//"))
                            img = $"https:{img}";
                        else if (img.StartsWith("/"))
                            img = init.host + img;
                        else if (!img.StartsWith("http"))
                            img = $"{init.host}/{img}";
                    }
                    #endregion

                    if (!init.ignore_no_picture && string.IsNullOrEmpty(img))
                        continue;

                    string clearText(string text)
                    {
                        if (string.IsNullOrEmpty(text))
                            return text;

                        text = text.Replace("&nbsp;", "");
                        text = Regex.Replace(text, "<[^>]+>", "");
                        text = HttpUtility.HtmlDecode(text);
                        return text.Trim();
                    }

                    #region is_serial
                    bool? is_serial = null;

                    if (cat != null)
                    {
                        if (init.movie_cats != null && init.movie_cats.Contains(cat))
                            is_serial = false;
                        else if (init.serial_cats != null && init.serial_cats.Contains(cat))
                            is_serial = true;
                    }

                    if (is_serial == null && parse.serial_regex != null)
                        is_serial = Regex.IsMatch(node.ToString(Formatting.None), parse.serial_regex, RegexOptions.IgnoreCase);

                    if (is_serial == null && parse.serial_key != null)
                    {
                        if (ModInit.nodeValue(node, parse.serial_key, host) != null)
                            is_serial = true;
                    }
                    #endregion

                    var pl = new PlaylistItem()
                    {
                        id = href,
                        title = clearText(name),
                        original_title = clearText(original_name),
                        img = PosterApi.Size(host, img),
                        year = clearText(year),
                        is_serial = is_serial == true
                    };

                    if (parse.args != null)
                    {
                        foreach (var arg in parse.args)
                        {
                            if (pl.args == null)
                                pl.args = new JObject();

                            object val = ModInit.nodeValue(node, arg, host);
                            ModInit.setArgsValue(arg, val, pl.args);
                        }
                    }

                    if (eval != null)
                    {
                        var options = ScriptOptions.Default
                            .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                            .AddImports("Shared")
                            .AddImports("Shared.Models")
                            .AddImports("Shared.Engine")
                            .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll"))
                            .AddImports("Newtonsoft.Json")
                            .AddImports("Newtonsoft.Json.Linq");

                        pl = CSharpEval.Execute<PlaylistItem>(eval, new CatalogChangePlaylisJson(init, plugin, host, html, nodes, pl, node), options);
                    }

                    if (pl != null)
                        playlists.Add(pl);
                }
            }

            return playlists;
        }
        #endregion

        #region goPlaylist
        static List<PlaylistItem> goPlaylist(string cat, HtmlDocument doc, in RequestModel requestInfo, string host, ContentParseSettings parse, CatalogSettings init, in string html, string plugin)
        {
            if (parse == null || string.IsNullOrEmpty(html))
                return null;

            if (init.debug)
                Console.WriteLine(html);

            string eval = parse.eval;
            if (!string.IsNullOrEmpty(eval) && eval.EndsWith(".cs"))
                eval = FileCache.ReadAllText($"catalog/sites/{eval}");

            if (string.IsNullOrEmpty(parse.nodes))
            {
                if (string.IsNullOrEmpty(eval))
                    return null;

                var options = ScriptOptions.Default
                    .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                    .AddImports("Shared")
                    .AddImports("Shared.Models")
                    .AddImports("Shared.Engine")
                    .AddReferences(CSharpEval.ReferenceFromFile("HtmlAgilityPack.dll"))
                    .AddImports("HtmlAgilityPack");

                return CSharpEval.Execute<List<PlaylistItem>>(eval, new CatalogPlaylist(init, plugin, host, html, doc, new List<PlaylistItem>()), options);
            }

            var nodes = doc.DocumentNode.SelectNodes(parse.nodes);
            if (nodes == null || nodes.Count == 0)
                return null;

            var playlists = new List<PlaylistItem>(nodes.Count);

            foreach (var node in nodes)
            {
                string name = ModInit.nodeValue(node, parse.name, host)?.ToString();
                string original_name = ModInit.nodeValue(node, parse.original_name, host)?.ToString();
                string href = ModInit.nodeValue(node, parse.href, host)?.ToString();
                string img = ModInit.nodeValue(node, parse.image, host)?.ToString();
                string year = ModInit.nodeValue(node, parse.year, host)?.ToString();

                if (init.debug)
                    Console.WriteLine($"\n\nname: {name}\noriginal_name: {original_name}\nhref: {href}\nimg: {img}\nyear: {year}\n\n{node.OuterHtml}");

                if (!string.IsNullOrWhiteSpace(name) && !string.IsNullOrWhiteSpace(href))
                {
                    #region href
                    if (href.StartsWith("../"))
                        href = href.Replace("../", "");
                    else if (href.StartsWith("//"))
                        href = Regex.Replace(href, "//[^/]+/", "");
                    else if (href.StartsWith("http"))
                        href = Regex.Replace(href, "https?://[^/]+/", "");
                    else if (href.StartsWith("/"))
                        href = href.Substring(1);
                    #endregion

                    #region img
                    if (img != null)
                    {
                        img = img.Replace("&amp;", "&").Replace("\\", "");

                        if (img.StartsWith("../"))
                            img = $"{init.host}/{img.Replace("../", "")}";
                        else if (img.StartsWith("//"))
                            img = $"https:{img}";
                        else if (img.StartsWith("/"))
                            img = init.host + img;
                        else if (!img.StartsWith("http"))
                            img = $"{init.host}/{img}";
                    }
                    #endregion

                    if (!init.ignore_no_picture && string.IsNullOrEmpty(img))
                        continue;

                    #region is_serial
                    bool? is_serial = null;

                    if (cat != null)
                    {
                        if (init.movie_cats != null && init.movie_cats.Contains(cat))
                            is_serial = false;
                        else if (init.serial_cats != null && init.serial_cats.Contains(cat))
                            is_serial = true;
                    }

                    if (is_serial == null && parse.serial_regex != null)
                        is_serial = Regex.IsMatch(node.OuterHtml, parse.serial_regex, RegexOptions.IgnoreCase);

                    if (is_serial == null && parse.serial_key != null)
                    {
                        if (ModInit.nodeValue(node, parse.serial_key, host) != null)
                            is_serial = true;
                    }
                    #endregion

                    var pl = new PlaylistItem()
                    {
                        id = href,
                        title = ModInit.clearText(name),
                        original_title = ModInit.clearText(original_name),
                        img = PosterApi.Size(host, img),
                        year = ModInit.clearText(year),
                        is_serial = is_serial == true
                    };

                    if (parse.args != null)
                    {
                        foreach (var arg in parse.args)
                        {
                            if (pl.args == null)
                                pl.args = new JObject();

                            object val = ModInit.nodeValue(node, arg, host);
                            ModInit.setArgsValue(arg, val, pl.args);
                        }
                    }

                    if (eval != null)
                    {
                        var options = ScriptOptions.Default
                            .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                            .AddImports("Shared")
                            .AddImports("Shared.Models")
                            .AddImports("Shared.Engine")
                            .AddReferences(CSharpEval.ReferenceFromFile("HtmlAgilityPack.dll"))
                            .AddImports("HtmlAgilityPack");

                        pl = CSharpEval.Execute<PlaylistItem>(eval, new CatalogChangePlaylis(init, plugin, host, html, nodes, pl, node), options);
                    }

                    if (pl != null)
                        playlists.Add(pl);
                }
            }

            return playlists;
        }
        #endregion
    }
}

```

## File: Catalog/ApiController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace Catalog.Controllers
{
    public class ApiController : BaseController
    {
        #region catalog.js
        [HttpGet]
        [AllowAnonymous]
        [Route("catalog.js")]
        [Route("catalog/js/{token}")]
        public ActionResult CatalogJS(string token)
        {
            var sb = new StringBuilder(FileCache.ReadAllText("plugins/catalog.js"));

            sb.Replace("{localhost}", host)
              .Replace("{token}", HttpUtility.UrlEncode(token))
              .Replace("catalogs:{}", $"catalogs:{jsonCatalogs()}");

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        [HttpGet]
        [Route("catalog")]
        public ActionResult Index()
        {
            return ContentTo(jsonCatalogs());
        }


        string jsonCatalogs()
        {
            var result = new JObject();

            string dir = Path.Combine(AppContext.BaseDirectory, "catalog", "sites");
            if (!Directory.Exists(dir))
                return result.ToString(Formatting.None);

            #region sites
            var sites = new List<(string key, JObject obj, int index)>();

            foreach (var file in Directory.GetFiles(dir, "*.yaml"))
            {
                try
                {
                    var site = Path.GetFileNameWithoutExtension(file);
                    if (string.IsNullOrEmpty(site))
                        continue;

                    var init = ModInit.goInit(site);
                    if (init == null || !init.enable || init.menu == null || init.hide)
                        continue;

                    var siteObj = new JObject();

                    foreach (var menuItem in init.menu)
                    {
                        if (menuItem?.categories == null || menuItem.categories.Count == 0)
                            continue;

                        foreach (var cat in menuItem.categories)
                        {
                            string catName = cat.Key;
                            string catCode = cat.Value;

                            if (!(siteObj[catName] is JObject catObj))
                            {
                                catObj = new JObject();

                                if (init.search != null)
                                    siteObj["search"] = $"/catalog/list?plugin={HttpUtility.UrlEncode(menuItem.catalog ?? site)}";

                                siteObj["search_lazy"] = init.search_lazy;

                                if (!string.IsNullOrEmpty(init.catalog_key))
                                    siteObj["catalog_key"] = init.catalog_key;

                                if (!string.IsNullOrEmpty(menuItem.defaultName))
                                    siteObj["defaultName"] = menuItem.defaultName;

                                siteObj[catName] = catObj;
                            }

                            string baseUrl = $"/catalog/list?plugin={HttpUtility.UrlEncode(menuItem.catalog ?? site)}&cat={HttpUtility.UrlEncode(catCode)}";

                            bool addBaseEntry = true;
                            if (menuItem.format != null)
                            {
                                if (!menuItem.format.ContainsKey("-"))
                                    addBaseEntry = false;
                            }

                            if (addBaseEntry)
                            {
                                if (catObj[catName] == null)
                                    catObj[catName] = baseUrl;
                            }

                            if (menuItem.sort != null)
                            {
                                foreach (var s in menuItem.sort)
                                {
                                    string sortName = s.Key;
                                    string sortCode = s.Value;
                                    if (string.IsNullOrEmpty(sortName) || string.IsNullOrEmpty(sortCode))
                                        continue;

                                    string sortUrl = baseUrl + "&sort=" + HttpUtility.UrlEncode(sortCode);
                                    if (catObj[sortName] == null)
                                        catObj[sortName] = sortUrl;
                                }
                            }
                        }
                    }

                    string siteKey = !string.IsNullOrEmpty(init.plugin) ? init.plugin : init.displayname ?? site;

                    int idx = init.displayindex;
                    if (idx == 0)
                        idx = int.MaxValue - sites.Count;

                    sites.Add((siteKey, siteObj, idx));
                }
                catch { }
            }
            #endregion

            #region result
            foreach (var s in sites.OrderBy(x => x.index))
            {
                result[s.key] = new JObject();

                if (s.obj.ContainsKey("search"))
                    result[s.key]["search"] = s.obj["search"];

                result[s.key]["search_lazy"] = s.obj["search_lazy"];

                string catalog_key = s.obj.ContainsKey("catalog_key") ? s.obj["catalog_key"]?.ToString() : null;
                string defaultName = s.obj.ContainsKey("defaultName") ? s.obj["defaultName"]?.ToString() : null;

                var menu = new JObject();
                var main = new JObject();

                foreach (var prop in s.obj.Properties())
                {
                    if (!(prop.Value is JObject catObj))
                        continue;

                    foreach (var inner in catObj.Properties())
                    {
                        string pname = prop.Name;
                        if (pname.StartsWith("["))
                            pname = prop.Name.Split(']')[1].Trim();

                        if (pname != inner.Name)
                            main[$"{pname} ‚Ä¢ {inner.Name.ToLower()}"] = inner.Value;
                        else
                            main[pname] = inner.Value;

                        if (!menu.ContainsKey(pname) || (catalog_key != null && catalog_key == inner.Name))
                            menu[pname] = inner.Value;
                    }

                    var categoryMap = new Dictionary<string, string>
                    {
                        { "–§–∏–ª—å–º—ã", "movie" },
                        { "–°–µ—Ä–∏–∞–ª—ã", "tv" },
                        { "–ú—É–ª—å—Ç—Ñ–∏–ª—å–º—ã", "cartoons" },
                        { "–ê–Ω–∏–º–µ", "anime" },
                        { "–†–µ–ª–∏–∑—ã", "relise" }
                    };

                    string targetCat, targetName = null;

                    if (categoryMap.TryGetValue(prop.Name, out targetCat))
                        targetName = prop.Name;

                    if (prop.Name.StartsWith("["))
                    {
                        targetCat = prop.Name.Split(']')[0].Trim('[');
                        targetName = prop.Name.Split(']')[1];
                    }

                    if (!string.IsNullOrEmpty(targetName) && !string.IsNullOrEmpty(targetCat))
                    {
                        var targetObj = new JObject();

                        foreach (var inner in catObj.Properties())
                        {
                            if (targetName.Trim() != inner.Name)
                                targetObj[inner.Name] = inner.Value;
                            else
                                targetObj[defaultName ?? inner.Name] = inner.Value;
                        }

                        if (targetObj.HasValues)
                            result[s.key][targetCat.Trim()] = targetObj;
                    }
                }

                if (menu.HasValues)
                    result[s.key]["menu"] = menu;

                if (main.HasValues)
                    result[s.key]["main"] = main;
            }
            #endregion

            return result.ToString(Formatting.None);
        }
    }
}

```

## File: Catalog/ModInit.cs
```
Ôªøusing YamlDotNet.Serialization;

namespace Catalog
{
    public class ModInit
    {
        public static void loaded()
        {
        }

        #region goInit
        public static CatalogSettings goInit(string site)
        {
            if (string.IsNullOrEmpty(site))
                return null;

            site = site.Trim().ToLowerInvariant();

            var hybridCache = new HybridCache();

            string memKey = $"catalog:goInit:{site}";
            if (!hybridCache.TryGetValue(memKey, out CatalogSettings init))
            {
                // –ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ –∏–º–µ–Ω–∏, –ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –ø–æ displayname –≤ *.yaml
                if (!File.Exists($"catalog/sites/{site}.yaml"))
                {
                    string found = FindSiteByDisplayName(site);
                    if (string.IsNullOrEmpty(found))
                        return null;

                    site = found;
                }

                var deserializer = new DeserializerBuilder().Build();

                // –ß—Ç–µ–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ YAML-—Ñ–∞–π–ª–∞
                string yaml = File.ReadAllText($"catalog/sites/{site}.yaml");
                var target = deserializer.Deserialize<Dictionary<object, object>>(yaml);

                foreach (string y in new string[] { "_", site })
                {
                    if (File.Exists($"catalog/override/{y}.yaml"))
                    {
                        // –ß—Ç–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ YAML-—Ñ–∞–π–ª–∞
                        string myYaml = File.ReadAllText($"catalog/override/{y}.yaml");
                        var mySource = deserializer.Deserialize<Dictionary<object, object>>(myYaml);

                        // –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–ª–æ–≤–∞—Ä–µ–π
                        foreach (var property in mySource)
                        {
                            if (!target.ContainsKey(property.Key))
                            {
                                target[property.Key] = property.Value;
                                continue;
                            }

                            if (property.Value is IDictionary<object, object> sourceDict &&
                                target[property.Key] is IDictionary<object, object> targetDict)
                            {
                                // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö —Å–ª–æ–≤–∞—Ä–µ–π
                                foreach (var item in sourceDict)
                                    targetDict[item.Key] = item.Value;
                            }
                            else
                            {
                                target[property.Key] = property.Value;
                            }
                        }
                    }
                }

                // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å–ª–æ–≤–∞—Ä—è –≤ –æ–±—ä–µ–∫—Ç CatalogSettings
                var serializer = new SerializerBuilder().Build();

                var yamlResult = serializer.Serialize(target);
                init = deserializer.Deserialize<CatalogSettings>(yamlResult);

                if (string.IsNullOrEmpty(init.plugin))
                    init.plugin = init.displayname;

                if (!init.debug || !AppInit.conf.multiaccess)
                    hybridCache.Set(memKey, init, DateTime.Now.AddMinutes(1), inmemory: true);
            }

            return init;
        }
        #endregion

        #region FindSiteByDisplayName
        static string FindSiteByDisplayName(string site)
        {
            var deserializer = new DeserializerBuilder().Build();

            foreach (var folder in new[] { "catalog/sites", "catalog/override" })
            {
                if (!Directory.Exists(folder))
                    continue;

                foreach (var file in Directory.EnumerateFiles(folder, "*.yaml"))
                {
                    try
                    {
                        var yaml = File.ReadAllText(file);
                        var dict = deserializer.Deserialize<Dictionary<object, object>>(yaml);
                        if (dict != null && dict.TryGetValue("displayname", out var dnObj) && dnObj != null)
                        {
                            var dn = dnObj.ToString().Trim().ToLowerInvariant();
                            if (dn == site)
                                return Path.GetFileNameWithoutExtension(file);
                        }
                    }
                    catch { }
                }
            }

            return null;
        }
        #endregion

        #region IsRhubFallback
        public static bool IsRhubFallback(BaseSettings init)
        {
            if (init.rhub && init.rhub_fallback)
            {
                init.rhub = false;
                return true;
            }

            return false;
        }
        #endregion


        #region nodeValue - HtmlNode
        public static object nodeValue(HtmlNode node, SingleNodeSettings nd, string host)
        {
            string value = null;

            if (nd != null)
            {
                if (string.IsNullOrEmpty(nd.node) && (!string.IsNullOrEmpty(nd.attribute) || nd.attributes != null))
                {
                    if (nd.attributes != null)
                    {
                        foreach (var attr in nd.attributes)
                        {
                            var attrValue = node.GetAttributeValue(attr, null);
                            if (!string.IsNullOrEmpty(attrValue))
                            {
                                value = attrValue;
                                break;
                            }
                        }
                    }
                    else
                    {
                        value = node.GetAttributeValue(nd.attribute, null);
                    }
                }
                else
                {
                    var inNode = node.SelectSingleNode(nd.node);
                    if (inNode != null)
                    {
                        if (nd.attributes != null)
                        {
                            foreach (var attr in nd.attributes)
                            {
                                var attrValue = inNode.GetAttributeValue(attr, null);
                                if (!string.IsNullOrEmpty(attrValue))
                                {
                                    value = attrValue;
                                    break;
                                }
                            }
                        }
                        else
                        {
                            value = (!string.IsNullOrEmpty(nd.attribute) ? inNode.GetAttributeValue(nd.attribute, null) : inNode.InnerText)?.Trim();
                        }
                    }
                }
            }

            if (string.IsNullOrEmpty(value))
                return null;

            if (nd.format != null)
            {
                var options = ScriptOptions.Default
                    .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                    .AddImports("Shared")
                    .AddImports("Shared.Engine")
                    .AddImports("Shared.Models")
                    .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll"))
                    .AddImports("Newtonsoft.Json")
                    .AddImports("Newtonsoft.Json.Linq");

                return CSharpEval.Execute<object>(nd.format, new CatalogNodeValue(value, host), options);
            }

            return value?.Trim();
        }
        #endregion

        #region nodeValue - JToken
        public static object nodeValue(JToken node, SingleNodeSettings nd, string host)
        {
            if (node == null || nd == null)
                return null;

            var current = node is JProperty property ? property.Value : node;

            JToken valueToken = null;

            if (!string.IsNullOrEmpty(nd.node))
            {
                current = current.SelectToken(nd.node);
                if (current == null)
                    return null;
            }

            if (nd.attributes != null)
            {
                foreach (var attr in nd.attributes)
                {
                    valueToken = current[attr];
                    if (valueToken != null)
                        break;
                }
            }

            if (valueToken == null && !string.IsNullOrEmpty(nd.attribute))
                valueToken = current[nd.attribute];

            if (valueToken == null)
                return null;

            string value = valueToken switch
            {
                JValue jValue => jValue.Value?.ToString(),
                JProperty jProp => jProp.Value?.ToString(),
                _ => valueToken.ToString(Formatting.None)
            };

            if (string.IsNullOrEmpty(value))
                return null;

            if (nd.format != null)
            {
                var options = ScriptOptions.Default
                    .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                    .AddImports("Shared")
                    .AddImports("Shared.Engine")
                    .AddImports("Shared.Models")
                    .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll"))
                    .AddImports("Newtonsoft.Json")
                    .AddImports("Newtonsoft.Json.Linq");

                return CSharpEval.Execute<object>(nd.format, new CatalogNodeValue(value, host), options);
            }

            if (valueToken is JValue)
                return value?.Trim();

            return valueToken;
        }
        #endregion


        #region setArgsValue
        public static void setArgsValue(SingleNodeSettings arg, object val, JObject jo)
        {
            if (val != null)
            {
                if (arg.name_arg is "kp_rating" or "imdb_rating")
                {
                    string rating = val?.ToString()?.Trim();
                    if (!string.IsNullOrEmpty(rating) && rating != "0" && rating != "0.0" && double.TryParse(rating.Replace(".", ","), out _))
                    {
                        rating = rating.Length > 3 ? rating.Substring(0, 3) : rating;
                        if (rating.Length == 1)
                            rating = $"{rating}.0";

                        jo[arg.name_arg] = JToken.FromObject(rating.Replace(",", "."));
                    }
                }
                else if (arg.name_arg is "vote_average")
                {
                    string value = val?.ToString()?.Trim()?.Replace(".", ",");
                    if (!string.IsNullOrEmpty(value) && double.TryParse(value, out double _v) && _v > 0)
                        jo[arg.name_arg] = JToken.FromObject(_v);
                }
                else if (arg.name_arg is "runtime" or "PG")
                {
                    string value = val?.ToString()?.Trim();
                    if (!string.IsNullOrEmpty(value) && long.TryParse(value, out long _v) && _v > 0)
                        jo[arg.name_arg] = JToken.FromObject(_v);
                }
                else if (arg.name_arg is "genres" or "created_by" or "production_countries" or "production_companies" or "networks" or "spoken_languages")
                {
                    if (val is string)
                    {
                        string arrayStr = val?.ToString();
                        var array = new JArray();

                        if (!string.IsNullOrEmpty(arrayStr))
                        {
                            foreach (string str in arrayStr.Split(","))
                            {
                                if (string.IsNullOrWhiteSpace(str))
                                    continue;

                                array.Add(new JObject() { ["name"] = clearText(str) });
                            }

                            jo[arg.name_arg] = array;
                        }
                    }
                    else if (IsStringList(val as JToken))
                    {
                        var array = new JArray();
                        foreach (var item in (JArray)val)
                            array.Add(new JObject() { ["name"] = clearText(item.ToString()) });

                        jo[arg.name_arg] = array;
                    }
                }
                else if (val is string && (arg.name_arg is "origin_country" or "languages"))
                {
                    string arrayStr = val?.ToString();
                    var array = new JArray();

                    if (!string.IsNullOrEmpty(arrayStr))
                    {
                        foreach (string str in arrayStr.Split(","))
                        {
                            if (!string.IsNullOrWhiteSpace(str))
                                array.Add(str.Trim());
                        }

                        if (array.Count > 0)
                            jo[arg.name_arg] = array;
                    }
                }
                else
                {
                    jo[arg.name_arg] = JToken.FromObject(val);
                }
            }
        }
        #endregion

        #region IsStringList
        static bool IsStringList(JToken token)
        {
            if (token?.Type != JTokenType.Array)
                return false;

            var array = token as JArray;
            return array?.All(item => item.Type == JTokenType.String) == true;
        }
        #endregion

        #region clearText
        public static string clearText(string text)
        {
            if (string.IsNullOrEmpty(text))
                return text;

            text = text.Replace("&nbsp;", "");
            text = Regex.Replace(text, "<[^>]+>", "");
            text = HttpUtility.HtmlDecode(text);
            return text.Trim();
        }
        #endregion
    }
}

```

## File: Catalog/CardController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.PlaywrightCore;
using System.Net.Http;

namespace Catalog.Controllers
{
    public class CardController : BaseController
    {
        [HttpGet]
        [Route("catalog/card")]
        public async Task<ActionResult> Index(string plugin, string uri, string type)
        {
            var init = ModInit.goInit(plugin)?.Clone();
            if (init == null || !init.enable)
                return BadRequest("init not found");

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected())
                rch.Disabled();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string memKey = $"catalog:card:{plugin}:{uri}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out JObject jo, inmemory: false))
                {
                    string url = $"{init.host}/{uri}";
                    var headers = httpHeaders(init);

                    if (init.args != null)
                        url = url.Contains("?") ? $"{url}&{init.args}" : $"{url}?{init.args}";

                    if (init.card_parse.initUrl != null)
                        url = CSharpEval.Execute<string>(init.card_parse.initUrl, new CatalogInitUrlCard(init.host, init.args, uri, HttpContext.Request.Query, type));

                    if (init.card_parse.initHeader != null)
                        headers = CSharpEval.Execute<List<HeadersModel>>(init.card_parse.initHeader, new CatalogInitHeader(url, headers));

                    reset:

                    string html = null;

                    if (!string.IsNullOrEmpty(init.card_parse.postData))
                    {
                        string mediaType = init.card_parse.postData.StartsWith("{") || init.card_parse.postData.StartsWith("[") ? "application/json" : "application/x-www-form-urlencoded";
                        var httpdata = new StringContent(init.card_parse.postData, Encoding.UTF8, mediaType);

                        html = rch.enable
                            ? await rch.Post(url, init.card_parse.postData, headers, useDefaultHeaders: init.useDefaultHeaders)
                            : await Http.Post(url, httpdata, headers: headers, proxy: proxy.proxy, timeoutSeconds: init.timeout, useDefaultHeaders: init.useDefaultHeaders);
                    }
                    else
                    {
                        html = rch.enable
                            ? await rch.Get(url, headers, useDefaultHeaders: init.useDefaultHeaders)
                            : init.priorityBrowser == "playwright" ? await PlaywrightBrowser.Get(init, url, headers, proxy.data, cookies: init.cookies)
                            : await Http.Get(url, headers: headers, proxy: proxy.proxy, timeoutSeconds: init.timeout, useDefaultHeaders: init.useDefaultHeaders);
                    }

                    if (html == null)
                    {
                        if (ModInit.IsRhubFallback(init))
                            goto reset;

                        if (!rch.enable)
                            proxyManager.Refresh();

                        return BadRequest("html");
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    var parse = init.card_parse;
                    bool? jsonPath = parse.jsonPath;
                    if (jsonPath == null)
                        jsonPath = init.jsonPath;

                    #region parse doc/json
                    HtmlNode node = null;
                    JToken json = null;

                    if (jsonPath == true)
                    {
                        try
                        {
                            json = JToken.Parse(html);

                            if (!string.IsNullOrEmpty(parse.node))
                            {
                                json = json.SelectToken(parse.node);
                                if (json == null)
                                    return BadRequest("parse.node");
                            }
                        }
                        catch
                        {
                            json = null;
                            return BadRequest("json");
                        }
                    }
                    else
                    {
                        var doc = new HtmlDocument();
                        doc.LoadHtml(html);

                        node = doc.DocumentNode;
                    }
                    #endregion

                    #region name / original_name / year
                    string name;
                    string original_name;
                    string year;

                    if (jsonPath == true)
                    {
                        name = ModInit.nodeValue(json, parse.name, host)?.ToString();
                        original_name = ModInit.nodeValue(json, parse.original_name, host)?.ToString();
                        year = ModInit.nodeValue(json, parse.year, host)?.ToString();
                    }
                    else
                    {
                        name = ModInit.nodeValue(node, parse.name, host)?.ToString();
                        original_name = ModInit.nodeValue(node, parse.original_name, host)?.ToString();
                        year = ModInit.nodeValue(node, parse.year, host)?.ToString();
                    }
                    #endregion

                    #region img
                    string img = jsonPath == true
                        ? ModInit.nodeValue(json, parse.image, host)?.ToString()
                        : ModInit.nodeValue(node, parse.image, host)?.ToString();

                    if (img != null)
                    {
                        img = img.Replace("&amp;", "&").Replace("\\", "");

                        if (img.StartsWith("../"))
                            img = $"{init.host}/{img.Replace("../", "")}";
                        else if (img.StartsWith("//"))
                            img = $"https:{img}";
                        else if (img.StartsWith("/"))
                            img = init.host + img;
                        else if (!img.StartsWith("http"))
                            img = $"{init.host}/{img}";
                    }
                    #endregion

                    jo = new JObject()
                    {
                        ["id"] = uri.Trim(),
                        ["img"] = PosterApi.Size(host, img),

                        ["vote_average"] = 0,
                        ["genres"] = new JArray(),
                        ["production_countries"] = new JArray(),
                        ["production_companies"] = new JArray()
                    };

                    string overview = jsonPath == true
                        ? ModInit.nodeValue(json, parse.description, host)?.ToString()
                        : ModInit.nodeValue(node, parse.description, host)?.ToString();

                    if (!string.IsNullOrEmpty(overview))
                        jo["overview"] = overview;

                    if (type == "tv")
                    {
                        jo["first_air_date"] = year;
                        jo["name"] = name;

                        if (!string.IsNullOrEmpty(original_name))
                            jo["original_name"] = original_name;
                    }
                    else
                    {
                        jo["release_date"] = year;
                        jo["title"] = name;

                        if (!string.IsNullOrEmpty(original_name))
                            jo["original_title"] = original_name;
                    }

                    #region card_args
                    if (init.card_args != null)
                    {
                        foreach (var arg in init.card_args)
                        {
                            object val = jsonPath == true
                                ? ModInit.nodeValue(json, arg, host)
                                : ModInit.nodeValue(node, arg, host);

                            ModInit.setArgsValue(arg, val, jo);
                        }
                    }
                    #endregion

                    if (init.tmdb_injects != null && init.tmdb_injects.Length > 0)
                        await Injects(year, jo, init.tmdb_injects);

                    if (!jo.ContainsKey("tagline") && !string.IsNullOrEmpty(original_name))
                        jo["tagline"] = original_name;

                    hybridCache.Set(memKey, jo, cacheTime(init.cache_time, init: init), inmemory: false);
                }

                return ContentTo(JsonConvert.SerializeObject(jo));
            });
        }


        #region TMDB Injects
        static readonly string[] defaultInjectskeys =
        [
            "imdb_id",
            "external_ids",
            "backdrop_path",
            "created_by",
            "genres",
            "production_companies",
            "production_countries",
            "content_ratings",
            "episode_run_time",
            "languages",
            "number_of_episodes",
            "number_of_seasons",
            "last_episode_to_air",
            "origin_country",
            "original_language",
            "status",
            "networks",
            "seasons",
            "type",
            "budget",
            "spoken_languages",
            "alternative_titles",
            "keywords",

            // &append_to_response=
            "videos",
            "credits",
            "recommendations",
            "similar",
        ];

        static readonly string[] addEmptykeys =
        [
            "tagline",
            "overview",
            "first_air_date",
            "last_air_date",
            "release_date",
            "runtime"
        ];

        async Task Injects(string year, JObject jo, string[] keys)
        {
            if (!jo.ContainsKey("imdb_id") && !jo.ContainsKey("original_title") && !jo.ContainsKey("original_name"))
                return;

            if (keys.Length == 1 && keys[0] == "default")
                keys = defaultInjectskeys;

            #region –ü–æ–∏—Å–∫ –∫–∞—Ä—Ç–æ—á–∫–∏ –≤ TMDB
            string imdbId = null;
            if (jo.ContainsKey("imdb_id"))
                imdbId = jo["imdb_id"]?.ToString();

            var header = HeadersModel.Init(("localrequest", AppInit.rootPasswd));

            long id = 0;
            string cat = string.Empty;

            if (!string.IsNullOrWhiteSpace(imdbId) && imdbId.StartsWith("tt"))
            {
                var find = await Http.Get<JObject>($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/3/find/{imdbId}?external_source=imdb_id&api_key={AppInit.conf.tmdb.api_key}", timeoutSeconds: 5, headers: header);
                if (find != null)
                {
                    foreach (string key in new string[] { "movie_results", "tv_results" })
                    {
                        if (find.ContainsKey(key))
                        {
                            var movies = find[key] as JArray;
                            if (movies != null && movies.Count > 0)
                            {
                                id = movies[0].Value<long>("id");
                                cat = key == "movie_results" ? "movie" : "tv";
                                break;
                            }
                        }
                    }
                }
            }
            else if (jo.ContainsKey("original_title") || jo.ContainsKey("original_name"))
            {
                string type = jo.ContainsKey("original_title") ? "movie" : "tv";
                string originalTitle = jo.Value<string>(type == "movie" ? "original_title" : "original_name");

                if (!string.IsNullOrEmpty(originalTitle) && int.TryParse(year.Split("-")[0], out int _year) && _year > 0)
                {
                    var searchMovie = await Http.Get<JObject>($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/3/search/{type}?query={HttpUtility.UrlEncode(originalTitle)}&api_key={AppInit.conf.tmdb.api_key}", timeoutSeconds: 5, headers: header);
                    if (searchMovie != null && searchMovie.ContainsKey("results"))
                    {
                        var results = searchMovie["results"] as JArray;
                        if (results != null && results.Count > 0)
                        {
                            long foundId = 0;
                            for (int i = 0; i < results.Count; i++)
                            {
                                var item = results[i] as JObject;
                                if (item == null)
                                    continue;

                                string date = item.Value<string>("release_date") ?? item.Value<string>("first_air_date");
                                if (string.IsNullOrEmpty(date))
                                    continue;

                                // date is usually in format YYYY-MM-DD, take first 4 chars
                                string yearStr = date.Length >= 4 ? date.Substring(0, 4) : date;
                                if (int.TryParse(yearStr, out int itemYear) && itemYear == _year)
                                {
                                    string _s1 = StringConvert.SearchName(originalTitle);
                                    string _s2 = StringConvert.SearchName(item.Value<string>(type == "movie" ? "original_title" : "original_name"));

                                    if (!string.IsNullOrEmpty(_s1) && !string.IsNullOrEmpty(_s2) && _s1 == _s2)
                                    {
                                        foundId = item.Value<long>("id");
                                        break;
                                    }
                                }
                            }

                            if (foundId != 0)
                            {
                                id = foundId;
                                cat = type;
                            }
                        }
                    }
                }
            }
            #endregion

            if (id == 0)
                return;

            string append = "content_ratings,release_dates,external_ids,keywords,alternative_titles,videos,credits,recommendations,similar";
            var result = await Http.Get<JObject>($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/3/{cat}/{id}?api_key={AppInit.conf.tmdb.api_key}&append_to_response={append}&language=ru", timeoutSeconds: 5, headers: header);
            if (result == null)
                return;

            foreach (string key in keys)
            {
                if (key is "videos" or "recommendations" or "similar")
                {
                    if (result.ContainsKey(key) && result[key] is JObject _jo && _jo.ContainsKey("results"))
                        jo[key] = _jo["results"];
                }
                else if (result.ContainsKey(key))
                {
                    jo[key] = result[key];
                }
            }

            if (result.ContainsKey("id"))
                jo["tmdb_id"] = result["id"];

            if (!jo.ContainsKey("imdb_id") && result.ContainsKey("external_ids") && result["external_ids"] is JObject extIds && extIds.ContainsKey("imdb_id"))
                jo["imdb_id"] = extIds["imdb_id"];

            foreach (string key in addEmptykeys)
            {
                if (!jo.ContainsKey(key) && result.ContainsKey(key))
                {
                    var tok = result[key];
                    if (tok == null)
                        continue;

                    if (tok.Type == JTokenType.String)
                    {
                        var str = tok.Value<string>();
                        if (!string.IsNullOrWhiteSpace(str))
                            jo[key] = str;
                    }
                    else
                    {
                        jo[key] = tok;
                    }
                }
            }
        }
        #endregion
    }
}

```

## File: Catalog/GlobalUsings.cs
```
Ôªøglobal using System;
global using System.Threading.Tasks;
global using System.Collections.Generic;
global using System.Text.RegularExpressions;
global using System.IO;
global using System.Linq;
global using Shared;
global using Shared.Models;
global using Shared.Engine;
global using Shared.Models.Base;
global using Shared.Models.Catalog;
global using Shared.Models.CSharpGlobals;
global using HtmlAgilityPack;
global using Newtonsoft.Json;
global using Newtonsoft.Json.Linq;
global using Microsoft.CodeAnalysis.Scripting;
global using System.Text;
global using System.Web;
```

## File: DLNA/ApiController.cs
```
Ôªøusing DLNA.Models;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using MongoDB.Driver;
using MonoTorrent;
using MonoTorrent.Client;
using NetVips;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Engine.JacRed;
using Shared.Models;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
using IO = System.IO;

namespace DLNA.Controllers
{
    public class DLNAController : BaseController
    {
        #region DLNAController
        static string dlna_path => AppInit.conf.dlna.path;

        static string defTrackers = "tr=http://retracker.local/announce&tr=http%3A%2F%2Fbt4.t-ru.org%2Fann%3Fmagnet&tr=http://retracker.mgts.by:80/announce&tr=http://tracker.city9x.com:2710/announce&tr=http://tracker.electro-torrent.pl:80/announce&tr=http://tracker.internetwarriors.net:1337/announce&tr=http://tracker2.itzmx.com:6961/announce&tr=udp://opentor.org:2710&tr=udp://public.popcorn-tracker.org:6969/announce&tr=udp://tracker.opentrackr.org:1337/announce&tr=http://bt.svao-ix.ru/announce&tr=udp://explodie.org:6969/announce&tr=wss://tracker.btorrent.xyz&tr=wss://tracker.openwebtorrent.com";

        static ClientEngine torrentEngine;
        static DateTime lastBullderClientEngineCall = DateTime.MinValue;

        public static void Initialization()
        {
            Directory.CreateDirectory("cache/torrent");
            Directory.CreateDirectory($"{dlna_path}/");
            Directory.CreateDirectory($"{dlna_path}/thumbs/");
            Directory.CreateDirectory($"{dlna_path}/tmdb/");

            ThreadPool.QueueUserWorkItem(async _ =>
            {
                string trackers_best_ip = await Http.Get("https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_best_ip.txt", timeoutSeconds: 20);
                if (trackers_best_ip != null)
                {
                    foreach (string line in trackers_best_ip.Split("\n"))
                    {
                        string tr = line.Replace("\n", "").Replace("\r", "").Trim();
                        if (!string.IsNullOrWhiteSpace(tr))
                            defTrackers += $"&tr={tr}";
                    }
                }
            });

            ThreadPool.QueueUserWorkItem(async _ =>
            {
                while (true)
                {
                    try
                    {
                        await Task.Delay(TimeSpan.FromMinutes(5));
                        await removeClientEngine();
                    }
                    catch { }
                }
            });

            ThreadPool.QueueUserWorkItem(async _ =>
            {
                while (true)
                {
                    try
                    {
                        await Task.Delay(TimeSpan.FromMinutes(1));

                        if (torrentEngine == null)
                            continue;

                        if (lastBullderClientEngineCall == DateTime.MinValue || DateTime.UtcNow - lastBullderClientEngineCall < TimeSpan.FromMinutes(10))
                            continue;

                        if (!HasActiveTorrentTasks())
                            await removeClientEngine();
                    }
                    catch { }
                }
            });

            if (!Directory.Exists("cache/metadata"))
                return;

            #region Resume download
            var _files = Directory.GetFiles("cache/metadata", "*.torrent");
            if (_files.Length == 0)
                return;

            bullderClientEngine();

            foreach (string path in _files)
            {
                var t = Torrent.Load(path);
                var manager = AppInit.conf.dlna.mode == "stream" ? torrentEngine.AddStreamingAsync(t, $"{dlna_path}/").Result : torrentEngine.AddAsync(t, $"{dlna_path}/").Result;

                //if (FastResume.TryLoad($"cache/fastresume/{t.InfoHash.ToHex()}.fresume", out FastResume resume))
                //    manager.LoadFastResume(resume);

                int[] indexs = null;

                try
                {
                    if (IO.File.Exists($"cache/metadata/{t.InfoHashes.V1.ToHex()}.json"))
                        indexs = JsonConvert.DeserializeObject<int[]>(IO.File.ReadAllText($"cache/metadata/{t.InfoHashes.V1.ToHex()}.json"));
                }
                catch { }

                bool setPriority = false;

                manager.TorrentStateChanged += async (s, e) =>
                {
                    try
                    {
                        if (e != null && e.NewState == TorrentState.Seeding)
                            await e.TorrentManager.StopAsync();

                        if (e != null && (e.NewState == TorrentState.Metadata || e.NewState == TorrentState.Hashing || e.NewState == TorrentState.Downloading))
                        {
                            if (!setPriority)
                            {
                                setPriority = true;

                                if (indexs == null || indexs.Length == 0)
                                {
                                    await manager.SetFilePriorityAsync(manager.Files[0], Priority.High);
                                }
                                else
                                {
                                    for (int i = 0; i < manager.Files.Count; i++)
                                    {
                                        if (indexs.Contains(i))
                                        {
                                            await manager.SetFilePriorityAsync(manager.Files[i], i == indexs[0] ? Priority.High : Priority.Normal);
                                        }
                                        else
                                        {
                                            await manager.SetFilePriorityAsync(manager.Files[i], Priority.DoNotDownload);
                                        }
                                    }
                                }
                            }
                        }

                        if (e != null && (e.NewState == TorrentState.Stopped || e.NewState == TorrentState.Stopping))
                        {
                            try
                            {
                                IO.File.Delete(path);
                                IO.File.Delete(path.Replace(".torrent", ".json"));
                            }
                            catch { }

                            foreach (var f in e.TorrentManager.Files)
                            {
                                try
                                {
                                    if (f.Priority == Priority.DoNotDownload && IO.File.Exists(f.FullPath))
                                        IO.File.Delete(f.FullPath);
                                }
                                catch { }
                            }

                            await removeClientEngine(e.TorrentManager.InfoHashes.V1.ToHex().ToLower());
                        }
                    }
                    catch { }
                };
            }
            #endregion
        }
        #endregion

        #region dlna.js
        [HttpGet]
        [AllowAnonymous]
        [Route("dlna.js")]
        [Route("dlna/js/{token}")]
        public ActionResult Plugin(string token)
        {
            if (!AppInit.conf.dlna.enable)
                return Content(string.Empty);

            var sb = new StringBuilder(FileCache.ReadAllText("plugins/dlna.js"));

            sb.Replace("{localhost}", host)
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        #region bullderClientEngine
        static Task bullderClientEngine(int connectionTimeout = 10)
        {
            lastBullderClientEngineCall = DateTime.UtcNow;

            if (torrentEngine != null)
                return Task.CompletedTask;

            EngineSettingsBuilder engineSettingsBuilder = new EngineSettingsBuilder()
            {
                MaximumHalfOpenConnections = 20,
                ConnectionTimeout = TimeSpan.FromSeconds(connectionTimeout),
                MaximumDownloadRate = AppInit.conf.dlna.downloadSpeed,
                MaximumUploadRate = AppInit.conf.dlna.uploadSpeed,
                MaximumDiskReadRate = AppInit.conf.dlna.maximumDiskReadRate,
                MaximumDiskWriteRate = AppInit.conf.dlna.maximumDiskWriteRate
            };

            torrentEngine = new ClientEngine(engineSettingsBuilder.ToSettings());
            return torrentEngine.StartAllAsync();
        }
        #endregion

        #region HasActiveTorrentTasks
        static bool HasActiveTorrentTasks()
        {
            try
            {
                if (torrentEngine?.Torrents == null)
                    return false;

                foreach (var torrent in torrentEngine.Torrents)
                {
                    if (torrent.State == TorrentState.Metadata || torrent.State == TorrentState.Downloading || torrent.State == TorrentState.Starting || torrent.State == TorrentState.Hashing)
                        return true;
                }
            }
            catch { }

            return false;
        }
        #endregion

        #region removeClientEngine
        async static Task removeClientEngine(string hash = null)
        {
            try
            {
                if (torrentEngine?.Torrents != null)
                {
                    var tdl = new List<TorrentManager>();

                    foreach (var i in torrentEngine.Torrents)
                    {
                        if (hash != null)
                        {
                            if (i.InfoHashes.V1.ToHex().ToLower() == hash)
                            {
                                try
                                {
                                    await i.StopAsync(TimeSpan.FromSeconds(20));
                                }
                                catch { }

                                tdl.Add(i);
                            }
                        }
                        else
                        {
                            if (i.State == TorrentState.Seeding || i.State == TorrentState.Stopped || i.State == TorrentState.Stopping)
                            {
                                try
                                {
                                    await i.StopAsync(TimeSpan.FromSeconds(120));
                                }
                                catch { }

                                tdl.Add(i);
                            }
                        }
                    }

                    if (tdl.Count > 0)
                    {
                        foreach (var item in tdl)
                        {
                            try
                            {
                                torrentEngine.Torrents.Remove(item);
                            }
                            catch { }

                            try
                            {
                                await torrentEngine.RemoveAsync(item);
                            }
                            catch { }
                        }

                    }

                    if (torrentEngine.Torrents.Count == 0)
                    {
                        try
                        {
                            await torrentEngine.StopAllAsync();
                        }
                        catch { }

                        torrentEngine.Dispose();
                        torrentEngine = null;
                    }
                }
            }
            catch { }
        }
        #endregion

        #region getTorrent
        async ValueTask<(string magnet, byte[] torrent)> getTorrent(string path)
        {
            if (!path.StartsWith("http"))
                return (path, null);

            string memkey = $"DLNAController:getTorrent:{path}";
            if (!memoryCache.TryGetValue(memkey, out (string magnet, byte[] torrent) cache))
            {
                var handler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                };

                handler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;

                using (var client = new System.Net.Http.HttpClient(handler))
                {
                    client.Timeout = TimeSpan.FromSeconds(10);

                    using (var response = await client.GetAsync(path))
                    {
                        if (response.StatusCode == System.Net.HttpStatusCode.OK)
                        {
                            using (var content = response.Content)
                            {
                                var t = await content.ReadAsByteArrayAsync();
                                cache.magnet = BencodeTo.Magnet(t);
                                if (cache.magnet != null)
                                    cache.torrent = t;
                            }
                        }
                        else if ((int)response.StatusCode is 301 or 302 or 307)
                        {
                            string location = response.Headers.Location?.ToString() ?? response.RequestMessage.RequestUri?.ToString();
                            if (location != null && location.StartsWith("magnet:"))
                                cache.magnet = location;
                        }
                    }
                }

                if (cache.magnet == null && cache.torrent == null)
                    return (null, null);

                memoryCache.Set(memkey, cache, DateTime.Now.AddMinutes(10));
            }

            return (cache.magnet, cache.torrent);
        }
        #endregion

        #region getTmdb
        JObject getTmdb(string name)
        {
            try
            {
                string file = $"{dlna_path}/tmdb/{CrypTo.md5(name)}.json";
                if (IO.File.Exists(file))
                {
                    var tmdb = JsonConvert.DeserializeObject<JObject>(IO.File.ReadAllText(file));
                    tmdb.Remove("created_by");
                    tmdb.Remove("networks");
                    tmdb.Remove("production_companies");

                    return tmdb;
                }
            }
            catch { }

            return null;
        }
        #endregion

        #region getEpisodes
        JArray getEpisodes(JObject tmdb, string fileName)
        {
            try
            {
                if (tmdb == null || !tmdb.ContainsKey("number_of_seasons"))
                    return null;

                int season = getSeason(fileName);

                string file = $"{dlna_path}/tmdb/{tmdb.Value<long>("id")}_season-{season}.json";
                if (IO.File.Exists(file))
                {
                    if (memoryCache.TryGetValue(file, out JArray episodes))
                        return episodes;

                    episodes = JsonConvert.DeserializeObject<JObject>(IO.File.ReadAllText(file)).Value<JArray>("episodes");
                    
                    memoryCache.Set(file, episodes, DateTime.Now.AddSeconds(10));
                    return episodes;
                }
            }
            catch { }

            return null;
        }
        #endregion

        #region getEpisode
        int getEpisode(string fileName)
        {
            if (int.TryParse(Regex.Match(fileName, "EP?([0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value, out int _e) && _e > 0)
                return _e;

            return 0;
        }
        #endregion

        #region getSeason
        int getSeason(string fileName)
        {
            if (int.TryParse(Regex.Match(fileName, "S([0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value, out int _s) && _s > 0)
                return _s;

            return 0;
        }
        #endregion


        #region Navigation
        [HttpGet]
        [Route("dlna")]
        public ActionResult Index(string path)
        {
            if (!AppInit.conf.dlna.enable)
                return Json(new { });

            #region getImage
            string getImage(string name)
            {
                string pathimage = $"thumbs/{name}.jpg";
                if (IO.File.Exists($"{dlna_path}/" + pathimage))
                    return $"{host}/dlna/stream?path={HttpUtility.UrlEncode(pathimage)}";

                return null;
            }
            #endregion

            #region getPreview
            string getPreview(string name)
            {
                string pathimage = $"temp/{name}.mp4";
                if (IO.File.Exists($"{dlna_path}/" + pathimage))
                    return $"{host}/dlna/stream?path={HttpUtility.UrlEncode(pathimage)}";

                pathimage = $"temp/{name}.webm";
                if (IO.File.Exists($"{dlna_path}/" + pathimage))
                    return $"{host}/dlna/stream?path={HttpUtility.UrlEncode(pathimage)}";

                return null;
            }
            #endregion

            #region countFiles
            int countFiles(string _path)
            {
                int count = 0;

                foreach (string file in Directory.GetFiles(_path))
                {
                    if (!Regex.IsMatch(Path.GetExtension(file), AppInit.conf.dlna.mediaPattern))
                        continue;

                    if (new FileInfo(file).Length > 0)
                        count++;
                }

                return count;
            }
            #endregion

            var playlist = new List<DlnaModel>();

            #region folders
            foreach (string folder in Directory.GetDirectories($"{dlna_path}/" + path))
            {
                if (folder.Contains("thumbs") || folder.Contains("tmdb") || folder.Contains("temp"))
                    continue;

                int length = countFiles(folder);
                if (length > 0 || Directory.GetDirectories(folder).Length > 0)
                {
                    playlist.Add(new DlnaModel()
                    {
                        type = "folder",
                        name = Path.GetFileName(folder),
                        uri = $"{host}/dlna?path={HttpUtility.UrlEncode(folder.Replace($"{dlna_path}/", ""))}",
                        img = getImage(CrypTo.md5(Path.GetFileName(folder))),
                        preview = getPreview(CrypTo.md5(Path.GetFileName(folder))),
                        path = folder.Replace($"{dlna_path}/", ""),
                        length = countFiles(folder),
                        creationTime = Directory.GetCreationTime(folder),
                        tmdb = getTmdb(Path.GetFileName(folder))
                    });
                }
            }
            #endregion

            #region files
            var filesTmdb = getTmdb(path);
            var subtitles = Directory.GetFiles($"{dlna_path}/" + path, "*.srt");

            foreach (string file in Directory.GetFiles($"{dlna_path}/" + path))
            {
                if (!Regex.IsMatch(Path.GetExtension(file), AppInit.conf.dlna.mediaPattern))
                    continue;

                string name = Path.GetFileName(file);
                var fileinfo = new FileInfo(file);
                if (fileinfo.Length == 0)
                    continue;

                JObject episodeTmdb = null;

                string img = getImage(CrypTo.md5(name));
                var episodes = getEpisodes(filesTmdb, name);
                if (episodes != null)
                {
                    int episode = getEpisode(name);
                    if (episode > 0)
                    {
                        episodeTmdb = episodes.FirstOrDefault(i => i.Value<int>("episode_number") == episode)?.ToObject<JObject>();
                        episodeTmdb.Remove("crew");
                        episodeTmdb.Remove("guest_stars");

                        if (episodeTmdb != null && episodeTmdb.ContainsKey("still_path"))
                            img = $"tmdb:/t/p/w400" + episodeTmdb.Value<string>("still_path");
                    }
                }

                if (img == null)
                    img = getImage(CrypTo.md5($"{path}/{name}"));

                var dlnaModel = new DlnaModel()
                {
                    type = "file",
                    name = name,
                    uri = $"{host}/dlna/stream?path={HttpUtility.UrlEncode(file.Replace($"{dlna_path}/", ""))}",
                    img = img,
                    preview = getPreview(CrypTo.md5(name)),
                    subtitles = new List<Subtitle>(),
                    path = file.Replace($"{dlna_path}/", ""),
                    length = fileinfo.Length,
                    creationTime = fileinfo.CreationTime,
                    s = getSeason(name),
                    e = getEpisode(name),
                    tmdb = string.IsNullOrEmpty(path) ? getTmdb(name) : filesTmdb,
                    episode = episodeTmdb
                };

                #region subtitles
                foreach (string subfile in subtitles)
                {
                    if (subfile.Contains(Path.GetFileNameWithoutExtension(file)))
                    {
                        dlnaModel.subtitles.Add(new Subtitle()
                        {
                            label = "Sub #1",
                            url = $"{host}/dlna/stream?path={HttpUtility.UrlEncode($"{path}/{Path.GetFileName(subfile)}")}"
                        });
                    }
                }
                #endregion

                playlist.Add(dlnaModel);
            }
            #endregion

            var jSettings = new JsonSerializerSettings()
            {
                DefaultValueHandling = DefaultValueHandling.Ignore,
                NullValueHandling = NullValueHandling.Ignore
            };

            if (string.IsNullOrWhiteSpace(path))
            {
                #region torrentEngine
                if (torrentEngine?.Torrents != null)
                {
                    foreach (var t in torrentEngine.Torrents)
                    {
                        if (t.State == TorrentState.Metadata || t.State == TorrentState.Downloading || t.State == TorrentState.Starting)
                        {
                            if (t.Torrent?.Name == null || (!IO.File.Exists($"{dlna_path}/{t.Torrent.Name}") && !Directory.Exists($"{dlna_path}/{t.Torrent.Name}")))
                            {
                                playlist.Add(new DlnaModel()
                                {
                                    type = "file",
                                    name = t.Torrent?.Name ?? t.InfoHashes.V1.ToHex(),
                                    img = getImage(t.InfoHashes.V1.ToHex())
                                });
                            }
                        }
                    }
                }
                #endregion

                return ContentTo(JsonConvert.SerializeObject(playlist.OrderByDescending(i => i.creationTime), jSettings));
            }

            return ContentTo(JsonConvert.SerializeObject(playlist.OrderBy(i =>
            {
                ulong.TryParse(Regex.Replace(i.name, "[^0-9]+", ""), out ulong ident);
                return ident;

            }), jSettings));
        }
        #endregion

        #region Stream
        [Route("dlna/stream")]
        public ActionResult Stream(string path)
        {
            if (!AppInit.conf.dlna.enable)
                return Json(new { });

            string contentType = "application/octet-stream";

            if (path.EndsWith(".jpg"))
                contentType = "image/jpeg";

            return File(IO.File.OpenRead($"{dlna_path}/" + path), contentType, true);
        }
        #endregion

        #region Delete
        [HttpGet]
        [Route("dlna/delete")]
        public ActionResult Delete(string path)
        {
            if (!AppInit.conf.dlna.enable)
                return Content(string.Empty);

            try
            {
                IO.File.Delete($"{dlna_path}/" + path);
            }
            catch { }

            try
            {
                Directory.Delete($"{dlna_path}/" + path, true);
            }
            catch { }

            return Content(string.Empty);
        }
        #endregion


        #region Managers
        [HttpGet]
        [Route("dlna/tracker/managers")]
        public ActionResult Managers()
        {
            if (!AppInit.conf.dlna.enable || torrentEngine?.Torrents == null)
                return Content("[]");

            return Json(torrentEngine.Torrents.Select(i => new
            {
                InfoHash = i.InfoHashes.V1.ToHex(),
                Name = i.Torrent?.Name ?? i.InfoHashes.V1.ToHex(),
                //Engine = new 
                //{
                //    i.Engine.ConnectionManager.HalfOpenConnections,
                //    i.Engine.ConnectionManager.OpenConnections,
                //    i.Engine.TotalDownloadSpeed,
                //    i.Engine.TotalUploadSpeed,
                //},
                Files = i.Files?.Select(f => new
                {
                    f.Path,
                    Priority = f.Priority.ToString(),
                    f.Length,
                    BytesDownloaded = f.BytesDownloaded()
                }),
                i.Monitor,
                i.OpenConnections,
                i.PartialProgress,
                i.Progress,
                i.Peers,
                State = i.State.ToString(),
                i.UploadingTo
            }));
        }
        #endregion

        #region Show
        [HttpGet]
        [Route("dlna/tracker/show")]
        async public Task<JsonResult> Show(string path)
        {
            if (!AppInit.conf.dlna.enable)
                return Json(new { error = "enable" });

            try
            {
                var tparse = await getTorrent(path);
                if (tparse.torrent != null)
                    return Json(Torrent.Load(tparse.torrent).Files.Select(i => new { i.Path }));

                if (tparse.magnet == null)
                    return Json(new { error = "magnet" });

                string hash = Regex.Match(tparse.magnet, "btih:([a-z0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value.ToLower();
                if (IO.File.Exists($"cache/torrent/{hash}"))
                    return Json(Torrent.Load(IO.File.ReadAllBytes($"cache/torrent/{hash}")).Files.Select(i => new { i.Path }));

                var s_cts = new CancellationTokenSource();
                s_cts.CancelAfter(1000 * 60 * 3);

                string magnet = tparse.magnet;
                magnet += (magnet.Contains("?") ? "&" : "?") + defTrackers;

                #region trackers
                //if (IO.File.Exists("cache/trackers.txt") && AppInit.conf.dlna.addTrackersToMagnet)
                //{
                //    foreach (string line in IO.File.ReadLines("cache/trackers.txt"))
                //    {
                //        if (string.IsNullOrWhiteSpace(line))
                //            continue;

                //        if (line.StartsWith("http") || line.StartsWith("udp:"))
                //        {
                //            string host = line.Replace("\r", "").Replace("\n", "").Replace("\t", "").Trim();
                //            string tr = HttpUtility.UrlEncode(host);

                //            if (!magnet.Contains(tr))
                //                magnet += $"&tr={tr}";
                //        }
                //    }
                //}
                #endregion

                await bullderClientEngine();

                if (torrentEngine.Torrents.FirstOrDefault(i => i.InfoHashes.V1.ToHex().ToLower() == hash) is TorrentManager manager)
                {
                    if (manager.Files != null)
                        return Json(manager.Files.Select(i => (ITorrentFile)i).Select(i => new { i.Path }));

                    await manager.WaitForMetadataAsync(s_cts.Token);
                    var files = manager.Files.Select(i => (ITorrentFile)i);
                    return Json(files.Select(i => new { i.Path }));
                }

                var data = await torrentEngine.DownloadMetadataAsync(MagnetLink.Parse(magnet), s_cts.Token);
                if (data.IsEmpty)
                    return Json(new { error = "DownloadMetadata" });

                var array = data.Span.ToArray();
                IO.File.WriteAllBytes($"cache/torrent/{hash}", array);

                return Json(Torrent.Load(array).Files.Select(i => new { i.Path }));
            }
            catch (Exception ex)
            {
                return Json(new { error = ex.ToString() });
            }
        }
        #endregion

        #region Download
        [HttpGet]
        [Route("dlna/tracker/download")]
        async public Task<JsonResult> Download(string path, int[] indexs, string thumb, long id, bool serial, int lastCount = -1)
        {
            if (!AppInit.conf.dlna.enable)
                return Json(new { error = "enable" });

            try
            {
                var tparse = await getTorrent(path);
                if (tparse.magnet == null)
                    return Json(new { error = "magnet" });

                // cache metadata
                string hash = Regex.Match(tparse.magnet, "btih:([a-z0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value.ToLower();
                if (IO.File.Exists($"cache/torrent/{hash}") && !IO.File.Exists($"cache/metadata/{hash.ToUpper()}.torrent"))
                    IO.File.Copy($"cache/torrent/{hash}", $"cache/metadata/{hash.ToUpper()}.torrent");
                
                var magnetLink = MagnetLink.Parse(tparse.magnet + (tparse.magnet.Contains("?") ? "&" : "?") + defTrackers);

                await bullderClientEngine();
                TorrentManager manager = torrentEngine.Torrents.FirstOrDefault(i => i.InfoHashes.V1.ToHex() == magnetLink.InfoHashes.V1.ToHex());

                ThreadPool.QueueUserWorkItem(async _ =>
                {
                    try
                    {
                        #region Download thumb
                        if (thumb != null)
                        {
                            try
                            {
                                #region IsValidImg
                                bool IsValidImg(byte[] _img)
                                {
                                    if (AppInit.conf.imagelibrary == "NetVips")
                                        return IsValidImgage(_img, path);

                                    return true;
                                }
                                #endregion

                                string uri = Regex.Replace(thumb, "^https?://[^/]+/", "");

                                var array = await Http.Download($"https://image.tmdb.org/{uri}", timeoutSeconds: 8);
                                if (array == null || !IsValidImg(array))
                                    array = await Http.Download($"https://imagetmdb.{AppInit.conf.cub.mirror}/{uri}");

                                if (array != null && IsValidImg(array))
                                {
                                    Directory.CreateDirectory($"{dlna_path}/thumbs");
                                    IO.File.WriteAllBytes($"{dlna_path}/thumbs/{magnetLink.InfoHashes.V1.ToHex()}.jpg", array);
                                }
                            }
                            catch { }
                        }
                        #endregion

                        if (manager == null)
                        {
                            dynamic tlink = tparse.torrent != null ? Torrent.Load(tparse.torrent) : magnetLink;
                            manager = AppInit.conf.dlna.mode == "stream" ? await torrentEngine.AddStreamingAsync(tlink, $"{dlna_path}/") : await torrentEngine.AddAsync(tlink, $"{dlna_path}/");

                            #region AddTrackerAsync
                            if (IO.File.Exists("cache/trackers.txt") && AppInit.conf.dlna.addTrackersToMagnet)
                            {
                                foreach (string line in IO.File.ReadLines("cache/trackers.txt").OrderBy(x => Random.Shared.Next()))
                                {
                                    if (string.IsNullOrWhiteSpace(line))
                                        continue;

                                    string host = line.Replace("\r", "").Replace("\n", "").Replace("\t", "").Trim();

                                    if (host.StartsWith("http") || host.StartsWith("udp:"))
                                    {
                                        try
                                        {
                                            await manager.TrackerManager.AddTrackerAsync(new Uri(host));
                                        }
                                        catch { }
                                    }
                                }
                            }
                            #endregion
                        }

                        await manager.StartAsync();
                        await manager.WaitForMetadataAsync();

                        #region thumb
                        if (IO.File.Exists($"{dlna_path}/thumbs/{magnetLink.InfoHashes.V1.ToHex()}.jpg"))
                        {
                            try
                            {
                                IO.File.Copy($"{dlna_path}/thumbs/{magnetLink.InfoHashes.V1.ToHex()}.jpg", $"{dlna_path}/thumbs/{CrypTo.md5(manager.Torrent.Name)}.jpg", true);
                            }
                            catch { }
                        }
                        #endregion

                        #region TorrentStateChanged
                        bool dispose = false;

                        manager.TorrentStateChanged += async (s, e) =>
                        {
                            try
                            {
                                if (!dispose && e != null && (e.NewState == TorrentState.Seeding || e.NewState == TorrentState.Stopped || e.NewState == TorrentState.Stopping))
                                {
                                    dispose = true;

                                    try
                                    {
                                        IO.File.Delete($"cache/metadata/{e.TorrentManager.InfoHashes.V1.ToHex()}.torrent");
                                        IO.File.Delete($"cache/metadata/{e.TorrentManager.InfoHashes.V1.ToHex()}.json");
                                    }
                                    catch { }

                                    foreach (var f in e.TorrentManager.Files)
                                    {
                                        try
                                        {
                                            if (f.Priority == Priority.DoNotDownload && IO.File.Exists(f.FullPath))
                                            {
                                                if (f.Length == 0 || f.BytesDownloaded() == 0)
                                                {
                                                    IO.File.Delete(f.FullPath);
                                                }
                                                else
                                                {
                                                    double percentageDownloaded = (double)f.BytesDownloaded() / f.Length;

                                                    if (percentageDownloaded < 0.9)
                                                        IO.File.Delete(f.FullPath);
                                                }
                                            }
                                        }
                                        catch { }
                                    }

                                    await removeClientEngine(e.TorrentManager.InfoHashes.V1.ToHex().ToLower());
                                }
                            }
                            catch { }
                        };
                        #endregion

                        #region lastCount
                        if (lastCount > 0 && manager.Files.Count >= lastCount)
                        {
                            var _indexs = new List<int>();
                            for (int i = manager.Files.Count-1; i >= 0; i--)
                            {
                                if (_indexs.Count == lastCount)
                                    break;

                                if (!Regex.IsMatch(Path.GetExtension(manager.Files[i].Path), AppInit.conf.dlna.mediaPattern))
                                    continue;

                                _indexs.Add(i);
                            }

                            indexs = _indexs.ToArray();
                        }
                        #endregion

                        #region indexs
                        if (indexs == null || indexs.Length == 0)
                        {
                            foreach (var file in manager.Files)
                            {
                                if (file.Priority != Priority.Normal)
                                    await manager.SetFilePriorityAsync(file, Priority.Normal);
                            }
                        }
                        else
                        {
                            Directory.CreateDirectory("cache/metadata/");
                            IO.File.WriteAllText($"cache/metadata/{manager.InfoHashes.V1.ToHex()}.json", JsonConvert.SerializeObject(indexs));

                            for (int i = 0; i < manager.Files.Count; i++)
                            {
                                if (indexs.Contains(i))
                                {
                                    if (manager.Files[i].Priority != Priority.Normal)
                                        await manager.SetFilePriorityAsync(manager.Files[i], Priority.Normal);
                                }
                                else
                                {
                                    if (manager.Files[i].Priority != Priority.DoNotDownload)
                                        await manager.SetFilePriorityAsync(manager.Files[i], Priority.DoNotDownload);
                                }
                            }
                        }
                        #endregion

                        #region tmdb
                        string cat = serial ? "tv" : "movie";
                        var header = HeadersModel.Init(("localrequest", AppInit.rootPasswd));
                        string json = await Http.Get($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/3/{cat}/{id}?api_key={AppInit.conf.tmdb.api_key}&language=ru", timeoutSeconds: 20, headers: header);

                        if (string.IsNullOrEmpty(json))
                            json = await Http.Get($"https://apitmdb.{AppInit.conf.cub.mirror}/3/{cat}/{id}?api_key={AppInit.conf.tmdb.api_key}&language=ru", timeoutSeconds: 20);

                        if (!string.IsNullOrEmpty(json))
                        {
                            IO.File.WriteAllText($"{dlna_path}/tmdb/{CrypTo.md5(manager.Torrent.Name)}.json", json);

                            if (serial)
                            {
                                if (int.TryParse(Regex.Match(json, "\"number_of_seasons\":([0-9 ]+)").Groups[1].Value.Trim(), out int number_of_seasons) && number_of_seasons > 0)
                                {
                                    async ValueTask write(int s)
                                    {
                                        string seasons = await Http.Get($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/3/{cat}/{id}/season/{s}?api_key={AppInit.conf.tmdb.api_key}&language=ru", timeoutSeconds: 20, headers: header);

                                        if (string.IsNullOrEmpty(seasons))
                                            seasons = await Http.Get($"https://apitmdb.{AppInit.conf.cub.mirror}/3/{cat}/{id}/season/{s}?api_key={AppInit.conf.tmdb.api_key}&language=ru", timeoutSeconds: 20);

                                        if (!string.IsNullOrEmpty(seasons))
                                            IO.File.WriteAllText($"{dlna_path}/tmdb/{id}_season-{s}.json", json);
                                    }

                                    if (number_of_seasons == 1)
                                        await write(number_of_seasons);
                                    else
                                    {
                                        foreach (var f in manager.Files)
                                        {
                                            int s = getSeason(Path.GetFileName(f.Path));
                                            if (s > 0)
                                                await write(s);
                                        }
                                    }
                                }
                            }
                        }
                        #endregion
                    }
                    catch { }
                });
            }
            catch (Exception ex)
            {
                return Json(new { error = ex.ToString() });
            }

            return Json(new { status = true });
        }
        #endregion


        #region Delete
        [HttpGet]
        [Route("dlna/tracker/stop")]
        [Route("dlna/tracker/delete")]
        async public Task<JsonResult> TorrentDelete(string infohash)
        {
            if (!AppInit.conf.dlna.enable || torrentEngine == null)
                return Json(new { });

            var manager = torrentEngine.Torrents.FirstOrDefault(i => i.InfoHashes.V1.ToHex() == infohash);
            if (manager != null)
            {
                try
                {
                    IO.File.Delete($"cache/metadata/{manager.InfoHashes.V1.ToHex()}.torrent");
                    IO.File.Delete($"cache/metadata/{manager.InfoHashes.V1.ToHex()}.json");
                }
                catch { }

                try
                {
                    await manager.StopAsync();
                }
                catch { }

                await removeClientEngine(manager.InfoHashes.V1.ToHex().ToLower());
            }

            return Json(new { status = true });
        }
        #endregion

        #region Pause
        [HttpGet]
        [Route("dlna/tracker/pause")]
        async public Task<JsonResult> TorrentPause(string infohash)
        {
            if (!AppInit.conf.dlna.enable || torrentEngine == null)
                return Json(new { });

            var manager = torrentEngine.Torrents.FirstOrDefault(i => i.InfoHashes.V1.ToHex() == infohash);
            if (manager != null)
                await manager.PauseAsync();

            return Json(new { status = true });
        }
        #endregion

        #region Start
        [HttpGet]
        [Route("dlna/tracker/start")]
        async public Task<JsonResult> TorrentStart(string infohash)
        {
            if (!AppInit.conf.dlna.enable || torrentEngine == null)
                return Json(new { });

            var manager = torrentEngine.Torrents.FirstOrDefault(i => i.InfoHashes.V1.ToHex() == infohash);
            if (manager != null)
                await manager.StartAsync();

            return Json(new { status = true });
        }
        #endregion

        #region ChangeFilePriority
        [HttpGet]
        [Route("dlna/tracker/changefilepriority")]
        async public Task<JsonResult> ChangeFilePriority(string infohash, int[] indexs)
        {
            if (!AppInit.conf.dlna.enable || torrentEngine == null)
                return Json(new { });

            var manager = torrentEngine.Torrents.FirstOrDefault(i => i.InfoHashes.V1.ToHex() == infohash);
            if (manager != null)
            {
                if (indexs == null || indexs.Length == 0)
                {
                    foreach (var file in manager.Files)
                    {
                        if (file.Priority != Priority.Normal)
                            await manager.SetFilePriorityAsync(file, Priority.Normal);
                    }

                    if (IO.File.Exists($"cache/metadata/{manager.InfoHashes.V1.ToHex()}.json"))
                        IO.File.Delete($"cache/metadata/{manager.InfoHashes.V1.ToHex()}.json");
                }
                else
                {
                    Directory.CreateDirectory("cache/metadata/");
                    IO.File.WriteAllText($"cache/metadata/{manager.InfoHashes.V1.ToHex()}.json", JsonConvert.SerializeObject(indexs));

                    for (int i = 0; i < manager.Files.Count; i++)
                    {
                        if (indexs.Contains(i))
                        {
                            if (manager.Files[i].Priority != Priority.Normal)
                                await manager.SetFilePriorityAsync(manager.Files[i], Priority.Normal);
                        }
                        else
                        {
                            if (manager.Files[i].Priority != Priority.DoNotDownload)
                                await manager.SetFilePriorityAsync(manager.Files[i], Priority.DoNotDownload);
                        }
                    }
                }
            }

            return Json(new { status = true });
        }
        #endregion



        #region IsValidImgage
        static bool IsValidImgage(byte[] _img, string path)
        {
            if (_img == null)
                return false;

            using (var image = Image.NewFromBuffer(_img))
            {
                try
                {
                    if (!path.Contains(".svg"))
                    {
                        // —Ç–µ—Å—Ç–∏—Ä—É–µ–º jpg/png –Ω–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å
                        byte[] temp = image.JpegsaveBuffer();
                        if (temp == null || temp.Length == 0)
                            return false;
                    }

                    return true;
                }
                catch
                {
                    return false;
                }
            }
        }
        #endregion
    }
}
```

## File: DLNA/ModInit.cs
```
Ôªøusing DLNA.Controllers;
using Shared;
using Shared.Engine;
using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace DLNA
{
    public class ModInit
    {
        public static void loaded()
        {
            DLNAController.Initialization();

            var init = AppInit.conf.dlna;
            var cover = init.cover;
            Directory.CreateDirectory($"{init.path}/temp/");

            ThreadPool.QueueUserWorkItem(async _ => 
            {
                bool? ffmpegInit = null;

                while (true)
                {
                    if (cover.timeout == -666)
                        await Task.Delay(TimeSpan.FromSeconds(5));
                    else
                        await Task.Delay(TimeSpan.FromMinutes(cover.timeout > 0 ? cover.timeout : 1));

                    if (!init.enable || !cover.enable)
                        continue;

                    if (ffmpegInit == null)
                    {
                        ffmpegInit = await FFmpeg.InitializationAsync();
                        if (ffmpegInit == false)
                            break;
                    }

                    try
                    {
                        #region path files
                        foreach (string file in Directory.GetFiles(init.path))
                        {
                            if (!Regex.IsMatch(Path.GetExtension(file), cover.extension))
                                continue;

                            string name = Path.GetFileName(file);
                            var fileinfo = new FileInfo(file);
                            if (fileinfo.Length == 0)
                                continue;

                            var time = fileinfo.CreationTime > fileinfo.LastWriteTime ? fileinfo.CreationTime : fileinfo.LastWriteTime;
                            if (time.AddMinutes(cover.skipModificationTime) > DateTime.Now)
                            {
                                log("skip time: " + file);
                                continue;
                            }

                            string thumb = Path.Combine(init.path, "thumbs", $"{CrypTo.md5(name)}.jpg");
                            if (File.Exists(thumb))
                            {
                                log("thumb ok: " + file);
                                continue;
                            }

                            string lockfile = Path.Combine(init.path, "temp", $"{CrypTo.md5(name)}-ffmpeg.lock");
                            if (File.Exists(lockfile))
                            {
                                log("lock: " + file);
                                continue;
                            }

                            File.Create(lockfile);

                            string coverComand = cover.coverComand.Replace("{file}", file).Replace("{thumb}", thumb);
                            log("\ncoverComand: " + coverComand);
                            var ffmpegLog = await FFmpeg.RunAsync(coverComand, priorityClass: cover.priorityClass);

                            log(ffmpegLog.outputData);
                            log(ffmpegLog.errorData);

                            if (cover.preview)
                            {
                                string preview = Path.Combine(init.path, "temp", $"{CrypTo.md5(name)}.mp4");
                                string previewComand = cover.previewComand.Replace("{file}", file).Replace("{preview}", preview);

                                log("\npreviewComand: " + previewComand);
                                ffmpegLog = await FFmpeg.RunAsync(previewComand, priorityClass: cover.priorityClass);

                                log(ffmpegLog.outputData);
                                log(ffmpegLog.errorData);
                            }
                        }
                        #endregion

                        #region path directories
                        foreach (string folder in Directory.GetDirectories(init.path))
                        {
                            if (folder.Contains("thumbs") || folder.Contains("tmdb") || folder.Contains("temp"))
                                continue;

                            string folder_name = Path.GetFileName(folder);
                            string folder_thumb = Path.Combine(init.path, "thumbs", $"{CrypTo.md5(folder_name)}.jpg");
                            if (File.Exists(folder_thumb))
                            {
                                log("thumb ok: " + folder);
                                continue;
                            }

                            var files = Directory.GetFiles(folder);
                            if (files.Length == 0)
                                continue;

                            var folderinfo = new DirectoryInfo(folder);
                            var time = folderinfo.CreationTime > folderinfo.LastWriteTime ? folderinfo.CreationTime : folderinfo.LastWriteTime;
                            if (time.AddMinutes(cover.skipModificationTime) > DateTime.Now)
                            {
                                log("skip time: " + folder);
                                continue;
                            }

                            string lockfile = Path.Combine(init.path, "temp", $"{CrypTo.md5(folder_name)}-ffmpeg.lock");
                            if (File.Exists(lockfile))
                            {
                                log("lock: " + folder);
                                continue;
                            }

                            File.Create(lockfile);

                            #region –ø–æ—Å—Ç–µ—Ä —Å –ø—Ä–µ–≤—å—é –Ω–∞ –ø–∞–ø–∫—É
                            {
                                string coverComand = cover.coverComand.Replace("{file}", files[0]).Replace("{thumb}", folder_thumb);
                                log("\ncoverComand: " + coverComand);
                                var ffmpegLog = await FFmpeg.RunAsync(coverComand, priorityClass: cover.priorityClass);

                                log(ffmpegLog.outputData);
                                log(ffmpegLog.errorData);

                                if (cover.preview)
                                {
                                    string preview = Path.Combine(init.path, "temp", $"{CrypTo.md5(folder_name)}.mp4");
                                    string previewComand = cover.previewComand.Replace("{file}", files[0]).Replace("{preview}", preview);

                                    log("\npreviewComand: " + previewComand);
                                    ffmpegLog = await FFmpeg.RunAsync(previewComand, priorityClass: cover.priorityClass);

                                    log(ffmpegLog.outputData);
                                    log(ffmpegLog.errorData);
                                }
                            }
                            #endregion

                            #region –ø–æ—Å—Ç–µ—Ä—ã –Ω–∞ —Ñ–∞–π–ª—ã –≤–Ω—É—Ç—Ä–∏ –ø–∞–ø–∫–∏
                            foreach (string file in files)
                            {
                                string name = $"{Path.GetFileName(folder)}/{Path.GetFileName(file)}";
                                string thumb = Path.Combine(init.path, "thumbs", $"{CrypTo.md5(name)}.jpg");

                                string coverComand = cover.coverComand.Replace("{file}", file).Replace("{thumb}", thumb);
                                log("\ncoverComand: " + coverComand);
                                var ffmpegLog = await FFmpeg.RunAsync(coverComand, priorityClass: cover.priorityClass);

                                log(ffmpegLog.outputData);
                                log(ffmpegLog.errorData);
                            }
                            #endregion
                        }
                        #endregion
                    }
                    catch { }
                }

            });
        }


        public static void log(string value)
        {
            if (AppInit.conf.dlna.cover.consoleLog && !string.IsNullOrEmpty(value))
                Console.WriteLine("\nFFmpeg: " + value);
        }
    }
}

```

## File: DLNA/Models/Subtitle.cs
```
Ôªønamespace DLNA.Models
{
    public class Subtitle
    {
        public string label { get; set; }

        public string url { get; set; }
    }
}

```

## File: DLNA/Models/DlnaModel.cs
```
Ôªøusing Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;

namespace DLNA.Models
{
    public class DlnaModel
    {
        public string name { get; set; }

        public string uri { get; set; }

        public string img { get; set; }

        public string preview { get; set; }

        public List<Subtitle> subtitles { get; set; }

        public string path { get; set; }

        public string type { get; set; }

        public long length { get; set; }

        public DateTime creationTime { get; set; }

        public int s { get; set; }

        public int e { get; set; }

        public JObject tmdb { get; set; }

        public JObject episode { get; set; }
    }
}

```

## File: Tracks/ModInit.cs
```
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Shared;
using Shared.Engine;
using Shared.Models.Module;
using System;
using System.IO;
using Tracks.Engine;

namespace Tracks
{
    public class ModInit
    {
        public static bool IsInitialization { get; private set; }

        public static void loaded(InitspaceModel initspace)
        {
            RegisterShutdown(initspace);

            Directory.CreateDirectory("database/tracks");
            FFprobe.InitializationAsync().ContinueWith(t =>
            {
                IsInitialization = t.Result;
                TranscodingService.Instance.Configure(AppInit.conf.transcoding);
            });
        }

        static void RegisterShutdown(InitspaceModel initspace)
        {
            if (initspace?.app?.ApplicationServices != null)
            {
                var lifetime = initspace.app.ApplicationServices.GetService<IHostApplicationLifetime>();
                lifetime?.ApplicationStopping.Register(StopTranscoding);
            }

            AppDomain.CurrentDomain.ProcessExit += (_, _) => StopTranscoding();
        }

        static void StopTranscoding()
        {
            try
            {
                TranscodingService.Instance.StopAll();
            }
            catch { }
        }
    }
}

```

## File: Tracks/TracksController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Shared;
using Shared.Engine;
using System;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Web;

namespace Tracks.Controllers
{
    public class TracksController : BaseController
    {
        [HttpGet]
        [AllowAnonymous]
        [Route("tracks.js")]
        [Route("tracks/js/{token}")]
        public ActionResult Tracks(string token)
        {
            if (!AppInit.conf.ffprobe.enable)
                return Content(string.Empty);

            var sb = new StringBuilder(FileCache.ReadAllText("plugins/tracks.js"));

            sb.Replace("{localhost}", host)
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }


        [Route("ffprobe")]
        async public Task<ActionResult> Ffprobe(string media, bool showerror)
        {
            if (!AppInit.conf.ffprobe.enable || string.IsNullOrWhiteSpace(media) || !media.StartsWith("http") || media.Contains("/transcoding/"))
                return ContentTo("{}");

            return ContentTo(await FfprobeJson(host, HttpContext, hybridCache, media));
        }


        public static async Task<string> FfprobeJson(string host, HttpContext httpContext, HybridCache hybridCache, string media, bool showerror = false)
        {
            string magnethash = null;

            if (media.Contains("/dlna/stream"))
            {
                string path = Regex.Match(media, "\\?path=([^&]+)").Groups[1].Value;
                if (!System.IO.File.Exists("dlna/" + HttpUtility.UrlDecode(path)))
                    return showerror ? "path" : "{}";

                magnethash = path;
            }
            else if (media.Contains("/stream/") || media.Contains("/lite/pidtor/"))
            {
                media = Regex.Replace(media, "[^a-z0-9_:\\-\\/\\.\\=\\?\\&\\%\\@]+", "", RegexOptions.IgnoreCase);

                if (media.Contains("/stream/") && !string.IsNullOrWhiteSpace(AppInit.conf.ffprobe.tsuri))
                    media = Regex.Replace(media, "^https?://[^/]+", AppInit.conf.ffprobe.tsuri, RegexOptions.IgnoreCase);
            }
            else if (media.Contains("/proxy/") && media.Contains(".mkv"))
            {
                string hash = Regex.Match(media, "/proxy/([^\n\r]+\\.mkv)").Groups[1].Value;
                media = ProxyLink.Decrypt(hash, null)?.uri;
                if (string.IsNullOrWhiteSpace(media))
                    return showerror ? "media" : "{}";
            }

            string argumentList = string.Empty;

            string memKey = $"tracks:ffprobe:{media}";
            if (!hybridCache.TryGetValue(memKey, out string outPut, inmemory: false))
            {
                #region getFolder
                static string getFolder(string magnethash)
                {
                    return $"database/tracks/{magnethash}";
                }
                #endregion

                if (media.Contains("/stream/"))
                {
                    magnethash = Regex.Match(media, "link=([a-z0-9]+)").Groups[1].Value;
                    string index = Regex.Match(media, @"index=([0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value;

                    if (!string.IsNullOrWhiteSpace(magnethash))
                        magnethash = $"{magnethash}_{index}";
                }
                else if (media.Contains("/lite/pidtor/"))
                {
                    magnethash = Regex.Match(media, "/lite/pidtor/s([a-z0-9]+)").Groups[1].Value;
                    string index = Regex.Match(media, @"tsid=([0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value;

                    if (!string.IsNullOrWhiteSpace(magnethash))
                        magnethash = $"{magnethash}_{index}";
                }

                if (string.IsNullOrEmpty(magnethash))
                    magnethash = CrypTo.md5(media);

                if (System.IO.File.Exists(getFolder(magnethash)))
                    outPut = BrotliTo.Decompress(getFolder(magnethash));

                if (string.IsNullOrWhiteSpace(outPut))
                {
                    if (!Uri.TryCreate(media, UriKind.Absolute, out var uri) ||
                        (uri.Scheme != Uri.UriSchemeHttp && uri.Scheme != Uri.UriSchemeHttps))
                        return showerror ? "uri" : "{}";

                    var process = new System.Diagnostics.Process();
                    process.StartInfo.UseShellExecute = false;
                    process.StartInfo.RedirectStandardOutput = true;
                    process.StartInfo.StandardOutputEncoding = Encoding.UTF8;
                    process.StartInfo.FileName = AppInit.Win32NT ? "data/ffprobe.exe" : System.IO.File.Exists("data/ffprobe") ? "data/ffprobe" : "ffprobe";

                    process.StartInfo.ArgumentList.Add("-v");
                    process.StartInfo.ArgumentList.Add("quiet");
                    process.StartInfo.ArgumentList.Add("-print_format");
                    process.StartInfo.ArgumentList.Add("json");
                    process.StartInfo.ArgumentList.Add("-show_format");
                    process.StartInfo.ArgumentList.Add("-show_streams");
                    process.StartInfo.ArgumentList.Add(AccsDbInvk.Args(uri.AbsoluteUri, httpContext));

                    argumentList = process.StartInfo.FileName + " " + string.Join(" ", process.StartInfo.ArgumentList);

                    process.Start();

                    outPut = await process.StandardOutput.ReadToEndAsync();
                    await process.WaitForExitAsync();

                    if (outPut == null)
                        outPut = string.Empty;

                    if (Regex.Replace(outPut, "[\n\r\t ]+", "") == "{}")
                        outPut = string.Empty;

                    if (!string.IsNullOrWhiteSpace(outPut) && !string.IsNullOrWhiteSpace(magnethash))
                    {
                        BrotliTo.Compress(getFolder(magnethash), outPut);
                    }
                    else
                    {
                        // –∑–∞–≥–ª—É—à–∫–∞
                        hybridCache.Set(memKey, outPut, DateTime.Now.AddMinutes(AppInit.conf.multiaccess ? 20 : 1), inmemory: false);
                    }
                }
            }

            return string.IsNullOrEmpty(outPut) ? (showerror ? argumentList : "{}") : outPut;
        }
    }
}

```

## File: Tracks/TranscodingController.cs
```
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.StaticFiles;
using Newtonsoft.Json;
using Shared;
using Shared.Engine;
using Shared.Models.AppConf;
using Shared.Models.Templates;
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Web;
using Tracks.Engine;

namespace Tracks.Controllers
{
    [ApiController]
    [Route("transcoding")]
    public sealed class TranscodingController : Controller
    {
        #region static
        readonly TranscodingService _service = TranscodingService.Instance;

        static readonly FileExtensionContentTypeProvider provider = new FileExtensionContentTypeProvider()
        {
            Mappings = {
                [".m4s"] = "video/mp4",
                [".ts"] = "video/mp2t",
                [".mp4"] = "video/mp4",
                [".m2ts"] = "video/MP2T"
            }
        };
        #endregion

        #region transcoding.js
        [AllowAnonymous]
        [HttpGet("/transcoding.js")]
        [HttpGet("js/{token}")]
        public ActionResult TranscodingJs(string token)
        {
            if (!AppInit.conf.transcoding.enable)
                return Content(string.Empty);

            var sb = new StringBuilder(FileCache.ReadAllText("plugins/transcoding.js"));

            sb.Replace("{localhost}", AppInit.Host(HttpContext))
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion


        #region Start
        [HttpGet("start.m3u8")]
        public async Task<IActionResult> StartM3u8(string src, int a, int s, bool subtitles, bool live)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (string.IsNullOrEmpty(src))
                return BadRequest(new { error = "src" });

            if (src.Contains("/proxy/") && src.Contains(".mkv"))
            {
                string hash = Regex.Match(src, "/proxy/([^\n\r]+\\.mkv)").Groups[1].Value;
                src = ProxyLink.Decrypt(hash, null)?.uri;
                if (string.IsNullOrWhiteSpace(src))
                    return BadRequest(new { error = "src decrypt" });
            }

            var defaults = AppInit.conf.transcoding;

            var (job, error) = await _service.Start(new TranscodingStartRequest() 
            { 
                src = src,
                live = live,
                subtitles = subtitles,
                audio = new TranscodingAudioOptions() { index = a },
                hls = new TranscodingHlsOptions() { seek = s }
            });

            if (job == null)
                return BadRequest(new { error });

            string uri = $"{AppInit.Host(HttpContext)}/transcoding/{job.StreamId}/{(live ? "live" : "main")}.m3u8";

            return Redirect(AccsDbInvk.Args(uri, HttpContext));
        }

        [HttpPost("start")]
        public async Task<IActionResult> Start([FromBody] TranscodingStartRequest request)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (request == null)
                return BadRequest(new { error = "Request body is required" });

            var (job, error) = await _service.Start(request);
            if (job == null)
                return BadRequest(new { error });

            return Ok(new
            {
                job.StreamId,
                playlistUrl = AccsDbInvk.Args($"{AppInit.Host(HttpContext)}/transcoding/{job.StreamId}/{(job.Context.live ? "live" : "main")}.m3u8", HttpContext),
                subtitlesUrl = job.Context.subtitles ? AccsDbInvk.Args($"{AppInit.Host(HttpContext)}/transcoding/{job.StreamId}/subtitles", HttpContext) : null,
                hls_timeout_seconds = 60
            });
        }
        #endregion

        #region Seek
        [HttpGet("{streamId}/seek/{ss}")]
        public async Task<IActionResult> Seek(string streamId, int ss)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (!_service.TryResolveJob(streamId, out var job))
                return NotFound();

            if (!job.Context.live)
                return BadRequest(new { error = "Context not live" });

            if (ss < 0)
                return BadRequest(new { error = "ss must be greater or equal 0" });

            var (success, error) = await _service.SeekAsync(streamId, ss);
            if (!success)
                return BadRequest(new { error });

            return Ok();
        }
        #endregion

        #region Live
        [HttpGet("{streamId}/live.m3u8")]
        public async Task<IActionResult> Live(string streamId)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (!_service.TryResolveJob(streamId, out var job))
                return NotFound();

            if (!job.Context.live)
                return BadRequest(new { error = "Context not live" });

            _service.Touch(job);

            string path = Path.Combine(job.Context.OutputDirectory, "index.m3u8");

            var fileExistsTimeout = TimeSpan.FromSeconds(60);
            var sw = System.Diagnostics.Stopwatch.StartNew();

            bool fileExists = System.IO.File.Exists(path);

            while (!fileExists && sw.Elapsed < fileExistsTimeout)
            {
                await Task.Delay(250);
                fileExists = System.IO.File.Exists(path);
                if (fileExists)
                    break;
            }

            if (!fileExists)
                return NotFound();

            string m3u8 = null;

            sw.Restart();
            while (sw.Elapsed < fileExistsTimeout)
            {
                try
                {
                    m3u8 = System.IO.File.ReadAllText(path);
                }
                catch
                {
                    m3u8 = null;
                }

                if (!string.IsNullOrEmpty(m3u8) && Regex.IsMatch(m3u8, "seg_[0-9]+\\.(m4s|ts)"))
                    break;

                await Task.Delay(250);
            }

            if (string.IsNullOrEmpty(m3u8))
                return NotFound();

            m3u8 = Regex.Replace(m3u8, "#EXT-X-MAP:URI=[^\n\r]+", $"#EXT-X-MAP:URI=\"{AccsDbInvk.Args("init.mp4", HttpContext)}\"");
            m3u8 = Regex.Replace(m3u8, "(seg_[0-9]+\\.(m4s|ts))", r =>
            {
                string file = r.Groups[1].Value;
                return AccsDbInvk.Args(file, HttpContext);
            });

            return Content(m3u8, "application/vnd.apple.mpegurl");
        }
        #endregion

        #region Playlist
        [HttpGet("{streamId}/main.m3u8")]
        public async Task<IActionResult> Playlist(string streamId)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (!_service.TryResolveJob(streamId, out var job))
                return NotFound();

            if (job.Context.live)
                return BadRequest(new { error = "Context not playlist" });

            if (!int.TryParse(job.Context.ffprobe["format"].Value<string>("duration").Split('.')[0].Split(',')[0], out int duration) || duration == 0)
                return BadRequest(new { error = "duration" });

            _service.Touch(job);

            var fileExistsTimeout = TimeSpan.FromSeconds(60);
            var sw = System.Diagnostics.Stopwatch.StartNew();

            while (sw.Elapsed < fileExistsTimeout)
            {
                if (Directory.GetFiles(job.Context.OutputDirectory).Length > 2)
                    break;

                await Task.Delay(250);
            }

            int segDur = job.Context.HlsOptions.segDur;

            var builder = new StringBuilder();
            builder.AppendLine("#EXTM3U");
            builder.AppendLine("#EXT-X-PLAYLIST-TYPE:VOD");
            builder.AppendLine($"#EXT-X-VERSION:{(job.Context.HlsOptions.fmp4 ? 7 : 3)}");
            builder.AppendLine($"#EXT-X-TARGETDURATION:{segDur}");
            builder.AppendLine("#EXT-X-MEDIA-SEQUENCE:0");

            if (job.Context.HlsOptions.fmp4)
                builder.AppendLine($"#EXT-X-MAP:URI=\"{AccsDbInvk.Args("init.mp4", HttpContext)}\"");

            for (int i = 0; i < (duration / segDur); i++)
            {
                builder.AppendLine($"#EXTINF:{segDur}.0,");
                builder.AppendLine(AccsDbInvk.Args($"seg_{i:d5}.{(job.Context.HlsOptions.fmp4 ? "m4s" : "ts")}", HttpContext));
            }

            builder.AppendLine("#EXT-X-ENDLIST");

            return Content(builder.ToString(), "application/vnd.apple.mpegurl");
        }
        #endregion

        #region Segment
        [HttpGet("{streamId}/{file}")]
        public async Task<IActionResult> Segment(string streamId, string file)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (!_service.TryResolveJob(streamId, out var job))
                return NotFound();

            _service.Touch(job);

            int? segmentIndex = null;
            if (!job.Context.live && file != null)
            {
                var matchSegment = Regex.Match(file, @"seg_(\d+)\.(m4s|ts)$", RegexOptions.IgnoreCase);
                if (matchSegment.Success && int.TryParse(matchSegment.Groups[1].Value, out var idx))
                    segmentIndex = idx;
            }

            var fileExistsTimeout = TimeSpan.FromSeconds(60);
            var sw = System.Diagnostics.Stopwatch.StartNew();

            string resolved = _service.GetFilePath(job, file);

            if (job.Context.live == false && resolved == null && !file.Contains(".vtt"))
            {
                #region SeekAsync
                if (segmentIndex.HasValue)
                {
                    int segDur = job.Context.HlsOptions.segDur;
                    int ss = segmentIndex.Value * segDur;

                    if (job.Context.HlsOptions.seek == 0 && 30 > ss)
                    {
                        // –ø–µ—Ä–≤—ã–µ 30 —Å–µ–∫—É–Ω–¥ –±–µ–∑ seek-–∞ - –Ω–µ —Ç—Ä–æ–≥–∞–µ–º
                    }
                    else if (job.Context.HlsOptions.seek == ss)
                    {
                        // ffmpeg –Ω–∞ —Ç–µ–∫—É—â–µ–º —Å–µ–≥–º–µ–Ω—Ç–µ
                    }
                    else
                    {
                        // —Ä–∞–±–æ—Ç–∞–µ—Ç –¥–∞–ª—å—à–µ —á–µ–º —Ç–µ–∫—É—â–∏–π —Å–µ–≥–º–µ–Ω—Ç
                        bool goSeek = job.Context.HlsOptions.seek > ss;

                        string extension = Path.GetExtension(file);
                        int segmentsPerMinute = (int)Math.Ceiling(30.0 / segDur);
                        int startIndex = Math.Max(0, segmentIndex.Value - segmentsPerMinute);

                        if (goSeek == false)
                        {
                            goSeek = true;

                            for (int i = startIndex; i < segmentIndex.Value; i++)
                            {
                                string candidate = $"seg_{i:d5}{extension}";
                                if (_service.GetFilePath(job, candidate) != null)
                                {
                                    // –µ—Å—Ç—å —Å–µ–≥–º–µ–Ω—Ç—ã –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 30 —Å–µ–∫—É–Ω–¥
                                    goSeek = false;
                                    break;
                                }
                            }
                        }

                        if (goSeek)
                            await _service.SeekAsync(streamId, ss, segmentIndex.Value);
                    }
                }
                #endregion

                do
                {
                    try
                    {
                        await Task.Delay(200);
                        resolved = _service.GetFilePath(job, file);
                        if (resolved != null)
                            break;
                    }
                    catch { }
                }
                while (sw.Elapsed < fileExistsTimeout);
            }

            if (resolved == null)
                return NotFound();

            #region –∂–¥–µ–º –ø–æ—è–≤–ª–µ–Ω–∏—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞
            while (segmentIndex.HasValue && sw.Elapsed < fileExistsTimeout)
            {
                try
                {
                    string seg = Path.Combine(job.OutputDirectory, $"seg_{segmentIndex.Value + 1:d5}");
                    if (System.IO.File.Exists($"{seg}.{(job.Context.HlsOptions.fmp4 ? "m4s" : "ts")}"))
                        break;
                }
                catch { }

                await Task.Delay(200);
            }
            #endregion

            #region FileStream
            FileStream fs = null;
            do
            {
                try
                {
                    fs = file.Contains(".vtt")
                        ? new FileStream(resolved, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
                        : System.IO.File.OpenRead(resolved);
                    break;
                }
                catch (IOException)
                {
                    await Task.Delay(200);
                }
                catch (UnauthorizedAccessException)
                {
                    await Task.Delay(200);
                }
            } 
            while (sw.Elapsed < fileExistsTimeout);

            if (fs == null)
                return NotFound();
            #endregion

            if (!provider.TryGetContentType(resolved, out var contentType))
                contentType = "application/octet-stream";

            if (segmentIndex.HasValue)
                _service.ReportSegmentAccess(job, segmentIndex.Value);

            return File(fs, contentType, enableRangeProcessing: true);
        }
        #endregion

        #region Subtitles
        [HttpGet("{streamId}/subtitles")]
        public IActionResult Subtitles(string streamId)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (!_service.TryResolveJob(streamId, out var job))
                return NotFound();

            _service.Touch(job);

            var subsTpl = new SubtitleTpl();

            if (job.Context.subtitles && job.Context.ffprobe.ContainsKey("streams"))
            {
                foreach (var s in job.Context.ffprobe["streams"])
                {
                    if (s.Value<string>("codec_type") != "subtitle")
                        continue;

                    if (s.Value<string>("codec_name") is "subrip" or "webvtt" or "ass" or "ssa" or "mov_text" or "ttml" or "sami")
                    {
                        int subIndex = s.Value<int>("index");
                        if (subIndex == 0)
                            continue;

                        string uri = $"{AppInit.Host(HttpContext)}/transcoding/{streamId}/{AccsDbInvk.Args($"subs_{subIndex}.vtt", HttpContext)}";

                        string name = s["tags"].Value<string>("title")
                            ?? s["language"].Value<string>("title")
                            ?? $"sub_{subIndex}";

                        subsTpl.Append(name, uri);
                    }
                }
            }

            return Ok(subsTpl.ToObject());
        }
        #endregion

        #region Heartbeat
        [HttpGet("{streamId}/heartbeat")]
        public IActionResult Heartbeat(string streamId)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (!_service.TryResolveJob(streamId, out var job))
                return NotFound();

            _service.Touch(job);
            return Ok();
        }
        #endregion

        #region StopAsync
        [HttpGet("{streamId}/stop")]
        public async Task<IActionResult> StopAsync(string streamId)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            var stopped = await _service.StopAsync(streamId);
            return stopped ? Ok() : NotFound();
        }
        #endregion

        #region Status
        [HttpGet("{streamId}/status")]
        public IActionResult Status(string streamId)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (!_service.TryResolveJob(streamId, out var job))
                return NotFound();

            var now = DateTime.UtcNow;
            var state = job.Process.HasExited ? TranscodingJobState.Stopped : TranscodingJobState.Running;

            var uptime = now - job.StartedUtc;

            int? exitCode = null;
            try
            {
                if (job.Process.HasExited)
                    exitCode = job.Process.ExitCode;
            }
            catch { }

            var snapshotLog = job.SnapshotLog();

            ulong time_ms = 0;
            foreach (string line in snapshotLog.Reverse())
            {
                if (!line.Contains("out_time_ms="))
                    continue;

                if (!ulong.TryParse(Regex.Match(line, "out_time_ms=([0-9]+)").Groups[1].Value, out time_ms))
                    continue;

                break;
            }

            return Content(JsonConvert.SerializeObject(new
            {
                job.StreamId,
                state = state.ToString(),
                job.OutputDirectory,
                ffmpeg = string.Join(" ", job.Process.StartInfo.ArgumentList),
                startedUtc = job.StartedUtc,
                lastAccessUtc = job.LastAccessUtc,
                uptime = uptime.TotalSeconds,
                positionSec = (ulong)(job.Context.HlsOptions.seek + (time_ms > 0 ? (time_ms / 1000000.0) : 0)),
                exitCode,
                job.Context.ffprobe,
                log = snapshotLog
            }), "application/json; charset=utf-8");
        }
        #endregion


        #region DOC
        [HttpGet("")]
        public IActionResult DOC()
        {
            var endpoints = new object[]
            {
                new {
                    path = "/transcoding/start.m3u8",
                    method = "GET",
                    query = new object[] {
                        new { name = "src", type = "string", required = true, description = "Source URL or local path to media" },
                        new { name = "a", type = "int", required = false, description = "Audio index (optional)" },
                        new { name = "s", type = "int", required = false, description = "Seek position in seconds (optional)" },
                        new { name = "subtitles", type = "bool", required = false, description = "subtitles on/off" },
                        new { name = "live", type = "bool", required = false, description = "Context live/playlist" }
                    },
                    description = "Start transcoding with query parameters and redirect to the generated HLS playlist"
                },
                new {
                    path = "/transcoding/start",
                    method = "POST",
                    contentType = "application/json",
                    body = new {
                        src = "https://example.com/media.mp4",
                        videoFormat = "",
                        live = false,
                        subtitles = false,
                        headers = new { referer = "https://example.com", userAgent = "HlsProxy/1.0" },
                        audio = AppInit.conf.transcoding.audioOptions,
                        hls = AppInit.conf.transcoding.hlsOptions
                    },
                    description = "Start transcoding by POSTing a JSON body. Returns StreamId and playlist URL"
                },
                new {
                    path = "/transcoding/{streamId}/live.m3u8",
                    method = "GET",
                    route = new { name = "streamId", type = "string", required = true },
                    description = "Returns the HLS live for the given transcoding job"
                },
                new {
                    path = "/transcoding/{streamId}/main.m3u8",
                    method = "GET",
                    route = new { name = "streamId", type = "string", required = true },
                    description = "Returns the HLS master/variant playlist for the given transcoding job"
                },
                new {
                    path = "/transcoding/{streamId}/{file}",
                    method = "GET",
                    route = new object[] {
                        new { name = "streamId", type = "string", required = true },
                        new { name = "file", type = "string", required = true, description = "Requested segment or asset (e.g. init.mp4, seg_1.m4s, index.m3u8)" }
                    },
                    description = "Serves individual segment files, init files and playlists produced by the transcoder. Supports range requests."
                },
                new {
                    path = "/transcoding/{streamId}/seek/{ss}",
                    method = "GET",
                    route = new object[] {
                        new { name = "streamId", type = "string", required = true },
                        new { name = "ss", type = "int", required = true, description = "Seek position in seconds (>= 0)" }
                    },
                    description = "Request the transcoder to seek to the specified position (async). Returns 200 on success."
                },
                new {
                    path = "/transcoding/{streamId}/heartbeat",
                    method = "GET",
                    route = new { name = "streamId", type = "string", required = true },
                    description = "Touch the job to keep it alive. Returns 200 if job exists."
                },
                new {
                    path = "/transcoding/{streamId}/stop",
                    method = "GET",
                    route = new { name = "streamId", type = "string", required = true },
                    description = "Stop the transcoding job. Returns 200 if stopped or 404 if job not found."
                },
                new {
                    path = "/transcoding/{streamId}/status",
                    method = "GET",
                    query = new { name = "log", type = "bool", required = false, description = "Include job log snapshot when true" },
                    route = new { name = "streamId", type = "string", required = true },
                    description = "Return current job status, uptime, position and optional log snapshot."
                }
            };

            return Ok(JsonConvert.SerializeObject(endpoints, Formatting.Indented));
        }
        #endregion
    }
}

```

## File: Tracks/Engine/TranscodingService.cs
```
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Models.AppConf;
using Shared.Models.Events;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Tracks.Controllers;

namespace Tracks.Engine
{
    internal sealed class TranscodingService
    {
        static readonly Lazy<TranscodingService> _lazy = new(() => new TranscodingService());

        readonly ConcurrentDictionary<string, TranscodingJob> _jobs = new();
        readonly Regex _safeFileNameRegex = new("^[A-Za-z0-9_.-]+$", RegexOptions.Compiled | RegexOptions.CultureInvariant);
        readonly Regex _segmentFileRegex = new("^seg_(\\d+)\\.(m4s|ts)$", RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant);

        int _segmentCleanupRunning;
        readonly Timer _segmentCleanupTimer;

        byte[] _hmacKey = RandomNumberGenerator.GetBytes(32);
        static string _ffmpegPath;

        public static TranscodingService Instance => _lazy.Value;

        private TranscodingService()
        {
            _segmentCleanupTimer = new Timer(_ => CleanupSegments(), null, TimeSpan.FromMinutes(1), TimeSpan.FromSeconds(20));
        }

        public void Configure(TranscodingConf config)
        {
            if (config == null)
                return;

            _ffmpegPath = string.IsNullOrWhiteSpace(config.ffmpeg)
                    ? (AppInit.Win32NT ? "data/ffmpeg.exe" : (File.Exists("data/ffmpeg") ? "data/ffmpeg" : "ffmpeg"))
                    : config.ffmpeg;

            if (string.IsNullOrWhiteSpace(config.tempRoot))
                config.tempRoot = Path.Combine("cache", "transcoding");

            try
            {
                if (!Directory.Exists(config.tempRoot))
                {
                    Directory.CreateDirectory(config.tempRoot);
                }
                else
                {
                    foreach (var dir in Directory.GetDirectories(config.tempRoot))
                    {
                        try
                        {
                            Directory.Delete(dir, true);
                        }
                        catch { }
                    }
                }
            }
            catch { }
        }

        public ICollection<TranscodingJob> Jobs => _jobs.Values;

        async public Task<(TranscodingJob job, string error)> Start(TranscodingStartRequest request)
        {
            var config = GetConfig();
            if (!config.enable)
                return (null!, "Transcoding disabled");

            if (request == null || string.IsNullOrWhiteSpace(request.src))
                return (null!, "Source URL is required");

            if (_jobs.Count >= Math.Max(1, config.maxConcurrentJobs))
                return (null!, "Maximum concurrent jobs reached");

            if (!TryValidateSource(request.src, config, out var source, out var error))
                return (null!, error);

            var id = Guid.NewGuid().ToString("N");
            var streamId = BuildToken(id);

            var outputDir = Path.Combine(config.tempRoot!, id);
            Directory.CreateDirectory(outputDir);

            #region ffprobe
            JObject ffprobe = null;

            string ffprobeJson = await TracksController.FfprobeJson(null, null, new HybridCache(), request.src);
            if (string.IsNullOrEmpty(ffprobeJson) || ffprobeJson == "{}")
                return (null!, "ffprobe");

            ffprobe = JsonConvert.DeserializeObject<JObject>(ffprobeJson);

            if (ffprobe == null || !ffprobe.ContainsKey("format"))
                return (null!, "ffprobe");
            #endregion

            var context = new TranscodingStartContext(
                source,
                SanitizeHeader(GetHeader(request.headers, "userAgent"), Http.UserAgent),
                SanitizeHeader(GetHeader(request.headers, "referer")),
                MergeHlsOptions(config, request.hls),
                MergeAudioOptions(config, request.audio),
                request.live,
                request.subtitles ?? config.defaultSubtitles,
                outputDir,
                null,
                ffprobe
            );

            var process = CreateProcess(context);

            try
            {
                if (!process.Start())
                {
                    process.Dispose();
                    return (null!, "Failed to start ffmpeg");
                }
            }
            catch (Exception ex)
            {
                process.Dispose();
                return (null!, $"Failed to start ffmpeg: {ex.Message}");
            }

            var job = new TranscodingJob(id, streamId, outputDir, process, context);
            if (!_jobs.TryAdd(id, job))
            {
                try
                {
                    process.Kill(true);
                }
                catch { }

                process.Dispose();
                try
                {
                    if (Directory.Exists(outputDir))
                        Directory.Delete(outputDir, true);
                }
                catch { }
                return (null!, "Failed to register job");
            }

            _ = Task.Run(() => PumpStdErrAsync(job));
            _ = Task.Run(() => IdleWatchdogAsync(job, config));

            process.EnableRaisingEvents = true;
            process.Exited += (_, _) => 
            {
                if (process.EnableRaisingEvents)
                    OnProcessExit(job);
            };

            return (job, string.Empty);
        }

        public bool TryResolveJob(string streamId, out TranscodingJob job)
        {
            job = null!;
            if (string.IsNullOrWhiteSpace(streamId))
                return false;

            if (!TryParseToken(streamId, out var id))
                return false;

            if (!_jobs.TryGetValue(id, out job))
                return false;

            return true;
        }

        public async Task<(bool success, string error)> SeekAsync(string streamId, int seconds, int? startSegment = null)
        {
            if (seconds < 0)
                return (false, "ss must be greater or equal 0");

            if (!TryResolveJob(streamId, out var job))
                return (false, "Job not found");

            var config = GetConfig();

            var newContext = job.Context with
            {
                HlsOptions = new TranscodingHlsOptions
                {
                    seek = seconds,
                    segDur = job.Context.HlsOptions.segDur,
                    winSize = job.Context.HlsOptions.winSize,
                    fmp4 = job.Context.HlsOptions.fmp4
                },
                startNumber = startSegment
            };

            job.Process.EnableRaisingEvents = false;
            await StopJobAsync(job, forced: true, cleanup: false);

            Directory.CreateDirectory(newContext.OutputDirectory);

            var process = CreateProcess(newContext);

            try
            {
                if (!process.Start())
                {
                    process.Dispose();
                    return (false, "Failed to start ffmpeg");
                }
            }
            catch (Exception ex)
            {
                process.Dispose();
                return (false, $"Failed to start ffmpeg: {ex.Message}");
            }

            var newJob = new TranscodingJob(job.Id, job.StreamId, job.OutputDirectory, process, newContext);

            if (_jobs.AddOrUpdate(job.Id, newJob, (k, v) => newJob) == null)
            {
                try
                {
                    process.Kill(true);
                }
                catch { }

                process.Dispose();
                return (false, "Failed to restart job");
            }

            _ = Task.Run(() => PumpStdErrAsync(newJob));
            _ = Task.Run(() => IdleWatchdogAsync(newJob, config));

            process.EnableRaisingEvents = true;
            process.Exited += (_, _) =>
            {
                if (process.EnableRaisingEvents)
                    OnProcessExit(newJob);
            };

            return (true, string.Empty);
        }

        public async Task<bool> StopAsync(string streamId)
        {
            if (!TryResolveJob(streamId, out var job))
                return false;

            await StopJobAsync(job);
            return true;
        }

        public void Touch(TranscodingJob job) => job.UpdateLastAccess();

        public string GetFilePath(TranscodingJob job, string file)
        {
            if (string.IsNullOrWhiteSpace(file) || !_safeFileNameRegex.IsMatch(file))
                return null;

            var candidate = Path.Combine(job.OutputDirectory, file);
            if (!candidate.StartsWith(job.OutputDirectory, StringComparison.Ordinal))
                return null;

            return File.Exists(candidate) ? candidate : null;
        }

        public void ReportSegmentAccess(TranscodingJob job, int segmentIndex)
        {
            job?.UpdateLastSegmentIndex(segmentIndex);
        }

        private async Task StopJobAsync(TranscodingJob job, bool forced = false, bool cleanup = true)
        {
            try
            {
                if (!job.Process.HasExited)
                {
                    if (forced)
                    {
                        job.Process.Kill(true);
                    }
                    else
                    {
                        try
                        {
                            await job.Process.StandardInput.WriteLineAsync("q");
                            await job.Process.StandardInput.FlushAsync();
                        }
                        catch { }

                        var waitTask = job.Process.WaitForExitAsync();
                        var timeout = Task.Delay(TimeSpan.FromMilliseconds(1500));
                        var completed = await Task.WhenAny(waitTask, timeout);
                        if (completed != waitTask)
                        {
                            try
                            {
                                job.Process.Kill(true);
                            }
                            catch { }

                            try
                            {
                                await job.Process.WaitForExitAsync();
                            }
                            catch { }
                        }
                        else
                        {
                            try
                            {
                                await waitTask;
                            }
                            catch { }
                        }
                    }
                }
            }
            finally
            {
                if (cleanup)
                    Cleanup(job);
            }
        }

        private void Cleanup(TranscodingJob job)
        {
            var removed = _jobs.TryRemove(job.Id, out _);

            try
            {
                job.StopBackground();
                job.SignalExit();
            }
            catch { }

            if (!removed)
                return;

            try
            {
                if (Directory.Exists(job.OutputDirectory))
                    Directory.Delete(job.OutputDirectory, true);
            }
            catch { }

            job.Dispose();
        }

        private TranscodingConf GetConfig()
        {
            return AppInit.conf.transcoding;
        }

        private static string GetHeader(Dictionary<string, string> headers, string key)
        {
            if (headers == null || headers.Count == 0)
                return null;

            foreach (var (k, v) in headers)
            {
                if (string.Equals(k, key, StringComparison.OrdinalIgnoreCase))
                    return v;
            }

            return null;
        }

        private static TranscodingHlsOptions MergeHlsOptions(TranscodingConf config, TranscodingHlsOptions request)
        {
            var opt = request ?? config.hlsOptions;

            return new TranscodingHlsOptions
            {
                seek = opt?.seek > 0 ? opt.seek : 0,
                segDur = opt?.segDur > 1 ? opt.segDur : 1,
                winSize = opt?.winSize > 5 ? opt.winSize : 5,
                fmp4 = opt?.fmp4 ?? true
            };
        }

        private static TranscodingAudioOptions MergeAudioOptions(TranscodingConf config, TranscodingAudioOptions request)
        {
            var opt = request ?? config.audioOptions;

            return new TranscodingAudioOptions
            {
                index = opt?.index >= 0 ? opt.index : 0,
                bitrateKbps = opt?.bitrateKbps is > 0 and <= 512 ? opt.bitrateKbps : 160,
                stereo = opt?.stereo ?? true,
                codec_copy = opt?.codec_copy ?? config.audioOptions.codec_copy
            };
        }

        private static bool TryValidateSource(string src, TranscodingConf config, out Uri uri, out string error)
        {
            error = string.Empty;
            uri = null!;

            if (!Uri.TryCreate(src, UriKind.Absolute, out uri) ||
                (uri.Scheme != Uri.UriSchemeHttp && uri.Scheme != Uri.UriSchemeHttps))
            {
                error = "Only http/https URLs are allowed";
                return false;
            }

            if (config.allowHosts != null && config.allowHosts.Length > 0)
            {
                if (!config.allowHosts.Contains(uri.Host, StringComparer.OrdinalIgnoreCase))
                {
                    error = "Source host is not allowed";
                    return false;
                }
            }

            return true;
        }

        public void StopAll()
        {
            var jobs = _jobs.Values.ToArray();
            foreach (var job in jobs)
            {
                try
                {
                    _ = StopJobAsync(job, forced: true).ConfigureAwait(false);
                }
                catch { }
            }
        }

        private Process CreateProcess(TranscodingStartContext context)
        {
            var config = GetConfig();

            var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = _ffmpegPath,
                    UseShellExecute = false,
                    RedirectStandardError = true,
                    RedirectStandardInput = true,
                    RedirectStandardOutput = false,
                    CreateNoWindow = true,
                    WorkingDirectory = context.OutputDirectory
                }
            };

            var args = process.StartInfo.ArgumentList;

            /*
-hide_banner ‚Äî –æ—Ç–∫–ª—é—á–∞–µ—Ç –≤—ã–≤–æ–¥ –±–∞–Ω–Ω–µ—Ä–∞ ffmpeg (–≤–µ—Ä—Å–∏—è/–∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è) –≤ stderr, —á—Ç–æ–±—ã –ª–æ–≥–∏ –±—ã–ª–∏ —á–∏—â–µ.
-user_agent {context.UserAgent} ‚Äî –∑–∞–¥–∞—ë—Ç –∑–∞–≥–æ–ª–æ–≤–æ–∫ User-Agent –¥–ª—è HTTP-–∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –≤—Ö–æ–¥–Ω–æ–º—É URL.
-headers "Referer: {context.Referer}\n" ‚Äî –¥–æ–±–∞–≤–ª—è–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–µ HTTP-–∑–∞–≥–æ–ª–æ–≤–∫–∏ (–∑–¥–µ—Å—å: Referer) –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ –≤—Ö–æ–¥–Ω–æ–º—É URL.
-re ‚Äî —á–∏—Ç–∞–µ—Ç –≤—Ö–æ–¥–Ω–æ–π –ø–æ—Ç–æ–∫ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏; –ø–æ–ª–µ–∑–Ω–æ –ø—Ä–∏ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏/—Å—Ç—Ä–∏–º–∏–Ω–≥–µ, —á—Ç–æ–±—ã –Ω–µ —á–∏—Ç–∞—Ç—å –≤—Ö–æ–¥ –±—ã—Å—Ç—Ä–µ–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏.
-threads 0 ‚Äî –ø–æ–∑–≤–æ–ª—è–µ—Ç ffmpeg –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–±—Ä–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤ (CPU) –¥–ª—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è/–¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è.
-fflags +genpts ‚Äî –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç PTS –¥–ª—è –∫–∞–¥—Ä–æ–≤, –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç (–∏–∑–±–µ–≥–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º —Å –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–º–∏ –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –º–µ—Ç–∫–∞–º–∏).
-i {Source} ‚Äî —É–∫–∞–∑—ã–≤–∞–µ—Ç –≤—Ö–æ–¥–Ω–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫ (URL/—Ñ–∞–π–ª).
-map 0:v:0 ‚Äî –º–∞–ø–ø–∏—Ç –ø–µ—Ä–≤—ã–π –≤–∏–¥–µ–æ–ø–æ—Ç–æ–∫ –ø–µ—Ä–≤–æ–≥–æ –≤—Ö–æ–¥–∞ –≤ –≤—ã—Ö–æ–¥.
-map 0:a:0 ‚Äî –º–∞–ø–ø–∏—Ç –ø–µ—Ä–≤—ã–π –∞—É–¥–∏–æ–ø–æ—Ç–æ–∫ –ø–µ—Ä–≤–æ–≥–æ –≤—Ö–æ–¥–∞ –≤ –≤—ã—Ö–æ–¥.
-sn (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –ø—Ä–∏ subtitles == false) ‚Äî –∏—Å–∫–ª—é—á–∏—Ç—å —Å—É–±—Ç–∏—Ç—Ä—ã –∏–∑ –≤—ã–≤–æ–¥–∞.
-dn ‚Äî –∏—Å–∫–ª—é—á–∏—Ç—å data-–ø–æ—Ç–æ–∫–∏ (metadata/data tracks).
-map_metadata -1 ‚Äî –Ω–µ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –≤ –≤—ã—Ö–æ–¥ (–æ—á–∏—â–∞–µ—Ç –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ).
-map_chapters -1 ‚Äî –Ω–µ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≥–ª–∞–≤—ã (—É–¥–∞–ª—è–µ—Ç chapters).
-c:v copy ‚Äî –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–∏–¥–µ–æ–ø–æ—Ç–æ–∫–∞ –±–µ–∑ –ø–µ—Ä–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è (–¥–ª—è –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –Ω–∞–≥—Ä—É–∑–∫–∏ –∏ –±–µ–∑ –ø–æ—Ç–µ—Ä–∏ –∫–∞—á–µ—Å—Ç–≤–∞).

–ê—É–¥–∏–æ:
–ï—Å–ª–∏ transcodeToAac:
-c:a aac ‚Äî –∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –∞—É–¥–∏–æ –≤ AAC.
-ac 2 / -ac 1 ‚Äî —á–∏—Å–ª–æ –∫–∞–Ω–∞–ª–æ–≤ (—Å—Ç–µ—Ä–µ–æ/–º–æ–Ω–æ) –ø–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ.
-b:a {N}k ‚Äî –±–∏—Ç—Ä–µ–π—Ç –∞—É–¥–∏–æ.
-profile:a aac_low ‚Äî –ø—Ä–æ—Ñ–∏–ª—å AAC (–æ–±—ã—á–Ω–æ LC –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ –∏ –Ω–∏–∑–∫–æ–π –∑–∞–¥–µ—Ä–∂–∫–∏).
–ò–Ω–∞—á–µ: -c:a copy ‚Äî –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –∞—É–¥–∏–æ –±–µ–∑ –ø–µ—Ä–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è.

HLS / –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä:
-avoid_negative_ts disabled ‚Äî –Ω–µ —Å–¥–≤–∏–≥–∞—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö TS; —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –∏—Å—Ö–æ–¥–Ω—ã–µ PTS –ø—Ä–∏ HLS-—Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏.
-max_muxing_queue_size 2048 ‚Äî —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –æ—á–µ—Ä–µ–¥—å –ø–∞–∫–µ—Ç–æ–≤ –ø—Ä–∏ –º—É–ª—å—Ç–∏–ø–ª–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–∏ (–ø–æ–º–æ–≥–∞–µ—Ç –ø—Ä–æ—Ç–∏–≤ ‚ÄúToo many packets buffered‚Äù).
-f hls ‚Äî —Ñ–æ—Ä–º–∞—Ç –≤—ã—Ö–æ–¥–∞ HLS (HTTP Live Streaming).
-max_delay 5000000 ‚Äî –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –±—É—Ñ–µ—Ä–∞ (–≤ –º–∫—Å; –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞), —Å–Ω–∏–∂–∞–µ—Ç —Ä–∏—Å–∫ –∏–∑–±—ã—Ç–æ—á–Ω–æ–≥–æ –±—É—Ñ–µ—Ä–∏–Ω–≥–∞.
-hls_segment_type fmp4 –∏–ª–∏ mpegts ‚Äî —Ç–∏–ø —Å–µ–≥–º–µ–Ω—Ç–æ–≤ HLS (CMAF/fMP4 –∏–ª–∏ MPEG-TS).
–¥–ª—è mpegts: -bsf:v h264_mp4toannexb ‚Äî –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç H.264 –∫ Annex-B, –∫–∞–∫ —Ç—Ä–µ–±—É–µ—Ç—Å—è –¥–ª—è TS.
-hls_time {segDur} ‚Äî –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–µ–≥–º–µ–Ω—Ç–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö.
-hls_flags append_list+omit_endlist ‚Äî
append_list ‚Äî –¥–æ–ø–∏—Å—ã–≤–∞—Ç—å –∑–∞–ø–∏—Å–∏ –≤ –ø–ª–µ–π–ª–∏—Å—Ç;
omit_endlist ‚Äî –Ω–µ –¥–æ–±–∞–≤–ª—è—Ç—å #EXT-X-ENDLIST, —á—Ç–æ–±—ã –ø–ª–µ–π–ª–∏—Å—Ç —Å—á–∏—Ç–∞–ª—Å—è ‚Äú–∂–∏–≤—ã–º‚Äù.
-hls_list_size {winSize} ‚Äî —Ä–∞–∑–º–µ—Ä –æ–∫–Ω–∞ –ø–ª–µ–π–ª–∏—Å—Ç–∞ (—Å–∫–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Å–µ–≥–º–µ–Ω—Ç–æ–≤ –≤–∏–¥–∏—Ç –∫–ª–∏–µ–Ω—Ç).
-master_pl_name index.m3u8 ‚Äî –∏–º—è master-–ø–ª–µ–π–ª–∏—Å—Ç–∞ (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è).
-hls_fmp4_init_filename {init.mp4} ‚Äî –∏–º—è init-—Å–µ–≥–º–µ–Ω—Ç–∞ –¥–ª—è fMP4.
-hls_segment_filename {seg_%05d.m4s | seg_%05d.ts} ‚Äî —à–∞–±–ª–æ–Ω –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–æ–≤ —Å–µ–≥–º–µ–Ω—Ç–æ–≤.
-y {PlaylistPath} ‚Äî –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å –≤—ã—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª –±–µ–∑ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è (–ø—É—Ç—å –∏—Ç–æ–≥–æ–≤–æ–≥–æ –ø–ª–µ–π–ª–∏—Å—Ç–∞/—Ñ–∞–π–ª–∞).
             */

            args.Add("-hide_banner");

            if (context.UserAgent != null)
            {
                args.Add("-user_agent");
                args.Add(context.UserAgent);
            }

            if (!string.IsNullOrWhiteSpace(context.Referer))
            {
                args.Add("-headers");
                args.Add($"Referer: {context.Referer}\\r\\n");
            }

            if (context.HlsOptions.seek > 0)
            {
                args.Add("-ss");
                args.Add(context.HlsOptions.seek.ToString());
                args.Add("-noaccurate_seek");
            }

            args.Add("-nostats");
            args.Add("-progress");
            args.Add("pipe:2");
            args.Add("-stats_period");
            args.Add(context.live ? "1" : "5");

            #region demuxer
            foreach (var c in config.comand["demuxer"])
            {
                foreach (var a in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                    args.Add(a);
            }
            #endregion

            #region readrate
            if (context.live)
            {
                args.Add("-re");
            }
            else if (config.playlistOptions.readrate > 0)
            {
                args.Add("-readrate");
                args.Add(config.playlistOptions.readrate.ToString().Replace(",", "."));

                if (config.playlistOptions.burst > 0)
                {
                    args.Add("-readrate_initial_burst");
                    args.Add(config.playlistOptions.burst.ToString());
                }
            }
            #endregion

            args.Add("-i");
            args.Add(context.Source.AbsoluteUri);

            #region input
            foreach (var c in config.comand["input"])
            {
                foreach (var a in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                    args.Add(a);
            }
            #endregion

            #region subtitles map
            if (context.subtitles && !context.live && 0 >= config.playlistOptions.readrate && context.ffprobe.ContainsKey("streams"))
            {
                args.Add("-copyts");

                foreach (var s in context.ffprobe["streams"])
                {
                    if (s.Value<string>("codec_type") != "subtitle")
                        continue;

                    string codec_name = s.Value<string>("codec_name");
                    if (!string.IsNullOrEmpty(codec_name) && config.subtitleOptions.codec.Contains(codec_name))
                    {
                        int subIndex = s.Value<int>("index");
                        if (subIndex == 0)
                            continue;

                        foreach (var c in config.subtitleOptions.comand)
                        {
                            foreach (var a in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                                args.Add(a.Replace("{subIndex}", subIndex.ToString()));
                        }
                    }
                }
            }
            #endregion

            #region HLS map
            foreach (var c in config.comand["output"])
            {
                foreach (var a in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                    args.Add(a.Replace("{audio_index}", $"{(0 >= context.Audio.index ? 0 : context.Audio.index)}"));
            }

            #region -c:v
            if (config.convertOptions.transcodeVideo && config.convertOptions.codec != null &&
                context.ffprobe != null && context.ffprobe.ContainsKey("streams") &&
                config.convertOptions.comand != null && config.convertOptions.comand.Count > 0)
            {
                try
                {
                    bool convert = false;

                    string codec_name = context.ffprobe["streams"].First.Value<string>("codec_name") ?? "";
                    if (!string.IsNullOrEmpty(codec_name) && config.convertOptions.codec.Contains(codec_name))
                        convert = true;

                    string pix_fmt = context.ffprobe["streams"].First.Value<string>("pix_fmt") ?? "";
                    if (!string.IsNullOrEmpty(pix_fmt) && config.convertOptions.codec.Contains(pix_fmt))
                        convert = true;

                    if (config.convertOptions.codec.Contains($"{codec_name}_{pix_fmt}"))
                        convert = true;

                    if (convert)
                    {
                        string[] comand = config.convertOptions.comand["default"];

                        foreach (string key in new string[] { $"{codec_name}_{pix_fmt}", pix_fmt, codec_name })
                        {
                            if (config.convertOptions.comand.ContainsKey(key))
                            {
                                comand = config.convertOptions.comand[key];
                                break;
                            }
                        }

                        foreach (var c in comand)
                        {
                            foreach (var t in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                                args.Add(t);
                        }
                    }
                    else
                    {
                        args.Add("-c:v");
                        args.Add("copy");
                    }
                }
                catch
                {
                    args.Add("-c:v");
                    args.Add("copy");
                }
            }
            else
            {
                args.Add("-c:v");
                args.Add("copy");
            }
            #endregion

            #region -c:a
            {
                bool convert = true;

                var audioCodec = context.ffprobe["streams"].FirstOrDefault(i => i.Value<int>("index") == ((0 >= context.Audio.index ? 0 : context.Audio.index) + 1));

                string codec_name = audioCodec?.Value<string>("codec_name") ?? string.Empty;
                if (!string.IsNullOrEmpty(codec_name) && context.Audio.codec_copy.Contains(codec_name))
                    convert = false;

                string channel = audioCodec?.Value<int?>("channels")?.ToString() ?? string.Empty;
                if (!string.IsNullOrEmpty(channel) && context.Audio.codec_copy.Contains(channel))
                    convert = false;

                if (context.Audio.codec_copy.Contains($"{codec_name}_{channel}"))
                    convert = false;

                if (convert)
                {
                    string[] comand = config.audioOptions.comand_transcode["default"];

                    foreach (string key in new string[] { $"{codec_name}_{channel}", channel, codec_name })
                    {
                        if (config.audioOptions.comand_transcode.ContainsKey(key))
                        {
                            comand = config.audioOptions.comand_transcode[key];
                            break;
                        }
                    }

                    foreach (var c in comand)
                    {
                        foreach (var a in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                            args.Add(a.Replace("{stereo}", context.Audio.stereo ? "2" : "1").Replace("{bitrateKbps}", $"{Math.Clamp(context.Audio.bitrateKbps, 32, 512)}k"));
                    }
                }
                else
                {
                    args.Add("-c:a");
                    args.Add("copy");
                }
            }
            #endregion

            args.Add("-f");
            args.Add("hls");

            foreach (var c in config.hlsOptions.comand["output"])
            {
                foreach (var a in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                    args.Add(a);
            }

            #region -hls_segment_type
            args.Add("-hls_segment_type");

            if (context.HlsOptions.fmp4)
            {
                args.Add("fmp4");
            }
            else
            {
                args.Add("mpegts");

                foreach (var c in config.hlsOptions.comand["segment_mpegts"])
                {
                    foreach (var a in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                        args.Add(a);
                }
            }
            #endregion

            args.Add("-hls_time");
            args.Add(context.HlsOptions.segDur.ToString(CultureInfo.InvariantCulture));

            if (context.live)
            {
                args.Add("-hls_flags");
                args.Add("append_list+omit_endlist+delete_segments");
            }

            args.Add("-hls_list_size");
            args.Add(context.HlsOptions.winSize.ToString(CultureInfo.InvariantCulture));

            #region -start_number
            int? startNumber = context.startNumber;
            if (!startNumber.HasValue && context.HlsOptions.seek > 0)
            {
                int segDur = Math.Max(1, context.HlsOptions.segDur);
                startNumber = context.HlsOptions.seek / segDur;
            }

            if (startNumber.HasValue)
            {
                args.Add("-start_number");
                args.Add(startNumber.Value.ToString());
            }
            #endregion

            args.Add("-master_pl_name");
            args.Add("index.m3u8");

            if (context.HlsOptions.fmp4)
            {
                args.Add("-hls_fmp4_init_filename");
                args.Add("init.mp4");
            }
            else
            {
                args.Add("-hls_playlist_type");
                args.Add("vod");
            }

            args.Add("-hls_segment_filename");
            args.Add(context.HlsOptions.fmp4 ? "seg_%05d.m4s" : "seg_%05d.ts");

            args.Add("-y");
            args.Add("index.m3u8");
            #endregion

            InvkEvent.Transcoding(new EventTranscoding(args, startNumber, context));

            return process;
        }

        private async Task PumpStdErrAsync(TranscodingJob job)
        {
            try
            {
                while (!job.Process.StandardError.EndOfStream)
                {
                    var line = await job.Process.StandardError.ReadLineAsync();
                    if (line == null)
                        break;

                    job.AppendLog(line);
                }
            }
            catch { }
        }

        private async Task IdleWatchdogAsync(TranscodingJob job, TranscodingConf config)
        {
            var idle = TimeSpan.FromSeconds(Math.Max(180, config.idleTimeoutSec));
            var idle_live = TimeSpan.FromSeconds(Math.Max(20, config.idleTimeoutSec_live));

            try
            {
                while (!job.CancellationToken.IsCancellationRequested && !job.Process.HasExited)
                {
                    await Task.Delay(TimeSpan.FromSeconds(1), job.CancellationToken);

                    if (job.Context.live)
                    {
                        if (config.idleTimeoutSec_live == -1)
                            continue;

                        if (DateTime.UtcNow - job.LastAccessUtc > idle_live)
                        {
                            await StopJobAsync(job);
                            break;
                        }
                    }
                    else
                    {

                        if (config.idleTimeoutSec == -1)
                            continue;

                        if (DateTime.UtcNow - job.LastAccessUtc > idle)
                        {
                            await StopJobAsync(job);
                            break;
                        }
                    }
                }
            }
            catch (TaskCanceledException)
            {
            }
        }

        private void OnProcessExit(TranscodingJob job)
        {
            if (job.Context.live)
            {
                job.SignalExit();
                Cleanup(job);
            }
        }

        private bool TryParseToken(string streamId, out string id)
        {
            id = string.Empty;
            var parts = streamId.Split('.', 2);
            if (parts.Length != 2)
                return false;

            id = parts[0];
            if (id.Length != 32)
                return false;

            try
            {
                var padded = parts[1].PadRight(parts[1].Length + (4 - parts[1].Length % 4) % 4, '=');
                var hmac = Convert.FromBase64String(padded.Replace('-', '+').Replace('_', '/'));
                var expected = ComputeHmac(id);
                if (!CryptographicOperations.FixedTimeEquals(hmac, expected))
                    return false;
            }
            catch
            {
                return false;
            }

            return true;
        }

        private string BuildToken(string id)
        {
            var mac = ComputeHmac(id);
            var b64 = Convert.ToBase64String(mac).TrimEnd('=').Replace('+', '-').Replace('/', '_');
            return $"{id}.{b64}";
        }

        private byte[] ComputeHmac(string id)
        {
            using var hmac = new HMACSHA256(_hmacKey);
            return hmac.ComputeHash(Encoding.UTF8.GetBytes(id));
        }

        private static string SanitizeHeader(string value, string fallback = "")
        {
            if (string.IsNullOrWhiteSpace(value))
                return fallback;

            var clean = value.Replace("\r", string.Empty).Replace("\n", string.Empty);
            return string.IsNullOrWhiteSpace(clean) ? fallback : clean;
        }

        private void CleanupSegments()
        {
            if (Interlocked.Exchange(ref _segmentCleanupRunning, 1) == 1)
                return;

            try
            {
                if (!(AppInit.conf?.transcoding?.playlistOptions?.delete_segments ?? false))
                    return;

                foreach (var job in _jobs.Values)
                {
                    if (job.Context.live)
                        continue;

                    var lastIndex = job.LastSegmentIndex;
                    if (0 >= lastIndex)
                        continue;

                    try
                    {
                        if (!Directory.Exists(job.OutputDirectory))
                            continue;

                        foreach (var file in Directory.GetFiles(job.OutputDirectory, "seg_*"))
                        {
                            try
                            {
                                var name = Path.GetFileName(file);
                                var match = _segmentFileRegex.Match(name);
                                if (!match.Success)
                                    continue;

                                if (!int.TryParse(match.Groups[1].Value, out var index))
                                    continue;

                                if (index >= lastIndex - 1)
                                    continue;

                                File.Delete(file);
                            }
                            catch { }
                        }
                    }
                    catch { }
                }
            }
            catch { }
            finally
            {
                Interlocked.Exchange(ref _segmentCleanupRunning, 0);
            }
        }
    }
}

```

## File: Tracks/Engine/TranscodingJob.cs
```
using Shared.Models.AppConf;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;

namespace Tracks.Engine
{
    internal sealed class TranscodingJob : IDisposable
    {
        private const int MaxLogLines = 200;

        private readonly LinkedList<string> _log = new();
        private readonly object _logSync = new();
        private readonly CancellationTokenSource _cts = new();
        private int _lastSegmentIndex = -1;

        public TranscodingJob(string id, string streamId, string outputDirectory, Process process, TranscodingStartContext context)
        {
            Id = id;
            StreamId = streamId;
            OutputDirectory = outputDirectory;
            Process = process;
            Context = context;
            StartedUtc = DateTime.UtcNow;
            LastAccessUtc = StartedUtc;
        }

        public string Id { get; }

        public string StreamId { get; }

        public string OutputDirectory { get; }

        public Process Process { get; }

        public TranscodingStartContext Context { get; }

        public DateTime StartedUtc { get; }

        public DateTime LastAccessUtc { get; private set; }

        public int? ExitCode { get; private set; }

        public bool HasExited => Process.HasExited;

        public CancellationToken CancellationToken => _cts.Token;

        public void UpdateLastAccess() => LastAccessUtc = DateTime.UtcNow;

        public int LastSegmentIndex => Volatile.Read(ref _lastSegmentIndex);

        public void UpdateLastSegmentIndex(int segmentIndex)
        {
            if (segmentIndex < 0)
                return;

            while (true)
            {
                var current = Volatile.Read(ref _lastSegmentIndex);
                if (segmentIndex <= current)
                    return;

                if (Interlocked.CompareExchange(ref _lastSegmentIndex, segmentIndex, current) == current)
                    return;
            }
        }


        public void AppendLog(string line)
        {
            if (string.IsNullOrWhiteSpace(line))
                return;

            lock (_logSync)
            {
                foreach (var part in line.Split('\n'))
                {
                    string trimmed = part.TrimEnd('\r');
                    if (string.IsNullOrWhiteSpace(trimmed))
                        continue;

                    if (trimmed.Length > 2000)
                        trimmed = trimmed[..2000];

                    _log.AddLast(trimmed);
                    if (_log.Count > MaxLogLines)
                        _log.RemoveFirst();
                }
            }
        }

        public string[] SnapshotLog()
        {
            lock (_logSync)
                return _log.ToArray();
        }

        public void SignalExit()
        {
            if (Process.HasExited)
                ExitCode = Process.ExitCode;
        }

        public void StopBackground()
            => _cts.Cancel();

        public void Dispose()
        {
            try
            {
                StopBackground();
            }
            catch { }

            try
            {
                Process.Dispose();
            }
            catch { }
        }
    }
}

```

## File: Tracks/Engine/TranscodingModels.cs
```
using Shared.Models.AppConf;
using System.Collections.Generic;

namespace Tracks.Engine
{
    public sealed class TranscodingStartRequest
    {
        public string src { get; set; } = string.Empty;

        public TranscodingAudioOptions audio { get; set; }

        public TranscodingHlsOptions hls { get; set; }

        public Dictionary<string, string> headers { get; set; }

        public bool live { get; set; }

        public bool? subtitles { get; set; }
    }

    public enum TranscodingJobState
    {
        Running,
        Idle,
        Stopped
    }
}

```

## File: Shared/AppInit.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Newtonsoft.Json;
using Shared.Engine;
using Shared.Models;
using Shared.Models.AppConf;
using Shared.Models.Base;
using Shared.Models.Browser;
using Shared.Models.DLNA;
using Shared.Models.Merchant;
using Shared.Models.Module;
using Shared.Models.Online.Settings;
using Shared.Models.ServerProxy;
using Shared.Models.SISI.Base;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Threading;
using YamlDotNet.Serialization;

namespace Shared
{
    public class AppInit
    {
        #region static
        public static string rootPasswd;

        public static bool Win32NT => Environment.OSVersion.Platform == PlatformID.Win32NT;

        public static bool IsDefaultApnOrCors(string apn) => apn != null && Regex.IsMatch(apn, "(apn.monster|apn.watch|cfhttp.top|lampac.workers.dev)");

        static FileSystemWatcher fileWatcher;

        static AppInit()
        {
            updateConf();
            if (File.Exists("init.conf"))
                lastUpdateConf = File.GetLastWriteTime("init.conf");

            updateYamlConf();
            if (File.Exists("init.yaml") && File.GetLastWriteTime("init.yaml") > lastUpdateConf)
                lastUpdateConf = File.GetLastWriteTime("init.yaml");

            LoadModules();

            #region watcherInit
            if (conf.watcherInit == "system")
            {
                fileWatcher = new FileSystemWatcher
                {
                    Path = Directory.GetCurrentDirectory(),
                    Filter = "init.conf",
                    NotifyFilter = NotifyFilters.FileName | NotifyFilters.LastWrite,
                    EnableRaisingEvents = true
                };

                fileWatcher.Changed += async (s, e) =>
                {
                    fileWatcher.EnableRaisingEvents = false;

                    try
                    {
                        await Task.Delay(200);
                        updateConf();
                        updateYamlConf();
                    }
                    catch { }
                    finally
                    {
                        fileWatcher.EnableRaisingEvents = true;
                    }
                };
            }
            else
            {
                ThreadPool.QueueUserWorkItem(async _ =>
                {
                    while (true)
                    {
                        await Task.Delay(TimeSpan.FromSeconds(1));

                        try
                        {
                            if (File.Exists("init.conf"))
                            {
                                var lwtConf = File.GetLastWriteTime("init.conf");
                                var lwtYaml = File.GetLastWriteTime("init.yaml");

                                if (lwtConf > lastUpdateConf || lwtYaml > lastUpdateConf)
                                {
                                    updateConf();
                                    updateYamlConf();

                                    lastUpdateConf = lwtConf > lwtYaml ? lwtConf : lwtYaml;

                                    try
                                    {

                                        string init = JsonConvert.SerializeObject(conf, Formatting.Indented, new JsonSerializerSettings()
                                        {
                                            NullValueHandling = NullValueHandling.Ignore,
                                            DefaultValueHandling = DefaultValueHandling.Ignore
                                        });

                                        Directory.CreateDirectory("database/backup/init");
                                        File.WriteAllText($"database/backup/init/{DateTime.Now.ToString("dd-MM-yyyy.HH")}.conf", init);
                                    }
                                    catch { }
                                }
                            }
                        }
                        catch { }
                    }
                });
            }
            #endregion
        }
        #endregion

        public readonly string guid = Guid.NewGuid().ToString();

        #region conf
        static DateTime lastUpdateConf = default;

        public static AppInit conf = null;

        static void updateConf()
        {
            if (!File.Exists("init.conf"))
            {
                conf = new AppInit();
                return;
            }

            string initfile = File.ReadAllText("init.conf").Trim();
            initfile = Regex.Replace(initfile, "\"weblog\":([ \t]+)?(true|false)([ \t]+)?,", "", RegexOptions.IgnoreCase);

            if (!initfile.StartsWith("{"))
                initfile = "{" + initfile + "}";

            try
            {
                conf = JsonConvert.DeserializeObject<AppInit>(initfile, new JsonSerializerSettings
                {
                    Error = (se, ev) =>
                    {
                        ev.ErrorContext.Handled = true;
                        Console.WriteLine($"DeserializeObject Exception init.conf:\n{ev.ErrorContext.Error}\n\n");
                    }
                });
            }
            catch { }

            if (conf == null)
                conf = new AppInit();

            PosterApi.Initialization(conf.omdbapi_key, conf.posterApi, new ProxyLink());

            #region accounts
            if (conf.accsdb.accounts != null)
            {
                foreach (var u in conf.accsdb.accounts)
                {
                    if (conf.accsdb.findUser(u.Key) is AccsUser user)
                    {
                        if (u.Value > user.expires)
                            user.expires = u.Value;
                    }
                    else
                    {
                        conf.accsdb.users.Add(new AccsUser()
                        {
                            id = u.Key.ToLower().Trim(),
                            expires = u.Value
                        });
                    }
                }
            }
            #endregion

            #region users.txt
            if (File.Exists("merchant/users.txt"))
            {
                long utc = DateTime.UtcNow.ToFileTimeUtc();
                foreach (string line in File.ReadAllLines("merchant/users.txt"))
                {
                    if (string.IsNullOrWhiteSpace(line) && !line.Contains("@"))
                        continue;

                    var data = line.Split(',');
                    if (data.Length > 1)
                    {
                        if (long.TryParse(data[1], out long ex) && ex > utc)
                        {
                            try
                            {
                                DateTime e = DateTime.FromFileTimeUtc(ex);
                                string email = data[0].ToLower().Trim();

                                if (conf.accsdb.findUser(email) is AccsUser user)
                                {
                                    if (e > user.expires)
                                        user.expires = e;

                                    user.group = conf.Merchant.defaultGroup;
                                }
                                else
                                {
                                    conf.accsdb.users.Add(new AccsUser()
                                    {
                                        id = email,
                                        expires = e,
                                        group = conf.Merchant.defaultGroup
                                    });
                                }
                            }
                            catch { }
                        }
                    }
                }
            }
            #endregion

            try
            {
                File.WriteAllText("current.conf", JsonConvert.SerializeObject(conf, Formatting.Indented));
            }
            catch { }
        }

        static void updateYamlConf()
        {
            if (conf == null)
                return;

            try
            {
                if (File.Exists("init.yaml"))
                {
                    string yaml = File.ReadAllText("init.yaml");
                    if (!string.IsNullOrWhiteSpace(yaml))
                    {
                        var deserializer = new DeserializerBuilder().IgnoreUnmatchedProperties().Build();
                        var yamlObject = deserializer.Deserialize(new StringReader(yaml));
                        if (yamlObject != null)
                        {
                            string json = JsonConvert.SerializeObject(yamlObject);
                            JsonConvert.PopulateObject(json, conf, new JsonSerializerSettings
                            {
                                Error = (se, ev) =>
                                {
                                    ev.ErrorContext.Handled = true;
                                    Console.WriteLine($"DeserializeObject Exception init.yaml:\n{ev.ErrorContext.Error}\n\n");
                                }
                            });

                            try
                            {
                                File.WriteAllText("current.conf", JsonConvert.SerializeObject(conf, Formatting.Indented));
                            }
                            catch { }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"DeserializeObject Exception init.yaml:\n{ex}\n\n");
            }
        }
        #endregion

        #region Host
        public static string Host(HttpContext httpContext)
        {
            string scheme = string.IsNullOrEmpty(conf.listen.scheme) ? httpContext.Request.Scheme : conf.listen.scheme;
            if (httpContext.Request.Headers.TryGetValue("xscheme", out var xscheme) && !string.IsNullOrEmpty(xscheme))
                scheme = xscheme;

            if (!string.IsNullOrEmpty(conf.listen.host))
                return $"{scheme}://{conf.listen.host}";

            if (httpContext.Request.Headers.TryGetValue("xhost", out var xhost))
                return $"{scheme}://{Regex.Replace(xhost, "^https?://", "")}";

            return $"{scheme}://{httpContext.Request.Host.Value}";
        }
        #endregion

        #region modules
        public static List<RootModule> modules;

        public static void LoadModules()
        {
            if (modules != null)
                return;

            modules = null;

            if (File.Exists("module/manifest.json"))
            {
                var jss = new JsonSerializerSettings { Error = (se, ev) => 
                { 
                    ev.ErrorContext.Handled = true; 
                    Console.WriteLine("module/manifest.json - " + ev.ErrorContext.Error + "\n\n"); 
                }};

                var mods = JsonConvert.DeserializeObject<List<RootModule>>(File.ReadAllText("module/manifest.json"), jss);
                if (mods == null)
                    return;

                modules = new List<RootModule>();
                foreach (var mod in mods)
                {
                    if (!mod.enable || mod.dll == "Jackett.dll")
                        continue;

                    string path = File.Exists(mod.dll) ? mod.dll : $"{Environment.CurrentDirectory}/module/{mod.dll}";
                    if (File.Exists(path))
                    {
                        try
                        {
                            mod.assembly = Assembly.LoadFile(path);
                            mod.index = mod.index != 0 ? mod.index : (100 + modules.Count);
                            modules.Add(mod);
                        }
                        catch { }
                    }
                }
            }
        }
        #endregion


        #region server
        public ListenConf listen = new ListenConf() 
        {
            localhost = "127.0.0.1",
            ip = "any", port = 9118,
            compression = true,
            frontend = null // cloudflare|nginx
        };

        public bool multiaccess = false;

        public bool mikrotik = false;

        public string watcherInit = "cron";// system

        public string imagelibrary = "NetVips"; // NetVips|ImageMagick|none

        public bool pirate_store = true;

        public string apikey = null;

        public bool litejac = true;

        public bool filelog = false;

        public bool disableEng = false;

        public bool always_rjson = false;

        public string anticaptchakey;

        public string omdbapi_key;

        public string playerInner;

        public string defaultOn = "enable";

        public string corsehost { get; set; } = "https://cors.apn.monster";

        public CorseuConf —Åorseu { get; set; } = new CorseuConf();

        public MediaApiConf media { get; set; } = new MediaApiConf();

        public ApnConf apn { get; set; } = new ApnConf() { secure = "none" };

        public Dictionary<string, CmdConf> cmd = new Dictionary<string, CmdConf>();

        public PosterApiConf posterApi = new PosterApiConf() 
        {
            rsize = true, width = 210,
            bypass = "statichdrezka\\."
        };

        public KitConf kit = new KitConf() { cacheToSeconds = 20 };

        public SyncConf sync = new SyncConf();

        public HybridCacheConf cache = new HybridCacheConf() 
        {
            type = "file",  // mem|file|hybrid
            extend = -1     // seconds (hybrid)
        };

        public WafConf WAF = new WafConf();

        public WebLogConf weblog = new WebLogConf();

        public OpenStatConf openstat = new OpenStatConf();

        public RchConf rch = new RchConf() 
        { 
            enable = true,
            websoket = "nws" // signalr|nws
        };

        public SyncUserConf sync_user = new SyncUserConf() { enable = true, version = 2 };

        public StorageConf storage = new StorageConf() { enable = true, max_size = 7_000000, brotli = false, md5name = true };

        public GCConf GC { get; set; } = new GCConf() 
        {
            enable = true,
            RetainVM = false, //Concurrent = false,
            ConserveMemory = 9, HighMemoryPercent = 1
        };

        public PuppeteerConf chromium = new PuppeteerConf()
        {
            enable = true, Headless = true,
            Args = ["--disable-blink-features=AutomationControlled"], // , "--window-position=-2000,100"
            context = new KeepopenContext() { keepopen = true, keepalive = 20, min = 0, max = 4 }
        };

        public PuppeteerConf firefox = new PuppeteerConf()
        {
            enable = false, Headless = true,
            context = new KeepopenContext() { keepopen = true, keepalive = 20, min = 1, max = 2 }
        };

        public FfprobeSettings ffprobe = new FfprobeSettings() { enable = true };

        public TranscodingConf transcoding { get; set; } = new TranscodingConf()
        {
            tempRoot = Path.Combine("cache", "transcoding"),
            idleTimeoutSec = 60 * 5, idleTimeoutSec_live = 120,
            maxConcurrentJobs = 5
        };

        public CubConf cub { get; set; } = new CubConf()
        {
            enable = false, viewru = true,
            domain = CrypTo.DecodeBase64("Y3ViLnJlZA=="), scheme = "http",
            mirror = "mirror-kurwa.men",
            cache_api = 180, cache_img = 120,
        };

        public TmdbConf tmdb { get; set; } = new TmdbConf()
        {
            enable = true,
            httpversion = 2, DNS_TTL = 20,
            cache_api = 240, cache_img = 60, check_img = false,
            api_key = "4ef0d7355d9ffb5151e987764708ce96"
        };

        public ServerproxyConf serverproxy = new ServerproxyConf()
        {
            enable = true, verifyip = true,
            encrypt = true, encrypt_aes = true,
            buffering = new ServerproxyBufferingConf()
            {
                enable = true, 
                rent = 81920, // 80KB
                length = 390  // 80KB * 390 —è—á–µ–µ–∫ = ~30MB
            },
            image = new ServerproxyImageConf()
            {
                cache = true, 
                cache_rsize = true,
                cache_time = 60 // minute
            },
            maxlength_m3u = 5000000, // 5mb
            maxlength_ts = 40000000  // 40mb
        };

        public FileCacheConf fileCacheInactive = new FileCacheConf() 
        { 
            hls = 90, html = 5, torrent = 2880 // minute
        };

        public DLNASettings dlna = new DLNASettings() 
        { 
            enable = true, path = "dlna",
            uploadSpeed = 125000 * 10,
            autoupdatetrackers = true, intervalUpdateTrackers = 90, addTrackersToMagnet = true,
            mediaPattern = "^\\.(aac|flac|mpga|mpega|mp2|mp3|m4a|oga|ogg|opus|spx|opus|weba|wav|dif|dv|fli|mp4|mpeg|mpg|mpe|mpv|mkv|ts|m4s|m2ts|mts|ogv|webm|avi|qt|mov)$",
            cover = new CoverSettings() 
            {
                enable = true, preview = true, 
                timeout = 20, skipModificationTime = 60,
                priorityClass = System.Diagnostics.ProcessPriorityClass.Idle,
                extension = "(mp4|mkv|avi|mpg|mpe|mpv)",
                coverComand = "-n -ss 3:00 -i \"{file}\" -vf \"thumbnail=150,scale=400:-2\" -frames:v 1 \"{thumb}\"",
                // —Ñ—Ä—ç–º—Ä—ç–π—Ç -r   : –±–æ–ª—å—à–µ - –±–æ–ª—å—à–µ —Ñ–∞–π–ª , –ø–ª–∞–≤–Ω–µ–µ –¥–≤–∏–∂–µ–Ω–∏—è
                // –∫–∞—á–µ—Å—Ç–≤–æ -crf : –±–æ–ª—å—à–µ - –º–µ–Ω—å—à–µ —Ñ–∞–π–ª , –ø–æ—è–≤–ª—è—é—Ç—Å—è –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã
                previewComand = "-n -ss 00:03:00 -to 00:03:07 -i \"{file}\" -ss 00:04:37 -to 00:04:44 -i \"{file}\" -ss 00:06:41 -to 00:06:48 -i \"{file}\" -ss 00:09:20 -to 00:09:27 -i \"{file}\" -ss 00:12:45 -to 00:12:52 -i \"{file}\" -ss 00:17:09 -to 00:17:16 -i \"{file}\" -ss 00:22:50 -to 00:22:57 -i \"{file}\" -ss 00:29:51 -to 00:29:58 -i \"{file}\" -ss 00:39:23 -to 00:39:30 -i \"{file}\" -ss 00:51:44 -to 00:51:51 -i \"{file}\" -ss 01:07:45 -to 01:07:52 -i \"{file}\" -ss 01:20:33 -to 01:20:40 -i \"{file}\" -filter_complex \"[0:v]setpts=0.5*PTS,scale=-2:240[v0];[1:v]setpts=0.5*PTS,scale=-2:240[v1];[2:v]setpts=0.5*PTS,scale=-2:240[v2];[3:v]setpts=0.5*PTS,scale=-2:240[v3];[4:v]setpts=0.5*PTS,scale=-2:240[v4];[5:v]setpts=0.5*PTS,scale=-2:240[v5];[6:v]setpts=0.5*PTS,scale=-2:240[v6];[7:v]setpts=0.5*PTS,scale=-2:240[v7];[8:v]setpts=0.5*PTS,scale=-2:240[v8];[9:v]setpts=0.5*PTS,scale=-2:240[v9];[10:v]setpts=0.5*PTS,scale=-2:240[v10];[11:v]setpts=0.5*PTS,scale=-2:240[v11];[v0][v1][v2][v3][v4][v5][v6][v7][v8][v9][v10][v11]concat=n=12:v=1:a=0\" -an -r 20 -c:v libx264 -crf 28 -preset veryslow \"{preview}\""
            }
        };

        public WebConf LampaWeb = new WebConf()
        {
            autoupdate = true,
            intervalupdate = 90, // minute
            basetag = true, index = "lampa-main/index.html",
            git = "yumata/lampa",
            tree = "c2416bb9f719d1ef89725443ef0450e20f299f3b"
        };

        public OnlineConf online = new OnlineConf()
        {
            findkp = "all", checkOnlineSearch = true, 
            spider = true, spiderName = "Spider",
            component = "lampac", name = "Lampac", description = "–ü–ª–∞–≥–∏–Ω –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –æ–Ω–ª–∞–π–Ω —Å–µ—Ä–∏–∞–ª–æ–≤ –∏ —Ñ–∏–ª—å–º–æ–≤",
            version = true, btn_priority_forced = true, showquality = true,
            with_search = new List<string>() { "kinotochka", "kinobase", "kinopub", "lumex", "filmix", "filmixtv", "fxapi", "redheadsound", "animevost", "animego", "animedia", "animebesst", "anilibria", "aniliberty", "rezka", "rhsprem", "kodik", "remux", "animelib", "kinoukr", "rc/filmix", "rc/fxapi", "rc/rhs", "vcdn", "videocdn", "lumex", "collaps", "collaps-dash", "vdbmovies", "hdvb", "alloha", "veoveo", "rutubemovie", "vkmovie" }
        };

        public SisiConf sisi { get; set; } = new SisiConf()
        {
            NextHUB = true, spider = true, lgbt = true,
            component = "sisi", iconame = "", push_all = true,
            heightPicture = 240, rsize = true, rsize_disable = ["Chaturbate", "PornHub", "PornHubPremium", "HQporner", "Spankbang", "Porntrex", "Xnxx", "Porndig", "Youjizz", "Veporn", "Pornk"],
            bookmarks = new BookmarksConf() { saveimage = true, savepreview = true },
            history = new HistoryConf() { enable = true, days = 30 }
        };

        public AccsConf accsdb = new AccsConf() 
        { 
            authMesage = "–í–æ–π–¥–∏—Ç–µ –≤ –∞–∫–∫–∞—É–Ω—Ç - –Ω–∞—Å—Ç—Ä–æ–π–∫–∏, —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è",
            denyMesage = "–î–æ–±–∞–≤—å—Ç–µ {account_email} –≤ init.conf –∏–ª–∏ —á–µ—Ä–µ–∑ {host}/admin",
            denyGroupMesage = "–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —ç—Ç–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã",
            expiresMesage = "–í—Ä–µ–º—è –¥–æ—Å—Ç—É–ø–∞ –¥–ª—è {account_email} –∏—Å—Ç–µ–∫–ª–æ –≤ {expires}",
            maxip_hour = 15, maxrequest_hour = 500, maxlock_day = 3, blocked_hour = 36,
            shared_daytime = 366*10, // 10 years
        };

        public MerchantsModel Merchant = new MerchantsModel();

        public VastConf vast = new VastConf();

        public HashSet<Known> KnownProxies { get; set; } = new HashSet<Known>() 
        {
            new Known() { ip = "10.2.0.0", prefixLength = 16 },
            new Known() { ip = "192.168.0.0", prefixLength = 16 }
        };

        public bool real_ip_cf { get; set; }

        public ProxySettings proxy = new ProxySettings();

        public ProxySettings[] globalproxy = new ProxySettings[]
        {
            new ProxySettings()
            {
                pattern = "\\.onion",
                list = ["socks5://127.0.0.1:9050"]
            }
        };

        public IReadOnlyCollection<OverrideResponse> overrideResponse = new List<OverrideResponse>()
        {
            new OverrideResponse()
            {
                pattern = "/over/text",
                action = "html",
                type = "text/plain; charset=utf-8",
                val = "text"
            },
            new OverrideResponse()
            {
                pattern = "/over/online.js",
                action = "file",
                type = "application/javascript; charset=utf-8",
                val = "plugins/online.js"
            },
            new OverrideResponse()
            {
                pattern = "/over/gogoole",
                action = "redirect",
                val = "https://www.google.com/"
            }
        };
        #endregion

        #region SISI
        public SisiSettings BongaCams { get; set; } = new SisiSettings("BongaCams", "kwwsv=22hh1erqjdfdpv1frp")
        {
            spider = false,
            headers = HeadersModel.Init(
                ("referer", "{host}/"),
                ("x-requested-with", "XMLHttpRequest")
            ).ToDictionary()
        };

        public SisiSettings Runetki { get; set; } = new SisiSettings("Runetki", "kwwsv=22uxv1uxqhwnl81frp")
        {
            spider = false,
            headers = HeadersModel.Init(
                ("referer", "{host}/"),
                ("x-requested-with", "XMLHttpRequest")
            ).ToDictionary()
        };

        public SisiSettings Chaturbate { get; set; } = new SisiSettings("Chaturbate", "kwwsv=22fkdwxuedwh1frp")
        {
            spider = false,
        };

        public SisiSettings Ebalovo { get; set; } = new SisiSettings("Ebalovo", "kwwsv=22zzz1hedoryr1sur")
        {
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5")
            ).ToDictionary(),
            headers_stream = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("sec-fetch-dest", "video"),
                ("sec-fetch-mode", "no-cors"),
                ("sec-fetch-site", "same-origin")
            ).ToDictionary()
        };

        public SisiSettings Eporner { get; set; } = new SisiSettings("Eporner", "kwwsv=22zzz1hsruqhu1frp", streamproxy: true);

        public SisiSettings HQporner { get; set; } = new SisiSettings("HQporner", "kwwsv=22p1ktsruqhu1frp")
        {
            geostreamproxy = ["ALL"],
            headers = HeadersModel.Init("referer", "{host}").ToDictionary()
        };

        public SisiSettings Porntrex { get; set; } = new SisiSettings("Porntrex", "kwwsv=22zzz1sruqwuh{1frp", streamproxy: true)
        {
            headers_stream = HeadersModel.Init(
                ("referer", "{host}/")
            ).ToDictionary()
        };

        public SisiSettings Spankbang { get; set; } = new SisiSettings("Spankbang", "kwwsv=22ux1vsdqnedqj1frp");

        public SisiSettings Xhamster { get; set; } = new SisiSettings("Xhamster", "kwwsv=22ux1{kdpvwhu1frp")
        {
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/plain, */*; q=0.0"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "cross-site")
            ).ToDictionary()
        };

        public SisiSettings Xnxx { get; set; } = new SisiSettings("Xnxx", "kwwsv=22zzz1{q{{1frp");

        public SisiSettings Tizam { get; set; } = new SisiSettings("Tizam", "kwwsv=22lq1wl}dp1lqir", streamproxy: true);

        public SisiSettings Xvideos { get; set; } = new SisiSettings("Xvideos", "kwwsv=22zzz1{ylghrv1frp");

        public SisiSettings XvideosRED { get; set; } = new SisiSettings("XvideosRED", "kwwsv=22zzz1{ylghrv1uhg", enable: false);

        public SisiSettings PornHub { get; set; } = new SisiSettings("PornHub", "kwwsv=22uw1sruqkxe1frp", streamproxy: true)
        {
            headers = HeadersModel.Init(
                Http.defaultFullHeaders,
                ("sec-ch-ua-mobile", "?0"),
                ("sec-ch-ua-platform", "\"Windows\""),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-site", "same-origin"),
                ("sec-fetch-mode", "navigate"),
                ("cookie", "platform=pc; accessAgeDisclaimerPH=1")
            ).ToDictionary()
        };

        public SisiSettings PornHubPremium { get; set; } = new SisiSettings("PornHubPremium", "kwwsv=22uw1sruqkxesuhplxp1frp", streamproxy: true, enable: false)
        {
            headers = HeadersModel.Init(
                ("sec-ch-ua-mobile", "?0"),
                ("sec-ch-ua-platform", "\"Windows\""),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-site", "none"),
                ("sec-fetch-user", "?1"),
                ("upgrade-insecure-requests", "1")
            ).ToDictionary()
        };
        #endregion

        #region Online
        /// <summary>
        /// https://iptv.online/ru/dealers/api
        /// </summary>
        public OnlinesSettings IptvOnline { get; set; } = new OnlinesSettings("IptvOnline", "https://iptv.online", enable: false);

        /// <summary>
        /// aHR0cHM6Ly92ZW92ZW8uaW8=
        /// </summary>
        public OnlinesSettings VeoVeo { get; set; } = new OnlinesSettings("VeoVeo", "kwwsv=22dsl1uvwsujdslsw1frp");

        public RezkaSettings Rezka { get; set; } = new RezkaSettings("Rezka", "kwwsv=22kguh}nd1ph", true) 
        {
            ajax = true, reserve = true,
            hls = true, scheme = "http",
            headers = Http.defaultHeaders
        };

        public RezkaSettings RezkaPrem { get; set; } = new RezkaSettings("RezkaPrem", null) 
        { 
            enable = false,
            reserve = true, hls = true, scheme = "http",
            headers = Http.defaultHeaders
        };

        public CollapsSettings Collaps { get; set; } = new CollapsSettings("Collaps", "kwwsv=22dsl1ox{hpeg1zv", streamproxy: true, two: false)
        {
            two = true,
            apihost = "https://api.bhcesh.me",
            token = "eedefb541aeba871dcfc756e6b31c02e",
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("Origin", "https://kinokrad.my")
            ).ToDictionary(),
            headers_stream = HeadersModel.Init(Http.defaultFullHeaders,
                ("Origin", "https://kinokrad.my"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "cross-site"),
                ("accept", "*/*")
            ).ToDictionary()
        };

        public OnlinesSettings Ashdi { get; set; } = new OnlinesSettings("Ashdi", "kwwsv=22edvh1dvkgl1yls") 
        { 
            geo_hide = ["RU", "BY"] 
        };

        public OnlinesSettings Kinoukr { get; set; } = new OnlinesSettings("Kinoukr", "kwwsv=22nlqrxnu1frp")
        {
            geo_hide = ["RU", "BY"],
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("cookie", "legit_user=1;"),
                ("origin", "{host}"),
                ("referer", "{host}/"),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-mode", "navigate"),
                ("sec-fetch-site", "same-origin"),
                ("sec-fetch-user", "?1"),
                ("upgrade-insecure-requests", "1")
            ).ToDictionary()
        };

        public OnlinesSettings Eneyida { get; set; } = new OnlinesSettings("Eneyida", "kwwsv=22hqh|lgd1wy");

        public OnlinesSettings Kinotochka { get; set; } = new OnlinesSettings("Kinotochka", "kwwsv=22nlqryleh1yls", streamproxy: true);

        public OnlinesSettings RutubeMovie { get; set; } = new OnlinesSettings("RutubeMovie", "kwwsv=22uxwxeh1ux", streamproxy: true);

        public OnlinesSettings VkMovie { get; set; } = new OnlinesSettings("VkMovie", "kwwsv=22dsl1ynylghr1ux", streamproxy: true)
        {
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("origin", "encrypt:kwwsv=22ynylghr1ux"),
                ("referer", "encrypt:kwwsv=22ynylghr1ux2")
            ).ToDictionary()
        };

        public OnlinesSettings Plvideo { get; set; } = new OnlinesSettings("Plvideo", "kwwsv=22dsl1j41soylghr1ux", streamproxy: true, enable: false);

        public OnlinesSettings CDNvideohub { get; set; } = new OnlinesSettings("CDNvideohub", "kwwsv=22sodsl1fgqylghrkxe1frp", streamproxy: true)
        {
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("referer", "encrypt:kwwsv=22kgnlqr1sxe2"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "cross-site")
            ).ToDictionary()
        };

        public OnlinesSettings Redheadsound { get; set; } = new OnlinesSettings("Redheadsound", "kwwsv=22uhgkhdgvrxqg1vwxglr", enable: false)
        {
            headers = HeadersModel.Init("referer", "{host}/").ToDictionary()
        };

        public OnlinesSettings iRemux { get; set; } = new OnlinesSettings("iRemux", "kwwsv=22phjdreodnr1frp", streamproxy: true) { corseu = true };

        public PidTorSettings PidTor { get; set; } = new PidTorSettings() 
        { 
            enable = true, redapi = "http://redapi.cfhttp.top", 
            min_sid = 15, emptyVoice = true 
        };

        /// <summary>
        /// http://filmixapp.cyou
        /// http://filmixapp.vip
        /// http://fxapp.biz
        /// </summary>
        public FilmixSettings Filmix { get; set; } = new FilmixSettings("Filmix", "http://filmixapp.cyou")
        {
            reserve = true,
            headers = HeadersModel.Init(
                ("Accept-Encoding", "gzip")
            ).ToDictionary()
        };

        public FilmixSettings FilmixTV { get; set; } = new FilmixSettings("FilmixTV", "kwwsv=22dsl1ilopl{1wy", enable: false)
        {
            pro = true,
            headers = HeadersModel.Init(
                ("user-agent", "Mozilla/5.0 (SMART-TV; LINUX; Tizen 6.0) AppleWebKit/537.36 (KHTML, like Gecko) 76.0.3809.146/6.0 TV Safari/537.36")
            ).ToDictionary()
        };

        public FilmixSettings FilmixPartner { get; set; } = new FilmixSettings("FilmixPartner", "kwws=22819418914;2sduwqhubdsl", enable: false);

        /// <summary>
        /// aHR0cHM6Ly9nby56ZXQtZmxpeC5vbmxpbmU=
        /// aHR0cHM6Ly9nby56ZXRmbGl4LW9ubGluZS5sb2w=
        /// </summary>
        public ZetflixSettings Zetflix { get; set; } = new ZetflixSettings("Zetflix", "kwwsv=22jr1}hw0iol{1rqolqh", enable: false)
        {
            browser_keepopen = true,
            geostreamproxy = ["ALL"],
            hls = true
        };

        /// <summary>
        /// aHR0cHM6Ly9raW5vcGxheTIuc2l0ZS8=
        /// a2lub2dvLm1lZGlh
        /// aHR0cHM6Ly9maWxtLTIwMjQub3JnLw==
        /// </summary>
        public OnlinesSettings VideoDB { get; set; } = new OnlinesSettings("VideoDB", "kwwsv=22nlqrjr1phgld", "kwwsv=2263ei6:<31reuxw1vkrz", streamproxy: true)
        {
            imitationHuman = true,
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("sec-fetch-storage-access", "active"),
                ("upgrade-insecure-requests", "1")
            ).ToDictionary(),
            headers_stream = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "*/*"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("origin", "{host}"),
                ("referer", "{host}/"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "same-site")
            ).ToDictionary()
        };

        /// <summary>
        /// aHR0cHM6Ly9jb2xkZmlsbS5pbmsv
        /// </summary>
        public OnlinesSettings CDNmovies { get; set; } = new OnlinesSettings("CDNmovies", "kwwsv=22frogfgq1{|}")
        {
            headers = HeadersModel.Init(
                ("DNT", "1"),
                ("Upgrade-Insecure-Requests", "1")
            ).ToDictionary()
        };

        public OnlinesSettings VDBmovies { get; set; } = new OnlinesSettings("VDBmovies", "kwwsv=22fgqprylhv0vwuhdp1rqolqh")
        {
            geostreamproxy = ["ALL"],
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("sec-fetch-storage-access", "active"),
                ("upgrade-insecure-requests", "1")
            ).ToDictionary()
        };

        public OnlinesSettings FanCDN { get; set; } = new OnlinesSettings("FanCDN", "kwwsv=22p|idqvhuldo1qhw", streamproxy: true)
        {
            enable = false,
            imitationHuman = true,
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("sec-fetch-storage-access", "active"),
                ("upgrade-insecure-requests", "1")
            ).ToDictionary(),
            headers_stream = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "*/*"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("origin", "encrypt:kwwsv=22idqfgq1qhw"),
                ("referer", "encrypt:kwwsv=22idqfgq1qhw2"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "same-site")
            ).ToDictionary()
        };

        public KinobaseSettings Kinobase { get; set; } = new KinobaseSettings("Kinobase", "kwwsv=22nlqredvh1ruj", true, hdr: true) 
        { 
            geostreamproxy = ["ALL"]
        };

        /// <summary>
        /// aHR0cHM6Ly91YWtpbm9nby5lYw==
        /// aHR0cHM6Ly91YWtpbm9nby5vbmxpbmU=
        /// </summary>
        public OnlinesSettings Kinogo { get; set; } = new OnlinesSettings("Kinogo", "kwwsv=22nlqrjr1ox{xu|", enable: false)
        {
            streamproxy = true
        };

        /// <summary>
        /// –ü–æ–ª—É—á–µ–Ω–∏–µ —É—á–µ—Ç–Ω–æ–π –∑–∞–ø–∏—Å–∏
        /// 
        /// tg: @monk_in_a_hat
        /// email: helpdesk@lumex.ink
        /// </summary>
        public LumexSettings VideoCDN { get; set; } = new LumexSettings("VideoCDN", "https://api.lumex.space", "API-—Ç–æ–∫–µ–Ω", "https://portal.lumex.host", "ID –∫–ª–∏–µ–Ω—Ç")
        {
            enable = false,
            log = false,
            verifyip = true, // —Å—Å—ã–ª–∫–∏ –ø—Ä–∏–≤—è–∑–∞–Ω—ã –∫ ip –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            scheme = "http",
            geostreamproxy = ["UA"],
            hls = false, // false - mp4 / true - m3u8
            disable_protection = false, // true - –æ—Ç–∫–ª—é—á–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ –ø–∞—Ä—Å–µ—Ä
            disable_ads = false, // –æ—Ç–∫–ª—é—á–∏—Ç—å —Ä–µ–∫–ª–∞–º—É
            vast = new VastConf() { msg = "–†–µ–∫–ª–∞–º–∞ –æ—Ç VideoCDN" }
        };

        public LumexSettings Lumex { get; set; } = new LumexSettings("Lumex", "kwwsv=22sruwdo1oxph{1krvw", null, "lumex.space", "tl6h28Hn1rL5")
        {
            enable = true,
            hls = true, scheme = "http",
            priorityBrowser = "http",
            geostreamproxy = ["ALL"]
        };

        public VokinoSettings VoKino { get; set; } = new VokinoSettings("VoKino", "http://api.vokino.org", streamproxy: true);

        public IframeVideoSettings IframeVideo { get; set; } = new IframeVideoSettings("IframeVideo", "kwwsv=22liudph1ylghr", "kwwsv=22ylghriudph1vsdfh", enable: false);

        /// <summary>
        /// aHR0cHM6Ly92aWQxNzMwODAxMzcwLmZvdHBybzEzNWFsdG8uY29tL2FwaS9pZGtwP2twX2lkPTEzOTI1NTAmZD1raW5vZ28uaW5j
        /// </summary>
        public OnlinesSettings HDVB { get; set; } = new OnlinesSettings("HDVB", "kwwsv=22dslye1frp", token: "8h5ih7f:3edig<d:747f7i4:3hh4e4<5")
        {
            headers = Http.defaultFullHeaders
        };

        /// <summary>
        /// aHR0cHM6Ly92aWJpeC5vcmcvYXBpL2V4dGVybmFsL2RvY3VtZW50YXRpb24=
        /// </summary>
        public OnlinesSettings Vibix { get; set; } = new OnlinesSettings("Vibix", "kwwsv=22ylel{1ruj", streamproxy: true, enable: false)
        {
            headers = Http.defaultFullHeaders
        };

        /// <summary>
        /// aHR0cHM6Ly92aWRlb3NlZWQudHYvZmFxLnBocA==
        /// </summary>
        public OnlinesSettings Videoseed { get; set; } = new OnlinesSettings("Videoseed", "kwwsv=22ylghrvhhg1wy", streamproxy: true, enable: false)
        {
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("sec-fetch-storage-access", "active"),
                ("upgrade-insecure-requests", "1")
            ).ToDictionary(),
            headers_stream = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "*/*"),
                ("referer", "encrypt:kwwsv=22wy040nlqrvhuldo1qhw2"),
                ("sec-fetch-dest", "video"),
                ("sec-fetch-mode", "no-cors"),
                ("sec-fetch-site", "cross-site")
            ).ToDictionary()
        };

        /// <summary>
        /// https://api.srvkp.com - —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π 
        /// https://cdn32.lol/api- apk
        /// https://cdn4t.store/api - apk
        /// https://kpapp.link/api - smart tv
        /// https://api.service-kp.com - —Å—Ç–∞—Ä—ã–π 
        /// </summary>
        public KinoPubSettings KinoPub { get; set; } = new KinoPubSettings("KinoPub", "https://api.srvkp.com")
        {
            // hls | hls4 | mp4
            filetype = "hls",
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-mode", "navigate"),
                ("sec-fetch-site", "none"),
                ("sec-fetch-user", "?1"),
                ("upgrade-insecure-requests", "1")
            ).ToDictionary()
        };

        public AllohaSettings Alloha { get; set; } = new AllohaSettings("Alloha", "kwwsv=22dsl1dsexjdoo1ruj", "kwwsv=22wruvr0dv1vwordgl1olyh", "", "", true, true) 
        { 
            reserve = true 
        };

        public AllohaSettings Mirage { get; set; } = new AllohaSettings("Mirage", "kwwsv=22dsl1dsexjdoo1ruj", "kwwsv=22txdguloolrq0dv1doodunqrz1rqolqh", "6892d506bbdd5790e0ca047ff39462", "", true, true)
        {
            enable = true,
            streamproxy = true,
            headers = Http.defaultFullHeaders
        };

        public OnlinesSettings GetsTV { get; set; } = new OnlinesSettings("GetsTV", "https://getstv.com", enable: false) 
        {
            headers = HeadersModel.Init(
                ("user-agent", "Mozilla/5.0 (Web0S; Linux/SmartTV) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.34 Safari/537.36 WebAppManager")
            ).ToDictionary()
        };
        #endregion

        #region ENG
        /// <summary>
        /// aHR0cHM6Ly93d3cuaHlkcmFmbGl4LnZpcA==
        /// </summary>
        public OnlinesSettings Hydraflix { get; set; } = new OnlinesSettings("Hydraflix", "kwwsv=22ylgidvw1sur", streamproxy: true) 
        {
            priorityBrowser = "scraping"
        };

        /// <summary>
        /// aHR0cHM6Ly92aWRzcmMueHl6
        /// aHR0cHM6Ly92aWRzcmMucHJv
        /// aHR0cHM6Ly92aWRzcmMudG8=
        /// </summary>
        public OnlinesSettings Vidsrc { get; set; } = new OnlinesSettings("Vidsrc", "kwwsv=22ylgvuf1ff", streamproxy: true);

        public OnlinesSettings MovPI { get; set; } = new OnlinesSettings("MovPI", "kwwsv=22prylhvdsl1foxe", streamproxy: true);

        /// <summary>
        /// aHR0cHM6Ly9kYXkyc29hcC54eXov
        /// </summary>
        public OnlinesSettings VidLink { get; set; } = new OnlinesSettings("VidLink", "kwwsv=22ylgolqn1sur", streamproxy: true);

        public OnlinesSettings Videasy { get; set; } = new OnlinesSettings("Videasy", "kwwsv=22sod|hu1ylghdv|1qhw", streamproxy: true);

        /// <summary>
        /// aHR0cHM6Ly9zbWFzaHlzdHJlYW0ueHl6
        /// </summary>
        public OnlinesSettings Smashystream { get; set; } = new OnlinesSettings("Smashystream", "kwwsv=22sod|hu1vpdvk|vwuhdp1frp", streamproxy: true);

        public OnlinesSettings Autoembed { get; set; } = new OnlinesSettings("Autoembed", "kwwsv=22sod|hu1dxwrhpehg1ff", streamproxy: true);

        /// <summary>
        /// Omega
        /// </summary>
        public OnlinesSettings Playembed { get; set; } = new OnlinesSettings("Playembed", "https://vidora.su", streamproxy: true, enable: false);


        /// <summary>
        /// EmbedSu
        /// </summary>
        public OnlinesSettings Twoembed { get; set; } = new OnlinesSettings("Twoembed", "https://embed.su", streamproxy: true, enable: false)
        {
            headers_stream = HeadersModel.Init(
                ("accept", "*/*"),
                ("accept-language", "en-US,en;q=0.5"),
                ("referer", "{host}/"),
                ("origin", "{host}"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "cross-site")
            ).ToDictionary()
        };

        public OnlinesSettings Rgshows { get; set; } = new OnlinesSettings("Rgshows", "kwwsv=22dsl1ujvkrzv1ph", streamproxy: true, enable: false)
        {
            headers = HeadersModel.Init(
                ("accept", "*/*"),
                ("user-agent", "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1"),
                ("accept-language", "en-US,en;q=0.5"),
                ("referer", "encrypt:kwwsv=22zzz1ujvkrzv1ph2"),
                ("origin", "encrypt:kwwsv=22zzz1ujvkrzv1ph"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "same-site")
            ).ToDictionary(),
            headers_stream = HeadersModel.Init(
                ("accept", "*/*"),
                ("user-agent", "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1"),
                ("accept-language", "en-US,en;q=0.5"),
                ("referer", "encrypt:kwwsv=22zzz1ujvkrzv1ph2"),
                ("origin", "encrypt:kwwsv=22zzz1ujvkrzv1ph"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "cross-site")
            ).ToDictionary()
        };
        #endregion

        #region Anime
        public KodikSettings Kodik { get; set; } = new KodikSettings("Kodik", "kwwsv=22nrglndsl1frp", "kwwsv=22nrgln1lqir", "74gg<8i;7f54:4<e3<g9f:44;556:d58", "", true)
        {
            auto_proxy = true,      // –ø—Ä–æ–∫—Å–∏ UA –≤ api 
            cdn_is_working = true,  // –ø—Ä–æ–∫—Å–∏ UA –≤ –æ–±—ã—á–Ω–æ–º 
            //geostreamproxy = ["UA"],
            headers = HeadersModel.Init(
                ("referer", "encrypt:kwwsv=22dqlole1ph2")
            ).ToDictionary()
        };

        /// <summary>
        /// move to AniLiberty
        /// </summary>
        public OnlinesSettings AnilibriaOnline { get; set; } = new OnlinesSettings("AnilibriaOnline", "kwwsv=22dsl1dqloleuld1wy", enable: false);

        public OnlinesSettings AniLiberty { get; set; } = new OnlinesSettings("AniLiberty", "kwwsv=22dsl1dqloleuld1dss");

        /// <summary>
        /// aHR0cHM6Ly9hbmlsaWIubWU=
        /// </summary>
        public OnlinesSettings AnimeLib { get; set; } = new OnlinesSettings("AnimeLib", "kwwsv=22dsl1fgqolev1ruj", streamproxy: true)
        {
            enable = false,
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("origin", "encrypt:kwwsv=22dqlphole1ruj"),
                ("referer", "encrypt:kwwsv=22dqlphole1ruj2"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "cross-site")
            ).ToDictionary(),
            headers_stream = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "*/*"),
                ("accept-encoding", "identity;q=1, *;q=0"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("origin", "encrypt:kwwsv=22dqlphole1ruj"),
                ("referer", "encrypt:kwwsv=22dqlphole1ruj2"),
                ("sec-fetch-dest", "video"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "same-site")
            ).ToDictionary()
        };

        public OnlinesSettings AniMedia { get; set; } = new OnlinesSettings("AniMedia", "kwwsv=22dphgld1rqolqh");

        public OnlinesSettings Animevost { get; set; } = new OnlinesSettings("Animevost", "kwwsv=22dqlphyrvw1ruj", streamproxy: true);

        public OnlinesSettings MoonAnime { get; set; } = new OnlinesSettings("MoonAnime", "kwwsv=22dsl1prrqdqlph1duw", token: ";98iHI0H5h4Ef05fd7640h9D4830:;3GIG0:6:F9E") { geo_hide = new string[] { "RU", "BY" } };

        public OnlinesSettings Animebesst { get; set; } = new OnlinesSettings("Animebesst", "kwwsv=22dqlph41ehvw");

        public OnlinesSettings AnimeGo { get; set; } = new OnlinesSettings("AnimeGo", "kwwsv=22dqlphjr1ph", streamproxy: true, enable: false)
        {
            headers_stream = HeadersModel.Init(
                ("origin", "https://aniboom.one"),
                ("referer", "https://aniboom.one/")
            ).ToDictionary()
        };
        #endregion
    }
}

```

## File: Shared/BaseSisiController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Base;
using Shared.Models.Events;
using Shared.Models.Module;
using Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using System.Net;
using System.Reflection;

namespace Shared
{
    public class BaseSisiController : BaseController
    {
        public BaseSettings init { get; private set; }

        #region IsBadInitialization
        async public ValueTask<bool> IsBadInitialization(BaseSettings init, bool? rch = null)
        {
            #region module initialization
            if (AppInit.modules != null)
            {
                var args = new InitializationModel(init, rch);

                foreach (RootModule mod in AppInit.modules.Where(i => i.initialization != null))
                {
                    try
                    {
                        if (mod.assembly.GetType(mod.NamespacePath(mod.initialization)) is Type t)
                        {
                            if (t.GetMethod("Invoke") is MethodInfo m2)
                            {
                                badInitMsg = (ActionResult)m2.Invoke(null, [HttpContext, memoryCache, requestInfo, host, args]);
                                if (badInitMsg != null)
                                    return true;
                            }

                            if (t.GetMethod("InvokeAsync") is MethodInfo m)
                            {
                                badInitMsg = await (Task<ActionResult>)m.Invoke(null, [HttpContext, memoryCache, requestInfo, host, args]);
                                if (badInitMsg != null)
                                    return true;
                            }
                        }
                    }
                    catch { }
                }
            }
            #endregion

            badInitMsg = await InvkEvent.BadInitialization(new EventBadInitialization(init, rch, requestInfo, host, HttpContext.Request, HttpContext, hybridCache));
            if (badInitMsg != null)
                return true;

            this.init = init;

            if (!init.enable || init.rip)
            {
                badInitMsg = OnError("disable");
                return true;
            }

            if (NoAccessGroup(init, out string error_msg))
            {
                badInitMsg = OnError(error_msg, false);
                return true;
            }

            var overridehost = await IsOverridehost(init);
            if (overridehost != null)
            {
                badInitMsg = overridehost;
                return true;
            }

            return IsCacheError(init);
        }
        #endregion

        #region OnError
        public JsonResult OnError(string msg, ProxyManager proxyManager, bool refresh_proxy = true, bool rcache = true)
        {
            if (refresh_proxy && !init.rhub)
                proxyManager?.Refresh();

            return OnError(msg, rcache: rcache);
        }

        public JsonResult OnError(string msg, bool rcache = true)
        {
            var model = new OnErrorResult(msg);

            if (AppInit.conf.multiaccess && rcache && !init.rhub)
                memoryCache.Set(ResponseCache.ErrorKey(HttpContext), model, DateTime.Now.AddSeconds(15));

            HttpContext.Response.StatusCode = 500;
            return Json(model);
        }
        #endregion

        #region OnResult
        public JsonResult OnResult(IList<PlaylistItem> playlists, BaseSettings conf, IList<MenuItem> menu, WebProxy proxy = null, int total_pages = 0)
        {
            if (playlists == null || playlists.Count == 0)
                return OnError("playlists", false);

            var result = new OnListResult(playlists.Count, total_pages, menu);

            for (int i = 0; i < playlists.Count; i++)
            {
                var pl = playlists[i];
                result.list[i] = new OnResultPlaylistItem
                {
                    name = pl.name,
                    video = HostStreamProxy(conf, pl.video, proxy: proxy),
                    model = pl.model,
                    picture = HostImgProxy(pl.picture, plugin: conf?.plugin),
                    preview = pl.preview,
                    time = pl.time,
                    json = pl.json,
                    related = pl.related,
                    quality = pl.quality,
                    qualitys = pl.qualitys,
                    bookmark = pl.bookmark,
                    hide = pl.hide,
                    myarg = pl.myarg
                };
            }

            return new JsonResult(result);
        }

        public JsonResult OnResult(IList<PlaylistItem> playlists, IList<MenuItem> menu, List<HeadersModel> headers = null, int total_pages = 0, string plugin = null)
        {
            if (playlists == null || playlists.Count == 0)
                return OnError("playlists", false);

            var result = new OnListResult(playlists.Count, total_pages, menu);

            for (int i = 0; i < playlists.Count; i++)
            {
                var pl = playlists[i];
                result.list[i] = new OnResultPlaylistItem
                {
                    name = pl.name,
                    video = pl.video.StartsWith("http") ? pl.video : $"{AppInit.Host(HttpContext)}/{pl.video}",
                    model = pl.model,
                    picture = HostImgProxy(pl.picture, plugin: plugin, headers: headers),
                    preview = pl.preview,
                    time = pl.time,
                    json = pl.json,
                    related = pl.related,
                    quality = pl.quality,
                    qualitys = pl.qualitys,
                    bookmark = pl.bookmark,
                    hide = pl.hide,
                    myarg = pl.myarg
                };
            }

            return new JsonResult(result);
        }

        public JsonResult OnResult(Dictionary<string, string> stream_links, BaseSettings init, WebProxy proxy, List<HeadersModel> headers_stream = null)
        {
            return OnResult(new StreamItem() { qualitys = stream_links }, init, proxy, headers_stream: headers_stream);
        }

        public JsonResult OnResult(StreamItem stream_links, BaseSettings init, WebProxy proxy, List<HeadersModel> headers_img = null, List<HeadersModel> headers_stream = null)
        {
            var result = new OnStreamResult(stream_links?.recomends?.Count ?? 0);

            if (!init.streamproxy && (init.geostreamproxy == null || init.geostreamproxy.Length == 0))
            {
                if (init.qualitys_proxy)
                    result.qualitys_proxy = stream_links.qualitys.ToDictionary(k => k.Key, v => HostStreamProxy(init, v.Value, proxy: proxy, headers: headers_stream, force_streamproxy: true));
            }

            if (stream_links.recomends != null && stream_links.recomends.Count > 0)
            {
                for (int i = 0; i < stream_links.recomends.Count; i++)
                {
                    var pl = stream_links.recomends[i];
                    result.recomends[i] = new OnResultPlaylistItem
                    {
                        name = pl.name,
                        video = pl.video.StartsWith("http") ? pl.video : $"{AppInit.Host(HttpContext)}/{pl.video}",
                        picture = HostImgProxy(pl.picture, height: 110, plugin: init?.plugin, headers: headers_img),
                        json = pl.json
                    };
                }
            }

            result.qualitys = stream_links.qualitys.ToDictionary(k => k.Key, v => HostStreamProxy(init, v.Value, proxy: proxy, headers: headers_stream));
            result.headers_stream = init.streamproxy ? null : (headers_stream?.ToDictionary() ?? init.headers_stream);

            return new JsonResult(result);
        }
        #endregion

        #region IsRhubFallback
        public bool IsRhubFallback(BaseSettings init)
        {
            if (init.rhub && init.rhub_fallback)
            {
                init.rhub = false;
                return true;
            }

            return false;
        }
        #endregion

        public Task<ActionResult> InvkSemaphore(string key, Func<ValueTask<ActionResult>> func) => InvkSemaphore(init, key, func);
    }
}

```

## File: Shared/Startup.cs
```
Ôªøusing Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Caching.Memory;

namespace Shared
{
    public class Startup
    {
        public static bool IsShutdown { get; set; }

        public static IServiceProvider ApplicationServices { get; private set; }

        public static IMemoryCache memoryCache { get; private set; }

        public static void Configure(IApplicationBuilder app, IMemoryCache mem)
        {
            ApplicationServices = app.ApplicationServices;
            memoryCache = mem;
        }
    }
}

```

## File: Shared/EventListener.cs
```
using Microsoft.AspNetCore.Mvc;
using Shared.Models;
using Shared.Models.Events;
using Shared.Models.JacRed;

namespace Shared
{
    public class EventListener
    {
        public static Action<EventLoadKit> LoadKitInit;

        public static Action<EventLoadKit> LoadKit;

        public static Func<EventProxyApiCreateHttpRequest, Task> ProxyApiCreateHttpRequest;

        public static Func<EventBadInitialization, Task<ActionResult>> BadInitialization;

        public static Func<EventHostStreamProxy, string> HostStreamProxy;

        public static Func<EventMyLocalIp, Task<string>> MyLocalIp;

        public static Func<EventControllerHttpHeaders, List<HeadersModel>> HttpHeaders;

        public static Func<bool, EventMiddleware, Task<bool>> Middleware;

        public static Func<string, EventAppReplace, string> AppReplace;

        public static Action<TorrentDetails> RedApiAddTorrents;

        public static Action<EventTranscoding> TranscodingCreateProcess;

        public static Action<EventHttpHandler> HttpHandler;

        public static Action<EventHttpHeaders> HttpRequestHeaders;

        public static Func<EventHttpResponse, Task> HttpResponse;

        public static Func<EventExternalids, (string imdb_id, string kinopoisk_id)> Externalids;

        public static Func<EventStreamQuality, (bool? next, string link)> StreamQuality;

        public static Func<EventStreamQualityFirts, (string link, string quality)?> StreamQualityFirts;

        public static Func<string, EventHybridCache, (DateTimeOffset ex, string value)> HybridCache;


        public static Action<EventRchRegistry> RchRegistry;

        public static Action<string> RchDisconnected;


        public static Action<EventNwsConnected> NwsConnected;

        public static Action<EventNwsMessage> NwsMessage;

        public static Action<string> NwsDisconnected;
    }
}

```

## File: Shared/BaseOnlineController.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Base;
using Shared.Models.Events;
using Shared.Models.Module;
using System.Reflection;

namespace Shared
{
    public class BaseOnlineController : BaseController
    {
        #region IsBadInitialization
        async public ValueTask<bool> IsBadInitialization(BaseSettings init, bool? rch = null)
        {
            #region module initialization
            if (AppInit.modules != null)
            {
                var args = new InitializationModel(init, rch);

                foreach (RootModule mod in AppInit.modules.Where(i => i.initialization != null))
                {
                    try
                    {
                        if (mod.assembly.GetType(mod.NamespacePath(mod.initialization)) is Type t)
                        {
                            if (t.GetMethod("Invoke") is MethodInfo m2)
                            {
                                badInitMsg = (ActionResult)m2.Invoke(null, [HttpContext, memoryCache, requestInfo, host, args]);
                                if (badInitMsg != null)
                                    return true;
                            }

                            if (t.GetMethod("InvokeAsync") is MethodInfo m)
                            {
                                badInitMsg = await (Task<ActionResult>)m.Invoke(null, [HttpContext, memoryCache, requestInfo, host, args]);
                                if (badInitMsg != null)
                                    return true;
                            }
                        }
                    }
                    catch { }
                }
            }
            #endregion

            badInitMsg = await InvkEvent.BadInitialization(new EventBadInitialization(init, rch, requestInfo, host, HttpContext.Request, HttpContext, hybridCache));
            if (badInitMsg != null)
                return true;

            if (!init.enable || init.rip)
            {
                badInitMsg = OnError("disable");
                return true;
            }

            if (NoAccessGroup(init, out string error_msg))
            {
                badInitMsg = new JsonResult(new { accsdb = true, msg = error_msg });
                return true;
            }

            var overridehost = await IsOverridehost(init);
            if (overridehost != null)
            {
                badInitMsg = overridehost;
                return true;
            }

            if (rch != null)
            {
                if ((bool)rch)
                {
                    if (init.rhub && !AppInit.conf.rch.enable)
                    {
                        badInitMsg = ShowError(RchClient.ErrorMsg);
                        return true;
                    }
                }
                else
                {
                    if (init.rhub)
                    {
                        badInitMsg = ShowError(RchClient.ErrorMsg);
                        return true;
                    }
                }
            }

            return IsCacheError(init);
        }
        #endregion


        #region MaybeInHls
        public bool MaybeInHls(bool hls, BaseSettings init)
        {
            if (!string.IsNullOrEmpty(init.apn?.host) && AppInit.IsDefaultApnOrCors(init.apn?.host))
                return false;

            if (init.apnstream && AppInit.IsDefaultApnOrCors(AppInit.conf.apn?.host))
                return false;

            return hls;
        }
        #endregion

        #region OnLog
        public void OnLog(string msg)
        {
            if (AppInit.conf.weblog.enable)
                Http.onlog?.Invoke(null, msg + "\n");
        }
        #endregion

        #region OnError
        public ActionResult OnError(ProxyManager proxyManager, bool refresh_proxy = true, string weblog = null) => OnError(string.Empty, proxyManager, refresh_proxy, weblog: weblog);

        public ActionResult OnError(string msg, ProxyManager? proxyManager, bool refresh_proxy = true, string weblog = null)
        {
            if (string.IsNullOrEmpty(msg) || !msg.StartsWith("{\"rch\""))
            {
                if (refresh_proxy)
                    proxyManager?.Refresh();
            }

            return OnError(msg, weblog: weblog);
        }

        public ActionResult OnError() => OnError(string.Empty);

        public ActionResult OnError(string msg, bool gbcache = true, string weblog = null)
        {
            if (!string.IsNullOrEmpty(msg))
            {
                if (msg.StartsWith("{\"rch\""))
                    return Content(msg);

                string log = $"{HttpContext.Request.Path.Value}\n{msg}";
                if (!string.IsNullOrEmpty(weblog))
                    log += $"\n\n\n===================\n\n{weblog}";

                Http.onlog?.Invoke(null, log);
            }

            if (AppInit.conf.multiaccess && gbcache)
                memoryCache.Set(ResponseCache.ErrorKey(HttpContext), msg ?? string.Empty, DateTime.Now.AddSeconds(20));

            HttpContext.Response.StatusCode = 500;
            return Content(msg ?? string.Empty, "text/html; charset=utf-8");
        }
        #endregion

        #region OnResult
        public ActionResult OnResult(CacheResult<string> cache, bool gbcache = true)
        {
            if (!cache.IsSuccess)
                return OnError(cache.ErrorMsg, gbcache: gbcache);

            return Content(cache.Value, "text/html; charset=utf-8");
        }

        public ActionResult OnResult<T>(CacheResult<T> cache, Func<string> html, bool origsource = false, bool gbcache = true)
        {
            if (!cache.IsSuccess)
                return OnError(cache.ErrorMsg, gbcache: gbcache);

            if (origsource && cache.Value != null)
                return Json(cache.Value);

            return ContentTo(html.Invoke());
        }
        #endregion

        public ActionResult ShowError(string msg) => Json(new { accsdb = true, msg });

        public string ShowErrorString(string msg) => System.Text.Json.JsonSerializer.Serialize(new { accsdb = true, msg });

        #region IsRhubFallback
        public bool IsRhubFallback<T>(CacheResult<T> cache, BaseSettings init)
        {
            if (cache.IsSuccess)
                return false;

            if (cache.ErrorMsg != null && cache.ErrorMsg.StartsWith("{\"rch\""))
                return false;

            if (cache.Value == null && init.rhub && init.rhub_fallback)
            {
                init.rhub = false;
                return true;
            }

            return false;
        }
        #endregion
    }
}

```

## File: Shared/InvkEvent.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.CodeAnalysis.Scripting;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Events;
using System.Collections.ObjectModel;
using System.Net;
using System.Net.Http;
using System.Security.Cryptography;
using System.Text.Json;
using System.Threading;
using YamlDotNet.Serialization;

namespace Shared
{
    public static class InvkEvent
    {
        #region static
        static InvkEvent()
        {
            updateConf();

            var eventsDir = Path.Combine(AppContext.BaseDirectory, "events");
            var lastWriteTimes = new Dictionary<string, DateTime>();

            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞—Ç
            foreach (var file in Directory.Exists(eventsDir) ? Directory.GetFiles(eventsDir, "*.yaml") : Array.Empty<string>())
                lastWriteTimes[file] = File.GetLastWriteTimeUtc(file);

            ThreadPool.QueueUserWorkItem(async _ =>
            {
                while (true)
                {
                    await Task.Delay(TimeSpan.FromSeconds(1));

                    if (!Directory.Exists(eventsDir))
                        continue;

                    bool changed = false;
                    var files = Directory.GetFiles(eventsDir, "*.yaml");

                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–æ–≤—ã—Ö –∏ –∏–∑–º–µ–Ω—ë–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
                    foreach (var file in files)
                    {
                        var writeTime = File.GetLastWriteTimeUtc(file);
                        if (!lastWriteTimes.TryGetValue(file, out var lastTime) || writeTime != lastTime)
                        {
                            changed = true;
                            lastWriteTimes[file] = writeTime;
                        }
                    }

                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–¥–∞–ª—ë–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
                    foreach (var file in lastWriteTimes.Keys.ToList())
                    {
                        if (!files.Contains(file))
                        {
                            changed = true;
                            lastWriteTimes.Remove(file);
                        }
                    }

                    if (changed)
                        updateConf();
                }
            });
        }
        #endregion

        #region conf
        public static EventsModel conf = new EventsModel();

        static void updateConf()
        {
            var eventsDir = Path.Combine(AppContext.BaseDirectory, "events");
            if (!Directory.Exists(eventsDir))
                return;

            var deserializer = new DeserializerBuilder().Build();
            var serializer = new SerializerBuilder().Build();

            // –ò—Ç–æ–≥–æ–≤—ã–π —Å–ª–æ–≤–∞—Ä—å –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤
            var merged = new Dictionary<object, object>();

            foreach (string file in Directory.GetFiles(eventsDir, "*.yaml"))
            {
                try
                {
                    if (Path.GetFileName(file) is "example.yaml" or "interceptors.yaml")
                        continue;

                    var yaml = File.ReadAllText(file);
                    var dict = deserializer.Deserialize<Dictionary<object, object>>(yaml);

                    foreach (var property in dict)
                    {
                        if (!merged.ContainsKey(property.Key))
                        {
                            merged[property.Key] = property.Value;
                            continue;
                        }

                        if (property.Value is IDictionary<object, object> sourceDict &&
                            merged[property.Key] is IDictionary<object, object> targetDict)
                        {
                            foreach (var item in sourceDict)
                                targetDict[item.Key] = item.Value;
                        }
                        else
                        {
                            merged[property.Key] = property.Value;
                        }
                    }
                }
                catch (Exception ex) { Console.WriteLine(ex); }
            }

            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ–±—ä–µ–¥–∏–Ω—ë–Ω–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å –æ–±—Ä–∞—Ç–Ω–æ –≤ YAML, –∑–∞—Ç–µ–º –¥–µ—Å–µ—Ä–∏–∞–ª–∏–∑—É–µ–º –≤ EventsModel
            var yamlResult = serializer.Serialize(merged);
            conf = deserializer.Deserialize<EventsModel>(yamlResult);
        }
        #endregion

        #region FileOrCode
        static string FileOrCode(string _val)
        {
            if (_val.EndsWith(".cs"))
                return FileCache.ReadAllText(Path.Combine("events", _val));

            return _val;
        }
        #endregion


        #region Invoke<T>
        static T Invoke<T>(string cs, object model, ScriptOptions options = null)
        {
            try
            {
                if (cs != null)
                    return CSharpEval.Execute<T>(FileOrCode(cs), model, options);
            }
            catch { }

            return default;
        }
        #endregion

        #region InvokeAsync<T>
        static Task<T> InvokeAsync<T>(string cs, object model, ScriptOptions options = null)
        {
            try
            {
                if (cs != null)
                    return CSharpEval.ExecuteAsync<T>(FileOrCode(cs), model, options);
            }
            catch { }

            return Task.FromResult(default(T));
        }
        #endregion

        #region Invoke
        static void Invoke(string cs, object model, ScriptOptions options = null)
        {
            try
            {
                if (cs != null)
                    CSharpEval.Execute(FileOrCode(cs), model, options);
            }
            catch { }
        }
        #endregion

        #region InvokeAsync
        static Task InvokeAsync(string cs, object model, ScriptOptions options = null)
        {
            try
            {
                if (cs != null)
                    return CSharpEval.ExecuteAsync(FileOrCode(cs), model, options);
            }
            catch { }

            return Task.CompletedTask;
        }
        #endregion


        #region LoadKitInit
        public static void LoadKitInit(EventLoadKit model)
        {
            EventListener.LoadKitInit?.Invoke(model);

            if (conf?.LoadKitInit == null)
                return;

            Invoke(conf?.LoadKitInit, model, ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Models.Base")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO"));
        }
        #endregion

        #region LoadKit
        public static void LoadKit(EventLoadKit model)
        {
            EventListener.LoadKit?.Invoke(model);

            if (conf?.LoadKit == null)
                return;

            Invoke(conf?.LoadKit, model, ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Models.Base")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO"));
        }
        #endregion

        #region ProxyApi
        async public static Task ProxyApi(object model)
        {
            string code = null;

            if (model is EventProxyApiCreateHttpRequest httpRequestModel)
            {
                code = conf?.ProxyApi?.CreateHttpRequest;

                if (EventListener.ProxyApiCreateHttpRequest != null)
                    await EventListener.ProxyApiCreateHttpRequest.Invoke(httpRequestModel);
            }

            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(typeof(HttpRequest).Assembly).AddImports("Microsoft.AspNetCore.Http")
                .AddReferences(typeof(Task).Assembly).AddImports("System.Threading.Tasks")
                .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine")
                .AddReferences(typeof(HttpRequestMessage).Assembly).AddImports("System.Net.Http")
                .AddReferences(typeof(System.Net.Cookie).Assembly).AddImports("System.Net")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO");

            await InvokeAsync(code, model, option);
        }
        #endregion

        #region BadInitialization
        public static Task<ActionResult> BadInitialization(EventBadInitialization model)
        {
            if (conf?.Controller?.BadInitialization == null)
            {
                if (EventListener.BadInitialization != null)
                    return EventListener.BadInitialization.Invoke(model);

                return Task.FromResult(default(ActionResult));
            }

            var option = ScriptOptions.Default
                .AddReferences(typeof(ActionResult).Assembly).AddImports("Microsoft.AspNetCore.Mvc")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Models.Base").AddImports("Shared.Engine")
                .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO");

            return InvokeAsync<ActionResult>(conf?.Controller?.BadInitialization, model, option);
        }
        #endregion

        #region HostStreamProxy
        public static string HostStreamProxy(EventHostStreamProxy model)
        {
            if (conf?.Controller?.HostStreamProxy == null)
                return EventListener.HostStreamProxy?.Invoke(model);

            var option = ScriptOptions.Default
                .AddReferences(typeof(HttpContext).Assembly).AddImports("Microsoft.AspNetCore.Http")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Engine").AddImports("Shared.Models.Base").AddImports("Shared.Models")
                .AddReferences(typeof(WebProxy).Assembly).AddImports("System.Net")
                .AddReferences(typeof(MD5).Assembly).AddImports("System.Security.Cryptography")
                .AddImports("System.Collections.Generic");

            return Invoke<string>(conf.Controller.HostStreamProxy, model, option);
        }
        #endregion

        #region MyLocalIp
        public static Task<string> MyLocalIp(EventMyLocalIp model)
        {
            if (string.IsNullOrEmpty(conf?.Controller?.MyLocalIp))
            {
                if (EventListener.MyLocalIp != null)
                    return EventListener.MyLocalIp.Invoke(model);

                return Task.FromResult(default(string));
            }

            var option = ScriptOptions.Default
                .AddReferences(typeof(HttpContext).Assembly).AddImports("Microsoft.AspNetCore.Http")
                .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Engine").AddImports("Shared.Models.Base")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO");

            return InvokeAsync<string>(conf.Controller.MyLocalIp, model, option);
        }
        #endregion

        #region HttpHeaders
        public static List<HeadersModel> HttpHeaders(EventControllerHttpHeaders model)
        {
            if (string.IsNullOrEmpty(conf?.Controller?.HttpHeaders))
                return EventListener.HttpHeaders?.Invoke(model);

            var option = ScriptOptions.Default
                .AddReferences(typeof(HttpContext).Assembly).AddImports("Microsoft.AspNetCore.Http")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Models.Base").AddImports("Shared.Models")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO")
                .AddImports("System.Collections.Generic");

            return Invoke<List<HeadersModel>>(conf.Controller.HttpHeaders, model, option);
        }
        #endregion

        #region Middleware
        public static Task<bool> Middleware(bool first, EventMiddleware model)
        {
            if ((first ? conf?.Middleware?.first : conf?.Middleware?.end) == null)
            {
                if (EventListener.Middleware != null)
                    return EventListener.Middleware.Invoke(first, model);

                return Task.FromResult(default(bool));
            }

            var option = ScriptOptions.Default
                .AddReferences(typeof(HttpContext).Assembly).AddImports("Microsoft.AspNetCore.Http")
                .AddReferences(typeof(Task).Assembly).AddImports("System.Threading.Tasks")
                .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine")
                .AddReferences(typeof(HttpRequestMessage).Assembly).AddImports("System.Net.Http")
                .AddReferences(typeof(System.Net.Cookie).Assembly).AddImports("System.Net")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO");

            return InvokeAsync<bool>(first ? conf?.Middleware?.first : conf?.Middleware?.end, model, option);
        }
        #endregion

        #region AppReplace
        public static string AppReplace(string e, EventAppReplace model)
        {
            string code = null;

            switch (e)
            {
                case "online":
                    code = conf?.Controller?.AppReplace?.online?.eval;
                    break;

                case "sisi":
                    code = conf?.Controller?.AppReplace?.sisi?.eval;
                    break;

                case "appjs":
                    code = conf?.Controller?.AppReplace?.appjs?.eval;
                    break;

                case "appcss":
                    code = conf?.Controller?.AppReplace?.appcss?.eval;
                    break;
            }

            if (string.IsNullOrEmpty(code))
                return EventListener.AppReplace?.Invoke(e, model);

            return Invoke<string>(code, model, ScriptOptions.Default.AddReferences(typeof(File).Assembly).AddImports("System.IO"));
        }
        #endregion

        #region Http
        public static void Http(object model)
        {
            string code = null;
            var modelType = model.GetType();

            if (modelType == typeof(EventHttpHandler))
            {
                code = conf?.Http?.Handler;
                EventListener.HttpHandler?.Invoke((EventHttpHandler)model);
            }

            else if (modelType == typeof(EventHttpHeaders))
            {
                code = conf?.Http?.Headers;
                EventListener.HttpRequestHeaders?.Invoke((EventHttpHeaders)model);
            }

            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(typeof(WebProxy).Assembly).AddImports("System.Net")
                .AddReferences(typeof(HttpClientHandler).Assembly).AddImports("System.Net.Http")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO");

            Invoke(code, model, option);
        }

        public static Task HttpAsync(object model)
        {
            string code = null;
            var modelType = model.GetType();

            if (modelType == typeof(EventHttpResponse))
            {
                code = conf?.Http?.Response;

                if (string.IsNullOrEmpty(code) && EventListener.HttpResponse != null)
                    return EventListener.HttpResponse.Invoke((EventHttpResponse)model);
            }

            if (string.IsNullOrEmpty(code))
                return Task.CompletedTask;

            var option = ScriptOptions.Default
                .AddReferences(typeof(WebProxy).Assembly).AddImports("System.Net")
                .AddReferences(typeof(HttpClientHandler).Assembly).AddImports("System.Net.Http");

            if (modelType == typeof(EventHttpResponse))
            {
                option.AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                      .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine")
                      .AddReferences(typeof(File).Assembly).AddImports("System.IO");
            }

            return InvokeAsync(code, model, option);
        }
        #endregion

        #region RedApi
        public static bool RedApi(string e, object model)
        {
            string code = null;

            switch (e)
            {
                case "addtorrent":
                    code = conf?.RedApi?.AddTorrents;
                    break;
            }

            return Invoke<bool>(code, model);
        }
        #endregion

        #region Externalids
        public static void Externalids(string id, ref string imdb_id, ref string kinopoisk_id, int serial)
        {
            (string imdb_id, string kinopoisk_id) result = default;

            var md = new EventExternalids(id, imdb_id, kinopoisk_id, serial);

            if (EventListener.Externalids != null)
                result = EventListener.Externalids.Invoke(md);

            if (!string.IsNullOrEmpty(conf?.Controller?.Externalids))
                result = Invoke<(string imdb_id, string kinopoisk_id)>(conf.Controller.Externalids, md);

            if (result == default || (result.imdb_id == null && result.kinopoisk_id == null))
                return;

            imdb_id = result.imdb_id;
            kinopoisk_id = result.kinopoisk_id;
        }
        #endregion

        #region StreamQualityTpl
        public static (bool? next, string link) StreamQuality(EventStreamQuality model)
        {
            if (string.IsNullOrEmpty(conf?.StreamQualityTpl))
                return EventListener.StreamQuality?.Invoke(model) ?? default;

            var option = ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Models.Events").AddImports("Shared.Models.Templates");

            return Invoke<(bool? next, string link)>(conf.StreamQualityTpl, model, option);
        }

        public static (string link, string quality)? StreamQualityFirts(EventStreamQualityFirts model)
        {
            if (string.IsNullOrEmpty(conf?.StreamQualityFirts))
                return EventListener.StreamQualityFirts?.Invoke(model);

            var option = ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Models.Events").AddImports("Shared.Models.Templates");

            return Invoke<(string link, string quality)?>(conf.StreamQualityFirts, model, option);
        }
        #endregion

        #region Transcoding
        public static void Transcoding(EventTranscoding model)
        {
            EventListener.TranscodingCreateProcess?.Invoke(model);

            var code = conf?.Transcoding?.CreateProcess;
            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(typeof(Collection<string>).Assembly).AddImports("System.Collections.ObjectModel")
                .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine").AddImports("Shared.Models.AppConf");

            Invoke(code, model, option);
        }
        #endregion

        #region Rch
        public static void RchRegistry(EventRchRegistry model)
        {
            EventListener.RchRegistry?.Invoke(model);

            var code = conf?.Rch?.Registry;
            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                .AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine");

            Invoke(code, model, option);
        }

        public static void RchDisconnected(EventRchDisconnected model)
        {
            EventListener.RchDisconnected?.Invoke(model.connectionId);

            var code = conf?.Rch?.Disconnected;
            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                .AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine");

            Invoke(code, model, option);
        }
        #endregion

        #region Nws
        public static void NwsConnected(EventNwsConnected model)
        {
            EventListener.NwsConnected?.Invoke(model);

            var code = conf?.Nws?.Connected;
            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(typeof(CancellationToken).Assembly).AddImports("System.Threading")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine");

            Invoke(code, model, option);
        }

        public static void NwsMessage(EventNwsMessage model)
        {
            EventListener.NwsMessage?.Invoke(model);

            var code = conf?.Nws?.Message;
            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(typeof(JsonElement).Assembly).AddImports("System.Text.Json")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine");

            Invoke(code, model, option);
        }

        public static void NwsDisconnected(EventNwsDisconnected model)
        {
            EventListener.NwsDisconnected?.Invoke(model.connectionId);

            var code = conf?.Nws?.Disconnected;
            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine");

            Invoke(code, model, option);
        }
        #endregion

        #region HybridCache
        public static (DateTimeOffset ex, string value) HybridCache(string e, string key, string value, DateTimeOffset ex)
        {
            string code = null;

            var model = new EventHybridCache(key, value, ex);

            switch (e)
            {
                case "read":
                    code = conf?.HybridCache?.Read;
                    break;

                case "write":
                    code = conf?.HybridCache?.Write;
                    break;
            }

            if (string.IsNullOrEmpty(code))
                return EventListener.HybridCache?.Invoke(e, model) ?? default;

            var option = ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Engine")
                .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO");

            return Invoke<(DateTimeOffset ex, string value)>(code, model, option);
        }
        #endregion

        public static void PidTor(EventPidTor model) => Invoke(conf?.PidTor, model);
    }
}

```

## File: Shared/Extensions.cs
```
Ôªøusing Shared.Models;

public static class Extensions
{
    public static Dictionary<string, string> ToDictionary(this IEnumerable<HeadersModel> headers)
    {
        if (headers == null)
            return null;

        var result = new Dictionary<string, string>();
        foreach (var h in headers)
            result.TryAdd(h.name, h.val);

        return result;
    }
}
```

## File: Shared/GlobalUsings.cs
```
Ôªøglobal using System;
global using System.Threading.Tasks;
global using System.Collections.Generic;
global using System.IO;
global using System.Linq;
```

## File: Shared/BaseController.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Engine;
using Shared.Models;
using Shared.Models.AppConf;
using Shared.Models.Base;
using Shared.Models.Events;
using Shared.Models.Online.Settings;
using Shared.Models.SISI.OnResult;
using System.Collections.Concurrent;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Web;
using IO = System.IO;

namespace Shared
{
    public class BaseController : Controller, IDisposable
    {
        IServiceScope serviceScope;

        public static string appversion => "149";

        public static string minorversion => "38";

        public HybridCache hybridCache { get; private set; }

        public IMemoryCache memoryCache { get; private set; }

        public RequestModel requestInfo => HttpContext.Features.Get<RequestModel>();

        public string host => AppInit.Host(HttpContext);

        protected static readonly ConcurrentDictionary<string, SemaphoreSlim> _semaphoreLocks = new();

        public ActionResult badInitMsg { get; set; }

        public BaseController()
        {
            hybridCache = new HybridCache();

            serviceScope = Startup.ApplicationServices.CreateScope();
            var scopeServiceProvider = serviceScope.ServiceProvider;
            memoryCache = scopeServiceProvider.GetService<IMemoryCache>();
        }

        #region mylocalip
        static string lastMyIp = null;

        async public ValueTask<string> mylocalip()
        {
            string key = "BaseController:mylocalip";
            if (!memoryCache.TryGetValue(key, out string userIp))
            {
                userIp = await InvkEvent.MyLocalIp(new EventMyLocalIp(requestInfo, HttpContext.Request, HttpContext, hybridCache));

                if (string.IsNullOrEmpty(userIp))
                {
                    var myip = await Http.Get<JObject>("https://api.ipify.org/?format=json");
                    if (myip == null || string.IsNullOrEmpty(myip.Value<string>("ip")))
                        return lastMyIp;

                    userIp = myip.Value<string>("ip");
                    lastMyIp = userIp;
                }

                memoryCache.Set(key, userIp, DateTime.Now.AddMinutes(5));
            }

            return userIp;
        }
        #endregion

        #region httpHeaders
        public List<HeadersModel> httpHeaders(BaseSettings init, List<HeadersModel> _startHeaders = null)
        {
            var headers = HeadersModel.Init(_startHeaders);
            if (init.headers == null)
                return headers;

            return httpHeaders(init.host, HeadersModel.Join(HeadersModel.Init(init.headers), headers));
        }

        public List<HeadersModel> httpHeaders(string site, Dictionary<string, string> headers)
        {
            return httpHeaders(site, HeadersModel.Init(headers));
        }

        public List<HeadersModel> httpHeaders(string site, List<HeadersModel> _headers)
        {
            if (_headers == null || _headers.Count == 0)
                return _headers;

            var headers = new List<HeadersModel>(_headers.Count);

            string ip = requestInfo.IP;
            string account_email = HttpContext.Request.Query["account_email"].ToString()?.ToLower().Trim() ?? string.Empty;

            foreach (var h in _headers)
            {
                if (string.IsNullOrEmpty(h.val) || string.IsNullOrEmpty(h.name))
                    continue;

                var bulder = new StringBuilder(h.val)
                   .Replace("{account_email}", account_email)
                   .Replace("{ip}", ip)
                   .Replace("{host}", site);

                string val = bulder.ToString();

                if (val.StartsWith("encrypt:"))
                {
                    string encrypt = Regex.Match(val, "^encrypt:([^\n\r]+)").Groups[1].Value;
                    val = new OnlinesSettings(null, encrypt).host;
                }

                if (val.Contains("{arg:"))
                {
                    foreach (Match m in Regex.Matches(val, "\\{arg:([^\\}]+)\\}"))
                    {
                        string _a = Regex.Match(HttpContext.Request.QueryString.Value, $"&{m.Groups[1].Value}=([^&]+)").Groups[1].Value;
                        val = val.Replace(m.Groups[0].Value, _a);
                    }
                }

                if (val.Contains("{head:"))
                {
                    foreach (Match m in Regex.Matches(val, "\\{head:([^\\}]+)\\}"))
                    {
                        if (HttpContext.Request.Headers.TryGetValue(m.Groups[1].Value, out var _h))
                        {
                            val = val.Replace(m.Groups[0].Value, string.Join(" ", _h.ToString()));
                        }
                        else
                        {
                            val = val.Replace(m.Groups[0].Value, string.Empty);
                        }

                        string _a = Regex.Match(HttpContext.Request.QueryString.Value, $"&{m.Groups[1].Value}=([^&]+)").Groups[1].Value;
                        val = val.Replace(m.Groups[0].Value, _a);
                    }
                }

                if (headers.FirstOrDefault(i => i.name == h.name) == null)
                    headers.Add(new HeadersModel(h.name, val));
            }

            var eventHeaders = InvkEvent.HttpHeaders(new EventControllerHttpHeaders(site, headers, requestInfo, HttpContext.Request, HttpContext));
            if (eventHeaders != null)
                headers = eventHeaders;

            return headers;
        }
        #endregion

        #region HostImgProxy
        public string HostImgProxy(string uri, int height = 0, List<HeadersModel> headers = null, string plugin = null)
        {
            if (!AppInit.conf.sisi.rsize || string.IsNullOrWhiteSpace(uri)) 
                return uri;

            var init = AppInit.conf.sisi;
            int width = init.widthPicture;
            height = height > 0 ? height : init.heightPicture;

            string goEncryptUri(string _uri)
            {
                string encrypt_uri = ProxyLink.Encrypt(_uri, requestInfo.IP, headers, verifyip: false, ex: DateTime.Now.AddMinutes(20));
                if (AppInit.conf.accsdb.enable && !AppInit.conf.serverproxy.encrypt)
                    encrypt_uri = AccsDbInvk.Args(encrypt_uri, HttpContext);

                return encrypt_uri;
            }

            if (plugin != null && init.proxyimg_disable != null && init.proxyimg_disable.Contains(plugin))
                return uri;

            if (width == 0 && height == 0 || plugin != null && init.rsize_disable != null && init.rsize_disable.Contains(plugin))
            {
                if (!string.IsNullOrEmpty(init.bypass_host))
                {
                    string sheme = uri.StartsWith("https:") ? "https" : "http";
                    string bypass_host = init.bypass_host.Replace("{sheme}", sheme).Replace("{uri}", Regex.Replace(uri, "^https?://", ""));

                    if (bypass_host.Contains("{encrypt_uri}"))
                        bypass_host = bypass_host.Replace("{encrypt_uri}", goEncryptUri(uri));

                    return bypass_host;
                }

                return $"{host}/proxyimg/{goEncryptUri(uri)}";
            }

            if (!string.IsNullOrEmpty(init.rsize_host))
            {
                string sheme = uri.StartsWith("https:") ? "https" : "http";
                string rsize_host = init.rsize_host.Replace("{width}", width.ToString()).Replace("{height}", height.ToString())
                                                   .Replace("{sheme}", sheme).Replace("{uri}", Regex.Replace(uri, "^https?://", ""));

                if (rsize_host.Contains("{encrypt_uri}"))
                    rsize_host = rsize_host.Replace("{encrypt_uri}", goEncryptUri(uri));

                return rsize_host;
            }

            return $"{host}/proxyimg:{width}:{height}/{goEncryptUri(uri)}";
        }
        #endregion

        #region HostStreamProxy
        public string HostStreamProxy(BaseSettings conf, string uri, List<HeadersModel> headers = null, WebProxy proxy = null, bool force_streamproxy = false)
        {
            if (!AppInit.conf.serverproxy.enable || string.IsNullOrEmpty(uri) || conf == null)
                return uri?.Split(" ")?[0]?.Trim();

            string _eventUri = InvkEvent.HostStreamProxy(new EventHostStreamProxy(conf, uri, headers, proxy, requestInfo, HttpContext, hybridCache));
            if (_eventUri != null)
                return _eventUri;

            if (conf.rhub && !conf.rhub_streamproxy)
                return uri.Split(" ")[0].Trim();

            bool streamproxy = conf.streamproxy || conf.useproxystream || force_streamproxy;
            if (!streamproxy && conf.geostreamproxy != null && conf.geostreamproxy.Length > 0)
            {
                string country = requestInfo.Country;
                if (!string.IsNullOrEmpty(country) && country.Length == 2)
                {
                    if (conf.geostreamproxy.Contains("ALL") || conf.geostreamproxy.Contains(country))
                        streamproxy = true;
                }
            }

            if (streamproxy)
            {
                if (conf.headers_stream != null && conf.headers_stream.Count > 0)
                    headers = HeadersModel.Init(conf.headers_stream);

                #region apnstream
                string apnlink(ApnConf apn)
                {
                    string link = uri.Split(" ")[0].Split("#")[0].Trim();

                    if (apn.secure == "nginx")
                    {
                        using (MD5 md5 = MD5.Create())
                        {
                            long ex = ((DateTimeOffset)DateTime.Now.AddHours(12)).ToUnixTimeSeconds();
                            string hash = Convert.ToBase64String(md5.ComputeHash(Encoding.UTF8.GetBytes($"{ex}{requestInfo.IP} {apn.secret}"))).Replace("=", "").Replace("+", "-").Replace("/", "_");

                            return $"{apn.host}/{hash}:{ex}/{link}";
                        }
                    }
                    else if (apn.secure == "cf")
                    {
                        using (var sha1 = SHA1.Create())
                        {
                            var data = Encoding.UTF8.GetBytes($"{requestInfo.IP}{link}{apn.secret}");
                            return Convert.ToBase64String(sha1.ComputeHash(data));
                        }
                    }
                    else if (apn.secure == "lampac")
                    {
                        string aes = AesTo.Encrypt(System.Text.Json.JsonSerializer.Serialize(new 
                        {
                            u = link,
                            i = requestInfo.IP,
                            v = true,
                            e = DateTime.Now.AddHours(36),
                            h = headers?.ToDictionary() 
                        }));

                        if (uri.Contains(".m3u"))
                            aes += ".m3u8";

                        return $"{apn.host}/proxy/{aes}";
                    }

                    return $"{apn.host}/{link}";
                }

                if (!string.IsNullOrEmpty(conf.apn?.host) && conf.apn.host.StartsWith("http"))
                    return apnlink(conf.apn);

                if (AppInit.conf.serverproxy.forced_apn || conf.apnstream)
                {
                    if (!string.IsNullOrEmpty(AppInit.conf?.apn?.host) && AppInit.conf.apn.host.StartsWith("http"))
                        return apnlink(AppInit.conf.apn);

                    return uri;
                }  
                #endregion

                uri = ProxyLink.Encrypt(uri, requestInfo.IP, httpHeaders(conf.host ?? conf.apihost, headers), conf != null && conf.useproxystream ? proxy : null, conf?.plugin);

                if (AppInit.conf.accsdb.enable && !AppInit.conf.serverproxy.encrypt)
                    uri = AccsDbInvk.Args(uri, HttpContext);

                return $"{host}/proxy/{uri}";
            }

            if (conf.url_reserve && !uri.Contains(" or ") && !uri.Contains("/proxy/") &&
                !Regex.IsMatch(HttpContext.Request.QueryString.Value, "&play=true", RegexOptions.IgnoreCase))
            {
                string url_reserve = ProxyLink.Encrypt(uri, requestInfo.IP, httpHeaders(conf.host ?? conf.apihost, headers), conf != null && conf.useproxystream ? proxy : null, conf?.plugin);

                if (AppInit.conf.accsdb.enable && !AppInit.conf.serverproxy.encrypt)
                    url_reserve = AccsDbInvk.Args(uri, HttpContext);

                uri += $" or {host}/proxy/{url_reserve}";
            }

            return uri;
        }
        #endregion

        #region InvokeCache
        public ValueTask<CacheResult<T>> InvokeCache<T>(string key, TimeSpan time, Func<CacheResult<T>, ValueTask<dynamic>> onget) => InvokeCache(key, time, null, onget);

        async public ValueTask<CacheResult<T>> InvokeCache<T>(string key, TimeSpan time, ProxyManager proxyManager, Func<CacheResult<T>, ValueTask<dynamic>> onget, bool? memory = null)
        {
            var semaphore = new SemaphorManager(key, TimeSpan.FromSeconds(40));

            try
            {
                await semaphore.WaitAsync();

                if (hybridCache.TryGetValue(key, out T _val, memory))
                {
                    HttpContext.Response.Headers.TryAdd("X-Invoke-Cache", "HIT");
                    return new CacheResult<T>() { IsSuccess = true, Value = _val };
                }

                HttpContext.Response.Headers.TryAdd("X-Invoke-Cache", "MISS");

                var val = await onget.Invoke(new CacheResult<T>());

                if (val == null)
                    return new CacheResult<T>() { IsSuccess = false, ErrorMsg = "null" };

                if (val.GetType() == typeof(CacheResult<T>))
                    return (CacheResult<T>)val;

                if (val.Equals(default(T)))
                    return new CacheResult<T>() { IsSuccess = false, ErrorMsg = "default" };

                if (typeof(T) == typeof(string) && string.IsNullOrEmpty(val.ToString()))
                    return new CacheResult<T>() { IsSuccess = false, ErrorMsg = "empty" };

                proxyManager?.Success();
                hybridCache.Set(key, val, time, memory);
                return new CacheResult<T>() { IsSuccess = true, Value = val };
            }
            finally
            {
                semaphore.Release();
            }
        }

        async public ValueTask<T> InvokeCache<T>(string key, TimeSpan time, Func<ValueTask<T>> onget, ProxyManager proxyManager = null, bool? memory = null)
        {
            var semaphore = new SemaphorManager(key, TimeSpan.FromSeconds(40));

            try
            {
                await semaphore.WaitAsync();

                if (hybridCache.TryGetValue(key, out T val, memory))
                    return val;

                val = await onget.Invoke();
                if (val == null || val.Equals(default(T)))
                    return default;

                proxyManager?.Success();
                hybridCache.Set(key, val, time, memory);
                return val;
            }
            finally
            {
                semaphore.Release();
            }
        }
        #endregion

        #region InvkSemaphore
        async public Task<ActionResult> InvkSemaphore(BaseSettings init, string key, Func<ValueTask<ActionResult>> func)
        {
            if (init != null)
            {
                if (init.rhub && init.rhub_fallback == false)
                    return await func.Invoke();
            }

            var semaphore = new SemaphorManager(key, TimeSpan.FromSeconds(40));

            try
            {
                await semaphore.WaitAsync();
                return await func.Invoke();
            }
            finally
            {
                semaphore.Release();
            }
        }
        #endregion

        #region cacheTime
        public TimeSpan cacheTime(int multiaccess, int home = 5, int mikrotik = 2, BaseSettings init = null, int rhub = -1)
        {
            if (init != null && init.rhub && rhub != -1)
                return TimeSpan.FromMinutes(rhub);

            int ctime = AppInit.conf.mikrotik ? mikrotik : AppInit.conf.multiaccess ? init != null && init.cache_time > 0 ? init.cache_time : multiaccess : home;
            if (ctime > multiaccess)
                ctime = multiaccess;

            return TimeSpan.FromMinutes(ctime);
        }
        #endregion

        #region IsCacheError
        public bool IsCacheError(BaseSettings init)
        {
            if (!AppInit.conf.multiaccess || init.rhub)
                return false;

            if (memoryCache.TryGetValue(ResponseCache.ErrorKey(HttpContext), out object errorCache))
            {
                HttpContext.Response.Headers.TryAdd("X-RCache", "true");

                if (errorCache is OnErrorResult)
                {
                    badInitMsg = Json(errorCache);
                    return true;
                }
                else if (errorCache is string)
                {
                    string msg = errorCache.ToString();
                }

                badInitMsg = Ok();
                return true;
            }

            return false;
        }
        #endregion

        #region IsOverridehost
        async public ValueTask<ActionResult> IsOverridehost(BaseSettings init)
        {
            string overridehost = null;

            if (!string.IsNullOrEmpty(init.overridehost))
                overridehost = init.overridehost;

            if (string.IsNullOrEmpty(overridehost) && init.overridehosts != null && init.overridehosts.Length > 0)
                overridehost = init.overridehosts[Random.Shared.Next(0, init.overridehosts.Length)];

            if (string.IsNullOrEmpty(overridehost))
                return null;

            if (string.IsNullOrEmpty(init.overridepasswd))
            {
                if (overridehost.Contains("?"))
                    overridehost += "&" + HttpContext.Request.QueryString.Value.Remove(0, 1);
                else
                    overridehost += HttpContext.Request.QueryString.Value;

                return new RedirectResult(overridehost);
            }

            overridehost = Regex.Replace(overridehost, "^(https?://[^/]+)/.*", "$1");
            string uri = overridehost + HttpContext.Request.Path.Value + HttpContext.Request.QueryString.Value;

            string clientip = requestInfo.IP;
            if (requestInfo.Country == null)
                clientip = await mylocalip();

            string html = await Http.Get(uri, timeoutSeconds: 10, headers: HeadersModel.Init
            (
                ("localrequest", init.overridepasswd),
                ("x-client-ip", clientip)
            ));

            if (html == null)
                return new ContentResult() { StatusCode = 502, Content = string.Empty };

            html = Regex.Replace(html, "\"(https?://[^/]+/proxy/)", "\"_tmp_ $1");
            html = Regex.Replace(html, $"\"{overridehost}", $"\"{host}");
            html = html.Replace("\"_tmp_ ", "\"");

            return ContentTo(html);
        }
        #endregion

        #region NoAccessGroup
        public bool NoAccessGroup(Igroup init, out string error_msg)
        {
            error_msg = null;

            if (init.group > 0)
            {
                var user = requestInfo.user;
                if (user == null || init.group > user.group)
                {
                    error_msg = AppInit.conf.accsdb.denyGroupMesage.
                                Replace("{account_email}", requestInfo.user_uid).
                                Replace("{user_uid}", requestInfo.user_uid);

                    return true;
                }
            }

            return false;
        }
        #endregion

        #region accsArgs
        public string accsArgs(string uri)
        {
            return AccsDbInvk.Args(uri, HttpContext);
        }
        #endregion

        #region loadKit
        public bool IsKitConf { get; private set; }

        async public ValueTask<JObject> loadKitConf()
        {
            var init = AppInit.conf.kit;
            if (!init.enable || string.IsNullOrEmpty(init.path) || string.IsNullOrEmpty(requestInfo.user_uid))
                return null;

            if (init.IsAllUsersPath)
            {
                if (init.allUsers != null && init.allUsers.TryGetValue(requestInfo.user_uid, out JObject userInit))
                    return userInit;

                return null;
            }
            else
            {
                string memKey = $"loadKit:{requestInfo.user_uid}";
                if (!memoryCache.TryGetValue(memKey, out JObject appinit))
                {
                    string json;

                    if (Regex.IsMatch(init.path, "^https?://"))
                    {
                        string uri = init.path.Replace("{uid}", HttpUtility.UrlEncode(requestInfo.user_uid));
                        json = await Http.Get(uri, timeoutSeconds: 5);
                    }
                    else
                    {
                        string init_file = $"{init.path}/{CrypTo.md5(requestInfo.user_uid)}";

                        if (init.eval_path != null)
                            init_file = CSharpEval.Execute<string>(init.eval_path, new KitConfEvalPath(init.path, requestInfo.user_uid));
                       
                        if (!IO.File.Exists(init_file))
                            return null;

                        json = IO.File.ReadAllText(init_file);
                    }

                    if (json == null)
                        return null;

                    try
                    {
                        if (!json.TrimStart().StartsWith("{"))
                            json = "{" + json + "}";

                        appinit = JsonConvert.DeserializeObject<JObject>(json);
                    }
                    catch { return null; }

                    memoryCache.Set(memKey, appinit, DateTime.Now.AddSeconds(Math.Max(5, init.cacheToSeconds)));
                }

                return appinit;
            }
        }

        async public ValueTask<T> loadKit<T>(T _init, Func<JObject, T, T, T> func = null) where T : BaseSettings, ICloneable
        {
            if (_init.kit == false && _init.rhub_fallback == false)
                return (T)_init.Clone();

            return loadKit((T)_init.Clone(), await loadKitConf(), func, clone: false);
        }

        public T loadKit<T>(T _init, JObject appinit, Func<JObject, T, T, T> func = null, bool clone = true) where T : BaseSettings, ICloneable
        {
            var init = clone ? (T)_init.Clone() : _init;
            var defaultinit = InvkEvent.conf.LoadKit != null ? (clone ? _init : (T)_init.Clone()) : null;

            InvkEvent.LoadKitInit(new EventLoadKit(defaultinit, init, appinit, requestInfo, hybridCache));

            if (init == null || !init.kit || appinit == null || string.IsNullOrEmpty(init.plugin) || !appinit.ContainsKey(init.plugin))
            {
                InvkEvent.LoadKit(new EventLoadKit(defaultinit, init, appinit, requestInfo, hybridCache));
                return init;
            }

            var conf = appinit.Value<JObject>(init.plugin);

            void update<T2>(string key, Action<T2> updateAction)
            {
                if (conf.ContainsKey(key))
                    updateAction(conf.Value<T2>(key));
            }

            update<bool>("enable", v => init.enable = v);
            if (conf.ContainsKey("enable") && init.enable)
                init.geo_hide = null;

            update<string>("displayname", v => init.displayname = v);
            update<int>("displayindex", v => init.displayindex = v);
            update<string>("client_type", v => init.client_type = v);

            update<string>("cookie", v => init.cookie = v);
            update<string>("token", v => init.token = v);

            update<string>("host", v => init.host = v);
            update<string>("apihost", v => init.apihost = v);
            update<string>("scheme", v => init.scheme = v);
            update<bool>("hls", v => init.hls = v);

            update<string>("overridehost", v => init.overridehost = v);
            update<string>("overridepasswd", v => init.overridepasswd = v);
            if (conf.ContainsKey("overridehosts"))
                init.overridehosts = conf["overridehosts"].ToObject<string[]>();

            if (conf.ContainsKey("headers"))
                init.headers = conf["headers"].ToObject<Dictionary<string, string>>();

            init.apnstream = true;
            if (conf.ContainsKey("apn"))
                init.apn = conf["apn"].ToObject<ApnConf>();

            init.useproxystream = false;
            update<bool>("streamproxy", v => init.streamproxy = v);
            if (conf.ContainsKey("geostreamproxy"))
                init.geostreamproxy = conf["geostreamproxy"].ToObject<string[]>();

            if (conf.ContainsKey("proxy"))
            {
                init.proxy = conf["proxy"].ToObject<ProxySettings>();
                if (init?.proxy?.list != null && init.proxy.list.Length > 0)
                    update<bool>("useproxy", v => init.useproxy = v);
            }

            if (init.useproxy)
            {
                init.rhub = false;
                init.rhub_fallback = true;
            }
            else if (AppInit.conf.kit.rhub_fallback || init.rhub_fallback)
            {
                update<bool>("rhub", v => init.rhub = v);
                update<bool>("rhub_fallback", v => init.rhub_fallback = v);
            }
            else
            {
                init.rhub = true;
                init.rhub_fallback = true;
            }

            if (init.rhub)
                update<int>("cache_time", v => init.cache_time = v);

            IsKitConf = true;

            InvkEvent.LoadKit(new EventLoadKit(defaultinit, init, conf, requestInfo, hybridCache));

            if (func != null)
                return func.Invoke(conf, init, conf.ToObject<T>());

            return init;
        }
        #endregion

        #region RedirectToPlay
        public RedirectResult RedirectToPlay(string url)
        {
            if (!url.Contains(" "))
                return new RedirectResult(url);

            return new RedirectResult(url.Split(" ")[0].Trim());
        }
        #endregion

        #region ContentTo / Dispose
        public ActionResult ContentTo(in string html)
        {
            return Content(html, html.StartsWith("{") || html.StartsWith("[") ? "application/json; charset=utf-8" : "text/html; charset=utf-8");
        }

        public new void Dispose()
        {
            serviceScope?.Dispose();
            base.Dispose();
        }
        #endregion
    }
}

```

## File: Shared/Models/HeadersModel.cs
```
Ôªønamespace Shared.Models
{
    public class HeadersModel
    {
        public HeadersModel(string name, string val)
        {
            this.name = name;
            this.val = val;
        }

        public string name { get; set; }

        public string val { get; set; }


        #region Init
        public static List<HeadersModel> Init(string name, string val)
        {
            return new List<HeadersModel>() { new HeadersModel(name, val)};
        }

        public static List<HeadersModel> Init(List<HeadersModel> headers)
        {
            return headers ?? new List<HeadersModel>();
        }

        public static List<HeadersModel> Init(params (string name, string val)[] headers)
        {
            var h = new List<HeadersModel>(headers.Count());

            foreach (var i in headers)
                h.Add(new HeadersModel(i.name, i.val));

            return h;
        }

        public static List<HeadersModel> Init(Dictionary<string, string> defaultHeaders, params (string name, string val)[] headers)
        {
            return Join(Init(headers), defaultHeaders);
        }

        public static List<HeadersModel> Init(IEnumerable<KeyValuePair<string, string>> headers)
        {
            if (headers == null || headers.Count() == 0)
                return new List<HeadersModel>();

            var h = new List<HeadersModel>(headers.Count());

            foreach (var i in headers)
                h.Add(new HeadersModel(i.Key, i.Value));

            return h;
        }
        #endregion

        #region Join
        public static List<HeadersModel> Join(List<HeadersModel> h1, List<HeadersModel> h2)
        {
            if (h1 == null)
                return h2 ?? new List<HeadersModel>();

            if (h2 == null)
                return h1 ?? new List<HeadersModel>();

            var result = new List<HeadersModel>(h1);
            result.AddRange(h2);

            return result;
        }

        public static List<HeadersModel> Join(List<HeadersModel> h1, Dictionary<string, string> h2)
        {
            if (h1 == null)
            {
                if (h2 == null)
                    return new List<HeadersModel>();

                return Init(h2);
            }

            if (h2 == null)
                return h1 ?? new List<HeadersModel>();

            var result = new List<HeadersModel>(h1);
            foreach (var _h2 in h2)
                result.Add(new HeadersModel(_h2.Key, _h2.Value));

            return result;
        }
        #endregion
    }
}

```

## File: Shared/Models/RequestModel.cs
```
Ôªøusing Shared.Engine;
using Shared.Models.Base;

namespace Shared.Models
{
    public struct RequestModel
    {
        public RequestModel()
        {
        }

        public bool IsLocalRequest { get; set; }

        public bool IsAnonymousRequest { get; set; }

        public string IP { get; set; }

        public string Path { get; set; }

        public string Query { get; set; }

        public string UserAgent { get; set; }

        #region Country
        private string _countryCode = null;
        public string Country
        {
            get
            {
                if (_countryCode == string.Empty)
                    return null;

                if (_countryCode != null)
                    return _countryCode;

                _countryCode = GeoIP2.Country(IP);
                if (_countryCode == null)
                {
                    _countryCode = string.Empty;
                    return null;
                }

                return _countryCode;
            }
            set
            {
                if (!string.IsNullOrEmpty(value))
                    _countryCode = value;
            }
        }
        #endregion

        public AccsUser user { get; set; }

        public string user_uid { get; set; }

        public Dictionary<string, object> @params { get; set; }
    }
}

```

## File: Shared/Models/AsyncManualResetEvent.cs
```
Ôªøusing System.Threading;

namespace Shared.Models
{
    public class AsyncManualResetEvent
    {
        private volatile TaskCompletionSource<bool> tcs = new TaskCompletionSource<bool>();

        public Task WaitAsync()
        {
            return tcs.Task;
        }

        async public ValueTask WaitAsync(int millisecondsTimeout)
        {
            try
            {
                await tcs.Task.WaitAsync(TimeSpan.FromMilliseconds(millisecondsTimeout));
            }
            catch { }
        }

        async public ValueTask WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken)
        {
            try
            {
                await tcs.Task.WaitAsync(TimeSpan.FromMilliseconds(millisecondsTimeout), cancellationToken);
            }
            catch { }
        }

        public void Set()
        {
            var currentTcs = tcs;
            if (Interlocked.CompareExchange(ref tcs, new TaskCompletionSource<bool>(), currentTcs) == currentTcs)
            {
                currentTcs.SetResult(true);
            }
        }

        //public void Reset()
        //{
        //    while (true)
        //    {
        //        var currentTcs = tcs;
        //        if (!currentTcs.Task.IsCompleted ||
        //            Interlocked.CompareExchange(ref tcs, currentTcs, null) == null)
        //        {
        //            return;
        //        }
        //    }
        //}
    }
}

```

## File: Shared/Models/CacheResult.cs
```
Ôªønamespace Shared.Models
{
    public class CacheResult<T>
    {
        public bool IsSuccess { get; set; }

        public string ErrorMsg { get; set; }

        public T Value { get; set; }


        public CacheResult<T> Fail(string msg)
        {
            return new CacheResult<T>() { IsSuccess = false, ErrorMsg = msg };
        }
    }
}

```

## File: Shared/Models/INws.cs
```
using System.Collections.Concurrent;
using System.Net.WebSockets;
using System.Threading;

namespace Shared.Models
{
    public interface INws
    {
        ConcurrentDictionary<string, NwsConnection> AllConnections();

        void WebLog(string message, string plugin);

        Task EventsAsync(string connectionId, string uid, string name, string data);

        Task SendAsync(string connectionId, string method, params object[] args);
    }

    public class NwsConnection : IDisposable
    {
        public NwsConnection(string connectionId, WebSocket socket, string host, string ip, string userAgent)
        {
            ConnectionId = connectionId;
            Socket = socket;
            Host = host;
            Ip = ip;
            UserAgent = userAgent;
            SendLock = new SemaphoreSlim(1, 1);
            UpdateActivity();
        }

        public string ConnectionId { get; }

        public WebSocket Socket { get; }

        public string Host { get; }

        public string Ip { get; }

        public string UserAgent { get; }

        public SemaphoreSlim SendLock { get; }

        long _lastActivityTicks;

        CancellationTokenSource _cancellationSource;

        public DateTime LastActivityUtc
        {
            get
            {
                long ticks = Interlocked.Read(ref _lastActivityTicks);
                return new DateTime(ticks, DateTimeKind.Utc);
            }
        }

        public void UpdateActivity()
        {
            Interlocked.Exchange(ref _lastActivityTicks, DateTime.UtcNow.Ticks);
        }

        public void SetCancellationSource(CancellationTokenSource source)
        {
            var previous = Interlocked.Exchange(ref _cancellationSource, source);
            previous?.Dispose();
        }

        public void Cancel()
        {
            var source = Interlocked.CompareExchange(ref _cancellationSource, null, null);
            if (source == null)
                return;

            try
            {
                source.Cancel();
            }
            catch (ObjectDisposedException)
            {
            }
        }

        public void Dispose()
        {
            SendLock.Dispose();
            Interlocked.Exchange(ref _cancellationSource, null)?.Dispose();
        }
    }
}

```

## File: Shared/Models/ISoks.cs
```
Ôªøusing Microsoft.AspNetCore.SignalR;

namespace Shared.Models
{
    public interface ISoks
    {
        IHubCallerClients AllClients { get; }

        void WebLog(string message, string plugin);

        Task EventsAsync(string connectionId, string uid, string name, string data);
    }
}

```

## File: Shared/Models/Proxy/ProxyLinkModel.cs
```
Ôªøusing System.Net;
using System.Text.Json.Serialization;

namespace Shared.Models.Proxy
{
    public class ProxyLinkModel
    {
        public ProxyLinkModel() 
        { 
            ex = DateTime.Now.AddHours(AppInit.conf.mikrotik ? 4 : 20);
        }

        public ProxyLinkModel(string reqip, List<HeadersModel> headers, WebProxy proxy, string uri, string plugin = null, bool verifyip = true, DateTime ex = default)
        {
            this.ex = ex;
            this.reqip = reqip;
            this.headers = headers;
            this.proxy = proxy;
            this.uri = uri;
            this.plugin = plugin;
            this.verifyip = verifyip;

            if (this.ex == default)
                this.ex = DateTime.Now.AddHours(AppInit.conf.mikrotik ? 4 : 20);
        }

        [JsonIgnore]
        public string id { get; set; }

        [JsonIgnore]
        public DateTime ex { get; set; }

        public string reqip { get; set; }

        public List<HeadersModel> headers { get; set; }

        [JsonIgnore]
        public WebProxy proxy { get; set; }

        public string uri { get; set; }

        public string plugin { get; set; }

        public bool verifyip { get; set; }
    }
}

```

## File: Shared/Models/Proxy/ProxyManagerModel.cs
```
Ôªønamespace Shared.Models.Proxy
{
    public class ProxyManagerModel
    {
        public string proxyip { get; set; }

        public int errors { get; set; }
    }
}

```

## File: Shared/Models/SISI/User.cs
```
Ôªøusing LiteDB;
using Shared.Models.SISI.Base;

namespace Shared.Models.SISI
{
    public class User
    {
        [BsonId]
        public string Id { get; set; }

        public List<PlaylistItem> Bookmarks { get; set; } = new();
    }
}

```

## File: Shared/Models/SISI/Xvideos.cs
```
Ôªønamespace Shared.Models.SISI.Xvideos
{
    public struct Related
    {
        public string u { get; set; }

        public string i { get; set; }

        public string d { get; set; }

        public string @if { get; set; }

        public string tf { get; set; }


        public string pn { get; set; }

        public string p { get; set; }

        public bool ch { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/ModelParse.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class ModelParse
    {
        public SingleNodeSettings name { get; set; }

        public SingleNodeSettings href { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/RouteSettings.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class RouteSettings
    {
        public string eval { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/ContentParseSettings.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class ContentParseSettings
    {
        public string nodes { get; set; }

        public SingleNodeSettings name { get; set; }

        public SingleNodeSettings href { get; set; }

        public SingleNodeSettings img { get; set; }

        public SingleNodeSettings duration { get; set; }

        public SingleNodeSettings quality { get; set; }

        public SingleNodeSettings preview { get; set; }

        public ModelParse model { get; set; }

        public List<ContentParseArg> args { get; set; }

        public bool json { get; set; } = true;

        public string eval { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/MenuSettings.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class MenuSettings
    {
        public bool bind { get; set; } = true;

        public Dictionary<string, string> route { get; set; }

        public Dictionary<string, string> sort { get; set; }

        public Dictionary<string, string> categories { get; set; }

        public string formatcat(string cat)
        {
            if (categories != null && categories.TryGetValue("format", out string format))
                return format.Replace("{cat}", cat);

            return cat;
        }

        public List<CustomCategories> customs { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/CustomCategories.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class CustomCategories
    {
        public string name { get; set; }

        public string arg { get; set; }

        public string format { get; set; }

        public Dictionary<string, string> submenu { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/NxtSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.SISI.NextHUB
{
    public class NxtSettings : BaseSettings, ICloneable
    {
        public NxtSettings()
        {
            cache_time = 5;
        }

        public bool debug { get; set; }

        public int timeout { get; set; } = 10;

        public bool streamproxy_preview { get; set; }

        public bool ignore_no_picture { get; set; } = true;

        public bool abortMedia { get; set; } = true;

        public bool fullCacheJS { get; set; } = true;

        public bool keepopen { get; set; } = true;

        public List<Microsoft.Playwright.Cookie> cookies { get; set; }

        public RouteSettings route { get; set; }

        public MenuSettings menu { get; set; }

        public ListSettings list { get; set; }

        public ListSettings search { get; set; }

        public ListSettings model { get; set; }

        public ContentParseSettings contentParse { get; set; }

        public ViewSettings view { get; set; }


        public NxtSettings Clone()
        {
            return (NxtSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/SISI/NextHUB/SingleNodeSettings.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class SingleNodeSettings
    {
        public string node { get; set; }

        public string attribute { get; set; }

        public string[] attributes { get; set; }

        public string format { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/ViewSettings.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class ViewSettings
    {
        public string initUrlEval { get; set; }

        public string addInitScript { get; set; }

        public string routeEval { get; set; }

        public string eval { get; set; }

        public string evalJS { get; set; }

        public string playbtn { get; set; }

        public string waitForSelector { get; set; }

        public float waitForSelector_timeout { get; set; } = 5000;

        public string patternFile { get; set; }

        public bool waitLocationFile { get; set; }

        public bool waitForResponse { get; set; }

        public RegexMatchSettings iframe { get; set; }

        public SingleNodeSettings nodeFile { get; set; }

        public RegexMatchSettings regexMatch { get; set; }

        public bool bindingToIP { get; set; }

        public bool fullCacheJS { get; set; } = true;

        public bool abortMedia { get; set; } = true;

        public string patternAbort { get; set; }

        public string patternAbortEnd { get; set; }

        public string patternWhiteRequest { get; set; }

        public bool related { get; set; }

        public ContentParseSettings relatedParse { get; set; }

        public bool NetworkIdle { get; set; }

        public int cache_time { get; set; } = 15;


        public bool viewsource { get; set; }

        public string priorityBrowser { get; set; }

        public bool keepopen { get; set; } = true;
    }
}

```

## File: Shared/Models/SISI/NextHUB/RegexMatchSettings.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class RegexMatchSettings
    {
        public string pattern { get; set; }

        public int index { get; set; } = 1;

        public string format { get; set; }

        public string[] matches { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/ContentParseArg.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class ContentParseArg : SingleNodeSettings
    {
        public string name { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/ListSettings.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class ListSettings
    {
        public int total_pages { get; set; } = 0;

        public string firstpage { get; set; }

        public string uri { get; set; }

        public string format { get; set; }

        public bool viewsource { get; set; } = true;

        public string waitForSelector { get; set; }

        public float waitForSelector_timeout { get; set; } = 5000;

        public string patternAbort { get; set; }

        public string routeEval { get; set; }

        public ContentParseSettings contentParse { get; set; }
    }
}

```

## File: Shared/Models/SISI/OnResult/OnListResult.cs
```
Ôªøusing Shared.Models.SISI.Base;

namespace Shared.Models.SISI.OnResult
{
    public struct OnListResult
    {
        public OnListResult(int listCount, int total_pages, IList<MenuItem> menu)
        {
            list = new OnResultPlaylistItem[listCount];
            this.total_pages = total_pages;
            this.menu = menu;
        }

        public IList<MenuItem> menu { get; set; }

        public int total_pages { get; set; }

        public OnResultPlaylistItem[] list { get; set; }
    }
}

```

## File: Shared/Models/SISI/OnResult/OnResultPlaylistItem.cs
```
Ôªøusing Shared.Models.SISI.Base;

namespace Shared.Models.SISI.OnResult
{
    public struct OnResultPlaylistItem
    {
        public string video { get; set; }

        public string name { get; set; }

        public string picture { get; set; }

        public string preview { get; set; }

        public string quality { get; set; }

        public string time { get; set; }

        public string myarg { get; set; }

        public bool json { get; set; }

        public bool hide { get; set; }

        public bool related { get; set; }

        public ModelItem model { get; set; }

        public Dictionary<string, string> qualitys { get; set; }

        public Bookmark bookmark { get; set; }
    }
}

```

## File: Shared/Models/SISI/OnResult/StreamItem.cs
```
Ôªøusing Shared.Models.SISI.Base;

namespace Shared.Models.SISI.OnResult
{
    public class StreamItem
    {
        public Dictionary<string, string> qualitys { get; set; }

        public Dictionary<string, string> qualitys_proxy { get; set; }

        public IList<PlaylistItem> recomends { get; set; }
    }
}

```

## File: Shared/Models/SISI/OnResult/OnStreamResult.cs
```
Ôªønamespace Shared.Models.SISI.OnResult
{
    public struct OnStreamResult
    {
        public OnStreamResult(int recomendsCount) 
        {
            recomends = new OnResultPlaylistItem[recomendsCount];
        }

        public Dictionary<string, string> qualitys { get; set; }

        public Dictionary<string, string> qualitys_proxy { get; set; }

        public Dictionary<string, string> headers_stream { get; set; }

        public OnResultPlaylistItem[] recomends { get; set; }
    }
}

```

## File: Shared/Models/SISI/OnResult/OnErrorResult.cs
```
Ôªønamespace Shared.Models.SISI.OnResult
{
    public struct OnErrorResult
    {
        public OnErrorResult(string msg)
        {
            this.msg = msg;
        }

        public bool error { get; set; } = true;

        public string msg { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/SisiSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.SISI.Base
{
    public class SisiSettings : BaseSettings, ICloneable
    {
        public SisiSettings(string plugin, string host, bool enable = true, bool useproxy = false, bool streamproxy = false)
        {
            this.enable = enable;
            this.plugin = plugin;
            this.useproxy = useproxy;
            this.streamproxy = streamproxy;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);
        }

        public SisiSettings Clone()
        {
            return (SisiSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/SISI/Base/HistoryConf.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public class HistoryConf
    {
        public bool enable { get; set; }

        public int days { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/PlaylistItem.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public class PlaylistItem
    {
        public string video { get; set; }

        public string name { get; set; }

        public string picture { get; set; }

        public string preview { get; set; }

        public string quality { get; set; }

        public string time { get; set; }

        public string myarg { get; set; }

        public bool json { get; set; }

        public bool hide { get; set; }

        public bool related { get; set; }

        public ModelItem model { get; set; }

        public Dictionary<string, string> qualitys { get; set; }

        public Bookmark bookmark { get; set; }

        public string history_uid { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/ModelItem.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public class ModelItem
    {
        public ModelItem() { }

        public ModelItem(string name, string uri)
        {
            this.uri = uri;
            this.name = name;
        }

        public string uri { get; set; }

        public string name { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/SisiConf.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public class SisiConf
    {
        public bool xdb { get; set; }

        public bool lgbt { get; set; }

        public bool NextHUB { get; set; }

        public string[] NextHUB_sites_enabled { get; set; }

        public bool rsize { get; set; }

        public string rsize_host { get; set; }

        public string bypass_host { get; set; }

        public string[] rsize_disable { get; set; }

        public string[] proxyimg_disable { get; set; }

        public int heightPicture { get; set; }

        public int widthPicture { get; set; }


        public bool spider { get; set; }

        public string component { get; set; }

        public string vipcontent { get; set; }

        public string iconame { get; set; }


        public bool push_all { get; set; }

        public bool forced_checkRchtype { get; set; }


        public BookmarksConf bookmarks { get; set; }

        public HistoryConf history { get; set; }


        public Dictionary<string, string> appReplace { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/BookmarksConf.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public class BookmarksConf
    {
        public bool saveimage { get; set; }

        public bool savepreview { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/ChannelItem.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public struct ChannelItem
    {
        public ChannelItem(string title, string playlist_url, int displayindex)
        {
            this.title = title;
            this.playlist_url = playlist_url;
            this.displayindex = displayindex;
        }

        public string title { get; set; }

        public string playlist_url { get; set; }

        public int displayindex { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/Bookmark.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public class Bookmark
    {
        public string uid { get; set; }

        public string site { get; set; }

        public string image { get; set; }

        public string href { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/MenuItem.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public struct MenuItem
    {
        public MenuItem(string title, string playlist_url) 
        {
            this.title = title;
            this.playlist_url = playlist_url;
        }

        public string title { get; set; }

        public string search_on { get; set; }

        public string logo_30x30 { get; set; }

        public string playlist_url { get; set; }

        public List<MenuItem> submenu { get; set; }
    }
}

```

## File: Shared/Models/Module/SisiEventsModel.cs
```
Ôªønamespace Shared.Models.Module
{
    public class SisiEventsModel
    {
        public SisiEventsModel(string rchtype, string account_email, string uid, string token)
        {
            this.rchtype = rchtype;
            this.account_email = account_email;
            this.uid = uid;
            this.token = token;
        }

        public string rchtype { get; set; }
        public string account_email { get; set; }
        public string uid { get; set; }
        public string token { get; set; }
    }
}

```

## File: Shared/Models/Module/SisiMod.cs
```
Ôªønamespace Shared.Models.Module
{
    public class SisiMod
    {
        public bool enable { get; set; }

        public string name { get; set; }

        public string url { get; set; }
    }
}

```

## File: Shared/Models/Module/OnlineEventsModel.cs
```
Ôªønamespace Shared.Models.Module
{
    public class OnlineEventsModel
    {
        public OnlineEventsModel(string id, string imdb_id, long kinopoisk_id, string title, string original_title, string original_language, int year, string source, string rchtype, int serial, bool life, bool islite, string account_email, string uid, string token, string nws_id)
        {
            this.id = id;
            this.imdb_id = imdb_id;
            this.kinopoisk_id = kinopoisk_id;
            this.title = title;
            this.original_title = original_title;
            this.original_language = original_language;
            this.year = year;
            this.source = source;
            this.rchtype = rchtype;
            this.serial = serial;
            this.life = life;
            this.islite = islite;
            this.account_email = account_email;
            this.uid = uid;
            this.token = token;
            this.nws_id = nws_id;
        }

        public string id { get; set; }
        public string imdb_id { get; set; }
        public long kinopoisk_id { get; set; }
        public string title { get; set; }
        public string original_title { get; set; }
        public string original_language { get; set; }
        public int year { get; set; }
        public string source { get; set; }
        public string rchtype { get; set; }
        public int serial { get; set; }
        public bool life { get; set; }
        public bool islite { get; set; }
        public string account_email { get; set; }
        public string uid { get; set; }
        public string token { get; set; }
        public string nws_id { get; set; }
    }
}

```

## File: Shared/Models/Module/JacMod.cs
```
Ôªønamespace Shared.Models.Module
{
    public class JacMod
    {
        public bool enable { get; set; }

        public string @namespace { get; set; }
    }
}

```

## File: Shared/Models/Module/OnlineMod.cs
```
Ôªønamespace Shared.Models.Module
{
    public class OnlineMod
    {
        public bool enable { get; set; }

        public string @namespace { get; set; }
    }
}

```

## File: Shared/Models/Module/OnlineSpiderModel.cs
```
namespace Shared.Models.Module
{
    public class OnlineSpiderModel
    {
        public OnlineSpiderModel(string title, bool isanime)
        {
            this.title = title;
            this.isanime = isanime;
        }

        public string title { get; set; }
        public bool isanime { get; set; }
        public bool requireRhub { get; set; }
    }
}

```

## File: Shared/Models/Module/InitspaceModel.cs
```
Ôªøusing Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace Shared.Models.Module
{
    public class InitspaceModel
    {
        public string path { get; set; }

        public ISoks soks { get; set; }

        public INws nws { get; set; }

        public IMemoryCache memoryCache { get; set; }

        public IConfiguration configuration { get; set; }

        public IServiceCollection services { get; set; }

        public IApplicationBuilder app { get; set; }
    }
}

```

## File: Shared/Models/Module/InitializationModel.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Module
{
    public class InitializationModel
    {
        public InitializationModel(BaseSettings init, bool? rch)
        {
            this.init = init;
            this.rch = rch;
        }

        public BaseSettings init { get; set; }
        public bool? rch { get; set; }
    }
}

```

## File: Shared/Models/Module/RootModule.cs
```
Ôªøusing System.Reflection;

namespace Shared.Models.Module
{
    public class RootModule
    {
        public bool enable { get; set; }

        public bool dynamic { get; set; }

        public int index { get; set; }

        public int version { get; set; }

        public string dll { get; set; }

        public string[] references { get; set; }

        public Assembly assembly { get; set; }


        public string @namespace { get; set; }

        public string initspace { get; set; }

        public string middlewares { get; set; }

        public string online { get; set; }

        public string sisi { get; set; }

        public string initialization { get; set; }

        public List<JacMod> jac { get; set; } = new List<JacMod>();


        public string NamespacePath(string val)
        {
            if (version >= 3 && !string.IsNullOrEmpty(@namespace))
                return $"{@namespace}.{val}";

            return val;
        }
    }
}

```

## File: Shared/Models/Module/Entrys/SisiModuleEntry.cs
```
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Shared.Models.SISI.Base;

namespace Shared.Models.Module.Entrys
{
    public class SisiModuleEntry
    {
        public RootModule mod;

        // version >= 3
        public Func<HttpContext, IMemoryCache, RequestModel, string, SisiEventsModel, List<ChannelItem>> Invoke = null;
        public Func<HttpContext, IMemoryCache, RequestModel, string, SisiEventsModel, Task<List<ChannelItem>>> InvokeAsync = null;

        // version < 3
        public Func<string, List<ChannelItem>> Events = null;

        public static List<SisiModuleEntry> sisiModulesCache = null;
        static readonly object _sisiModulesCacheLock = new object();

        public static void EnsureCache(bool forced = false)
        {
            if (AppInit.modules == null)
                return;

            if (forced == false && sisiModulesCache != null)
                return;

            lock (_sisiModulesCacheLock)
            {
                if (forced == false && sisiModulesCache != null)
                    return;

                sisiModulesCache = new List<SisiModuleEntry>();

                try
                {
                    foreach (var mod in AppInit.modules.Where(i => i.sisi != null && i.enable))
                    {
                        try
                        {
                            var entry = new SisiModuleEntry() { mod = mod };

                            var assembly = mod.assembly;
                            if (assembly == null)
                                continue;

                            var type = assembly.GetType(mod.NamespacePath(mod.sisi));
                            if (type == null)
                                continue;

                            if (mod.version >= 3)
                            {
                                try
                                {
                                    var m = type.GetMethod("Invoke");
                                    if (m != null)
                                    {
                                        entry.Invoke = (Func<HttpContext, IMemoryCache, RequestModel, string, SisiEventsModel, List<ChannelItem>>)Delegate.CreateDelegate(
                                            typeof(Func<HttpContext, IMemoryCache, RequestModel, string, SisiEventsModel, List<ChannelItem>>), m);
                                    }
                                }
                                catch { }

                                try
                                {
                                    var m2 = type.GetMethod("InvokeAsync");
                                    if (m2 != null)
                                    {
                                        entry.InvokeAsync = (Func<HttpContext, IMemoryCache, RequestModel, string, SisiEventsModel, Task<List<ChannelItem>>>)Delegate.CreateDelegate(
                                            typeof(Func<HttpContext, IMemoryCache, RequestModel, string, SisiEventsModel, Task<List<ChannelItem>>>), m2);
                                    }
                                }
                                catch { }
                            }
                            else
                            {
                                try
                                {
                                    var m = type.GetMethod("Events");
                                    if (m != null)
                                    {
                                        entry.Events = (Func<string, List<ChannelItem>>)Delegate.CreateDelegate(
                                            typeof(Func<string, List<ChannelItem>>), m);
                                    }
                                }
                                catch { }
                            }

                            if (entry.Invoke != null || entry.InvokeAsync != null || entry.Events != null)
                                sisiModulesCache.Add(entry);
                        }
                        catch { }
                    }
                }
                catch { }
            }
        }
    }
}

```

## File: Shared/Models/Module/Entrys/MiddlewaresModuleEntry.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using System.Reflection;

namespace Shared.Models.Module.Entrys
{
    public class MiddlewaresModuleEntry
    {
        public RootModule mod;
        public Func<bool, HttpContext, IMemoryCache, bool> Invoke = null;
        public Func<bool, HttpContext, IMemoryCache, Task<bool>> InvokeAsync = null;
        public Func<HttpContext, IMemoryCache, bool> InvokeV1 = null;
        public Func<HttpContext, IMemoryCache, Task<bool>> InvokeAsyncV1 = null;


        public static List<MiddlewaresModuleEntry> middlewareModulesCache = null;
        static readonly object _middlewareModulesCacheLock = new object();

        public static void EnsureCache(bool forced = false)
        {
            if (AppInit.modules == null)
                return;

            if (forced == false && middlewareModulesCache != null)
                return;

            lock (_middlewareModulesCacheLock)
            {
                if (forced == false && middlewareModulesCache != null)
                    return;

                middlewareModulesCache = new List<MiddlewaresModuleEntry>();

                foreach (var mod in AppInit.modules.Where(i => i.middlewares != null && i.enable))
                {
                    try
                    {
                        var entry = new MiddlewaresModuleEntry() { mod = mod };

                        Assembly assembly = mod.assembly;
                        if (assembly == null)
                            continue;

                        var type = assembly.GetType(mod.NamespacePath(mod.middlewares));
                        if (type == null)
                            continue;

                        if (mod.version >= 2)
                        {
                            try
                            {
                                var m = type.GetMethod("Invoke");
                                if (m != null)
                                {
                                    entry.Invoke = (Func<bool, HttpContext, IMemoryCache, bool>)Delegate.CreateDelegate(
                                        typeof(Func<bool, HttpContext, IMemoryCache, bool>), m);
                                }
                            }
                            catch { }

                            try
                            {
                                var m2 = type.GetMethod("InvokeAsync");
                                if (m2 != null)
                                {
                                    entry.InvokeAsync = (Func<bool, HttpContext, IMemoryCache, Task<bool>>)Delegate.CreateDelegate(
                                        typeof(Func<bool, HttpContext, IMemoryCache, Task<bool>>), m2);
                                }
                            }
                            catch { }
                        }
                        else
                        {
                            try
                            {
                                var m = type.GetMethod("Invoke");
                                if (m != null)
                                {
                                    entry.InvokeV1 = (Func<HttpContext, IMemoryCache, bool>)Delegate.CreateDelegate(
                                        typeof(Func<HttpContext, IMemoryCache, bool>), m);
                                }
                            }
                            catch { }

                            try
                            {
                                var m2 = type.GetMethod("InvokeAsync");
                                if (m2 != null)
                                {
                                    entry.InvokeAsyncV1 = (Func<HttpContext, IMemoryCache, Task<bool>>)Delegate.CreateDelegate(
                                        typeof(Func<HttpContext, IMemoryCache, Task<bool>>), m2);
                                }
                            }
                            catch { }
                        }

                        if (entry.Invoke != null || entry.InvokeAsync != null || entry.InvokeV1 != null || entry.InvokeAsyncV1 != null)
                            middlewareModulesCache.Add(entry);
                    }
                    catch { }
                }
            }
        }
    }
}

```

## File: Shared/Models/Module/Entrys/OnlineModuleEntry.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;

namespace Shared.Models.Module.Entrys
{
    public class OnlineModuleEntry
    {
        public RootModule mod;

        // version >= 3
        public Func<HttpContext, IMemoryCache, RequestModel, string, OnlineEventsModel, List<(string name, string url, string plugin, int index)>> Invoke = null;
        public Func<HttpContext, IMemoryCache, RequestModel, string, OnlineEventsModel, Task<List<(string name, string url, string plugin, int index)>>> InvokeAsync = null;
        public Func<HttpContext, IMemoryCache, RequestModel, string, OnlineSpiderModel, List<(string name, string url, int index)>> Spider = null;
        public Func<HttpContext, IMemoryCache, RequestModel, string, OnlineSpiderModel, Task<List<(string name, string url, int index)>>> SpiderAsync = null;

        // version < 3
        public Func<string, long, string, long, string, string, string, int, string, int, string, List<(string name, string url, string plugin, int index)>> Events = null;
        public Func<HttpContext, IMemoryCache, string, long, string, long, string, string, string, int, string, int, string, Task<List<(string name, string url, string plugin, int index)>>> EventsAsync = null;
        public static List<OnlineModuleEntry> onlineModulesCache = null;
        static readonly object _onlineModulesCacheLock = new object();

        public static void EnsureCache(bool forced = false)
        {
            if (AppInit.modules == null)
                return;

            if (forced == false && onlineModulesCache != null)
                return;

            lock (_onlineModulesCacheLock)
            {
                if (forced == false && onlineModulesCache != null)
                    return;

                onlineModulesCache = new List<OnlineModuleEntry>();

                try
                {
                    foreach (var mod in AppInit.modules.Where(i => i.online != null && i.enable))
                    {
                        try
                        {
                            var entry = new OnlineModuleEntry() { mod = mod };

                            var assembly = mod.assembly;
                            if (assembly == null)
                                continue;

                            var type = assembly.GetType(mod.NamespacePath(mod.online));
                            if (type == null)
                                continue;

                            if (mod.version >= 3)
                            {
                                try
                                {
                                    var m = type.GetMethod("Invoke");
                                    if (m != null)
                                    {
                                        entry.Invoke = (Func<HttpContext, IMemoryCache, RequestModel, string, OnlineEventsModel, List<(string name, string url, string plugin, int index)>>)Delegate.CreateDelegate(
                                            typeof(Func<HttpContext, IMemoryCache, RequestModel, string, OnlineEventsModel, List<(string name, string url, string plugin, int index)>>), m);
                                    }
                                }
                                catch { }

                                try
                                {
                                    var m2 = type.GetMethod("InvokeAsync");
                                    if (m2 != null)
                                    {
                                        entry.InvokeAsync = (Func<HttpContext, IMemoryCache, RequestModel, string, OnlineEventsModel, Task<List<(string name, string url, string plugin, int index)>>>)Delegate.CreateDelegate(
                                            typeof(Func<HttpContext, IMemoryCache, RequestModel, string, OnlineEventsModel, Task<List<(string name, string url, string plugin, int index)>>>), m2);
                                    }
                                }
                                catch { }

                                try
                                {
                                    var m3 = type.GetMethod("Spider");
                                    if (m3 != null)
                                    {
                                        entry.Spider = (Func<HttpContext, IMemoryCache, RequestModel, string, OnlineSpiderModel, List<(string name, string url, int index)>>)Delegate.CreateDelegate(
                                            typeof(Func<HttpContext, IMemoryCache, RequestModel, string, OnlineSpiderModel, List<(string name, string url, int index)>>), m3);
                                    }
                                }
                                catch { }

                                try
                                {
                                    var m4 = type.GetMethod("SpiderAsync");
                                    if (m4 != null)
                                    {
                                        entry.SpiderAsync = (Func<HttpContext, IMemoryCache, RequestModel, string, OnlineSpiderModel, Task<List<(string name, string url, int index)>>>)Delegate.CreateDelegate(
                                            typeof(Func<HttpContext, IMemoryCache, RequestModel, string, OnlineSpiderModel, Task<List<(string name, string url, int index)>>>), m4);
                                    }
                                }
                                catch { }

                            }
                            else
                            {
                                try
                                {
                                    var m = type.GetMethod("Events");
                                    if (m != null)
                                    {
                                        entry.Events = (Func<string, long, string, long, string, string, string, int, string, int, string, List<(string name, string url, string plugin, int index)>>)Delegate.CreateDelegate(
                                            typeof(Func<string, long, string, long, string, string, string, int, string, int, string, List<(string name, string url, string plugin, int index)>>), m);
                                    }
                                }
                                catch { }

                                try
                                {
                                    var m2 = type.GetMethod("EventsAsync");
                                    if (m2 != null)
                                    {
                                        entry.EventsAsync = (Func<HttpContext, IMemoryCache, string, long, string, long, string, string, string, int, string, int, string, Task<List<(string name, string url, string plugin, int index)>>>)Delegate.CreateDelegate(
                                            typeof(Func<HttpContext, IMemoryCache, string, long, string, long, string, string, string, int, string, int, string, Task<List<(string name, string url, string plugin, int index)>>>), m2);
                                    }
                                }
                                catch { }
                            }

                            if (entry.Invoke != null || entry.InvokeAsync != null || entry.Events != null || entry.EventsAsync != null || entry.Spider != null || entry.SpiderAsync != null)
                                onlineModulesCache.Add(entry);
                        }
                        catch { }
                    }
                }
                catch { }
            }
        }

    }
}

```

## File: Shared/Models/Catalog/ContentParseSettings.cs
```
Ôªønamespace Shared.Models.Catalog
{
    public class ContentParseSettings
    {
        public string serial_regex { get; set; }

        public SingleNodeSettings serial_key { get; set; }

        public bool? jsonPath { get; set; }


        public string nodes { get; set; }

        public SingleNodeSettings name { get; set; }

        public SingleNodeSettings original_name { get; set; }

        public SingleNodeSettings href { get; set; }

        public SingleNodeSettings image { get; set; }

        public SingleNodeSettings year { get; set; }

        public List<SingleNodeSettings> args { get; set; }

        public SingleNodeSettings total_pages { get; set; }

        public string eval { get; set; }
    }
}

```

## File: Shared/Models/Catalog/MenuSettings.cs
```
Ôªønamespace Shared.Models.Catalog
{
    public class MenuSettings
    {
        public Dictionary<string, string> categories { get; set; }

        public Dictionary<string, string> sort { get; set; }

        public Dictionary<string, string> format { get; set; }

        public string defaultName { get; set; }

        public string catalog { get; set; }
    }
}

```

## File: Shared/Models/Catalog/CardParseSettings.cs
```
Ôªønamespace Shared.Models.Catalog
{
    public class CardParseSettings
    {
        public bool? jsonPath { get; set; }

        public string initUrl { get; set; }

        public string postData { get; set; }

        public string initHeader { get; set; }


        public string node { get; set; }

        public SingleNodeSettings name { get; set; }

        public SingleNodeSettings original_name { get; set; }

        public SingleNodeSettings image { get; set; }

        public SingleNodeSettings year { get; set; }

        public SingleNodeSettings description { get; set; }
    }
}

```

## File: Shared/Models/Catalog/PlaylistItem.cs
```
Ôªøusing Newtonsoft.Json.Linq;

namespace Shared.Models.Catalog
{
    public class PlaylistItem
    {
        public string id { get; set; }

        public bool is_serial { get; set; }

        public string title { get; set; }

        public string original_title { get; set; }

        public string img { get; set; }

        public string year { get; set; }

        public string card { get; set; }

        public JObject args { get; set; }
    }
}

```

## File: Shared/Models/Catalog/SingleNodeSettings.cs
```
Ôªønamespace Shared.Models.Catalog
{
    public class SingleNodeSettings
    {
        public string node { get; set; }

        public string attribute { get; set; }

        public string[] attributes { get; set; }


        public string format { get; set; }

        public string name_arg { get; set; }
    }
}

```

## File: Shared/Models/Catalog/CatalogSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Catalog
{
    public class CatalogSettings : BaseSettings, ICloneable
    {
        public CatalogSettings()
        {
            cache_time = 5;
        }

        public string args { get; set; }

        public bool hide { get; set; }

        public bool? jsonPath { get; set; }

        public bool search_lazy { get; set; } = true;

        public bool debug { get; set; }

        public int timeout { get; set; } = 10;

        public bool useDefaultHeaders { get; set; } = true;

        public List<Microsoft.Playwright.Cookie> cookies { get; set; }

        public bool ignore_no_picture { get; set; } = true;


        public string[] serial_cats { get; set; }

        public string[] movie_cats { get; set; }

        public string catalog_key { get; set; }

        public List<MenuSettings> menu { get; set; }


        public ListSettings search { get; set; }

        public ListSettings list { get; set; }

        public ContentParseSettings content { get; set; }


        public CardParseSettings card_parse { get; set; }

        public List<SingleNodeSettings> card_args { get; set; }

        public string[] tmdb_injects { get; set; }


        public CatalogSettings Clone()
        {
            return (CatalogSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Catalog/ListSettings.cs
```
Ôªønamespace Shared.Models.Catalog
{
    public class ListSettings
    {
        public string initUrl { get; set; }

        public string initHeader { get; set; }

        public int total_pages { get; set; }

        public int count_page { get; set; }

        public string firstpage { get; set; }

        public string uri { get; set; }

        public string postData { get; set; }

        public ContentParseSettings contentParse { get; set; }
    }
}

```

## File: Shared/Models/DLNA/CoverSettings.cs
```
Ôªøusing System.Diagnostics;

namespace Shared.Models.DLNA
{
    public class CoverSettings
    {
        public bool enable { get; set; }

        public bool consoleLog { get; set; }

        public bool preview { get; set; }

        public int timeout { get; set; }

        public int skipModificationTime { get; set; }

        public string extension { get; set; }

        public string coverComand { get; set; }

        public string previewComand { get; set; }

        public ProcessPriorityClass? priorityClass { get; set; }
    }
}

```

## File: Shared/Models/DLNA/DLNASettings.cs
```
Ôªønamespace Shared.Models.DLNA
{
    public class DLNASettings
    {
        public bool enable { get; set; }

        public string path { get; set; }

        public string mediaPattern { get; set; }

        public bool autoupdatetrackers { get; set; }

        public bool addTrackersToMagnet { get; set; }

        public int intervalUpdateTrackers { get; set; }

        public string mode { get; set; }

        public int downloadSpeed { get; set; }

        public int uploadSpeed { get; set; }

        public int maximumDiskReadRate { get; set; }

        public int maximumDiskWriteRate { get; set; }

        public CoverSettings cover { get; set; }
    }
}

```

## File: Shared/Models/JacRed/TorrentDetails.cs
```
Ôªøusing Shared.Models.JacRed.Tracks;

namespace Shared.Models.JacRed
{
    public class TorrentDetails : ICloneable
    {
        public string trackerName { get; set; }

        public string[] types { get; set; }

        public string url { get; set; }

        public HashSet<string> urls { get; set; }


        public string title { get; set; }

        public int sid { get; set; }

        public int pir { get; set; }

        public string sizeName { get; set; }

        public DateTime createTime { get; set; } = DateTime.UtcNow;

        public DateTime updateTime { get; set; } = DateTime.UtcNow;

        public DateTime checkTime { get; set; } = DateTime.Now;

        public string magnet { get; set; }

        public string parselink { get; set; }


        public string name { get; set; }

        public string originalname { get; set; }

        public int relased { get; set; }

        public double size { get; set; }

        public int quality { get; set; }

        public string videotype { get; set; }

        public HashSet<string> voices { get; set; } = new HashSet<string>();

        public HashSet<int> seasons { get; set; } = new HashSet<int>();


        public HashSet<string> languages { get; set; }

        public List<ffStream> ffprobe { get; set; }


        public object Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/JacRed/Tracks/ffTags.cs
```
Ôªønamespace Shared.Models.JacRed.Tracks
{
    public class ffTags
    {
        public string language { get; set; }

        public string BPS { get; set; }

        public string DURATION { get; set; }

        public string title { get; set; }
    }
}

```

## File: Shared/Models/JacRed/Tracks/ffStream.cs
```
Ôªønamespace Shared.Models.JacRed.Tracks
{
    public class ffStream
    {
        public int index { get; set; }

        public string codec_name { get; set; }

        public string codec_long_name { get; set; }

        public string codec_type { get; set; }

        public int? width { get; set; }

        public int? height { get; set; }

        public int? coded_width { get; set; }

        public int? coded_height { get; set; }

        public string sample_fmt { get; set; }

        public string sample_rate { get; set; }

        public int? channels { get; set; }

        public string channel_layout { get; set; }

        public string bit_rate { get; set; }

        public ffTags tags { get; set; }
    }
}

```

## File: Shared/Models/JacRed/Tracks/ffprobemodel.cs
```
Ôªønamespace Shared.Models.JacRed.Tracks
{
    public class ffprobemodel
    {
        public List<ffStream> streams { get; set; }
    }
}

```

## File: Shared/Models/Browser/KeepopenContext.cs
```
Ôªønamespace Shared.Models.Browser
{
    public class KeepopenContext
    {
        public bool keepopen { get; set; }

        public int keepalive { get; set; }

        public int min { get; set; }

        public int max { get; set; }
    }
}

```

## File: Shared/Models/Browser/KeepopenPage.cs
```
Ôªøusing Microsoft.Playwright;

namespace Shared.Models.Browser
{
    public class KeepopenPage
    {
        #region Firefox
        public IPage page { get; set; }

        public bool busy { get; set; }

        public DateTime lockTo { get; set; }
        #endregion


        public IBrowserContext context { get; set; }

        public DateTime lastActive { get; set; } = DateTime.Now;

        public DateTime create { get; set; } = DateTime.Now;


        public string plugin { get; set; }

        public  (string ip, string username, string password) proxy { get; set; }
    }
}

```

## File: Shared/Models/AppConf/KitConf.cs
```
Ôªøusing Newtonsoft.Json.Linq;

namespace Shared.Models.AppConf
{
    public class KitConf
    {
        public bool enable { get; set; }

        public string path { get; set; }

        public string eval_path { get; set; }

        public bool IsAllUsersPath { get; set; }

        public int cacheToSeconds { get; set; }

        public bool rhub_fallback { get; set; }

        [System.Text.Json.Serialization.JsonIgnore]
        [Newtonsoft.Json.JsonIgnore]
        public Dictionary<string, JObject> allUsers { get; set; }
    }


    public record KitConfEvalPath(string path, string uid);
}

```

## File: Shared/Models/AppConf/CmdConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class CmdConf
    {
        public string path { get; set; }

        public string arguments { get; set; }

        public string eval { get; set; }
    }
}

```

## File: Shared/Models/AppConf/OpenStatConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class OpenStatConf
    {
        public bool enable { get; set; }

        public string token { get; set; }
    }
}

```

## File: Shared/Models/AppConf/MediaApiConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class MediaApiConf
    {
        public string[] tokens { get; set; } = Array.Empty<string>();
    }
}
```

## File: Shared/Models/AppConf/OverrideResponse.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class OverrideResponse
    {
        public bool firstEndpoint { get; set; }

        public string pattern { get; set; }

        public string action { get; set; }

        public string type { get; set; }

        public string val { get; set; }
    }
}

```

## File: Shared/Models/AppConf/WebConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class WebConf
    {
        public bool autoupdate { get; set; }

        public string git { get; set; }

        public string tree { get; set; }

        public int intervalupdate { get; set; }

        public string index { get; set; }

        public string path { get; set; }

        public bool basetag { get; set; }

        public InitPlugins initPlugins { get; set; } = new InitPlugins();


        public Dictionary<string, string> appReplace { get; set; }

        public Dictionary<string, string> cssReplace { get; set; }
    }
}

```

## File: Shared/Models/AppConf/FfprobeSettings.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class FfprobeSettings
    {
        public bool enable { get; set; }

        public string tsuri { get; set; }
    }
}

```

## File: Shared/Models/AppConf/Known.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class Known
    {
        public string ip { get; set; }

        public int prefixLength { get; set; }
    }
}

```

## File: Shared/Models/AppConf/FileCacheConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class FileCacheConf
    {
        public int html { get; set; }

        public int torrent { get; set; }

        public int hls { get; set; }
    }
}

```

## File: Shared/Models/AppConf/TmdbConf.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.AppConf
{
    public class TmdbConf : Iproxy
    {
        public bool enable { get; set; }

        public int httpversion { get; set; }

        public string api_key { get; set; }


        public string DNS { get; set; }

        public int DNS_TTL { get; set; }


        public string API_IP { get; set; }

        public string API_Minor { get; set; }


        public string IMG_IP { get; set; }

        public string IMG_Minor { get; set; }


        public int cache_api { get; set; }

        public int cache_img { get; set; }

        public bool check_img { get; set; }


        public bool useproxy { get; set; }

        public bool useproxystream { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }
    }
}

```

## File: Shared/Models/AppConf/RchConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class RchConf
    {
        public bool enable { get; set; }

        public string websoket { get; set; }

        public bool requiredConnected { get; set; }

        public string notSupportMsg { get; set; }

        public string[] blacklistHost { get; set; }
    }
}

```

## File: Shared/Models/AppConf/WebLogConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class WebLogConf
    {
        public bool enable { get; set; }

        public string token { get; set; }
    }
}

```

## File: Shared/Models/AppConf/InitPlugins.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class InitPlugins
    {
        public bool dlna { get; set; } = true;

        public bool tracks { get; set; } = true;

        public bool transcoding { get; set; }

        public bool tmdbProxy { get; set; } = true;

        public bool online { get; set; } = true;

        public bool catalog { get; set; } = true;

        public bool sisi { get; set; } = true;

        public bool torrserver { get; set; } = true;

        public bool backup { get; set; } = true;


        public bool sync { get; set; } = true;

        public bool bookmark { get; set; }

        public bool timecode { get; set; }
    }
}

```

## File: Shared/Models/AppConf/StorageConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class StorageConf
    {
        public bool enable { get; set; }

        public long max_size { get; set; }

        public bool brotli { get; set; }

        public bool md5name { get; set; }
    }
}

```

## File: Shared/Models/AppConf/CubConf.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.AppConf
{
    public class CubConf : Iproxy
    {
        public bool enable { get; set; }

        public string[] geo { get; set; }

        public bool viewru { get; set; }


        public string domain { get; set; }

        public string scheme { get; set; }

        public string mirror { get; set; }


        public int cache_api { get; set; }

        public int cache_img { get; set; }


        public bool useproxy { get; set; }

        public bool useproxystream { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }


        public bool enabled(string country)
        {
            bool cubproxy = enable;
            if (cubproxy && geo != null)
                cubproxy = geo.Contains(country);

            return cubproxy;
        }
    }
}

```

## File: Shared/Models/AppConf/GCConf.cs
```
namespace Shared.Models.AppConf
{
    public class GCConf
    {
        public bool enable { get; set; }

        public bool aggressive { get; set; }

        public bool? Concurrent { get; set; }

        public int? ConserveMemory { get; set; }

        public int? HighMemoryPercent { get; set; }

        public bool? RetainVM { get; set; }
    }
}

```

## File: Shared/Models/AppConf/TracksTranscodingConf.cs
```
Ôªøusing Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Shared.Models.AppConf
{
    public class TranscodingConf
    {
        public bool enable { get; set; }

        public string ffmpeg { get; set; }

        public string tempRoot { get; set; }

        public int idleTimeoutSec { get; set; }

        public int idleTimeoutSec_live { get; set; }

        public bool defaultSubtitles { get; set; }

        public int maxConcurrentJobs { get; set; }

        public string[] allowHosts { get; set; } = Array.Empty<string>();

        public TranscodingHlsOptions hlsOptions { get; set; } = new();

        public TranscodingAudioOptions audioOptions { get; set; } = new();

        public TranscodingSubtitleOptions subtitleOptions { get; set; } = new();

        public TranscodingPlaylistOptions playlistOptions { get; set; } = new();

        public TranscodingConvertOptions convertOptions { get; set; } = new();

        [JsonProperty("comand", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string[]> comand { get; set; } = new Dictionary<string, string[]>()
        {
            ["demuxer"] = ["-threads 0", "-fflags +genpts"],
            ["input"] = ["-avoid_negative_ts disabled"],
            ["output"] = [
                "-map 0:v:0", "-map 0:a:{audio_index}",
                "-dn", "-sn",
                "-map_metadata -1", "-map_chapters -1", "-max_muxing_queue_size 2048"
            ],
        };
    }

    public class TranscodingHlsOptions
    {
        [JsonIgnore]
        public int seek { get; set; }

        /// <summary>
        /// hls_time
        /// </summary>
        public int segDur { get; set; } = 6;

        /// <summary>
        /// hls_list_size
        /// </summary>
        public int winSize { get; set; } = 10;

        /// <summary>
        /// hls_segment_type fmp4 / mpegts
        /// </summary>
        public bool fmp4 { get; set; } = true;

        [JsonProperty("comand", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string[]> comand { get; set; } = new Dictionary<string, string[]>()
        {
            ["output"] = ["-max_delay 5000000"],
            ["segment_mpegts"] = ["-bsf:v h264_mp4toannexb"],
        };
    }

    public class TranscodingAudioOptions
    {
        [JsonIgnore]
        public int index { get; set; }

        public int bitrateKbps { get; set; } = 192;

        public bool stereo { get; set; } = true;

        [JsonProperty("codec_copy", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public string[] codec_copy { get; set; } = Array.Empty<string>();

        [JsonProperty("comand_transcode", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string[]> comand_transcode { get; set; } = new Dictionary<string, string[]>()
        {
            ["default"] = ["-c:a aac", "-ac {stereo}", "-b:a {bitrateKbps}", "-profile:a aac_low"]
        };
    }

    public class TranscodingPlaylistOptions
    {
        /// <summary>
        /// sped
        /// </summary>
        public double readrate { get; set; } = 1.6;

        /// <summary>
        /// 10 MB
        /// </summary>
        public int burst { get; set; } = 10485760;

        public bool delete_segments { get; set; } = true;
    }

    public class TranscodingConvertOptions
    {
        public bool transcodeVideo { get; set; }

        [JsonProperty("codec", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public string[] codec { get; set; } = { "mpeg4", "msmpeg4v3", "flv1", "av1" };

        [JsonProperty("comand", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string[]> comand { get; set; } = new Dictionary<string, string[]>()
        {
            ["default"] = ["-c:v libx264", "-preset veryfast", "-tune zerolatency", "-pix_fmt yuv420p"],
            
            ["h264_yuv420p10le"] = [
                "-vf", "scale=in_color_matrix=bt2020nc:out_color_matrix=bt709:in_range=pc:out_range=tv,format=yuv420p",
                "-c:v libx264", "-preset veryfast", "-tune zerolatency", "-pix_fmt yuv420p",
                "-x264-params", "colorprim=bt709:transfer=bt709:colormatrix=bt709",
                "-color_primaries bt709", "-color_trc bt709", "-colorspace bt709", "-color_range tv"
            ]
        };
    }

    public class TranscodingSubtitleOptions
    {
        [JsonProperty("codec", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public string[] codec { get; set; } = { "subrip", "webvtt", "ass", "ssa", "mov_text", "ttml", "sami" };

        [JsonProperty("comand", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public string[] comand { get; set; } = ["-map 0:{subIndex}", "-an -vn", "-c:s webvtt", "-flush_packets 1", "-max_interleave_delta 0", "-muxpreload 0", "-muxdelay 0", "-f webvtt", "subs_{subIndex}.vtt"];
    }

    public record TranscodingStartContext(
        Uri Source,
        string UserAgent,
        string Referer,
        TranscodingHlsOptions HlsOptions,
        TranscodingAudioOptions Audio,
        bool live,
        bool subtitles,
        string OutputDirectory,
        int? startNumber,
        JObject ffprobe
    );
}

```

## File: Shared/Models/AppConf/OnlineConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class OnlineConf
    {
        public string findkp { get; set; }

        public bool checkOnlineSearch { get; set; }

        public bool spider { get; set; }

        public string spiderName { get; set; }


        public string component { get; set; }

        public string name { get; set; }

        public string description { get; set; }

        public bool version { get; set; }

        public bool btn_priority_forced { get; set; }

        public bool showquality { get; set; }


        public string apn { get; set; }

        public Dictionary<string, string> appReplace { get; set; }


        public List<string> with_search { get; set; }
    }
}

```

## File: Shared/Models/AppConf/HybridCacheConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class HybridCacheConf
    {
        public string type { get; set; }

        public int extend { get; set; }
    }
}

```

## File: Shared/Models/AppConf/AccsConf.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Shared.Models.Base;
using System.Collections.Concurrent;

namespace Shared.Models.AppConf
{
    public class AccsConf
    {
        public bool enable { get; set; }

        public string shared_passwd { get; set; }

        public int shared_daytime { get; set; }

        public string whitepattern { get; set; }

        public HashSet<string> white_uids { get; set; }

        public string premium_pattern { get; set; }

        public string domainId_pattern { get; set; }

        public int maxip_hour { get; set; }

        public int maxrequest_hour { get; set; }

        public int maxlock_day { get; set; }

        public int blocked_hour { get; set; }

        public string authMesage { get; set; }

        public string denyMesage { get; set; }

        public string denyGroupMesage { get; set; }

        public string expiresMesage { get; set; }

        public Dictionary<string, object> @params { get; set; }

        public Dictionary<string, DateTime> accounts { get; set; } = new Dictionary<string, DateTime>();

        public ConcurrentBag<AccsUser> users { get; set; } = new ConcurrentBag<AccsUser>();


        public AccsUser findUser(HttpContext httpContext, out string uid)
        {
            var user = findUser(httpContext.Request.Query["token"].ToString()) ??
                       findUser(httpContext.Request.Query["account_email"].ToString()) ??
                       findUser(httpContext.Request.Query["uid"].ToString()) ??
                       findUser(httpContext.Request.Query["box_mac"].ToString());

            if (user != null)
            {
                uid = user.id;
                return user;
            }

            uid = null;
            return null;
        }

        public AccsUser findUser(string uid)
        {
            if (string.IsNullOrEmpty(uid))
                return null;

            uid = uid.ToLower().Trim();
            return users.FirstOrDefault(i => (i.id != null && i.id.ToLower() == uid) || (i.ids != null && i.ids.FirstOrDefault(id => id.ToLower() == uid) != null));
        }
    }
}

```

## File: Shared/Models/AppConf/SyncUserConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class SyncUserConf
    {
        public bool enable { get; set; }

        public int version { get; set; }

        public bool fullset { get; set; }
    }
}

```

## File: Shared/Models/AppConf/WafConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class WafConf
    {
        public bool enable { get; set; }

        public List<string> whiteIps { get; set; }

        public int limit_req { get; set; }

        /// <summary>
        /// uri_pattern: limit_req
        /// </summary>
        public Dictionary<string, int> limit_map { get; set; }

        public List<string> ipsDeny { get; set; }

        public List<string> ipsAllow { get; set; }

        public List<string> countryDeny { get; set; }

        public List<string> countryAllow { get; set; }

        /// <summary>
        /// header_key: regex
        /// </summary>
        public Dictionary<string, string> headersDeny { get; set; }
    }
}

```

## File: Shared/Models/AppConf/CorseuConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class CorseuConf
    {
        public string[] tokens { get; set; }
    }
}
```

## File: Shared/Models/AppConf/ListenConf.cs
```
using Microsoft.AspNetCore.Server.Kestrel.Core;

namespace Shared.Models.AppConf
{
    public class ListenConf
    {
        public string ip { get; set; }

        public int port { get; set; }

        public bool compression { get; set; }

        public string sock { get; set; }

        public string scheme { get; set; }

        public string host { get; set; }

        public string frontend { get; set; }

        public string localhost { get; set; }

        public int? keepalive { get; set; }

        public HttpProtocols? endpointDefaultsProtocols { get; set; }
    }
}

```

## File: Shared/Models/AppConf/CronTime.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class CronTime
    {
        public int updateLampaWeb;

        public int clearCache;

        public int updateTrackers;
    }
}

```

## File: Shared/Models/AppConf/PuppeteerConf.cs
```
Ôªøusing Shared.Models.Browser;

namespace Shared.Models.AppConf
{
    public class PuppeteerConf
    {
        public bool enable { get; set; }

        public KeepopenContext context { get; set; }

        public bool Headless { get; set; }

        public bool DEV { get; set; }

        public bool consoleLog { get; set; }

        public bool Devtools { get; set; }

        public string executablePath { get; set; }

        public string[] Args { get; set; }
    }
}

```

## File: Shared/Models/AppConf/SyncConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class SyncConf
    {
        public bool enable { get; set; }

        /// <summary>
        /// master
        /// slave
        /// </summary>
        public string type { get; set; }

        public string initconf { get; set; }

        public bool sync_full { get; set; } = true;

        public string api_host { get; set; }

        public string api_passwd { get; set; }

        public Dictionary<string, string> override_conf { get; set; }
    }
}

```

## File: Shared/Models/Templates/EpisodeTpl.cs
```
Ôªøusing Shared.Models.Base;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Web;

namespace Shared.Models.Templates
{
    public struct EpisodeTpl
    {
        public List<(string name, string title, string s, string e, string link, string method, StreamQualityTpl? streamquality, SubtitleTpl? subtitles, string streamlink, string voice_name, VastConf vast, List<HeadersModel> headers, int? hls_manifest_timeout, SegmentTpl? segments, string subtitles_call)> data { get; set; }

        public EpisodeTpl() : this(20) { }

        public EpisodeTpl(int capacity) 
        {
            data = new List<(string, string, string, string, string, string, StreamQualityTpl?, SubtitleTpl?, string, string, VastConf, List<HeadersModel>, int?, SegmentTpl?, string)>(capacity);
        }

        public void Append(string name, string title, string s, string e, string link, string method = "play", in StreamQualityTpl? streamquality = null, in SubtitleTpl? subtitles = null, string streamlink = null, string voice_name = null, VastConf vast = null, List<HeadersModel> headers = null, int? hls_manifest_timeout = null, SegmentTpl? segments = null, string subtitles_call = null)
        {
            if (!string.IsNullOrEmpty(name) && !string.IsNullOrEmpty(link))
                data.Add((name, $"{title} ({e} —Å–µ—Ä–∏—è)", s, e, link, method, streamquality, subtitles, streamlink, voice_name, vast, headers, hls_manifest_timeout, segments, subtitles_call));
        }

        public string ToHtml()
        {
            if (data.Count == 0)
                return string.Empty;

            bool firstjson = true;
            var html = new StringBuilder();
            html.Append("<div class=\"videos__line\">");

            foreach (var i in data) 
            {
                var vast = i.vast ?? AppInit.conf.vast;

                string datajson = JsonSerializer.Serialize(new
                {
                    i.method,
                    url = i.link,
                    i.title,
                    stream = i.streamlink,
                    headers = i.headers != null ? i.headers.ToDictionary(k => k.name, v => v.val) : null,
                    quality = i.streamquality?.ToObject(emptyToNull: true),
                    subtitles = i.subtitles?.ToObject(emptyToNull: true),
                    i.subtitles_call,
                    i.voice_name,
                    i.hls_manifest_timeout,
                    vast = vast?.url != null ? vast : null,
                    i.segments

                }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault });

                html.Append($"<div class=\"videos__item videos__movie selector {(firstjson ? "focused" : "")}\" media=\"\" s=\"{i.s}\" e=\"{i.e}\" data-json='{datajson}'><div class=\"videos__item-imgbox videos__movie-imgbox\"></div><div class=\"videos__item-title\">{HttpUtility.HtmlEncode(i.name)}</div></div>");
                firstjson = false;
            }

            return html.ToString() + "</div>";
        }

        public string ToJson(in VoiceTpl? vtpl = null)
        {
            if (data.Count == 0)
                return "[]";

            return JsonSerializer.Serialize(new
            {
                type = "episode",
                voice = vtpl?.ToObject(),
                data = data.Select(i => new
                {
                    i.method,
                    url = i.link,
                    stream = i.streamlink,
                    headers = i.headers != null ? i.headers.ToDictionary(k => k.name, v => v.val) : null,
                    quality = i.streamquality?.ToObject(emptyToNull: true),
                    subtitles = i.subtitles?.ToObject(emptyToNull: true),
                    i.subtitles_call,
                    s = int.TryParse(i.s, out int _s) ? _s : 0,
                    e = int.TryParse(i.e, out int _e) ? _e : 0,
                    details = i.voice_name,
                    i.name,
                    i.title,
                    i.hls_manifest_timeout,
                    vast = (i.vast ?? AppInit.conf.vast)?.url != null ? (i.vast ?? AppInit.conf.vast) : null,
                    i.segments
                })
            }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull });
        }
    }
}

```

## File: Shared/Models/Templates/VideoTpl.cs
```
Ôªøusing Shared.Models.Base;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Shared.Models.Templates
{
    public static class VideoTpl
    {
        public static string ToJson(string method, string url, string title, in StreamQualityTpl? streamquality = null, in SubtitleTpl? subtitles = null, string quality = null, VastConf vast = null, List<HeadersModel> headers = null, int? hls_manifest_timeout = null, SegmentTpl? segments = null, string subtitles_call = null)
        {
            var _vast = vast ?? AppInit.conf.vast;

            return JsonSerializer.Serialize(new
            {
                title,
                method,
                url,
                headers = headers != null ? headers.ToDictionary(k => k.name, v => v.val) : null,
                quality = streamquality?.ToObject(emptyToNull: true) ?? new StreamQualityTpl(new List<(string, string)>() { (url, quality??"auto") }).ToObject(),
                subtitles = subtitles?.ToObject(emptyToNull: true),
                subtitles_call,
                hls_manifest_timeout,
                vast = _vast?.url != null ? _vast : _vast,
                segments = segments?.ToObject()

            }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault });
        }
    }
}

```

## File: Shared/Models/Templates/VoiceTpl.cs
```
Ôªøusing System.Text;
using System.Text.Json;
using System.Web;

namespace Shared.Models.Templates
{
    public struct VoiceTpl
    {
        public List<(string name, bool active, string link)> data { get; set; }

        public VoiceTpl() : this(15) { }

        public VoiceTpl(int capacity) { data = new List<(string, bool, string)>(capacity); }

        public void Append(string name, bool active, string link)
        {
            if (!string.IsNullOrEmpty(name))
                data.Add((name, active, link));
        }

        public string ToHtml()
        {
            if (data.Count == 0)
                return string.Empty;

            var html = new StringBuilder();
            html.Append("<div class=\"videos__line\">");

            foreach (var i in data)
                html.Append("<div class=\"videos__button selector " + (i.active ? "active" : "") + "\" data-json='{\"method\":\"link\",\"url\":\"" + i.link + "\"}'>" + HttpUtility.HtmlEncode(i.name) + "</div>");

            return html.ToString() + "</div>";
        }

        public string ToJson() => JsonSerializer.Serialize(ToObject());

        public object ToObject()
        {
            if (data.Count == 0)
                return new List<string>();

            return data.Select(i => new 
            {
                method = "link",
                url = i.link,
                i.active,
                i.name
            });
        }
    }
}

```

## File: Shared/Models/Templates/SeasonTpl.cs
```
Ôªøusing System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Web;

namespace Shared.Models.Templates
{
    public struct SeasonTpl
    {
        public List<(string name, string link, int? id)> data { get; set; }

        public string quality = null;

        public SeasonTpl() : this(10) { }

        public SeasonTpl(int capacity) { data = new List<(string, string, int?)>(capacity); }

        public SeasonTpl(string quality, int capacity = 10) 
        {
            data = new List<(string, string, int?)>(capacity);
            this.quality = quality; 
        }

        public void Append(string name, string link, string id)
        {
            int.TryParse(id, out int sid);
            Append(name, link, sid);
        }

        public void Append(string name, string link, int id)
        {
            if (!string.IsNullOrEmpty(name))
                data.Add((name, link, id));
        }

        public string ToHtml(in VoiceTpl? vtpl = null)
        {
            if (data.Count == 0)
                return string.Empty;

            bool firstjson = true;
            var html = new StringBuilder();

            if (vtpl != null)
                html.Append(vtpl?.ToHtml());

            html.Append("<div class=\"videos__line\">");

            if (!string.IsNullOrEmpty(quality))
                html.Append($"<!--q:{quality}-->");

            foreach (var i in data) 
            {
                html.Append("<div class=\"videos__item videos__season selector " + (firstjson ? "focused" : "") + "\" data-json='{\"method\":\"link\",\"url\":\"" + i.link + "\"}'><div class=\"videos__season-layers\"></div><div class=\"videos__item-imgbox videos__season-imgbox\"><div class=\"videos__item-title videos__season-title\">" + HttpUtility.HtmlEncode(i.name) + "</div></div></div>");
                firstjson = false;
            }

            return html.ToString() + "</div>";
        }

        public string ToJson(in VoiceTpl? vtpl = null)
        {
            if (data.Count == 0)
                return "[]";

            return JsonSerializer.Serialize(new
            {
                type = "season",
                maxquality = quality,
                voice = vtpl?.ToObject(),
                data = data.Select(i => new
                {
                    i.id,
                    method = "link",
                    url = i.link,
                    i.name
                })
            }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull });
        }
    }
}

```

## File: Shared/Models/Templates/SimilarTpl.cs
```
Ôªøusing System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Web;

namespace Shared.Models.Templates
{
    public struct SimilarTpl
    {
        public List<(string title, string year, string details, string link, string img)> data { get; set; }

        public SimilarTpl() : this(20) { }

        public SimilarTpl(int capacity) { data = new List<(string, string, string, string, string)>(capacity); }


        public string OnlineSplit => "{prestige-split}";


        public void Append(string title, string year, string details, string link, string img = null)
        {
            if (!string.IsNullOrEmpty(title))
                data.Add((title, year, details, link, img));
        }

        public string ToHtml()
        {
            if (data.Count == 0)
                return string.Empty;

            bool firstjson = true;
            var html = new StringBuilder();
            html.Append("<div class=\"videos__line\">");

            foreach (var i in data) 
            {
                string datajson = JsonSerializer.Serialize(new
                {
                    method = "link",
                    url = i.link,
                    similar = true,
                    year = i.year != null && int.TryParse(i.year, out int _year) ? _year : 0,
                    i.details,
                    i.img

                }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault });

                datajson = datajson.Replace("{prestige-split}", "<span class=\\\"online-prestige-split\\\">‚óè</span>");

                html.Append($"<div class=\"videos__item videos__season selector {(firstjson ? "focused" : "")}\" data-json='{datajson}'><div class=\"videos__season-layers\"></div><div class=\"videos__item-imgbox videos__season-imgbox\"><div class=\"videos__item-title videos__season-title\">{HttpUtility.HtmlEncode(i.title)}</div></div></div>");
                firstjson = false;
            }

            return html.ToString() + "</div>";
        }


        public string ToJson()
        {
            if (data.Count == 0)
                return "[]";

            return JsonSerializer.Serialize(new 
            {
                type = "similar",
                data = data.Select(i => new 
                {
                    url = i.link,
                    details = i.details?.Replace("{prestige-split}", "<span class=\"online-prestige-split\">‚óè</span>"),
                    i.title,
                    year = int.TryParse(i.year, out int _year) ? _year : 0,
                    i.img
                })
            }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault });
        }
    }
}

```

## File: Shared/Models/Templates/SubtitleTpl.cs
```
Ôªøusing System.Text.Json;

namespace Shared.Models.Templates
{
    public struct SubtitleTpl
    {
        public List<(string label, string url)> data { get; set; }

        public SubtitleTpl() : this(10) { }

        public SubtitleTpl(int capacity) { data = new List<(string, string)>(capacity); }

        public bool IsEmpty() => data.Count == 0;

        public void Append(string label, string url)
        {
            if (!string.IsNullOrEmpty(label) && !string.IsNullOrEmpty(url))
                data.Add((label, url));
        }

        public string ToJson() => JsonSerializer.Serialize(ToObject());

        public object ToObject(bool emptyToNull = false)
        {
            if (data.Count == 0)
                return emptyToNull ? null : new List<string>();

            return data.Select(i => new
            {
                method = "link",
                i.url,
                i.label
            });
        }
    }
}

```

## File: Shared/Models/Templates/MovieTpl.cs
```
Ôªøusing System.Text;
using System.Text.Json.Serialization;
using System.Text.Json;
using System.Web;
using Shared.Models.Base;

namespace Shared.Models.Templates
{
    public struct MovieTpl
    {
        string title, original_title;

        public List<(string voiceOrQuality, string link, string method, string stream, StreamQualityTpl? streamquality, SubtitleTpl? subtitles, string voice_name, string year, string details, string quality, VastConf vast, List<HeadersModel> headers, int? hls_manifest_timeout, SegmentTpl? segments, string subtitles_call)> data { get; set; }

        public MovieTpl(string title) : this(title, null, 15) { }

        public MovieTpl(string title, string original_title) : this(title, original_title, 15) { }

        public MovieTpl(string title, string original_title, int capacity) 
        {
            this.title = title;
            this.original_title = original_title;
            data = new List<(string, string, string, string, StreamQualityTpl?, SubtitleTpl?, string, string, string, string, VastConf vast, List<HeadersModel>, int?, SegmentTpl?, string)> (capacity); 
        }

        public bool IsEmpty() => data.Count == 0;

        public void Append(string voiceOrQuality, string link, string method = "play", string stream = null, in StreamQualityTpl? streamquality = null, in SubtitleTpl? subtitles = null, string voice_name = null, string year = null, string details = null, string quality = null, VastConf vast = null, List<HeadersModel> headers = null, int? hls_manifest_timeout = null, SegmentTpl? segments = null, string subtitles_call = null)
        {
            if (!string.IsNullOrEmpty(voiceOrQuality) && !string.IsNullOrEmpty(link))
                data.Add((voiceOrQuality, link, method, stream, streamquality, subtitles, voice_name, year, details, quality, vast, headers, hls_manifest_timeout, segments, subtitles_call));
        }

        public string ToHtml(string voiceOrQuality, string link, string method = "play", string stream = null, in StreamQualityTpl? streamquality = null, in SubtitleTpl? subtitles = null, string voice_name = null, string year = null, string details = null, string quality = null, VastConf vast = null, List<HeadersModel> headers = null, int? hls_manifest_timeout = null, SegmentTpl? segments = null, string subtitles_call = null)
        {
            Append(voiceOrQuality, link, method, stream, streamquality, subtitles, voice_name, year, details, quality, vast, headers, hls_manifest_timeout, segments, subtitles_call);
            return ToHtml();
        }

        public string ToHtml(bool reverse = false)
        {
            if (data.Count == 0)
                return string.Empty;

            bool firstjson = true;
            var html = new StringBuilder();
            html.Append("<div class=\"videos__line\">");

            if (reverse)
                data.Reverse();

            foreach (var i in data) 
            {
                var vast = i.vast ?? AppInit.conf.vast;

                string datajson = JsonSerializer.Serialize(new
                {
                    i.method,
                    url = i.link,
                    i.stream,
                    headers = i.headers != null ? i.headers.ToDictionary(k => k.name, v => v.val) : null,
                    quality = i.streamquality?.ToObject(emptyToNull: true),
                    subtitles = i.subtitles?.ToObject(emptyToNull: true),
                    i.subtitles_call,
                    translate = i.voiceOrQuality,
                    maxquality = i.streamquality?.MaxQuality() ?? i.quality,
                    i.voice_name,
                    i.details,
                    year = int.TryParse(i.year, out int _year) ? _year : 0,
                    title = $"{title ?? original_title} ({i.voiceOrQuality})",
                    i.hls_manifest_timeout,
                    vast = vast?.url != null ? vast : null,
                    i.segments

                }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault });

                html.Append($"<div class=\"videos__item videos__movie selector {(firstjson ? "focused" : "")}\" media=\"\" data-json='{datajson}'><div class=\"videos__item-imgbox videos__movie-imgbox\"></div><div class=\"videos__item-title\">{HttpUtility.HtmlEncode(i.voiceOrQuality)}</div></div>");
                firstjson = false;

                if (!string.IsNullOrEmpty(i.quality))
                    html.Append($"<!--{i.quality}p-->");
            }

            return html.ToString() + "</div>";
        }

        public string ToJson(bool reverse = false, in VoiceTpl? vtpl = null)
        {
            if (data.Count == 0)
                return "[]";

            if (reverse)
                data.Reverse();

            string name = title ?? original_title;

            return JsonSerializer.Serialize(new
            {
                type = "movie",
                voice = vtpl?.ToObject(),
                data = data.Select(i => new
                {
                    i.method,
                    url = i.link,
                    i.stream,
                    headers = i.headers != null ? i.headers.ToDictionary(k => k.name, v => v.val) : null,
                    quality = i.streamquality?.ToObject(emptyToNull: true),
                    subtitles = i.subtitles?.ToObject(emptyToNull: true),
                    i.subtitles_call,
                    translate = i.voiceOrQuality,
                    maxquality = i.streamquality?.MaxQuality() ?? i.quality,
                    details = (i.voice_name == null && i.details == null) ? null : (i.voice_name + i.details),
                    year = int.TryParse(i.year, out int _year) ? _year : 0,
                    title = $"{name} ({i.voiceOrQuality})",
                    i.hls_manifest_timeout,
                    vast = (i.vast ?? AppInit.conf.vast)?.url != null ? (i.vast ?? AppInit.conf.vast) : null,
                    i.segments
                })
            }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault });
        }
    }
}

```

## File: Shared/Models/Templates/StreamQualityTpl.cs
```
using Shared.Models.Events;
using System.Text.Json;

namespace Shared.Models.Templates
{
    public struct StreamQualityTpl
    {
        public List<(string link, string quality)> data { get; set; } = new List<(string, string)>(8);

        public StreamQualityTpl() { }

        public StreamQualityTpl(IEnumerable<(string link, string quality)> streams) 
        {
            if (streams != null)
            {
                foreach (var item in streams)
                    Append(item.link, item.quality);
            }
        }

        public bool Any() => data.Any();

        public void Append(string link, string quality)
        {
            if (string.IsNullOrEmpty(quality))
                return;

            var eventResult = InvkEvent.StreamQuality(new EventStreamQuality(link, quality, prepend: false));
            if (eventResult.next.HasValue && !eventResult.next.Value)
                return;

            link = eventResult.link ?? link;

            if (!string.IsNullOrEmpty(link))
                data.Add((link, quality));
        }

        public void Insert(string link, string quality)
        {
            if (string.IsNullOrEmpty(quality))
                return;

            var eventResult = InvkEvent.StreamQuality(new EventStreamQuality(link, quality, prepend: true));
            if (eventResult.next.HasValue && !eventResult.next.Value)
                return;

            link = eventResult.link ?? link;

            if (!string.IsNullOrEmpty(link))
                data.Insert(0, (link, quality));
        }

        public string ToJson() => JsonSerializer.Serialize(ToObject());

        public Dictionary<string, string> ToObject(bool emptyToNull = false)
        {
            var result = new Dictionary<string, string>();
            foreach (var item in data)
                result.TryAdd(item.quality, item.link);

            if (emptyToNull && result.Count == 0)
                return null;

            return result;
        }

        public string MaxQuality()
        {
            if (data.Count == 0)
                return string.Empty;

            return data[0].quality;
        }

        public (string link, string quality) Firts()
        {
            if (data.Count == 0)
                return default;

            var eventResult = InvkEvent.StreamQualityFirts(new EventStreamQualityFirts(data));

            return eventResult ?? data[0];
        }
    }
}

```

## File: Shared/Models/Templates/SegmentTpl.cs
```
Ôªønamespace Shared.Models.Templates
{
    public struct SegmentTpl
    {
        public List<(int start, int end)> ads { get; set; }

        public List<(int start, int end)> skips { get; set; }

        public SegmentTpl()
        {
            ads = new List<(int, int)>();
            skips = new List<(int, int)>();
        }

        public bool IsEmpty() => ads.Count == 0 && skips.Count == 0;

        public void ad(int start, int end)
        {
            if (start >= 0 && end >= 0 && end >= start)
                ads.Add((start == 0 ? 1 : start, end));
        }

        public void skip(int start, int end)
        {
            if (start >= 0 && end >= 0 && end >= start)
                skips.Add((start == 0 ? 1 : start, end));
        }

        public object ToObject()
        {
            if (IsEmpty())
                return null;

            var adList = ads.Select(i => new { i.start, i.end }).ToList();
            var skipList = skips.Select(i => new { i.start, i.end }).ToList();

            return new { ad = adList, skip = skipList };
        }
    }
}

```

## File: Shared/Models/Online/ApiModel.cs
```
Ôªønamespace Shared.Models.Online
{
    public class ApiModel
    {
        public string title { get; set; }

        public string stream_url { get; set; }

        public List<(string link, string quality)> streams { get; set; } = new List<(string link, string quality)>();

        public List<ApiModel> submenu { get; set; }

        /// <summary>
        /// voice
        /// season
        /// episode
        /// </summary>
        public string type { get; set; }
    }
}

```

## File: Shared/Models/Online/Mirage.cs
```
Ôªønamespace Shared.Models.Online.Mirage
{
    public record AcDecode(string baer);
}

```

## File: Shared/Models/Online/CDNmovies/Episode.cs
```
Ôªønamespace Shared.Models.Online.CDNmovies
{
    public struct Episode
    {
        public string title { get; set; }

        public string file { get; set; }
    }
}

```

## File: Shared/Models/Online/CDNmovies/Voice.cs
```
Ôªønamespace Shared.Models.Online.CDNmovies
{
    public struct Voice
    {
        public string title { get; set; }

        public Season[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/CDNmovies/Season.cs
```
Ôªønamespace Shared.Models.Online.CDNmovies
{
    public struct Season
    {
        public string title { get; set; }

        public Episode[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/Settings/KinoPubSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class KinoPubSettings : BaseSettings, ICloneable
    {
        public KinoPubSettings(string plugin, string host = null)
        {
            this.plugin = plugin;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);
        }

        public string[] tokens { get; set; }

        public string filetype { get; set; }


        public KinoPubSettings Clone()
        {
            return (KinoPubSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/KodikSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class KodikSettings : BaseSettings, ICloneable
    {
        public KodikSettings(string plugin, string apihost, string linkhost, string token, string secret_token, bool localip, bool enable = true, bool hls = true, bool streamproxy = false)
        {
            this.plugin = plugin;
            this.secret_token = secret_token;
            this.localip = localip;
            this.enable = enable;
            this.hls = hls;
            this.streamproxy = streamproxy;

            this.linkhost = linkhost.StartsWith("http") ? linkhost : Decrypt(linkhost)!;
            this.apihost = apihost.StartsWith("http") ? apihost : Decrypt(apihost);
            this.token = token.Contains(":") ? Decrypt(token)! : token;
        }

        public bool auto_proxy { get; set; }

        public bool cdn_is_working { get; set; }

        public string secret_token { get; set; }

        public string linkhost { get; set; }

        public bool localip { get; set; }

        public KodikSettings Clone()
        {
            return (KodikSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/IframeVideoSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class IframeVideoSettings : BaseSettings, ICloneable
    {
        public IframeVideoSettings(string plugin, string host, string cdnhost, bool enable = true)
        {
            this.cdnhost = cdnhost;
            this.enable = enable;
            this.plugin = plugin;

            if (host != null)
                apihost = host.StartsWith("http") ? host : Decrypt(host);
        }

        public string cdnhost { get; set; }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/LumexSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class LumexSettings : BaseSettings, ICloneable
    {
        public LumexSettings(string plugin, string apihost, string token, string iframehost, string clientId)
        {
            this.plugin = plugin;

            if (apihost != null)
                this.apihost = apihost.StartsWith("http") ? apihost : Decrypt(apihost);

            if (iframehost != null)
                this.iframehost = iframehost.StartsWith("http") ? iframehost : (iframehost.Contains("{") ? Decrypt(iframehost) : iframehost);

            if (token != null)
                this.token = (token.Contains(":") || token.Contains("{")) ? Decrypt(token) : token;

            this.clientId = clientId;
        }


        public string clientId { get; set; }

        public string iframehost { get; set; }


        public string username { get; set; }

        public string password { get; set; }

        public string domain { get; set; }

        public bool disable_protection { get; set; }

        public bool disable_ads { get; set; }

        public bool log { get; set; }

        public bool verifyip { get; set; }


        public LumexSettings Clone()
        {
            return (LumexSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/CollapsSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class CollapsSettings : BaseSettings, ICloneable
    {
        public CollapsSettings(string plugin, string host, bool enable = true, bool streamproxy = false, bool two = false)
        {
            this.enable = enable;
            this.plugin = plugin;
            this.streamproxy = streamproxy;
            this.two = two;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);
        }


        public bool two { get; set; }
         
        public bool dash { get; set; }


        public CollapsSettings Clone()
        {
            return (CollapsSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/KinobaseSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class KinobaseSettings : BaseSettings
    {
        public KinobaseSettings(string plugin, string host, bool playerjs, bool hdr)
        {
            enable = true;
            this.plugin = plugin;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);

            this.playerjs = playerjs;
            this.hdr = hdr;
        }


        public bool playerjs { get; set; }

        public bool hdr { get; set; }
    }
}

```

## File: Shared/Models/Online/Settings/ZetflixSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class ZetflixSettings : BaseSettings, ICloneable
    {
        public ZetflixSettings(string plugin, string host, bool enable = true, bool streamproxy = false, bool rip = false)
        {
            this.enable = enable;
            this.plugin = plugin;
            this.streamproxy = streamproxy;
            this.rip = rip;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);
        }


        public bool browser_keepopen { get; set; }

        public ZetflixSettings Clone()
        {
            return (ZetflixSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/RezkaSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class RezkaSettings : BaseSettings, ICloneable
    {
        public RezkaSettings(string plugin, string host, bool streamproxy = false)
        {
            enable = true;
            this.plugin = plugin;
            this.streamproxy = streamproxy;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);
        }


        public string login { get; set; }

        public string passwd { get; set; }

        public bool premium { get; set; }

        public bool reserve { get; set; }

        public string uacdn { get; set; }

        public bool forceua { get; set; }

        public bool xrealip { get; set; }

        public bool xapp { get; set; }

        public bool? ajax { get; set; }


        public RezkaSettings Clone()
        {
            return (RezkaSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/VokinoSettings.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.VoKino;

namespace Shared.Models.Online.Settings
{
    public class VokinoSettings : BaseSettings, ICloneable
    {
        public VokinoSettings(string plugin, string host, bool streamproxy, bool rip = false)
        {
            this.streamproxy = streamproxy;
            this.plugin = plugin;
            this.rip = rip;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);
        }


        public bool onlyBalancerName { get; set; }

        public ViewOnline online { get; set; } = new ViewOnline();


        public VokinoSettings Clone()
        {
            return (VokinoSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/OnlinesSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class OnlinesSettings : BaseSettings, ICloneable
    {
        public OnlinesSettings(string plugin, string host, string apihost = null, bool useproxy = false, string token = null, bool enable = true, bool streamproxy = false, bool rip = false, bool forceEncryptToken = false)
        {
            this.enable = enable;
            this.plugin = plugin;
            this.useproxy = useproxy;
            this.streamproxy = streamproxy;
            this.rip = rip;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);

            if (apihost != null)
                this.apihost = apihost.StartsWith("http") ? apihost : Decrypt(apihost);

            if (token != null)
                this.token = forceEncryptToken || token.Contains(":") || token.Contains("<") ? Decrypt(token) : token;
        }

        public bool imitationHuman { get; set; }


        public OnlinesSettings Clone()
        {
            return (OnlinesSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/AllohaSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class AllohaSettings : BaseSettings, ICloneable
    {
        public AllohaSettings(string plugin, string apihost, string linkhost, string token, string secret_token, bool localip, bool m4s)
        {
            this.plugin = plugin;
            this.token = token;
            this.secret_token = secret_token;
            this.localip = localip;
            this.m4s = m4s;

            this.linkhost = linkhost == null ? string.Empty : (linkhost.StartsWith("http") ? linkhost : Decrypt(linkhost)!);
            this.apihost = apihost == null ? string.Empty : (apihost.StartsWith("http") ? apihost : Decrypt(apihost));
        }


        public string secret_token { get; set; }

        public string linkhost { get; set; }

        public bool localip { get; set; }

        public bool m4s { get; set; }

        public bool reserve { get; set; }


        public AllohaSettings Clone()
        {
            return (AllohaSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/PidTorSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class PidTorSettings : Igroup, ICloneable
    {
        bool _enable;

        public bool enable
        {
            get
            {
                if (AppInit.conf.defaultOn == "enabled")
                    return enabled;

                return _enable;
            }
            set
            {
                _enable = value;
            }
        }

        public bool enabled { get; set; }


        public string displayname { get; set; }

        public int displayindex { get; set; }

        public string redapi { get; set; }

        public string apikey { get; set; }

        public int min_sid { get; set; }

        public long max_size { get; set; }

        public long max_serial_size { get; set; }

        public bool emptyVoice { get; set; }

        public bool forceAll { get; set; }

        public string filter { get; set; }

        public string filter_ignore { get; set; }

        public string sort { get; set; }

        public PidTorAuthTS base_auth { get; set; }

        public string[] torrs { get; set; }

        public List<PidTorAuthTS> auth_torrs { get; set; }

        public int group { get; set; }

        public bool group_hide { get; set; } = true;


        public PidTorSettings Clone()
        {
            return (PidTorSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }

    public class PidTorAuthTS
    {
        public bool enable { get; set; }

        public string host { get; set; }

        public string login { get; set; }

        public string passwd { get; set; }

        public string country { get; set; }

        public string no_country { get; set; }

        public Dictionary<string, string> headers { get; set; }
    }
}

```

## File: Shared/Models/Online/Settings/FilmixSettings.cs
```
Ôªøusing Newtonsoft.Json;
using Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class FilmixSettings : BaseSettings, ICloneable
    {
        public FilmixSettings(string plugin, string host, bool enable = true)
        {
            this.enable = enable;
            this.plugin = plugin;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);
        }

        public int hidefreeStart { get; set; } = 19;

        public int hidefreeEnd { get; set; } = 23;

        public string[] tokens { get; set; }

        public bool reserve { get; set; }

        public bool pro { get; set; }

        public bool livehash { get; set; }

        [JsonIgnore]
        public string token_apitv { get; set; }

        [JsonIgnore]
        public string hash_apitv { get; set; }

        public string user_apitv { get; set; }

        public string passwd_apitv { get; set; }


        public string APIKEY { get; set; }

        public string APISECRET { get; set; }

        public string user_name { get; set; }

        public string user_passw { get; set; }

        public string lowlevel_api_passw { get; set; }


        public FilmixSettings Clone()
        {
            return (FilmixSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Kodik/RootObject.cs
```
Ôªønamespace Shared.Models.Online.Kodik
{
    public class RootObject
    {
        public List<Result> results { get; set; }
    }
}

```

## File: Shared/Models/Online/Kodik/MaterialData.cs
```
Ôªønamespace Shared.Models.Online.Kodik
{
    public struct MaterialData
    {
        public string poster_url { get; set; }

        public string drama_poster_url { get; set; }

        public string anime_poster_url { get; set; }
    }
}

```

## File: Shared/Models/Online/Kodik/EmbedModel.cs
```
Ôªøusing Shared.Models.Templates;

namespace Shared.Models.Online.Kodik
{
    public class EmbedModel
    {
        public SimilarTpl? stpl { get; set; }

        public List<Result> result { get; set; }
    }
}

```

## File: Shared/Models/Online/Kodik/Result.cs
```
Ôªønamespace Shared.Models.Online.Kodik
{
    public struct Result
    {
        public string id { get; set; }

        public string title { get; set; }

        public string title_orig { get; set; }

        public string type { get; set; }

        public int? year { get; set; }

        public string link { get; set; }

        public string imdb_id { get; set; }

        public string kinopoisk_id { get; set; }

        public Translation translation { get; set; }

        public int last_season { get; set; }

        public Dictionary<string, Season> seasons { get; set; }


        public MaterialData material_data { get; set; }
    }
}

```

## File: Shared/Models/Online/Kodik/StreamModel.cs
```
Ôªønamespace Shared.Models.Online.Kodik
{
    public struct StreamModel
    {
        public string q { get; set; }

        public string url { get; set; }
    }
}

```

## File: Shared/Models/Online/Kodik/Translation.cs
```
Ôªønamespace Shared.Models.Online.Kodik
{
    public struct Translation
    {
        public string title { get; set; }
    }
}

```

## File: Shared/Models/Online/Kodik/Season.cs
```
Ôªønamespace Shared.Models.Online.Kodik
{
    public struct Season
    {
        public string link { get; set; }

        public Dictionary<string, string> episodes { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoCDN/VCDNSettings.cs
```
Ôªønamespace Shared.Models.Online.VideoCDN
{
    public class VCDNSettings
    {
        public VCDNSettings(string apihost, string token, string cdnhost, bool useproxy)
        {
            this.apihost = apihost;
            this.token = token;
            this.cdnhost = cdnhost;
            this.useproxy = useproxy;
        }


        public string apihost { get; set; }

        public string token { get; set; }

        public string cdnhost { get; set; }

        public bool useproxy { get; set; }

        public bool streamproxy { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoCDN/Folder.cs
```
Ôªønamespace Shared.Models.Online.VideoCDN
{
    public struct Folder
    {
        public string id { get; set; }

        public string file { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoCDN/SearchRoot.cs
```
Ôªønamespace Shared.Models.Online.VideoCDN
{
    public class SearchRoot
    {
        public Datum[] data { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoCDN/Datum.cs
```
Ôªønamespace Shared.Models.Online.VideoCDN
{
    public struct Datum
    {
        public int kp_id { get; set; }

        public string imdb_id { get; set; }

        public string title { get; set; }

        public string orig_title { get; set; }

        public string add { get; set; }

        public string content_type { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoCDN/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.VideoCDN
{
    public class EmbedModel
    {
        public string type { get; set; } = null!;

        public Dictionary<string, string> voices { get; set; }

        public Dictionary<string, HashSet<int>> voiceSeasons { get; set; }

        public Dictionary<string, List<Season>> serial { get; set; }

        public Dictionary<string, string> movie { get; set; }

        public string quality { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoCDN/Season.cs
```
Ôªønamespace Shared.Models.Online.VideoCDN
{
    public struct Season
    {
        public int id { get; set; }

        public Folder[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/Redheadsound/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Redheadsound
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public string iframe { get; set; }

        public string iframeUri { get; set; }
    }
}

```

## File: Shared/Models/Online/Lumex/Track.cs
```
Ôªønamespace Shared.Models.Online.Lumex
{
    public struct Track
    {
        public string src { get; set; }
        public string srlang { get; set; }
        public string label { get; set; }
    }
}

```

## File: Shared/Models/Online/Lumex/Medium.cs
```
Ôªønamespace Shared.Models.Online.Lumex
{
    public struct Medium
    {
        public int translation_id { get; set; }

        public string translation_name { get; set; }

        public int? max_quality { get; set; }

        public string playlist { get; set; }

        public string[] subtitles { get; set; }

        public Track[] tracks { get; set; }



        public int season_id { get; set; }

        public Episode[] episodes { get; set; }
    }
}

```

## File: Shared/Models/Online/Lumex/SearchRoot.cs
```
Ôªønamespace Shared.Models.Online.Lumex
{
    public class SearchRoot
    {
        public Datum[] data { get; set; }
    }
}

```

## File: Shared/Models/Online/Lumex/DatumDB.cs
```
Ôªønamespace Shared.Models.Online.Lumex
{
    public struct DatumDB
    {
        public long id { get; set; }

        public long kinopoisk_id { get; set; }

        public string imdb_id { get; set; }

        public string ru_title { get; set; }

        public string orig_title { get; set; }

        public string content_type { get; set; }

        public string year { get; set; }
    }
}

```

## File: Shared/Models/Online/Lumex/Datum.cs
```
Ôªønamespace Shared.Models.Online.Lumex
{
    public struct Datum
    {
        public long kp_id { get; set; }

        public string imdb_id { get; set; }

        public string title { get; set; }

        public string orig_title { get; set; }

        public string add { get; set; }

        public long id { get; set; }

        public string content_type { get; set; }
    }
}

```

## File: Shared/Models/Online/Lumex/Episode.cs
```
Ôªønamespace Shared.Models.Online.Lumex
{
    public struct Episode
    {
        public int episode_id { get; set; }

        public Medium[] media { get; set; }
    }
}

```

## File: Shared/Models/Online/Lumex/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Lumex
{
    public class EmbedModel
    {
        public string csrf { get; set; }

        public string tag_url { get; set; }

        public string content_type { get; set; }

        public Medium[] media { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoDB/RootObject.cs
```
Ôªønamespace Shared.Models.Online.VideoDB
{
    public struct RootObject
    {
        public string title { get; set; }

        public string file { get; set; }

        public string subtitle { get; set; }

        public Folder[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoDB/Folder.cs
```
Ôªønamespace Shared.Models.Online.VideoDB
{
    public struct Folder
    {
        public string title { get; set; }

        public Folder[] folder { get; set; }

        public string file { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoDB/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.VideoDB
{
    public class EmbedModel
    {
        public RootObject[] pl { get; set; }

        public bool movie { get; set; }

        public bool obfuscation { get; set; }

        public string quality { get; set; }
    }
}

```

## File: Shared/Models/Online/Filmix/RootObject.cs
```
Ôªønamespace Shared.Models.Online.Filmix
{
    public class RootObject
    {
        public PlayerLinks player_links { get; set; }

        public string quality { get; set; }
    }
}

```

## File: Shared/Models/Online/Filmix/PlayerLinks.cs
```
Ôªøusing Newtonsoft.Json.Linq;

namespace Shared.Models.Online.Filmix
{
    public struct PlayerLinks
    {
        public Movie[] movie { get; set; }

        /// <summary>
        /// —Å–µ–∑–æ–Ω, (–æ–∑–≤—É—á–∫–∞, (—Å–µ—Ä–∏—è, item))
        /// </summary>
        public Dictionary<string, Dictionary<string, JToken>> playlist { get; set; }
    }
}

```

## File: Shared/Models/Online/Filmix/SearchResult.cs
```
Ôªøusing Shared.Models.Templates;

namespace Shared.Models.Online.Filmix
{
    public class SearchResult
    {
        public int id { get; set; }

        public SimilarTpl? similars { get; set; }
    }
}

```

## File: Shared/Models/Online/Filmix/SearchModel.cs
```
Ôªønamespace Shared.Models.Online.Filmix
{
    public class SearchModel
    {
        public int id { get; set; }

        public string title { get; set; }

        public string original_title { get; set; }

        /// <summary>
        /// api.filmix.tv
        /// </summary>
        public string original_name { get; set; }

        public string poster { get; set; }

        public int year { get; set; }
    }
}

```

## File: Shared/Models/Online/Filmix/Movie.cs
```
Ôªønamespace Shared.Models.Online.Filmix
{
    public struct Movie
    {
        public string link { get; set; }

        public string translation { get; set; }

        public int[] qualities { get; set; }
    }
}

```

## File: Shared/Models/Online/AniLibria/RootObject.cs
```
Ôªønamespace Shared.Models.Online.AniLibria
{
    public struct RootObject
    {
        public Names names { get; set; }

        public string code { get; set; }

        public Season season { get; set; }

        public Player player { get; set; }

        public Poster posters { get; set; }
    }
}

```

## File: Shared/Models/Online/AniLibria/Series.cs
```
Ôªønamespace Shared.Models.Online.AniLibria
{
    public struct Series
    {
        public int serie { get; set; }

        public Hls hls { get; set; }
    }
}

```

## File: Shared/Models/Online/AniLibria/Hls.cs
```
Ôªønamespace Shared.Models.Online.AniLibria
{
    public struct Hls
    {
        public string fhd { get; set; }

        public string hd { get; set; }

        public string sd { get; set; }
    }
}

```

## File: Shared/Models/Online/AniLibria/Names.cs
```
Ôªønamespace Shared.Models.Online.AniLibria
{
    public struct Names
    {
        public string ru { get; set; }

        public string en { get; set; }
    }
}

```

## File: Shared/Models/Online/AniLibria/Poster.cs
```
Ôªønamespace Shared.Models.Online.AniLibria
{
    public struct Poster
    {
        public Poster_url small { get; set; }

        public Poster_url medium { get; set; }

        public Poster_url original { get; set; }
    }

    public struct Poster_url
    {
        public string url { get; set; }
    }
}

```

## File: Shared/Models/Online/AniLibria/Player.cs
```
Ôªønamespace Shared.Models.Online.AniLibria
{
    public struct Player
    {
        public string host { get; set; }

        public Dictionary<string, Series> playlist { get; set; }
    }
}

```

## File: Shared/Models/Online/AniLibria/Season.cs
```
Ôªønamespace Shared.Models.Online.AniLibria
{
    public struct Season
    {
        public int year { get; set; }
    }
}

```

## File: Shared/Models/Online/Zetflix/RootObject.cs
```
Ôªønamespace Shared.Models.Online.Zetflix
{
    public struct RootObject
    {
        public string title { get; set; }

        public string file { get; set; }

        public Folder[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/Zetflix/Folder.cs
```
Ôªønamespace Shared.Models.Online.Zetflix
{
    public struct Folder
    {
        public string comment { get; set; }

        public string file { get; set; }
    }
}

```

## File: Shared/Models/Online/Zetflix/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Zetflix
{
    public class EmbedModel
    {
        public List<RootObject> pl { get; set; }

        public bool movie { get; set; }

        public string quality { get; set; }

        public string check_url { get; set; }
    }
}

```

## File: Shared/Models/Online/AnimeLib/Episode.cs
```
Ôªønamespace Shared.Models.Online.AnimeLib
{
    public struct Episode
    {
        public int id { get; set; }
        public string name { get; set; }
        public string number { get; set; }
        public string season { get; set; }
    }
}

```

## File: Shared/Models/Online/AnimeLib/Quality.cs
```
Ôªønamespace Shared.Models.Online.AnimeLib
{
    public struct Quality
    {
        public string href { get; set; }

        public int quality { get; set; }
    }
}

```

## File: Shared/Models/Online/AnimeLib/DataSearch.cs
```
Ôªønamespace Shared.Models.Online.AnimeLib
{
    public struct DataSearch
    {
        public string rus_name { get; set; }
        public string eng_name { get; set; }
        public string slug_url { get; set; }
        public string releaseDate { get; set; }
        public –°over cover { get; set; }
    }
}

```

## File: Shared/Models/Online/AnimeLib/Video.cs
```
Ôªønamespace Shared.Models.Online.AnimeLib
{
    public struct Video
    {
        public List<Quality> quality { get; set; }
    }
}

```

## File: Shared/Models/Online/AnimeLib/AnimeLibTokenState.cs
```
Ôªønamespace Shared.Models.Online.AnimeLib
{
    public class AnimeLibTokenState
    {
        public string token { get; set; }
        public string refresh_token { get; set; }
        public long refresh_time { get; set; }
    }
}

```

## File: Shared/Models/Online/AnimeLib/–°over.cs
```
Ôªønamespace Shared.Models.Online.AnimeLib
{
    public struct –°over
    {
        public string @default { get; set; }
    }
}

```

## File: Shared/Models/Online/AnimeLib/Player.cs
```
Ôªønamespace Shared.Models.Online.AnimeLib
{
    public struct Player
    {
        public string player { get; set; }

        public PlayerTeam team { get; set; }

        public Video video { get; set; }
    }

    public struct PlayerTeam
    {
        public string name { get; set; }
    }
}

```

## File: Shared/Models/Online/Kinobase/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Kinobase
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }
        public string errormsg { get; set; }


        public string content { get; set; }

        public Season[] serial { get; set; }

        public string quality { get; set; }
    }
}

```

## File: Shared/Models/Online/Kinobase/Playlist.cs
```
Ôªønamespace Shared.Models.Online.Kinobase
{
    public struct Playlist
    {
        public int id { get; set; }
        public string file { get; set; }
        public string comment { get; set; }
        public string title { get; set; }
        public string subtitle { get; set; }
    }
}

```

## File: Shared/Models/Online/Kinobase/SearchModel.cs
```
Ôªøusing Shared.Models.Templates;

namespace Shared.Models.Online.Kinobase
{
    public class SearchModel
    {
        public string link { get; set; }

        public SimilarTpl? similar { get; set; }
    }
}

```

## File: Shared/Models/Online/Kinobase/Season.cs
```
Ôªønamespace Shared.Models.Online.Kinobase
{
    public struct Season
    {
        public long id { get; set; }

        public string file { get; set; }

        public string title { get; set; }

        public string comment { get; set; }

        public string subtitle { get; set; }

        public Season[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/Rezka/MovieModel.cs
```
Ôªønamespace Shared.Models.Online.Rezka
{
    public class MovieModel
    {
        /// <summary>
        /// Rezka
        /// </summary>
        public List<ApiModel> links { get; set; }

        /// <summary>
        /// Voidboos
        /// </summary>
        public string url { get; set; }

        public string subtitlehtml { get; set; }
    }
}

```

## File: Shared/Models/Online/Rezka/Episodes.cs
```
Ôªønamespace Shared.Models.Online.Rezka
{
    public class Episodes
    {
        public string episodes { get; set; }

        public string seasons { get; set; }
    }
}

```

## File: Shared/Models/Online/Rezka/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Rezka
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public string content { get; set; }

        public string id { get; set; }

        public List<SimilarModel> similar { get; set; }
    }
}

```

## File: Shared/Models/Online/Rezka/SimilarModel.cs
```
Ôªønamespace Shared.Models.Online.Rezka
{
    public class SimilarModel
    {
        public SimilarModel(string title, string year, string href, string img)
        {
            this.title = title;
            this.year = year;
            this.href = href;
            this.img = img;
        }

        public string title { get; set; }

        public string year { get; set; }

        public string href { get; set; }

        public string img { get; set; }
    }
}

```

## File: Shared/Models/Online/Rezka/SearchModel.cs
```
Ôªønamespace Shared.Models.Online.Rezka
{
    public class SearchModel
    {
        public bool IsEmpty { get; set; }

        public string content { get; set; }

        public string href { get; set; }

        public string search_uri { get; set; }

        public List<SimilarModel> similar { get; set; }
    }
}

```

## File: Shared/Models/Online/PiTor/RootObject.cs
```
Ôªønamespace Shared.Models.Online.PiTor
{
    public class RootObject
    {
        public Result[] Results { get; set; }
    }
}

```

## File: Shared/Models/Online/PiTor/Info.cs
```
Ôªønamespace Shared.Models.Online.PiTor
{
    public struct Info
    {
        public string[] voices { get; set; }

        public string sizeName { get; set; }

        public int[] seasons { get; set; }
    }
}

```

## File: Shared/Models/Online/PiTor/FileStat.cs
```
Ôªønamespace Shared.Models.Online.PiTor
{
    public struct FileStat
    {
        public int Id { get; set; }

        public string Path { get; set; }

        public long Length { get; set; }
    }
}

```

## File: Shared/Models/Online/PiTor/Result.cs
```
Ôªønamespace Shared.Models.Online.PiTor
{
    public struct Result
    {
        public string Tracker { get; set; }
        public string Title { get; set; }
        public long? Size { get; set; }
        public int Seeders { get; set; }
        public string MagnetUri { get; set; }
        public Info info { get; set; }

        public DateTime PublishDate { get; set; }
    }
}

```

## File: Shared/Models/Online/PiTor/Stat.cs
```
Ôªønamespace Shared.Models.Online.PiTor
{
    public class Stat
    {
        public FileStat[] file_stats { get; set; }
    }
}

```

## File: Shared/Models/Online/Vibix/Seasons.cs
```
Ôªønamespace Shared.Models.Online.Vibix
{
    public struct Seasons
    {
        public string title { get; set; }
        public Seasons[] folder { get; set; }
        public string file { get; set; }
    }
}

```

## File: Shared/Models/Online/Vibix/Video.cs
```
Ôªønamespace Shared.Models.Online.Vibix
{
    public class Video
    {
        public string iframe_url { get; set; }

        public string type { get; set; }
    }
}

```

## File: Shared/Models/Online/Vibix/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Vibix
{
    public class EmbedModel
    {
        public Seasons[] playlist { get; set; }
    }
}

```

## File: Shared/Models/Online/Eneyida/BobrKurwa.cs
```
Ôªønamespace Shared.Models.Online.Eneyida
{
    public struct BobrKurwa
    {
        public string name { get; set; }

        public string eng_name { get; set; }

        public string year { get; set; }


        public string ashdi { get; set; }

        public string tortuga { get; set; }
    }
}

```

## File: Shared/Models/Online/Eneyida/Similar.cs
```
Ôªønamespace Shared.Models.Online.Eneyida
{
    public class Similar
    {
        public string title { get; set; }

        public string year { get; set; }

        public string href { get; set; }

        public string img { get; set; }
    }
}

```

## File: Shared/Models/Online/Eneyida/EmbedModel.cs
```
Ôªøusing Shared.Models.Online.Tortuga;

namespace Shared.Models.Online.Eneyida
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public string source_type { get; set; }

        public string content { get; set; }

        public string quel { get; set; }

        public Voice[] serial { get; set; }

        public Ashdi.Voice[] serial_ashdi { get; set; }

        public List<Similar> similars { get; set; }
    }
}

```

## File: Shared/Models/Online/Alloha/Episode.cs
```
Ôªønamespace Shared.Models.Online.Alloha
{
    public struct Episode
    {
        public int episode { get; set; }

        public Dictionary<string, Translation> translation { get; set; }
    }
}
```

## File: Shared/Models/Online/Alloha/FileQ.cs
```
Ôªønamespace Shared.Models.Online.Alloha
{
    public struct FileQ
    {
        public string h264 { get; set; }

        public string av1 { get; set; }
    }
}

```

## File: Shared/Models/Online/Alloha/Translation.cs
```
Ôªønamespace Shared.Models.Online.Alloha
{
    public struct Translation
    {
        public string translation { get; set; }
    }
}

```

## File: Shared/Models/Online/Plvideo/Profile.cs
```
Ôªønamespace Shared.Models.Online.Plvideo
{
    public struct Profile
    {
        public string hls { get; set; }
    }
}

```

## File: Shared/Models/Online/Plvideo/Item.cs
```
Ôªønamespace Shared.Models.Online.Plvideo
{
    public struct Item
    {
        public string id { get; set; }

        public string title { get; set; }

        public ItemuploadFile uploadFile { get; set; }

        public string visible { get; set; }
    }

    public struct ItemuploadFile
    {
        public long videoDuration { get; set; }
    }
}

```

## File: Shared/Models/Online/Ashdi/Series.cs
```
Ôªønamespace Shared.Models.Online.Ashdi
{
    public struct Series
    {
        public string title { get; set; }

        public string file { get; set; }

        public string subtitle { get; set; }
    }
}

```

## File: Shared/Models/Online/Ashdi/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Ashdi
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public string content { get; set; }

        public Voice[] serial { get; set; }
    }
}

```

## File: Shared/Models/Online/Ashdi/Voice.cs
```
Ôªønamespace Shared.Models.Online.Ashdi
{
    public struct Voice
    {
        public string title { get; set; }

        public Season[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/Ashdi/Season.cs
```
Ôªønamespace Shared.Models.Online.Ashdi
{
    public struct Season
    {
        public string title { get; set; }

        public Series[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/VoKino/RootObject.cs
```
Ôªønamespace Shared.Models.Online.VoKino
{
    public class RootObject
    {
        public –°hannel[] menu { get; set; }

        public –°hannel[] channels { get; set; }
    }
}

```

## File: Shared/Models/Online/VoKino/–°hannel.cs
```
Ôªønamespace Shared.Models.Online.VoKino
{
    public class –°hannel
    {
        public string title { get; set; }

        public string ident { get; set; }

        public string playlist_url { get; set; }

        public bool selected { get; set; }

        public –°hannel[] submenu { get; set; }


        public string stream_url { get; set; }

        public string quality_full { get; set; }

        public Dictionary<string, string> extra { get; set; }

        public Details details { get; set; }
    }
}

```

## File: Shared/Models/Online/VoKino/Similar.cs
```
Ôªønamespace Shared.Models.Online.VoKino
{
    public struct Similar
    {
        public string title { get; set; }

        public string balancer { get; set; }
    }
}

```

## File: Shared/Models/Online/VoKino/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.VoKino
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public –°hannel[] menu { get; set; }

        public –°hannel[] channels { get; set; }

        public List<Similar> similars { get; set; }
    }
}

```

## File: Shared/Models/Online/VoKino/Details.cs
```
Ôªønamespace Shared.Models.Online.VoKino
{
    public struct Details
    {
        public string id { get; set; }
    }
}

```

## File: Shared/Models/Online/VoKino/ViewOnline.cs
```
Ôªønamespace Shared.Models.Online.VoKino
{
    public class ViewOnline
    {
        public bool vokino { get; set; } = true;

        public bool filmix { get; set; } = true;

        public bool alloha { get; set; } = true;

        public bool hdvb { get; set; } = true;

        public bool remux { get; set; } = true;

        public bool monframe { get; set; } = true;

        public bool ashdi { get; set; } = true;

        public bool vibix { get; set; } = true;
    }
}

```

## File: Shared/Models/Online/Kinotochka/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Kinotochka
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public string content { get; set; }
    }
}

```

## File: Shared/Models/Online/Collaps/RootObject.cs
```
Ôªønamespace Shared.Models.Online.Collaps
{
    public struct RootObject
    {

        public int season { get; set; }

        public Episode[] episodes { get; set; }
    }
}

```

## File: Shared/Models/Online/Collaps/Cc.cs
```
Ôªønamespace Shared.Models.Online.Collaps
{
    public struct Cc
    {
        public string url { get; set; }

        public string name { get; set; }
    }
}

```

## File: Shared/Models/Online/Collaps/Episode.cs
```
Ôªønamespace Shared.Models.Online.Collaps
{
    public struct Episode
    {
        public string episode { get; set; }
        
        public string hls { get; set; }

        public string dasha { get; set; }
        public string dash { get; set; }

        public Cc[] cc { get; set; }

        public Audio audio { get; set; }
    }
}

```

## File: Shared/Models/Online/Collaps/Audio.cs
```
Ôªønamespace Shared.Models.Online.Collaps
{
    public struct Audio
    {
        public string[] names { get; set; }
    }
}

```

## File: Shared/Models/Online/Collaps/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Collaps
{
    public class EmbedModel
    {
        public string content { get; set; }

        public RootObject[] serial { get; set; }
    }
}

```

## File: Shared/Models/Online/Collaps/ResultSearch.cs
```
Ôªønamespace Shared.Models.Online.Collaps
{
    public struct ResultSearch
    {
        public int id { get; set; }

        public string name { get; set; }

        public string origin_name { get; set; }

        public int year { get; set; }

        public string poster { get; set; }
    }
}

```

## File: Shared/Models/Online/FanCDN/Episode.cs
```
Ôªønamespace Shared.Models.Online.FanCDN
{
    public struct Episode
    {
        public string title { get; set; }

        public string file { get; set; }

        public string subtitles { get; set; }


        public Dictionary<string, Episode> folder { get; set; }
    }
}

```

## File: Shared/Models/Online/FanCDN/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.FanCDN
{
    public class EmbedModel
    {
        public Episode[] movies { get; set; }

        public Voice[] serial { get; set; }
    }
}

```

## File: Shared/Models/Online/FanCDN/Voice.cs
```
Ôªønamespace Shared.Models.Online.FanCDN
{
    public struct Voice
    {
        public int id { get; set; }

        public string title { get; set; }

        public Dictionary<string, Episode> folder { get; set; }

        public int seasons { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/RootObject.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public class RootObject
    {
        public int status { get; set; }

        public Item item { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/SearchItem.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public struct SearchItem
    {
        public int id { get; set; }

        public string type { get; set; }

        public string title { get; set; }

        public string voice { get; set; }

        public long? kinopoisk { get; set; }

        public long? imdb { get; set; }

        public int year { get; set; }

        public Dictionary<string, string> posters { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Author.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public class Author
    {
        public int? id { get; set; }

        public string title { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Subtitle.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public struct Subtitle
    {
        public string lang { get; set; }

        public string url { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/SearchObject.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public class SearchObject
    {
        public SearchItem[] items { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Episode.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public struct Episode
    {
        public long id { get; set; }

        public int number { get; set; }

        public string title { get; set; }

        public Subtitle[] subtitles { get; set; }

        public File[] files { get; set; }

        public Audio[] audios { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Audio.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public class Audio
    {
        public int index { get; set; }

        public string lang { get; set; }

        public string codec { get; set; }

        public Author author { get; set; }

        public Author type { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Video.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public class Video
    {
        public long id { get; set; }

        public string title { get; set; }

        public Subtitle[] subtitles { get; set; }

        public File[] files { get; set; }

        public Audio[] audios { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Item.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public struct Item
    {
        public bool advert { get; set; }

        public int quality { get; set; }

        public string voice { get; set; }

        public Video[] videos { get; set; }

        public Season[] seasons { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Url.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public struct Url
    {
        public string http { get; set; }

        public string hls { get; set; }

        public string hls4 { get; set; }

        public string hls2 { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/SearchResult.cs
```
Ôªøusing Shared.Models.Templates;

namespace Shared.Models.Online.KinoPub
{
    public class SearchResult
    {
        public int id { get; set; }

        public SimilarTpl? similars { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/File.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public struct File
    {
        public string quality { get; set; }

        public string file { get; set; }

        public Url url { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Season.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public struct Season
    {
        public int number { get; set; }

        public Episode[] episodes { get; set; }
    }
}

```

## File: Shared/Models/Online/FilmixTV/RootObject.cs
```
Ôªøusing System.Text.Json.Serialization;

namespace Shared.Models.Online.FilmixTV
{
    public class RootObject
    {
        [JsonInclude]
        public Dictionary<string, Dictionary<string, Season>> SerialVoice { get; set; }

        [JsonInclude]
        public MovieTV[] Movies { get; set; }
    }
}

```

## File: Shared/Models/Online/FilmixTV/Serial.cs
```
Ôªønamespace Shared.Models.Online.FilmixTV
{
    public struct Season
    {
        public int season { get; set; }
        public Dictionary<string, Episode> episodes { get; set; }
    }

    public struct Episode
    {
        public int episode { get; set; }
        public File[] files { get; set; }
    }

    public struct File
    {
        public string url { get; set; }
        public int quality { get; set; }
    }
}

```

## File: Shared/Models/Online/FilmixTV/Movie.cs
```
Ôªønamespace Shared.Models.Online.FilmixTV
{
    public struct MovieTV
    {
        public File[] files { get; set; }
        public string voiceover { get; set; }
    }
}

```

## File: Shared/Models/Online/RutubeMovie/–°ategory.cs
```
Ôªønamespace Shared.Models.Online.RutubeMovie
{
    public struct –°ategory
    {
        public int id { get; set; }
    }
}

```

## File: Shared/Models/Online/RutubeMovie/Result.cs
```
Ôªønamespace Shared.Models.Online.RutubeMovie
{
    public struct Result
    {
        public string id { get; set; }

        public string title { get; set; }

        public long duration { get; set; }

        public –°ategory category { get; set; }

        public bool is_hidden { get; set; }
        public bool is_deleted { get; set; }
        public bool is_adult { get; set; }
        public bool is_locked { get; set; }
        public bool is_audio { get; set; }
        public bool is_paid { get; set; }
        public bool is_livestream { get; set; }
    }
}

```

## File: Shared/Models/Online/iRemux/Similar.cs
```
Ôªønamespace Shared.Models.Online.iRemux
{
    public class Similar
    {
        public string title { get; set; }

        public string year { get; set; }

        public string href { get; set; }
    }
}

```

## File: Shared/Models/Online/iRemux/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.iRemux
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public string content { get; set; }

        public List<Similar> similars { get; set; } = new List<Similar>(15);
    }
}

```

## File: Shared/Models/Online/VkMovie/CatalogVideo.cs
```
namespace Shared.Models.Online.VkMovie
{
    public class CatalogVideo
    {
        public Video video { get; set; }
    }
}

```

## File: Shared/Models/Online/VkMovie/VideoSubtitle.cs
```
namespace Shared.Models.Online.VkMovie
{
    public class VideoSubtitle
    {
        public string lang { get; set; }
        public string title { get; set; }
        public bool is_auto { get; set; }
        public string url { get; set; }
        public string manifest_name { get; set; }
    }
}

```

## File: Shared/Models/Online/VkMovie/Video.cs
```
namespace Shared.Models.Online.VkMovie
{
    public class Video
    {
        public long id { get; set; }
        public long owner_id { get; set; }
        public string title { get; set; }
        public string description { get; set; }
        public long duration { get; set; }
        public VideoFiles files { get; set; }
        public VideoSubtitle[] subtitles { get; set; }
    }
}

```

## File: Shared/Models/Online/VkMovie/VideoFiles.cs
```
namespace Shared.Models.Online.VkMovie
{
    public class VideoFiles
    {
        public string mp4_144 { get; set; }
        public string mp4_240 { get; set; }
        public string mp4_360 { get; set; }
        public string mp4_480 { get; set; }
        public string mp4_720 { get; set; }
        public string mp4_1080 { get; set; }
        public string mp4_1440 { get; set; }
        public string mp4_2160 { get; set; }
        public string hls { get; set; }
        public string hls_fmp4 { get; set; }
        public string hls_streams { get; set; }
        public string dash_sep { get; set; }
        public string dash_streams { get; set; }
        public string dash_webm { get; set; }
        public string failover_host { get; set; }
    }
}

```

## File: Shared/Models/Online/HDVB/Folder.cs
```
Ôªønamespace Shared.Models.Online.HDVB
{
    public struct Folder
    {
        public string id { get; set; }

        public string episode { get; set; }

        public Folder[] folder { get; set; }

        public string title { get; set; }

        public string file { get; set; }
    }
}

```

## File: Shared/Models/Online/VDBmovies/RootObject.cs
```
Ôªønamespace Shared.Models.Online.VDBmovies
{
    public class RootObject
    {
        public Dictionary<string, Movie> data { get; set; }
    }
}

```

## File: Shared/Models/Online/VDBmovies/Episode.cs
```
Ôªønamespace Shared.Models.Online.VDBmovies
{
    public struct Episode
    {
        public string title { get; set; }

        public string file { get; set; }

        public string subtitle { get; set; }

        public string subtitles { get; set; }
    }
}

```

## File: Shared/Models/Online/VDBmovies/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.VDBmovies
{
    public class EmbedModel
    {
        public Episode[] movies { get; set; }

        public CDNmovies.Voice[] serial { get; set; }

        public string quality { get; set; }
    }
}

```

## File: Shared/Models/Online/VDBmovies/MovieDB.cs
```
Ôªønamespace Shared.Models.Online.VDBmovies
{
    public struct MovieDB
    {
        public string id { get; set; }
        public string ru_title { get; set; }
        public string orig_title { get; set; }
        public string imdb_id { get; set; }
        public long? kinopoisk_id { get; set; }
        public int year { get; set; }
    }
}

```

## File: Shared/Models/Online/VDBmovies/Movie.cs
```
Ôªønamespace Shared.Models.Online.VDBmovies
{
    public struct Movie
    {
        public string iframe_src { get; set; }
    }
}

```

## File: Shared/Models/Online/Tortuga/Series.cs
```
Ôªønamespace Shared.Models.Online.Tortuga
{
    public struct Series
    {
        public string title { get; set; }

        public string file { get; set; }

        public string subtitle { get; set; }
    }
}

```

## File: Shared/Models/Online/Tortuga/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Tortuga
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public string content { get; set; } = null!;

        public List<Voice> serial { get; set; }
    }
}

```

## File: Shared/Models/Online/Tortuga/Voice.cs
```
Ôªønamespace Shared.Models.Online.Tortuga
{
    public struct Voice
    {
        public string title { get; set; }

        public string season { get; set; }

        public Season[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/Tortuga/Season.cs
```
Ôªønamespace Shared.Models.Online.Tortuga
{
    public struct Season
    {
        public string title { get; set; }

        public string number { get; set; }

        public Series[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/VeoVeo/Movie.cs
```
Ôªønamespace Shared.Models.Online.VeoVeo
{
    public struct Movie
    {
        public long id { get; set; }

        public int year { get; set; }

        public long? kinopoiskId { get; set; }

        public string imdbId { get; set; }

        public string originalTitle { get; set; }

        public string title { get; set; }
    }
}

```

## File: Shared/Models/Events/EventsRecord.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json.Linq;
using Shared.Engine;
using Shared.Models.AppConf;
using Shared.Models.Base;
using Shared.Models.JacRed;
using Shared.Models.Online.Settings;
using System.Collections.ObjectModel;
using System.Net;
using System.Net.Http;
using System.Threading;
using System.Text.Json;

namespace Shared.Models.Events
{
    public record EventLoadKit(BaseSettings defaultinit, BaseSettings init, JObject userconf, RequestModel requestInfo, HybridCache hybridCache);

    public record EventMiddleware(RequestModel requestInfo, HttpRequest request, HttpContext httpContext, HybridCache hybridCache, IMemoryCache memoryCache);

    public record EventBadInitialization(BaseSettings init, bool? rch, RequestModel requestInfo, string host, HttpRequest request, HttpContext httpContext, HybridCache hybridCache);

    public record EventAppReplace(string source, string token, string arg, string host, RequestModel requestInfo, HttpRequest request, HybridCache hybridCache);

    public record EventExternalids(string id, string imdb_id, string kinopoisk_id, int serial);

    public record EventHybridCache(string key, string value, DateTimeOffset ex);

    public record EventRedApi(TorrentDetails torrent);

    public record EventPidTor(PidTorSettings init, RequestModel requestInfo, HybridCache hybridCache);

    public record EventHostStreamProxy(BaseSettings conf, string uri, List<HeadersModel> headers, WebProxy proxy, RequestModel requestInfo, HttpContext httpContext, HybridCache hybridCache);

    public record EventMyLocalIp(RequestModel requestInfo, HttpRequest request, HttpContext httpContext, HybridCache hybridCache);

    public record EventControllerHttpHeaders(string site, List<HeadersModel> headers, RequestModel requestInfo, HttpRequest request, HttpContext httpContext);

    public record EventStreamQuality(string link, string quality, bool prepend);

    public record EventStreamQualityFirts(IReadOnlyList<(string link, string quality)> data);

    public record EventHttpHandler(string url, HttpClientHandler handler, WebProxy proxy, CookieContainer cookieContainer, IMemoryCache memoryCache);

    public record EventHttpHeaders(string url, HttpRequestMessage client, string cookie, string referer, List<HeadersModel> headers, bool useDefaultHeaders, IMemoryCache memoryCache);

    public record EventHttpResponse(string url, HttpContent data, HttpClient client, string result, HttpResponseMessage response, IMemoryCache memoryCache);

    public record EventProxyApiCreateHttpRequest(string plugin, HttpRequest request, List<HeadersModel> headers, Uri uri, bool ismedia, HttpRequestMessage requestMessage);

    public record EventTranscoding(Collection<string> args, int? startNumber, TranscodingStartContext context);

    public record EventRchRegistry(string connectionId, string ip, string host, RchClientInfo info, NwsConnection connection);

    public record EventRchDisconnected(string connectionId);

    public record EventNwsConnected(string connectionId, string ip, RequestModel requestInfo, NwsConnection connection, CancellationToken token);

    public record EventNwsDisconnected(string connectionId);

    public record EventNwsMessage(string connectionId, string payload, string method, JsonElement args);
}

```

## File: Shared/Models/Events/EventsModel.cs
```
Ôªønamespace Shared.Models.Events
{
    public class EventsModel()
    {
        public string LoadKitInit { get; set; }

        public string LoadKit { get; set; }

        public string PidTor { get; set; }

        public string StreamQualityTpl { get; set; }

        public string StreamQualityFirts { get; set; }

        public EventModelMiddleware Middleware { get; set; }

        public EventModelController Controller { get; set; }

        public EventModelHttp Http { get; set; }

        public EventModelRedApi RedApi { get; set; }

        public EventModelHybridCache HybridCache { get; set; }

        public EventModelProxyApi ProxyApi { get; set; }

        public EventModelTranscoding Transcoding { get; set; }

        public EventModelRch Rch { get; set; }

        public EventModelNws Nws { get; set; }
    }

    public class EventModelController()
    {
        public string BadInitialization { get; set; }

        public EventModelAppReplace AppReplace { get; set; }

        public string Externalids { get; set; }

        public string HostStreamProxy { get; set; }

        public string MyLocalIp { get; set; }

        public string HttpHeaders { get; set; }
    }

    public class EventModelAppReplace()
    {
        public EventModelAppReplaceComand online { get; set; }

        public EventModelAppReplaceComand sisi { get; set; }

        public EventModelAppReplaceComand appjs { get; set; }

        public EventModelAppReplaceComand appcss { get; set; }
    }

    public class EventModelAppReplaceComand()
    {
        public Dictionary<string, string> list { get; set; }

        public Dictionary<string, string> regex { get; set; }

        public string eval { get; set; }
    }

    public class EventModelMiddleware()
    {
        public string first { get; set; }

        public string end { get; set; }
    }

    public class EventModelHttp()
    {
        public string Handler { get; set; }

        public string Headers { get; set; }

        public string Response { get; set; }
    }

    public class EventModelRedApi()
    {
        public string AddTorrents { get; set; }
    }

    public class EventModelHybridCache()
    {
        public string Read { get; set; }

        public string Write { get; set; }
    }

    public class EventModelProxyApi()
    {
        public string CreateHttpRequest { get; set; }
    }

    public class EventModelTranscoding()
    {
        public string CreateProcess { get; set; }
    }

    public class EventModelRch()
    {
        public string Registry { get; set; }

        public string Disconnected { get; set; }
    }

    public class EventModelNws()
    {
        public string Connected { get; set; }

        public string Disconnected { get; set; }

        public string Message { get; set; }
    }
}

```

## File: Shared/Models/CSharpGlobals/recordGlobals.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Shared.Engine;

namespace Shared.Models.CSharpGlobals
{
    public record CmdEvalModel(string key, string comand, RequestModel requestInfo, HttpRequest request, HybridCache hybridCache, IMemoryCache memoryCache);
}

```

## File: Shared/Models/CSharpGlobals/CatalogGlobals.cs
```
using HtmlAgilityPack;
using Microsoft.AspNetCore.Http;
using Newtonsoft.Json.Linq;
using Shared.Models.Catalog;

namespace Shared.Models.CSharpGlobals
{
    public record CatalogPlaylist(CatalogSettings init, string plugin, string host, string html, HtmlDocument doc, List<PlaylistItem> playlists);

    public record CatalogChangePlaylis(CatalogSettings init, string plugin, string host, string html, HtmlNodeCollection nodes, PlaylistItem pl, HtmlNode row);

    public record CatalogPlaylistJson(CatalogSettings init, string plugin, string host, string html, JToken json, List<PlaylistItem> playlists);

    public record CatalogChangePlaylisJson(CatalogSettings init, string plugin, string host, string html, IEnumerable<JToken> nodes, PlaylistItem pl, JToken row);

    public record CatalogGlobalsMenuRoute(string host, string plugin, string args, string url, string search, string cat, string sort, IQueryCollection query, int page);

    public record CatalogNodeValue(string value, string host);

    public record CatalogInitUrlCard(string host, string args, string uri, IQueryCollection query, string type);

    public record CatalogInitHeader(string url, List<HeadersModel> headers);
}

```

## File: Shared/Models/CSharpGlobals/OverrideResponseGlobals.cs
```
Ôªøusing Microsoft.AspNetCore.Http;

namespace Shared.Models.CSharpGlobals
{
    public class OverrideResponseGlobals
    {
        public OverrideResponseGlobals() { }

        public OverrideResponseGlobals(string url, HttpRequest rq, RequestModel rinfo)
        {
            request = rq;
            requestInfo = rinfo;
        }

        public string url { get; set; }

        public HttpRequest request { get; set; }

        public RequestModel requestInfo { get; set; }
    }
}

```

## File: Shared/Models/CSharpGlobals/NxtGlobals.cs
```
Ôªøusing HtmlAgilityPack;
using Microsoft.AspNetCore.Http;
using Microsoft.Playwright;
using Shared.Engine;
using Shared.Models.SISI.Base;
using Shared.Models.SISI.NextHUB;

namespace Shared.Models.CSharpGlobals
{
    public record NxtPlaylist(NxtSettings init, string plugin, string host, string html, HtmlDocument doc, List<PlaylistItem> playlists);

    public record NxtChangePlaylis(NxtSettings init, string plugin, string host, string html, HtmlNodeCollection nodes, PlaylistItem pl, HtmlNode row);

    public record NxtRoute(IRoute route, IQueryCollection query, string requestUrl, string search, string sort, string cat, string model, int page);

    public record NxtEvalView(NxtSettings init, IQueryCollection query, string html, string plugin, string url, string file, List<HeadersModel> headers, ProxyManager proxyManager);

    public record NxtRegexMatch(string html, RegexMatchSettings m);

    public record NxtMenuRoute(string host, string plugin, string url, string search, string cat, string sort, string model, IQueryCollection query, int page);

    public record NxtUrlRequest(string host, string plugin, string url, IQueryCollection query, bool related);

    public record NxtNodeValue(string value, string host);
}

```

## File: Shared/Models/ServerProxy/HlsCachePattern.cs
```
Ôªønamespace Shared.Models.ServerProxy
{
    public class HlsCachePattern
    {
        /// <summary>
        /// match
        /// replace
        /// </summary>
        public string type { get; set; }

        /// <summary>
        /// match[index]
        /// </summary>
        public int index { get; set; }

        public string pattern { get; set; }

        public string replacement { get; set; }
    }
}

```

## File: Shared/Models/ServerProxy/ServerproxyBufferingConf.cs
```
Ôªønamespace Shared.Models.ServerProxy
{
    public class ServerproxyBufferingConf
    {
        public bool enable { get; set; }

        public string pattern { get; set; }

        public int rent { get; set; }

        public int length { get; set; }
    }
}

```

## File: Shared/Models/ServerProxy/ServerproxyConf.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.ServerProxy
{
    public class ServerproxyConf : Iproxy
    {
        public bool enable { get; set; }

        public bool encrypt { get; set; }

        public bool encrypt_aes { get; set; }

        public bool verifyip { get; set; }

        public bool showOrigUri { get; set; }

        public bool responseContentLength { get; set; }

        public ServerproxyImageConf image { get; set; } = new ServerproxyImageConf();


        public bool forced_apn { get; set; }

        public ServerproxyBufferingConf buffering { get; set; } = new ServerproxyBufferingConf();

        public int maxlength_m3u { get; set; }

        public int maxlength_ts { get; set; }


        public bool useproxy { get; set; }

        public bool useproxystream { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }
    }
}

```

## File: Shared/Models/ServerProxy/HlsCacheConf.cs
```
Ôªønamespace Shared.Models.ServerProxy
{
    public class HlsCacheConf
    {
        public bool enable { get; set; }

        public string plugin { get; set; }

        public List<HlsCachePattern> tasks { get; set; }
    }
}

```

## File: Shared/Models/ServerProxy/ServerproxyImageConf.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.ServerProxy
{
    public class ServerproxyImageConf : Iproxy
    {
        public bool cache { get; set; }

        public bool cache_rsize { get; set; }

        public int cache_time { get; set; }


        public bool useproxy { get; set; }

        public bool useproxystream { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }
    }
}

```

## File: Shared/Models/Base/CorseuRequest.cs
```
Ôªønamespace Shared.Models.Base
{
    public class CorseuRequest
    {
        public string browser { get; set; }

        public string url { get; set; }

        public string method { get; set; }

        public string data { get; set; }

        public int? httpversion { get; set; }

        public int? timeout { get; set; }

        public string encoding { get; set; }

        public Dictionary<string, string> headers { get; set; }

        public bool? defaultHeaders { get; set; }

        public bool? autoredirect { get; set; }

        public string proxy { get; set; }

        public string proxy_name { get; set; }

        public bool? headersOnly { get; set; }

        public string auth_token { get; set; }
    }
}

```

## File: Shared/Models/Base/UserSync.cs
```
Ôªøusing LiteDB;

namespace Shared.Models.Base
{
    public class UserSync
    {
        [BsonId]
        public string id { get; set; }

        public Dictionary<string, Dictionary<string, string>> timecodes { get; set; } = new Dictionary<string, Dictionary<string, string>>();
    }
}

```

## File: Shared/Models/Base/MediaRequest.cs
```
Ôªønamespace Shared.Models.Base
{
    public class MediaRequestBase
    {
        public string auth_token { get; set; }

        public string type { get; set; }

        public int? width { get; set; }

        public int? height { get; set; }

        public Dictionary<string, string> headers { get; set; }

        public string proxy { get; set; }

        public string proxy_name { get; set; }

        public bool apnstream { get; set; }

        public bool useproxystream { get; set; } = true;
    }

    public class MediaRequest : MediaRequestBase
    {
        public List<string> urls { get; set; } = new();
    }
}

```

## File: Shared/Models/Base/PosterApi.cs
```
Ôªøusing System.Text.RegularExpressions;

namespace Shared.Models.Base
{
    public static class PosterApi
    {
        static string omdbapi_key;
        static PosterApiConf init;
        static IProxyLink iproxy;

        public static void Initialization(string omdbkey, PosterApiConf conf, IProxyLink _iproxy)
        {
            omdbapi_key = omdbkey;
            init = conf;
            iproxy = _iproxy;
        }

        public static string Find(long? kpid, string imdb)
        {
            string imdb_img = null, kp_img = null;

            if (!string.IsNullOrEmpty(omdbapi_key) && !string.IsNullOrEmpty(imdb))
                imdb_img = $"https://img.omdbapi.com/?apikey={omdbapi_key}&i={imdb}";

            if (kpid > 0)
                kp_img = $"https://st.kp.yandex.net/images/film_iphone/iphone360_{kpid}.jpg";

            if (imdb_img != null && kp_img != null)
                return Size($"{imdb_img} or {kp_img}");

            return Size(imdb_img ?? kp_img);
        }

        public static string Size(string host, string uri)
        {
            if (string.IsNullOrEmpty(uri))
                return uri;

            string img = Size(uri);
            if (img.StartsWith("http"))
                return img;

            return host + img;
        }

        public static string Size(string uri)
        {
            if (string.IsNullOrEmpty(uri) || iproxy == null || init == null || !init.rsize || (init.width == 0 && init.height == 0))
                return uri?.Split(" or ")?[0];

            if (!string.IsNullOrEmpty(init.disable_rsize) && Regex.IsMatch(uri, init.disable_rsize, RegexOptions.IgnoreCase))
                return uri?.Split(" or ")?[0];

            if (!string.IsNullOrEmpty(init.bypass) && Regex.IsMatch(uri, init.bypass, RegexOptions.IgnoreCase))
                return $"{init.host}/proxyimg/{iproxy.Encrypt(uri, "posterapi")}";

            return $"{init.host}/proxyimg:{init.width}:{init.height}/{iproxy.Encrypt(uri, "posterapi")}";
        }
    }
}

```

## File: Shared/Models/Base/Igroup.cs
```
Ôªønamespace Shared.Models.Base
{
    public interface Igroup
    {
        public int group { get; set; }

        public bool group_hide { get; set; }
    }
}

```

## File: Shared/Models/Base/ProxySettings.cs
```
Ôªønamespace Shared.Models.Base
{
    public class ProxySettings : ICloneable
    {
        public string name;

        public string pattern;


        public bool useAuth;

        public bool BypassOnLocal;

        public string username;

        public string password;


        public string pattern_auth = "^(?<sheme>[^/]+//)?(?<username>[^:/]+):(?<password>[^@]+)@(?<host>.*)";

        public int maxRequestError = 2;


        public string file;

        public string url;

        public string[] list;


        public string refresh_uri;

        public List<ProxyAction> actions;

        public int actions_attempts = 6;


        public object Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Base/PosterApiConf.cs
```
Ôªønamespace Shared.Models.Base
{
    public class PosterApiConf : Iproxy
    {
        public string host { get; set; }

        public bool rsize { get; set; }

        public int height { get; set; }

        public int width { get; set; }


        /// <summary>
        /// –ü—Ä–æ–∫—Å–∏—Ç—å –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞
        /// </summary>
        public string bypass { get; set; }

        /// <summary>
        /// –ù–µ –ø—Ä–æ–∫—Å–∏—Ç—å
        /// </summary>
        public string disable_rsize { get; set; }


        #region proxy
        public bool useproxy { get; set; }

        public bool useproxystream { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }
        #endregion
    }
}

```

## File: Shared/Models/Base/BaseSettings.cs
```
Ôªøusing Newtonsoft.Json;

namespace Shared.Models.Base
{
    public class BaseSettings : Iproxy, Istreamproxy, Icors, Igroup, ICloneable
    {
        bool _enable;

        public bool enable 
        {
            get 
            {
                if (AppInit.conf.defaultOn == "enabled")
                    return enabled;

                return _enable;
            }
            set
            {
                _enable = value;
            }
        }

        public bool enabled { get; set; }

        public bool spider { get; set; } = true;


        public bool kit { get; set; } = true;

        public string plugin { get; set; }

        public int group { get; set; }

        public bool group_hide { get; set; } = true;

        public bool rhub { get; set; }

        public bool rhub_streamproxy { get; set; }

        public bool rhub_fallback { get; set; }

        public string[] rhub_geo_disable { get; set; }

        public string[] geo_hide { get; set; }

        public string client_type { get; set; }

        public bool rip { get; set; }

        public int cache_time { get; set; }

        public string displayname { get; set; }

        public int displayindex { get; set; }

        public string overridehost { get; set; }

        public string[] overridehosts { get; set; }

        public string overridepasswd { get; set; }

        public string host { get; set; }

        public string apihost { get; set; }

        public string scheme { get; set; }

        public bool hls { get; set; }

        public string cookie { get; set; }

        public string token { get; set; }

        [JsonProperty("headers",
            ObjectCreationHandling = ObjectCreationHandling.Replace,   // ‚Üê –∑–∞–º–µ–Ω–∏—Ç—å, –∞ –Ω–µ –¥–æ–ø–æ–ª–Ω—è—Ç—å
            NullValueHandling = NullValueHandling.Ignore               // ‚Üê –Ω–µ –∑–∞—Ç–∏—Ä–∞—Ç—å null-–æ–º
        )]
        public Dictionary<string, string> headers { get; set; }

        [JsonProperty("headers_stream",
            ObjectCreationHandling = ObjectCreationHandling.Replace,   // ‚Üê –∑–∞–º–µ–Ω–∏—Ç—å, –∞ –Ω–µ –¥–æ–ø–æ–ª–Ω—è—Ç—å
            NullValueHandling = NullValueHandling.Ignore               // ‚Üê –Ω–µ –∑–∞—Ç–∏—Ä–∞—Ç—å null-–æ–º
        )]
        public Dictionary<string, string> headers_stream { get; set; }

        public VastConf vast { get; set; }

        public string priorityBrowser { get; set; }


        #region proxy
        public bool useproxy { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }

        public bool useproxystream { get; set; }

        public bool streamproxy { get; set; }

        public bool apnstream { get; set; }

        public string[] geostreamproxy { get; set; }

        public ApnConf apn { get; set; }

        public bool qualitys_proxy { get; set; } = true;

        public bool url_reserve { get; set; }
        #endregion

        #region cors
        public bool corseu { get; set; }

        public string webcorshost { get; set; }

        public string corsHost()
        {
            string crhost = !string.IsNullOrWhiteSpace(webcorshost) ? webcorshost : corseu ? AppInit.conf.corsehost : null;
            if (string.IsNullOrWhiteSpace(crhost))
                return host;

            return $"{crhost}/{host}";
        }

        public string cors(string uri)
        {
            string crhost = !string.IsNullOrWhiteSpace(webcorshost) ? webcorshost : corseu ? AppInit.conf.corsehost : null;
            if (string.IsNullOrWhiteSpace(crhost) || string.IsNullOrWhiteSpace(uri) || uri.Contains(crhost))
                return uri;

            return $"{crhost}/{uri}";
        }
        #endregion


        public string Decrypt(string data)
        {
            try
            {
                if (data == null)
                    return data;

                char[] buffer = data.ToCharArray();
                for (int i = 0; i < buffer.Length; i++)
                {
                    char letter = buffer[i];
                    letter = (char)(letter - 3);
                    buffer[i] = letter;
                }

                return new string(buffer);
            }
            catch { return null; }
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Base/AccsUser.cs
```
Ôªønamespace Shared.Models.Base
{
    public class AccsUser
    {
        public string id { get; set; }

        public List<string> ids { get; set; } = new List<string>();

        public bool IsPasswd { get; set; }

        public DateTime expires { get; set; }

        public int group { get; set; }

        public bool ban { get; set; }

        public string ban_msg { get; set; }

        public string comment { get; set; }

        public Dictionary<string, object> @params { get; set; }
    }
}

```

## File: Shared/Models/Base/VastConf.cs
```
Ôªønamespace Shared.Models.Base
{
    public class VastConf
    {
        public VastConf() { }

        public VastConf(string url, string msg) 
        {
            this.url = url;
            this.msg = msg;
        }

        public string url { get; set; }

        public string msg { get; set; }

        /// <summary>
        /// ru,ua,kz,etc
        /// </summary>
        public string region { get; set; }

        /// <summary>
        /// 'android','noname','webos','tizen','apple','browser','nw','philips','orsay','apple_tv','netcast','electron'
        /// </summary>
        public string platform { get; set; }

        /// <summary>
        /// tv, mobile
        /// </summary>
        public string screen { get; set; }
    }
}

```

## File: Shared/Models/Base/IProxyLink.cs
```
Ôªønamespace Shared.Models.Base
{
    public interface IProxyLink
    {
        public string Encrypt(string uri, string plugin, DateTime ex = default);
    }
}

```

## File: Shared/Models/Base/Iproxy.cs
```
Ôªønamespace Shared.Models.Base
{
    public interface Iproxy
    {
        public bool useproxy { get; set; }

        public bool useproxystream { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }
    }
}

```

## File: Shared/Models/Base/ApnConf.cs
```
Ôªønamespace Shared.Models.Base
{
    public class ApnConf
    {
        public string host { get; set; }

        public string secure { get; set; }

        public string secret { get; set; }
    }
}

```

## File: Shared/Models/Base/Istreamproxy.cs
```
Ôªønamespace Shared.Models.Base
{
    public interface Istreamproxy
    {
        public bool rhub { get; set; }

        public bool rhub_streamproxy { get; set; }

        public bool useproxystream { get; set; }

        public bool streamproxy { get; set; }

        public bool apnstream { get; set; }

        public string[] geostreamproxy { get; set; }

        public bool qualitys_proxy { get; set; }

        public ProxySettings proxy { get; set; }

        public ApnConf apn { get; set; }
    }
}

```

## File: Shared/Models/Base/Icors.cs
```
Ôªønamespace Shared.Models.Base
{
    public interface Icors
    {
        public string host { get; set; }

        public bool corseu { get; set; }

        public string webcorshost { get; set; }


        public string corsHost();

        public string cors(string uri);
    }
}

```

## File: Shared/Models/Base/ProxyAction.cs
```
Ôªønamespace Shared.Models.Base
{
    public class ProxyAction
    {
        public string url;
        public string data;
        public string contains;

        public int timeoutSeconds = 5;
    }
}

```

## File: Shared/Models/Merchant/StreampayConf.cs
```
Ôªønamespace Shared.Models.Merchant
{
    public class StreampayConf
    {
        public bool enable { get; set; }

        public long store_id { get; set; }

        public string public_key { get; set; }

        public string private_key { get; set; }
    }
}

```

## File: Shared/Models/Merchant/MerchantsModel.cs
```
Ôªøusing Shared.Models.Merchant.LtcWallet;

namespace Shared.Models.Merchant
{
    public class MerchantsModel
    {
        public int accessCost { get; set; } = 2;

        public int accessForMonths { get; set; } = 1;

        public int allowedDifference { get; set; }

        public int defaultGroup { get; set; }

        public B2payConf B2PAY { get; set; } = new B2payConf();

        public CryptoCloudConf CryptoCloud { get; set; } = new CryptoCloudConf();

        public FreekassaConf FreeKassa { get; set; } = new FreekassaConf();

        public StreampayConf Streampay { get; set; } = new StreampayConf();

        public LtcWalletConf LtcWallet { get; set; } = new LtcWalletConf();
    }
}

```

## File: Shared/Models/Merchant/CryptoCloudConf.cs
```
Ôªønamespace Shared.Models.Merchant
{
    public class CryptoCloudConf
    {
        public bool enable { get; set; }

        public string SHOPID { get; set; }

        public string APIKEY { get; set; }

        public string SECRETKEY { get; set; }
    }
}

```

## File: Shared/Models/Merchant/B2payConf.cs
```
Ôªønamespace Shared.Models.Merchant
{
    public class B2payConf
    {
        public bool enable { get; set; }

        public bool sandbox { get; set; }

        public long username_id { get; set; }

        public string encryption_iv { get; set; }

        public string encryption_password { get; set; }
    }
}

```

## File: Shared/Models/Merchant/FreekassaConf.cs
```
Ôªønamespace Shared.Models.Merchant
{
    public class FreekassaConf
    {
        public bool enable { get; set; }

        public long shop_id { get; set; }

        public string secret { get; set; }
    }
}

```

## File: Shared/Models/Merchant/LtcWallet/Transaction.cs
```
Ôªønamespace Shared.Models.Merchant.LtcWallet
{
    public class Transaction
    {
        public string address { get; set; }

        public string category { get; set; }

        public double amount { get; set; }

        public string status { get; set; }

        public string txid { get; set; }
    }
}

```

## File: Shared/Models/Merchant/LtcWallet/LtcWalletConf.cs
```
Ôªønamespace Shared.Models.Merchant.LtcWallet
{
    public class LtcWalletConf
    {
        public bool enable { get; set; }

        public string rpc { get; set; } = "http://127.0.0.1:9332/";

        public string rpcuser { get; set; } = "ltc";

        public string rpcpassword { get; set; } = "ltc";
    }
}

```

## File: Shared/Models/Merchant/LtcWallet/RootTransactions.cs
```
Ôªønamespace Shared.Models.Merchant.LtcWallet
{
    public class RootTransactions
    {
        public List<Transaction> result { get; set; }
    }
}

```

## File: Shared/Models/SQL/HybridCacheContext.cs
```
Ôªøusing Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;

namespace Shared.Models.SQL
{
    public partial class HybridCacheContext
    {
        public static void Initialization() 
        {
            try
            {
                var sqlDb = new HybridCacheContext();
                    sqlDb.Database.EnsureCreated();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"HybridCacheDb initialization failed: {ex.Message}");
            }
        }
    }


    public partial class HybridCacheContext : DbContext
    {
        public DbSet<HybridCacheSqlModel> files { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlite("Data Source=cache/HybridCache.sql");
            optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<HybridCacheSqlModel>()
                        .HasIndex(j => j.ex);
        }
    }

    public class HybridCacheSqlModel
    {
        [Key]
        public string Id { get; set; }

        public DateTime ex { get; set; }

        public string value { get; set; }
    }
}

```

## File: Shared/Models/SQL/ExternalidsContext.cs
```
Ôªøusing Microsoft.Data.Sqlite;
using Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;
using System.Threading;

namespace Shared.Models.SQL
{
    public partial class ExternalidsContext
    {
        public static readonly SemaphoreSlim semaphore = new SemaphoreSlim(1, 1);

        public static void Initialization() 
        {
            try
            {
                var sqlDb = new ExternalidsContext();
                    sqlDb.Database.EnsureCreated();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"ExternalidsDb initialization failed: {ex.Message}");
            }
        }

        async public Task<int> SaveChangesLocks()
        {
            try
            {
                await semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                return await base.SaveChangesAsync();
            }
            catch
            {
                return 0;
            }
            finally
            {
                semaphore.Release();
            }
        }
    }


    public partial class ExternalidsContext : DbContext
    {
        public DbSet<ExternalidsSqlModel> imdb { get; set; }

        public DbSet<ExternalidsSqlModel> kinopoisk { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlite(new SqliteConnectionStringBuilder
            {
                DataSource = "cache/Externalids.sql",
                Cache = SqliteCacheMode.Shared,
                DefaultTimeout = 10,
                Pooling = true
            }.ToString());

            optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
        }
    }

    public class ExternalidsSqlModel
    {
        [Key]
        public string Id { get; set; }

        public string value { get; set; }
    }
}

```

## File: Shared/Models/SQL/SisiContext.cs
```
using Microsoft.Data.Sqlite;
using Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;
using System.Threading;

namespace Shared.Models.SQL
{
    public partial class SisiContext
    {
        public static readonly SemaphoreSlim semaphore = new SemaphoreSlim(1, 1);

        public static void Initialization() 
        {
            Directory.CreateDirectory("database");

            try
            {
                using (var sqlDb = new SisiContext())
                {
                    sqlDb.Database.EnsureCreated();

                    #region migrate historys table
                    try
                    {
                        using (var conn = sqlDb.Database.GetDbConnection())
                        {
                            conn.Open();
                            using (var cmd = conn.CreateCommand())
                            {
                                cmd.CommandText = "SELECT name FROM sqlite_master WHERE type='table' AND name='historys';";
                                var res = cmd.ExecuteScalar();
                                if (res == null)
                                {
                                    cmd.CommandText = @"CREATE TABLE IF NOT EXISTS historys (
                                                        Id INTEGER PRIMARY KEY AUTOINCREMENT,
                                                        user TEXT NOT NULL,
                                                        uid TEXT NOT NULL,
                                                        created TEXT,
                                                        json TEXT
                                                    );";
                                    cmd.ExecuteNonQuery();

                                    cmd.CommandText = "CREATE UNIQUE INDEX IF NOT EXISTS IX_historys_user_uid ON historys(user, uid);";
                                    cmd.ExecuteNonQuery();
                                }
                            }
                            conn.Close();
                        }
                    }
                    catch { }
                    #endregion
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"SisiDb initialization failed: {ex.Message}");
            }
        }

        async public Task<int> SaveChangesLocks()
        {
            try
            {
                await semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                return await base.SaveChangesAsync();
            }
            catch
            {
                return 0;
            }
            finally
            {
                semaphore.Release();
            }
        }
    }


    public partial class SisiContext : DbContext
    {
        public DbSet<SisiBookmarkSqlModel> bookmarks { get; set; }

        public DbSet<SisiHistorySqlModel> historys { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlite(new SqliteConnectionStringBuilder
            {
                DataSource = "database/Sisi.sql",
                Cache = SqliteCacheMode.Shared,
                DefaultTimeout = 10,
                Pooling = true
            }.ToString());

            optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<SisiBookmarkSqlModel>()
                        .HasIndex(b => new { b.user, b.uid })
                        .IsUnique();

            modelBuilder.Entity<SisiHistorySqlModel>()
                        .HasIndex(h => new { h.user, h.uid })
                        .IsUnique();
        }
    }

    public class SisiBookmarkSqlModel
    {
        [Key]
        public long Id { get; set; }

        [Required]
        public string user { get; set; }

        [Required]
        public string uid { get; set; }

        public DateTime created { get; set; }

        public string json { get; set; }

        public string name { get; set; }

        public string model { get; set; }
    }

    public class SisiHistorySqlModel
    {
        [Key]
        public long Id { get; set; }

        [Required]
        public string user { get; set; }

        [Required]
        public string uid { get; set; }

        public DateTime created { get; set; }

        public string json { get; set; }
    }
}

```

## File: Shared/Models/SQL/SyncUserContext.cs
```
Ôªøusing Microsoft.Data.Sqlite;
using Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Threading;

namespace Shared.Models.SQL
{
    public partial class SyncUserContext
    {
        public static readonly SemaphoreSlim semaphore = new SemaphoreSlim(1, 1);

        public static void Initialization() 
        {
            Directory.CreateDirectory("database");

            try
            {
                var sqlDb = new SyncUserContext();
                    sqlDb.Database.EnsureCreated();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"SyncUserDb initialization failed: {ex.Message}");
            }
        }

        async public Task<int> SaveChangesLocks()
        {
            try
            {
                await semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                return await base.SaveChangesAsync();
            }
            catch
            {
                return 0;
            }
            finally
            {
                semaphore.Release();
            }
        }
    }


    public partial class SyncUserContext : DbContext
    {
        public DbSet<SyncUserTimecodeSqlModel> timecodes { get; set; }

        public DbSet<SyncUserBookmarkSqlModel> bookmarks { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlite(new SqliteConnectionStringBuilder
            {
                DataSource = "database/SyncUser.sql",
                Cache = SqliteCacheMode.Shared,
                DefaultTimeout = 10,
                Pooling = true
            }.ToString());

            optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<SyncUserTimecodeSqlModel>()
                        .HasIndex(t => new { t.user, t.card, t.item })
                        .IsUnique();

            modelBuilder.Entity<SyncUserBookmarkSqlModel>()
                        .HasIndex(t => t.user)
                        .IsUnique();
        }
    }

    public class SyncUserTimecodeSqlModel
    {
        [Key]
        public long Id { get; set; }

        [Required]
        public string user { get; set; }

        [Required]
        public string card { get; set; }

        [Required]
        public string item { get; set; }

        public string data { get; set; }

        public DateTime updated { get; set; }
    }

    [Table("bookmarks")]
    public class SyncUserBookmarkSqlModel
    {
        [Key]
        public long Id { get; set; }

        [Required]
        public string user { get; set; }

        [Required]
        public string data { get; set; }

        public DateTime updated { get; set; }
    }
}

```

## File: Shared/Models/SQL/ProxyLinkContext.cs
```
Ôªøusing Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;

namespace Shared.Models.SQL
{
    public partial class ProxyLinkContext
    {
        public static ProxyLinkContext Read { get; private set; }

        public static void Initialization() 
        {
            try
            {
                var sqlDb = new ProxyLinkContext();
                    sqlDb.Database.EnsureCreated();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"ProxyLinkDb initialization failed: {ex.Message}");
            }
        }
    }


    public partial class ProxyLinkContext : DbContext
    {
        public DbSet<ProxyLinkSqlModel> links { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlite("Data Source=cache/ProxyLink.sql");
            optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<ProxyLinkSqlModel>()
                        .HasIndex(j => j.ex);
        }
    }

    public class ProxyLinkSqlModel
    {
        [Key]
        public string Id { get; set; }

        public DateTime ex { get; set; }

        public string json { get; set; }
    }
}

```

## File: Shared/Models/SQL/PlaywrightContext.cs
```
Ôªøusing Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;

namespace Shared.Models.SQL
{
    public partial class PlaywrightContext
    {
        public static void Initialization() 
        {
            try
            {
                var sqlDb = new PlaywrightContext();
                    sqlDb.Database.EnsureCreated();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"PlaywrightDb initialization failed: {ex.Message}");
            }
        }
    }


    public partial class PlaywrightContext : DbContext
    {
        public DbSet<PlaywrightSqlModel> files { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlite("Data Source=cache/Playwright.sql");
            optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<ProxyLinkSqlModel>()
                        .HasIndex(j => j.ex);
        }
    }

    public class PlaywrightSqlModel
    {
        [Key]
        public string Id { get; set; }

        public DateTime ex { get; set; }

        public byte[] content { get; set; }

        public string headers { get; set; }
    }
}

```

## File: Shared/PlaywrightCore/Firefox.cs
```
Ôªøusing Microsoft.Playwright;
using Shared.Engine;
using Shared.Models.Browser;
using System.Runtime.InteropServices;
using System.Threading;

namespace Shared.PlaywrightCore
{
    public class Firefox : PlaywrightBase, IDisposable
    {
        #region static
        static List<KeepopenPage> pages_keepopen = new();

        public static long stats_keepopen { get; set; }

        public static long stats_newcontext { get; set; }

        static IPlaywright playwright = null;
        static IBrowser browser = null;

        static bool shutdown = false;

        public static PlaywrightStatus Status { get; private set; } = PlaywrightStatus.disabled;

        public static int ContextsCount => browser?.Contexts?.Count ?? 0;

        async public static Task CreateAsync()
        {
            try
            {
                var init = AppInit.conf.firefox;
                if (!init.enable || browser != null || shutdown)
                    return;

                string executablePath = init.executablePath;

                #region Download firefox
                if (string.IsNullOrEmpty(executablePath))
                {
                    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                    {
                        switch (RuntimeInformation.ProcessArchitecture)
                        {
                            case Architecture.X86:
                            case Architecture.X64:
                                {
                                    string camoufox = RuntimeInformation.ProcessArchitecture == Architecture.X64 ? "x86_64" : "i686";
                                    string uri = $"https://github.com/immisterio/playwright/releases/download/chrome/camoufox-135.0.1-beta.23-win.{camoufox}.zip";
                                    bool res = await DownloadFile(uri, ".playwright/firefox/release.zip", "firefox/");
                                    if (!res)
                                    {
                                        Console.WriteLine("Firefox: error download firefox.zip");
                                        return;
                                    }

                                    executablePath = ".playwright\\firefox\\camoufox.exe";
                                    break;
                                }
                            default:
                                Console.WriteLine("Firefox: Architecture unknown");
                                return;
                        }
                    }
                    else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
                    {
                        switch (RuntimeInformation.ProcessArchitecture)
                        {
                            case Architecture.X64:
                            case Architecture.Arm64:
                                {
                                    string camoufox = RuntimeInformation.ProcessArchitecture == Architecture.X64 ? "x86_64" : "arm64";
                                    string uri = $"https://github.com/immisterio/playwright/releases/download/chrome/camoufox-135.0.1-beta.23-mac.{camoufox}.zip";
                                    bool res = await DownloadFile(uri, ".playwright/camoufox.zip");
                                    if (!res)
                                    {
                                        Console.WriteLine("Firefox: error download camoufox.zip");
                                        return;
                                    }

                                    Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), ".playwright/Camoufox.app/Contents/MacOS/camoufox")}");
                                    executablePath = ".playwright/Camoufox.app/Contents/MacOS/camoufox";
                                    await Task.Delay(TimeSpan.FromSeconds(4));
                                    break;
                                }
                            default:
                                Console.WriteLine("Firefox: Architecture unknown");
                                return;
                        }
                    }
                    else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                    {
                        string camoufox = null;

                        switch (RuntimeInformation.ProcessArchitecture)
                        {
                            case Architecture.X86:
                                camoufox = "i686";
                                break;
                            case Architecture.X64:
                                camoufox = "x86_64";
                                break;
                            case Architecture.Arm64:
                                camoufox = "arm64";
                                break;
                            default:
                                Console.WriteLine("Firefox: Architecture unknown");
                                return;
                        }

                        if (camoufox != null)
                        {
                            string uri = $"https://github.com/immisterio/playwright/releases/download/chrome/camoufox-135.0.1-beta.23-lin.{camoufox}.zip";
                            bool res = await DownloadFile(uri, ".playwright/camoufox.zip", "firefox/");
                            if (!res)
                            {
                                Console.WriteLine("Firefox: error download camoufox.zip");
                                return;
                            }

                            Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), ".playwright/firefox/camoufox")}");
                            executablePath = ".playwright/firefox/camoufox";
                            await Task.Delay(TimeSpan.FromSeconds(4));
                        }
                    }
                    else
                    {
                        Console.WriteLine("Firefox: IsOSPlatform unknown");
                        return;
                    }
                }
                #endregion

                if (string.IsNullOrEmpty(executablePath))
                {
                    Console.WriteLine("Firefox: firefox is not installed, please specify full path in executablePath");
                    return;
                }

                Console.WriteLine("Firefox: Initialization");

                playwright = await Playwright.CreateAsync();

                Console.WriteLine("Firefox: CreateAsync");

                browser = await playwright.Firefox.LaunchAsync(new BrowserTypeLaunchOptions
                {
                    Headless = init.Headless,
                    ExecutablePath = executablePath,
                    Args = init.Args
                });

                Console.WriteLine("Firefox: LaunchAsync");

                Status = init.Headless ? PlaywrightStatus.headless : PlaywrightStatus.NoHeadless;
                Console.WriteLine($"Firefox: v{browser.Version} / {Status.ToString()} / {browser.IsConnected}");

                browser.Disconnected += Browser_Disconnected;
            }
            catch (Exception ex) 
            {
                Status = PlaywrightStatus.disabled;
                Console.WriteLine($"Firefox: {ex.Message}"); 
            }
        }

        async private static void Browser_Disconnected(object sender, IBrowser e)
        {
            Status = PlaywrightStatus.disabled;
            browser.Disconnected -= Browser_Disconnected;
            Console.WriteLine("Firefox: Browser_Disconnected");

            if (pages_keepopen != null)
                pages_keepopen.Clear();

            try
            {
                await browser.CloseAsync();
                await browser.DisposeAsync();
            }
            catch { }

            browser = null;

            try
            {
                playwright.Dispose();
            }
            catch { }

            playwright = null;
            pages_keepopen = new();
            await Task.Delay(TimeSpan.FromSeconds(10));
            await CreateAsync();
        }
        #endregion

        #region CronStart
        public static void CronStart()
        {
            _closeLifetimeTimer = new Timer(CronCloseLifetimeContext, null, TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1));
        }

        static Timer _closeLifetimeTimer;

        static bool _cronCloseLifetimeWork = false;
        #endregion

        #region CronCloseLifetimeContext
        async static void CronCloseLifetimeContext(object state)
        {
            if (!AppInit.conf.firefox.enable || Status == PlaywrightStatus.disabled)
                return;

            if (_cronCloseLifetimeWork)
                return;

            _cronCloseLifetimeWork = true;

            try
            {
                var init = AppInit.conf.firefox;
                if (0 >= init.context.keepalive)
                    return;

                foreach (var k in pages_keepopen.ToArray())
                {
                    if (Math.Max(1, init.context.min) >= pages_keepopen.Count)
                        break;

                    if (DateTime.Now > k.lastActive.AddMinutes(init.context.keepalive))
                    {
                        try
                        {
                            await k.page.CloseAsync().ConfigureAwait(false);
                            pages_keepopen.Remove(k);
                        }
                        catch { }
                    }
                }
            }
            catch { }
            finally
            {
                _cronCloseLifetimeWork = false;
            }
        }
        #endregion


        public bool IsCompleted { get; set; }

        public string failedUrl { get; set; }

        IPage page { get; set; }

        KeepopenPage keepopen_page { get; set; }


        async public Task<IPage> NewPageAsync(string plugin, Dictionary<string, string> headers = null, (string ip, string username, string password) proxy = default, bool keepopen = true)
        {
            try
            {
                if (browser == null)
                    return null;

                if (proxy != default)
                {
                    #region proxy NewContext
                    if (keepopen)
                    {
                        foreach (var pg in pages_keepopen.ToArray().Where(i => i.proxy != default))
                        {
                            if (pg.plugin == plugin)
                            {
                                if (pg.proxy.ip != proxy.ip || pg.proxy.username != proxy.username || pg.proxy.password != proxy.password)
                                {
                                    _ = pg.page.CloseAsync().ConfigureAwait(false);
                                    pages_keepopen.Remove(pg);
                                    continue;
                                }
                            }

                            if (pg.proxy.ip == proxy.ip && pg.proxy.username == proxy.username && pg.proxy.password == proxy.password)
                            {
                                stats_keepopen++;
                                pg.busy = true;
                                keepopen_page = pg;
                                page = pg.page;
                                page.RequestFailed += Page_RequestFailed;

                                if (headers != null && headers.Count > 0)
                                    await page.SetExtraHTTPHeadersAsync(headers).ConfigureAwait(false);

                                return page;
                            }
                        }
                    }

                    var contextOptions = new BrowserNewContextOptions
                    {
                        Proxy = new Proxy 
                        { 
                            Server = proxy.ip,
                            Bypass = "127.0.0.1",
                            Username = proxy.username,
                            Password = proxy.password
                        }
                    };

                    stats_newcontext++;
                    var context = await browser.NewContextAsync(contextOptions).ConfigureAwait(false);
                    page = await context.NewPageAsync().ConfigureAwait(false);
                    #endregion
                }
                else
                {
                    #region NewContext
                    if (keepopen)
                    {
                        foreach (var pg in pages_keepopen.Where(i => i.proxy == default))
                        {
                            if (pg.busy == false && DateTime.Now > pg.lockTo)
                            {
                                stats_keepopen++;
                                pg.busy = true;
                                keepopen_page = pg;
                                page = pg.page;
                                page.RequestFailed += Page_RequestFailed;

                                if (headers != null && headers.Count > 0)
                                    await page.SetExtraHTTPHeadersAsync(headers).ConfigureAwait(false);

                                return page;
                            }
                        }
                    }

                    stats_newcontext++;
                    page = await browser.NewPageAsync().ConfigureAwait(false);
                    #endregion
                }

                if (headers != null && headers.Count > 0)
                    await page.SetExtraHTTPHeadersAsync(headers).ConfigureAwait(false);

                page.Popup += Page_Popup;
                page.Download += Page_Download;

                if (!keepopen || !AppInit.conf.firefox.context.keepopen || pages_keepopen.Count >= Math.Max(AppInit.conf.firefox.context.min, AppInit.conf.firefox.context.max))
                {
                    page.RequestFailed += Page_RequestFailed;
                    return page;
                }

                keepopen_page = new KeepopenPage() { page = page, busy = true, plugin = plugin, proxy = proxy };
                pages_keepopen.Add(keepopen_page);
                page.RequestFailed += Page_RequestFailed;
                return page;
            }
            catch { return null; }
        }


        void Page_RequestFailed(object sender, IRequest e)
        {
            try
            {
                if (failedUrl != null && e.Url == failedUrl)
                {
                    completionSource.SetResult(null);
                    WebLog(e.Method, e.Url, "RequestFailed", default, e);
                }
            }
            catch { }
        }

        void Page_Download(object sender, IDownload e)
        {
            try
            {
                e.CancelAsync().ConfigureAwait(false);
            }
            catch { }
        }

        void Page_Popup(object sender, IPage e)
        {
            try
            {
                e.CloseAsync().ConfigureAwait(false);
            }
            catch { }
        }


        public void Dispose()
        {
            if (browser == null || AppInit.conf.firefox.DEV)
                return;

            try
            {
                page.RequestFailed -= Page_RequestFailed;

                if (keepopen_page != null)
                {
                    keepopen_page.page.GotoAsync("about:blank").ConfigureAwait(false);
                    keepopen_page.lastActive = DateTime.Now;
                    keepopen_page.lockTo = DateTime.Now.AddSeconds(1);
                    keepopen_page.busy = false;
                }
                else
                {
                    page.Popup -= Page_Popup;
                    page.Download -= Page_Download;
                    page.CloseAsync().ConfigureAwait(false);
                }
            }
            catch { }
        }

        public static void FullDispose()
        {
            shutdown = true;
            if (browser == null)
                return;

            try
            {
                browser.CloseAsync().ContinueWith(t => browser.DisposeAsync());
            }
            catch { }
        }
    }
}

```

## File: Shared/PlaywrightCore/Scraping.cs
```
Ôªøusing Shared.Engine;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.Text.RegularExpressions;
using Titanium.Web.Proxy;
using Titanium.Web.Proxy.EventArguments;
using Titanium.Web.Proxy.Http;
using Titanium.Web.Proxy.Models;

namespace Shared.PlaywrightCore
{
    public class Scraping : IDisposable
    {
        Process process;

        ExplicitProxyEndPoint explicitEndPoint;
        ProxyServer proxyServer;

        string patternUrl, headerKey;

        public bool IsCompleted { get; set; }

        public Action<SessionEventArgs> OnRequest { get; set; }

        public Action<SessionEventArgs> OnResponse { get; set; }


        public Scraping(string targetUrl, string patternUrl, string headerKey, string proxyBypassList = "*.example.com")
        {
            try
            {
                this.patternUrl = patternUrl;
                this.headerKey = headerKey;

                if (Chromium.Status != PlaywrightStatus.disabled)
                {
                    proxyServer = new ProxyServer();
                    proxyServer.BeforeRequest += Request;
                    proxyServer.BeforeResponse += Response;

                    if (!File.Exists("cache/titanium.pfx"))
                    {
                        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–æ—Ä–Ω–µ–≤–æ–π —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç (–µ—Å–ª–∏ –µ—â–µ –Ω–µ —Å–æ–∑–¥–∞–Ω)
                        if (proxyServer.CertificateManager.RootCertificate == null)
                            proxyServer.CertificateManager.CreateRootCertificate();

                        // –ü–æ–ª—É—á–∞–µ–º –∫–æ—Ä–Ω–µ–≤–æ–π —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç
                        X509Certificate2 rootCert = proxyServer.CertificateManager.RootCertificate;

                        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ PFX-—Ñ–∞–π–ª (—Å –ø–∞—Ä–æ–ª–µ–º)
                        byte[] certBytes = rootCert.Export(X509ContentType.Pkcs12, "35sd85454gfd");
                        File.WriteAllBytes("cache/titanium.pfx", certBytes);

                        certBytes = proxyServer.CertificateManager.RootCertificate.Export(X509ContentType.Cert);
                        File.WriteAllBytes("cache/titanium.crt", certBytes);
                    }

                    if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux) && !File.Exists("/usr/local/share/ca-certificates/lampac_titanium.crt"))
                    {
                        File.Copy("cache/titanium.crt", "/usr/local/share/ca-certificates/lampac_titanium.crt", true);
                        _ = Bash.Run("update-ca-certificates");
                    }

                    proxyServer.CertificateManager.LoadRootCertificate("cache/titanium.pfx", "35sd85454gfd");
                    proxyServer.ServerCertificateValidationCallback += OnCertificateValidation;

                    explicitEndPoint = new ExplicitProxyEndPoint(System.Net.IPAddress.Loopback, 0, true);
                    proxyServer.AddEndPoint(explicitEndPoint);
                    proxyServer.Start();

                    #region executablePath
                    string executablePath = AppInit.conf.chromium.executablePath;

                    if (string.IsNullOrEmpty(executablePath))
                    {
                        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                        {
                            if (RuntimeInformation.ProcessArchitecture == Architecture.Arm64)
                                executablePath = ".playwright\\chrome-win32\\chrome.exe";
                            else
                                executablePath = ".playwright\\chrome-win\\chrome.exe";
                        }
                        else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
                        {
                            executablePath = ".playwright/chrome-mac/Chromium.app/Contents/MacOS/Chromium";
                        }
                        else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                        {
                            executablePath = ".playwright/chrome-linux/chrome";
                        }
                    }

                    if (string.IsNullOrEmpty(executablePath) || !File.Exists(executablePath))
                        return;
                    #endregion

                    int proxyPort = explicitEndPoint.Port;

                    var startInfo = new ProcessStartInfo
                    {
                        FileName = executablePath,
                        UseShellExecute = false,
                        RedirectStandardOutput = true,
                        RedirectStandardError = true,
                        CreateNoWindow = false
                    };

                    startInfo.ArgumentList.Add($"--proxy-server=127.0.0.1:{proxyPort}");
                    startInfo.ArgumentList.Add($"--proxy-bypass-list=localhost;127.0.0.1;*.microsoft.com;{proxyBypassList}");
                    startInfo.ArgumentList.Add("--incognito");
                    startInfo.ArgumentList.Add("--ignore-certificate-errors");
                    startInfo.ArgumentList.Add("--ignore-ssl-errors");
                    startInfo.ArgumentList.Add("--disable-web-security");
                    startInfo.ArgumentList.Add("--no-first-run");
                    startInfo.ArgumentList.Add("--no-default-browser-check");
                    startInfo.ArgumentList.Add("--disable-background-mode");
                    startInfo.ArgumentList.Add("--no-sandbox");

                    if (AppInit.conf.chromium.Headless)
                    {
                        startInfo.ArgumentList.Add("--headless");
                        startInfo.ArgumentList.Add($"--user-agent=\"{Http.UserAgent}\"");
                    }

                    startInfo.ArgumentList.Add(targetUrl);

                    process = Process.Start(startInfo);
                    if (process == null)
                        return;
                }
            }
            catch { Dispose(); }
        }


        private Task Request(object sender, SessionEventArgs e)
        {
            try
            {
                var session = e.HttpClient.Request;

                if (IsCompleted)
                {
                    e.Ok(string.Empty);
                    return Task.CompletedTask;
                }

                if (session.Method == "GET" && !string.IsNullOrEmpty(patternUrl) && Regex.IsMatch(session.Url, patternUrl))
                {
                    IsCompleted = true;
                    completionSource.TrySetResult(session);
                    e.Ok(string.Empty);
                    return Task.CompletedTask;
                }

                if (!string.IsNullOrEmpty(headerKey))
                {
                    foreach (var header in session.Headers)
                    {
                        if (header.Name == headerKey)
                        {
                            IsCompleted = true;
                            completionSource.TrySetResult(session);
                            e.Ok(string.Empty);
                            return Task.CompletedTask;
                        }
                    }
                }

                if (AppInit.conf.chromium.consoleLog)
                {
                    Console.WriteLine("=== HTTP –ó–ê–ü–†–û–° ===");
                    Console.WriteLine($"URL: {session.Url}");
                    Console.WriteLine($"–ú–µ—Ç–æ–¥: {session.Method}");
                    Console.WriteLine("–ó–∞–≥–æ–ª–æ–≤–∫–∏:");
                    foreach (var header in session.Headers)
                        Console.WriteLine($"  {header.Name}: {header.Value}");
                    Console.WriteLine();
                }
            }
            catch { }

            OnRequest?.Invoke(e);
            return Task.CompletedTask;
        }

        private Task Response(object sender, SessionEventArgs e)
        {
            try
            {
                if (AppInit.conf.chromium.consoleLog)
                {
                    var session = e.HttpClient.Response;
                    Console.WriteLine("=== HTTP –û–¢–í–ï–¢ ===");
                    Console.WriteLine($"URL: {e.HttpClient.Request.Url}");
                    Console.WriteLine($"–°—Ç–∞—Ç—É—Å: {session.StatusCode} {session.StatusDescription}");
                    Console.WriteLine("–ó–∞–≥–æ–ª–æ–≤–∫–∏:");
                    foreach (var header in session.Headers)
                        Console.WriteLine($"  {header.Name}: {header.Value}");
                    Console.WriteLine();
                }

                OnResponse?.Invoke(e);
            }
            catch { }

            return Task.CompletedTask;
        }


        #region WaitPageResult
        TaskCompletionSource<Request> completionSource { get; set; } = new TaskCompletionSource<Request>();

        async public Task<Request> WaitPageResult(int seconds = 10)
        {
            try
            {
                if (proxyServer == null)
                    return null;

                var completionTask = completionSource.Task;
                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(seconds));

                var completedTask = await Task.WhenAny(completionTask, timeoutTask).ConfigureAwait(false);

                if (completedTask == completionTask)
                    return await completionTask;

                return null;
            }
            catch { return null; }
        }
        #endregion

        #region Dispose
        public void Dispose()
        {
            if (AppInit.conf.chromium.DEV)
                return;

            try
            {
                if (proxyServer != null)
                {
                    proxyServer.BeforeRequest -= Request;
                    proxyServer.BeforeResponse -= Response;
                    proxyServer.ServerCertificateValidationCallback -= OnCertificateValidation;

                    Task.Run(() =>
                    {
                        try
                        {
                            proxyServer.Stop();
                            proxyServer.Dispose();
                        }
                        catch { }
                        finally
                        {
                            proxyServer = null;
                        }
                    });
                }
            }
            catch { }

            try
            {
                if (process != null)
                {
                    Task.Run(() =>
                    {
                        try
                        {
                            process.Kill(true);
                            process.Close();
                            process.Dispose();
                        }
                        catch { }
                        finally
                        {
                            process = null;
                        }
                    });
                }
            }
            catch { }

            completionSource = null;
        }
        #endregion



        private Task OnCertificateValidation(object sender, CertificateValidationEventArgs e)
        {
            e.IsValid = true;
            return Task.CompletedTask;
        }
    }
}

```

## File: Shared/PlaywrightCore/PlaywrightBrowser.cs
```
Ôªøusing Microsoft.Playwright;
using Shared.Models;
using Shared.Models.Base;

namespace Shared.PlaywrightCore
{
    public class PlaywrightBrowser : IDisposable
    {
        public static PlaywrightStatus Status
        {
            get
            {
                if (Chromium.Status == PlaywrightStatus.NoHeadless || Firefox.Status != PlaywrightStatus.disabled)
                    return PlaywrightStatus.NoHeadless;

                if (Chromium.Status == PlaywrightStatus.headless)
                    return PlaywrightStatus.headless;

                return PlaywrightStatus.disabled;
            }
        }

        public bool IsCompleted
        {
            get
            {
                if (chromium != null)
                    return chromium.IsCompleted;

                return firefox.IsCompleted;
            }
        }

        public TaskCompletionSource<string> completionSource
        {
            get
            {
                if (chromium != null)
                    return chromium.completionSource;

                return firefox.completionSource;
            }
        }


        public Chromium chromium = null;

        public Firefox firefox = null;


        public PlaywrightBrowser(string priorityBrowser = null)
        {
            if (priorityBrowser == "firefox" && Firefox.Status != PlaywrightStatus.disabled)
            {
                firefox = new Firefox();
                return;
            }

            chromium = new Chromium();
        }

        public void SetFailedUrl(string url)
        {
            if (chromium != null)
            {
                chromium.failedUrl = url;
            }
            else
            {
                firefox.failedUrl = url;
            }
        }

        async public Task<IPage> NewPageAsync(string plugin, Dictionary<string, string> headers = null, (string ip, string username, string password) proxy = default, bool keepopen = true, bool imitationHuman = false, bool deferredDispose = false)
        {
            try
            {
                if (chromium == null && firefox == null)
                    return default;

                IPage page = default;

                if (chromium != null)
                    page = await chromium.NewPageAsync(plugin, headers, proxy, keepopen: keepopen, imitationHuman: imitationHuman, deferredDispose: deferredDispose).ConfigureAwait(false);
                else
                    page = await firefox.NewPageAsync(plugin, headers, proxy, keepopen: keepopen).ConfigureAwait(false);

                return page;
            }
            catch { return default; }
        }


        public void SetPageResult(in string val)
        {
            try
            {
                if (chromium != null)
                {
                    chromium.IsCompleted = true;
                    chromium.completionSource.SetResult(val);
                }
                else
                {
                    firefox.IsCompleted = true;
                    firefox.completionSource.SetResult(val);
                }
            }
            catch { }
        }

        public Task<string> WaitPageResult(int seconds = 10)
        {
            try
            {
                if (chromium != null)
                    return chromium.WaitPageResult(seconds);

                return firefox.WaitPageResult(seconds);
            }
            catch { return default; }
        }


        public Task WaitForAnySelectorAsync(IPage page, params string[] selectors)
        {
            var tasks = selectors.Select(selector =>
                page.WaitForSelectorAsync(selector)
            ).ToArray();

            return Task.WhenAny(tasks);
        }


        async public Task ClearContinueAsync(IRoute route, IPage page)
        {
            var cookies = await page.Context.CookiesAsync();
            if (cookies == null || cookies.Count == 0)
            {
                // –Ω–µ—Ç—É –∫—É–∫–∏, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
                await route.ContinueAsync();
                return;
            }

            var filteredCookies = cookies.Where(c => c.Name != "cf_clearance").Select(c => new Cookie
            {
                Name = c.Name,
                Value = c.Value,
                Domain = c.Domain,
                Path = c.Path,
                Expires = c.Expires,
                HttpOnly = c.HttpOnly,
                Secure = c.Secure,
                SameSite = c.SameSite
            }).ToList();

            if (filteredCookies.Count == cookies.Count)
            {
                // –ï—Å–ª–∏ –∫—É–∫–∏ –Ω–µ —Å–æ–¥–µ—Ä–∂–∞—Ç cf_clearance, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
                await route.ContinueAsync();
                return;
            }

            if (filteredCookies.Count == 0)
            {
                // –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è cf_clearance –Ω–µ –æ—Å—Ç–∞–ª–æ—Å—å –¥—Ä—É–≥–∏—Ö –∫—É–∫–∏
                await page.Context.ClearCookiesAsync();
                await route.ContinueAsync();
                return;
            }

            await page.Context.ClearCookiesAsync();
            await page.Context.AddCookiesAsync(filteredCookies);

            await route.ContinueAsync();
        }


        public void Dispose()
        {
            chromium?.Dispose();
            firefox?.Dispose();
        }




        async public static ValueTask<string> Get(BaseSettings init, string url, List<HeadersModel> headers = null, (string ip, string username, string password) proxy = default, List<Cookie> cookies = null)
        {
            try
            {
                using (var browser = new PlaywrightBrowser(init?.priorityBrowser))
                {
                    var page = await browser.NewPageAsync(init?.plugin, headers?.ToDictionary(), proxy).ConfigureAwait(false);
                    if (page == null)
                        return null;

                    if (cookies != null)
                        await page.Context.AddCookiesAsync(cookies).ConfigureAwait(false);

                    IResponse response = default;

                    if (browser.firefox != null)
                    {
                        response = await page.GotoAsync(url, new PageGotoOptions() { WaitUntil = WaitUntilState.DOMContentLoaded }).ConfigureAwait(false);
                    }
                    else
                    {
                        response = await page.GotoAsync($"view-source:{url}", new PageGotoOptions()
                        {
                            Timeout = 10_000,
                            WaitUntil = WaitUntilState.DOMContentLoaded
                        }).ConfigureAwait(false);
                    }

                    if (response != null)
                    {
                        string result = await response.TextAsync().ConfigureAwait(false);
                        PlaywrightBase.WebLog(response.Request, response, result, proxy);

                        return result;
                    }
                }
            }
            catch { }

            return null;
        }
    }
}

```

## File: Shared/PlaywrightCore/Chromium.cs
```
Ôªøusing Microsoft.Playwright;
using Shared.Engine;
using Shared.Models.Browser;
using System.Runtime.InteropServices;
using System.Threading;

namespace Shared.PlaywrightCore
{
    public class Chromium : PlaywrightBase, IDisposable
    {
        #region static
        public static BrowserNewContextOptions baseContextOptions = new BrowserNewContextOptions
        {
            UserAgent = Http.UserAgent,
            ExtraHTTPHeaders = new Dictionary<string, string>(Http.defaultHeaders)
            {
                ["accept-language"] = "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"
            }
        };

        static List<KeepopenPage> pages_keepopen = new();

        static IBrowserContext keepopen_context { get; set; }

        static DateTime create_keepopen_context { get; set; }

        public static long stats_keepopen { get; set; }

        public static long stats_newcontext { get; set; }

        public static (DateTime time, int status, string ex) stats_ping { get; set; }


        public static IPlaywright playwright { get; private set; } = null;

        static IBrowser browser = null;

        static bool shutdown = false;

        public static PlaywrightStatus Status { get; private set; } = PlaywrightStatus.disabled;

        public static int ContextsCount => browser?.Contexts?.Count ?? 0;

        async public static Task CreateAsync()
        {
            try
            {
                var init = AppInit.conf.chromium;
                if (!init.enable || browser != null || shutdown)
                    return;

                string executablePath = init.executablePath;

                #region Download chromium
                if (string.IsNullOrEmpty(executablePath))
                {
                    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                    {
                        switch (RuntimeInformation.ProcessArchitecture)
                        {
                            case Architecture.X86:
                            case Architecture.X64:
                            case Architecture.Arm64:
                                {
                                    string uri = $"https://github.com/immisterio/playwright/releases/download/chrome/chrome-win-{RuntimeInformation.ProcessArchitecture.ToString().ToLower()}.zip";
                                    bool res = await DownloadFile(uri, ".playwright/chrome.zip");
                                    if (!res)
                                    {
                                        Console.WriteLine("Chromium: error download chrome.zip");
                                        return;
                                    }

                                    if (RuntimeInformation.ProcessArchitecture == Architecture.Arm64)
                                        executablePath = ".playwright\\chrome-win32\\chrome.exe";
                                    else
                                        executablePath = ".playwright\\chrome-win\\chrome.exe";
                                    break;
                                }
                            default:
                                Console.WriteLine("Chromium: Architecture unknown");
                                return;
                        }
                    }
                    else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
                    {
                        switch (RuntimeInformation.ProcessArchitecture)
                        {
                            case Architecture.X64:
                            case Architecture.Arm64:
                                {
                                    string uri = $"https://github.com/immisterio/playwright/releases/download/chrome/chrome-mac-{RuntimeInformation.ProcessArchitecture.ToString().ToLower()}.zip";
                                    bool res = await DownloadFile(uri, ".playwright/chrome.zip");
                                    if (!res)
                                    {
                                        Console.WriteLine("Chromium: error download chrome.zip");
                                        return;
                                    }

                                    Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), ".playwright/chrome-mac/Chromium.app/Contents/MacOS/Chromium")}");
                                    executablePath = ".playwright/chrome-mac/Chromium.app/Contents/MacOS/Chromium";
                                    await Task.Delay(TimeSpan.FromSeconds(4));
                                    break;
                                }
                            default:
                                Console.WriteLine("Chromium: Architecture unknown");
                                return;
                        }
                    }
                    else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                    {
                        switch (RuntimeInformation.ProcessArchitecture)
                        {
                            case Architecture.X86:
                            case Architecture.X64:
                                {
                                    string uri = $"https://github.com/immisterio/playwright/releases/download/chrome/chrome-linux-{RuntimeInformation.ProcessArchitecture.ToString().ToLower()}.zip";
                                    bool res = await DownloadFile(uri, ".playwright/chrome.zip");
                                    if (!res)
                                    {
                                        Console.WriteLine("Chromium: error download chrome.zip");
                                        return;
                                    }

                                    Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), ".playwright/chrome-linux/chrome")}");
                                    executablePath = ".playwright/chrome-linux/chrome";
                                    await Task.Delay(TimeSpan.FromSeconds(4));
                                    break;
                                }
                            default:
                                Console.WriteLine("PlaywChromiumright: Architecture unknown");
                                return;
                        }
                    }
                    else
                    {
                        Console.WriteLine("Chromium: IsOSPlatform unknown");
                        return;
                    }
                }
                #endregion

                if (string.IsNullOrEmpty(executablePath))
                {
                    Console.WriteLine("Chromium: chromium is not installed, please specify full path in executablePath");
                    return;
                }

                Console.WriteLine("Chromium: Initialization");

                playwright = await Playwright.CreateAsync();

                Console.WriteLine("Chromium: CreateAsync");

                browser = await playwright.Chromium.LaunchAsync(new BrowserTypeLaunchOptions
                {
                    Headless = init.Headless,
                    ExecutablePath = executablePath,
                    Args = init.Args,
                    Devtools = init.Devtools
                });

                Console.WriteLine("Chromium: LaunchAsync");

                Status = init.Headless ? PlaywrightStatus.headless : PlaywrightStatus.NoHeadless;
                Console.WriteLine($"Chromium: v{browser.Version} / {Status.ToString()} / {browser.IsConnected}");

                if (AppInit.conf.chromium.context.keepopen)
                {
                    create_keepopen_context = DateTime.Now;
                    var kpc = await browser.NewContextAsync(baseContextOptions);
                    await kpc.NewPageAsync();
                    keepopen_context = kpc;
                }
            }
            catch (Exception ex) 
            {
                Status = PlaywrightStatus.disabled;
                Console.WriteLine($"Chromium: {ex.Message}"); 
            }
        }
        #endregion

        #region CronStart
        public static void CronStart()
        {
            _closeLifetimeTimer = new Timer(CronCloseLifetimeContext, null, TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1));
            _browserDisconnectedTimer = new Timer(CronBrowserDisconnected, null, TimeSpan.FromMinutes(2), TimeSpan.FromMinutes(1));
        }

        static Timer _closeLifetimeTimer, _browserDisconnectedTimer;

        static bool _cronCloseLifetimeWork = false, _cronBrowserDisconnectedWork = false;
        #endregion

        #region CronCloseLifetimeContext
        async static void CronCloseLifetimeContext(object state)
        {
            if (!AppInit.conf.chromium.enable || Status == PlaywrightStatus.disabled)
                return;

            if (_cronCloseLifetimeWork)
                return;

            _cronCloseLifetimeWork = true;

            try
            {
                var init = AppInit.conf.chromium;
                if (!init.context.keepopen || 0 >= init.context.keepalive)
                    return;

                if (DateTime.Now.AddMinutes(-init.context.keepalive) > create_keepopen_context)
                {
                    create_keepopen_context = DateTime.Now;
                    var kpc = await browser.NewContextAsync(baseContextOptions);
                    await kpc.NewPageAsync();

                    try
                    {
                        _ = keepopen_context.CloseAsync().ConfigureAwait(false);
                    }
                    catch { }

                    keepopen_context = kpc;
                }

                if (pages_keepopen.Count > 0 && pages_keepopen.Count > init.context.min)
                {
                    foreach (var k in pages_keepopen.ToArray())
                    {
                        if (init.context.min >= pages_keepopen.Count)
                            break;

                        if (DateTime.Now.AddMinutes(-init.context.keepalive) > k.create)
                        {
                            try
                            {
                                if (pages_keepopen.Remove(k))
                                {
                                    await Task.Delay(TimeSpan.FromSeconds(20));
                                    await k.context.CloseAsync();
                                }
                            }
                            catch { }
                        }
                    }
                }
            }
            catch { }
            finally
            {
                _cronCloseLifetimeWork = false;
            }
        }
        #endregion

        #region CronBrowserDisconnected
        async static void CronBrowserDisconnected(object state)
        {
            if (!AppInit.conf.chromium.enable)
                return;

            if (_cronBrowserDisconnectedWork)
                return;

            _cronBrowserDisconnectedWork = true;

            try
            {
                stats_ping = (DateTime.Now, 1, null);
                if (shutdown)
                    return;

                stats_ping = (DateTime.Now, 2, null);

                if ((AppInit.conf.multiaccess || AppInit.conf.chromium.Headless) && Status != PlaywrightStatus.disabled)
                {
                    try
                    {
                        stats_ping = (DateTime.Now, 3, null);
                        if (AppInit.conf.multiaccess == false && keepopen_context == null)
                            return;

                        stats_ping = (DateTime.Now, 4, null);
                        if (browser == null && keepopen_context == null)
                            return;

                        bool isOk = false;

                        try
                        {
                            stats_ping = (DateTime.Now, 5, null);
                            IPage p = keepopen_context != null ? await keepopen_context.NewPageAsync() : await browser.NewPageAsync();
                            if (p != null)
                            {
                                try
                                {
                                    var options = new PageGotoOptions
                                    {
                                        Timeout = 5000, // 5 —Å–µ–∫—É–Ω–¥
                                        WaitUntil = WaitUntilState.DOMContentLoaded
                                    };

                                    var r = await p.GotoAsync($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/api/chromium/ping", options);
                                    if (r != null)
                                    {
                                        stats_ping = (DateTime.Now, r.Status, null);
                                        if (r.Status == 200)
                                            isOk = true;
                                    }
                                }
                                finally
                                {
                                    await p.CloseAsync();
                                }
                            }
                        }
                        catch
                        {
                            stats_ping = (DateTime.Now, 500, null);
                        }

                        if (!isOk)
                        {
                            Console.WriteLine("\nChromium: Browser_Disconnected");

                            Status = PlaywrightStatus.disabled;

                            keepopen_context = null;

                            if (pages_keepopen != null)
                                pages_keepopen.Clear();

                            try
                            {
                                if (browser != null)
                                {
                                    await browser.CloseAsync();
                                    await browser.DisposeAsync();
                                }
                            }
                            catch { }

                            try
                            {
                                playwright.Dispose();
                            }
                            catch { }

                            browser = null;
                            playwright = null;

                            await CreateAsync();
                        }
                    }
                    catch (Exception ex)
                    {
                        stats_ping = (DateTime.Now, -1, ex.Message);
                        Console.WriteLine(ex.Message);
                    }
                }
            }
            catch { }
            finally
            {
                _cronBrowserDisconnectedWork = false;
            }
        }
        #endregion


        public bool IsCompleted { get; set; }

        bool imitationHuman { get; set; }

        bool deferredDispose { get; set; }

        public string failedUrl { get; set; }

        IPage page { get; set; }

        IBrowserContext context { get; set; }

        KeepopenPage keepopen_page { get; set; }


        async public Task<IPage> NewPageAsync(string plugin, Dictionary<string, string> headers = null, (string ip, string username, string password) proxy = default, bool keepopen = true, bool imitationHuman = false, bool deferredDispose = false)
        {
            try
            {
                if (browser == null)
                    return null;

                this.imitationHuman = imitationHuman;
                this.deferredDispose = deferredDispose;

                if (proxy != default)
                {
                    #region NewPageAsync
                    if (keepopen)
                    {
                        foreach (var pg in pages_keepopen.ToArray())
                        {
                            if (pg.plugin == plugin)
                            {
                                if (pg.proxy.ip != proxy.ip || pg.proxy.username != proxy.username || pg.proxy.password != proxy.password)
                                {
                                    _ = pg.context.CloseAsync().ConfigureAwait(false);
                                    pages_keepopen.Remove(pg);
                                    continue;
                                }
                            }

                            if (pg.proxy.ip == proxy.ip && pg.proxy.username == proxy.username && pg.proxy.password == proxy.password)
                            {
                                stats_keepopen++;
                                keepopen_page = pg;
                                await ClearCookie(pg.context).ConfigureAwait(false);
                                page = await pg.context.NewPageAsync().ConfigureAwait(false);
                                break;
                            }
                        }
                    }

                    if (page == default)
                    {
                        var contextOptions = new BrowserNewContextOptions
                        {
                            Proxy = new Proxy
                            {
                                Server = proxy.ip,
                                Bypass = "127.0.0.1",
                                Username = proxy.username,
                                Password = proxy.password
                            },
                            UserAgent = baseContextOptions.UserAgent,
                            ExtraHTTPHeaders = baseContextOptions.ExtraHTTPHeaders
                        };

                        stats_newcontext++;
                        context = await browser.NewContextAsync(contextOptions).ConfigureAwait(false);
                        page = await context.NewPageAsync().ConfigureAwait(false);
                    }
                    #endregion

                    if (headers != null && headers.Count > 0)
                        await page.SetExtraHTTPHeadersAsync(headers).ConfigureAwait(false);

                    page.Popup += Page_Popup;
                    page.Download += Page_Download;
                    page.RequestFailed += Page_RequestFailed;

                    if (AppInit.conf.chromium.Devtools)
                        await Task.Delay(TimeSpan.FromSeconds(2)).ConfigureAwait(false); // —á—Ç–æ –±—ã devtools —É—Å–ø–µ–ª –æ—Ç–∫—Ä—ã—Ç—å—Å—è

                    if (!keepopen || keepopen_page != null || !AppInit.conf.chromium.context.keepopen || pages_keepopen.Count >= AppInit.conf.chromium.context.max)
                        return page;

                    await context.NewPageAsync().ConfigureAwait(false); // —á—Ç–æ-–±—ã context –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–ª—Å—è —Å –ø–æ—Å–ª–µ–¥–Ω–µ–π –∑–∞–∫—Ä—ã—Ç–æ–π –≤–∫–ª–∞–¥–∫–æ–π
                    if (pages_keepopen.Count >= AppInit.conf.chromium.context.max)
                        return page;

                    // –æ–¥–∏–Ω –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤ —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —ç—Ç–æ—Ç –ø—Ä–æ–∫—Å–∏
                    if (proxy != default && pages_keepopen.FirstOrDefault(i => i.proxy.ip == proxy.ip && i.proxy.username == proxy.username && i.proxy.password == proxy.password)?.proxy != default)
                        return page;

                    keepopen_page = new KeepopenPage() { context = context, plugin = plugin, proxy = proxy };
                    pages_keepopen.Add(keepopen_page);
                    return page;
                }
                else
                {
                    #region NewPageAsync
                    if (keepopen && keepopen_context != default)
                    {
                        stats_keepopen++;
                        await ClearCookie(keepopen_context).ConfigureAwait(false);
                        page = await keepopen_context.NewPageAsync().ConfigureAwait(false);
                    }
                    else
                    {
                        stats_newcontext++;
                        page = await browser.NewPageAsync().ConfigureAwait(false);
                    }
                    #endregion

                    if (headers != null && headers.Count > 0)
                        await page.SetExtraHTTPHeadersAsync(headers).ConfigureAwait(false);

                    page.Popup += Page_Popup;
                    page.Download += Page_Download;
                    page.RequestFailed += Page_RequestFailed;

                    if (AppInit.conf.chromium.Devtools)
                        await Task.Delay(TimeSpan.FromSeconds(2)).ConfigureAwait(false); // —á—Ç–æ –±—ã devtools —É—Å–ø–µ–ª –æ—Ç–∫—Ä—ã—Ç—å—Å—è

                    return page;
                }
            }
            catch { return null; }
        }


        static bool workClearCookie = false;

        async Task ClearCookie(IBrowserContext context)
        {
            if (workClearCookie)
                return;

            try
            {
                workClearCookie = true;
                var cookies = await context.CookiesAsync();

                foreach (var cookie in cookies.Where(c => c.Name == "cf_clearance"))
                {
                    await context.ClearCookiesAsync(new BrowserContextClearCookiesOptions
                    {
                        Name = cookie.Name,
                        Domain = cookie.Domain,
                        Path = cookie.Path
                    });
                }
            }
            catch { }

            workClearCookie = false;
        }


        void Page_RequestFailed(object sender, IRequest e)
        {
            try
            {
                if (failedUrl != null && e.Url == failedUrl)
                {
                    completionSource.SetResult(null);
                    WebLog(e.Method, e.Url, "RequestFailed", default, e);
                }
            }
            catch { }
        }

        void Page_Download(object sender, IDownload e)
        {
            try
            {
                e.CancelAsync().ConfigureAwait(false);
            }
            catch { }
        }

        void Page_Popup(object sender, IPage e)
        {
            try
            {
                e.CloseAsync().ConfigureAwait(false);
            }
            catch { }
        }


        public void Dispose()
        {
            if (browser == null || AppInit.conf.chromium.DEV)
                return;

            try
            {
                page.RequestFailed -= Page_RequestFailed;
                page.Popup -= Page_Popup;
                page.Download -= Page_Download;

                void close()
                {
                    if (keepopen_page != null)
                    {
                        page.CloseAsync().ConfigureAwait(false);
                    }
                    else if (context != null)
                    {
                        context.CloseAsync().ConfigureAwait(false);
                    }
                    else
                    {
                        page.CloseAsync().ConfigureAwait(false);
                    }
                }

                if (imitationHuman || deferredDispose)
                {
                    Task.Delay(deferredDispose ? 2_000 : 10_000)
                        .ContinueWith(t => close());
                }
                else
                {
                    close();
                }
            }
            catch { }
        }

        public static void FullDispose()
        {
            shutdown = true;
            if (browser == null)
                return;

            try
            {
                browser.CloseAsync().ContinueWith(t => browser.DisposeAsync());
            }
            catch { }
        }
    }
}

```

## File: Shared/PlaywrightCore/PlaywrightBase.cs
```
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.Playwright;
using Shared.Engine;
using Shared.Models;
using Shared.Models.SQL;
using System.IO.Compression;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.PlaywrightCore
{
    public enum PlaywrightStatus
    {
        disabled,
        headless,
        NoHeadless
    }

    public class PlaywrightBase
    {
        static DateTime _nextClearDb = default;

        public TaskCompletionSource<string> completionSource { get; private set; } = new TaskCompletionSource<string>();

        #region WaitPageResult
        async public Task<string> WaitPageResult(int seconds = 10)
        {
            try
            {
                var completionTask = completionSource.Task;
                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(seconds));

                var completedTask = await Task.WhenAny(completionTask, timeoutTask).ConfigureAwait(false);

                if (completedTask == completionTask)
                    return await completionTask;

                return null;
            }
            catch { return null; }
        }
        #endregion


        #region InitializationAsync
        async public static Task<bool> InitializationAsync()
        {
            try
            {
                if (!AppInit.conf.chromium.enable && !AppInit.conf.firefox.enable)
                    return false;

                if (!File.Exists(".playwright/package/index.js"))
                {
                    bool res = await DownloadFile("https://github.com/immisterio/playwright/releases/download/chrome/package.zip", ".playwright/package.zip");
                    if (!res)
                    {
                        Console.WriteLine("Playwright: error download package.zip");
                        return false;
                    }
                }

                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                {
                    switch (RuntimeInformation.ProcessArchitecture)
                    {
                        case Architecture.X86:
                        case Architecture.X64:
                        case Architecture.Arm64:
                            {
                                string arc = RuntimeInformation.ProcessArchitecture.ToString().ToLower();
                                bool res = await DownloadFile($"https://github.com/immisterio/playwright/releases/download/chrome/node-win-{arc}.exe", $".playwright\\node\\win32_{arc}\\node.exe");
                                if (!res)
                                {
                                    Console.WriteLine($"Playwright: error download node-win-{arc}.exe");
                                    return false;
                                }
                                break;
                            }
                        default:
                            Console.WriteLine("Playwright: Architecture unknown");
                            return false;
                    }
                }
                else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
                {
                    switch (RuntimeInformation.ProcessArchitecture)
                    {
                        case Architecture.X64:
                        case Architecture.Arm64:
                            {
                                string arc = RuntimeInformation.ProcessArchitecture.ToString().ToLower();
                                bool res = await DownloadFile($"https://github.com/immisterio/playwright/releases/download/chrome/node-mac-{arc}", $".playwright/node/mac-{arc}/node");
                                if (!res)
                                {
                                    Console.WriteLine($"Playwright: error download node-mac-{arc}");
                                    return false;
                                }

                                Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), $".playwright/node/mac-{arc}/node")}");
                                await Task.Delay(TimeSpan.FromSeconds(4));
                                break;
                            }
                        default:
                            Console.WriteLine("Playwright: Architecture unknown");
                            return false;
                    }
                }
                else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                {
                    switch (RuntimeInformation.ProcessArchitecture)
                    {
                        case Architecture.X86:
                        case Architecture.X64:
                        case Architecture.Arm64:
                            {
                                string arc = RuntimeInformation.ProcessArchitecture.ToString().ToLower();
                                bool res = await DownloadFile($"https://github.com/immisterio/playwright/releases/download/chrome/node-linux-{arc}", $".playwright/node/linux-{arc}/node");
                                if (!res)
                                {
                                    Console.WriteLine($"Playwright: error download node-linux-{arc}");
                                    return false;
                                }

                                Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), $".playwright/node/linux-{arc}/node")}");
                                await Task.Delay(TimeSpan.FromSeconds(4));
                                break;
                            }
                        case Architecture.Arm:
                            {
                                bool res = await DownloadFile("https://github.com/immisterio/playwright/releases/download/chrome/node-linux-armv7l", ".playwright/node/linux-arm/node");
                                if (!res)
                                {
                                    Console.WriteLine("Playwright: error download node-linux-armv7l");
                                    return false;
                                }

                                Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), ".playwright/node/linux-arm/node")}");
                                await Task.Delay(TimeSpan.FromSeconds(4));
                                break;
                            }
                        default:
                            Console.WriteLine("Playwright: Architecture unknown");
                            return false;
                    }
                }
                else
                {
                    Console.WriteLine("Playwright: IsOSPlatform unknown");
                    return false;
                }

                if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux) && (AppInit.conf.chromium.Headless == false || AppInit.conf.firefox.Headless == false))
                {
                    if (!File.Exists("/usr/bin/Xvfb"))
                    {
                        Console.WriteLine("Playwright: install xvfb");
                        await Bash.Run("apt update && apt install -y xvfb");
                    }

                    _ = Bash.Run("Xvfb :99 -screen 0 1280x1024x24").ConfigureAwait(false);
                    Environment.SetEnvironmentVariable("DISPLAY", ":99");
                    await Task.Delay(TimeSpan.FromSeconds(5));
                    Console.WriteLine("Playwright: Xvfb 99");
                }

                Console.WriteLine("Playwright: Initialization");
                return true;
            }
            catch (Exception ex) 
            {
                Console.WriteLine($"Playwright: {ex.Message}");
                return false;
            }
        }
        #endregion

        #region DownloadFile
        async public static Task<bool> DownloadFile(string uri, string outfile, string folder = null)
        {
            if (File.Exists($"{outfile}.ok"))
                return true;

            if (File.Exists(outfile))
                File.Delete(outfile);

            Directory.CreateDirectory(Path.GetDirectoryName(outfile));

            Console.WriteLine($"Playwright: Download {outfile}");

            if (await Http.DownloadFile(uri, outfile))
            {
                File.Create($"{outfile}.ok");

                if (outfile.EndsWith(".zip"))
                {
                    Console.WriteLine($"Playwright: unzip {outfile}");

                    if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                    {
                        await Bash.Run($"unzip {Path.Combine(Environment.CurrentDirectory, outfile)} -d {Path.Combine(Environment.CurrentDirectory, ".playwright", folder ?? string.Empty)}");
                    }
                    else
                    {
                        ZipFile.ExtractToDirectory(outfile, ".playwright/" + folder, overwriteFiles: true);
                    }

                    File.Delete(outfile);
                }

                return true;
            }
            else
            {
                File.Delete(outfile);
                return false;
            }
        }
        #endregion

        #region WebLog
        public static void WebLog(IRequest request, IResponse response, in string result, (string ip, string username, string password) proxy = default)
        {
            try
            {
                if (request.Url.Contains("127.0.0.1") || !AppInit.conf.weblog.enable)
                    return;

                var log = new StringBuilder();

                log.Append($"{DateTime.Now}\n");

                if (proxy != default)
                    log.Append($"proxy: {proxy}\n");

                log.Append($"{request.Method}: {request.Url}\n");

                foreach (var item in request.Headers)
                    log.Append($"{item.Key}: {item.Value}\n");

                if (response == null)
                {
                    log.Append("\nresponse null");
                    Http.onlog?.Invoke(null, log.ToString());
                    return;
                }

                log.Append($"\n\nCurrentUrl: {response.Url}\nStatusCode: {response.Status}\n");
                foreach (var item in response.Headers)
                    log.Append($"{item.Key}: {item.Value}\n");

                Http.onlog?.Invoke(null, $"{log.ToString()}\n{result}");
            }
            catch { }
        }

        public static void WebLog(string method, string url, in string result, (string ip, string username, string password) proxy = default, IRequest request = default, IResponse response = default)
        {
            try
            {
                if (url.Contains("127.0.0.1") || !AppInit.conf.weblog.enable)
                    return;

                var log = new StringBuilder();

                log.Append($"{DateTime.Now}\n");

                if (proxy != default)
                    log.Append($"proxy: {proxy}\n");

                log.Append($"{method}: {url}\n");

                if (request?.Headers != null)
                {
                    foreach (var item in request.Headers)
                        log.Append($"{item.Key}: {item.Value}\n");
                }

                if (response?.Headers != null)
                {
                    log.Append($"\n\nCurrentUrl: {response.Url}\nStatusCode: {response.Status}\n");
                    foreach (var item in response.Headers)
                        log.Append($"{item.Key}: {item.Value}\n");
                }

                Http.onlog?.Invoke(null, $"{log.ToString()}\n{result}");
            }
            catch { }
        }
        #endregion

        #region IframeUrl
        public static string IframeUrl(string link) => $"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/api/chromium/iframe?src={HttpUtility.UrlEncode(link)}";

        public static string IframeHtml(string link) => $@"<html lang=""ru"">
                <head>
                    <meta charset=""UTF-8"">
                    <meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
                    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"">
                </head>
                <body>
                    <iframe width=""560"" height=""400"" src=""{link}"" frameborder=""0"" allow=""*"" allowfullscreen></iframe>
                </body>
            </html>";
        #endregion

        #region AbortOrCache
        async public static ValueTask<bool> AbortOrCache(IPage page, IRoute route, bool abortMedia = false, bool fullCacheJS = false, string patterCache = null)
        {
            try
            {
                if (Regex.IsMatch(route.Request.Url, "(image.tmdb.org|yandex\\.|google-analytics|yahoo\\.|fonts.googleapis|googletagmanager|opensubtitles\\.|/favicon\\.ico$)"))
                {
                    await route.AbortAsync();
                    return true;
                }

                if (abortMedia && Regex.IsMatch(route.Request.Url.Split("?")[0], "\\.(woff2?|vtt|srt|css|svg|jpe?g|png|gif|webp|ico|ts|m4s)$"))
                {
                    if (AppInit.conf.chromium.consoleLog || AppInit.conf.firefox.consoleLog)
                        Console.WriteLine($"Playwright: Abort {route.Request.Url}");

                    await route.AbortAsync();
                    return true;
                }

                if (route.Request.Method == "GET")
                {
                    bool valid = false;
                    string memkey = route.Request.Url;

                    if ((fullCacheJS && route.Request.Url.Contains(".js")) || Regex.IsMatch(route.Request.Url, "(\\.googleapis\\.com/css|gstatic\\.com|plrjs\\.com)", RegexOptions.IgnoreCase))
                    {
                        valid = true;
                        memkey = route.Request.Url.Split("?")[0];
                    }
                    else if (Regex.IsMatch(route.Request.Url, "\\.(js|wasm)$") || Regex.IsMatch(route.Request.Url, "\\.(css|woff2?|svg|jpe?g|png|gif)"))
                    {
                        valid = true;
                        memkey = route.Request.Url;
                    }
                    else if (patterCache != null && Regex.IsMatch(route.Request.Url, patterCache))
                    {
                        valid = true;
                        memkey = route.Request.Url;
                    }

                    if (valid)
                    {
                        #region ClearDb
                        try
                        {
                            if (DateTime.Now > _nextClearDb)
                            {
                                _nextClearDb = DateTime.Now.AddMinutes(5);

                                var now = DateTime.Now;

                                using (var sqlDb = new PlaywrightContext())
                                {
                                    await sqlDb.files
                                        .Where(i => now > i.ex)
                                        .ExecuteDeleteAsync();
                                }
                            }
                        }
                        catch { }
                        #endregion

                        PlaywrightSqlModel doc = null;

                        using (var sqlDb = new PlaywrightContext())
                            doc = sqlDb.files.Find(memkey);

                        if (doc?.content != null)
                        {
                            if (AppInit.conf.chromium.consoleLog || AppInit.conf.firefox.consoleLog)
                                Console.WriteLine($"Playwright: CACHE {route.Request.Url}");

                            await route.FulfillAsync(new RouteFulfillOptions
                            {
                                BodyBytes = doc.content,
                                Headers = JsonSerializer.Deserialize<Dictionary<string, string>>(doc.headers)
                            });
                        }
                        else
                        {
                            if (AppInit.conf.chromium.consoleLog || AppInit.conf.firefox.consoleLog)
                                Console.WriteLine($"Playwright: MISS {route.Request.Url}");

                            await route.ContinueAsync();

                            try
                            {
                                var response = await page.WaitForResponseAsync(route.Request.Url);
                                if (response != null)
                                {
                                    var content = await response.BodyAsync();
                                    if (content != null)
                                    {
                                        using (var sqlDb = new PlaywrightContext())
                                        {
                                            sqlDb.files.Add(new PlaywrightSqlModel()
                                            {
                                                Id = memkey,
                                                ex = DateTime.Now.AddHours(1),
                                                headers = JsonSerializer.Serialize(response.Headers.ToDictionary()),
                                                content = content
                                            });

                                            await sqlDb.SaveChangesAsync();
                                        }
                                    }
                                }
                            }
                            catch { }
                        }

                        return true;
                    }
                }

                if (AppInit.conf.chromium.consoleLog || AppInit.conf.firefox.consoleLog)
                    Console.WriteLine($"Playwright: {route.Request.Method} {route.Request.Url}");

                return false;
            }
            catch { return false; }
        }
        #endregion

        #region GotoAsync
        public static void GotoAsync(IPage page, string uri)
        {
            var options = new PageGotoOptions
            {
                Timeout = 60_000, // 60 —Å–µ–∫—É–Ω–¥
                WaitUntil = WaitUntilState.DOMContentLoaded
            };

            _ = page.GotoAsync(uri, options).ConfigureAwait(false);
        }
        #endregion

        #region ConsoleLog
        public static void ConsoleLog(in string value, List<HeadersModel> headers = null)
        {
            if (AppInit.conf.chromium.consoleLog || AppInit.conf.firefox.consoleLog)
            {
                if (headers != null)
                {
                    Console.WriteLine($"\n{value}\n{Newtonsoft.Json.JsonConvert.SerializeObject(headers.ToDictionary(), Newtonsoft.Json.Formatting.Indented)}\n");
                }
                else
                {
                    Console.WriteLine(value);
                }
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/AccsDbInvk.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using System.Text;
using System.Web;

namespace Shared.Engine
{
    public static class AccsDbInvk
    {
        public static string Args(string uri, HttpContext httpContext)
        {
            var args = new StringBuilder();

            if (httpContext.Request.Query.ContainsKey("account_email") && !uri.Contains("account_email="))
            {
                string account_email = httpContext.Request.Query["account_email"].ToString()?.ToLower()?.Trim();
                if (!string.IsNullOrEmpty(account_email))
                    args.Append($"&account_email={HttpUtility.UrlEncode(account_email)}");
            }

            if (httpContext.Request.Query.ContainsKey("uid") && !uri.Contains("uid="))
            {
                string uid = httpContext.Request.Query["uid"].ToString()?.ToLower()?.Trim();
                if (!string.IsNullOrEmpty(uid))
                    args.Append($"&uid={HttpUtility.UrlEncode(uid)}");
            }

            if (httpContext.Request.Query.ContainsKey("token") && !uri.Contains("token="))
            {
                string token = httpContext.Request.Query["token"].ToString()?.ToLower()?.Trim();
                if (!string.IsNullOrEmpty(token))
                    args.Append($"&token={HttpUtility.UrlEncode(token)}");
            }

            if (httpContext.Request.Query.ContainsKey("box_mac") && !uri.Contains("box_mac="))
            {
                string box_mac = httpContext.Request.Query["box_mac"].ToString()?.ToLower()?.Trim();
                if (!string.IsNullOrEmpty(box_mac))
                    args.Append($"&box_mac={HttpUtility.UrlEncode(box_mac)}");
            }

            if (httpContext.Request.Query.ContainsKey("nws_id") && !uri.Contains("nws_id="))
            {
                string nws_id = httpContext.Request.Query["nws_id"].ToString()?.ToLower()?.Trim();
                if (!string.IsNullOrEmpty(nws_id))
                    args.Append($"&nws_id={HttpUtility.UrlEncode(nws_id)}");
            }

            if (args.Length == 0)
                return uri;

            if (string.IsNullOrEmpty(uri))
                return args.ToString();

            if (uri.Contains("?"))
                return uri + args.ToString();

            return $"{uri}?{args.Remove(0, 1).ToString()}";
        }
    }
}

```

## File: Shared/Engine/Bash.cs
```
Ôªøusing System.Diagnostics;

namespace Shared.Engine
{
    public static class Bash
    {
        public static bool Invoke(string comand)
        {
            try
            {
                var processInfo = new ProcessStartInfo();
                processInfo.UseShellExecute = false;
                processInfo.RedirectStandardOutput = true;
                processInfo.FileName = "/bin/bash";
                processInfo.Arguments = $" -c \"{comand.Replace("\"", "\\\"").Replace("'", "\\\'")}\"";

                var process = Process.Start(processInfo);
                if (process == null)
                    return false;

                return true;
            }
            catch
            {
                return false;
            }
        }

        async public static Task<string> Run(string comand)
        {
            try
            {
                var processInfo = new ProcessStartInfo();
                processInfo.UseShellExecute = false;
                processInfo.RedirectStandardError = true;
                processInfo.RedirectStandardOutput = true;
                processInfo.FileName = "/bin/bash";
                processInfo.Arguments = $" -c \"{comand.Replace("\"", "\\\"").Replace("'", "\\\'")}\"";

                var process = Process.Start(processInfo);
                if (process == null)
                    return null;

                string outPut = await process.StandardOutput.ReadToEndAsync();
                outPut += await process.StandardError.ReadToEndAsync();

                await process.WaitForExitAsync();

                return outPut;
            }
            catch
            {
                return null;
            }
        }
    }
}

```

## File: Shared/Engine/AesTo.cs
```
Ôªøusing System.Security.Cryptography;
using System.Text;

namespace Shared.Engine
{
    public static class AesTo
    {
        static byte[] aesKey, aesIV;

        static AesTo()
        {
            if (File.Exists("cache/aeskey"))
            {
                var i = File.ReadAllText("cache/aeskey").Split("/");
                aesKey = Encoding.UTF8.GetBytes(i[0]);
                aesIV = Encoding.UTF8.GetBytes(i[1]);
            }
            else
            {
                string k = CrypTo.unic(16);
                string v = CrypTo.unic(16);
                File.WriteAllText("cache/aeskey", $"{k}/{v}");

                aesKey = Encoding.UTF8.GetBytes(k);
                aesIV = Encoding.UTF8.GetBytes(v);
            }
        }

        public static string Encrypt(string plainText)
        {
            try
            {
                using (var aes = Aes.Create())
                {
                    aes.Key = aesKey;
                    aes.IV = aesIV;

                    using (var encryptor = aes.CreateEncryptor(aes.Key, aes.IV))
                    {
                        using (var ms = new MemoryStream())
                        {
                            using (var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                            {
                                try
                                {
                                    using (var sw = new StreamWriter(cs, Encoding.UTF8))
                                        sw.Write(plainText ?? string.Empty);

                                    return Convert.ToBase64String(ms.ToArray());
                                }
                                catch { return null; }
                            }
                        }
                    }
                }
            }
            catch
            {
                return null;
            }
        }

        public static string Decrypt(string cipherText)
        {
            try
            {
                using (var aes = Aes.Create())
                {
                    aes.Key = aesKey;
                    aes.IV = aesIV;

                    using (var decryptor = aes.CreateDecryptor(aes.Key, aes.IV))
                    {
                        using (var ms = new MemoryStream(Convert.FromBase64String(cipherText)))
                        {
                            using (var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))
                            {
                                try
                                {
                                    using (var sr = new StreamReader(cs, Encoding.UTF8))
                                        return sr.ReadToEnd();
                                }
                                catch { return null; }
                            }
                        }
                    }
                }
            }
            catch
            {
                return null;
            }
        }
    }
}
```

## File: Shared/Engine/FFmpeg.cs
```
Ôªøusing System.Diagnostics;
using System.Runtime.InteropServices;

namespace Shared.Engine
{
    /// <summary>
    /// https://github.com/BtbN/FFmpeg-Builds/releases
    /// </summary>
    public static class FFmpeg
    {
        #region InitializationAsync
        static bool disableInstall = false;

        async public static Task<bool> InitializationAsync()
        {
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                #region Windows
                if (File.Exists("data/ffmpeg.exe") && File.Exists("data/ffprobe.exe"))
                {
                    Console.WriteLine("FFmpeg: Initialization");
                    return true;
                }

                if (RuntimeInformation.ProcessArchitecture != Architecture.X64 && RuntimeInformation.ProcessArchitecture != Architecture.Arm64)
                {
                    Console.WriteLine("FFmpeg: Architecture unknown");
                    return false;
                }

                if (disableInstall)
                    return true;

                disableInstall = true;
                string arh = RuntimeInformation.ProcessArchitecture == Architecture.X64 ? "64" : "arm64";

                foreach (string fileName in new string[] { "ffmpeg", "ffprobe" })
                {
                    if (File.Exists($"data/{fileName}.exe"))
                        continue;

                    if (!await Http.DownloadFile($"https://github.com/immisterio/ffmpeg/releases/download/ffmpeg2/{fileName}-win{arh}-gpl.exe", $"data/{fileName}.exe"))
                        File.Delete($"data/{fileName}.exe");
                }

                bool success = File.Exists("data/ffmpeg.exe") && File.Exists("data/ffprobe.exe");

                Console.WriteLine(success ? "FFmpeg: Initialization" : "FFmpeg: error download");
                disableInstall = false;
                return success;
                #endregion
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                #region Linux
                if ((File.Exists("data/ffmpeg") && File.Exists("data/ffprobe")) || File.Exists("/bin/ffmpeg"))
                {
                    Console.WriteLine("FFmpeg: Initialization");
                    return true;
                }

                string version = await Bash.Run("ffmpeg -version");
                if (version == null || !version.Contains("FFmpeg developers"))
                {
                    if (disableInstall)
                        return true;

                    disableInstall = true;

                    if (RuntimeInformation.ProcessArchitecture == Architecture.X64 || RuntimeInformation.ProcessArchitecture == Architecture.Arm64)
                    {
                        string arh = RuntimeInformation.ProcessArchitecture == Architecture.X64 ? "64" : "arm64";

                        foreach (string fileName in new string[] { "ffmpeg", "ffprobe" })
                        {
                            if (File.Exists($"data/{fileName}"))
                                continue;

                            if (!await Http.DownloadFile($"https://github.com/immisterio/ffmpeg/releases/download/ffmpeg2/{fileName}-linux{arh}-gpl", $"data/{fileName}"))
                            {
                                File.Delete($"data/{fileName}");
                                continue;
                            }

                            Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), $"data/{fileName}")}");
                        }

                        bool success = File.Exists("data/ffmpeg") && File.Exists("data/ffprobe");

                        await Task.Delay(1000); // Wait for chmod to complete
                        Console.WriteLine(success ? "FFmpeg: Initialization" : "FFmpeg: error download");
                        disableInstall = false;
                        return success;
                    }
                    else
                    {
                        await Bash.Run("apt update && apt install -y ffmpeg");
                        version = await Bash.Run("ffmpeg -version");
                        if (version == null || !version.Contains("FFmpeg developers"))
                        {
                            Console.WriteLine("FFmpeg: error install ffmpeg");
                            disableInstall = false;
                            return false;
                        }
                    }
                }

                Console.WriteLine("FFmpeg: Initialization");
                return true;
                #endregion
            }

            Console.WriteLine("FFmpeg: OS unknown");
            return false;
        }
        #endregion

        #region RunAsync
        async public static ValueTask<(string outputData, string errorData)> RunAsync(string comand, string workingDirectory = null, ProcessPriorityClass? priorityClass = null)
        {
            try
            {
                var process = new Process();
                process.StartInfo.UseShellExecute = false;
                process.StartInfo.RedirectStandardOutput = true;
                process.StartInfo.RedirectStandardError = true;
                process.StartInfo.FileName = AppInit.Win32NT ? "data/ffmpeg.exe" : File.Exists("data/ffmpeg") ? "data/ffmpeg" : "ffmpeg";
                process.StartInfo.Arguments = comand;
                process.StartInfo.WorkingDirectory = workingDirectory;
                process.Start();

                if (priorityClass != null)
                {
                    try
                    {
                        process.PriorityClass = (ProcessPriorityClass)priorityClass;
                    }
                    catch (InvalidOperationException)
                    {
                        // –ü—Ä–æ—Ü–µ—Å—Å –∑–∞–≤–µ—Ä—à–∏–ª—Å—è –¥–æ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞
                    }
                    catch(Exception ex)
                    {
                        Console.WriteLine("FFmpeg: " + ex.Message);
                    }
                }

                string outputData = string.Empty, errorData = string.Empty;

                process.OutputDataReceived += (sender, args) =>
                {
                    if (!string.IsNullOrEmpty(args.Data))
                        outputData += args.Data + "\n";
                };

                process.ErrorDataReceived += (sender, args) =>
                {
                    if (!string.IsNullOrEmpty(args.Data))
                        errorData += args.Data + "\n";
                };

                process.BeginOutputReadLine();
                process.BeginErrorReadLine();

                await process.WaitForExitAsync();

                return (outputData, errorData);
            }
            catch 
            {
                return default;
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/ProxyLink.cs
```
Ôªøusing Microsoft.EntityFrameworkCore;
using Shared.Models;
using Shared.Models.Base;
using Shared.Models.Proxy;
using Shared.Models.SQL;
using System.Collections.Concurrent;
using System.Net;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;
using System.Threading;

namespace Shared.Engine
{
    public class ProxyLink : IProxyLink
    {
        #region ProxyLink
        static ConcurrentDictionary<string, ProxyLinkModel> links = new ConcurrentDictionary<string, ProxyLinkModel>();

        static Timer _cronTimer;

        static ProxyLink()
        {
            _cronTimer = new Timer(Cron, null, TimeSpan.Zero, TimeSpan.FromSeconds(5));
        }
        #endregion


        #region Encrypt
        public string Encrypt(string uri, string plugin, DateTime ex = default) => Encrypt(uri, null, verifyip: false, ex: ex, plugin: plugin);

        public static string Encrypt(string uri, ProxyLinkModel p, bool forceMd5 = false) => Encrypt(uri, p.reqip, p.headers, p.proxy, p.plugin, p.verifyip, forceMd5: forceMd5);

        public static string Encrypt(string uri, string reqip, List<HeadersModel> headers = null, WebProxy proxy = null, string plugin = null, bool verifyip = true, DateTime ex = default, bool forceMd5 = false)
        {
            if (string.IsNullOrWhiteSpace(uri))
                return string.Empty;

            string hash;
            bool IsMd5 = false;
            string uri_clear = uri.Contains("#") ? uri.Split("#")[0].Trim() : uri.Trim();

            if (plugin == "posterapi")
            {
                hash = AesTo.Encrypt(JsonSerializer.Serialize(new { u = uri_clear }));
            }
            else if (!forceMd5 && AppInit.conf.serverproxy.encrypt_aes && (headers == null || headers.Count == 0) && proxy == null && !uri_clear.Contains(" or "))
            {
                if (verifyip && AppInit.conf.serverproxy.verifyip)
                {
                    hash = AesTo.Encrypt(JsonSerializer.Serialize(new
                    {
                        p = plugin,
                        u = uri_clear,
                        i = reqip,
                        v = true,
                        e = DateTime.Now.AddHours(36)
                    }));
                }
                else
                {
                    hash = AesTo.Encrypt(JsonSerializer.Serialize(new { p = plugin, u = uri_clear }));
                }
            }
            else
            {
                IsMd5 = true;
                hash = CrypTo.md5(uri_clear + (verifyip && AppInit.conf.serverproxy.verifyip ? reqip : string.Empty));
            }

            if (uri.Contains(".m3u8"))
                hash += ".m3u8";
            else if (uri.Contains(".m3u"))
                hash += ".m3u";
            else if (uri.Contains(".mpd"))
                hash += ".mpd";
            else if (uri.Contains(".webm"))
                hash += ".webm";
            else if (uri.Contains(".ts"))
                hash += ".ts";
            else if (uri.Contains(".m4s"))
                hash += ".m4s";
            else if (uri.Contains(".mp4"))
                hash += ".mp4";
            else if (uri.Contains(".mkv"))
                hash += ".mkv";
            else if (uri.Contains(".aac"))
                hash += ".aac";
            else if (uri.Contains(".jpg") || uri.Contains(".jpeg"))
                hash += ".jpg";
            else if (uri.Contains(".png"))
                hash += ".png";
            else if (uri.Contains(".webp"))
                hash += ".webp";
            else if (uri.Contains(".vtt"))
                hash += ".vtt";
            else if (uri.Contains(".srt"))
                hash += ".srt";

            if (IsMd5)
            {
                var md = new ProxyLinkModel(verifyip ? reqip : null, headers, proxy, uri_clear, plugin, verifyip, ex: ex);
                links.AddOrUpdate(hash, md, (d, u) => md);
            }

            return hash;
        }
        #endregion

        #region Decrypt
        public static ProxyLinkModel Decrypt(string hash, string reqip)
        {
            if (string.IsNullOrEmpty(hash))
                return null;

            if (IsAes(hash))
            {
                hash = Regex.Replace(hash, "\\.[a-z0-9]+$", "", RegexOptions.IgnoreCase);

                string dec = AesTo.Decrypt(hash);
                if (string.IsNullOrEmpty(dec))
                    return null;

                var root = JsonNode.Parse(dec);

                if (root["v"]?.GetValue<bool>() == true)
                {
                    if (reqip != null && root["i"].GetValue<string>() != reqip)
                        return null;

                    if (DateTime.Now > root["e"].GetValue<DateTime>())
                        return null;
                }

                var headers = HeadersModel.Init(root["h"]?.Deserialize<Dictionary<string, string>>());

                return new ProxyLinkModel(reqip, headers, null, root["u"].GetValue<string>(), root["p"]?.GetValue<string>());
            }

            if (!links.TryGetValue(hash, out ProxyLinkModel val))
            {
                try
                {
                    if (!AppInit.conf.mikrotik)
                    {
                        using (var sqlDb = new ProxyLinkContext())
                        {
                            var link = sqlDb.links.Find(hash);

                            if (link != null && link.ex > DateTime.Now)
                            {
                                val = JsonSerializer.Deserialize<ProxyLinkModel>(link.json);
                                val.id = link.Id;
                                val.ex = link.ex;
                            }
                        }
                    }
                }
                catch { }
            }

            if (val != null)
            {
                if (val.verifyip == false || AppInit.conf.serverproxy.verifyip == false || val.reqip == string.Empty || reqip == null || reqip == val.reqip)
                    return val;
            }

            return null;
        }
        #endregion

        #region IsAes
        public static bool IsAes(string hash)
        {
            if (hash.StartsWith("http"))
                return false;

            if (hash.Split('?', '&', '.')[0].Length == 32)
                return false;

            return true;
        }
        #endregion


        #region Cron
        static HashSet<string> tempLinks = new();

        static int cronRound = 0;

        static DateTime _nextClearDb = DateTime.Now.AddHours(1);

        static bool _cronWork = false;

        async static void Cron(object state)
        {
            if (_cronWork || links.Count == 0)
                return;

            _cronWork = true;

            try
            {
                if (cronRound == 60)
                {
                    cronRound = 0;
                    tempLinks.Clear();
                }

                cronRound++;

                using (var sqlDb = new ProxyLinkContext())
                {
                    if (DateTime.Now > _nextClearDb)
                    {
                        _nextClearDb = DateTime.Now.AddHours(1);

                        var now = DateTime.Now;

                        await sqlDb.links
                             .Where(i => now > i.ex)
                             .ExecuteDeleteAsync();
                    }
                    else
                    {
                        foreach (var link in links.ToArray())
                        {
                            try
                            {
                                if (AppInit.conf.mikrotik || link.Value.proxy != null || DateTime.Now.AddMinutes(5) > link.Value.ex || link.Value.uri.Contains(" or "))
                                {
                                    if (DateTime.Now > link.Value.ex)
                                        links.TryRemove(link.Key, out _);
                                }
                                else
                                {
                                    if (tempLinks.Contains(link.Key))
                                        links.TryRemove(link.Key, out _);
                                    else
                                    {
                                        link.Value.id = link.Key;

                                        await sqlDb.links
                                            .Where(x => x.Id == link.Key)
                                            .ExecuteDeleteAsync();

                                        sqlDb.links.Add(new ProxyLinkSqlModel()
                                        {
                                            Id = link.Key,
                                            ex = link.Value.ex,
                                            json = JsonSerializer.Serialize(link.Value)
                                        });

                                        if (await sqlDb.SaveChangesAsync() > 0)
                                        {
                                            tempLinks.Add(link.Key);
                                            links.TryRemove(link.Key, out _);
                                        }
                                    }
                                }
                            }
                            catch (Exception ex) { Console.WriteLine($"ProxyLink: {ex}"); }
                        }
                    }
                }
            }
            catch (Exception ex) { Console.WriteLine($"ProxyLink: {ex}"); }
            finally 
            {
                _cronWork = false;
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/ModuleRepository.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc.ApplicationParts;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.IO.Compression;
using System.Net.Http;
using System.Text;
using System.Threading;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Shared.Engine
{
    /// <summary>
    /// Codex AI - Module Repository
    /// </summary>
    public static class ModuleRepository
    {
        private const string RepositoryFile = "module/repository.yaml";
        private const string StateFile = "module/.repository_state.json";

        private static readonly object SyncRoot = new object();
        private static readonly HttpClient HttpClient;

        private static ApplicationPartManager partManager;
        private static Dictionary<string, string> repositoryState;

        static ModuleRepository()
        {
            HttpClient = new HttpClient
            {
                Timeout = TimeSpan.FromSeconds(60)
            };

            if (!HttpClient.DefaultRequestHeaders.UserAgent.Any())
                HttpClient.DefaultRequestHeaders.UserAgent.ParseAdd("LampacModuleRepository/1.0");

            if (!HttpClient.DefaultRequestHeaders.Accept.Any())
                HttpClient.DefaultRequestHeaders.Accept.ParseAdd("application/vnd.github+json");
        }

        public static void Configuration(IMvcBuilder mvcBuilder)
        {
            partManager = mvcBuilder?.PartManager;

            UpdateModules();
        }

        private static void UpdateModules()
        {
            if (!Monitor.TryEnter(SyncRoot))
            {
                Console.WriteLine("ModuleRepository: UpdateModules skipped because another update is running");
                return;
            }

            Console.WriteLine("ModuleRepository: UpdateModules start");

            try
            {
                var repositories = LoadConfiguration();
                if (repositories.Count == 0)
                {
                    Console.WriteLine("ModuleRepository: no repositories configured");
                    return;
                }

                Directory.CreateDirectory(Path.Combine(Environment.CurrentDirectory, "module"));
                Console.WriteLine("ModuleRepository: ensured module directory exists");

                var state = LoadState();
                bool stateChanged = false;
                var modulesToCompile = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

                foreach (var repository in repositories)
                {
                    try
                    {
                        if (!repository.IsValid)
                        {
                            Console.WriteLine($"ModuleRepository: skipping invalid repository '{repository?.Url}'");
                            continue;
                        }

                        bool missingModule = repository.Folders.Any(folder => !Directory.Exists(Path.Combine(Environment.CurrentDirectory, "module", folder.ModuleName)));
                        string commitSha = GetLatestCommitSha(repository);
                        if (string.IsNullOrEmpty(commitSha))
                        {
                            Console.WriteLine($"ModuleRepository: could not determine latest commit for {repository.Url}");
                            continue;
                        }

                        string stateKey = repository.StateKey;
                        if (!missingModule && state.TryGetValue(stateKey, out string storedSha) && string.Equals(storedSha, commitSha, StringComparison.OrdinalIgnoreCase))
                        {
                            Console.WriteLine($"ModuleRepository: repository '{repository.Url}' is up-to-date (sha={commitSha})");
                            continue;
                        }

                        if (DownloadAndExtract(repository, modulesToCompile))
                        {
                            state[stateKey] = commitSha;
                            stateChanged = true;
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"ModuleRepository: error processing repository {repository?.Url} - {ex.Message}");
                    }
                }

                if (stateChanged)
                {
                    SaveState(state);
                    Console.WriteLine("ModuleRepository: state saved");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"module repository: {ex.Message}");
            }
            finally
            {
                Console.WriteLine("ModuleRepository: UpdateModules finished, releasing lock");
                Monitor.Exit(SyncRoot);
            }
        }

        private static List<RepositoryEntry> LoadConfiguration()
        {
            string path = Path.Combine(Environment.CurrentDirectory, RepositoryFile.Replace('/', Path.DirectorySeparatorChar));
            if (!File.Exists(path))
            {
                Console.WriteLine($"ModuleRepository: repository config file not found at {path}");
                return new List<RepositoryEntry>();
            }

            try
            {
                string yaml = File.ReadAllText(path);
                if (string.IsNullOrWhiteSpace(yaml))
                {
                    Console.WriteLine("ModuleRepository: repository config file is empty");
                    return new List<RepositoryEntry>();
                }

                var deserializer = new DeserializerBuilder()
                    .WithNamingConvention(UnderscoredNamingConvention.Instance)
                    .IgnoreUnmatchedProperties()
                    .Build();

                var document = deserializer.Deserialize(new StringReader(yaml));
                if (document == null)
                {
                    Console.WriteLine("ModuleRepository: repository config deserialized to null");
                    return new List<RepositoryEntry>();
                }

                var repos = ParseRepositories(document);
                Console.WriteLine($"ModuleRepository: loaded {repos.Count} repository entries from config");
                return repos;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"module repository: failed to read configuration - {ex.Message}");
                return new List<RepositoryEntry>();
            }
        }

        private static List<RepositoryEntry> ParseRepositories(object document)
        {
            var list = new List<RepositoryEntry>();

            if (document is IList<object> sequence)
            {
                foreach (var item in sequence)
                {
                    var repository = CreateRepository(item);
                    if (repository != null)
                        list.Add(repository);
                    else
                        Console.WriteLine("ModuleRepository: skipped invalid repository entry in sequence");
                }
            }
            else if (document is IDictionary<object, object> map)
            {
                foreach (var entry in map)
                {
                    var repository = CreateRepository(entry.Value);
                    if (repository != null)
                        list.Add(repository);
                    else
                        Console.WriteLine("ModuleRepository: skipped invalid repository entry in map");
                }
            }

            return list;
        }

        private static RepositoryEntry CreateRepository(object node)
        {
            if (node is IDictionary<object, object> map)
            {
                string url = GetString(map, "repository", "repo", "url", "git", "remote");
                if (string.IsNullOrWhiteSpace(url))
                {
                    Console.WriteLine("ModuleRepository: repository entry missing url");
                    return null;
                }

                string branch = GetString(map, "branch", "ref");
                var folders = ParseFolders(map);

                var repository = new RepositoryEntry
                {
                    Url = url.Trim(),
                    Branch = string.IsNullOrWhiteSpace(branch) ? null : branch.Trim(),
                    Folders = folders
                };

                if (!TryParseGitHubUrl(repository.Url, out string owner, out string name))
                {
                    Console.WriteLine($"module repository: unsupported repository url '{repository.Url}'");
                    return null;
                }

                repository.Owner = owner;
                repository.Name = name;

                ApplyAuthenticationSettings(map, repository);
                Console.WriteLine($"ModuleRepository: parsed repository {repository.Owner}/{repository.Name} branch={repository.Branch ?? "(default)"}");

                // If no folders were specified in YAML, try to fetch top-level directories from GitHub repo
                if (repository.Folders == null || repository.Folders.Count == 0)
                {
                    try
                    {
                        var remoteFolders = FetchRepositoryFolders(repository);
                        if (remoteFolders.Count > 0)
                        {
                            repository.Folders = remoteFolders;
                            Console.WriteLine($"ModuleRepository: populated {remoteFolders.Count} folders from remote repository {repository.Owner}/{repository.Name}");
                        }
                        else
                        {
                            Console.WriteLine($"ModuleRepository: no folders found in remote repository {repository.Owner}/{repository.Name}");
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"ModuleRepository: failed to fetch folders for {repository.Owner}/{repository.Name} - {ex.Message}");
                    }
                }

                return repository;
            }

            return null;
        }

        private static void ApplyAuthenticationSettings(IDictionary<object, object> map, RepositoryEntry repository)
        {
            if (map == null || repository == null)
                return;

            string accept = GetString(map, "accept", "accept_header");
            if (!string.IsNullOrWhiteSpace(accept))
                repository.AcceptHeader = accept.Trim();

            string authHeader = GetString(map, "auth_header", "authorization", "authorization_header");
            if (!string.IsNullOrWhiteSpace(authHeader))
            {
                string resolvedHeader = ResolveSecretValue(authHeader, "auth_header", repository);
                if (!string.IsNullOrWhiteSpace(resolvedHeader))
                    repository.Token = resolvedHeader.Trim();

                return;
            }

            string tokenValue = GetString(map, "token", "pat", "personal_access_token");
            if (string.IsNullOrWhiteSpace(tokenValue))
                return;

            string resolvedToken = ResolveSecretValue(tokenValue, "token", repository);
            if (string.IsNullOrWhiteSpace(resolvedToken))
                return;

            string tokenType = GetString(map, "token_type", "auth_type", "authorization_scheme", "scheme", "token_scheme");
            string headerValue;

            if (!string.IsNullOrWhiteSpace(tokenType))
            {
                headerValue = $"{tokenType.Trim()} {resolvedToken.Trim()}".Trim();
            }
            else
            {
                string trimmed = resolvedToken.Trim();
                headerValue = trimmed.Contains(' ') ? trimmed : $"token {trimmed}";
            }

            if (string.IsNullOrWhiteSpace(headerValue))
            {
                Console.WriteLine($"ModuleRepository: resolved token for {repository.Url} is empty");
                return;
            }

            repository.Token = headerValue;
        }

        private static string ResolveSecretValue(string value, string fieldName, RepositoryEntry repository)
        {
            if (string.IsNullOrWhiteSpace(value))
                return null;

            string trimmed = value.Trim();

            int envIndex = trimmed.IndexOf("env:", StringComparison.OrdinalIgnoreCase);
            if (envIndex < 0)
                return trimmed;

            var builder = new StringBuilder();
            int currentIndex = 0;

            while (envIndex >= 0)
            {
                builder.Append(trimmed, currentIndex, envIndex - currentIndex);

                int nameStart = envIndex + 4;
                int nameEnd = nameStart;
                while (nameEnd < trimmed.Length && (char.IsLetterOrDigit(trimmed[nameEnd]) || trimmed[nameEnd] == '_'))
                    nameEnd++;

                if (nameEnd == nameStart)
                {
                    Console.WriteLine($"ModuleRepository: {fieldName} environment variable name is missing for repository {repository?.Url}");
                    return null;
                }

                string envName = trimmed[nameStart..nameEnd];
                string envValue = Environment.GetEnvironmentVariable(envName);
                if (string.IsNullOrWhiteSpace(envValue))
                {
                    Console.WriteLine($"ModuleRepository: environment variable '{envName}' not found for repository {repository?.Url}");
                    return null;
                }

                builder.Append(envValue.Trim());
                currentIndex = nameEnd;
                envIndex = trimmed.IndexOf("env:", currentIndex, StringComparison.OrdinalIgnoreCase);
            }

            builder.Append(trimmed[currentIndex..]);
            return builder.ToString().Trim();
        }

        private static List<RepositoryFolder> ParseFolders(IDictionary<object, object> map)
        {
            foreach (string key in new[] { "modules", "folders", "directories", "paths", "include" })
            {
                if (TryGetValue(map, key, out object value))
                    return ConvertToFolders(value);
            }

            return new List<RepositoryFolder>();
        }

        private static List<RepositoryFolder> ConvertToFolders(object value)
        {
            var result = new List<RepositoryFolder>();

            if (value is IList<object> sequence)
            {
                foreach (var item in sequence)
                {
                    var folder = ConvertFolderItem(item);
                    if (folder != null)
                        result.Add(folder);
                    else
                        Console.WriteLine("ModuleRepository: skipped invalid folder item in sequence");
                }
            }
            else if (value is IDictionary<object, object> map)
            {
                foreach (var entry in map)
                {
                    var folder = ConvertFolderEntry(entry.Key, entry.Value);
                    if (folder != null)
                        result.Add(folder);
                    else
                        Console.WriteLine("ModuleRepository: skipped invalid folder entry in map");
                }
            }

            return result;
        }

        private static RepositoryFolder ConvertFolderItem(object item)
        {
            if (item is string str)
                return CreateFolder(str, null);

            if (item is IDictionary<object, object> map)
            {
                string source = GetString(map, "path", "source", "folder", "repo_path", "from");
                string target = GetString(map, "target", "name", "to", "destination");

                if (string.IsNullOrEmpty(source) && map.Count == 1)
                {
                    var single = map.First();
                    source = single.Key?.ToString();
                    target = single.Value?.ToString();
                }

                return CreateFolder(source, target);
            }

            return null;
        }

        private static RepositoryFolder ConvertFolderEntry(object key, object value)
        {
            if (value is IDictionary<object, object> map)
            {
                string source = GetString(map, "path", "source", "folder", "repo_path", "from") ?? key?.ToString();
                string target = GetString(map, "target", "name", "to", "destination") ?? value?.ToString();
                return CreateFolder(source, target);
            }

            return CreateFolder(key?.ToString(), value?.ToString());
        }

        private static RepositoryFolder CreateFolder(string source, string target)
        {
            if (string.IsNullOrWhiteSpace(source))
                return null;

            var folder = new RepositoryFolder(source, target);
            if (!folder.IsValid)
                return null;

            return folder;
        }

        private static string GetString(IDictionary<object, object> map, params string[] keys)
        {
            foreach (var key in keys)
            {
                foreach (var entry in map)
                {
                    if (string.Equals(entry.Key?.ToString(), key, StringComparison.OrdinalIgnoreCase))
                        return entry.Value?.ToString();
                }
            }

            return null;
        }

        private static bool TryGetValue(IDictionary<object, object> map, string key, out object value)
        {
            foreach (var entry in map)
            {
                if (string.Equals(entry.Key?.ToString(), key, StringComparison.OrdinalIgnoreCase))
                {
                    value = entry.Value;
                    return true;
                }
            }

            value = null;
            return false;
        }

        private static Dictionary<string, string> LoadState()
        {
            if (repositoryState != null)
                return repositoryState;

            string path = Path.Combine(Environment.CurrentDirectory, StateFile.Replace('/', Path.DirectorySeparatorChar));

            if (File.Exists(path))
            {
                try
                {
                    var json = File.ReadAllText(path);
                    var data = JsonConvert.DeserializeObject<Dictionary<string, string>>(json);
                    if (data != null)
                        repositoryState = new Dictionary<string, string>(data, StringComparer.OrdinalIgnoreCase);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"module repository: failed to load state - {ex.Message}");
                }
            }

            repositoryState ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            Console.WriteLine($"ModuleRepository: loaded state entries = {repositoryState.Count}");
            return repositoryState;
        }

        private static void SaveState(Dictionary<string, string> state)
        {
            try
            {
                string path = Path.Combine(Environment.CurrentDirectory, StateFile.Replace('/', Path.DirectorySeparatorChar));
                Directory.CreateDirectory(Path.GetDirectoryName(path));
                File.WriteAllText(path, JsonConvert.SerializeObject(state, Formatting.Indented));
            }
            catch (Exception ex)
            {
                Console.WriteLine($"module repository: failed to save state - {ex.Message}");
            }
        }

        private static string GetLatestCommitSha(RepositoryEntry repository)
        {
            if (string.IsNullOrEmpty(repository.Owner) || string.IsNullOrEmpty(repository.Name))
            {
                Console.WriteLine("ModuleRepository: GetLatestCommitSha - owner or name is empty");
                return null;
            }

            // Determine a usable branch (try configured, default, then main, then master)
            var branch = DetermineBranch(repository);
            if (string.IsNullOrEmpty(branch))
            {
                Console.WriteLine($"ModuleRepository: could not determine a valid branch for {repository.Owner}/{repository.Name}");
                return null;
            }

            var branchInfo = GetJson(repository, $"https://api.github.com/repos/{repository.Owner}/{repository.Name}/branches/{Uri.EscapeDataString(branch)}");
            var sha = branchInfo?["commit"]?["sha"]?.Value<string>();
            Console.WriteLine($"ModuleRepository: latest commit sha for {repository.Owner}/{repository.Name} ({branch}) = {sha}");
            return sha;
        }

        private static string DetermineBranch(RepositoryEntry repository)
        {
            if (string.IsNullOrEmpty(repository.Owner) || string.IsNullOrEmpty(repository.Name))
                return null;

            var candidates = new List<string>();
            if (!string.IsNullOrWhiteSpace(repository.Branch))
                candidates.Add(repository.Branch.Trim());

            // Try to get default branch from repo metadata
            var repoInfo = GetJson(repository, $"https://api.github.com/repos/{repository.Owner}/{repository.Name}");
            var defaultBranch = repoInfo?["default_branch"]?.Value<string>();
            if (!string.IsNullOrWhiteSpace(defaultBranch) && !candidates.Contains(defaultBranch, StringComparer.OrdinalIgnoreCase))
                candidates.Add(defaultBranch);

            // Add common fallbacks
            if (!candidates.Contains("main", StringComparer.OrdinalIgnoreCase))
                candidates.Add("main");
            if (!candidates.Contains("master", StringComparer.OrdinalIgnoreCase))
                candidates.Add("master");

            foreach (var b in candidates)
            {
                if (string.IsNullOrWhiteSpace(b))
                    continue;

                var branchInfo = GetJson(repository, $"https://api.github.com/repos/{repository.Owner}/{repository.Name}/branches/{Uri.EscapeDataString(b)}");
                if (branchInfo != null)
                {
                    repository.Branch = b;
                    Console.WriteLine($"ModuleRepository: selected branch '{b}' for {repository.Owner}/{repository.Name}");
                    return b;
                }
            }

            return null;
        }

        private static HttpResponseMessage SendGetRequest(string url, RepositoryEntry repository, string acceptOverride = null, bool includeConfiguredAccept = true)
        {
            var request = CreateRequest(HttpMethod.Get, url, repository, acceptOverride, includeConfiguredAccept);

            try
            {
                return HttpClient.SendAsync(request).GetAwaiter().GetResult();
            }
            finally
            {
                request.Dispose();
            }
        }

        private static HttpRequestMessage CreateRequest(HttpMethod method, string url, RepositoryEntry repository, string acceptOverride, bool includeConfiguredAccept)
        {
            var request = new HttpRequestMessage(method, url);

            if (!string.IsNullOrWhiteSpace(repository?.Token))
                request.Headers.TryAddWithoutValidation("Authorization", repository.Token);

            if (includeConfiguredAccept && !string.IsNullOrWhiteSpace(repository?.AcceptHeader))
                request.Headers.TryAddWithoutValidation("Accept", repository.AcceptHeader);

            if (!string.IsNullOrWhiteSpace(acceptOverride))
                request.Headers.TryAddWithoutValidation("Accept", acceptOverride);

            return request;
        }

        private static JObject GetJson(RepositoryEntry repository, string url)
        {
            try
            {
                using var response = SendGetRequest(url, repository);
                if (!response.IsSuccessStatusCode)
                {
                    Console.WriteLine($"module repository: request {url} failed with {(int)response.StatusCode} {response.StatusCode}");
                    return null;
                }

                string json = response.Content.ReadAsStringAsync().GetAwaiter().GetResult();
                if (string.IsNullOrEmpty(json))
                    return null;

                Console.WriteLine($"ModuleRepository: GetJson success for {url}");
                return JsonConvert.DeserializeObject<JObject>(json);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"module repository: request {url} failed - {ex.Message}");
                return null;
            }
        }

        private static JArray GetJsonArray(RepositoryEntry repository, string url)
        {
            try
            {
                using var response = SendGetRequest(url, repository);
                if (!response.IsSuccessStatusCode)
                {
                    Console.WriteLine($"module repository: request {url} failed with {(int)response.StatusCode} {response.StatusCode}");
                    return null;
                }

                string json = response.Content.ReadAsStringAsync().GetAwaiter().GetResult();
                if (string.IsNullOrEmpty(json))
                    return null;

                Console.WriteLine($"ModuleRepository: GetJsonArray success for {url}");
                return JsonConvert.DeserializeObject<JArray>(json);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"module repository: request {url} failed - {ex.Message}");
                return null;
            }
        }

        private static List<RepositoryFolder> FetchRepositoryFolders(RepositoryEntry repository)
        {
            var result = new List<RepositoryFolder>();
            if (string.IsNullOrEmpty(repository.Owner) || string.IsNullOrEmpty(repository.Name))
                return result;

            var branch = DetermineBranch(repository);
            if (string.IsNullOrEmpty(branch))
                return result;

            string url = $"https://api.github.com/repos/{repository.Owner}/{repository.Name}/contents?ref={Uri.EscapeDataString(branch)}";
            var items = GetJsonArray(repository, url);
            if (items == null)
                return result;

            foreach (var item in items)
            {
                var type = item["type"]?.Value<string>();
                if (!string.Equals(type, "dir", StringComparison.OrdinalIgnoreCase))
                    continue;

                var name = item["name"]?.Value<string>();
                if (string.IsNullOrEmpty(name))
                    continue;

                var folder = new RepositoryFolder(name, null);
                if (folder.IsValid)
                    result.Add(folder);
            }

            return result;
        }

        private static bool DownloadAndExtract(RepositoryEntry repository, HashSet<string> modulesToCompile)
        {
            string branch = string.IsNullOrWhiteSpace(repository.Branch) ? "main" : repository.Branch;
            string archiveUrl = $"https://codeload.github.com/{repository.Owner}/{repository.Name}/zip/refs/heads/{Uri.EscapeDataString(branch)}";
            string tempZip = Path.Combine(Path.GetTempPath(), $"lampac-modrepo-{Guid.NewGuid():N}.zip");
            string tempDir = Path.Combine(Path.GetTempPath(), $"lampac-modrepo-{Guid.NewGuid():N}");

            Console.WriteLine($"ModuleRepository: DownloadAndExtract start for {repository.Owner}/{repository.Name} branch={branch}");

            try
            {
                Console.WriteLine($"ModuleRepository: downloading archive {archiveUrl}");
                using (var response = SendGetRequest(archiveUrl, repository))
                {
                    if (!response.IsSuccessStatusCode)
                    {
                        Console.WriteLine($"module repository: failed to download {archiveUrl} - {(int)response.StatusCode}{response.StatusCode}");
                        return false;
                    }

                    using (var stream = File.Create(tempZip))
                        response.Content.CopyToAsync(stream).GetAwaiter().GetResult();
                }

                ZipFile.ExtractToDirectory(tempZip, tempDir, true);
                Console.WriteLine($"ModuleRepository: archive extracted to {tempDir}");

                string root = Directory.GetDirectories(tempDir).FirstOrDefault();
                if (string.IsNullOrEmpty(root) || !Directory.Exists(root))
                {
                    Console.WriteLine("module repository: archive structure not recognized");
                    return false;
                }

                Console.WriteLine($"ModuleRepository: archive root = {root}");

                foreach (var folder in repository.Folders)
                {
                    string sourcePath = folder.GetSourcePath(root);
                    if (!Directory.Exists(sourcePath))
                    {
                        Console.WriteLine($"module repository: folder '{folder.Source}' not found in {repository.Url}");
                        continue;
                    }

                    string destinationPath = Path.Combine(Environment.CurrentDirectory, "module", folder.ModuleName);

                    string existingManifestJson = null;
                    string existingManifestPath = Path.Combine(destinationPath, "manifest.json");

                    if (Directory.Exists(destinationPath))
                    {
                        try
                        {
                            // Read existing manifest if present so we can preserve/merge its values
                            if (File.Exists(existingManifestPath))
                            {
                                try { existingManifestJson = File.ReadAllText(existingManifestPath); } catch { existingManifestJson = null; }
                            }

                            Directory.Delete(destinationPath, true);
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"module repository: failed to clean '{destinationPath}': {ex.Message}");
                            continue;
                        }
                    }

                    Directory.CreateDirectory(destinationPath);
                    CopyDirectory(sourcePath, destinationPath);

                    // After copying, merge manifests if we had an existing one
                    string newManifestPath = Path.Combine(destinationPath, "manifest.json");
                    if (!string.IsNullOrEmpty(existingManifestJson) && File.Exists(newManifestPath))
                    {
                        try
                        {
                            string newManifestJson = File.ReadAllText(newManifestPath);
                            var merged = MergeManifests(existingManifestJson, newManifestJson);
                            if (merged != null)
                                File.WriteAllText(newManifestPath, merged);
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"module repository: failed to merge post-copy manifest.json for '{folder.ModuleName}': {ex.Message}");
                        }
                    }

                    modulesToCompile.Add(folder.ModuleName);
                    Console.WriteLine($"module repository: updated module '{folder.ModuleName}' from {repository.Url}");
                }

                return true;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"module repository: {ex.Message}");
                return false;
            }
            finally
            {
                try { if (File.Exists(tempZip)) File.Delete(tempZip); } catch { }
                try { if (Directory.Exists(tempDir)) Directory.Delete(tempDir, true); } catch { }
                Console.WriteLine($"ModuleRepository: DownloadAndExtract finished for {repository.Owner}/{repository.Name}");
            }
        }

        private static string MergeManifests(string existingJson, string newJson)
        {
            try
            {
                var existingToken = JsonConvert.DeserializeObject<JToken>(existingJson);
                var newToken = JsonConvert.DeserializeObject<JToken>(newJson);

                if (existingToken == null)
                    return newJson;

                if (newToken == null)
                    return existingJson;

                // If both are arrays: merge by 'dll' key; start from existing to preserve custom fields
                if (existingToken is JArray existingArr && newToken is JArray newArr)
                {
                    // Build index for existing by dll (case-insensitive)
                    var existingIndex = new Dictionary<string, JObject>(StringComparer.OrdinalIgnoreCase);
                    foreach (var e in existingArr.OfType<JObject>())
                    {
                        var dll = e["dll"]?.Value<string>();
                        if (!string.IsNullOrEmpty(dll))
                            existingIndex[dll.ToLowerInvariant()] = (JObject)e.DeepClone();
                    }

                    // Apply updates from newArr: only properties present in source overwrite existing
                    foreach (var n in newArr.OfType<JObject>())
                    {
                        var ndll = n["dll"]?.Value<string>();
                        if (!string.IsNullOrEmpty(ndll) && existingIndex.TryGetValue(ndll.ToLowerInvariant(), out JObject existObj))
                        {
                            foreach (var prop in n.Properties())
                            {
                                var name = prop.Name;
                                if (string.Equals(name, "enable", StringComparison.OrdinalIgnoreCase))
                                {
                                    // preserve existing enable if present
                                    if (existObj.Property(name, StringComparison.OrdinalIgnoreCase) == null)
                                        existObj[name] = prop.Value.DeepClone();

                                    continue;
                                }

                                // Only update properties that exist in new manifest (we are iterating them)
                                existObj[name] = prop.Value.DeepClone();
                            }

                            existingIndex[ndll.ToLowerInvariant()] = existObj;
                        }
                        else
                        {
                            // New entry: add to existingIndex
                            var clone = (JObject)n.DeepClone();
                            existingIndex[ndll?.ToLowerInvariant() ?? Guid.NewGuid().ToString()] = clone;
                        }
                    }

                    // Preserve original order where possible: start with original existingArr order, then append any new ones not present
                    var resultArr = new JArray();

                    var added = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                    foreach (var e in existingArr.OfType<JObject>())
                    {
                        var dll = e["dll"]?.Value<string>() ?? string.Empty;
                        if (existingIndex.TryGetValue(dll.ToLowerInvariant(), out JObject val))
                        {
                            resultArr.Add(val);
                            added.Add(dll.ToLowerInvariant());
                        }
                        else
                        {
                            resultArr.Add(e);
                            added.Add(dll.ToLowerInvariant());
                        }
                    }

                    // Append remaining
                    foreach (var kv in existingIndex)
                    {
                        if (!added.Contains(kv.Key))
                            resultArr.Add(kv.Value);
                    }

                    return JsonConvert.SerializeObject(resultArr, Formatting.Indented);
                }

                // If both are objects: merge into existing, updating only fields present in new, but preserve existing enable
                if (existingToken is JObject existingObjRoot && newToken is JObject newObjRoot)
                {
                    foreach (var prop in newObjRoot.Properties())
                    {
                        var name = prop.Name;
                        if (string.Equals(name, "enable", StringComparison.OrdinalIgnoreCase) && existingObjRoot.Property(name, StringComparison.OrdinalIgnoreCase) != null)
                            continue; // preserve

                        existingObjRoot[name] = prop.Value.DeepClone();
                    }

                    return JsonConvert.SerializeObject(existingObjRoot, Formatting.Indented);
                }

                // Fallback: return newJson
                return newJson;
            }
            catch
            {
                return newJson;
            }
        }

        private static void CopyDirectory(string source, string destination)
        {
            foreach (string directory in Directory.GetDirectories(source, "*", SearchOption.AllDirectories))
            {
                string relative = Path.GetRelativePath(source, directory);
                if (ShouldSkip(relative))
                    continue;

                Directory.CreateDirectory(Path.Combine(destination, relative));
            }

            foreach (string file in Directory.GetFiles(source, "*", SearchOption.AllDirectories))
            {
                string relative = Path.GetRelativePath(source, file);
                if (ShouldSkip(relative))
                    continue;

                string target = Path.Combine(destination, relative);
                Directory.CreateDirectory(Path.GetDirectoryName(target));

                try
                {
                    File.Copy(file, target, true);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"module repository: failed to copy file '{file}' to '{target}': {ex.Message}");
                }
            }
        }

        private static bool ShouldSkip(string relative)
        {
            if (string.IsNullOrEmpty(relative))
                return false;

            string normalized = relative.Replace('\\', '/');
            if (normalized.StartsWith(".git", StringComparison.OrdinalIgnoreCase) || normalized.StartsWith(".github", StringComparison.OrdinalIgnoreCase))
                return true;

            string fileName = Path.GetFileName(normalized);
            if (string.Equals(fileName, ".gitignore", StringComparison.OrdinalIgnoreCase) || string.Equals(fileName, ".gitattributes", StringComparison.OrdinalIgnoreCase))
                return true;

            return false;
        }

        private static bool TryParseGitHubUrl(string url, out string owner, out string name)
        {
            owner = null;
            name = null;

            if (string.IsNullOrWhiteSpace(url))
                return false;

            string working = url.Trim();

            if (working.StartsWith("git@", StringComparison.OrdinalIgnoreCase))
            {
                int index = working.IndexOf(':');
                if (index != -1 && working.Length > index + 1)
                    working = working[(index + 1)..];
            }

            if (!working.StartsWith("http", StringComparison.OrdinalIgnoreCase) && working.Contains("github.com"))
                working = "https://" + working.TrimStart('/');

            if (Uri.TryCreate(working, UriKind.Absolute, out var uri) && uri.Host.EndsWith("github.com", StringComparison.OrdinalIgnoreCase))
            {
                var segments = uri.AbsolutePath.Trim('/').Split('/', StringSplitOptions.RemoveEmptyEntries);
                if (segments.Length >= 2)
                {
                    owner = segments[0];
                    name = segments[1];
                }
            }
            else
            {
                var parts = working.Trim('/').Split('/', StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length >= 2)
                {
                    owner = parts[^2];
                    name = parts[^1];
                }
            }

            if (!string.IsNullOrEmpty(name) && name.EndsWith(".git", StringComparison.OrdinalIgnoreCase))
                name = name[..^4];

            return !string.IsNullOrEmpty(owner) && !string.IsNullOrEmpty(name);
        }

        private sealed class RepositoryEntry
        {
            public string Url { get; set; }
            public string Branch { get; set; }
            public string Owner { get; set; }
            public string Name { get; set; }
            public string Token { get; set; }
            public string AcceptHeader { get; set; }
            public List<RepositoryFolder> Folders { get; set; } = new List<RepositoryFolder>();

            public bool IsValid => !string.IsNullOrEmpty(Url) && !string.IsNullOrEmpty(Owner) && !string.IsNullOrEmpty(Name) && Folders.Count > 0;

            public string StateKey => $"repo:{Url}|{Branch}";
        }

        private sealed class RepositoryFolder
        {
            public RepositoryFolder(string source, string target)
            {
                Source = Normalize(source);
                ModuleName = NormalizeTarget(target, Source);
            }

            public string Source { get; }

            public string ModuleName { get; }

            public bool IsValid => !string.IsNullOrEmpty(Source) && !string.IsNullOrEmpty(ModuleName);

            private static string Normalize(string value)
            {
                if (string.IsNullOrWhiteSpace(value))
                    return null;

                string trimmed = value.Trim().Replace('\\', '/').Trim('/');
                if (trimmed.Contains(".."))
                    return null;

                return trimmed;
            }

            private static string NormalizeTarget(string target, string source)
            {
                string normalized = Normalize(target);
                if (string.IsNullOrEmpty(normalized))
                    normalized = Normalize(source);

                if (string.IsNullOrEmpty(normalized))
                    return null;

                var segments = normalized.Split('/', StringSplitOptions.RemoveEmptyEntries);
                if (segments.Length == 0)
                    return null;

                return segments[^1].Replace('/', Path.DirectorySeparatorChar);
            }

            public string GetSourcePath(string root)
            {
                string path = root;
                foreach (string part in Source.Split('/', StringSplitOptions.RemoveEmptyEntries))
                    path = Path.Combine(path, part);

                return path;
            }
        }
    }
}
```

## File: Shared/Engine/SemaphorManager.cs
```
using System.Collections.Concurrent;
using System.Threading;

namespace Shared.Engine
{
    public class SemaphorManager
    {
        #region static
        private static readonly ConcurrentDictionary<string, SemaphoreEntry> _semaphoreLocks = new();
        private static readonly Timer _cleanupTimer = new(_ => Cleanup(), null, TimeSpan.FromMinutes(1), TimeSpan.FromSeconds(20));

        static void Cleanup()
        {
            var threshold = DateTime.UtcNow - TimeSpan.FromMinutes(2);

            foreach (var kvp in _semaphoreLocks.ToArray())
            {
                if (kvp.Value.LastUsed < threshold && _semaphoreLocks.TryRemove(kvp.Key, out var removed))
                    removed.Dispose();
            }
        }
        #endregion

        SemaphoreEntry semaphore { get; set; }
        TimeSpan timeSpan;


        public SemaphorManager(string key)
        {
            timeSpan = TimeSpan.FromSeconds(40);
            semaphore = _semaphoreLocks.GetOrAdd(key, _ => new SemaphoreEntry(new SemaphoreSlim(1, 1)));
        }

        public SemaphorManager(string key, TimeSpan timeSpan)
        {
            this.timeSpan = timeSpan;
            semaphore = _semaphoreLocks.GetOrAdd(key, _ => new SemaphoreEntry(new SemaphoreSlim(1, 1)));
        }


        public Task WaitAsync()
        {
            return semaphore.WaitAsync(timeSpan);
        }

        public Task WaitAsync(TimeSpan timeSpan)
        {
            return semaphore.WaitAsync(timeSpan);
        }

        public void Release()
        {
            try
            {
                semaphore.Release();
            }
            catch { }
        }


        async public Task Invoke(Action action)
        {
            try
            {
                await semaphore.WaitAsync(timeSpan);
                action();
            }
            finally
            {
                semaphore.Release();
            }
        }

        async public Task Invoke(Func<Task> func)
        {
            try
            {
                await semaphore.WaitAsync(timeSpan);
                await func();
            }
            finally
            {
                semaphore.Release();
            }
        }


        async public Task<T> Invoke<T>(Func<T> func)
        {
            try
            {
                await semaphore.WaitAsync(timeSpan);
                return func();
            }
            finally
            {
                semaphore.Release();
            }
        }

        async public Task<T> Invoke<T>(Func<Task<T>> func)
        {
            try
            {
                await semaphore.WaitAsync(timeSpan);
                return await func();
            }
            finally
            {
                semaphore.Release();
            }
        }


        #region SemaphoreEntry
        private sealed class SemaphoreEntry : IDisposable
        {
            private readonly SemaphoreSlim _semaphore;

            public SemaphoreEntry(SemaphoreSlim semaphore)
            {
                _semaphore = semaphore;
                Touch();
            }

            public DateTime LastUsed { get; private set; }

            public void Touch()
            {
                LastUsed = DateTime.UtcNow;
            }

            public Task WaitAsync(TimeSpan timeSpan)
            {
                Touch();
                return _semaphore.WaitAsync(timeSpan);
            }

            public void Release()
            {
                Touch();
                _semaphore.Release();
            }

            public void Dispose()
            {
                _semaphore.Dispose();
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/UnicTo.cs
```
Ôªøusing System.Text;

namespace Shared.Engine
{
    public static class UnicTo
    {
        static string ArrayList => "qwertyuioplkjhgfdsazxcvbnmQWERTYUIOPLKJHGFDSAZXCVBNM1234567890";
        static string ArrayListToNumber => "1234567890";

        public static string Code(int size = 8, bool IsNumberCode = false)
        {
            StringBuilder array = new StringBuilder();
            for (int i = 0; i < size; i++)
            {
                array.Append(ArrayList[Random.Shared.Next(0, 61)]);
            }

            return array.ToString();
        }

        public static string Number(int size = 8)
        {
            StringBuilder array = new StringBuilder();
            for (int i = 0; i < size; i++)
            {
                array.Append(ArrayListToNumber[Random.Shared.Next(0, 9)]);
            }

            return array.ToString();
        }
    }
}

```

## File: Shared/Engine/RchClient.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models;
using Shared.Models.Base;
using Shared.Models.Events;
using System.Collections.Concurrent;
using System.Text.RegularExpressions;
using System.Threading;

namespace Shared.Engine
{
    public class RchClientInfo
    {
        public int version { get; set; }
        public string host { get; set; }
        public string rchtype { get; set; }
        public int apkVersion { get; set; }
        public string player { get; set; }
        public string account_email { get; set; }
        public string unic_id { get; set; }
        public string profile_id { get; set; }
        public string token { get; set; }

        public object ob { get; set; }
        public Dictionary<string, object> obs { get; set; } = new Dictionary<string, object>();
    }

    public struct RchClient
    {
        #region static
        static RchClient()
        {
            _checkConnectionTimer = new Timer(CheckConnection, null, TimeSpan.FromMinutes(2), TimeSpan.FromMinutes(4));
        }

        static Timer _checkConnectionTimer;

        static bool _cronCheckConnectionWork = false;

        async static void CheckConnection(object state)
        {
            if (_cronCheckConnectionWork || clients.Count == 0)
                return;

            _cronCheckConnectionWork = true;

            try
            {
                await Parallel.ForEachAsync(clients.Keys.ToArray(), new ParallelOptions 
                { 
                    MaxDegreeOfParallelism = Math.Max(2, Environment.ProcessorCount) 
                }, 
                async (connectionId, cancellationToken) =>
                {
                    if (clients.TryGetValue(connectionId, out var client) && client.connection == null)
                    {
                        var rch = new RchClient(connectionId);
                        string result = await rch.SendHub("ping", useDefaultHeaders: false);
                        if (result != "pong")
                            OnDisconnected(connectionId);
                    }
                });
            }
            catch { }
            finally
            {
                _cronCheckConnectionWork = false;
            }
        }


        public static string ErrorMsg => AppInit.conf.rch.enable ? "rhub –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –¥–∞–Ω–Ω—ã–º –±–∞–ª–∞–Ω—Å–µ—Ä–æ–º" : "–í–∫–ª—é—á–∏—Ç–µ rch –≤ init.conf";

        public static EventHandler<(string connectionId, string rchId, string url, string data, Dictionary<string, string> headers, bool returnHeaders)> hub = null;

        public static readonly ConcurrentDictionary<string, (string ip, string host, RchClientInfo info, NwsConnection connection)> clients = new ConcurrentDictionary<string, (string, string, RchClientInfo, NwsConnection)>();

        public static readonly ConcurrentDictionary<string, TaskCompletionSource<string>> rchIds = new ConcurrentDictionary<string, TaskCompletionSource<string>>();


        public static void Registry(string ip, string connectionId, string host = null, string json = null, NwsConnection connection = null)
        {
            var info = new RchClientInfo();

            if (json != null)
            {
                try
                {
                    info = System.Text.Json.JsonSerializer.Deserialize<RchClientInfo>(json);
                }
                catch { }
            }

            if (AppInit.conf.rch.blacklistHost != null && info.host != null)
            {
                foreach (string h in AppInit.conf.rch.blacklistHost)
                {
                    if (info.host.Contains(h))
                        return;
                }
            }

            if (info == null)
                info = new RchClientInfo() { version = -1 };

            clients.AddOrUpdate(connectionId, (ip, host, info, connection), (i, j) => (ip, host, info, connection));
            InvkEvent.RchRegistry(new EventRchRegistry(connectionId, ip, host, info, connection));
        }


        public static void OnDisconnected(string connectionId)
        {
            if (clients.TryRemove(connectionId, out _))
                InvkEvent.RchDisconnected(new EventRchDisconnected(connectionId));
        }
        #endregion

        BaseSettings init;

        HttpContext httpContext;

        string ip, connectionId;

        bool enableRhub, rhub_fallback;

        public bool enable => init.rhub && enableRhub;

        public string connectionMsg { get; private set; }

        public string ipkey(string key, ProxyManager? proxy) => $"{key}:{(enableRhub ? ip : proxy?.CurrentProxyIp)}";

        public RchClient(string connectionId) 
        {
            this.connectionId = connectionId;
        }

        public RchClient(HttpContext context, string host, BaseSettings init, in RequestModel requestInfo, int? keepalive = null)
        {
            this.init = init;
            httpContext = context;
            enableRhub = init.rhub;
            rhub_fallback = init.rhub_fallback;
            ip = requestInfo.IP;

            if (enableRhub && rhub_fallback && init.rhub_geo_disable != null)
            {
                if (requestInfo.Country != null && init.rhub_geo_disable.Contains(requestInfo.Country))
                {
                    enableRhub = false;
                    init.rhub = false;
                }
            }

            connectionMsg = System.Text.Json.JsonSerializer.Serialize(new
            {
                rch = true,
                ws = $"{host}/ws",
                nws = $"{(host.StartsWith("https") ? "wss" : "ws")}://{Regex.Replace(host, "^https?://", "")}/nws"
            });
        }


        public void Disabled()
        {
            enableRhub = false;
        }


        #region Eval
        public void EvalRun(string data)
        {
            _= SendHub("evalrun", data).ConfigureAwait(false);
        }

        async public Task<string> Eval(string data)
        {
            return await SendHub("eval", data).ConfigureAwait(false);
        }

        async public Task<T> Eval<T>(string data, bool IgnoreDeserializeObject = false)
        {
            try
            {
                string json = await SendHub("eval", data, useDefaultHeaders: false).ConfigureAwait(false);
                if (json == null)
                    return default;

                if (IgnoreDeserializeObject)
                    return JsonConvert.DeserializeObject<T>(json, new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } });

                return JsonConvert.DeserializeObject<T>(json);
            }
            catch
            {
                return default;
            }
        }
        #endregion

        #region Headers
        async public Task<(JObject headers, string currentUrl, string body)> Headers(string url, string data, List<HeadersModel> headers = null, bool useDefaultHeaders = true)
        {
            try
            {
                string json = await SendHub(url, data, headers, useDefaultHeaders, true).ConfigureAwait(false);
                if (json == null)
                    return default;

                var job = JsonConvert.DeserializeObject<JObject>(json);
                if (!job.ContainsKey("body"))
                    return default;

                return (job.Value<JObject>("headers"), job.Value<string>("currentUrl"), job.Value<string>("body"));
            }
            catch
            {
                return default;
            }
        }
        #endregion

        #region Get
        async public ValueTask<string> Get(string url, List<HeadersModel> headers = null, bool useDefaultHeaders = true)
        {
            return await SendHub(url, null, headers, useDefaultHeaders).ConfigureAwait(false);
        }

        async public ValueTask<T> Get<T>(string url, List<HeadersModel> headers = null, bool IgnoreDeserializeObject = false, bool useDefaultHeaders = true)
        {
            try
            {
                string html = await SendHub(url, null, headers, useDefaultHeaders).ConfigureAwait(false);
                if (html == null)
                    return default;

                if (IgnoreDeserializeObject)
                    return JsonConvert.DeserializeObject<T>(html, new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } });

                return JsonConvert.DeserializeObject<T>(html);
            }
            catch
            {
                return default;
            }
        }
        #endregion

        #region Post
        async public ValueTask<string> Post(string url, string data, List<HeadersModel> headers = null, bool useDefaultHeaders = true) 
        {
            return await SendHub(url, data, headers, useDefaultHeaders).ConfigureAwait(false);
        }

        async public ValueTask<T> Post<T>(string url, string data, List<HeadersModel> headers = null, bool IgnoreDeserializeObject = false, bool useDefaultHeaders = true)
        {
            try
            {
                string json = await SendHub(url, data, headers, useDefaultHeaders).ConfigureAwait(false);
                if (json == null)
                    return default;

                if (IgnoreDeserializeObject)
                    return JsonConvert.DeserializeObject<T>(json, new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } });

                return JsonConvert.DeserializeObject<T>(json);
            }
            catch
            {
                return default;
            }
        }
        #endregion

        #region SendHub
        async Task<string> SendHub(string url, string data = null, List<HeadersModel> headers = null, bool useDefaultHeaders = true, bool returnHeaders = false, bool waiting = true)
        {
            if (hub == null)
                return null;

            if (string.IsNullOrEmpty(connectionId) || !clients.ContainsKey(connectionId))
                connectionId = SocketClient().connectionId;

            if (string.IsNullOrEmpty(connectionId))
                return null;

            string rchId = Guid.NewGuid().ToString();

            try
            {
                var tcs = new TaskCompletionSource<string>();
                rchIds.TryAdd(rchId, tcs);

                var send_headers = !useDefaultHeaders ? null : new Dictionary<string, string>(Http.defaultHeaders)
                {
                    { "Accept-Language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5" }
                };

                if (headers != null)
                {
                    if (send_headers == null)
                        send_headers = new Dictionary<string, string>();

                    foreach (var h in headers)
                    {
                        if (!send_headers.ContainsKey(h.name))
                            send_headers.TryAdd(h.name, h.val);
                    }
                }

                hub.Invoke(null, (connectionId, rchId, url, data, send_headers, returnHeaders));

                if (!waiting)
                    return null;

                string result = await tcs.Task.WaitAsync(TimeSpan.FromSeconds(rhub_fallback ? 8 : 12)).ConfigureAwait(false);
                rchIds.TryRemove(rchId, out _);

                if (string.IsNullOrWhiteSpace(result))
                    return null;

                return result;
            }
            catch
            {
                return null;
            }
            finally 
            {
                rchIds.TryRemove(rchId, out _);
            }
        }
        #endregion


        #region IsNotConnected
        public bool IsNotConnected() => IsNotConnected(ip);

        bool IsNotConnected(string ip)
        {
            if (!enableRhub)
                return false; // rch –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è

            if (httpContext != null && httpContext.Request.QueryString.Value.Contains("&checksearch=true"))
                return true; // –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è checksearch

            return SocketClient().connectionId == null;
        }
        #endregion

        #region IsRequiredConnected
        public bool IsRequiredConnected()
        {
            if (!AppInit.conf.rch.requiredConnected)
                return false; // –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ

            if (httpContext != null)
            {
                var requestInfo = httpContext.Features.Get<RequestModel>();
                if (requestInfo.IsLocalRequest)
                    return false;
            }

            return SocketClient().connectionId == null;
        }
        #endregion

        #region IsNotSupport
        public bool IsNotSupport(string rch_deny, out string rch_msg)
        {
            rch_msg = null;

            if (!enableRhub)
                return false; // rch –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è

            if (httpContext != null && httpContext.Request.QueryString.Value.Contains("&checksearch=true"))
                return false; // –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è checksearch

            var info = InfoConnected();
            if (info == null || string.IsNullOrEmpty(info.rchtype))
                return false; // –∫–ª–∏–µ–Ω—Ç –Ω–µ –≤ —Å–µ—Ç–∏

            // —Ä–∞–∑—Ä–µ—à–µ–Ω –≤–æ–∑–≤—Ä–∞—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä
            if (rhub_fallback)
            {
                if (rch_deny.Contains(info.rchtype)) {
                    enableRhub = false;
                    init.rhub = false;
                }
                return false;
            }

            if (AppInit.conf.rch.notSupportMsg != null)
                rch_msg = AppInit.conf.rch.notSupportMsg;
            else if (info.rchtype == "web")
                rch_msg = "–ù–∞ MSX –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ";
            else
                rch_msg = "–¢–æ–ª—å–∫–æ –Ω–∞ android";

            return rch_deny.Contains(info.rchtype);
        }
        #endregion

        #region InfoConnected
        public RchClientInfo InfoConnected()
        {
            return SocketClient().data.rch_info;
        }
        #endregion

        #region SocketClient
        public (string connectionId, (string ip, string host, RchClientInfo rch_info, NwsConnection connection) data) SocketClient()
        {
            string _ip = ip;

            if (AppInit.conf.rch.websoket == "nws")
            {
                if (!string.IsNullOrEmpty(connectionId) && clients.ContainsKey(connectionId))
                    return (connectionId, clients[connectionId]);

                if (httpContext == null)
                    return default;

                if (httpContext.Request.Query.ContainsKey("nws_id"))
                {
                    string nws_id = httpContext.Request.Query["nws_id"].ToString()?.ToLower()?.Trim();
                    if (!string.IsNullOrEmpty(nws_id) && clients.ContainsKey(nws_id))
                        return (nws_id, clients[nws_id]);
                }
            }
            else
            {
                var client = clients.LastOrDefault(i => i.Value.ip == _ip);
                if (client.Value.info?.rchtype != null)
                    return (client.Key, client.Value);
            }

            return default;
        }
        #endregion
    }
}

```

## File: Shared/Engine/ProxyManager.cs
```
Ôªøusing Microsoft.Extensions.Caching.Memory;
using Shared.Models.Base;
using Shared.Models.Proxy;
using System.Collections.Concurrent;
using System.Net;
using System.Text.RegularExpressions;
using System.Threading;

namespace Shared.Engine
{
    public class ProxyManager
    {
        #region static
        static IMemoryCache memoryCache;
        static ConcurrentDictionary<string, ProxyManagerModel> database = new ConcurrentDictionary<string, ProxyManagerModel>();

        public static void Configure(IMemoryCache mem)
        {
            memoryCache = mem;
        }
        #endregion

        #region ProxyManager
        string plugin;
        bool refresh;
        Iproxy conf;

        public string[] proxyKeys;

        public ProxyManager(string plugin, Iproxy conf, bool refresh = true)
        {
            this.plugin = plugin;
            this.conf = conf;
            this.refresh = refresh;
            proxyKeys = [plugin, $"{plugin}:conf", $"{plugin}:globalname"];
        }

        public ProxyManager(BaseSettings conf, bool refresh = true)
        {
            plugin = !string.IsNullOrEmpty(conf.plugin) ? conf.plugin : conf.host ?? conf.apihost;
            this.conf = conf;
            this.refresh = refresh;
            proxyKeys = [plugin, $"{plugin}:conf", $"{plugin}:globalname"];
        }
        #endregion

        #region Get / BaseGet
        public WebProxy Get() => BaseGet().proxy;

        public (WebProxy proxy, (string ip, string username, string password) data) BaseGet()
        {
            if (!conf.useproxy && !conf.useproxystream)
                return default;

            (WebProxy proxy, (string ip, string username, string password) data) proxy(ProxySettings p_orig, string key)
            {
                ProxySettings p = ConfigureProxy(p_orig);

                if (p?.list == null || p.list.Length == 0)
                    return default;

                if (!database.TryGetValue(key, out ProxyManagerModel val) || val.proxyip == null || !p.list.Contains(val.proxyip))
                {
                    val = new ProxyManagerModel();

                    if (p.actions != null && p.actions.Count > 0)
                    {
                        val.proxyip = p.list.First();
                        start_action(p, key, val.proxyip);
                    }
                    else
                    {
                        val.proxyip = p.list.OrderBy(a => Guid.NewGuid()).First();
                        database.AddOrUpdate(key, val, (k, v) => val);
                    }
                }

                return ConfigureWebProxy(p, val.proxyip);
            }


            if (conf.proxy?.list != null && conf.proxy.list.Length > 0 || !string.IsNullOrEmpty(conf.proxy?.file) || !string.IsNullOrEmpty(conf.proxy?.url))
            {
                return proxy(conf.proxy, $"{plugin}:conf");
            }
            else
            {
                if (!string.IsNullOrEmpty(conf.globalnameproxy))
                {
                    string _globalnameproxy = conf.globalnameproxy;
                    return proxy(AppInit.conf.globalproxy.FirstOrDefault(i => i.name == _globalnameproxy), $"{plugin}:globalname");
                }
                else
                {
                    return proxy(AppInit.conf.proxy, $"{plugin}:conf");
                }
            }
        }
        #endregion

        #region Refresh
        public void Refresh()
        {
            if (!refresh)
                return;

            void update(ProxySettings p, string key)
            {
                if (database.TryGetValue(key, out ProxyManagerModel val))
                {
                    int maxRequestError = 2;
                    if (p?.maxRequestError > 0)
                        maxRequestError = p.maxRequestError;

                    if (val.errors >= maxRequestError)
                    {
                        if (!string.IsNullOrEmpty(p?.refresh_uri))
                            _ = Http.Get(p.refresh_uri, timeoutSeconds: 5).ConfigureAwait(false);

                        if (p?.actions != null && p.actions.Count > 0)
                        {
                            val.errors = 0;
                            start_action(ConfigureProxy(p), key);
                            return;
                        }

                        val.errors = 0;
                        val.proxyip = null;
                        database.TryRemove(key, out _);
                    }
                    else
                    {
                        val.errors += 1;
                    }
                }
            }

            update(AppInit.conf.proxy, plugin);

            if (conf == null)
                return;

            update(conf.proxy, $"{plugin}:conf");
            string _globalnameproxy = conf.globalnameproxy;
            update(AppInit.conf.globalproxy.FirstOrDefault(i => i.name == _globalnameproxy), $"{plugin}:globalname");
        }
        #endregion

        #region Success
        public void Success()
        {
            foreach (string key in proxyKeys)
            {
                if (database.TryGetValue(key, out var val) && val.errors > 0)
                    val.errors = 0;
            }
        }
        #endregion

        #region CurrentProxyIp
        public string CurrentProxyIp
        {
            get
            {
                foreach (string key in proxyKeys)
                {
                    if (database.TryGetValue(key, out var val))
                        return val.proxyip;
                }

                return null;
            }
        }
        #endregion



        ProxySettings ConfigureProxy(ProxySettings orig)
        {
            if (orig == null)
                return null;

            ProxySettings p = (ProxySettings)orig.Clone();

            if (!string.IsNullOrEmpty(p.file) && File.Exists(p.file))
                p.list = File.ReadAllLines(p.file);

            if (!string.IsNullOrEmpty(p.url))
            {
                string mkey = $"ProxyManager:{p.url}";
                if (!memoryCache.TryGetValue(mkey, out List<string> list))
                {
                    list = new List<string>();

                    string txt = Http.Get(p.url, timeoutSeconds: 5).Result;
                    if (txt != null)
                    {
                        foreach (string line in txt.Split("\n"))
                        {
                            if (line.Contains(":"))
                                list.Add(line.Trim());
                        }
                    }

                    memoryCache.Set(mkey, list, DateTime.Now.AddMinutes(15));
                }

                p.list = list.ToArray();
            }

            return p;
        }


        public static (WebProxy proxy, (string ip, string username, string password) data) ConfigureWebProxy(ProxySettings p, string proxyip)
        {
            NetworkCredential credentials = null;

            if (proxyip.Contains("@"))
            {
                var g = Regex.Match(proxyip, p.pattern_auth).Groups;
                proxyip = g["sheme"].Value + g["host"].Value;
                credentials = new NetworkCredential(g["username"].Value, g["password"].Value);
            }
            else if (p.useAuth)
                credentials = new NetworkCredential(p.username, p.password);

            var proxy = new WebProxy(proxyip, p.BypassOnLocal, null, credentials);
            return (proxy, (proxyip, credentials?.UserName, credentials?.Password));
        }


        void start_action(ProxySettings p, string key, string current_proxyip = null)
        {
            if (p == null)
                return;

            string mkey = $"ProxyManager:start_action:{key}";
            if (memoryCache.TryGetValue(mkey, out _))
                return;

            memoryCache.Set(mkey, 0, DateTime.Now.AddMinutes(10));

            ThreadPool.QueueUserWorkItem(async _ =>
            {
                try
                {
                    string proxyip = null;
                    var list = p.list.OrderBy(a => Guid.NewGuid()).ToList();

                    if (!string.IsNullOrEmpty(current_proxyip))
                    {
                        if (list.Contains(current_proxyip))
                        {
                            list.Remove(current_proxyip);
                            list.Insert(0, current_proxyip);
                        }
                    }

                    foreach (string proxy in list.Take(p.actions_attempts))
                    {
                        bool isok = true;
                        proxyip = proxy;

                        foreach (var action in p.actions)
                        {
                            string result = string.Empty;

                            if (!string.IsNullOrEmpty(action.data))
                                result = await Http.Post(action.url, action.data, httpversion: 2, timeoutSeconds: action.timeoutSeconds, proxy: ConfigureWebProxy(p, proxy).proxy);
                            else
                                result = await Http.Get(action.url, httpversion: 2, timeoutSeconds: action.timeoutSeconds, proxy: ConfigureWebProxy(p, proxy).proxy);

                            if (result == null || !result.Contains(action.contains))
                            {
                                isok = false;
                                break;
                            }
                        }

                        if (isok)
                            break;
                    }

                    var val = new ProxyManagerModel();
                    val.proxyip = proxyip;
                    database.AddOrUpdate(key, val, (k, v) => val);
                }
                catch { }
                finally
                {
                    memoryCache.Remove(mkey);
                }
            });
        }
    }
}

```

## File: Shared/Engine/FrendlyHttp.cs
```
Ôªøusing System.Collections.Concurrent;
using System.Net;
using System.Net.Http;
using System.Threading;

namespace Shared.Engine
{
    public static class FrendlyHttp
    {
        #region static
        static ConcurrentDictionary<string, (DateTime lifetime, HttpClient http)> _clients = new ConcurrentDictionary<string, (DateTime, HttpClient)>();

        static FrendlyHttp()
        {
            ThreadPool.QueueUserWorkItem(async _ => 
            {
                while (true)
                {
                    await Task.Delay(TimeSpan.FromMinutes(1));

                    try
                    {
                        foreach (var c in _clients.Where(c => DateTime.UtcNow > c.Value.lifetime).ToArray())
                        {
                            try
                            {
                                if (_clients.TryRemove(c.Key, out var _c))
                                {
                                    await Task.Delay(TimeSpan.FromSeconds(20));
                                    _c.http.Dispose();
                                }
                            }
                            catch { }
                        }
                    }
                    catch { }
                }
            });
        }
        #endregion

        #region HttpMessageClient
        public static HttpClient HttpMessageClient
        (
            string factoryClient,
            HttpClientHandler handler,
            long MaxResponseContentBufferSize = -1
        )
        {
            // 10MB
            long maxBufferSize = 10_000_000;
            if (MaxResponseContentBufferSize > 0)
                maxBufferSize = MaxResponseContentBufferSize;

            if ((handler != null && handler.CookieContainer.Count > 0) || Http.httpClientFactory == null)
            {
                var client = new HttpClient(handler);
                client.MaxResponseContentBufferSize = maxBufferSize;
                return client;
            }

            var webProxy = handler?.Proxy != null ? handler.Proxy as WebProxy : null;

            if (webProxy == null)
            {
                if (handler != null && handler.AllowAutoRedirect == false)
                {
                    if (factoryClient is "base" or "http2")
                        factoryClient += "NoRedirect";
                }

                var factory = Http.httpClientFactory.CreateClient(factoryClient);

                if (maxBufferSize > factory.MaxResponseContentBufferSize)
                    factory.MaxResponseContentBufferSize = maxBufferSize;

                return factory;
            }

            int port = 0;
            string ip = null, username = null, password = null;

            ip = webProxy.Address?.Host;
            port = webProxy.Address?.Port ?? 0;

            if (webProxy.Credentials is NetworkCredential credentials)
            {
                username = credentials.UserName;
                password = credentials.Password;
            }

            return _clients.GetOrAdd($"{ip}:{port}:{username}:{password}:{MaxResponseContentBufferSize}:{handler?.AllowAutoRedirect}", k => 
            {
                var client = new HttpClient(handler);
                client.MaxResponseContentBufferSize = maxBufferSize;

                return (DateTime.UtcNow.AddMinutes(30), client);

            }).http;
        }
        #endregion
    }
}

```

## File: Shared/Engine/HtmlParse.cs
```
Ôªøusing HtmlAgilityPack;
using System.Text.RegularExpressions;

namespace Shared.Engine
{
    public class HtmlParse
    {
        public List<HtmlRowParse> nodes { get; private set; } = new List<HtmlRowParse>();

        public HtmlParse(string html, string xpathNodes) 
        {
            var doc = new HtmlDocument();
            doc.LoadHtml(html);

            var _nodes = doc.DocumentNode?.SelectNodes(xpathNodes);
            if (_nodes == null)
                return;

            foreach (var node in _nodes)
                nodes.Add(new HtmlRowParse(node));
        }

        public static List<HtmlRowParse> Nodes(string html, string xpathNodes)
        {
            return new HtmlParse(html, xpathNodes).nodes;
        }
    }


    public class HtmlRowParse
    {
        public HtmlNode row { get; private set; }

        public HtmlRowParse(HtmlNode node)
        {
            row = node;
        }

        #region SelectText
        public string SelectText(string xpath, string attribute = null, string[] attributes = null)
        {
            string value = null;

            if (string.IsNullOrEmpty(xpath) && (!string.IsNullOrEmpty(attribute) || attributes != null))
            {
                if (attributes != null)
                {
                    foreach (var attr in attributes)
                    {
                        string attrValue = row.GetAttributeValue(attr, null);
                        if (!string.IsNullOrWhiteSpace(attrValue))
                        {
                            value = attrValue;
                            break;
                        }
                    }
                }
                else
                {
                    value = row.GetAttributeValue(attribute, null);
                }
            }
            else
            {
                var inNode = row.SelectSingleNode(xpath);
                if (inNode != null)
                {
                    if (attributes != null)
                    {
                        foreach (var attr in attributes)
                        {
                            string attrValue = inNode.GetAttributeValue(attr, null);
                            if (!string.IsNullOrWhiteSpace(attrValue))
                            {
                                value = attrValue;
                                break;
                            }
                        }
                    }
                    else
                    {
                        value = (!string.IsNullOrEmpty(attribute) ? inNode.GetAttributeValue(attribute, null) : inNode.InnerText);
                    }
                }
            }

            if (string.IsNullOrWhiteSpace(value))
                return null;

            return value?.Trim();
        }
        #endregion

        #region SelectHtml
        public string SelectHtml(string xpath)
        {
            var inNode = row.SelectSingleNode(xpath);
            if (inNode != null)
            {
                string html = inNode.InnerHtml;
                if (string.IsNullOrWhiteSpace(html))
                    return null;

                return inNode.InnerHtml;
            }

            return null;
        }
        #endregion

        #region Regex
        public string Regex(string xpath, string pattern, int index = 1, RegexOptions options = RegexOptions.IgnoreCase)
        {
            string html = SelectHtml(pattern);
            if (string.IsNullOrWhiteSpace(html))
                return null;

            string res = System.Text.RegularExpressions.Regex.Match(html, pattern, options).Groups[index].Value;
            if (string.IsNullOrWhiteSpace(res))
                return null;

            return res.Trim();
        }

        public string Regex(string xpath, string pattern, string groupName, RegexOptions options = RegexOptions.IgnoreCase)
        {
            string html = SelectHtml(pattern);
            if (string.IsNullOrWhiteSpace(html))
                return null;

            string res = System.Text.RegularExpressions.Regex.Match(html, pattern, options).Groups[groupName].Value;
            if (string.IsNullOrWhiteSpace(res))
                return null;

            return res.Trim();
        }


        public string Regex(string pattern, int index = 1, RegexOptions options = RegexOptions.IgnoreCase)
        {
            string res = System.Text.RegularExpressions.Regex.Match(row.InnerHtml, pattern, options).Groups[index].Value;
            if (string.IsNullOrWhiteSpace(res))
                return null;

            return res.Trim();
        }

        public string Regex(string pattern, string groupName, RegexOptions options = RegexOptions.IgnoreCase)
        {
            string res = System.Text.RegularExpressions.Regex.Match(row.InnerHtml, pattern, options).Groups[groupName].Value;
            if (string.IsNullOrWhiteSpace(res))
                return null;

            return res.Trim();
        }
        #endregion
    }
}

```

## File: Shared/Engine/CSharpEval.cs
```
Ôªøusing Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;
using Microsoft.CodeAnalysis.Scripting.Hosting;
using Microsoft.Extensions.DependencyModel;
using Shared.Models.Module;
using System.Collections.Concurrent;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine
{
    public static class CSharpEval
    {
        static ConcurrentDictionary<string, dynamic> scripts = new ConcurrentDictionary<string, dynamic>();

        public static PortableExecutableReference ReferenceFromFile(string dll)
        {
            if (File.Exists(dll))
                return MetadataReference.CreateFromFile(Path.Combine(AppContext.BaseDirectory, dll));

            return MetadataReference.CreateFromFile(Path.Combine(AppContext.BaseDirectory, "runtimes", "references", dll));
        }


        #region Execute<T>
        public static T Execute<T>(in string cs, object model, ScriptOptions options = null)
        {
            return ExecuteAsync<T>(cs, model, options).GetAwaiter().GetResult();
        }

        public static Task<T> ExecuteAsync<T>(string cs, object model, ScriptOptions options = null)
        {
            var entry = scripts.GetOrAdd(CrypTo.md5(cs), _ =>
            {
                if (options == null)
                    options = ScriptOptions.Default;

                options = options.AddReferences(typeof(Console).Assembly).AddImports("System")
                                 .AddReferences(typeof(HttpUtility).Assembly).AddImports("System.Web")
                                 .AddReferences(typeof(Enumerable).Assembly).AddImports("System.Linq")
                                 .AddReferences(typeof(List<>).Assembly).AddImports("System.Collections.Generic")
                                 .AddReferences(typeof(Regex).Assembly).AddImports("System.Text.RegularExpressions");

                return CSharpScript.Create<T>(
                    cs,
                    options,
                    globalsType: model.GetType(),
                    assemblyLoader: new InteractiveAssemblyLoader()
                ).CreateDelegate();
            });

            return entry(model);
        }
        #endregion

        #region BaseExecute<T>
        public static T BaseExecute<T>(in string cs, object model, ScriptOptions options = null, InteractiveAssemblyLoader loader = null)
        {
            return BaseExecuteAsync<T>(cs, model, options, loader).GetAwaiter().GetResult();
        }

        public static Task<T> BaseExecuteAsync<T>(string cs, object model, ScriptOptions options = null, InteractiveAssemblyLoader loader = null)
        {
            var entry = scripts.GetOrAdd(CrypTo.md5(cs), _ =>
            {
                return CSharpScript.Create<T>(
                    cs,
                    options,
                    globalsType: model.GetType(),
                    assemblyLoader: loader
                ).CreateDelegate();
            });

            return entry(model);
        }
        #endregion

        #region Execute
        public static void Execute(in string cs, object model, ScriptOptions options = null)
        {
            ExecuteAsync(cs, model, options).GetAwaiter().GetResult();
        }

        public static Task ExecuteAsync(string cs, object model, ScriptOptions options = null)
        {
            var entry = scripts.GetOrAdd(CrypTo.md5(cs), _ =>
            {
                if (options == null)
                    options = ScriptOptions.Default;

                options = options.AddReferences(typeof(Console).Assembly).AddImports("System")
                                 .AddReferences(typeof(HttpUtility).Assembly).AddImports("System.Web")
                                 .AddReferences(typeof(Enumerable).Assembly).AddImports("System.Linq")
                                 .AddReferences(typeof(List<>).Assembly).AddImports("System.Collections.Generic")
                                 .AddReferences(typeof(Regex).Assembly).AddImports("System.Text.RegularExpressions");

                return CSharpScript.Create(
                    cs,
                    options,
                    globalsType: model.GetType(),
                    assemblyLoader: new InteractiveAssemblyLoader()
                ).CreateDelegate();
            });

            return entry(model);
        }
        #endregion


        #region Compilation
        public static List<PortableExecutableReference> appReferences;
        static readonly object lockCompilationObj = new();

        public static Assembly Compilation(RootModule mod)
        {
            string path = $"{Environment.CurrentDirectory}/module/{mod.dll}";
            if (Directory.Exists(path))
            {
                lock (lockCompilationObj)
                {
                    var syntaxTree = new List<SyntaxTree>();

                    foreach (string file in Directory.GetFiles(path, "*.cs", SearchOption.AllDirectories))
                    {
                        string _file = file.Replace("\\", "/").Replace(path.Replace("\\", "/"), "").Replace(Environment.CurrentDirectory.Replace("\\", "/"), "");
                        if (Regex.IsMatch(_file, "(\\.vs|bin|obj|Properties)/", RegexOptions.IgnoreCase))
                            continue;

                        syntaxTree.Add(CSharpSyntaxTree.ParseText(File.ReadAllText(file)));
                    }

                    if (appReferences == null)
                    {
                        var dependencyContext = DependencyContext.Default;
                        var assemblies = dependencyContext.RuntimeLibraries
                            .SelectMany(library => library.GetDefaultAssemblyNames(dependencyContext))
                            .Select(Assembly.Load)
                            .ToList();

                        appReferences = assemblies.Select(assembly => MetadataReference.CreateFromFile(assembly.Location)).ToList();
                    }

                    if (mod.references != null)
                    {
                        foreach (string refns in mod.references)
                        {
                            string dlrns = Path.Combine(Environment.CurrentDirectory, "module", mod.dll, refns);
                            if (File.Exists(dlrns) && appReferences.FirstOrDefault(a => Path.GetFileName(a.FilePath) == refns) == null)
                            {
                                var assembly = Assembly.LoadFrom(dlrns);
                                appReferences.Add(MetadataReference.CreateFromFile(assembly.Location));
                            }
                        }
                    }

                    CSharpCompilation compilation = CSharpCompilation.Create(Path.GetFileName(mod.dll), syntaxTree, references: appReferences, options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

                    using (var ms = new MemoryStream())
                    {
                        var result = compilation.Emit(ms);

                        if (result.Success)
                        {
                            ms.Seek(0, SeekOrigin.Begin);
                            return Assembly.Load(ms.ToArray());
                        }
                        else
                        {
                            Console.WriteLine($"\ncompilation error: {mod.dll}");
                            foreach (var diagnostic in result.Diagnostics)
                            {
                                if (diagnostic.Severity == DiagnosticSeverity.Error)
                                    Console.WriteLine(diagnostic);
                            }
                            Console.WriteLine("\n");
                        }
                    }
                }
            }

            return null;
        }
        #endregion
    }
}

```

## File: Shared/Engine/StringConvert.cs
```
Ôªøusing System.Text.RegularExpressions;

namespace Shared.Engine
{
    public static class StringConvert
    {
        #region FindStartText
        public static string FindStartText(in string data, string end, string start = null)
        {
            try
            {
                int endtIndex = data.IndexOf(end);
                if (endtIndex == -1)
                    return null;

                return data.AsSpan(0, endtIndex).ToString();
            }
            catch
            {
                return null;
            }
        }
        #endregion

        #region FindLastText
        public static string FindLastText(in string data, string start, string end = null)
        {
            try
            {
                int startIndex = data.IndexOf(start);
                if (startIndex == -1)
                    return null;

                var resSpan = data.AsSpan(startIndex);
                string res = resSpan.ToString();

                if (end == null)
                    return res;

                return FindStartText(res, end);
            }
            catch 
            {
                return null;
            }
        }
        #endregion

        #region Remove
        public static string Remove(string data, string start, string end)
        {
            try
            {
                for (int i = 0; i < 10; i++)
                {
                    int startIndex = data.IndexOf(start);
                    if (startIndex == 0)
                        break;


                    int endIndex = data.IndexOf(end);
                    if (endIndex == 0) {
                        data = data.Remove(startIndex);
                        break;
                    }
                    
                    data = data.Remove(startIndex, (endIndex - startIndex));
                }

                return data;
            }
            catch
            {
                return data;
            }
        }
        #endregion


        #region SearchName
        public static string SearchName(string val, string empty = null)
        {
            if (string.IsNullOrWhiteSpace(val))
                return empty;

            string result = Regex.Replace(val.ToLower(), "[^a-zA-Z–∞-—è–ê-–Ø0-9–Å—ë]+", "").Replace("—ë", "–µ").Replace("—â", "—à");
            if (string.IsNullOrWhiteSpace(result))
                return empty;

            return result;
        }
        #endregion
    }
}

```

## File: Shared/Engine/BrotliTo.cs
```
Ôªøusing System.IO.Compression;
using System.Text;

namespace Shared.Engine
{
    public static class BrotliTo
    {
        static readonly object lockObj = new object();


        public static byte[] Compress(string value)
        {
            return Compress(Encoding.UTF8.GetBytes(value));
        }

        public static byte[] Compress(in byte[] value)
        {
            try
            {
                using (var input = new MemoryStream(value))
                {
                    using (var output = new MemoryStream())
                    {
                        try
                        {
                            using (var stream = new BrotliStream(output, CompressionLevel.Fastest))
                                input.CopyTo(stream);

                            return output.ToArray();
                        }
                        catch { return null; }
                    }
                }
            }
            catch { return null; }
        }

        public static void Compress(string outfile, in string value)
        {
            try
            {
                Compress(outfile, Encoding.UTF8.GetBytes(value));
            }
            catch { }
        }

        public static void Compress(string outfile, in byte[] value)
        {
            try
            {
                lock (lockObj)
                {
                    using (var input = new MemoryStream(value))
                    {
                        using (var output = new FileStream(outfile, FileMode.Create, FileAccess.Write, FileShare.None))
                        {
                            try
                            {
                                using (var stream = new BrotliStream(output, CompressionLevel.Fastest))
                                    input.CopyTo(stream);
                            }
                            catch { }
                        }
                    }
                }
            }
            catch { }
        }


        public static string Decompress(byte[] value)
        {
            try
            {
                using (var input = new MemoryStream(value))
                {
                    using (var output = new MemoryStream())
                    {
                        try
                        {
                            using (var stream = new BrotliStream(input, CompressionMode.Decompress))
                                stream.CopyTo(output);

                            return Encoding.UTF8.GetString(output.ToArray());
                        }
                        catch { return null; }
                    }
                }
            }
            catch { return null; }
        }

        public static string Decompress(string infile)
        {
            try
            {
                byte[] array = DecompressArray(infile);
                if (array == null)
                    return null;

                return Encoding.UTF8.GetString(array);
            }
            catch { return null; }
        }

        public static byte[] DecompressArray(string infile)
        {
            try
            {
                using (var input = new FileStream(infile, FileMode.Open, FileAccess.Read))
                {
                    using (var output = new MemoryStream())
                    {
                        try
                        {
                            using (var stream = new BrotliStream(input, CompressionMode.Decompress))
                                stream.CopyTo(output);

                            return output.ToArray();
                        }
                        catch { return null; }
                    }
                }
            }
            catch { return null; }
        }
    }
}

```

## File: Shared/Engine/HtmlCommon.cs
```
Ôªøusing HtmlAgilityPack;
using System.Text.RegularExpressions;

namespace Shared.Engine
{
    public class HtmlCommon
    {
        HtmlNode row;

        public HtmlCommon(HtmlNode row)
        {
            this.row = row;
        }


        public string NodeValue(in string node, string attribute = null, string removeChild = null)
        {
            if (string.IsNullOrEmpty(node) && !string.IsNullOrEmpty(attribute))
            {
                return row.GetAttributeValue(attribute, null);
            }
            else
            {
                var inNode = row.SelectSingleNode(node);
                if (inNode != null)
                {
                    if (removeChild != null)
                        inNode.RemoveChild(inNode.SelectSingleNode(removeChild));

                    return (!string.IsNullOrEmpty(attribute) ? inNode.GetAttributeValue(attribute, null) : inNode.InnerText)?.Trim();
                }
            }

            return null;
        }


        public string Match(string pattern, int index = 1)
        {
            return new Regex(pattern, RegexOptions.IgnoreCase).Match(row.InnerHtml).Groups[index].Value.Trim();
        }


        public static int Integer(string value)
        {
            if (string.IsNullOrEmpty(value))
                return 0;

            if (int.TryParse(Regex.Replace(value, "[^0-9]+", ""), out int result))
                return result;

            return 0;
        }
    }
}

```

## File: Shared/Engine/GeoIP2.cs
```
Ôªøusing MaxMind.GeoIP2;

namespace Shared.Engine
{
    public class GeoIP2
    {
        static DatabaseReader cityReader = null;

        static GeoIP2()
        {
            if (File.Exists("data/GeoLite2-Country.mmdb"))
                cityReader = new DatabaseReader("data/GeoLite2-Country.mmdb");
        }

        /// <param name="IP">IP –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</param>
        /// <returns>–°—Ç—Ä–∞–Ω–∞ UA,RU,BY,KZ</returns>
        public static string Country(string IP)
        {
            if (string.IsNullOrEmpty(IP) || cityReader == null)
                return null;

            try
            {
                return cityReader.Country(IP).Country.IsoCode.ToUpper();
            }
            catch { return null; }
        }
    }
}

```

## File: Shared/Engine/FFprobe.cs
```
Ôªøusing System.Diagnostics;

namespace Shared.Engine
{
    public static class FFprobe
    {
        #region InitializationAsync
        public static Task<bool> InitializationAsync()
        {
            return FFmpeg.InitializationAsync();
        }
        #endregion

        #region RunAsync
        async public static ValueTask<(string outputData, string errorData)> RunAsync(string comand, string workingDirectory = null)
        {
            try
            {
                var process = new Process();
                process.StartInfo.UseShellExecute = false;
                process.StartInfo.RedirectStandardOutput = true;
                process.StartInfo.RedirectStandardError = true;
                process.StartInfo.FileName = AppInit.Win32NT ? "data/ffprobe.exe" : File.Exists("data/ffprobe") ? "data/ffprobe" : "ffprobe";
                process.StartInfo.Arguments = comand;
                process.StartInfo.WorkingDirectory = workingDirectory;
                process.Start();

                string outputData = string.Empty, errorData = string.Empty;

                process.OutputDataReceived += (sender, args) =>
                {
                    if (!string.IsNullOrEmpty(args.Data))
                        outputData += args.Data;
                };

                process.ErrorDataReceived += (sender, args) =>
                {
                    if (!string.IsNullOrEmpty(args.Data))
                        errorData += args.Data;
                };

                process.BeginOutputReadLine();
                process.BeginErrorReadLine();

                await process.WaitForExitAsync();

                return (outputData, errorData);
            }
            catch
            {
                return default;
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/TimeZoneTo.cs
```
Ôªønamespace Shared.Engine
{
    public static class TimeZoneTo
    {
        public static bool ByIds(string[] zones, out DateTime zoneTime)
        {
            zoneTime = DateTime.MinValue;

            foreach (var zone in zones)
            {
                if (ById(zone, out zoneTime))
                    return true;
            }

            return false;
        }

        public static bool ById(string zone, out DateTime zoneTime)
        {
            zoneTime = DateTime.MinValue;

            try
            {
                TimeZoneInfo tz = TimeZoneInfo.FindSystemTimeZoneById("Europe/Kiev");
                zoneTime = TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, tz);

                return true;
            }
            catch 
            {
                return false;
            }
        }
    }
}

```

## File: Shared/Engine/HybridCache.cs
```
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.SQL;
using System.Collections.Concurrent;
using System.Threading;

namespace Shared.Engine
{
    public struct HybridCache
    {
        #region HybridCache
        static IMemoryCache memoryCache;

        static Timer _clearTimer;

        static DateTime _nextClearDb = DateTime.Now.AddMinutes(20);

        static ConcurrentDictionary<string, (DateTime extend, HybridCacheSqlModel cache)> tempDb;

        public static void Configure(IMemoryCache mem)
        {
            memoryCache = mem;

            tempDb = new ConcurrentDictionary<string, (DateTime extend, HybridCacheSqlModel value)>();
            _clearTimer = new Timer(UpdateDB, null, TimeSpan.Zero, TimeSpan.FromSeconds(5));
        }

        static bool updatingDb = false;
        async static void UpdateDB(object state)
        {
            if (updatingDb || tempDb.Count == 0)
                return;

            try
            {
                updatingDb = true;

                using (var sqlDb = new HybridCacheContext())
                {
                    if (DateTime.Now > _nextClearDb)
                    {
                        _nextClearDb = DateTime.Now.AddMinutes(20);

                        var now = DateTime.Now;

                        await sqlDb.files
                            .Where(i => now > i.ex)
                            .ExecuteDeleteAsync();
                    }
                    else
                    {
                        var array = tempDb.ToArray().Where(t => t.Value.extend >= DateTime.Now);
                        if (array.Any())
                        {
                            var delete_ids = array.Select(k => k.Key).ToHashSet();
                            if (delete_ids.Count > 0)
                            {
                                await sqlDb.files
                                    .Where(x => delete_ids.Contains(x.Id))
                                    .ExecuteDeleteAsync();
                            }

                            var hash_ids = new HashSet<string>();

                            foreach (var t in array)
                            {
                                if (hash_ids.Add(t.Key))
                                {
                                    sqlDb.files.Add(new HybridCacheSqlModel()
                                    {
                                        Id = t.Key,
                                        ex = t.Value.cache.ex,
                                        value = t.Value.cache.value
                                    });
                                }
                            }

                            await sqlDb.SaveChangesAsync();

                            foreach (var t in array)
                                tempDb.TryRemove(t.Key, out _);
                        }
                    }
                }
            }
            catch (Exception ex) 
            { 
                Console.WriteLine("HybridCache: " + ex); 
            }
            finally
            {
                updatingDb = false;
            }
        }
        #endregion


        #region TryGetValue
        public bool TryGetValue(string key, out object value)
        {
            return memoryCache.TryGetValue(key, out value);
        }

        public bool TryGetValue<TItem>(string key, out TItem value, bool? inmemory = null)
        {
            if (!AppInit.conf.mikrotik && AppInit.conf.cache.type != "mem")
            {
                if (memoryCache.TryGetValue(key, out value))
                    return true;

                if (ReadCache(key, out value, out bool setmemory))
                {
                    if (setmemory && inmemory != false && AppInit.conf.cache.type == "hybrid" && AppInit.conf.cache.extend > 0)
                        memoryCache.Set(key, value, DateTime.Now.AddSeconds(AppInit.conf.cache.extend));

                    return true;
                }

                return false;
            }

            return memoryCache.TryGetValue(key, out value);
        }
        #endregion

        #region ReadCache
        private bool ReadCache<TItem>(string key, out TItem value, out bool setmemory)
        {
            value = default;
            setmemory = true;

            if (AppInit.conf.cache.type == "mem")
                return false;

            var type = typeof(TItem);
            bool isText = type == typeof(string);

            bool IsDeserialize = type.GetConstructor(Type.EmptyTypes) != null 
                || type.IsValueType 
                || type.IsArray
                || type == typeof(JToken)
                || type == typeof(JObject)
                || type == typeof(JArray);

            if (!isText && !IsDeserialize)
                return false;

            try
            {
                bool deserializeCache(HybridCacheSqlModel doc, out TItem result)
                {
                    result = default;

                    if (doc?.Id == null || DateTime.Now > doc.ex)
                        return false;

                    var eventResult = InvkEvent.HybridCache("read", key, doc.value, doc.ex);

                    if (IsDeserialize)
                        result = JsonConvert.DeserializeObject<TItem>(eventResult.value ?? doc.value);
                    else
                        result = (TItem)Convert.ChangeType(eventResult.value ?? doc.value, type);

                    return true;
                }

                string md5key = CrypTo.md5(key);

                tempDb.TryGetValue(md5key, out var _temp);

                if (_temp.cache != null)
                {
                    setmemory = false;
                    return deserializeCache(_temp.cache, out value);
                }
                else
                {
                    using (var sqlDb = new HybridCacheContext())
                    {
                        var doc = sqlDb.files.Find(md5key);
                        return deserializeCache(doc, out value);
                    }
                }
            }
            catch { }

            return false;
        }
        #endregion


        #region Set
        public TItem Set<TItem>(string key, TItem value, DateTimeOffset absoluteExpiration, bool? inmemory = null)
        {
            if (inmemory != true && !AppInit.conf.mikrotik && WriteCache(key, value, absoluteExpiration, default))
                return value;

            if (inmemory != true && !AppInit.conf.mikrotik)
                Console.WriteLine($"set memory: {key} / {DateTime.Now}");

            return memoryCache.Set(key, value, absoluteExpiration);
        }

        public TItem Set<TItem>(string key, TItem value, TimeSpan absoluteExpirationRelativeToNow, bool? inmemory = null)
        {
            if (inmemory != true && !AppInit.conf.mikrotik && WriteCache(key, value, default, absoluteExpirationRelativeToNow))
                return value;

            if (inmemory != true && !AppInit.conf.mikrotik)
                Console.WriteLine($"set memory: {key} / {DateTime.Now}");

            return memoryCache.Set(key, value, absoluteExpirationRelativeToNow);
        }
        #endregion

        #region WriteCache
        private bool WriteCache<TItem>(string key, TItem value, DateTimeOffset absoluteExpiration, TimeSpan absoluteExpirationRelativeToNow)
        {
            if (AppInit.conf.cache.type == "mem")
                return false;

            var type = typeof(TItem);
            bool isText = type == typeof(string);

            bool IsSerialize = type.GetConstructor(Type.EmptyTypes) != null
                || type.IsValueType
                || type.IsArray
                || type == typeof(JToken)
                || type == typeof(JObject)
                || type == typeof(JArray);

            if (!isText && !IsSerialize)
                return false;

            try
            {
                string result;

                if (IsSerialize)
                {
                    result = JsonConvert.SerializeObject(value);
                }
                else
                {
                    result = value.ToString();
                }

                if (absoluteExpiration == default)
                    absoluteExpiration = DateTimeOffset.Now.Add(absoluteExpirationRelativeToNow);

                var eventResult = InvkEvent.HybridCache("write", key, result, absoluteExpiration);
                if (eventResult != default)
                {
                    result = eventResult.value;
                    absoluteExpiration = eventResult.ex;
                }

                var extend = DateTime.Now.AddSeconds(Math.Max(5, AppInit.conf.cache.extend));

                tempDb.TryAdd(CrypTo.md5(key), (extend, new HybridCacheSqlModel()
                {
                    Id = CrypTo.md5(key),
                    ex = absoluteExpiration.DateTime,
                    value = result
                }));

                return true;
            }
            catch { }

            return false;
        }
        #endregion
    }
}

```

## File: Shared/Engine/JsonHelper.cs
```
using Newtonsoft.Json;
using System.Collections;
using System.IO.Compression;

namespace Shared.Engine
{
    public static class JsonHelper
    {
        #region ListReader
        public static List<T> ListReader<T>(string filePath, int capacity = 0)
        {
            var items = new List<T>(capacity);

            using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read))
            {
                using (var gzipStream = new GZipStream(fileStream, CompressionMode.Decompress))
                {
                    using (var reader = new StreamReader(gzipStream))
                    {
                        using (var jsonReader = new JsonTextReader(reader))
                        {
                            var serializer = new JsonSerializer();
                            while (jsonReader.Read())
                            {
                                if (jsonReader.TokenType == JsonToken.StartObject)
                                {
                                    try
                                    {
                                        items.Add(serializer.Deserialize<T>(jsonReader));
                                    }
                                    catch { }
                                }
                            }
                        }
                    }
                }
            }

            return items;
        }
        #endregion

        #region IEnumerableReader
        public static IEnumerable<T> IEnumerableReader<T>(string filePath)
        {
            if (!File.Exists(filePath))
                return Enumerable.Empty<T>();

            return new JsonItemEnumerable<T>(filePath);
        }
        #endregion


        #region [Codex AI] JsonItemEnumerable<T>
        private class JsonItemEnumerable<T> : IEnumerable<T>
        {
            readonly string filePath;

            public JsonItemEnumerable(string filePath)
            {
                this.filePath = filePath;
            }

            public IEnumerator<T> GetEnumerator() => new JsonItemEnumerator(filePath);

            IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

            private class JsonItemEnumerator : IEnumerator<T>
            {
                readonly string filePath;
                readonly JsonSerializer serializer = new JsonSerializer();

                FileStream fileStream;
                GZipStream gzipStream;
                StreamReader reader;
                JsonTextReader jsonReader;

                public JsonItemEnumerator(string filePath)
                {
                    this.filePath = filePath;
                    Initialize();
                }

                public T Current { get; private set; }

                object IEnumerator.Current => Current;

                void Initialize()
                {
                    try
                    {
                        fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read);
                        gzipStream = new GZipStream(fileStream, CompressionMode.Decompress);
                        reader = new StreamReader(gzipStream);
                        jsonReader = new JsonTextReader(reader);
                    }
                    catch
                    {
                        Dispose();
                    }
                }

                public bool MoveNext()
                {
                    if (jsonReader == null)
                        return false;

                    while (jsonReader.Read())
                    {
                        if (jsonReader.TokenType == JsonToken.StartObject)
                        {
                            try
                            {
                                Current = serializer.Deserialize<T>(jsonReader);
                                return true;
                            }
                            catch { }
                        }
                    }

                    Current = default;
                    return false;
                }

                public void Reset() => throw new NotSupportedException();

                public void Dispose()
                {
                    jsonReader?.Close();
                    reader?.Dispose();
                    gzipStream?.Dispose();
                    fileStream?.Dispose();
                }
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/ModuleInvoke.cs
```
Ôªøusing Newtonsoft.Json.Linq;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Shared.Engine
{
    /// <summary>
    /// [Copilot AI]
    /// </summary>
    public static class ModuleInvoke
    {
        public static T Init<T>(string filed, T val)
        {
            if (val == null)
                return val;

            // Use existing ConfObject logic to get merged JObject/token
            var confObj = Conf(filed, val);
            if (confObj == null)
                return val;

            // If caller expects a JObject, return directly
            if (typeof(T) == typeof(JObject))
                return (T)(object)confObj;

            // If we have a wrapper for non-object values { "value": ... }, extract it
            if (confObj.Count == 1 && confObj.ContainsKey("value"))
            {
                try
                {
                    var token = confObj["value"];
                    return token.ToObject<T>();
                }
                catch
                {
                    return val;
                }
            }

            // Otherwise try to convert the merged object back to T
            try
            {
                return confObj.ToObject<T>();
            }
            catch
            {
                return val;
            }
        }

        public static JObject Conf(string filed, object val)
        {
            if (val == null)
                return null;

            // Convert incoming value to JToken/JObject
            JToken baseToken = val as JToken ?? JToken.FromObject(val);
            if (baseToken == null)
                return null;

            if (baseToken.Type != JTokenType.Object)
            {
                // For non-object values wrap into a simple object so merging still possible
                return new JObject { ["value"] = baseToken };
            }

            var baseObj = (JObject)baseToken;

            try
            {
                if (!File.Exists("init.conf") && !File.Exists("init.yaml"))
                    return baseObj;

                JObject jo = null;
                // First try init.conf if exists
                if (File.Exists("init.conf"))
                {
                    string initfile = File.ReadAllText("init.conf").Trim();
                    if (!string.IsNullOrEmpty(initfile))
                    {
                        if (!initfile.StartsWith("{"))
                            initfile = "{" + initfile + "}";

                        try
                        {
                            jo = JObject.Parse(initfile);
                        }
                        catch
                        {
                            try 
                            { 
                                jo = JObject.FromObject(Newtonsoft.Json.JsonConvert.DeserializeObject(initfile) ?? new JObject()); 
                            } 
                            catch { jo = null; }
                        }
                    }
                }

                // Then try init.yaml and merge/override into jo if present
                if (File.Exists("init.yaml"))
                {
                    try
                    {
                        var yaml = File.ReadAllText("init.yaml").Trim();
                        if (!string.IsNullOrEmpty(yaml))
                        {
                            var deserializer = new DeserializerBuilder()
                                .WithNamingConvention(CamelCaseNamingConvention.Instance)
                                .IgnoreUnmatchedProperties()
                                .Build();

                            var deserialized = deserializer.Deserialize<object>(yaml) ?? new object();

                            // Convert deserialized YAML to JSON and then to JObject
                            var json = Newtonsoft.Json.JsonConvert.SerializeObject(deserialized);

                            JObject yamlJo = null;
                            try
                            {
                                yamlJo = JObject.Parse(json);
                            }
                            catch
                            {
                                try 
                                { 
                                    yamlJo = JObject.FromObject(Newtonsoft.Json.JsonConvert.DeserializeObject(json) ?? new JObject()); 
                                } 
                                catch { yamlJo = null; }
                            }

                            if (yamlJo != null)
                            {
                                if (jo == null)
                                    jo = yamlJo;
                                else
                                    Merge(jo, yamlJo);
                            }
                        }
                    }
                    catch
                    {
                        // ignore yaml parse errors
                    }
                }

                if (jo == null || !jo.ContainsKey(filed))
                    return baseObj;

                var node = jo[filed];

                // If field explicitly false -> return original val
                if (node.Type == JTokenType.Boolean && node.Value<bool>() == false)
                    return baseObj;

                // If node is not an object, nothing to merge -> return original
                if (node.Type != JTokenType.Object)
                    return baseObj;

                var overrideObj = (JObject)node;

                // Deep clone base
                var result = (JObject)baseObj.DeepClone();

                Merge(result, overrideObj);

                return result;
            }
            catch
            {
                return baseObj;
            }
        }

        static void Merge(JObject target, JObject source)
        {
            foreach (var prop in source.Properties())
            {
                var tprop = target.Property(prop.Name);

                if (tprop != null && tprop.Value.Type == JTokenType.Object && prop.Value.Type == JTokenType.Object)
                {
                    Merge((JObject)tprop.Value, (JObject)prop.Value);
                }
                else
                {
                    // Replace or add
                    target[prop.Name] = prop.Value.DeepClone();
                }
            }
        }
    }
}

```

## File: Shared/Engine/CrypTo.cs
```
Ôªøusing System.Security.Cryptography;
using System.Text;

namespace Shared.Engine
{
    public class CrypTo
    {
        public static string md5(string text)
        {
            if (text == null)
                return string.Empty;

            using (var md5 = MD5.Create())
            {
                var result = md5.ComputeHash(Encoding.UTF8.GetBytes(text));
                return BitConverter.ToString(result).Replace("-", "").ToLower();
            }
        }

        public static byte[] md5binary(string text)
        {
            if (text == null)
                return null;

            using (var md5 = MD5.Create())
            {
                var result = md5.ComputeHash(Encoding.UTF8.GetBytes(text));
                return result;
            }
        }

        public static string DecodeBase64(string base64Text)
        {
            if (string.IsNullOrEmpty(base64Text))
                return string.Empty;

            try
            {
                return Encoding.UTF8.GetString(Convert.FromBase64String(base64Text));
            }
            catch { }

            return string.Empty;
        }

        public static string Base64(string text)
        {
            if (text == null)
                return string.Empty;

            return Convert.ToBase64String(Encoding.UTF8.GetBytes(text));
        }

        public static string Base64(byte[] text)
        {
            if (text == null)
                return string.Empty;

            return Convert.ToBase64String(text);
        }

        public static string SHA256(string text)
        {
            using (SHA256 sha256 = System.Security.Cryptography.SHA256.Create())
            {
                // Compute the hash of the given string
                byte[] hashValue = sha256.ComputeHash(Encoding.UTF8.GetBytes(text));

                // Convert the byte array to string format
                return BitConverter.ToString(hashValue).Replace("-", "").ToLower();
            }
        }

        public static string SHA(string text)
        {
            using (SHA1 sha = SHA1.Create())
            {
                // Compute the hash of the given string
                byte[] hashValue = sha.ComputeHash(Encoding.UTF8.GetBytes(text));

                // Convert the byte array to string format
                return BitConverter.ToString(hashValue).Replace("-", "").ToLower();
            }
        }

        public static string AES256(string text, string secret_pw, string secret_iv)
        {
            using (Aes encryptor = Aes.Create())
            {
                encryptor.Mode = CipherMode.CBC;
                encryptor.KeySize = 256;
                encryptor.BlockSize = 128;
                encryptor.Padding = PaddingMode.PKCS7;

                // Set key and IV
                encryptor.Key = Encoding.UTF8.GetBytes(SHA256(secret_pw).Substring(0, 32));
                encryptor.IV = Encoding.UTF8.GetBytes(SHA256(secret_iv).Substring(0, 16));

                // Instantiate a new MemoryStream object to contain the encrypted bytes
                MemoryStream memoryStream = new MemoryStream();

                // Instantiate a new encryptor from our Aes object
                ICryptoTransform aesEncryptor = encryptor.CreateEncryptor();

                // Instantiate a new CryptoStream object to process the data and write it to the 
                // memory stream
                CryptoStream cryptoStream = new CryptoStream(memoryStream, aesEncryptor, CryptoStreamMode.Write);

                // Convert the plainText string into a byte array
                byte[] plainBytes = Encoding.UTF8.GetBytes(text);

                // Encrypt the input plaintext string
                cryptoStream.Write(plainBytes, 0, plainBytes.Length);

                // Complete the encryption process
                cryptoStream.FlushFinalBlock();

                // Convert the encrypted data from a MemoryStream to a byte array
                byte[] cipherBytes = memoryStream.ToArray();

                // Close both the MemoryStream and the CryptoStream
                memoryStream.Close();
                cryptoStream.Close();

                // Convert the encrypted byte array to a base64 encoded string
                return Convert.ToBase64String(cipherBytes, 0, cipherBytes.Length);
            }
        }

        #region unic
        static string ArrayList => "qwertyuioplkjhgfdsazxcvbnmQWERTYUIOPLKJHGFDSAZXCVBNM1234567890";
        static string ArrayListToNumber => "1234567890";
        public static string unic(int size = 8, bool IsNumberCode = false, string addArrayList = null)
        {
            StringBuilder array = new StringBuilder(size);
            string list = IsNumberCode ? ArrayListToNumber : ArrayList + addArrayList;

            for (int i = 0; i < size; i++)
                array.Append(list[Random.Shared.Next(0, list.Length)]);

            return array.ToString();
        }
        #endregion
    }
}

```

## File: Shared/Engine/ResponseCache.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using System.Text.RegularExpressions;

namespace Shared.Engine
{
    public static class ResponseCache
    {
        public static string ErrorKey(HttpContext httpContext)
        {
            string key = httpContext.Request.Path.Value + httpContext.Request.QueryString.Value;
            return "ResponseCache:errorMsg:" + Regex.Replace(key, "(\\?|&)(account_email|cub_id|box_mac|uid|token|source|rchtype)=[^&]+", "");
        }
    }
}

```

## File: Shared/Engine/FileCache.cs
```
Ôªøusing System.Text.RegularExpressions;

namespace Shared.Engine
{
    public static class FileCache
    {
        private static readonly object _lock = new object();

        static Dictionary<string, (DateTime lockTime, string value)> db = new();

        public static string ReadAllText(string path)
        {
            return ReadAllText(path, true);
        }

        public static string ReadAllText(string path, bool saveCache)
        {
            var secondCache = DateTime.Now.AddSeconds(AppInit.conf.multiaccess ? 5 : 1);

            try
            {
                lock (_lock)
                {
                    if (db.TryGetValue(path, out var cache))
                    {
                        if (cache.lockTime > DateTime.Now)
                            return cache.value;
                    }

                    string extension = Path.GetExtension(path);
                    string mypath = Regex.Replace(path, $"{extension}$", $".my{extension}");

                    if (!File.Exists(mypath))
                    {
                        if (!File.Exists(path))
                        {
                            db.TryAdd(path, (secondCache, string.Empty));
                            return string.Empty;
                        }

                        mypath = path;
                    }

                    cache = (secondCache, File.ReadAllText(mypath));

                    if (saveCache)
                        db.TryAdd(path, cache);

                    return cache.value;
                }
            }
            catch 
            {
                return string.Empty;
            }
        }
    }
}

```

## File: Shared/Engine/Http.cs
```
Ôªøusing Newtonsoft.Json;
using Shared.Models;
using Shared.Models.Events;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace Shared.Engine
{
    public static class Http
    {
        public static IHttpClientFactory httpClientFactory;

        #region defaultHeaders / UserAgent
        public static readonly Dictionary<string, string> defaultHeaders = new Dictionary<string, string>()
        {
            ["sec-ch-ua-mobile"] = "?0",
            ["sec-ch-ua-platform"] = "\"Windows\"",
            ["sec-ch-ua"] = "\"Chromium\";v=\"142\", \"Google Chrome\";v=\"142\", \"Not_A Brand\";v=\"99\"",
            ["user-agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36"
        };

        public static readonly Dictionary<string, string> defaultFullHeaders = new Dictionary<string, string>(defaultHeaders)
        {
            ["cache-control"] = "no-cache",
            ["dnt"] = "1",
            ["pragma"] = "no-cache",
            ["priority"] = "u=0, i"
        };

        public static string UserAgent => defaultHeaders["user-agent"];
        #endregion

        #region Handler
        public static HttpClientHandler Handler(string url, WebProxy proxy, CookieContainer cookieContainer = null)
        {
            string log = string.Empty;
            return Handler(url, proxy, ref log, cookieContainer);
        }

        static HttpClientHandler Handler(string url, WebProxy proxy, ref string loglines, CookieContainer cookieContainer = null)
        {
            var handler = new HttpClientHandler()
            {
                AllowAutoRedirect = true,
                AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate
            };

            handler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;

            if (proxy != null)
            {
                handler.UseProxy = true;
                handler.Proxy = proxy;
                loglines += $"proxy: {proxy.Address.ToString()}\n";
            }
            else
            {
                handler.UseProxy = false;
            }

            if (cookieContainer != null)
            {
                handler.CookieContainer = cookieContainer;
                handler.UseCookies = true; //<-- Enable the use of cookies.
            }

            if (AppInit.conf.globalproxy != null && AppInit.conf.globalproxy.Length > 0)
            {
                foreach (var p in AppInit.conf.globalproxy)
                {
                    if (p.list == null || p.list.Length == 0 || p.pattern == null)
                        continue;

                    if (Regex.IsMatch(url, p.pattern, RegexOptions.IgnoreCase))
                    {
                        string proxyip = p.list.OrderBy(a => Guid.NewGuid()).First();

                        NetworkCredential credentials = null;

                        if (proxyip.Contains("@"))
                        {
                            var g = Regex.Match(proxyip, p.pattern_auth).Groups;
                            proxyip = g["sheme"].Value + g["host"].Value;
                            credentials = new NetworkCredential(g["username"].Value, g["password"].Value);
                        }
                        else if (p.useAuth)
                            credentials = new NetworkCredential(p.username, p.password);

                        handler.UseProxy = true;
                        handler.Proxy = new WebProxy(proxyip, p.BypassOnLocal, null, credentials);
                        loglines += $"globalproxy: {proxyip} {(p.useAuth ? $" - {p.username}:{p.password}" : "")}\n";
                        break;
                    }
                }
            }

            InvkEvent.Http(new EventHttpHandler(url, handler, proxy, cookieContainer, Startup.memoryCache));

            return handler;
        }
        #endregion

        #region DefaultRequestHeaders
        public static void DefaultRequestHeaders(string url, HttpRequestMessage client, string cookie, string referer, List<HeadersModel> headers, bool useDefaultHeaders = true)
        {
            string loglines = string.Empty;
            DefaultRequestHeaders(url, client, cookie, referer, headers, ref loglines, useDefaultHeaders);
        }

        public static void DefaultRequestHeaders(string url, HttpRequestMessage client, string cookie, string referer, List<HeadersModel> headers, ref string loglines, bool useDefaultHeaders = true)
        {
            if (useDefaultHeaders)
            {
                client.Headers.TryAddWithoutValidation("Accept-Language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5");
                loglines += $"Accept-Language: {client.Headers.AcceptLanguage}\n";
            }

            if (cookie != null)
            {
                client.Headers.TryAddWithoutValidation("cookie", cookie);
                loglines += $"cookie: {cookie}\n";
            }

            if (referer != null)
            {
                client.Headers.TryAddWithoutValidation("referer", referer);
                loglines += $"referer: {referer}\n";
            }

            bool setDefaultUseragent = true;

            if (headers != null)
            {
                foreach (var item in headers)
                {
                    if (item.name.ToLower() == "user-agent")
                        setDefaultUseragent = false;

                    if (!client.Headers.Contains(item.name))
                    {
                        client.Headers.TryAddWithoutValidation(item.name, item.val);
                        loglines += $"{item.name}: {item.val}\n";
                    }
                }
            }

            if (useDefaultHeaders && setDefaultUseragent)
            {
                client.Headers.TryAddWithoutValidation("User-Agent", UserAgent);
                loglines += $"User-Agent: {client.Headers.UserAgent}\n";
            }

            InvkEvent.Http(new EventHttpHeaders(url, client, cookie, referer, headers, useDefaultHeaders, Startup.memoryCache));
        }
        #endregion


        #region GetLocation
        async public static Task<string> GetLocation(string url, string referer = null, int timeoutSeconds = 8, List<HeadersModel> headers = null, int httpversion = 1, bool allowAutoRedirect = false, WebProxy proxy = null)
        {
            try
            {
                var handler = Handler(url, proxy);
                handler.AllowAutoRedirect = allowAutoRedirect;

                var client = FrendlyHttp.HttpMessageClient(httpversion == 2 ? "http2" : "base", handler);

                var req = new HttpRequestMessage(HttpMethod.Get, url)
                {
                    Version = httpversion == 1 ? HttpVersion.Version11 : new Version(httpversion, 0)
                };

                DefaultRequestHeaders(url, req, null, referer, headers);

                using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(Math.Max(5, timeoutSeconds))))
                {
                    using (HttpResponseMessage response = await client.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, cts.Token).ConfigureAwait(false))
                    {
                        string location = (int)response.StatusCode == 301 || (int)response.StatusCode == 302 || (int)response.StatusCode == 307 ? response.Headers.Location?.ToString() : response.RequestMessage.RequestUri?.ToString();
                        location = Uri.EscapeUriString(System.Web.HttpUtility.UrlDecode(location ?? ""));

                        return string.IsNullOrWhiteSpace(location) ? null : location;
                    }
                }
            }
            catch
            {
                return null;
            }
        }
        #endregion

        #region ResponseHeaders
        async public static Task<HttpResponseMessage> ResponseHeaders(string url, int timeoutSeconds = 8, List<HeadersModel> headers = null, int httpversion = 1, bool allowAutoRedirect = false, WebProxy proxy = null)
        {
            try
            {
                var handler = Handler(url, proxy);
                handler.AllowAutoRedirect = allowAutoRedirect;

                var client = FrendlyHttp.HttpMessageClient(httpversion == 2 ? "http2" : "base", handler);

                var req = new HttpRequestMessage(HttpMethod.Get, url)
                {
                    Version = httpversion == 1 ? HttpVersion.Version11 : new Version(httpversion, 0)
                };

                DefaultRequestHeaders(url, req, null, null, headers);

                using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(Math.Max(5, timeoutSeconds))))
                    using (HttpResponseMessage response = await client.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, cts.Token).ConfigureAwait(false))
                        return response;
            }
            catch
            {
                return null;
            }
        }
        #endregion


        #region Get
        async public static ValueTask<string> Get(string url, Encoding encoding = default, string cookie = null, string referer = null, int timeoutSeconds = 15, List<HeadersModel> headers = null, long MaxResponseContentBufferSize = 0, WebProxy proxy = null, int httpversion = 1, bool statusCodeOK = true, bool weblog = true, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, HttpContent body = null)
        {
            return (await BaseGetAsync(url, encoding, cookie: cookie, referer: referer, timeoutSeconds: timeoutSeconds, headers: headers, MaxResponseContentBufferSize: MaxResponseContentBufferSize, proxy: proxy, httpversion: httpversion, statusCodeOK: statusCodeOK, weblog: weblog, cookieContainer: cookieContainer, useDefaultHeaders: useDefaultHeaders, body: body).ConfigureAwait(false)).content;
        }
        #endregion

        #region Get<T>
        async public static ValueTask<T> Get<T>(string url, Encoding encoding = default, string cookie = null, string referer = null, long MaxResponseContentBufferSize = 0, int timeoutSeconds = 15, List<HeadersModel> headers = null, bool IgnoreDeserializeObject = false, WebProxy proxy = null, bool statusCodeOK = true, int httpversion = 1, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, bool weblog = true, HttpContent body = null)
        {
            try
            {
                string html = (await BaseGetAsync(url, encoding, cookie: cookie, referer: referer, MaxResponseContentBufferSize: MaxResponseContentBufferSize, timeoutSeconds: timeoutSeconds, headers: headers, proxy: proxy, httpversion: httpversion, statusCodeOK: statusCodeOK, cookieContainer: cookieContainer, useDefaultHeaders: useDefaultHeaders, weblog: weblog, body: body).ConfigureAwait(false)).content;
                if (html == null)
                    return default;

                if (IgnoreDeserializeObject)
                    return JsonConvert.DeserializeObject<T>(html, new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } });

                return JsonConvert.DeserializeObject<T>(html);
            }
            catch
            {
                return default;
            }
        }
        #endregion


        #region BaseGetAsync<T>
        async public static Task<(T content, HttpResponseMessage response)> BaseGetAsync<T>(string url, Encoding encoding = default, string cookie = null, string referer = null, long MaxResponseContentBufferSize = 0, int timeoutSeconds = 15, List<HeadersModel> headers = null, bool IgnoreDeserializeObject = false, WebProxy proxy = null, bool statusCodeOK = true, int httpversion = 1, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, HttpContent body = null)
        {
            try
            {
                var result = await BaseGetAsync(url, encoding, cookie: cookie, referer: referer, MaxResponseContentBufferSize: MaxResponseContentBufferSize, timeoutSeconds: timeoutSeconds, headers: headers, proxy: proxy, httpversion: httpversion, statusCodeOK: statusCodeOK, cookieContainer: cookieContainer, useDefaultHeaders: useDefaultHeaders, body: body).ConfigureAwait(false);
                if (result.content == null)
                    return default;

                JsonSerializerSettings settings = null;

                if (IgnoreDeserializeObject)
                    settings = new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } };

                return (JsonConvert.DeserializeObject<T>(result.content, settings), result.response);
            }
            catch
            {
                return default;
            }
        }
        #endregion

        #region BaseGetAsync
        async public static Task<(string content, HttpResponseMessage response)> BaseGetAsync(string url, Encoding encoding = default, string cookie = null, string referer = null, int timeoutSeconds = 15, long MaxResponseContentBufferSize = 0, List<HeadersModel> headers = null, WebProxy proxy = null, int httpversion = 1, bool statusCodeOK = true, bool weblog = true, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, HttpContent body = null)
        {
            string loglines = string.Empty;

            try
            {
                var handler = Handler(url, proxy, ref loglines, cookieContainer);

                var client = FrendlyHttp.HttpMessageClient(httpversion == 1 ? "base" : $"http{httpversion}", handler, MaxResponseContentBufferSize);

                if (cookieContainer != null)
                {
                    var cookiesString = new StringBuilder();
                    foreach (Cookie c in cookieContainer.GetCookies(new Uri(url)))
                        cookiesString.Append($"{c.Name}={c.Value}; ");

                    if (!string.IsNullOrEmpty(cookiesString.ToString()))
                        loglines += $"Cookie: {cookiesString.ToString().TrimEnd(' ', ';')}\n";
                }

                var req = new HttpRequestMessage(HttpMethod.Get, url)
                {
                    Version = httpversion == 1 ? HttpVersion.Version11 : new Version(httpversion, 0),
                    Content = body
                };

                DefaultRequestHeaders(url, req, cookie, referer, headers, ref loglines, useDefaultHeaders);

                using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(Math.Max(5, timeoutSeconds))))
                {
                    using (HttpResponseMessage response = await client.SendAsync(req, cts.Token).ConfigureAwait(false))
                    {
                        loglines += $"\n\nStatusCode: {(int)response.StatusCode}\n";
                        foreach (var h in response.Headers)
                        {
                            if (h.Key == "Set-Cookie")
                            {
                                foreach (string v in h.Value)
                                    loglines += $"{h.Key}: {v}\n";
                            }
                            else
                                loglines += $"{h.Key}: {string.Join("", h.Value)}\n";
                        }

                        using (HttpContent content = response.Content)
                        {
                            if (encoding != default)
                            {
                                string res = encoding.GetString(await content.ReadAsByteArrayAsync().ConfigureAwait(false));
                                var model = new EventHttpResponse(url, null, client, res, response, Startup.memoryCache);

                                if (string.IsNullOrWhiteSpace(res))
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                loglines += "\n" + res;
                                if (statusCodeOK && response.StatusCode != HttpStatusCode.OK)
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                await InvkEvent.HttpAsync(model);
                                return (res, response);
                            }
                            else
                            {
                                string res = await content.ReadAsStringAsync().ConfigureAwait(false);
                                var model = new EventHttpResponse(url, null, client, res, response, Startup.memoryCache);

                                if (string.IsNullOrWhiteSpace(res))
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                loglines += "\n" + res;
                                if (statusCodeOK && response.StatusCode != HttpStatusCode.OK)
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                await InvkEvent.HttpAsync(model);
                                return (res, response);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                loglines = ex.ToString();

                await InvkEvent.HttpAsync(new EventHttpResponse(url, null, null, ex.ToString(), new HttpResponseMessage()
                {
                    StatusCode = HttpStatusCode.InternalServerError,
                    RequestMessage = new HttpRequestMessage()
                }, Startup.memoryCache));

                return (null, new HttpResponseMessage()
                {
                    StatusCode = HttpStatusCode.InternalServerError,
                    RequestMessage = new HttpRequestMessage()
                });
            }
            finally
            {
                if (weblog)
                    WriteLog(url, "GET", body == null ? null : body.ReadAsStringAsync().Result, loglines);
            }
        }
        #endregion


        #region Post
        public static ValueTask<string> Post(string url, in string data, string cookie = null, int MaxResponseContentBufferSize = 0, int timeoutSeconds = 15, List<HeadersModel> headers = null, WebProxy proxy = null, int httpversion = 1, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, bool removeContentType = false)
        {
            return Post(url, new StringContent(data, Encoding.UTF8, "application/x-www-form-urlencoded"), cookie: cookie, MaxResponseContentBufferSize: MaxResponseContentBufferSize, timeoutSeconds: timeoutSeconds, headers: headers, proxy: proxy, httpversion: httpversion, cookieContainer: cookieContainer, useDefaultHeaders: useDefaultHeaders, removeContentType: removeContentType);
        }

        async public static ValueTask<string> Post(string url, HttpContent data, Encoding encoding = default, string cookie = null, int MaxResponseContentBufferSize = 0, int timeoutSeconds = 15, List<HeadersModel> headers = null, WebProxy proxy = null, int httpversion = 1, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, bool removeContentType = false, bool statusCodeOK = true)
        {
            return (await BasePost(url, data, encoding, cookie, MaxResponseContentBufferSize, timeoutSeconds, headers, proxy, httpversion, cookieContainer, useDefaultHeaders, removeContentType, statusCodeOK).ConfigureAwait(false)).content;
        }
        #endregion

        #region Post<T>
        public static Task<T> Post<T>(string url, in string data, string cookie = null, int timeoutSeconds = 15, List<HeadersModel> headers = null, Encoding encoding = default, WebProxy proxy = null, bool IgnoreDeserializeObject = false, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, int httpversion = 1)
        {
            return Post<T>(url, new StringContent(data, Encoding.UTF8, "application/x-www-form-urlencoded"), cookie: cookie, timeoutSeconds: timeoutSeconds, headers: headers, encoding: encoding, proxy: proxy, IgnoreDeserializeObject: IgnoreDeserializeObject, cookieContainer: cookieContainer, useDefaultHeaders: useDefaultHeaders, httpversion: httpversion);
        }

        async public static Task<T> Post<T>(string url, HttpContent data, string cookie = null, int timeoutSeconds = 15, List<HeadersModel> headers = null, Encoding encoding = default, WebProxy proxy = null, bool IgnoreDeserializeObject = false, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, int httpversion = 1)
        {
            try
            {
                string json = await Post(url, data, cookie: cookie, timeoutSeconds: timeoutSeconds, headers: headers, encoding: encoding, proxy: proxy, cookieContainer: cookieContainer, useDefaultHeaders: useDefaultHeaders, httpversion: httpversion).ConfigureAwait(false);
                if (json == null)
                    return default;

                if (IgnoreDeserializeObject)
                    return JsonConvert.DeserializeObject<T>(json, new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } });

                return JsonConvert.DeserializeObject<T>(json);
            }
            catch
            {
                return default;
            }
        }
        #endregion

        #region BasePost
        async public static Task<(string content, HttpResponseMessage response)> BasePost(string url, HttpContent data, Encoding encoding = default, string cookie = null, int MaxResponseContentBufferSize = 0, int timeoutSeconds = 15, List<HeadersModel> headers = null, WebProxy proxy = null, int httpversion = 1, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, bool removeContentType = false, bool statusCodeOK = true)
        {
            string loglines = string.Empty;

            try
            {
                var handler = Handler(url, proxy, ref loglines, cookieContainer);

                var client = FrendlyHttp.HttpMessageClient(httpversion == 1 ? "base" : $"http{httpversion}", handler, MaxResponseContentBufferSize);

                if (cookieContainer != null)
                {
                    var cookiesString = new StringBuilder();
                    foreach (Cookie c in cookieContainer.GetCookies(new Uri(url)))
                        cookiesString.Append($"{c.Name}={c.Value}; ");

                    if (!string.IsNullOrEmpty(cookiesString.ToString()))
                        loglines += $"Cookie: {cookiesString.ToString().TrimEnd(' ', ';')}\n";
                }

                var req = new HttpRequestMessage(HttpMethod.Post, url)
                {
                    Version = httpversion == 1 ? HttpVersion.Version11 : new Version(httpversion, 0),
                    Content = data
                };

                DefaultRequestHeaders(url, req, cookie, null, headers, ref loglines, useDefaultHeaders);

                if (removeContentType)
                    req.Content.Headers.Remove("Content-Type");

                using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(Math.Max(5, timeoutSeconds))))
                {
                    using (HttpResponseMessage response = await client.SendAsync(req, cts.Token).ConfigureAwait(false))
                    {
                        loglines += $"\n\nStatusCode: {(int)response.StatusCode}\n";
                        foreach (var h in response.Headers)
                        {
                            if (h.Key == "Set-Cookie")
                            {
                                foreach (string v in h.Value)
                                    loglines += $"{h.Key}: {v}\n";
                            }
                            else
                                loglines += $"{h.Key}: {string.Join("", h.Value)}\n";
                        }

                        using (HttpContent content = response.Content)
                        {
                            if (encoding != default)
                            {
                                string res = encoding.GetString(await content.ReadAsByteArrayAsync().ConfigureAwait(false));
                                var model = new EventHttpResponse(url, data, client, res, response, Startup.memoryCache);

                                if (string.IsNullOrWhiteSpace(res))
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                loglines += "\n" + res;
                                if (statusCodeOK && response.StatusCode != HttpStatusCode.OK)
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                await InvkEvent.HttpAsync(model);
                                return (res, response);
                            }
                            else
                            {
                                string res = await content.ReadAsStringAsync().ConfigureAwait(false);
                                var model = new EventHttpResponse(url, data, client, res, response, Startup.memoryCache);

                                if (string.IsNullOrWhiteSpace(res))
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                loglines += "\n" + res;
                                if (statusCodeOK && response.StatusCode != HttpStatusCode.OK)
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                await InvkEvent.HttpAsync(model);
                                return (res, response);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                loglines = ex.ToString();

                await InvkEvent.HttpAsync(new EventHttpResponse(url, data, null, ex.ToString(), new HttpResponseMessage()
                {
                    StatusCode = HttpStatusCode.InternalServerError,
                    RequestMessage = new HttpRequestMessage()
                }, Startup.memoryCache));

                return (null, new HttpResponseMessage()
                {
                    StatusCode = HttpStatusCode.InternalServerError,
                    RequestMessage = new HttpRequestMessage()
                });
            }
            finally
            {
                WriteLog(url, "POST", data.ReadAsStringAsync().Result, loglines);
            }
        }
        #endregion


        #region Download
        async public static Task<byte[]> Download(string url, string cookie = null, string referer = null, int timeoutSeconds = 20, long MaxResponseContentBufferSize = 0, List<HeadersModel> headers = null, WebProxy proxy = null, bool statusCodeOK = true, bool useDefaultHeaders = true)
        {
            return (await BaseDownload(url, cookie, referer, timeoutSeconds, MaxResponseContentBufferSize, headers, proxy, statusCodeOK, useDefaultHeaders).ConfigureAwait(false)).array;
        }
        #endregion

        #region BaseDownload
        async public static Task<(byte[] array, HttpResponseMessage response)> BaseDownload(string url, string cookie = null, string referer = null, int timeoutSeconds = 20, long MaxResponseContentBufferSize = 0, List<HeadersModel> headers = null, WebProxy proxy = null, bool statusCodeOK = true, bool useDefaultHeaders = true)
        {
            try
            {
                var handler = Handler(url, proxy);

                var client = FrendlyHttp.HttpMessageClient("base", handler);

                var req = new HttpRequestMessage(HttpMethod.Get, url)
                {
                    Version = HttpVersion.Version11
                };

                DefaultRequestHeaders(url, req, cookie, referer, headers, useDefaultHeaders);

                using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(Math.Max(20, timeoutSeconds))))
                {
                    using (HttpResponseMessage response = await client.SendAsync(req, cts.Token).ConfigureAwait(false))
                    {
                        if (statusCodeOK && response.StatusCode != HttpStatusCode.OK)
                            return (null, response);

                        using (HttpContent content = response.Content)
                        {
                            byte[] res = await content.ReadAsByteArrayAsync().ConfigureAwait(false);
                            if (res == null || res.Length == 0)
                                return (null, response);

                            return (res, response);
                        }
                    }
                }
            }
            catch
            {
                return (null, new HttpResponseMessage()
                {
                    StatusCode = HttpStatusCode.InternalServerError,
                    RequestMessage = new HttpRequestMessage()
                });
            }
        }
        #endregion

        #region DownloadFile
        async public static Task<bool> DownloadFile(string url, string path, int timeoutSeconds = 20, List<HeadersModel> headers = null, WebProxy proxy = null)
        {
            try
            {
                using (var handler = Handler(url, proxy))
                {
                    using (var client = new HttpClient(handler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(timeoutSeconds);

                        bool setDefaultUseragent = true;

                        if (headers != null)
                        {
                            foreach (var item in headers)
                            {
                                if (item.name.ToLower() == "user-agent")
                                    setDefaultUseragent = false;

                                if (!client.DefaultRequestHeaders.Contains(item.name))
                                    client.DefaultRequestHeaders.Add(item.name, item.val);
                            }
                        }

                        if (setDefaultUseragent)
                            client.DefaultRequestHeaders.Add("User-Agent", UserAgent);

                        using (var stream = await client.GetStreamAsync(url))
                        {
                            using (var fileStream = new FileStream(path, FileMode.Create, FileAccess.Write, FileShare.None))
                            {
                                await stream.CopyToAsync(fileStream);
                                return true;
                            }
                        }
                    }
                }
            }
            catch
            {
                return false;
            }
        }
        #endregion


        #region WriteLog
        static FileStream logFileStream = null;

        public static EventHandler<string> onlog = null;

        static void WriteLog(string url, string method, in string postdata, in string result)
        {
            if (url.Contains("127.0.0.1"))
                return;

            if (!AppInit.conf.filelog && !AppInit.conf.weblog.enable)
                return;

            var log = new StringBuilder();

            log.Append($"{DateTime.Now}\n{method}: {url}\n");

            if (!string.IsNullOrEmpty(postdata))
                log.Append($"{postdata}\n\n");

            log.Append(result);

            onlog?.Invoke(null, log.ToString());

            if (!AppInit.conf.filelog || log.Length > 700_000)
                return;

            string dateLog = DateTime.Today.ToString("dd.MM.yy");
            string patchlog = $"cache/logs/HttpClient_{dateLog}.log";

            if (logFileStream == null || !File.Exists(patchlog))
                logFileStream = new FileStream(patchlog, FileMode.Append, FileAccess.Write, FileShare.Read);

            var buffer = Encoding.UTF8.GetBytes($"\n\n\n################################################################\n\n{log.ToString()}");
            logFileStream.Write(buffer, 0, buffer.Length);
            logFileStream.Flush();
        }
        #endregion
    }
}

```

## File: Shared/Engine/SISI/HQpornerTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class HQpornerTo
    {
        public static ValueTask<string> InvokeHtml(string host, string search, string sort, string c, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = $"{host}/";

            if (!string.IsNullOrWhiteSpace(search))
            {
                url += $"?q={HttpUtility.UrlEncode(search)}&p={pg}";
            }
            else
            {
                if (!string.IsNullOrEmpty(c))
                {
                    url += $"category/{c}";
                }
                else
                {
                    if (!string.IsNullOrEmpty(sort))
                        url += $"top/{sort}";

                    else
                        url += "hdporn";
                }

                url += $"/{pg}";
            }

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("<div class=\"img-container\">");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                var g = Regex.Match(row, "href=\"/([^\"]+)\" class=\"atfi[^\"]+\"><img src=\"//([^\"]+)\"[^>]+ alt=\"([^\"]+)\"").Groups;
                if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                {
                    string duration = new Regex("class=\"fa fa-clock-o\" [^>]+></i>([\n\r\t ]+)?([^<]+)<").Match(row).Groups[2].Value.Trim();

                    var pl = new PlaylistItem()
                    {
                        name = g[3].Value.Trim(),
                        video = $"{uri}?uri={g[1].Value}",
                        picture = "https://" + g[2].Value,
                        time = duration,
                        json = true,
                        bookmark = new Bookmark()
                        {
                            site = "hqr",
                            href = g[1].Value,
                            image = "https://" + g[2].Value
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string sort, string c)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";
            string url = host + "hqr";

            var menu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = url,
                }
            };

            if (string.IsNullOrEmpty(c))
            {
                menu.Add(new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrEmpty(sort) ? "–Ω–æ–≤–∏–Ω–∫–∏" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–°–∞–º—ã–µ –Ω–æ–≤—ã–µ",
                            playlist_url = url + $"?c={c}"
                        },
                        new MenuItem()
                        {
                            title = "–¢–æ–ø –Ω–µ–¥–µ–ª–∏",
                            playlist_url = url + $"?c={c}&sort=week"
                        },
                        new MenuItem()
                        {
                            title = "–¢–æ–ø –º–µ—Å—è—Ü–∞",
                            playlist_url = url + $"?c={c}&sort=month"
                        }
                    }
                });
            }

            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–í—Å–µ",
                        playlist_url = url + $"?sort={sort}"
                    },
                    new MenuItem()
                    {
                        title = "1080p porn",
                        playlist_url = url + $"?sort={sort}&c=1080p-porn"
                    },
                    new MenuItem()
                    {
                        title = "anal",
                        playlist_url = url + $"?sort={sort}&c=anal-sex-hd"
                    },
                    new MenuItem()
                    {
                        title = "4k porn",
                        playlist_url = url + $"?sort={sort}&c=4k-porn"
                    },
                    new MenuItem()
                    {
                        title = "milf",
                        playlist_url = url + $"?sort={sort}&c=milf"
                    },
                    new MenuItem()
                    {
                        title = "lesbian",
                        playlist_url = url + $"?sort={sort}&c=lesbian"
                    },
                    new MenuItem()
                    {
                        title = "60fps",
                        playlist_url = url + $"?sort={sort}&c=60fps-porn"
                    },
                    new MenuItem()
                    {
                        title = "creampie",
                        playlist_url = url + $"?sort={sort}&c=creampie"
                    },
                    new MenuItem()
                    {
                        title = "big tits",
                        playlist_url = url + $"?sort={sort}&c=big-tits"
                    },
                    new MenuItem()
                    {
                        title = "teen porn",
                        playlist_url = url + $"?sort={sort}&c=teen-porn"
                    },
                    new MenuItem()
                    {
                        title = "pov",
                        playlist_url = url + $"?sort={sort}&c=pov"
                    },
                    new MenuItem()
                    {
                        title = "threesome",
                        playlist_url = url + $"?sort={sort}&c=threesome"
                    },
                    new MenuItem()
                    {
                        title = "asian",
                        playlist_url = url + $"?sort={sort}&c=asian"
                    },
                    new MenuItem()
                    {
                        title = "old and young",
                        playlist_url = url + $"?sort={sort}&c=old-and-young"
                    },
                    new MenuItem()
                    {
                        title = "ebony",
                        playlist_url = url + $"?sort={sort}&c=ebony"
                    },
                    new MenuItem()
                    {
                        title = "big ass",
                        playlist_url = url + $"?sort={sort}&c=big-ass"
                    },
                    new MenuItem()
                    {
                        title = "interracial",
                        playlist_url = url + $"?sort={sort}&c=interracial"
                    },
                    new MenuItem()
                    {
                        title = "squirt",
                        playlist_url = url + $"?sort={sort}&c=squirt"
                    },
                    new MenuItem()
                    {
                        title = "mature",
                        playlist_url = url + $"?sort={sort}&c=mature"
                    },
                    new MenuItem()
                    {
                        title = "sex massage",
                        playlist_url = url + $"?sort={sort}&c=porn-massage"
                    },
                    new MenuItem()
                    {
                        title = "amateur",
                        playlist_url = url + $"?sort={sort}&c=amateur"
                    },
                    new MenuItem()
                    {
                        title = "casting",
                        playlist_url = url + $"?sort={sort}&c=casting"
                    },
                    new MenuItem()
                    {
                        title = "gangbang",
                        playlist_url = url + $"?sort={sort}&c=gangbang"
                    },
                    new MenuItem()
                    {
                        title = "stockings",
                        playlist_url = url + $"?sort={sort}&c=stockings"
                    },
                    new MenuItem()
                    {
                        title = "big dick",
                        playlist_url = url + $"?sort={sort}&c=big-dick"
                    },
                    new MenuItem()
                    {
                        title = "babe",
                        playlist_url = url + $"?sort={sort}&c=babe"
                    },
                    new MenuItem()
                    {
                        title = "latina",
                        playlist_url = url + $"?sort={sort}&c=latina"
                    },
                    new MenuItem()
                    {
                        title = "group sex",
                        playlist_url = url + $"?sort={sort}&c=group-sex"
                    },
                    new MenuItem()
                    {
                        title = "russian",
                        playlist_url = url + $"?sort={sort}&c=russian"
                    },
                    new MenuItem()
                    {
                        title = "masturbation",
                        playlist_url = url + $"?sort={sort}&c=masturbation"
                    },
                    new MenuItem()
                    {
                        title = "hairy pussy",
                        playlist_url = url + $"?sort={sort}&c=hairy-pussy"
                    },
                    new MenuItem()
                    {
                        title = "uniforms",
                        playlist_url = url + $"?sort={sort}&c=uniforms"
                    },
                    new MenuItem()
                    {
                        title = "shemale",
                        playlist_url = url + $"?sort={sort}&c=shemale"
                    },
                    new MenuItem()
                    {
                        title = "blonde",
                        playlist_url = url + $"?sort={sort}&c=blonde"
                    },
                    new MenuItem()
                    {
                        title = "orgasm",
                        playlist_url = url + $"?sort={sort}&c=orgasm"
                    },
                    new MenuItem()
                    {
                        title = "pickup",
                        playlist_url = url + $"?sort={sort}&c=pickup"
                    },
                    new MenuItem()
                    {
                        title = "sex party",
                        playlist_url = url + $"?sort={sort}&c=sex-parties"
                    },
                    new MenuItem()
                    {
                        title = "bdsm",
                        playlist_url = url + $"?sort={sort}&c=bdsm"
                    },
                    new MenuItem()
                    {
                        title = "public",
                        playlist_url = url + $"?sort={sort}&c=public"
                    },
                    new MenuItem()
                    {
                        title = "japanese",
                        playlist_url = url + $"?sort={sort}&c=japanese-girls-porn"
                    },
                    new MenuItem()
                    {
                        title = "redhead",
                        playlist_url = url + $"?sort={sort}&c=redhead"
                    },
                    new MenuItem()
                    {
                        title = "orgy",
                        playlist_url = url + $"?sort={sort}&c=orgy"
                    },
                    new MenuItem()
                    {
                        title = "blowjob",
                        playlist_url = url + $"?sort={sort}&c=blowjob"
                    },
                    new MenuItem()
                    {
                        title = "fetish",
                        playlist_url = url + $"?sort={sort}&c=fetish"
                    },
                    new MenuItem()
                    {
                        title = "brunette",
                        playlist_url = url + $"?sort={sort}&c=brunette"
                    },
                    new MenuItem()
                    {
                        title = "small tits",
                        playlist_url = url + $"?sort={sort}&c=small-tits"
                    },
                    new MenuItem()
                    {
                        title = "undressing",
                        playlist_url = url + $"?sort={sort}&c=undressing"
                    },
                    new MenuItem()
                    {
                        title = "cumshot",
                        playlist_url = url + $"?sort={sort}&c=cumshot"
                    },
                    new MenuItem()
                    {
                        title = "outdoor",
                        playlist_url = url + $"?sort={sort}&c=outdoor"
                    },
                    new MenuItem()
                    {
                        title = "deepthroat",
                        playlist_url = url + $"?sort={sort}&c=deepthroat"
                    },
                    new MenuItem()
                    {
                        title = "bondage",
                        playlist_url = url + $"?sort={sort}&c=bondage"
                    },
                    new MenuItem()
                    {
                        title = "shaved pussy",
                        playlist_url = url + $"?sort={sort}&c=shaved-pussy"
                    },
                    new MenuItem()
                    {
                        title = "bisexual",
                        playlist_url = url + $"?sort={sort}&c=bisexual"
                    },
                    new MenuItem()
                    {
                        title = "hentai",
                        playlist_url = url + $"?sort={sort}&c=hentai"
                    },
                    new MenuItem()
                    {
                        title = "handjob",
                        playlist_url = url + $"?sort={sort}&c=handjob"
                    },
                    new MenuItem()
                    {
                        title = "pussy licking",
                        playlist_url = url + $"?sort={sort}&c=pussy-licking"
                    },
                    new MenuItem()
                    {
                        title = "moaning",
                        playlist_url = url + $"?sort={sort}&c=moaning"
                    },
                    new MenuItem()
                    {
                        title = "fisting",
                        playlist_url = url + $"?sort={sort}&c=fisting"
                    },
                    new MenuItem()
                    {
                        title = "vintage",
                        playlist_url = url + $"?sort={sort}&c=vintage"
                    },
                    new MenuItem()
                    {
                        title = "tattooed",
                        playlist_url = url + $"?sort={sort}&c=tattooed"
                    },
                    new MenuItem()
                    {
                        title = "beach",
                        playlist_url = url + $"?sort={sort}&c=beach-porn"
                    },
                    new MenuItem()
                    {
                        title = "vibrator",
                        playlist_url = url + $"?sort={sort}&c=vibrator"
                    },
                    new MenuItem()
                    {
                        title = "fingering",
                        playlist_url = url + $"?sort={sort}&c=fingering"
                    },
                    new MenuItem()
                    {
                        title = "squeezing tits",
                        playlist_url = url + $"?sort={sort}&c=squeezing-tits"
                    },
                    new MenuItem()
                    {
                        title = "long hair",
                        playlist_url = url + $"?sort={sort}&c=long-hair"
                    }
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }

            return menu;
        }

        async public static ValueTask<Dictionary<string, string>> StreamLinks(string host, string uri, Func<string, ValueTask<string>> onresult, Func<string, ValueTask<string>> oniframe)
        {
            if (string.IsNullOrWhiteSpace(uri))
                return null;

            string html = await onresult.Invoke($"{host}/{uri}");
            if (html == null)
                return null;

            string uriframe = Regex.Match(html, "<iframe src=\"//([^/]+/video/[^/]+/)\"").Groups[1].Value;
            if (string.IsNullOrWhiteSpace(uriframe))
                return null;

            string iframeHtml = await oniframe.Invoke($"https://{uriframe}");
            if (iframeHtml == null)
                return null;

            var stream_links = new Dictionary<string, string>();
            var match = new Regex("src=\"//([^\"]+)\" title=\"([^\"]+)\"").Match(iframeHtml.Replace("\\", ""));
            while (match.Success)
            {
                if (!string.IsNullOrWhiteSpace(match.Groups[1].Value) && !string.IsNullOrWhiteSpace(match.Groups[2].Value) && !match.Groups[2].Value.Contains("Default"))
                {
                    string hls = "https://" + match.Groups[1].Value;
                    stream_links.TryAdd(match.Groups[2].Value, hls);
                }

                match = match.NextMatch();
            }

            if (stream_links.Count == 0)
            {
                string jw = Regex.Match(iframeHtml, "\\$\\(\"#jw\"\\)([^;]+)").Groups[1].Value;
                if (jw.Contains("replaceAll"))
                {
                    var grpal = Regex.Match(iframeHtml, "replaceAll\\(\"([^\"]+)\",([^\\+]+)\\+\"pubs/\"\\+([^\\+]+)").Groups;

                    string cdn = Regex.Match(iframeHtml, grpal[2].Value + "=\"([^\"]+)\"").Groups[1].Value;
                    string hash = Regex.Match(iframeHtml, grpal[3].Value + "=\"([^\"]+)\"").Groups[1].Value;

                    if (!string.IsNullOrEmpty(cdn) && !string.IsNullOrEmpty(hash))
                    {
                        match = new Regex("src=\"([^\"]+[0-9]+\\.mp4)\" title=\"([^\"]+)\"").Match(iframeHtml.Replace("\\", ""));
                        while (match.Success)
                        {
                            if (!string.IsNullOrWhiteSpace(match.Groups[1].Value) && !string.IsNullOrWhiteSpace(match.Groups[2].Value) && !match.Groups[2].Value.Contains("Default"))
                            {
                                string hls = match.Groups[1].Value.Replace(grpal[1].Value, $"https:{cdn}pubs/{hash}/");

                                if (hls.StartsWith("https:"))
                                    stream_links.TryAdd(match.Groups[2].Value, hls);
                            }

                            match = match.NextMatch();
                        }
                    }
                }
            }

            return stream_links.Reverse().ToDictionary(k => k.Key, v => v.Value);
        }
    }
}

```

## File: Shared/Engine/SISI/EpornerTo.cs
```
Ôªøusing HtmlAgilityPack;
using Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class EpornerTo
    {
        public static ValueTask<string> InvokeHtml(string host, string search, string sort, string c, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = $"{host}/";

            if (!string.IsNullOrWhiteSpace(search))
            {
                url += $"search/{HttpUtility.UrlEncode(search)}/";

                if (pg > 1)
                    url += $"{pg}/";

                if (!string.IsNullOrEmpty(sort))
                    url += $"{sort}/";
            }
            else
            {
                if (!string.IsNullOrEmpty(c)) 
                {
                    url += $"cat/{c}/";

                    if (pg > 1)
                        url += $"{pg}/";
                }
                else
                {
                    if (pg > 1)
                        url += $"{pg}/";

                    if (!string.IsNullOrEmpty(sort))
                        url += $"{sort}/";
                }
            }

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var doc = new HtmlDocument();
            doc.LoadHtml(html);

            string single = doc.DocumentNode.SelectSingleNode("//*[@id='relateddiv' or @id='vidresults']")?.InnerHtml;
            if (single != null)
                html = single;
            else
            {
                if (html.Contains("class=\"toptopbelinset\""))
                    html = html.Split("class=\"toptopbelinset\"")[1];

                if (html.Contains("class=\"relatedtext\""))
                    html = html.Split("class=\"relatedtext\"")[1];
            }

            var rows = Regex.Split(html, "<div class=\"mb( hdy)?\"");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                var g = Regex.Match(row, "<p class=\"mbtit\"><a href=\"/([^\"]+)\">([^<]+)</a>").Groups;
                string quality = Regex.Match(row, "<div class=\"mvhdico\"([^>]+)?><span>([^\"<]+)").Groups[2].Value;

                if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                {
                    string img = Regex.Match(row, " data-src=\"([^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrWhiteSpace(img))
                        img = Regex.Match(row, "<img src=\"([^\"]+)\"").Groups[1].Value;

                    string dataid = Regex.Match(row, "data-id=\"([^\"]+)\"").Groups[1].Value;
                    string preview = Regex.Replace(img, "/[^/]+$", "") + $"/{dataid}-preview.webm";

                    string duration = Regex.Match(row, "<span class=\"mbtim\"([^>]+)?>([^<]+)</span>").Groups[2].Value.Trim();

                    var pl = new PlaylistItem()
                    {
                        name = g[2].Value,
                        video = $"{uri}?uri={g[1].Value}",
                        picture = img,
                        preview = preview,
                        quality = quality,
                        time = duration,
                        json = true,
                        related = true,
                        bookmark = new Bookmark()
                        {
                            site = "epr",
                            href = g[1].Value,
                            image = img
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string search, string sort, string c)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";
            string url = host + "epr";

            var menu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = url,
                }
            };

            if (!string.IsNullOrEmpty(search))
            {
                string encodesearch = HttpUtility.UrlEncode(search);

                menu.Add(new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrWhiteSpace(sort) ? "–Ω–æ–≤–∏–Ω–∫–∏" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–æ–≤–∏–Ω–∫–∏",
                            playlist_url = url + $"?search={encodesearch}"
                        },
                        new MenuItem()
                        {
                            title = "–¢–æ–ø –ø—Ä–æ—Å–º–æ—Ç—Ä–∞",
                            playlist_url = url + $"?sort=most-viewed&search={encodesearch}"
                        },
                        new MenuItem()
                        {
                            title = "–¢–æ–ø —Ä–µ–π—Ç–∏–Ω–≥–∞",
                            playlist_url = url + $"?sort=top-rated&search={encodesearch}"
                        },
                        new MenuItem()
                        {
                            title = "–î–ª–∏–Ω–Ω—ã–µ —Ä–æ–ª–∏–∫–∏",
                            playlist_url = url + $"?sort=longest&search={encodesearch}"
                        },
                        new MenuItem()
                        {
                            title = "–ö–æ—Ä–æ—Ç–∫–∏–µ —Ä–æ–ª–∏–∫–∏",
                            playlist_url = url + $"?sort=shortest&search={encodesearch}"
                        }
                    }
                });

                return menu;
            }

            if (string.IsNullOrEmpty(c))
            {
                menu.Add(new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrWhiteSpace(sort) ? "–Ω–æ–≤–∏–Ω–∫–∏" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–æ–≤–∏–Ω–∫–∏",
                            playlist_url = url
                        },
                        new MenuItem()
                        {
                            title = "–¢–æ–ø –ø—Ä–æ—Å–º–æ—Ç—Ä–∞",
                            playlist_url = url + "?sort=most-viewed"
                        },
                        new MenuItem()
                        {
                            title = "–¢–æ–ø —Ä–µ–π—Ç–∏–Ω–≥–∞",
                            playlist_url = url + "?sort=top-rated"
                        },
                        new MenuItem()
                        {
                            title = "–î–ª–∏–Ω–Ω—ã–µ —Ä–æ–ª–∏–∫–∏",
                            playlist_url = url + "?sort=longest"
                        },
                        new MenuItem()
                        {
                            title = "–ö–æ—Ä–æ—Ç–∫–∏–µ —Ä–æ–ª–∏–∫–∏",
                            playlist_url = url + "?sort=shortest"
                        }
                    }
                });
            }

            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–í—Å–µ",
                        playlist_url = url
                    },
                    new MenuItem()
                    {
                        title = "4K UHD",
                        playlist_url = url + $"?c=4k-porn"
                    },
                    new MenuItem()
                    {
                        title = "60 FPS",
                        playlist_url = url + $"?c=60fps"
                    },
                    new MenuItem()
                    {
                        title = "Amateur",
                        playlist_url = url + $"?c=amateur"
                    },
                    new MenuItem()
                    {
                        title = "Anal",
                        playlist_url = url + $"?c=anal"
                    },
                    new MenuItem()
                    {
                        title = "Asian",
                        playlist_url = url + $"?c=asian"
                    },
                    new MenuItem()
                    {
                        title = "ASMR",
                        playlist_url = url + $"?c=asmr"
                    },
                    new MenuItem()
                    {
                        title = "BBW",
                        playlist_url = url + $"?c=bbw"
                    },
                    new MenuItem()
                    {
                        title = "BDSM",
                        playlist_url = url + $"?c=bdsm"
                    },
                    new MenuItem()
                    {
                        title = "Big Ass",
                        playlist_url = url + $"?c=big-ass"
                    },
                    new MenuItem()
                    {
                        title = "Big Dick",
                        playlist_url = url + $"?c=big-dick"
                    },
                    new MenuItem()
                    {
                        title = "Big Tits",
                        playlist_url = url + $"?c=big-tits"
                    },
                    new MenuItem()
                    {
                        title = "Bisexual",
                        playlist_url = url + $"?c=bisexual"
                    },
                    new MenuItem()
                    {
                        title = "Blonde",
                        playlist_url = url + $"?c=blonde"
                    },
                    new MenuItem()
                    {
                        title = "Blowjob",
                        playlist_url = url + $"?c=blowjob"
                    },
                    new MenuItem()
                    {
                        title = "Bondage",
                        playlist_url = url + $"?c=bondage"
                    },
                    new MenuItem()
                    {
                        title = "Brunette",
                        playlist_url = url + $"?c=brunette"
                    },
                    new MenuItem()
                    {
                        title = "Bukkake",
                        playlist_url = url + $"?c=bukkake"
                    },
                    new MenuItem()
                    {
                        title = "Creampie",
                        playlist_url = url + $"?c=creampie"
                    },
                    new MenuItem()
                    {
                        title = "Cumshot",
                        playlist_url = url + $"?c=cumshot"
                    },
                    new MenuItem()
                    {
                        title = "Double Penetration",
                        playlist_url = url + $"?c=double-penetration"
                    },
                    new MenuItem()
                    {
                        title = "Ebony",
                        playlist_url = url + $"?c=ebony"
                    },
                    new MenuItem()
                    {
                        title = "Fat",
                        playlist_url = url + $"?c=fat"
                    },
                    new MenuItem()
                    {
                        title = "Fetish",
                        playlist_url = url + $"?c=fetish"
                    },
                    new MenuItem()
                    {
                        title = "Fisting",
                        playlist_url = url + $"?c=fisting"
                    },
                    new MenuItem()
                    {
                        title = "Footjob",
                        playlist_url = url + $"?c=footjob"
                    },
                    new MenuItem()
                    {
                        title = "For Women",
                        playlist_url = url + $"?c=for-women"
                    },
                    new MenuItem()
                    {
                        title = "Gay",
                        playlist_url = url + $"?c=gay"
                    },
                    new MenuItem()
                    {
                        title = "Group Sex",
                        playlist_url = url + $"?c=group-sex"
                    },
                    new MenuItem()
                    {
                        title = "Handjob",
                        playlist_url = url + $"?c=handjob"
                    },
                    new MenuItem()
                    {
                        title = "Hardcore",
                        playlist_url = url + $"?c=hardcore"
                    },
                    new MenuItem()
                    {
                        title = "Hentai",
                        playlist_url = url + $"?c=hentai"
                    },
                    new MenuItem()
                    {
                        title = "Homemade",
                        playlist_url = url + $"?c=homemade"
                    },
                    new MenuItem()
                    {
                        title = "Hotel",
                        playlist_url = url + $"?c=hotel"
                    },
                    new MenuItem()
                    {
                        title = "Housewives",
                        playlist_url = url + $"?c=housewives"
                    },
                    new MenuItem()
                    {
                        title = "Indian",
                        playlist_url = url + $"?c=indian"
                    },
                    new MenuItem()
                    {
                        title = "Interracial",
                        playlist_url = url + $"?c=interracial"
                    },
                    new MenuItem()
                    {
                        title = "Japanese",
                        playlist_url = url + $"?c=japanese"
                    },
                    new MenuItem()
                    {
                        title = "Latina",
                        playlist_url = url + $"?c=latina"
                    },
                    new MenuItem()
                    {
                        title = "Lesbian",
                        playlist_url = url + $"?c=lesbians"
                    },
                    new MenuItem()
                    {
                        title = "Lingerie",
                        playlist_url = url + $"?c=lingerie"
                    },
                    new MenuItem()
                    {
                        title = "Massage",
                        playlist_url = url + $"?c=massage"
                    },
                    new MenuItem()
                    {
                        title = "Masturbation",
                        playlist_url = url + $"?c=masturbation"
                    },
                    new MenuItem()
                    {
                        title = "Mature",
                        playlist_url = url + $"?c=mature"
                    },
                    new MenuItem()
                    {
                        title = "MILF",
                        playlist_url = url + $"?c=milf"
                    },
                    new MenuItem()
                    {
                        title = "Nurses",
                        playlist_url = url + $"?c=nurse"
                    },
                    new MenuItem()
                    {
                        title = "Office",
                        playlist_url = url + $"?c=office"
                    },
                    new MenuItem()
                    {
                        title = "Older Men",
                        playlist_url = url + $"?c=old-man"
                    },
                    new MenuItem()
                    {
                        title = "Orgy",
                        playlist_url = url + $"?c=orgy"
                    },
                    new MenuItem()
                    {
                        title = "Outdoor",
                        playlist_url = url + $"?c=outdoor"
                    },
                    new MenuItem()
                    {
                        title = "Petite",
                        playlist_url = url + $"?c=petite"
                    },
                    new MenuItem()
                    {
                        title = "Pornstar",
                        playlist_url = url + $"?c=pornstar"
                    },
                    new MenuItem()
                    {
                        title = "POV",
                        playlist_url = url + $"?c=pov-porn"
                    },
                    new MenuItem()
                    {
                        title = "Public",
                        playlist_url = url + $"?c=public"
                    },
                    new MenuItem()
                    {
                        title = "Redhead",
                        playlist_url = url + $"?c=redhead"
                    },
                    new MenuItem()
                    {
                        title = "Shemale",
                        playlist_url = url + $"?c=shemale"
                    },
                    new MenuItem()
                    {
                        title = "Sleep",
                        playlist_url = url + $"?c=sleep"
                    },
                    new MenuItem()
                    {
                        title = "Small Tits",
                        playlist_url = url + $"?c=small-tits"
                    },
                    new MenuItem()
                    {
                        title = "Squirt",
                        playlist_url = url + $"?c=squirt"
                    },
                    new MenuItem()
                    {
                        title = "Striptease",
                        playlist_url = url + $"?c=striptease"
                    },
                    new MenuItem()
                    {
                        title = "Students",
                        playlist_url = url + $"?c=students"
                    },
                    new MenuItem()
                    {
                        title = "Swinger",
                        playlist_url = url + $"?c=swingers"
                    },
                    new MenuItem()
                    {
                        title = "Teen",
                        playlist_url = url + $"?c=teens"
                    },
                    new MenuItem()
                    {
                        title = "Threesome",
                        playlist_url = url + $"?c=threesome"
                    },
                    new MenuItem()
                    {
                        title = "Toys",
                        playlist_url = url + $"?c=toys"
                    },
                    new MenuItem()
                    {
                        title = "Uncategorized",
                        playlist_url = url + $"?c=uncategorized"
                    },
                    new MenuItem()
                    {
                        title = "Uniform",
                        playlist_url = url + $"?c=uniform"
                    },
                    new MenuItem()
                    {
                        title = "Vintage",
                        playlist_url = url + $"?c=vintage"
                    },
                    new MenuItem()
                    {
                        title = "Webcam",
                        playlist_url = url + $"?c=webcam"
                    }
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }

            return menu;
        }

        async public static ValueTask<StreamItem> StreamLinks(string uri, string host, string url, Func<string, ValueTask<string>> onresult, Func<string, ValueTask<string>> onjson, Func<string, string> onlog = null)
        {
            if (string.IsNullOrEmpty(url))
                return null;

            string html = await onresult.Invoke($"{host}/{url}");
            if (html == null)
                return null;

            string vid = Regex.Match(html, "vid ?= ?'([^']+)'").Groups[1].Value;
            string hash = Regex.Match(html, "hash ?= ?'([^']+)'").Groups[1].Value;
            if (string.IsNullOrWhiteSpace(vid) || string.IsNullOrWhiteSpace(hash))
                return null;

            string json = await onjson.Invoke($"{host}/xhr/video/{vid}?hash={convertHash(hash)}&domain={Regex.Replace(host, "^https?://", "")}&fallback=false&embed=false&supportedFormats=dash,mp4&_={DateTimeOffset.UtcNow.ToUnixTimeSeconds()}");
            if (json == null)
                return null;

            onlog?.Invoke("json: " + json);

            var stream_links = new Dictionary<string, string>();
            var match = new Regex("\"src\":( +)?\"(https?://[^/]+/[^\"]+-([0-9]+p).mp4)\",").Match(json);
            while (match.Success)
            {
                onlog?.Invoke($"{match.Groups[3].Value} /  {match.Groups[2].Value}");
                stream_links.TryAdd(match.Groups[3].Value, match.Groups[2].Value);
                match = match.NextMatch();
            }

            onlog?.Invoke("stream_links: " + stream_links.Count);

            return new StreamItem()
            {
                qualitys = stream_links,
                recomends = Playlist(uri, html)
            };
        }


        #region convertHash
        static string convertHash(in string h)
        {
            return Base36(h.Substring(0, 8)) + Base36(h.Substring(8, 8)) + Base36(h.Substring(16, 8)) + Base36(h.Substring(24, 8));
        }
        #endregion

        #region Base36
        static string Base36(in string val)
        {
            string result = "";
            ulong value = Convert.ToUInt64(val, 16);

            const int Base = 36;
            const string Chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

            while (value > 0)
            {
                result = Chars[(int)(value % Base)] + result; // use StringBuilder for better performance
                value /= Base;
            }

            return result.ToLower();
        }
        #endregion
    }
}

```

## File: Shared/Engine/SISI/RunetkiTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using System.Text.RegularExpressions;

namespace Shared.Engine.SISI
{
    public static class RunetkiTo
    {
        public static ValueTask<string> InvokeHtml(string host, string sort, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = host + $"/tools/listing_v3.php?livetab={sort ?? "all"}&offset={(pg > 1 ? ((pg-1) * 72) : 0)}&limit=72";

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(in string html, out int total_pages, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            total_pages = 0;

            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("\"gender\"");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                string baba = Regex.Match(row, "\"username\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(baba))
                    continue;

                string esid = Regex.Match(row, "\"esid\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(esid))
                    continue;

                string img = Regex.Match(row, "\"thumb_image\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(img))
                    continue;

                string title = Regex.Match(row, "\"display_name\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(title))
                    title = baba;

                var pl = new PlaylistItem()
                {
                    name = title,
                    quality = Regex.Match(row, "\"vq\":\"([^\"]+)\"").Groups[1].Value,
                    video = $"https://{esid}.bcvcdn.com/hls/stream_{baba}/playlist.m3u8",
                    picture = $"https:{img.Replace("\\", "").Replace("{ext}", "jpg")}"
                };

                if (onplaylist != null)
                    pl = onplaylist.Invoke(pl);

                playlists.Add(pl);
            }

            string total_count = Regex.Match(html, "\"total_count\":([0-9]+),").Groups[1].Value;
            if (int.TryParse(total_count, out int total) && total > 0)
            {
                if (72 >= total)
                    total_pages = 1;
                else
                    total_pages = (total / 72) + 1;
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string sort)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";

            return new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrWhiteSpace(sort) ? "–≤—ã–±—Ä–∞—Ç—å" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–æ–≤—ã–µ",
                            playlist_url = host + "runetki?sort=new"
                        },
                        new MenuItem()
                        {
                            title = "–ü–∞—Ä—ã",
                            playlist_url = host + "runetki?sort=couples"
                        },
                        new MenuItem()
                        {
                            title = "–î–µ–≤—É—à–∫–∏",
                            playlist_url = host + "runetki?sort=female"
                        },
                        new MenuItem()
                        {
                            title = "–ü–∞—Ä–Ω–∏",
                            playlist_url = host + "runetki?sort=male"
                        },
                        new MenuItem()
                        {
                            title = "–¢—Ä–∞–Ω—Å—Å–µ–∫—Å—É–∞–ª—ã",
                            playlist_url = host + "runetki?sort=transsexual"
                        }
                    }
                }
            };
        }
    }
}

```

## File: Shared/Engine/SISI/XhamsterTo.cs
```
Ôªøusing HtmlAgilityPack;
using Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class XhamsterTo
    {
        public static ValueTask<string> InvokeHtml(string host, string plugin, string search, string c, string q, string sort, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url;

            if (!string.IsNullOrWhiteSpace(search))
            {
                url = $"{host}/search/{HttpUtility.UrlEncode(search)}?page={pg}";
            }
            else
            {
                switch (plugin ?? "")
                {
                    case "xmrsml":
                        url = $"{host}/shemale";
                        break;
                    case "xmrgay":
                        url = $"{host}/gay";
                        break;
                    default:
                        url = host;
                        break;
                }

                if (!string.IsNullOrEmpty(c))
                    url += $"/categories/{c}";

                if (!string.IsNullOrEmpty(q))
                    url += $"/{q}";

                switch (sort ?? "")
                {
                    case "newest":
                        url += "/newest";
                        break;
                    case "best":
                        url += "/best";
                        break;
                    default:
                        break;
                }

                if (pg > 0)
                    url += $"/{pg}";
            }

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            string section = html;

            if (html.Contains("mixed-section"))
            {
                var doc = new HtmlDocument();
                doc.LoadHtml(html);
                string single = doc.DocumentNode.SelectSingleNode("//div[contains(@class, 'mixed-section')]")?.InnerHtml;
                if (single != null)
                    section = single;
            }

            var rows = Regex.Split(section, "(<div class=\"thumb-list__item video-thumb|thumb-list-mobile-item)");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                if (string.IsNullOrWhiteSpace(row) || row.Contains("badge_premium"))
                    continue;

                var g = Regex.Match(row, "__nam[^\"]+\" href=\"https?://[^/]+/([^\"]+)\"([^>]+)?>(<!--[^-]+-->)?([^<]+)").Groups;
                string title = g[4].Value;
                string href = g[1].Value;

                if (!string.IsNullOrEmpty(href) && !string.IsNullOrWhiteSpace(title))
                {
                    string duration = Regex.Match(row, "data-role=\"video-duration\"><[^>]+>([^<]+)").Groups[1].Value;
                    if (string.IsNullOrEmpty(duration))
                        duration = Regex.Match(row, "datetime=\"([^\"]+)\"").Groups[1].Value;

                    string img = Regex.Match(row, " srcset=\"([^\"]+)\"").Groups[1].Value;
                    if (!img.StartsWith("http") || img.Contains("(w:16,h:9)"))
                    {
                        img = Regex.Match(row, "thumb-image-container__image\" src=\"([^\"]+)\"").Groups[1].Value;
                        if (!img.StartsWith("http"))
                            img = Regex.Match(row, "<noscript><img src=\"([^\"]+)\"").Groups[1].Value.Trim();
                    }

                    if (!img.StartsWith("http"))
                        continue;

                    var pl = new PlaylistItem()
                    {
                        name = title,
                        video = $"{uri}?uri={href}",
                        picture = img,
                        quality = row.Contains("-hd") ? "HD" : row.Contains("-uhd") ? "4K" : null,
                        preview = Regex.Match(row, "data-previewvideo=\"([^\"]+)\"").Groups[1].Value,
                        time = duration?.Trim(),
                        json = true,
                        related = true,
                        bookmark = new Bookmark()
                        {
                            site = "xmr",
                            href = href,
                            image = img
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string plugin, string c, string q, string sort)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";

            var menu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = host + plugin,
                },
                new MenuItem()
                {
                    title = $"–ö–∞—á–µ—Å—Ç–≤–æ: {(q == "4k" ? "2160p" : "–õ—é–±–æ–µ")}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem("–õ—é–±–æ–µ", host + $"{plugin}?c={c}&sort={sort}"),
                        new MenuItem("2160p", host + $"{plugin}?c={c}&sort={sort}&q=4k")
                    }
                },
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(sort == "newest" ? "–ù–æ–≤–∏–Ω–∫–∏" : sort == "best" ? "–õ—É—á—à–∏–µ" :"–í —Ç—Ä–µ–Ω–¥–µ")}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem("–í —Ç—Ä–µ–Ω–¥–µ", host + $"{plugin}?c={c}&q={q}&sort=trend"),
                        new MenuItem("–°–∞–º—ã–µ –Ω–æ–≤—ã–µ", host + $"{plugin}?c={c}&q={q}&sort=newest"),
                        new MenuItem("–õ—É—á—à–∏–µ –≤–∏–¥–µ–æ", host + $"{plugin}?c={c}&q={q}&sort=best")
                    }
                },
                new MenuItem()
                {
                    title = $"–û—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è: {(plugin == "xmrgay" ? "–ì–µ–∏" : plugin == "xmrsml" ? "–¢—Ä–∞–Ω—Å—ã" :"–ì–µ—Ç–µ—Ä–æ")}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem("–ì–µ—Ç–µ—Ä–æ", host + "xmr"),
                        new MenuItem("–ì–µ–∏", host + "xmrgay"),
                        new MenuItem("–¢—Ä–∞–Ω—Å—ã", host + "xmrsml")
                    }
                }
            };

            if (plugin == "xmr")
            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem("–í—Å–µ", host + $"{plugin}?sort={sort}&q={q}"),
                    new MenuItem("–†—É—Å—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=russian"),
                    new MenuItem("–°–µ–∫—Å –≤—Ç—Ä–æ–µ–º", host + $"{plugin}?sort={sort}&q={q}&c=threesome"),
                    new MenuItem("–ê–∑–∏–∞—Ç—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=asian"),
                    new MenuItem("–ê–Ω–∞–ª", host + $"{plugin}?sort={sort}&q={q}&c=anal"),
                    new MenuItem("–ê—Ä–∞–±—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=arab"),
                    new MenuItem("–ê–°–ú–†", host + $"{plugin}?sort={sort}&q={q}&c=asmr"),
                    new MenuItem("–ë–∞–±–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=granny"),
                    new MenuItem("–ë–î–°–ú", host + $"{plugin}?sort={sort}&q={q}&c=bdsm"),
                    new MenuItem("–ë–∏", host + $"{plugin}?sort={sort}&q={q}&c=bisexual"),
                    new MenuItem("–ë–æ–ª—å—à–∏–µ –∂–æ–ø—ã", host + $"{plugin}?sort={sort}&q={q}&c=big-ass"),
                    new MenuItem("–ë–æ–ª—å—à–∏–µ –∑–∞–¥–Ω–∏—Ü—ã", host + $"{plugin}?sort={sort}&q={q}&c=pawg"),
                    new MenuItem("–ë–æ–ª—å—à–∏–µ —Å–∏—Å—å–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=big-tits"),
                    new MenuItem("–ë–æ–ª—å—à–æ–π —á–ª–µ–Ω", host + $"{plugin}?sort={sort}&q={q}&c=big-cock"),
                    new MenuItem("–ë—Ä–∏—Ç–∞–Ω—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=british"),
                    new MenuItem("–í –≤–æ–∑—Ä–∞—Å—Ç–µ", host + $"{plugin}?sort={sort}&q={q}&c=mature"),
                    new MenuItem("–í–µ–±–∫–∞–º–µ—Ä–∞", host + $"{plugin}?sort={sort}&q={q}&c=webcam"),
                    new MenuItem("–í–∏–Ω—Ç–∞–∂", host + $"{plugin}?sort={sort}&q={q}&c=vintage"),
                    new MenuItem("–í–æ–ª–æ—Å–∞—Ç—ã–µ", host + $"{plugin}?sort={sort}&q={q}&c=hairy"),
                    new MenuItem("–ì–æ–ª—ã–µ –º—É–∂—á–∏–Ω—ã –æ–¥–µ—Ç—ã–µ –∂–µ–Ω—â–∏–Ω—ã", host + $"{plugin}?sort={sort}&q={q}&c=cfnm"),
                    new MenuItem("–ì—Ä—É–ø–ø–æ–≤–æ–π —Å–µ–∫—Å", host + $"{plugin}?sort={sort}&q={q}&c=group-sex"),
                    new MenuItem("–ì—ç–Ω–≥–±—ç–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=gangbang"),
                    new MenuItem("–î–∏–ª–¥–æ", host + $"{plugin}?sort={sort}&q={q}&c=dildo"),
                    new MenuItem("–î–æ–º–∞—à–Ω–µ–µ –ø–æ—Ä–Ω–æ", host + $"{plugin}?sort={sort}&q={q}&c=homemade"),
                    new MenuItem("–î—Ä–æ—á–∫–∞ —Å—Ç—É–ø–Ω—è–º–∏", host + $"{plugin}?sort={sort}&q={q}&c=footjob"),
                    new MenuItem("–ñ–µ–Ω—Å–∫–æ–µ –¥–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ", host + $"{plugin}?sort={sort}&q={q}&c=femdom"),
                    new MenuItem("–ñ–∏—Ä–æ–±–∞—Å–∏–Ω–∞", host + $"{plugin}?sort={sort}&q={q}&c=ssbbw"),
                    new MenuItem("–ñ–æ–ø–∞", host + $"{plugin}?sort={sort}&q={q}&c=ass"),
                    new MenuItem("–ó–∞—Å—Ç—Ä—è–ª–∞", host + $"{plugin}?sort={sort}&q={q}&c=stuck"),
                    new MenuItem("–ó–Ω–∞–º–µ–Ω–∏—Ç–æ—Å—Ç—å", host + $"{plugin}?sort={sort}&q={q}&c=celebrity"),
                    new MenuItem("–ò–≥—Ä–∞", host + $"{plugin}?sort={sort}&q={q}&c=game"),
                    new MenuItem("–ò—Å—Ç–æ—Ä–∏—è", host + $"{plugin}?sort={sort}&q={q}&c=story"),
                    new MenuItem("–ö–∞—Å—Ç–∏–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=casting"),
                    new MenuItem("–ö–æ–º–∏—á–µ—Å–∫–∏–π", host + $"{plugin}?sort={sort}&q={q}&c=comic"),
                    new MenuItem("–ö–æ–Ω—á–∏–Ω–∞", host + $"{plugin}?sort={sort}&q={q}&c=cumshot"),
                    new MenuItem("–ö—Ä–µ–º–æ–≤—ã–π –ø–∏—Ä–æ–≥", host + $"{plugin}?sort={sort}&q={q}&c=creampie"),
                    new MenuItem("–õ–∞—Ç–∏–Ω–∞", host + $"{plugin}?sort={sort}&q={q}&c=latina"),
                    new MenuItem("–õ–µ—Å–±–∏—è–Ω–∫–∞", host + $"{plugin}?sort={sort}&q={q}&c=lesbian"),
                    new MenuItem("–õ–∏–∑–∞—Ç—å –∫–∏—Å–∫—É", host + $"{plugin}?sort={sort}&q={q}&c=eating-pussy"),
                    new MenuItem("–õ—é–±–∏—Ç–µ–ª—å—Å–∫–æ–µ –ø–æ—Ä–Ω–æ", host + $"{plugin}?sort={sort}&q={q}&c=amateur"),
                    new MenuItem("–ú–∞—Å—Å–∞–∂", host + $"{plugin}?sort={sort}&q={q}&c=massage"),
                    new MenuItem("–ú–µ–¥—Å–µ—Å—Ç—Ä–∞", host + $"{plugin}?sort={sort}&q={q}&c=nurse"),
                    new MenuItem("–ú–µ–∂—Ä–∞—Å–æ–≤—ã–π —Å–µ–∫—Å", host + $"{plugin}?sort={sort}&q={q}&c=interracial"),
                    new MenuItem("–ú–ò–õ–§", host + $"{plugin}?sort={sort}&q={q}&c=milf"),
                    new MenuItem("–ú–∏–ª—ã–µ", host + $"{plugin}?sort={sort}&q={q}&c=cute"),
                    new MenuItem("–ú–∏–Ω–µ—Ç", host + $"{plugin}?sort={sort}&q={q}&c=blowjob"),
                    new MenuItem("–ú–∏–Ω–∏–∞—Ç—é—Ä–Ω–∞—è", host + $"{plugin}?sort={sort}&q={q}&c=petite"),
                    new MenuItem("–ú–∏—Å—Å–∏–æ–Ω–µ—Ä—Å–∫–∞—è –ø–æ–∑–∞", host + $"{plugin}?sort={sort}&q={q}&c=missionary"),
                    new MenuItem("–ú–æ–Ω–∞—Ö–∏–Ω—è", host + $"{plugin}?sort={sort}&q={q}&c=nun"),
                    new MenuItem("–ú—É–ª—å—Ç—Ñ–∏–ª—å–º—ã", host + $"{plugin}?sort={sort}&q={q}&c=cartoon"),
                    new MenuItem("–ù–µ–≥—Ä–∏—Ç—è–Ω–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=black"),
                    new MenuItem("–ù–µ–º–µ—Ü–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=german"),
                    new MenuItem("–û—Ñ–∏—Å", host + $"{plugin}?sort={sort}&q={q}&c=office"),
                    new MenuItem("–ü–µ—Ä–≤—ã–π —Ä–∞–∑", host + $"{plugin}?sort={sort}&q={q}&c=first-time"),
                    new MenuItem("–ü–ª—è–∂", host + $"{plugin}?sort={sort}&q={q}&c=beach"),
                    new MenuItem("–ü–æ—Ä–Ω–æ –¥–ª—è –∂–µ–Ω—â–∏–Ω", host + $"{plugin}?sort={sort}&q={q}&c=porn-for-women"),
                    new MenuItem("–†–µ—Å–ª–∏–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=wrestling"),
                    new MenuItem("–†–æ–≥–æ–Ω–æ—Å—Ü—ã", host + $"{plugin}?sort={sort}&q={q}&c=cuckold"),
                    new MenuItem("–†–æ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π", host + $"{plugin}?sort={sort}&q={q}&c=romantic"),
                    new MenuItem("–°–≤–∏–Ω–≥–µ—Ä—ã", host + $"{plugin}?sort={sort}&q={q}&c=swingers"),
                    new MenuItem("–°–∫–≤–∏—Ä—Ç", host + $"{plugin}?sort={sort}&q={q}&c=squirting"),
                    new MenuItem("–°—Ç–∞—Ä–∏–∫", host + $"{plugin}?sort={sort}&q={q}&c=old-man"),
                    new MenuItem("–°—Ç–∞—Ä—ã–µ —Å –º–æ–ª–æ–¥—ã–º–∏", host + $"{plugin}?sort={sort}&q={q}&c=old-young"),
                    new MenuItem("–¢–∏–Ω–µ–π–¥–∂–µ—Ä—ã (18+)", host + $"{plugin}?sort={sort}&q={q}&c=teen"),
                    new MenuItem("–¢–æ–ª—Å—Ç—É—à–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=bbw"),
                    new MenuItem("–¢—Ä–µ–Ω–∞–∂–µ—Ä–Ω—ã–π –∑–∞–ª", host + $"{plugin}?sort={sort}&q={q}&c=gym"),
                    new MenuItem("–£–∑–∫–∞—è –∫–∏—Å–∫–∞", host + $"{plugin}?sort={sort}&q={q}&c=tight-pussy"),
                    new MenuItem("–§—Ä–∞–Ω—Ü—É–∑—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=french"),
                    new MenuItem("–§—É—Ç–∞–Ω–∞—Ä–∏", host + $"{plugin}?sort={sort}&q={q}&c=futanari"),
                    new MenuItem("–•–∞—Ä–¥–∫–æ—Ä", host + $"{plugin}?sort={sort}&q={q}&c=hardcore"),
                    new MenuItem("–•–µ–Ω–¥–∂–æ–±", host + $"{plugin}?sort={sort}&q={q}&c=handjob"),
                    new MenuItem("–•–µ–Ω—Ç–∞–π", host + $"{plugin}?sort={sort}&q={q}&c=hentai"),
                    new MenuItem("–Ø–ø–æ–Ω—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=japanese")
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }
            else if (plugin == "xmrgay")
            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem("–í—Å–µ", host + $"{plugin}?sort={sort}&q={q}"),
                    new MenuItem("Russian", host + $"{plugin}?sort={sort}&q={q}&c=russian"),
                    new MenuItem("Threesome", host + $"{plugin}?sort={sort}&q={q}&c=threesome"),
                    new MenuItem("–ê–∑–∏–∞—Ç—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=asian"),
                    new MenuItem("–ë–î–°–ú", host + $"{plugin}?sort={sort}&q={q}&c=bdsm"),
                    new MenuItem("–ë–µ–∑ –ø—Ä–µ–∑–µ—Ä–≤–∞—Ç–∏–≤–∞", host + $"{plugin}?sort={sort}&q={q}&c=bareback"),
                    new MenuItem("–ë–æ–ª—å—à–∏–µ –¥—ã—Ä–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=gaping"),
                    new MenuItem("–ë–æ–ª—å—à–æ–π —á–ª–µ–Ω", host + $"{plugin}?sort={sort}&q={q}&c=big-cock"),
                    new MenuItem("–ë—É–∫–∫–∞–∫–µ", host + $"{plugin}?sort={sort}&q={q}&c=bukkake"),
                    new MenuItem("–í–µ–±–∫–∞–º–µ—Ä–∞", host + $"{plugin}?sort={sort}&q={q}&c=webcam"),
                    new MenuItem("–í–∏–Ω—Ç–∞–∂", host + $"{plugin}?sort={sort}&q={q}&c=vintage"),
                    new MenuItem("–ì–ª–æ—Ä–∏—Ö–æ–ª", host + $"{plugin}?sort={sort}&q={q}&c=glory-hole"),
                    new MenuItem("–ì—Ä—É–ø–ø–æ–≤–æ–π —Å–µ–∫—Å", host + $"{plugin}?sort={sort}&q={q}&c=group-sex"),
                    new MenuItem("–ì—ç–Ω–≥–±—ç–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=gangbang"),
                    new MenuItem("–î–µ–¥—É—à–∫–∞", host + $"{plugin}?sort={sort}&q={q}&c=grandpa"),
                    new MenuItem("–î–∏–ª–¥–æ", host + $"{plugin}?sort={sort}&q={q}&c=dildo"),
                    new MenuItem("–ö–æ–Ω—á–∞—Ç—å –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏", host + $"{plugin}?sort={sort}&q={q}&c=cum-tribute"),
                    new MenuItem("–ö–æ–Ω—á–∏–Ω–∞", host + $"{plugin}?sort={sort}&q={q}&c=cumshot"),
                    new MenuItem("–ö—Ä–∞—Å–∞–≤—á–∏–∫", host + $"{plugin}?sort={sort}&q={q}&c=hunk"),
                    new MenuItem("–ö—Ä–µ–º–æ–≤—ã–π –ø–∏—Ä–æ–≥", host + $"{plugin}?sort={sort}&q={q}&c=creampie"),
                    new MenuItem("–ú–∞–ª–µ–Ω—å–∫–∏–π —á–ª–µ–Ω", host + $"{plugin}?sort={sort}&q={q}&c=small-cock"),
                    new MenuItem("–ú–∞—Å—Å–∞–∂", host + $"{plugin}?sort={sort}&q={q}&c=massage"),
                    new MenuItem("–ú–∞—Å—Ç—É—Ä–±–∞—Ü–∏—è", host + $"{plugin}?sort={sort}&q={q}&c=masturbation"),
                    new MenuItem("–ú–µ–¥–≤–µ–¥—å", host + $"{plugin}?sort={sort}&q={q}&c=bear"),
                    new MenuItem("–ú–µ–∂—Ä–∞—Å–æ–≤—ã–π —Å–µ–∫—Å", host + $"{plugin}?sort={sort}&q={q}&c=interracial"),
                    new MenuItem("–ú–∏–Ω–µ—Ç", host + $"{plugin}?sort={sort}&q={q}&c=blowjob"),
                    new MenuItem("–ú–æ–ª–æ–¥—ã–µ", host + $"{plugin}?sort={sort}&q={q}&c=young"),
                    new MenuItem("–ù–∞ –ø—Ä–∏—Ä–æ–¥–µ", host + $"{plugin}?sort={sort}&q={q}&c=outdoor"),
                    new MenuItem("–ù–µ–≥—Ä—ã", host + $"{plugin}?sort={sort}&q={q}&c=black"),
                    new MenuItem("–ü–∞–ø–æ—á–∫–∞", host + $"{plugin}?sort={sort}&q={q}&c=daddy"),
                    new MenuItem("–ü–ª—è–∂", host + $"{plugin}?sort={sort}&q={q}&c=beach"),
                    new MenuItem("–ü—É—Ö–ª—è—à", host + $"{plugin}?sort={sort}&q={q}&c=chubby"),
                    new MenuItem("–†–∞–∑–¥–µ–≤–∞–ª–∫–∞", host + $"{plugin}?sort={sort}&q={q}&c=locker-room"),
                    new MenuItem("–†–µ—Å—Ç–ª–∏–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=wrestling"),
                    new MenuItem("–°–µ–∫—Å –∏–≥—Ä—É—à–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=sex-toy"),
                    new MenuItem("–°–ª–∞–¥–∫–∏–π –º–∞–ª—å—á–∏–∫", host + $"{plugin}?sort={sort}&q={q}&c=twink"),
                    new MenuItem("–°–æ–ª–æ", host + $"{plugin}?sort={sort}&q={q}&c=solo"),
                    new MenuItem("–°–ø–∞–Ω–∫–∏–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=spanking"),
                    new MenuItem("–°—Ç–∞—Ä—ã–µ —Å –º–æ–ª–æ–¥—ã–º–∏", host + $"{plugin}?sort={sort}&q={q}&c=old-young"),
                    new MenuItem("–°—Ç—Ä–∏–ø—Ç–∏–∑", host + $"{plugin}?sort={sort}&q={q}&c=striptease"),
                    new MenuItem("–¢–æ–ª—Å—Ç—ã–µ", host + $"{plugin}?sort={sort}&q={q}&c=fat"),
                    new MenuItem("–¢—Ä–∞–Ω—Å–≤–µ—Å—Ç–∏—Ç—ã", host + $"{plugin}?sort={sort}&q={q}&c=crossdresser"),
                    new MenuItem("–§–∏—Å—Ç–∏–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=fisting"),
                    new MenuItem("–•–µ–Ω–¥–∂–æ–±", host + $"{plugin}?sort={sort}&q={q}&c=handjob"),
                    new MenuItem("–•–µ–Ω—Ç–∞–π", host + $"{plugin}?sort={sort}&q={q}&c=hentai"),
                    new MenuItem("–≠–º–æ–±–æ–π", host + $"{plugin}?sort={sort}&q={q}&c=emo")
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }
            else if (plugin == "xmrsml")
            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem("–í—Å–µ", host + $"{plugin}?sort={sort}&q={q}"),
                    new MenuItem("Russian", host + $"{plugin}?sort={sort}&q={q}&c=russian"),
                    new MenuItem("Cuckold", host + $"{plugin}?sort={sort}&q={q}&c=cuckold"),
                    new MenuItem("–ê–∑–∏–∞—Ç—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=asian"),
                    new MenuItem("–ë–î–°–ú", host + $"{plugin}?sort={sort}&q={q}&c=bdsm"),
                    new MenuItem("–ë–µ–∑ –ø—Ä–µ–∑–µ—Ä–≤–∞—Ç–∏–≤–∞", host + $"{plugin}?sort={sort}&q={q}&c=bareback"),
                    new MenuItem("–ë–ª–æ–Ω–¥–∏–Ω–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=blonde"),
                    new MenuItem("–ë–æ–ª—å—à–∏–µ –∂–æ–ø—ã", host + $"{plugin}?sort={sort}&q={q}&c=big-ass"),
                    new MenuItem("–ë–æ–ª—å—à–æ–π —á–ª–µ–Ω", host + $"{plugin}?sort={sort}&q={q}&c=big-cock"),
                    new MenuItem("–í–µ–±–∫–∞–º–µ—Ä–∞", host + $"{plugin}?sort={sort}&q={q}&c=webcam"),
                    new MenuItem("–í–∏–Ω—Ç–∞–∂", host + $"{plugin}?sort={sort}&q={q}&c=vintage"),
                    new MenuItem("–ì—Ä—É–ø–ø–æ–≤–æ–π —Å–µ–∫—Å", host + $"{plugin}?sort={sort}&q={q}&c=group-sex"),
                    new MenuItem("–ì—ç–Ω–≥–±—ç–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=gangbang"),
                    new MenuItem("–î–æ–º–∞—à–Ω–µ–µ", host + $"{plugin}?sort={sort}&q={q}&c=homemade"),
                    new MenuItem("–ó–æ–ª–æ—Ç–æ–π –¥–æ–∂–¥—å", host + $"{plugin}?sort={sort}&q={q}&c=pissing"),
                    new MenuItem("–ö—Ä–µ–º–æ–≤—ã–π –ø–∏—Ä–æ–≥", host + $"{plugin}?sort={sort}&q={q}&c=creampie"),
                    new MenuItem("–õ–∞—Ç–µ–∫—Å", host + $"{plugin}?sort={sort}&q={q}&c=latex"),
                    new MenuItem("–õ–∞—Ç–∏–Ω–∞", host + $"{plugin}?sort={sort}&q={q}&c=latina"),
                    new MenuItem("–õ–µ–¥–∏–±–æ–π", host + $"{plugin}?sort={sort}&q={q}&c=ladyboy"),
                    new MenuItem("–õ–æ–≤—É—à–∫–∞", host + $"{plugin}?sort={sort}&q={q}&c=trap"),
                    new MenuItem("–õ—é–±–∏—Ç–µ–ª—å—Å–∫–æ–µ –ø–æ—Ä–Ω–æ", host + $"{plugin}?sort={sort}&q={q}&c=amateur"),
                    new MenuItem("–ú–∞–ª–µ–Ω—å–∫–∏–µ —Å–∏—Å—å–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=small-tits"),
                    new MenuItem("–ú–∞—Å—Ç—É—Ä–±–∞—Ü–∏—è", host + $"{plugin}?sort={sort}&q={q}&c=masturbation"),
                    new MenuItem("–ú–µ–∂—Ä–∞—Å–æ–≤—ã–π —Å–µ–∫—Å", host + $"{plugin}?sort={sort}&q={q}&c=interracial"),
                    new MenuItem("–ú–∏–Ω–µ—Ç", host + $"{plugin}?sort={sort}&q={q}&c=blowjob"),
                    new MenuItem("–ú–∏–Ω–∏–∞—Ç—é—Ä–Ω–∞—è", host + $"{plugin}?sort={sort}&q={q}&c=petite"),
                    new MenuItem("–ù–∞ –ø—Ä–∏—Ä–æ–¥–µ", host + $"{plugin}?sort={sort}&q={q}&c=outdoor"),
                    new MenuItem("–ù–∏–∂–Ω–µ–µ –±–µ–ª—å–µ", host + $"{plugin}?sort={sort}&q={q}&c=lingerie"),
                    new MenuItem("–û—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞", host + $"{plugin}?sort={sort}&q={q}&c=pov"),
                    new MenuItem("–ü–∞—Ä–µ–Ω—å —Ç—Ä–∞—Ö–∞–µ—Ç —Ç—Ä–∞–Ω—Å–∞", host + $"{plugin}?sort={sort}&q={q}&c=guy-fucks-shemale"),
                    new MenuItem("–ü–æ–¥—Ä–æ—Å—Ç–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=teen"),
                    new MenuItem("–†—ã–∂–∏–µ", host + $"{plugin}?sort={sort}&q={q}&c=redhead"),
                    new MenuItem("–°–µ–∫—Å –≤—Ç—Ä–æ–µ–º", host + $"{plugin}?sort={sort}&q={q}&c=threesome"),
                    new MenuItem("–°–µ–∫—Å –∏–≥—Ä—É—à–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=sex-toy"),
                    new MenuItem("–°–æ–ª–æ", host + $"{plugin}?sort={sort}&q={q}&c=solo"),
                    new MenuItem("–¢–∞—Ç—É–∏—Ä–æ–≤–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=tattoo"),
                    new MenuItem("–¢–æ–ª—Å—Ç—É—à–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=bbw"),
                    new MenuItem("–¢—Ä–∞–Ω—Å —Ç—Ä–∞—Ö–∞–µ—Ç –¥–µ–≤—É—à–∫—É", host + $"{plugin}?sort={sort}&q={q}&c=shemale-fucks-girl"),
                    new MenuItem("–¢—Ä–∞–Ω—Å —Ç—Ä–∞—Ö–∞–µ—Ç –ø–∞—Ä–Ω—è", host + $"{plugin}?sort={sort}&q={q}&c=shemale-fucks-guy"),
                    new MenuItem("–¢—Ä–∞–Ω—Å —Ç—Ä–∞—Ö–∞–µ—Ç —Ç—Ä–∞–Ω—Å–∞", host + $"{plugin}?sort={sort}&q={q}&c=shemale-fucks-shemale"),
                    new MenuItem("–¢—Ä–∞–Ω—Å–≤–µ—Å—Ç–∏—Ç", host + $"{plugin}?sort={sort}&q={q}&c=transgender"),
                    new MenuItem("–§–µ—Ç–∏—à", host + $"{plugin}?sort={sort}&q={q}&c=fetish"),
                    new MenuItem("–•–∞—Ä–¥–∫–æ—Ä", host + $"{plugin}?sort={sort}&q={q}&c=hardcore"),
                    new MenuItem("–•–µ–Ω–¥–∂–æ–±", host + $"{plugin}?sort={sort}&q={q}&c=handjob"),
                    new MenuItem("–•–µ–Ω—Ç–∞–π", host + $"{plugin}?sort={sort}&q={q}&c=hentai"),
                    new MenuItem("–•–æ—Ä–æ—à–µ–Ω—å–∫–∞—è", host + $"{plugin}?sort={sort}&q={q}&c=pretty"),
                    new MenuItem("–ß–µ—Ä–Ω–æ–∫–æ–∂–∏–µ", host + $"{plugin}?sort={sort}&q={q}&c=black"),
                    new MenuItem("–ß—É–ª–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=stockings"),
                    new MenuItem("–Ø–ø–æ–Ω—Å–∫–æ–µ –ø–æ—Ä–Ω–æ", host + $"{plugin}?sort={sort}&q={q}&c=japanese")
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }

            return menu;
        }

        async public static ValueTask<StreamItem> StreamLinks(string uri, string host, string url, Func<string, ValueTask<string>> onresult)
        {
            if (string.IsNullOrEmpty(url))
                return null;

            string html = await onresult.Invoke($"{host}/{url}");
            if (html == null)
                return null;

            string stream_link = Regex.Match(html, "rel=\"preload\" href=\"([^\"]+)\"").Groups[1].Value.Replace("\\", "");
            if (!stream_link.Contains(".m3u"))
                return null;

            if (stream_link.StartsWith("/"))
                stream_link = host + stream_link;

            return new StreamItem()
            {
                qualitys = new Dictionary<string, string>()
                {
                    ["auto"] = stream_link
                },
                recomends = Playlist(uri, html)
            };
        }
    }
}

```

## File: Shared/Engine/SISI/EbalovoTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class EbalovoTo
    {
        public static ValueTask<string> InvokeHtml(string host, string search, string sort, string c, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = $"{host}/";

            if (!string.IsNullOrWhiteSpace(search))
            {
                url += $"search/{HttpUtility.UrlEncode(search)}/";
            }
            else
            {
                if (!string.IsNullOrEmpty(c))
                {
                    url += $"porno/{c}";

                    if (sort is "porno-online" or "xxx-top")
                        url += $"-rating";

                    url += "/";
                }
                else
                {
                    if (!string.IsNullOrEmpty(sort))
                        url += $"{sort}/";
                }
            }

            if (pg > 1)
                url += $"{pg}/";

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("<div class=\"item\">");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows)
            {
                if (!row.Contains("<div class=\"item-info\">"))
                    continue;

                string link = Regex.Match(row, "<a href=\"https?://[^/]+/(video/[^\"]+)\"").Groups[1].Value;
                string title = Regex.Match(row, "<div class=\"item-title\">([^<]+)</div>").Groups[1].Value;

                if (!string.IsNullOrWhiteSpace(title) && !string.IsNullOrWhiteSpace(link))
                {
                    string duration = Regex.Match(row, " data-eb=\"([^;\"]+);").Groups[1].Value.Trim();
                    var img = Regex.Match(row, "( )src=\"(([^\"]+)/[0-9]+.jpg)\"").Groups;
                    if (string.IsNullOrWhiteSpace(img[3].Value) || img[2].Value.Contains("load.png"))
                        img = Regex.Match(row, "(data-srcset|data-src|srcset)=\"([^\"]+/[0-9]+.jpg)\"").Groups;

                    var pl = new PlaylistItem()
                    {
                        name = title.Trim(),
                        video = $"{uri}?uri={link}",
                        picture = img[2].Value,
                        time = duration,
                        json = true,
                        related = true,
                        bookmark = new Bookmark()
                        {
                            site = "elo",
                            href = link,
                            image = img[2].Value
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string sort, string c)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";
            string url = host + "elo";

            var menu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = url,
                },
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrEmpty(sort) ? "–Ω–æ–≤–∏–Ω–∫–∏" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–æ–≤–∏–Ω–∫–∏",
                            playlist_url = url + $"?c={c}"
                        },
                        new MenuItem()
                        {
                            title = "–õ—É—á—à–µ–µ",
                            playlist_url = url + $"?c={c}&sort=porno-online"
                        },
                        new MenuItem()
                        {
                            title = "–ü–æ–ø—É–ª—è—Ä–Ω–æ–µ",
                            playlist_url = url + $"?c={c}&sort=xxx-top"
                        }
                    }
                }
            };


            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–í—Å–µ",
                        playlist_url = url + $"?sort={sort}"
                    },
                    new MenuItem()
                    {
                        title = "CFNM",
                        playlist_url = url + $"?sort={sort}&c=cfnm"
                    },
                    new MenuItem()
                    {
                        title = "pov",
                        playlist_url = url + $"?sort={sort}&c=pov"
                    },
                    new MenuItem()
                    {
                        title = "–ê–Ω–∞–ª",
                        playlist_url = url + $"?sort={sort}&c=anal-videos"
                    },
                    new MenuItem()
                    {
                        title = "–ê–Ω–∞–ª—å–Ω–∞—è –¥—ã—Ä–∞",
                        playlist_url = url + $"?sort={sort}&c=gape"
                    },
                    new MenuItem()
                    {
                        title = "–ê–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–±–∫–∞",
                        playlist_url = url + $"?sort={sort}&c=butt-plug-porn"
                    },
                    new MenuItem()
                    {
                        title = "–ë–î–°–ú",
                        playlist_url = url + $"?sort={sort}&c=bdsm-porn"
                    },
                    new MenuItem()
                    {
                        title = "–ë–ª–æ–Ω–¥–∏–Ω–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=blonde"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ –∂–æ–ø—ã",
                        playlist_url = url + $"?sort={sort}&c=big-ass"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ —Å–∏—Å—å–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=big-tits"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ —á–ª–µ–Ω—ã",
                        playlist_url = url + $"?sort={sort}&c=big-cock"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–æ–π —á—ë—Ä–Ω—ã–π —á–ª–µ–Ω",
                        playlist_url = url + $"?sort={sort}&c=bbc"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–Ω–¥–∞–∂",
                        playlist_url = url + $"?sort={sort}&c=bondage"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ—Å—Å",
                        playlist_url = url + $"?sort={sort}&c=boss"
                    },
                    new MenuItem()
                    {
                        title = "–ë—Ä–∏—Ç—ã–µ –ø–∏—Å—å–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=shaved-pussy"
                    },
                    new MenuItem()
                    {
                        title = "–ë—Ä—é–Ω–µ—Ç–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=a1-brunette"
                    },
                    new MenuItem()
                    {
                        title = "–ë—É–∫–∫–∞–∫–µ",
                        playlist_url = url + $"?sort={sort}&c=bukkake"
                    },
                    new MenuItem()
                    {
                        title = "–í –≥–æ–ª—å—Ñ–∞—Ö",
                        playlist_url = url + $"?sort={sort}&c=knee-socks"
                    },
                    new MenuItem()
                    {
                        title = "–í –∫–ª—É–±–µ",
                        playlist_url = url + $"?sort={sort}&c=club"
                    },
                    new MenuItem()
                    {
                        title = "–í –∫—Ä–∞—Å–∏–≤–æ–º –±–µ–ª—å–µ",
                        playlist_url = url + $"?sort={sort}&c=lingerie"
                    },
                    new MenuItem()
                    {
                        title = "–í –º–∞–π–∫–µ",
                        playlist_url = url + $"?sort={sort}&c=shirt"
                    },
                    new MenuItem()
                    {
                        title = "–í –º–∞—Å–ª–µ",
                        playlist_url = url + $"?sort={sort}&c=oiled"
                    },
                    new MenuItem()
                    {
                        title = "–í –º–∞—à–∏–Ω–µ",
                        playlist_url = url + $"?sort={sort}&c=car-porn"
                    },
                    new MenuItem()
                    {
                        title = "–í –æ—á–∫–∞—Ö",
                        playlist_url = url + $"?sort={sort}&c=glasses"
                    },
                    new MenuItem()
                    {
                        title = "–í –ø—Ä–µ–∑–µ—Ä–≤–∞—Ç–∏–≤–µ",
                        playlist_url = url + $"?sort={sort}&c=condom"
                    },
                    new MenuItem()
                    {
                        title = "–í —Å–ø–∞–ª—å–Ω–µ",
                        playlist_url = url + $"?sort={sort}&c=bedroom"
                    },
                    new MenuItem()
                    {
                        title = "–í —Å–ø–æ—Ä—Ç–∑–∞–ª–µ",
                        playlist_url = url + $"?sort={sort}&c=gym-porn"
                    },
                    new MenuItem()
                    {
                        title = "–í —á—É–ª–∫–∞—Ö",
                        playlist_url = url + $"?sort={sort}&c=stockings"
                    },
                    new MenuItem()
                    {
                        title = "–í–µ–±–∫–∞–º–µ—Ä–∞",
                        playlist_url = url + $"?sort={sort}&c=webcam"
                    },
                    new MenuItem()
                    {
                        title = "–í–æ–ª–æ—Å–∞—Ç–∞—è –ø–∏–∑–¥–∞",
                        playlist_url = url + $"?sort={sort}&c=hairy"
                    },
                    new MenuItem()
                    {
                        title = "–ì–∏–±–∫–∏–µ",
                        playlist_url = url + $"?sort={sort}&c=flexible"
                    },
                    new MenuItem()
                    {
                        title = "–ì–ª–æ—Ç–∞–µ—Ç —Å–ø–µ—Ä–º—É",
                        playlist_url = url + $"?sort={sort}&c=cum-swallow"
                    },
                    new MenuItem()
                    {
                        title = "–ì–æ—Ä–Ω–∏—á–Ω–∞—è",
                        playlist_url = url + $"?sort={sort}&c=maid"
                    },
                    new MenuItem()
                    {
                        title = "–ì–æ—Å–ø–æ–∂–∞",
                        playlist_url = url + $"?sort={sort}&c=mistress"
                    },
                    new MenuItem()
                    {
                        title = "–ì—Ä—É–ø–ø–æ–≤—É—Ö–∞",
                        playlist_url = url + $"?sort={sort}&c=group-porno"
                    },
                    new MenuItem()
                    {
                        title = "–î–∏–ª–¥–æ",
                        playlist_url = url + $"?sort={sort}&c=dildo"
                    },
                    new MenuItem()
                    {
                        title = "–î–ª–∏–Ω–Ω—ã–µ –≤–æ–ª–æ—Å—ã",
                        playlist_url = url + $"?sort={sort}&c=long-hair"
                    },
                    new MenuItem()
                    {
                        title = "–î–æ–∫—Ç–æ—Ä",
                        playlist_url = url + $"?sort={sort}&c=doctor"
                    },
                    new MenuItem()
                    {
                        title = "–î–æ–º–∞—à–Ω–µ–µ –ø–æ—Ä–Ω–æ",
                        playlist_url = url + $"?sort={sort}&c=amateur"
                    },
                    new MenuItem()
                    {
                        title = "–î—Ä–æ—á–∏—Ç –ø–∞—Ä–Ω—é",
                        playlist_url = url + $"?sort={sort}&c=handjob"
                    },
                    new MenuItem()
                    {
                        title = "–ï–≤—Ä–æ",
                        playlist_url = url + $"?sort={sort}&c=a1-europe"
                    },
                    new MenuItem()
                    {
                        title = "–ñ–µ—Å—Ç—å",
                        playlist_url = url + $"?sort={sort}&c=fun"
                    },
                    new MenuItem()
                    {
                        title = "–ñ–ú–ñ",
                        playlist_url = url + $"?sort={sort}&c=a1-threesome"
                    },
                    new MenuItem()
                    {
                        title = "–ò–∑–º–µ–Ω–∞",
                        playlist_url = url + $"?sort={sort}&c=cheating"
                    },
                    new MenuItem()
                    {
                        title = "–ò–Ω—Ç–∏–º–Ω—ã–µ —Å—Ç—Ä–∏–∂–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=intimate-haircut"
                    },
                    new MenuItem()
                    {
                        title = "–ö–ª—è–ø –≤ —Ä–æ—Ç",
                        playlist_url = url + $"?sort={sort}&c=gag"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ—Ä–æ—Ç–∫–∏–µ –≤–æ–ª–æ—Å—ã",
                        playlist_url = url + $"?sort={sort}&c=short-hair"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ—Å–∏—á–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=braids"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä–∞—Å–∏–≤–∞—è –≥—Ä—É–¥—å",
                        playlist_url = url + $"?sort={sort}&c=nice-tits-porn"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä–∞—Å–∏–≤—ã–µ",
                        playlist_url = url + $"?sort={sort}&c=a1-babe"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä–∞—Å–∏–≤—ã–µ –ø–æ–ø–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=ass"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä–∞—Å–∏–≤—ã–π —Å–µ–∫—Å",
                        playlist_url = url + $"?sort={sort}&c=beautiful"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä—É–ø–Ω—ã–º –ø–ª–∞–Ω–æ–º",
                        playlist_url = url + $"?sort={sort}&c=closeup"
                    },
                    new MenuItem()
                    {
                        title = "–ö—É–∫–æ–ª–¥",
                        playlist_url = url + $"?sort={sort}&c=cuckold"
                    },
                    new MenuItem()
                    {
                        title = "–ö—É–Ω–∏",
                        playlist_url = url + $"?sort={sort}&c=cunni"
                    },
                    new MenuItem()
                    {
                        title = "–õ–µ—Å–±–∏",
                        playlist_url = url + $"?sort={sort}&c=lesbi-porno"
                    },
                    new MenuItem()
                    {
                        title = "–õ–∏–∂–µ—Ç –ø–æ–ø—É",
                        playlist_url = url + $"?sort={sort}&c=ass-licking-porn"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞—Å—Å–∞–∂",
                        playlist_url = url + $"?sort={sort}&c=massage"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞—Å—Ç—É—Ä–±–∞—Ü–∏—è",
                        playlist_url = url + $"?sort={sort}&c=a1-masturbation"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞—á–µ—Ö–∞",
                        playlist_url = url + $"?sort={sort}&c=a1-stepmom"
                    },
                    new MenuItem()
                    {
                        title = "–ú–µ–¥—Å–µ—Å—Ç—Ä–∞",
                        playlist_url = url + $"?sort={sort}&c=nurse"
                    },
                    new MenuItem()
                    {
                        title = "–ú–µ–∂–¥—É —Å–∏—Å–µ–∫",
                        playlist_url = url + $"?sort={sort}&c=tits-fuck"
                    },
                    new MenuItem()
                    {
                        title = "–ú–µ–∂—Ä–∞—Å—Å–æ–≤–æ–µ",
                        playlist_url = url + $"?sort={sort}&c=interracial"
                    },
                    new MenuItem()
                    {
                        title = "–ú–ñ–ú",
                        playlist_url = url + $"?sort={sort}&c=2man-woman"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∏–Ω–µ—Ç",
                        playlist_url = url + $"?sort={sort}&c=blowjob"
                    },
                    new MenuItem()
                    {
                        title = "–ú–æ–ª–æ–¥—ã–µ",
                        playlist_url = url + $"?sort={sort}&c=teen"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞ –∫–∞–±–ª—É–∫–∞—Ö",
                        playlist_url = url + $"?sort={sort}&c=heels"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞ –ø–ª—è–∂–µ",
                        playlist_url = url + $"?sort={sort}&c=beach"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞ –ø—Ä–∏—Ä–æ–¥–µ",
                        playlist_url = url + $"?sort={sort}&c=outdoor-sex"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞ –ø—É–±–ª–∏–∫–µ",
                        playlist_url = url + $"?sort={sort}&c=a1-public"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞ —Å—Ç–æ–ª–µ",
                        playlist_url = url + $"?sort={sort}&c=table"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞–µ–∑–¥–Ω–∏—Ü–∞",
                        playlist_url = url + $"?sort={sort}&c=cowgirl"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞—Ä—É—á–Ω–∏–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=handcuffs"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞—Ç—É—Ä–∞–ª—å–Ω—ã–µ —Å–∏—Å—å–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=a1-natural-tits"
                    },
                    new MenuItem()
                    {
                        title = "–ù–µ–≥—Ä–∏—Ç—è–Ω–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=black-girl"
                    },
                    new MenuItem()
                    {
                        title = "–ù–µ–≥—Ä—ã",
                        playlist_url = url + $"?sort={sort}&c=black"
                    },
                    new MenuItem()
                    {
                        title = "–ù–µ–≥—Ä—ã —Å –±–ª–æ–Ω–¥–∏–Ω–∫–∞–º–∏",
                        playlist_url = url + $"?sort={sort}&c=blacks-on-blondes"
                    },
                    new MenuItem()
                    {
                        title = "–ù–µ–∫—Ä–∞—Å–∏–≤–∞—è –≥—Ä—É–¥—å",
                        playlist_url = url + $"?sort={sort}&c=ugly-tits"
                    },
                    new MenuItem()
                    {
                        title = "–ù—è–Ω—è",
                        playlist_url = url + $"?sort={sort}&c=babysitter"
                    },
                    new MenuItem()
                    {
                        title = "–ü–∏—Å–∞–µ—Ç",
                        playlist_url = url + $"?sort={sort}&c=pissing"
                    },
                    new MenuItem()
                    {
                        title = "–ü–ª—ë—Ç–∫–∞",
                        playlist_url = url + $"?sort={sort}&c=whip"
                    },
                    new MenuItem()
                    {
                        title = "–ü–æ–¥ –≤–æ–¥–æ–π",
                        playlist_url = url + $"?sort={sort}&c=underwater"
                    },
                    new MenuItem()
                    {
                        title = "–ü–æ–¥—á–∏–Ω–µ–Ω–∏–µ",
                        playlist_url = url + $"?sort={sort}&c=submission"
                    },
                    new MenuItem()
                    {
                        title = "–ü–æ–∑–∞ 69",
                        playlist_url = url + $"?sort={sort}&c=69"
                    },
                    new MenuItem()
                    {
                        title = "–ü–æ—Ä–Ω–æ –∑—Ä–µ–ª—ã—Ö",
                        playlist_url = url + $"?sort={sort}&c=milfs"
                    },
                    new MenuItem()
                    {
                        title = "–†–µ—Å–ª–∏–Ω–≥",
                        playlist_url = url + $"?sort={sort}&c=wrestling"
                    },
                    new MenuItem()
                    {
                        title = "–†—É—Å—Å–∫–æ–µ –¥–æ–º–∞—à–Ω–µ–µ –ø–æ—Ä–Ω–æ",
                        playlist_url = url + $"?sort={sort}&c=russian-amateur"
                    },
                    new MenuItem()
                    {
                        title = "–†—É—Å—Å–∫–æ–µ –ø–æ—Ä–Ω–æ",
                        playlist_url = url + $"?sort={sort}&c=ruporn"
                    },
                    new MenuItem()
                    {
                        title = "–†—ã–∂–∏–µ",
                        playlist_url = url + $"?sort={sort}&c=redhead"
                    },
                    new MenuItem()
                    {
                        title = "–° –ª–∞—Ç–∏–Ω–∫–∞–º–∏",
                        playlist_url = url + $"?sort={sort}&c=latina-sex"
                    },
                    new MenuItem()
                    {
                        title = "–° –Ω–µ–≤–µ—Å—Ç–æ–π",
                        playlist_url = url + $"?sort={sort}&c=bride"
                    },
                    new MenuItem()
                    {
                        title = "–° —Ç—Ä–µ–Ω–µ—Ä–æ–º",
                        playlist_url = url + $"?sort={sort}&c=couch-porn"
                    },
                    new MenuItem()
                    {
                        title = "–°–≤–∏–Ω–≥–µ—Ä—ã",
                        playlist_url = url + $"?sort={sort}&c=swingers"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Ä–µ—Ç–∞—Ä—à–∞",
                        playlist_url = url + $"?sort={sort}&c=secretary-porn"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å –≤ –æ–±—â–∞–≥–µ",
                        playlist_url = url + $"?sort={sort}&c=dorm-porn"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å –≤ –æ—Ñ–∏—Å–µ",
                        playlist_url = url + $"?sort={sort}&c=office-sex"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å –Ω–∞ –∫—É—Ö–Ω–µ",
                        playlist_url = url + $"?sort={sort}&c=kitchen"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å —Å –±—ã–≤—à–µ–π",
                        playlist_url = url + $"?sort={sort}&c=exgfs"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å-–∏–≥—Ä—É—à–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=sex-toys"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å-–º–∞—à–∏–Ω–∞",
                        playlist_url = url + $"?sort={sort}&c=sex-machines"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å-—Ä–∞–±—ã–Ω—è",
                        playlist_url = url + $"?sort={sort}&c=slave"
                    },
                    new MenuItem()
                    {
                        title = "–°–∏–ª–∏–∫–æ–Ω–æ–≤—ã–µ —Å–∏—Å—å–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=silicone-tits"
                    },
                    new MenuItem()
                    {
                        title = "–°–∫–≤–∏—Ä—Ç",
                        playlist_url = url + $"?sort={sort}&c=squirting"
                    },
                    new MenuItem()
                    {
                        title = "–°–æ–ª–æ",
                        playlist_url = url + $"?sort={sort}&c=a1-solo"
                    },
                    new MenuItem()
                    {
                        title = "–°–ø–µ—Ä–º–∞ –≤—ã—Ç–µ–∫–∞–µ—Ç",
                        playlist_url = url + $"?sort={sort}&c=creampie"
                    },
                    new MenuItem()
                    {
                        title = "–°–ø–µ—Ä–º–∞ –Ω–∞ –≥—Ä—É–¥–∏",
                        playlist_url = url + $"?sort={sort}&c=cum-on-tits"
                    },
                    new MenuItem()
                    {
                        title = "–°–ø–µ—Ä–º–∞ –Ω–∞ –ª–∏—Ü–µ",
                        playlist_url = url + $"?sort={sort}&c=facial"
                    },
                    new MenuItem()
                    {
                        title = "–°–ø–µ—Ä–º–∞ –Ω–∞ –Ω–æ–≥–∞—Ö",
                        playlist_url = url + $"?sort={sort}&c=sperma-na-nogah"
                    },
                    new MenuItem()
                    {
                        title = "–°–ø–µ—Ä–º–∞ –Ω–∞ –ø–∏–∑–¥–µ",
                        playlist_url = url + $"?sort={sort}&c=cum-on-pussy"
                    },
                    new MenuItem()
                    {
                        title = "–°–ø–µ—Ä–º–∞ –Ω–∞ –ø–æ–ø–µ",
                        playlist_url = url + $"?sort={sort}&c=cum-on-ass"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç–∞—Ä—ã–µ —Å –º–æ–ª–æ–¥—ã–º–∏",
                        playlist_url = url + $"?sort={sort}&c=old-and-young"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç—Ä–∞–ø–æ–Ω",
                        playlist_url = url + $"?sort={sort}&c=strapon"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç—Ä–∏–ø—Ç–∏–∑",
                        playlist_url = url + $"?sort={sort}&c=strip"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç—É–¥–µ–Ω—Ç–∫–∞",
                        playlist_url = url + $"?sort={sort}&c=schoolgirls"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç—É–¥–µ–Ω—Ç—ã",
                        playlist_url = url + $"?sort={sort}&c=students"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç—é–∞—Ä–¥–µ—Å—Å–∞",
                        playlist_url = url + $"?sort={sort}&c=styuardessa"
                    },
                    new MenuItem()
                    {
                        title = "–¢—Ä–∞—Ö",
                        playlist_url = url + $"?sort={sort}&c=trah"
                    },
                    new MenuItem()
                    {
                        title = "–£—á–∏—Ç —Ç—Ä–∞—Ö–∞—Ç—å—Å—è",
                        playlist_url = url + $"?sort={sort}&c=teaching"
                    },
                    new MenuItem()
                    {
                        title = "–£—á–∏—Ç–µ–ª—å",
                        playlist_url = url + $"?sort={sort}&c=teacher"
                    },
                    new MenuItem()
                    {
                        title = "–£—á–∏—Ç–µ–ª—å–Ω–∏—Ü–∞",
                        playlist_url = url + $"?sort={sort}&c=teacher-milf"
                    },
                    new MenuItem()
                    {
                        title = "–§—É—Ç—Ñ–µ—Ç–∏—à",
                        playlist_url = url + $"?sort={sort}&c=foot-fetish"
                    },
                    new MenuItem()
                    {
                        title = "–•—É–¥—ã–µ",
                        playlist_url = url + $"?sort={sort}&c=skinny-porn"
                    },
                    new MenuItem()
                    {
                        title = "–ß–µ—à—Å–∫–æ–µ –ø–æ—Ä–Ω–æ",
                        playlist_url = url + $"?sort={sort}&c=czech-porn"
                    },
                    new MenuItem()
                    {
                        title = "–ß–ª–µ–Ω –∏–∑ –¥—ã—Ä–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=gloryhole-porn"
                    },
                    new MenuItem()
                    {
                        title = "–≠—Ä–æ—Ç–∏–∫–∞",
                        playlist_url = url + $"?sort={sort}&c=erotic"
                    }
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }

            return menu;
        }

        async public static ValueTask<StreamItem> StreamLinks(string uri, string host, string url, Func<string, ValueTask<string>> onresult, Func<string, ValueTask<string>> onlocation = null)
        {
            if (string.IsNullOrEmpty(url))
                return null;

            string html = await onresult.Invoke($"{host}/{url}");
            if (html == null)
                return null;

            string stream_link = null;

            foreach (string q in new string[] { "video_alt_url", "video_url" })
            {
                stream_link = Regex.Match(html, $"{q}:([\t ]+)?('|\")(?<link>[^\"']+)").Groups["link"].Value;
                if (!string.IsNullOrEmpty(stream_link))
                    break;
            }

            if (string.IsNullOrEmpty(stream_link))
                return null;

            if (onlocation != null)
            {
                string location = await onlocation.Invoke(stream_link);
                if (location == null || stream_link == location || location.Contains("_file/"))
                    return null;

                stream_link = location;
            }

            return new StreamItem()
            {
                qualitys = new Dictionary<string, string>()
                {
                    ["auto"] = stream_link
                },
                recomends = Playlist(uri, html)
            };
        }
    }
}

```

## File: Shared/Engine/SISI/PornHubTo.cs
```
Ôªøusing HtmlAgilityPack;
using Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class PornHubTo
    {
        public static ValueTask<string> InvokeHtml(string host, string plugin, string search, string model, string sort, int c, string hd, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = $"{host}/";

            if (!string.IsNullOrEmpty(search))
            {
                url += $"video/search?search={HttpUtility.UrlEncode(search)}";

                if (!string.IsNullOrEmpty(sort))
                    url += $"&o={sort}";
            }
            else if (!string.IsNullOrEmpty(model))
            {
                if (model.StartsWith("pornstar/"))
                    url += $"{model}/videos/upload";
                else
                    url += $"model/{model}/videos";
            }
            else
            {
                switch (plugin ?? "")
                {
                    case "phubgay":
                        url += "gay/video";
                        break;
                    case "phubsml":
                        url += "transgender";
                        break;
                    default:
                        url += "video";
                        break;
                }

                if (!string.IsNullOrEmpty(sort))
                    url += $"?o={sort}";

                if (!string.IsNullOrEmpty(hd))
                    url += (url.Contains("?") ? "&" : "?") + $"hd={hd}";

                if (c > 0)
                    url += (url.Contains("?") ? "&" : "?") + $"c={c}";
            }

            if (pg > 1)
                url += $"{(url.Contains("?") ? "&" : "?")}page={pg}";

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string video_uri, string list_uri, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null, bool related = false, bool prem = false, bool IsModel_page = false)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            string videoCategory = null;

            var doc = new HtmlDocument();
            doc.LoadHtml(html);
            var node = doc.DocumentNode;

            if (related)
            {
                videoCategory = node.SelectSingleNode("//*[@id='relatedVideosListing' or @id='relatedVideos']")?.InnerHtml;
            }
            else if (html.Contains("id=\"videoCategory\""))
            {
                videoCategory = node.SelectSingleNode("//*[@id='videoCategory']")?.InnerHtml;
            }
            else if (html.Contains("videoList clearfix browseVideo-tabSplit"))
            {
                var ids = html.Split("videoList clearfix browseVideo-tabSplit");
                if (ids.Length > 1)
                    videoCategory = ids[1].Split("<h2>Languages</h2>")[0].Split("pageHeader")[0];
            }
            else
            {
                videoCategory = node.SelectSingleNode("//*[@id='videoSearchResult' or @id='mostRecentVideosSection' or @id='moreData' or @id='content-tv-container' or @id='lazyVids']")?.InnerHtml;
            }

            if (videoCategory == null)
                return new List<PlaylistItem>();

            ModelItem model = null;
            if (IsModel_page) 
            {
                string name = Regex.Match(html, "itemprop=\"name\">([\r\n\t ]+)?([^<]+)</h1>").Groups[2].Value.Trim();
                string href = Regex.Match(html, "rel=\"canonical\" href=\"(https?://[^/]+)?/model/([^/]+)/").Groups[2].Value;

                if (!string.IsNullOrEmpty(name) && !string.IsNullOrEmpty(href))
                {
                    model = new ModelItem()
                    {
                        name = name,
                        uri = list_uri + (list_uri.Contains("?") ? "&" : "?") + $"model={href}",
                    };
                }
            }

            string splitkey = videoCategory.Contains("pcVideoListItem ") ? "pcVideoListItem " : videoCategory.Contains("data-video-segment") ? "data-video-segment" : videoCategory.Contains("<li data-id=") ? "<li data-id=" : "<li id=";

            var rows = videoCategory.Split(splitkey);
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                if (row.Contains("brand__badge") || row.Contains("private-vid-title"))
                    continue;

                string m(string pattern, int index = 1)
                {
                    string res = Regex.Match(row, pattern).Groups[index].Value;
                    if (string.IsNullOrWhiteSpace(res))
                        return null;

                    return res;
                }

                string vkey = m("(-|_)vkey=\"([^\"]+)\"", 2) ?? m("viewkey=([^\"]+)\"");
                if (vkey == null)
                    continue;

                string title = m("href=\"/[^\"]+\" title=\"([^\"]+)\"") ?? m("class=\"videoTitle\">([^<]+)<") ?? m("href=\"/view_[^\"]+\" onclick=[^>]+>([^<]+)<");
                if (title == null)
                    continue;

                string img = m("data-mediumthumb=\"(https?://[^\"]+)\"") ?? m("data-path=\"(https?://[^\"]+)\"")?.Replace("{index}", "3") ?? m("<img src=\"([^\"]+)\"");
                if (img == null)
                    continue;

                if (!IsModel_page)
                {
                    model = null;
                    var gmodel = Regex.Match(row, "href=\"/model/([^\"]+)\"[^>]+>([^<]+)<");
                    if (string.IsNullOrEmpty(gmodel.Groups[1].Value))
                        gmodel = Regex.Match(row, "href=\"/(pornstar/[^\"]+)\"[^>]+>([^<]+)<");

                    if (!string.IsNullOrEmpty(gmodel.Groups[1].Value))
                    {
                        model = new ModelItem()
                        {
                            name = gmodel.Groups[2].Value,
                            uri = list_uri + (list_uri.Contains("?") ? "&" : "?") + $"model={gmodel.Groups[1].Value}",
                        };
                    }
                }

                var pl = new PlaylistItem()
                {
                    name = title,
                    video = $"{video_uri}?vkey={vkey}",
                    model = model,
                    picture = img,
                    preview = m("data-mediabook=\"(https?://[^\"]+)\"") ?? m("data-webm=\"(https?://[^\"]+)\""),
                    time = m("<var class=\"duration\">([^<]+)</var>") ?? m("class=\"time\">([^<]+)<") ?? m("class=\"videoDuration floatLeft\">([^<]+)<") ?? m("time\">([^<]+)<"),
                    json = true,
                    related = true,
                    bookmark = new Bookmark()
                    {
                        site = prem ? "phubprem" : "phub",
                        href = vkey,
                        image = img
                    }
                };

                if (onplaylist != null)
                    pl = onplaylist.Invoke(pl);

                playlists.Add(pl);
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string plugin, string search, string sort, int c, string hd = null)
        {
            #region getSortName
            string getSortName(string sort, string emptyName)
            {
                if (string.IsNullOrWhiteSpace(sort))
                    return emptyName;

                switch (sort)
                {
                    case "mr":
                    case "cm":
                        return "–Ω–æ–≤–µ–π—à–µ–µ";

                    case "ht":
                        return "—Å–∞–º—ã–µ –≥–æ—Ä—è—á–∏–µ";

                    case "vi":
                    case "mv":
                        return "–±–æ–ª—å—à–µ –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤";

                    case "ra":
                    case "tr":
                        return "–ª—É—á—à–∏–µ";

                    default:
                        return emptyName;
                }
            }
            #endregion

            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";
            string url = host + plugin;

            if (!string.IsNullOrEmpty(search))
            {
                string encodesearch = HttpUtility.UrlEncode(search);

                return new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–ü–æ–∏—Å–∫",
                        search_on = "search_on",
                        playlist_url = url,
                    },
                    new MenuItem()
                    {
                        title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {getSortName(sort, "–ù–∞–∏–±–æ–ª–µ–µ –∞–∫—Ç—É–∞–ª—å–Ω–æ–µ")}",
                        playlist_url = "submenu",
                        submenu = new List<MenuItem>()
                        {
                            new MenuItem()
                            {
                                title = "–ù–∞–∏–±–æ–ª–µ–µ –∞–∫—Ç—É–∞–ª—å–Ω–æ–µ",
                                playlist_url = url + $"?search={encodesearch}"
                            },
                            new MenuItem()
                            {
                                title = "–ù–æ–≤–µ–π—à–µ–µ",
                                playlist_url = url + $"?search={encodesearch}&sort=mr"
                            },
                            new MenuItem()
                            {
                                title = "–õ—É—á—à–∏–µ",
                                playlist_url = url + $"?search={encodesearch}&sort=tr"
                            },
                            new MenuItem()
                            {
                                title = "–ë–æ–ª—å—à–µ –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤",
                                playlist_url = url + $"?search={encodesearch}&sort=mv"
                            }
                        }
                    }
                };
            }

            var menu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = url,
                },
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {getSortName(sort, "–ù–µ–¥–∞–≤–Ω–æ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–º")}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–µ–¥–∞–≤–Ω–æ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–º",
                            playlist_url = url + $"?hd={hd}&c={c}"
                        },
                        new MenuItem()
                        {
                            title = "–ù–æ–≤–µ–π—à–µ–µ",
                            playlist_url = url + $"?hd={hd}&c={c}&sort=cm"
                        },
                        new MenuItem()
                        {
                            title = "–°–∞–º—ã–µ –≥–æ—Ä—è—á–∏–µ",
                            playlist_url = url + $"?hd={hd}&c={c}&sort=ht"
                        },
                        new MenuItem()
                        {
                            title = "–õ—É—á—à–∏–µ",
                            playlist_url = url + $"?hd={hd}&c={c}&sort=tr"
                        }
                    }
                }
            };

            if (plugin == "pornhubpremium" || plugin == "phubprem")
            {
                menu.Insert(1, new MenuItem()
                {
                    title = $"–ö–∞—á–µ—Å—Ç–≤–æ: {(hd == "2" ? "1080p" : hd == "3" ? "1440p" : hd == "4" ? "2160p" : "–≤—Å–µ")}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–í—Å–µ",
                            playlist_url = url + $"?sort={sort}&c={c}"
                        },
                        new MenuItem()
                        {
                            title = "2160p",
                            playlist_url = url + $"?sort={sort}&c={c}&hd=4"
                        },
                        new MenuItem()
                        {
                            title = "1440p",
                            playlist_url = url + $"?sort={sort}&c={c}&hd=3"
                        },
                        new MenuItem()
                        {
                            title = "1080p",
                            playlist_url = url + $"?sort={sort}&c={c}&hd=2"
                        }
                    }
                });
            }
            else
            {
                menu.Add(new MenuItem()
                {
                    title = $"–û—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è: {(plugin == "phubgay" ? "–ì–µ–∏" : plugin == "phubsml" ? "–¢—Ä–∞–Ω—Å—ã" : "–ì–µ—Ç–µ—Ä–æ")}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ì–µ—Ç–µ—Ä–æ",
                            playlist_url = host + "phub",
                        },
                        new MenuItem()
                        {
                            title = "–ì–µ–∏",
                            playlist_url = host + "phubgay",
                        },
                        new MenuItem()
                        {
                            title = "–¢—Ä–∞–Ω—Å—ã",
                            playlist_url = host + "phubsml",
                        }
                    }
                });
            }

            if (plugin == "phubgay")
            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–í—Å–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}"
                    },
                    new MenuItem()
                    {
                        title = "–ê–∑–∏–∞—Ç—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=48"
                    },
                    new MenuItem()
                    {
                        title = "–ë–µ–∑ –ø—Ä–µ–∑–µ—Ä–≤–∞—Ç–∏–≤–∞",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=40"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ —á–ª–µ–Ω—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=58"
                    },
                    new MenuItem()
                    {
                        title = "–í–µ–±-–∫–∞–º–µ—Ä–∞",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=342"
                    },
                    new MenuItem()
                    {
                        title = "–ì–æ–Ω–∑–æ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=372"
                    },
                    new MenuItem()
                    {
                        title = "–ì—Ä—É–±—ã–π —Å–µ–∫—Å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=312"
                    },
                    new MenuItem()
                    {
                        title = "–î—Ä–æ—á–∏—Ç",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=262"
                    },
                    new MenuItem()
                    {
                        title = "–ñ–µ—Ä–µ–±—Ü—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=70"
                    },
                    new MenuItem()
                    {
                        title = "–ó—Ä–µ–ª—ã–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=332"
                    },
                    new MenuItem()
                    {
                        title = "–ö–∞—Å—Ç–∏–Ω–≥–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=362"
                    },
                    new MenuItem()
                    {
                        title = "–ö–∞—á–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=322"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ–ª–ª–µ–¥–∂",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=68"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ–Ω—á–∞—é—Ç",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=352"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä–µ–º–ø–∞–π",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=71"
                    },
                    new MenuItem()
                    {
                        title = "–õ–∞—Ç–∏–Ω–æ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=50"
                    },
                    new MenuItem()
                    {
                        title = "–õ—é–±–∏—Ç–µ–ª—å—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=252"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞—Å—Å–∞–∂",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=45"
                    },
                    new MenuItem()
                    {
                        title = "–ú–µ–¥–≤–µ–¥—å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=66"
                    },
                    new MenuItem()
                    {
                        title = "–ú–µ–∂—Ä–∞—Å—Å–æ–≤—ã–π –°–µ–∫—Å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=64"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∏–Ω–µ—Ç",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=56"
                    },
                    new MenuItem()
                    {
                        title = "–ú–æ–ª–æ–¥–µ–Ω—å–∫–∏–µ –≥–µ–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=49"
                    },
                    new MenuItem()
                    {
                        title = "–ú—É–ª—å—Ç–∏–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=422"
                    },
                    new MenuItem()
                    {
                        title = "–ú—É—Å–∫—É–ª–∏—Å—Ç—ã–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=51"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞ –ø—É–±–ª–∏–∫–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=84"
                    },
                    new MenuItem()
                    {
                        title = "–ù–µ –æ–±—Ä–µ–∑–∞–Ω–Ω—ã–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=272"
                    },
                    new MenuItem()
                    {
                        title = "–ù–µ–≥—Ä—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=44"
                    },
                    new MenuItem()
                    {
                        title = "–ù–æ–≥–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=412"
                    },
                    new MenuItem()
                    {
                        title = "–ü–∞–ø–∏–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=47"
                    },
                    new MenuItem()
                    {
                        title = "–ü–∞—Ä–Ω–∏ (—Å–æ–ª–æ)",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=54"
                    },
                    new MenuItem()
                    {
                        title = "–ü—É—Ö–ª–µ–Ω—å–∫–∏–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=392"
                    },
                    new MenuItem()
                    {
                        title = "–†–µ—Ç—Ä–æ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=77"
                    },
                    new MenuItem()
                    {
                        title = "–¢–∞—Ç—É–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ú—É–∂—á–∏–Ω—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=552"
                    },
                    new MenuItem()
                    {
                        title = "–§–µ—Ç–∏—à",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=52"
                    }
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }
            else if (plugin == "phub" || plugin == "phubprem")
            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–í—Å–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}"
                    },
                    new MenuItem()
                    {
                        title = "–ñ–µ–Ω—Å–∫–∏–π –í—ã–±–æ—Ä",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=73"
                    },
                    new MenuItem()
                    {
                        title = "–†—É—Å—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=99"
                    },
                    new MenuItem()
                    {
                        title = "–ù–µ–º–µ—Ü–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=95"
                    },
                    new MenuItem()
                    {
                        title = "60FPS",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=105"
                    },
                    new MenuItem()
                    {
                        title = "–ê–∑–∏–∞—Ç–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=1"
                    },
                    new MenuItem()
                    {
                        title = "–ê–Ω–∞–ª—å–Ω—ã–π —Å–µ–∫—Å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=35"
                    },
                    new MenuItem()
                    {
                        title = "–ê—Ä–∞–±—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=98"
                    },
                    new MenuItem()
                    {
                        title = "–ë–î–°–ú",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=10"
                    },
                    new MenuItem()
                    {
                        title = "–ë–µ–∑–æ–±–∏–¥–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=221"
                    },
                    new MenuItem()
                    {
                        title = "–ë–∏—Å–µ–∫—Å—É–∞–ª—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=76"
                    },
                    new MenuItem()
                    {
                        title = "–ë–ª–æ–Ω–¥–∏–Ω–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=9"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∞—è –≥—Ä—É–¥—å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=8"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ —á–ª–µ–Ω—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=7"
                    },
                    new MenuItem()
                    {
                        title = "–ë—Ä–∞–∑–∏–ª—å—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=102"
                    },
                    new MenuItem()
                    {
                        title = "–ë—Ä–∏—Ç–∞–Ω—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=96"
                    },
                    new MenuItem()
                    {
                        title = "–ë—Ä—ã–∑–≥–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=69"
                    },
                    new MenuItem()
                    {
                        title = "–ë—Ä—é–Ω–µ—Ç–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=11"
                    },
                    new MenuItem()
                    {
                        title = "–ë—É–∫–∫–∞–∫–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=14"
                    },
                    new MenuItem()
                    {
                        title = "–í —à–∫–æ–ª–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=88"
                    },
                    new MenuItem()
                    {
                        title = "–í–µ–±-–∫–∞–º–µ—Ä–∞",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=61"
                    },
                    new MenuItem()
                    {
                        title = "–í–µ—á–µ—Ä–∏–Ω–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=53"
                    },
                    new MenuItem()
                    {
                        title = "–ì–æ–Ω–∑–æ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=41"
                    },
                    new MenuItem()
                    {
                        title = "–ì—Ä—É–±—ã–π —Å–µ–∫—Å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=67"
                    },
                    new MenuItem()
                    {
                        title = "–ì—Ä—É–ø–ø–æ–≤—É—Ö–∞",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=80"
                    },
                    new MenuItem()
                    {
                        title = "–î–≤–æ–π–Ω–æ–µ –ø—Ä–æ–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=72"
                    },
                    new MenuItem()
                    {
                        title = "–î–µ–≤—É—à–∫–∏ (—Å–æ–ª–æ)",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=492"
                    },
                    new MenuItem()
                    {
                        title = "–î—Ä–æ—á–∏—Ç",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=20"
                    },
                    new MenuItem()
                    {
                        title = "–ï–≤—Ä–æ–ø–µ–π—Ü—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=55"
                    },
                    new MenuItem()
                    {
                        title = "–ñ–µ–Ω—Å–∫–∏–π –æ—Ä–≥–∞–∑–º",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=502"
                    },
                    new MenuItem()
                    {
                        title = "–ñ–µ—Å—Ç–∫–∏–π —Å–µ–∫—Å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=21"
                    },
                    new MenuItem()
                    {
                        title = "–ó–∞ –∫–∞–¥—Ä–æ–º",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=141"
                    },
                    new MenuItem()
                    {
                        title = "–ó–≤–µ–∑–¥—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=12"
                    },
                    new MenuItem()
                    {
                        title = "–ó–æ–ª–æ—Ç–æ–π –¥–æ–∂–¥—å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=211"
                    },
                    new MenuItem()
                    {
                        title = "–ó—Ä–µ–ª—ã–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=28"
                    },
                    new MenuItem()
                    {
                        title = "–ò–≥—Ä—É—à–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=23"
                    },
                    new MenuItem()
                    {
                        title = "–ò–Ω–¥–∏–π—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=101"
                    },
                    new MenuItem()
                    {
                        title = "–ò—Ç–∞–ª—å—è–Ω—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=97"
                    },
                    new MenuItem()
                    {
                        title = "–ö–∞—Å—Ç–∏–Ω–≥–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=90"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ–ª–ª–µ–¥–∂",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=79"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ–Ω—á–∞—é—Ç",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=16"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ—Ä–µ–π—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=103"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ—Å–ø–ª–µ–π",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=241"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä–∞—Å–æ—Ç–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=5"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä–µ–º–ø–∞–π",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=15"
                    },
                    new MenuItem()
                    {
                        title = "–ö—É–Ω–∏–ª–∏–Ω–≥—É—Å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=131"
                    },
                    new MenuItem()
                    {
                        title = "–ö—É—Ä—è—â–∏–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=91"
                    },
                    new MenuItem()
                    {
                        title = "–õ–∞—Ç–∏–Ω–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=26"
                    },
                    new MenuItem()
                    {
                        title = "–õ—é–±–∏—Ç–µ–ª—å—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=3"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞–ª–µ–Ω—å–∫–∞—è –≥—Ä—É–¥—å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=59"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞–º–æ—á–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=29"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞—Å—Å–∞–∂",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=78"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞—Å—Ç—É—Ä–±–∞—Ü–∏—è",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=22"
                    },
                    new MenuItem()
                    {
                        title = "–ú–µ–∂—Ä–∞—Å—Å–æ–≤—ã–π –°–µ–∫—Å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=25"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∏–Ω–µ—Ç",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=13"
                    },
                    new MenuItem()
                    {
                        title = "–ú—É–ª–∞—Ç—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=17"
                    },
                    new MenuItem()
                    {
                        title = "–ú—É–ª—å—Ç–∏–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=86"
                    },
                    new MenuItem()
                    {
                        title = "–ú—É—Å–∫—É–ª–∏—Å—Ç—ã–µ –ú—É–∂—á–∏–Ω—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=512"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞ –ø—É–±–ª–∏–∫–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=24"
                    },
                    new MenuItem()
                    {
                        title = "–ù–æ–≥–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=93"
                    },
                    new MenuItem()
                    {
                        title = "–ù—è–Ω–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=89"
                    },
                    new MenuItem()
                    {
                        title = "–ü–∞—Ä–æ–¥–∏—è",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=201"
                    },
                    new MenuItem()
                    {
                        title = "–ü–µ–Ω—Å–∏–æ–Ω–µ—Ä—ã / –ø–æ–¥—Ä–æ—Å—Ç–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=181"
                    },
                    new MenuItem()
                    {
                        title = "–ü–æ–¥—Ä–æ—Å—Ç–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=37"
                    },
                    new MenuItem()
                    {
                        title = "–ü–æ–ø–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=4"
                    },
                    new MenuItem()
                    {
                        title = "–ü—Ä–∏–∫–æ–ª—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=32"
                    },
                    new MenuItem()
                    {
                        title = "–†–µ—Ç—Ä–æ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=43"
                    },
                    new MenuItem()
                    {
                        title = "–†–æ–≥–æ–Ω–æ—Å—Ü—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=242"
                    },
                    new MenuItem()
                    {
                        title = "–†–æ–ª–µ–≤—ã–µ –ò–≥—Ä—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=81"
                    },
                    new MenuItem()
                    {
                        title = "–†–æ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=522"
                    },
                    new MenuItem()
                    {
                        title = "–†—ã–∂–∏–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=42"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å –≤—Ç—Ä–æ–µ–º",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=65"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å-–æ—Ä–≥–∏—è",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=2"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–º–µ–π–Ω—ã–µ —Ñ–∞–Ω—Ç–∞–∑–∏–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=444"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç—Ä–∞–ø–æ–Ω",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=542"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç—Ä–∏–ø—Ç–∏–∑",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=33"
                    },
                    new MenuItem()
                    {
                        title = "–¢–∞—Ç—É–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ñ–µ–Ω—â–∏–Ω—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=562"
                    },
                    new MenuItem()
                    {
                        title = "–¢–æ–ª—Å—Ç—É—à–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=6"
                    },
                    new MenuItem()
                    {
                        title = "–¢—Ä–∞–Ω—Å–≤–µ—Å—Ç–∏—Ç—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=83"
                    },
                    new MenuItem()
                    {
                        title = "–£–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–µ–Ω–∏–µ –ø–∞–ª—å—Ü–∞–º–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=592"
                    },
                    new MenuItem()
                    {
                        title = "–§–µ—Ç–∏—à",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=18"
                    },
                    new MenuItem()
                    {
                        title = "–§–∏—Å—Ç–∏–Ω–≥",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=19"
                    },
                    new MenuItem()
                    {
                        title = "–§—Ä–∞–Ω—Ü—É–∑—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=94"
                    },
                    new MenuItem()
                    {
                        title = "–•–µ–Ω—Ç–∞–π",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=36"
                    },
                    new MenuItem()
                    {
                        title = "–ß–µ—à—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=100"
                    },
                    new MenuItem()
                    {
                        title = "–Ø–ø–æ–Ω—Ü—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=111"
                    }
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }

            return menu;
        }

        async public static ValueTask<StreamItem> StreamLinks(string video_uri, string list_uri, string host, string vkey, Func<string, ValueTask<string>> onresult)
        {
            if (string.IsNullOrEmpty(vkey))
                return null;

            string html = await onresult.Invoke($"{host}/view_video.php?viewkey={vkey}");
            if (html == null)
                return null;

            var qualitys = new Dictionary<string, string>();

            foreach (string q in new string[] { "1080", "720", "480", "240" })
            {
                string video = Regex.Match(html, $"\"videoUrl\":\"([^\"]+)\",\"quality\":\"{q}\"").Groups[1].Value;
                if (!string.IsNullOrEmpty(video))
                    qualitys.TryAdd($"{q}p", video.Replace("\\", "").Replace("///", "//"));
            }

            if (qualitys.Count == 0)
                return null;

            return new StreamItem()
            {
                qualitys = qualitys,
                recomends = Playlist(video_uri, list_uri, html, related: true)
            };
        }


        public static int Pages(in string html)
        { 
            if (string.IsNullOrEmpty(html))
                return 0;

            if (!html.Contains("class=\"page_number\""))
                return 1;

            int maxpage = 0;
            foreach (Match match in new Regex("class=\"page_number\"><a [^>]+>([0-9]+)<").Matches(html))
            {
                if (int.TryParse(match.Groups[1].Value, out int page) && page > maxpage)
                    maxpage = page;
            }

            // –º–æ–¥–µ–ª—å 6, –Ω–∞–≤–∏–≥–∞—Ü–∏—è 5
            if (4 >= maxpage)
                return maxpage;

            return 0;
        }


        #region getDirectLinks
        static string getDirectLinks(in string pageCode)
        {
            var vars = new List<(string name, string param)>();

            string mainParamBody = Regex.Match(pageCode, "var player_mp4_seek = \"[^\"]+\";[\n\r\t ]+(// var[^\n\r]+[\n\r\t ]+)?([^\n\r]+)").Groups[2].Value;
            mainParamBody = Regex.Replace(mainParamBody, "/\\*.*?\\*/", "");
            mainParamBody = mainParamBody.Replace("\" + \"", "");

            foreach (Match currVar in Regex.Matches(mainParamBody, "var ([^=]+)=([^;]+);"))
                vars.Add((currVar.Groups[1].Value, currVar.Groups[2].Value.Replace("\"", "").Replace(" + ", "")));

            string mediapattern = /*mainParamBody.Contains("var media_4=") && mainParamBody.Contains("var media_5=") ? "var media_(4)=(.*?);" : */"var media_([0-9]+)=(.*?);";
            foreach (Match m in Regex.Matches(mainParamBody, mediapattern, RegexOptions.Singleline))
            {
                string link = "";
                foreach (string curr in m.Groups[2].Value.Replace(" ", "").Split('+'))
                {
                    string param = vars.Find(x => x.name == curr).param;
                    if (param == null)
                        continue;

                    link += param;
                }

                if (link.Contains("urlset/master.m3u8"))
                    return link;
            }

            return null;
        }
        #endregion
    }
}

```

## File: Shared/Engine/SISI/BongaCamsTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using System.Text.RegularExpressions;

namespace Shared.Engine.SISI
{
    public static class BongaCamsTo
    {
        public static ValueTask<string> InvokeHtml(string host, string sort, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = host + $"/tools/listing_v3.php?livetab={sort ?? "all"}&offset={(pg > 1 ? ((pg-1) * 72) : 0)}&limit=72";

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(in string html, out int total_pages, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            total_pages = 0;

            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("\"gender\"");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                string baba = Regex.Match(row, "\"username\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(baba))
                    continue;

                string esid = Regex.Match(row, "\"esid\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(esid))
                    continue;

                string img = Regex.Match(row, "\"thumb_image\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(img))
                    continue;

                string title = Regex.Match(row, "\"display_name\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(title))
                    title = baba;

                var pl = new PlaylistItem()
                {
                    name = title,
                    quality = Regex.Match(row, "\"vq\":\"([^\"]+)\"").Groups[1].Value,
                    video = $"https://{esid}.bcvcdn.com/hls/stream_{baba}/public-aac/stream_{baba}/chunks.m3u8",
                    picture = $"https:{img.Replace("\\", "").Replace("{ext}", "jpg")}"
                };

                if (onplaylist != null)
                    pl = onplaylist.Invoke(pl);

                playlists.Add(pl);
            }

            string total_count = Regex.Match(html, "\"total_count\":([0-9]+),").Groups[1].Value;
            if (int.TryParse(total_count, out int total) && total > 0)
            {
                if (72 >= total)
                    total_pages = 1;
                else
                    total_pages = (total / 72) + 1;
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string sort)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";

            return new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrWhiteSpace(sort) ? "–≤—ã–±—Ä–∞—Ç—å" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–æ–≤—ã–µ",
                            playlist_url = host + "bgs?sort=new"
                        },
                        new MenuItem()
                        {
                            title = "–ü–∞—Ä—ã",
                            playlist_url = host + "bgs?sort=couples"
                        },
                        new MenuItem()
                        {
                            title = "–î–µ–≤—É—à–∫–∏",
                            playlist_url = host + "bgs?sort=female"
                        },
                        new MenuItem()
                        {
                            title = "–†—É—Å—Å–∫–∏–µ –º–æ–¥–µ–ª–∏",
                            playlist_url = host + "bgs?sort=female/tags/russian"
                        },
                        new MenuItem()
                        {
                            title = "–ü–∞—Ä–Ω–∏",
                            playlist_url = host + "bgs?sort=male"
                        },
                        new MenuItem()
                        {
                            title = "–¢—Ä–∞–Ω—Å—Å–µ–∫—Å—É–∞–ª—ã",
                            playlist_url = host + "bgs?sort=transsexual"
                        }
                    }
                }
            };
        }
    }
}

```

## File: Shared/Engine/SISI/SpankbangTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class SpankbangTo
    {
        public static ValueTask<string> InvokeHtml(string host, string search, string sort, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = $"{host}/";

            if (!string.IsNullOrWhiteSpace(search))
            {
                url += $"s/{HttpUtility.UrlEncode(search)}/{pg}/";
            }
            else
            {
                url += $"{sort ?? "new_videos"}/{pg}/";

                if (sort == "most_popular")
                    url += "?p=m";
            }

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            if (html.Contains("class=\"main-container\""))
                html = html.Split("class=\"main-container\"")[1];

            var nodes = HtmlParse.Nodes(html, "//div[@data-testid='video-item']");
            var playlists = new List<PlaylistItem>(nodes.Count);

            foreach (var node in nodes)
            {
                var g = Regex.Match(node.row.InnerHtml, "<a href=\"/(?<link>[^\"]+)\" title=\"(?<title>[^\"]+)\"").Groups;
                if (!string.IsNullOrWhiteSpace(g["link"].Value) && !string.IsNullOrWhiteSpace(g["title"].Value))
                {
                    #region image
                    string img = node.Regex("([\n\r\t ]+)src=\"([^\"]+)\"", 2);
                    if (!img.Contains("/w:"))
                        img = node.Regex("data-src=\"([^\"]+)\"");

                    img = Regex.Replace(img, "/w:[0-9]00/", "/w:300/");
                    #endregion

                    string preview = node.Regex("data-preview=\"([^\"]+)\"");
                    if (string.IsNullOrEmpty(preview))
                        preview = node.Regex("<source data-src=\"([^\"]+)\"");

                    var pl = new PlaylistItem()
                    {
                        name = g["title"].Value,
                        video = $"{uri}?uri={g["link"].Value}",
                        quality = node.SelectText(".//*[@data-testid='video-item-resolution']"),
                        picture = img,
                        preview = preview,
                        time = node.SelectText(".//*[@data-testid='video-item-length']"),
                        json = true,
                        related = true,
                        bookmark = new Bookmark()
                        {
                            site = "sbg",
                            href = g["link"].Value,
                            image = img
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string sort)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";

            return new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = host + "sbg",
                },
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrWhiteSpace(sort) ? "–Ω–æ–≤–æ–µ" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–æ–≤–æ–µ",
                            playlist_url = host + "sbg"
                        },
                        new MenuItem()
                        {
                            title = "–¢—Ä–µ–Ω–¥–æ–≤–æ–µ",
                            playlist_url = host + "sbg?sort=trending_videos"
                        },
                        new MenuItem()
                        {
                            title = "–ü–æ–ø—É–ª—è—Ä–Ω–æ–µ",
                            playlist_url = host + "sbg?sort=most_popular"
                        }
                    }
                }
            };
        }

        async public static ValueTask<StreamItem> StreamLinks(string uri, string host, string url, Func<string, ValueTask<string>> onresult)
        {
            if (string.IsNullOrEmpty(url))
                return null;

            string html = await onresult.Invoke($"{host}/{url}");
            if (string.IsNullOrEmpty(html))
                return null;

            var stream_links = new Dictionary<int, string>();

            var match = new Regex("'([0-9]+)(p|k)': ?\\[\'(https?://[^']+)\'").Match(html);
            while (match.Success)
            {
                int q = $"{match.Groups[1].Value}{match.Groups[2].Value}" == "4k" ? 2160 : int.Parse(match.Groups[1].Value);
                stream_links.TryAdd(q, match.Groups[3].Value);
                match = match.NextMatch();
            }

            return new StreamItem()
            {
                qualitys = stream_links.OrderByDescending(i => i.Key).ToDictionary(k => $"{k.Key}p", v => v.Value),
                recomends = Playlist(uri, html)
            };
        }
    }
}

```

## File: Shared/Engine/SISI/ChaturbateTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using System.Text.RegularExpressions;

namespace Shared.Engine.SISI
{
    public static class ChaturbateTo
    {
        public static ValueTask<string> InvokeHtml(string host, string sort, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = host + "/api/ts/roomlist/room-list/?enable_recommendations=false&limit=90";

            if (!string.IsNullOrWhiteSpace(sort))
                url += $"&genders={sort}";

            if (pg > 1)
                url += $"&offset={pg * 90}";

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("display_age");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                if (!row.Contains("\"current_show\":\"public\""))
                    continue;

                string baba = Regex.Match(row, "\"username\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrWhiteSpace(baba))
                    continue;

                string img = Regex.Match(row, "\"img\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(img))
                    continue;

                var pl = new PlaylistItem()
                {
                    name = baba.Trim(),
                    //quality = row.Contains(">HD+</div>") ? "HD+" : row.Contains(">HD</div>") ? "HD" : null,
                    video = $"{uri}?baba={baba}",
                    picture = img.Replace("\\", ""),
                    json = true
                };

                if (onplaylist != null)
                    pl = onplaylist.Invoke(pl);

                playlists.Add(pl);
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string sort)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";

            var sortmenu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–õ—É—á—à–∏–µ",
                    playlist_url = host + "chu"
                },
                new MenuItem()
                {
                    title = "–î–µ–≤—É—à–∫–∏",
                    playlist_url = host + "chu?sort=f"
                },
                new MenuItem()
                {
                    title = "–ü–∞—Ä—ã",
                    playlist_url = host + "chu?sort=c"
                },
                new MenuItem()
                {
                    title = "–ü–∞—Ä–Ω–∏",
                    playlist_url = host + "chu?sort=m"
                },
                new MenuItem()
                {
                    title = "–¢—Ä–∞–Ω—Å—Å–µ–∫—Å—É–∞–ª—ã",
                    playlist_url = host + "chu?sort=t"
                }
            };

            return new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {sortmenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"={sort}")).title ?? "–õ—É—á—à–∏–µ" }",
                    playlist_url = "submenu",
                    submenu = sortmenu
                }
            };
        }

        async public static ValueTask<Dictionary<string, string>> StreamLinks(string host, string baba, Func<string, ValueTask<string>> onresult)
        {
            if (string.IsNullOrWhiteSpace(baba))
                return null;

            string html = await onresult.Invoke($"{host}/{baba}/");
            string hls = new Regex("(https?://[^ ]+/playlist\\.m3u8)").Match(html ?? "").Groups[1].Value;
            if (string.IsNullOrWhiteSpace(hls))
                return null;

            return new Dictionary<string, string>()
            {
                ["auto"] = hls.Replace("\\u002D", "-").Replace("\\", "")
            };
        }
    }
}

```

## File: Shared/Engine/SISI/XnxxTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using Shared.Models.SISI.Xvideos;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class XnxxTo
    {
        public static ValueTask<string> InvokeHtml(string host, string search, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = $"{host}/best/{DateTime.Today.AddMonths(-1):yyyy-MM}/{pg}";
            if (!string.IsNullOrWhiteSpace(search))
                url = $"{host}/search/{HttpUtility.UrlEncode(search)}/{pg}";

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("<div id=\"video_");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                var g = Regex.Match(row, "<a href=\"/(video-[^\"]+)\" title=\"([^\"]+)\"").Groups;
                string quality = Regex.Match(row, "<span class=\"superfluous\"> - </span>([^<]+)</span>").Groups[1].Value;

                if (!string.IsNullOrEmpty(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                {
                    string duration = Regex.Match(row, "</span>([^<]+)<span class=\"video-hd\">").Groups[1].Value.Trim();
                    string img = Regex.Match(row, "data-src=\"([^\"]+)\"").Groups[1].Value.Replace(".THUMBNUM.", ".1.");

                    // https://cdn77-pic.xvideos-cdn.com/videos/thumbs169ll/5a/6d/4f/5a6d4f718214eebf73225ec96b670f62-2/5a6d4f718214eebf73225ec96b670f62.27.jpg
                    // https://cdn77-pic.xvideos-cdn.com/videos/videopreview/5a/6d/4f/5a6d4f718214eebf73225ec96b670f62_169.mp4
                    string preview = Regex.Replace(img, "/thumbs[^/]+/", "/videopreview/");
                    preview = Regex.Replace(preview, "/[^/]+$", "");
                    preview = Regex.Replace(preview, "-[0-9]+$", "");

                    var pl = new PlaylistItem()
                    {
                        name = g[2].Value,
                        video = $"{uri}?uri={g[1].Value}",
                        picture = img,
                        preview = preview + "_169.mp4",
                        time = duration,
                        quality = string.IsNullOrWhiteSpace(quality) ? null : quality,
                        json = true,
                        related = true,
                        bookmark = new Bookmark()
                        {
                            site = "xnx",
                            href = g[1].Value,
                            image = img
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";

            return new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = host + "xnx",
                }
            };
        }

        async public static ValueTask<StreamItem> StreamLinks(string uri, string host, string url, Func<string, ValueTask<string>> onresult, Func<string, ValueTask<string>> onm3u = null)
        {
            if (string.IsNullOrWhiteSpace(url))
                return null;

            string html = await onresult.Invoke($"{host}/{Regex.Replace(url ?? string.Empty, "^([^/]+)/.*", "$1/_")}");
            if (html == null)
                return null;

            string stream_link = new Regex("html5player\\.setVideoHLS\\('([^']+)'\\);").Match(html).Groups[1].Value;
            if (string.IsNullOrWhiteSpace(stream_link))
                return null;

            #region getRelated
            List<PlaylistItem> getRelated()
            {
                var related = new List<PlaylistItem>();

                string json = Regex.Match(html!, "video_related=([^\n\r]+);window").Groups[1].Value;
                if (string.IsNullOrWhiteSpace(json) || !json.StartsWith("[") || !json.EndsWith("]"))
                    return related;

                try
                {
                    foreach (var r in JsonSerializer.Deserialize<List<Related>>(json))
                    {
                        if (string.IsNullOrEmpty(r.tf) || string.IsNullOrEmpty(r.u) || string.IsNullOrEmpty(r.i))
                            continue;

                        related.Add(new PlaylistItem()
                        {
                            name = r.tf,
                            video = $"{uri}?uri={r.u.Remove(0, 1)}",
                            picture = r.i,
                            json = true,
                            related = true,
                            bookmark = new Bookmark()
                            {
                                site = "xnx",
                                href = r.u.Remove(0, 1),
                                image = r.i
                            }
                        });
                    }
                }
                catch { }

                return related;
            }
            #endregion

            string m3u8 = onm3u == null ? null : await onm3u.Invoke(stream_link);
            if (m3u8 == null)
            {
                return new StreamItem()
                {
                    qualitys = new Dictionary<string, string>()
                    {
                        ["auto"] = stream_link
                    },
                    recomends = getRelated()
                };
            }

            var stream_links = new Dictionary<int, string>();
            foreach (Match m in Regex.Matches(m3u8, "(hls-(2160|1440|1080|720|480|360)p[^\n\r\t ]+)"))
            {
                string hls = m.Groups[1].Value;
                if (string.IsNullOrEmpty(hls))
                    continue;

                hls = $"{Regex.Replace(stream_link, "/hls\\.m3u.*", "")}/{hls}".Replace("https:", "http:");
                stream_links.Add(int.Parse(m.Groups[2].Value), hls);
            }

            return new StreamItem()
            {
                qualitys = stream_links.OrderByDescending(i => i.Key).ToDictionary(k => $"{k.Key}p", v => v.Value),
                recomends = getRelated()
            };
        }
    }
}

```

## File: Shared/Engine/SISI/PorntrexTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class PorntrexTo
    {
        public static ValueTask<string> InvokeHtml(string host, string search, string sort, string c, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = $"{host}/";

            if (!string.IsNullOrWhiteSpace(search))
            {
                url = $"{host}/search/{HttpUtility.UrlEncode(search)}/";

                if (!string.IsNullOrEmpty(sort))
                    url += $"{sort}/";

                url += $"?from_videos={pg}";
            }
            else
            {
                if (!string.IsNullOrEmpty(c))
                {
                    url += $"categories/{c}/";

                    if (sort == "most-popular")
                        url += $"top-rated/";

                    url += $"?from4={pg}";
                }
                else
                {
                    if (string.IsNullOrEmpty(sort))
                    {
                        url += $"latest-updates/{pg}/";
                    }
                    else
                    {
                        url += $"{sort}/weekly/?from4={pg}";
                    }
                }
            }

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("<div class=\"video-preview-screen");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                if (row.Contains("<span class=\"line-private\">"))
                    continue;

                var g = Regex.Match(row, "<a href=\"https?://[^/]+/(video/[^\"]+)\" title=\"([^\"]+)\"").Groups;

                if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                {
                    string quality = Regex.Match(row, "<span class=\"quality\">([^<]+)</span>").Groups[1].Value;
                    string duration = Regex.Match(row, "<i class=\"fa fa-clock-o\"></i>([^<]+)</div>").Groups[1].Value.Trim();
                    var img = Regex.Match(row, "data-src=\"(https?:)?//(((ptx|statics)\\.cdntrex\\.com/contents/videos_screenshots/[0-9]+/[0-9]+)[^\"]+)").Groups;

                    var pl = new PlaylistItem()
                    {
                        video = $"{uri}?uri={g[1].Value}",
                        name = g[2].Value,
                        picture = $"https://{img[2].Value}",
                        quality = !string.IsNullOrEmpty(quality) ? quality : null,
                        time = duration,
                        json = true,
                        bookmark = new Bookmark()
                        {
                            site = "ptx",
                            href = g[1].Value,
                            image = $"https://{img[2].Value}"
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string search, string sort, string c)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";
            string url = host + "ptx";

            if (!string.IsNullOrEmpty(search))
            {
                string encodesearch = HttpUtility.UrlEncode(search);

                return new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–ü–æ–∏—Å–∫",
                        search_on = "search_on",
                        playlist_url = url,
                    },
                    new MenuItem()
                    {
                        title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrEmpty(sort) ? "Most Relevant" : sort)}",
                        playlist_url = "submenu",
                        submenu = new List<MenuItem>()
                        {
                            new MenuItem()
                            {
                                title = "Most Relevant",
                                playlist_url = url + $"?c={c}&search={encodesearch}"
                            },
                            new MenuItem()
                            {
                                title = "–ù–æ–≤–∏–Ω–∫–∏",
                                playlist_url = url + $"?c={c}&sort=latest-updates&search={encodesearch}"
                            },
                            new MenuItem()
                            {
                                title = "–¢–æ–ø –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤",
                                playlist_url = url + $"?c={c}&sort=most-popular&search={encodesearch}"
                            }
                        }
                    }
                };
            }

            var menu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = url,
                },
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrEmpty(sort) ? "–Ω–æ–≤–∏–Ω–∫–∏" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–æ–≤–∏–Ω–∫–∏",
                            playlist_url = url + $"?c={c}"
                        },
                        new MenuItem()
                        {
                            title = "–¢–æ–ø –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤",
                            playlist_url = url + $"?c={c}&sort=most-popular"
                        }
                    }
                }
            };

            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–í—Å–µ",
                        playlist_url = url + $"?sort={sort}"
                    },
                    new MenuItem()
                    {
                        title = "4K UHD",
                        playlist_url = url + $"?sort={sort}&c=4k-porn"
                    },
                    new MenuItem()
                    {
                        title = "Anal",
                        playlist_url = url + $"?sort={sort}&c=anal"
                    },
                    new MenuItem()
                    {
                        title = "Arab",
                        playlist_url = url + $"?sort={sort}&c=arab"
                    },
                    new MenuItem()
                    {
                        title = "Asian",
                        playlist_url = url + $"?sort={sort}&c=asian"
                    },
                    new MenuItem()
                    {
                        title = "Ass licking",
                        playlist_url = url + $"?sort={sort}&c=ass-licking"
                    },
                    new MenuItem()
                    {
                        title = "Ass to mouth (ATM)",
                        playlist_url = url + $"?sort={sort}&c=ass-to-mouth"
                    },
                    new MenuItem()
                    {
                        title = "Babe",
                        playlist_url = url + $"?sort={sort}&c=babe"
                    },
                    new MenuItem()
                    {
                        title = "Babysitter",
                        playlist_url = url + $"?sort={sort}&c=babysitter"
                    },
                    new MenuItem()
                    {
                        title = "BBW",
                        playlist_url = url + $"?sort={sort}&c=bbw"
                    },
                    new MenuItem()
                    {
                        title = "Big Ass",
                        playlist_url = url + $"?sort={sort}&c=big-ass"
                    },
                    new MenuItem()
                    {
                        title = "Big Tits",
                        playlist_url = url + $"?sort={sort}&c=big-tits"
                    },
                    new MenuItem()
                    {
                        title = "Black",
                        playlist_url = url + $"?sort={sort}&c=black"
                    },
                    new MenuItem()
                    {
                        title = "Blonde",
                        playlist_url = url + $"?sort={sort}&c=blonde"
                    },
                    new MenuItem()
                    {
                        title = "Blowjob",
                        playlist_url = url + $"?sort={sort}&c=blowjob"
                    },
                    new MenuItem()
                    {
                        title = "Bondage",
                        playlist_url = url + $"?sort={sort}&c=bondage"
                    },
                    new MenuItem()
                    {
                        title = "Brunette",
                        playlist_url = url + $"?sort={sort}&c=brunette"
                    },
                    new MenuItem()
                    {
                        title = "Bukkake",
                        playlist_url = url + $"?sort={sort}&c=bukkake"
                    },
                    new MenuItem()
                    {
                        title = "Busty",
                        playlist_url = url + $"?sort={sort}&c=busty"
                    },
                    new MenuItem()
                    {
                        title = "Casting",
                        playlist_url = url + $"?sort={sort}&c=casting"
                    },
                    new MenuItem()
                    {
                        title = "Celebrities",
                        playlist_url = url + $"?sort={sort}&c=celebrities"
                    },
                    new MenuItem()
                    {
                        title = "College",
                        playlist_url = url + $"?sort={sort}&c=college"
                    },
                    new MenuItem()
                    {
                        title = "Compilation",
                        playlist_url = url + $"?sort={sort}&c=compilation"
                    },
                    new MenuItem()
                    {
                        title = "Creampie",
                        playlist_url = url + $"?sort={sort}&c=creampie"
                    },
                    new MenuItem()
                    {
                        title = "Cuckold",
                        playlist_url = url + $"?sort={sort}&c=cuckold"
                    },
                    new MenuItem()
                    {
                        title = "Cum-swap",
                        playlist_url = url + $"?sort={sort}&c=cum-swapping"
                    },
                    new MenuItem()
                    {
                        title = "Cumshots",
                        playlist_url = url + $"?sort={sort}&c=cumshots"
                    },
                    new MenuItem()
                    {
                        title = "Czech",
                        playlist_url = url + $"?sort={sort}&c=czech"
                    },
                    new MenuItem()
                    {
                        title = "Czech Massage",
                        playlist_url = url + $"?sort={sort}&c=czech-massage"
                    },
                    new MenuItem()
                    {
                        title = "Deepthroat",
                        playlist_url = url + $"?sort={sort}&c=deepthroat"
                    },
                    new MenuItem()
                    {
                        title = "Doggystyle",
                        playlist_url = url + $"?sort={sort}&c=doggystyle"
                    },
                    new MenuItem()
                    {
                        title = "Double Penetration (DP)",
                        playlist_url = url + $"?sort={sort}&c=double-penetration"
                    },
                    new MenuItem()
                    {
                        title = "Ebony",
                        playlist_url = url + $"?sort={sort}&c=ebony"
                    },
                    new MenuItem()
                    {
                        title = "Fantasy",
                        playlist_url = url + $"?sort={sort}&c=fantasy"
                    },
                    new MenuItem()
                    {
                        title = "Fetish",
                        playlist_url = url + $"?sort={sort}&c=fetish"
                    },
                    new MenuItem()
                    {
                        title = "Fingering",
                        playlist_url = url + $"?sort={sort}&c=fingering"
                    },
                    new MenuItem()
                    {
                        title = "Fisting",
                        playlist_url = url + $"?sort={sort}&c=fisting"
                    },
                    new MenuItem()
                    {
                        title = "Footjob",
                        playlist_url = url + $"?sort={sort}&c=footjob"
                    },
                    new MenuItem()
                    {
                        title = "Foursome",
                        playlist_url = url + $"?sort={sort}&c=foursome"
                    },
                    new MenuItem()
                    {
                        title = "Gangbang",
                        playlist_url = url + $"?sort={sort}&c=gangbang"
                    },
                    new MenuItem()
                    {
                        title = "Gangbang Creampie",
                        playlist_url = url + $"?sort={sort}&c=gangbang-creampie"
                    },
                    new MenuItem()
                    {
                        title = "Gaping",
                        playlist_url = url + $"?sort={sort}&c=gaping"
                    },
                    new MenuItem()
                    {
                        title = "Gay",
                        playlist_url = url + $"?sort={sort}&c=gay"
                    },
                    new MenuItem()
                    {
                        title = "German",
                        playlist_url = url + $"?sort={sort}&c=german"
                    },
                    new MenuItem()
                    {
                        title = "Gloryhole",
                        playlist_url = url + $"?sort={sort}&c=gloryhole"
                    },
                    new MenuItem()
                    {
                        title = "Hairy",
                        playlist_url = url + $"?sort={sort}&c=hairy"
                    },
                    new MenuItem()
                    {
                        title = "Handjob",
                        playlist_url = url + $"?sort={sort}&c=handjob"
                    },
                    new MenuItem()
                    {
                        title = "Hardcore",
                        playlist_url = url + $"?sort={sort}&c=hardcore"
                    },
                    new MenuItem()
                    {
                        title = "Hentai",
                        playlist_url = url + $"?sort={sort}&c=hentai"
                    },
                    new MenuItem()
                    {
                        title = "Homemade",
                        playlist_url = url + $"?sort={sort}&c=homemade"
                    },
                    new MenuItem()
                    {
                        title = "Hungarian",
                        playlist_url = url + $"?sort={sort}&c=hungarian"
                    },
                    new MenuItem()
                    {
                        title = "Indian",
                        playlist_url = url + $"?sort={sort}&c=indian"
                    },
                    new MenuItem()
                    {
                        title = "Interracial",
                        playlist_url = url + $"?sort={sort}&c=interracial"
                    },
                    new MenuItem()
                    {
                        title = "Japanese",
                        playlist_url = url + $"?sort={sort}&c=japanese"
                    },
                    new MenuItem()
                    {
                        title = "Latina",
                        playlist_url = url + $"?sort={sort}&c=latina"
                    },
                    new MenuItem()
                    {
                        title = "Lesbian",
                        playlist_url = url + $"?sort={sort}&c=lesbian"
                    },
                    new MenuItem()
                    {
                        title = "Lingerie",
                        playlist_url = url + $"?sort={sort}&c=lingerie"
                    },
                    new MenuItem()
                    {
                        title = "Massage",
                        playlist_url = url + $"?sort={sort}&c=massage"
                    },
                    new MenuItem()
                    {
                        title = "Masturbation",
                        playlist_url = url + $"?sort={sort}&c=masturbation"
                    },
                    new MenuItem()
                    {
                        title = "Mature",
                        playlist_url = url + $"?sort={sort}&c=mature"
                    },
                    new MenuItem()
                    {
                        title = "Milf",
                        playlist_url = url + $"?sort={sort}&c=milf"
                    },
                    new MenuItem()
                    {
                        title = "Office",
                        playlist_url = url + $"?sort={sort}&c=office"
                    },
                    new MenuItem()
                    {
                        title = "Old and Young",
                        playlist_url = url + $"?sort={sort}&c=old-and-young"
                    },
                    new MenuItem()
                    {
                        title = "Orgy",
                        playlist_url = url + $"?sort={sort}&c=orgy"
                    },
                    new MenuItem()
                    {
                        title = "Outdoor",
                        playlist_url = url + $"?sort={sort}&c=outdoor"
                    },
                    new MenuItem()
                    {
                        title = "Petite",
                        playlist_url = url + $"?sort={sort}&c=petite"
                    },
                    new MenuItem()
                    {
                        title = "POV",
                        playlist_url = url + $"?sort={sort}&c=pov"
                    },
                    new MenuItem()
                    {
                        title = "Public",
                        playlist_url = url + $"?sort={sort}&c=public"
                    },
                    new MenuItem()
                    {
                        title = "Pussy licking",
                        playlist_url = url + $"?sort={sort}&c=pussy-licking"
                    },
                    new MenuItem()
                    {
                        title = "Red Head",
                        playlist_url = url + $"?sort={sort}&c=red-head"
                    },
                    new MenuItem()
                    {
                        title = "Riding",
                        playlist_url = url + $"?sort={sort}&c=riding"
                    },
                    new MenuItem()
                    {
                        title = "Russian",
                        playlist_url = url + $"?sort={sort}&c=russian"
                    },
                    new MenuItem()
                    {
                        title = "School Girl",
                        playlist_url = url + $"?sort={sort}&c=school-girl"
                    },
                    new MenuItem()
                    {
                        title = "Shemale",
                        playlist_url = url + $"?sort={sort}&c=shemale"
                    },
                    new MenuItem()
                    {
                        title = "Skinny",
                        playlist_url = url + $"?sort={sort}&c=skinny"
                    },
                    new MenuItem()
                    {
                        title = "Small tits",
                        playlist_url = url + $"?sort={sort}&c=small-tits"
                    },
                    new MenuItem()
                    {
                        title = "Solo",
                        playlist_url = url + $"?sort={sort}&c=solo"
                    },
                    new MenuItem()
                    {
                        title = "Squirt",
                        playlist_url = url + $"?sort={sort}&c=squirt"
                    },
                    new MenuItem()
                    {
                        title = "Strap-on",
                        playlist_url = url + $"?sort={sort}&c=strap-on"
                    },
                    new MenuItem()
                    {
                        title = "Swallow",
                        playlist_url = url + $"?sort={sort}&c=swallow"
                    },
                    new MenuItem()
                    {
                        title = "Teen",
                        playlist_url = url + $"?sort={sort}&c=teen"
                    },
                    new MenuItem()
                    {
                        title = "Threesome",
                        playlist_url = url + $"?sort={sort}&c=threesome"
                    },
                    new MenuItem()
                    {
                        title = "Titfuck",
                        playlist_url = url + $"?sort={sort}&c=titfuck"
                    },
                    new MenuItem()
                    {
                        title = "Toys",
                        playlist_url = url + $"?sort={sort}&c=toys"
                    },
                    new MenuItem()
                    {
                        title = "Uniform",
                        playlist_url = url + $"?sort={sort}&c=uniform"
                    },
                    new MenuItem()
                    {
                        title = "Vintage",
                        playlist_url = url + $"?sort={sort}&c=vintage"
                    },
                    new MenuItem()
                    {
                        title = "Webcam",
                        playlist_url = url + $"?sort={sort}&c=webcam"
                    },
                    new MenuItem()
                    {
                        title = "Wife",
                        playlist_url = url + $"?sort={sort}&c=wife"
                    }
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }

            return menu;
        }

        async public static ValueTask<Dictionary<string, string>> StreamLinks(string host, string uri, Func<string, ValueTask<string>> onresult)
        {
            if (string.IsNullOrWhiteSpace(uri))
                return null;

            string html = await onresult.Invoke($"{host}/{uri}");
            if (html == null)
                return null;

            var stream_links = new Dictionary<string, string>();
            var match = new Regex("(https?://[^/]+/get_file/[^\\.]+_([0-9]+p)\\.mp4)").Match(html);
            while (match.Success)
            {
                stream_links.TryAdd(match.Groups[2].Value, match.Groups[1].Value);
                match = match.NextMatch();
                //break;
            }

            if (stream_links.Count == 0)
            {
                string link = Regex.Match(html, "(https?://[^/]+/get_file/[^\\.]+\\.mp4)").Groups[1].Value;
                if (!string.IsNullOrWhiteSpace(link))
                    stream_links.TryAdd("auto", link);
            }

            return stream_links.Reverse().ToDictionary(k => k.Key, v => v.Value);
        }
    }
}

```

## File: Shared/Engine/SISI/XvideosTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using Shared.Models.SISI.Xvideos;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class XvideosTo
    {
        public static ValueTask<string> InvokeHtml(string host, string plugin, string search, string sort, string c, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url;

            if (!string.IsNullOrWhiteSpace(search))
            {
                url = $"{host}/?k={HttpUtility.UrlEncode(search)}&p={pg}";
            }
            else
            {
                if (!string.IsNullOrEmpty(c))
                {
                    url = $"{host}/c/s:{(sort == "top"  ? "rating" : "uploaddate")}/{c}/{pg}";
                }
                else
                {
                    if (sort == "top")
                    {
                        url = $"{host}/{(plugin == "xdsgay" ? "best-of-gay" : plugin == "xdssml" ? "best-of-shemale" : "best")}/{DateTime.Today.AddMonths(-1):yyyy-MM}";
                    }
                    else
                    {
                        url = plugin == "xdsgay" ? $"{host}/gay" : plugin == "xdssml" ? $"{host}/shemale" : $"{host}/new";
                    }

                    url += $"/{pg}";
                }
            }

            return onresult.Invoke(url);
        }


        public static List<PlaylistItem> Playlist(string uri, string uri_star, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null, string site = "xds")
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("<div id=\"video_");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                // <a href="/video.ucmdacd450a/_" title="–ì–æ—Ä–Ω–∏—á–Ω–∞—è –ø—Ä–∏—Ö–æ–¥–∏—Ç –Ω–∞ —Ä–∞–±–æ—Ç—É –≤ –∫–æ—Ä–æ—Ç–∫–æ–º –ø–ª–∞—Ç—å–µ (–ª–µ—Å–±—É—Ö–∞ –ª—é–±–∏—Ç —á–ª–µ–Ω)">
                var g = Regex.Match(row, "<a href=\"/(video[^\"]+|search-video/[^\"]+)\" title=\"([^\"]+)\"").Groups;
                if (string.IsNullOrEmpty(g[1].Value) || string.IsNullOrEmpty(g[2].Value))
                {
                    // <a href="/video.ohpbioo5118/_." target="_blank">–Ø –¥—É–º–∞–ª, —á—Ç–æ –Ω–µ –ø–µ—Ä–µ–∂–∏–≤—É –µ–≥–æ –Ω–∞–∫–∞–∑–∞–Ω–∏—è.</a>
                    g = Regex.Match(row, "<a href=\"\\/(video[^\"]+)\"[^>]+>([^<]+)").Groups;
                }

                if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                {
                    string qmark = Regex.Match(row, "<span class=\"video-hd-mark\">([^<]+)</span>").Groups[1].Value;
                    string duration = Regex.Match(row, "<span class=\"duration\">([^<]+)</span>").Groups[1].Value.Trim();

                    string img = Regex.Match(row, "data-src=\"([^\"]+)\"").Groups[1].Value;
                    img = Regex.Replace(img, "/videos/thumbs([0-9]+)/", "/videos/thumbs$1lll/");
                    img = Regex.Replace(img, "\\.THUMBNUM\\.(jpg|png)$", ".1.$1", RegexOptions.IgnoreCase);

                    // https://cdn77-pic.xvideos-cdn.com/videos/thumbs169ll/5a/6d/4f/5a6d4f718214eebf73225ec96b670f62-2/5a6d4f718214eebf73225ec96b670f62.27.jpg
                    // https://cdn77-pic.xvideos-cdn.com/videos/videopreview/5a/6d/4f/5a6d4f718214eebf73225ec96b670f62_169.mp4
                    string preview = Regex.Replace(img, "/thumbs[^/]+/", "/videopreview/");
                    preview = Regex.Replace(preview, "/[^/]+$", "");
                    preview = Regex.Replace(preview, "-[0-9]+$", "");

                    img = img.Replace("thumbs169l/", "thumbs169lll/").Replace("thumbs169ll/", "thumbs169lll/");

                    var gm = Regex.Match(row, "href=\"/([^\"]+)\"><span class=\"name\">([^<]+)<").Groups;
                    var model = string.IsNullOrEmpty(gm[1].Value) || string.IsNullOrEmpty(gm[2].Value) ? default : new ModelItem()
                    {
                        name = gm[2].Value,
                        uri = $"{uri_star}?uri=" + (gm[1].Value.Contains("/") ? gm[1].Value : $"channels/{gm[1].Value}"),
                    };

                    var pl = new PlaylistItem()
                    {
                        name = g[2].Value,
                        video = $"{uri}?uri={g[1].Value}",
                        picture = img,
                        preview = preview + "_169.mp4",
                        quality = string.IsNullOrWhiteSpace(qmark) ? null : qmark,
                        time = duration,
                        json = true,
                        related = true,
                        model = model,
                        bookmark = new Bookmark()
                        {
                            site = site,
                            href = g[1].Value,
                            image = img
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }


        async public static ValueTask<List<PlaylistItem>> Pornstars(string uri_video, string uri_star, string host, string plugin, string uri, string sort, int pg, Func<string, ValueTask<string>> onresult)
        {
            if (string.IsNullOrEmpty(uri))
                return null;

            sort = string.IsNullOrEmpty(sort) ? "new" : sort;
            string url = plugin == "xdsgay" ? $"{host}/{uri}/videos/{sort}/gay" : plugin == "xdssml" ? $"{host}/{uri}/videos/{sort}/shemale" : $"{host}/{uri}/videos/{sort}";

            url += $"/{pg}";

            string json = await onresult.Invoke(url);
            if (json == null || (!json.StartsWith("{") && !json.StartsWith("[")))
                return null;

            try
            {
                var jsonObj = JsonSerializer.Deserialize<JsonObject>(json);
                if (jsonObj == null || !jsonObj.ContainsKey("videos"))
                    return null;

                var videos = jsonObj["videos"]?.Deserialize<List<Related>>();
                if (videos == null)
                    return null;

                var playlists = new List<PlaylistItem>(videos.Count);

                foreach (var r in videos)
                {
                    if (string.IsNullOrEmpty(r.tf) || string.IsNullOrEmpty(r.u) || string.IsNullOrEmpty(r.@if))
                        continue;

                    string preview = Regex.Replace(r.@if, "/thumbs[^/]+/", "/videopreview/");
                    preview = Regex.Replace(preview, "/[^/]+$", "");
                    preview = Regex.Replace(preview, "-[0-9]+$", "");

                    var model = string.IsNullOrEmpty(r.p) || string.IsNullOrEmpty(r.pn) ? default : new ModelItem()
                    {
                        name = r.pn,
                        uri = $"{uri_star}?uri=" + (r.ch ? "channels/" : "pornstars/") + r.p,
                    };

                    playlists.Add(new PlaylistItem()
                    {
                        name = r.tf,
                        video = $"{uri_video}?uri={r.u.Remove(0, 1)}",
                        picture = r.@if,
                        preview = preview + "_169.mp4",
                        time = r.d,
                        json = true,
                        related = true,
                        model = model,
                        bookmark = new Bookmark()
                        {
                            site = "xds",
                            href = r.u.Remove(0, 1),
                            image = r.@if
                        }
                    });
                }

                return playlists;
            }
            catch 
            {
                return null;
            }
        }


        public static List<MenuItem> Menu(string host, string plugin, string sort, string c)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";
            string url = host + plugin;

            var menu = new List<MenuItem>(4)
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = url,
                }
            };

            var menusort = new MenuItem()
            {
                title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(sort == "like" ? "–ü–æ–Ω—Ä–∞–≤–∏–≤—à–∏–µ—Å—è" : sort == "top" ? "–õ—É—á—à–∏–µ" : "–ù–æ–≤–æ–µ")}",
                playlist_url = "submenu",
                submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–ù–æ–≤–æ–µ",
                        playlist_url = url + $"?c={c}"
                    },
                    new MenuItem()
                    {
                        title = "–õ—É—á—à–∏–µ",
                        playlist_url = url + $"?c={c}&sort=top"
                    }
                }
            };

            if (plugin == "xdsred" && string.IsNullOrEmpty(c))
            {
                menusort.submenu.Add(new MenuItem()
                {
                    title = "–ü–æ–Ω—Ä–∞–≤–∏–≤—à–∏–µ—Å—è",
                    playlist_url = url + $"?c={c}&sort=like"
                });
            }

            if (plugin != "xdsred" && sort != "like")
            {
                menu.Add(new MenuItem()
                {
                    title = $"–û—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è: {(plugin == "xdsgay" ? "–ì–µ–∏" : plugin == "xdssml" ? "–¢—Ä–∞–Ω—Å—ã" : "–ì–µ—Ç–µ—Ä–æ")}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ì–µ—Ç–µ—Ä–æ",
                            playlist_url = host + "xds",
                        },
                        new MenuItem()
                        {
                            title = "–ì–µ–∏",
                            playlist_url = host + "xdsgay",
                        },
                        new MenuItem()
                        {
                            title = "–¢—Ä–∞–Ω—Å—ã",
                            playlist_url = host + "xdssml",
                        }
                    }
                });
            }

            if (sort != "like" && (plugin == "xds" || plugin == "xdsred"))
            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–í—Å–µ",
                        playlist_url = url
                    },
                    new MenuItem()
                    {
                        title = "–ê–∑–∏–∞—Ç",
                        playlist_url = url + $"?sort={sort}&c=Asian_Woman-32"
                    },
                    new MenuItem()
                    {
                        title = "–ê–Ω–∞–ª",
                        playlist_url = url + $"?sort={sort}&c=Anal-12"
                    },
                    new MenuItem()
                    {
                        title = "–ê—Ä–∞–±–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Arab-159"
                    },
                    new MenuItem()
                    {
                        title = "–ë–∏—Å–µ–∫—Å—É–∞–ª—ã",
                        playlist_url = url + $"?sort={sort}&c=Bi_Sexual-62"
                    },
                    new MenuItem()
                    {
                        title = "–ë–ª–æ–Ω–¥–∏–Ω–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Blonde-20"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ –ü–æ–ø—ã",
                        playlist_url = url + $"?sort={sort}&c=Big_Ass-24"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ –°–∏—Å—å–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Big_Tits-23"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ —è–π—Ü–∞",
                        playlist_url = url + $"?sort={sort}&c=Big_Cock-34"
                    },
                    new MenuItem()
                    {
                        title = "–ë—Ä—é–Ω–µ—Ç–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Brunette-25"
                    },
                    new MenuItem()
                    {
                        title = "–í –º–∞—Å–ª–µ",
                        playlist_url = url + $"?sort={sort}&c=Oiled-22"
                    },
                    new MenuItem()
                    {
                        title = "–í–µ–± –∫–∞–º–µ—Ä—ã",
                        playlist_url = url + $"?sort={sort}&c=Cam_Porn-58"
                    },
                    new MenuItem()
                    {
                        title = "–ì—ç–Ω–≥–±—ç–Ω–≥",
                        playlist_url = url + $"?sort={sort}&c=Gangbang-69"
                    },
                    new MenuItem()
                    {
                        title = "–ó–∏—è—é—â–∏–µ –æ—Ç–≤–µ—Ä—Å—Ç–∏—è",
                        playlist_url = url + $"?sort={sort}&c=Gapes-167"
                    },
                    new MenuItem()
                    {
                        title = "–ó—Ä–µ–ª—ã–µ",
                        playlist_url = url + $"?sort={sort}&c=Mature-38"
                    },
                    new MenuItem()
                    {
                        title = "–ò–Ω–¥–∏–π—Å–∫–∏–π",
                        playlist_url = url + $"?sort={sort}&c=Indian-89"
                    },
                    new MenuItem()
                    {
                        title = "–ò—Å–ø–æ—Ä—á–µ–Ω–Ω–∞—è —Å–µ–º—å—è",
                        playlist_url = url + $"?sort={sort}&c=Fucked_Up_Family-81"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ–Ω—á–∞–µ—Ç –≤–Ω—É—Ç—Ä—å",
                        playlist_url = url + $"?sort={sort}&c=Creampie-40"
                    },
                    new MenuItem()
                    {
                        title = "–ö—É–∫–æ–ª–¥ / –ì–æ—Ä—è—á–∞—è –ñ–µ–Ω–∞",
                        playlist_url = url + $"?sort={sort}&c=Cuckold-237"
                    },
                    new MenuItem()
                    {
                        title = "–õ–∞—Ç–∏–Ω–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Latina-16"
                    },
                    new MenuItem()
                    {
                        title = "–õ–µ—Å–±–∏—è–Ω–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Lesbian-26"
                    },
                    new MenuItem()
                    {
                        title = "–õ—é–±–∏—Ç–µ–ª—å—Å–∫–æ–µ –ø–æ—Ä–Ω–æ",
                        playlist_url = url + $"?sort={sort}&c=Amateur-65"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞–º–æ—á–∫–∏. –ú–ò–õ–§",
                        playlist_url = url + $"?sort={sort}&c=Milf-19"
                    },
                    new MenuItem()
                    {
                        title = "–ú–µ–∂—Ä–∞—Å—Å–æ–≤—ã–µ",
                        playlist_url = url + $"?sort={sort}&c=Interracial-27"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∏–Ω–µ—Ç",
                        playlist_url = url + $"?sort={sort}&c=Blowjob-15"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∏–∂–Ω–µ–µ –±–µ–ª—å—ë",
                        playlist_url = url + $"?sort={sort}&c=Lingerie-83"
                    },
                    new MenuItem()
                    {
                        title = "–ü–æ–ø–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Ass-14"
                    },
                    new MenuItem()
                    {
                        title = "–†—ã–∂–∏–µ",
                        playlist_url = url + $"?sort={sort}&c=Redhead-31"
                    },
                    new MenuItem()
                    {
                        title = "–°–∫–≤–∏—Ä—Ç–∏–Ω–≥",
                        playlist_url = url + $"?sort={sort}&c=Squirting-56"
                    },
                    new MenuItem()
                    {
                        title = "–°–æ–ª–æ",
                        playlist_url = url + $"?sort={sort}&c=Solo_and_Masturbation-33"
                    },
                    new MenuItem()
                    {
                        title = "–°–ø–µ—Ä–º–∞",
                        playlist_url = url + $"?sort={sort}&c=Cumshot-18"
                    },
                    new MenuItem()
                    {
                        title = "–¢–∏–Ω–µ–π–¥–∂–µ—Ä—ã",
                        playlist_url = url + $"?sort={sort}&c=Teen-13"
                    },
                    new MenuItem()
                    {
                        title = "–§–µ–º–¥–æ–º",
                        playlist_url = url + $"?sort={sort}&c=Femdom-235"
                    },
                    new MenuItem()
                    {
                        title = "–§–∏—Å—Ç–∏–Ω–≥",
                        playlist_url = url + $"?sort={sort}&c=Fisting-165"
                    },
                    new MenuItem()
                    {
                        title = "–ß–µ—Ä–Ω—ã–µ –ñ–µ–Ω—â–∏–Ω—ã",
                        playlist_url = url + $"?sort={sort}&c=bbw-51"
                    },
                    new MenuItem()
                    {
                        title = "–ß–µ—Ä–Ω—ã–π",
                        playlist_url = url + $"?sort={sort}&c=Black_Woman-30"
                    },
                    new MenuItem()
                    {
                        title = "–ß—É–ª–∫–∏,–∫–æ–ª–≥–æ—Ç–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Stockings-28"
                    },
                    new MenuItem()
                    {
                        title = "ASMR",
                        playlist_url = url + $"?sort={sort}&c=ASMR-229"
                    }
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }

            menu.Insert(1, menusort);

            return menu;
        }


        async public static ValueTask<StreamItem> StreamLinks(string uri, string uri_star, string host, string url, Func<string, ValueTask<string>> onresult, Func<string, ValueTask<string>> onm3u = null)
        {
            if (string.IsNullOrWhiteSpace(url))
                return null;

            //string? html = await onresult.Invoke($"{host}/{Regex.Replace(url ?? "", "^([^/]+)/.*", "$1/_")}");
            string html = await onresult.Invoke($"{host}/{url}");
            if (html == null)
                return null;

            string stream_link = new Regex("html5player\\.setVideoHLS\\('([^']+)'\\);").Match(html).Groups[1].Value;
            if (string.IsNullOrWhiteSpace(stream_link))
                return null;

            #region getRelated
            List<PlaylistItem> getRelated()
            {
                var related = new List<PlaylistItem>();

                string json = Regex.Match(html!, "video_related=([^\n\r]+);window").Groups[1].Value;
                if (string.IsNullOrWhiteSpace(json) || !json.StartsWith("[") || !json.EndsWith("]"))
                    return related;

                try
                {
                    foreach (var r in JsonSerializer.Deserialize<List<Related>>(json))
                    {
                        if (string.IsNullOrEmpty(r.tf) || string.IsNullOrEmpty(r.u) || string.IsNullOrEmpty(r.@if))
                            continue;

                        string preview = Regex.Replace(r.i, "/thumbs[^/]+/", "/videopreview/");
                        preview = Regex.Replace(preview, "/[^/]+$", "");
                        preview = Regex.Replace(preview, "-[0-9]+$", "");

                        var model = string.IsNullOrEmpty(r.p) || string.IsNullOrEmpty(r.pn) ? default : new ModelItem()
                        {
                            name = r.pn,
                            uri = $"{uri_star}?uri=" + (r.ch ? "channels/" : "pornstars/") + r.p,
                        };

                        related.Add(new PlaylistItem()
                        {
                            name = r.tf,
                            video = $"{uri}?uri={r.u.Remove(0, 1)}",
                            picture = r.@if,
                            preview = preview + "_169.mp4",
                            time = r.d,
                            json = true,
                            related = true,
                            model = model,
                            bookmark = new Bookmark()
                            {
                                site = "xds",
                                href = r.u.Remove(0, 1),
                                image = r.@if
                            }
                        });
                    }
                }
                catch { }

                return related;
            }
            #endregion

            string m3u8 = onm3u == null ? null : await onm3u.Invoke(stream_link);
            if (m3u8 == null)
            {
                return new StreamItem()
                {
                    qualitys = new Dictionary<string, string>()
                    {
                        ["auto"] = stream_link
                    },
                    recomends = getRelated()
                };
            }

            var stream_links = new Dictionary<int, string>();

            foreach (string line in m3u8.Split('\n'))
            {
                if (string.IsNullOrWhiteSpace(line) || !line.StartsWith("hls-"))
                    continue;

                string _q = new Regex("hls-([0-9]+)p").Match(line).Groups[1].Value;

                if (int.TryParse(_q, out int q) && q > 0)
                    stream_links.TryAdd(q, $"{Regex.Replace(stream_link, "/hls.m3u8.*", "")}/{line}");
            }

            return new StreamItem()
            {
                qualitys = stream_links.OrderByDescending(i => i.Key).ToDictionary(k => $"{k.Key}p", v => v.Value),
                recomends = getRelated()
            };
        }
    }
}

```

## File: Shared/Engine/JacRed/tParse.cs
```
Ôªøusing System.Globalization;
using System.Text.RegularExpressions;

namespace Shared.Engine.JacRed
{
    public static class tParse
    {
        #region BytesToString
        public static string BytesToString(long byteCount)
        {
            string[] suf = { "Byt", "KB", "MB", "GB", "TB", "PB", "EB" };
            if (byteCount == 0)
                return "0 " + suf[0];
            long bytes = Math.Abs(byteCount);
            int place = Convert.ToInt32(Math.Floor(Math.Log(bytes, 1024)));
            double num = Math.Round(bytes / Math.Pow(1024, place), 1);
            return (Math.Sign(byteCount) * num).ToString().Replace(",", ".") + " " + suf[place];
        }
        #endregion

        #region ParseCreateTime
        public static DateTime ParseCreateTime(string line, string format)
        {
            line = Regex.Replace(line, " —è–Ω–≤\\.? ", ".01.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " —Ñ–µ–≤—Ä?\\.? ", ".02.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –º–∞—Ä—Ç?\\.? ", ".03.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∞–ø—Ä\\.? ", ".04.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –º–∞–π\\.? ", ".05.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∏—é–Ω—å?\\.? ", ".06.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∏—é–ª—å?\\.? ", ".07.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∞–≤–≥\\.? ", ".08.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " —Å–µ–Ω—Ç?\\.? ", ".09.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –æ–∫—Ç\\.? ", ".10.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –Ω–æ—è–±?\\.? ", ".11.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –¥–µ–∫\\.? ", ".12.", RegexOptions.IgnoreCase);

            line = Regex.Replace(line, " —è–Ω–≤(–∞—Ä—è?)? ", ".01.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " —Ñ–µ–≤(—Ä–∞–ª—è?)? ", ".02.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –º–∞—Ä—Ç–∞? ", ".03.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∞–ø—Ä(–µ–ª—è?)? ", ".04.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –º–∞(–π|—è)? ", ".05.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∏—é–Ω(—å|—è)? ", ".06.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∏—é–ª(—å|—è)? ", ".07.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∞–≤–≥(—É—Å—Ça?)? ", ".08.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " —Å–µ–Ω—Ç(—è–±—Ä(—è|—å)?)? ", ".09.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –æ–∫—Ç(—è–±—Ä(—è|—å)?)? ", ".10.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –Ω–æ—è(–±—Ä(—è|—å)?)? ", ".11.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –¥–µ–∫(–∞–±—Ä(—è|—å)?)? ", ".12.", RegexOptions.IgnoreCase);

            line = Regex.Replace(line, " —è–Ω–≤–∞—Ä(—å|—è)?\\.? ", ".01.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " —Ñ–µ–≤—Ä–∞–ª(—å|—è)?\\.? ", ".02.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –º–∞—Ä—Ç–∞?\\.? ", ".03.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∞–ø—Ä–µ–ª(—å|—è)?\\.? ", ".04.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –º–∞–π?—è?\\.? ", ".05.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∏—é–Ω(—å|—è)?\\.? ", ".06.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∏—é–ª(—å|—è)?\\.? ", ".07.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∞–≤–≥—É—Å—Ç–∞?\\.? ", ".08.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " —Å–µ–Ω—Ç—è–±—Ä(—å|—è)?\\.? ", ".09.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –æ–∫—Ç—è–±—Ä(—å|—è)?\\.? ", ".10.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –Ω–æ—è–±—Ä(—å|—è)?\\.? ", ".11.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –¥–µ–∫–∞–±—Ä(—å|—è)?\\.? ", ".12.", RegexOptions.IgnoreCase);

            line = Regex.Replace(line, " Jan ", ".01.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Feb ", ".02.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Mar ", ".03.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Apr ", ".04.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " May ", ".05.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Jun ", ".06.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Jul ", ".07.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Aug ", ".08.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Sep ", ".09.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Oct ", ".10.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Nov ", ".11.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Dec ", ".12.", RegexOptions.IgnoreCase);

            if (Regex.IsMatch(line, "^[0-9]\\."))
                line = $"0{line}";

            DateTime.TryParseExact(line.ToLower(), format, new CultureInfo("ru-RU"), DateTimeStyles.None, out DateTime createTime);
            return createTime;
        }
        #endregion
    }
}

```

## File: Shared/Engine/JacRed/BencodeTo.cs
```
Ôªøusing BencodeNET.Parsing;
using BencodeNET.Torrents;
using System.Text.RegularExpressions;

namespace Shared.Engine.JacRed
{
    public static class BencodeTo
    {
        #region Magnet
        public static string Magnet(in byte[] torrent)
        {
            try
            {
                if (torrent == null)
                    return null;

                var parser = new BencodeParser();
                var res = parser.Parse<Torrent>(torrent);

                string magnet = res.GetMagnetLink();
                if (res.OriginalInfoHash != null)
                    magnet = Regex.Replace(magnet, @"urn:btih:[\w0-9]+", $"urn:btih:{res.OriginalInfoHash.ToLower()}", RegexOptions.IgnoreCase);

                return magnet;
            }
            catch 
            {
                return null;
            }
        }
        #endregion

        #region SizeName
        public static string SizeName(in byte[] torrent)
        {
            try
            {
                if (torrent == null)
                    return null;

                var parser = new BencodeParser();
                var res = parser.Parse<Torrent>(torrent);

                string FormatBytes(long bytes)
                {
                    string[] Suffix = { "B", "KB", "MB", "GB", "TB" };
                    int i;
                    double dblSByte = bytes;
                    for (i = 0; i < Suffix.Length && bytes >= 1024; i++, bytes /= 1024)
                    {
                        dblSByte = bytes / 1024.0;
                    }

                    return String.Format("{0:N2} {1}", dblSByte, Suffix[i]).Replace(",", ".");
                }

                return FormatBytes(res.TotalSize);
            }
            catch
            {
                return null;
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Collaps.cs
```
Ôªøusing Shared.Models;
using Shared.Models.Base;
using Shared.Models.Online.Collaps;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct CollapsInvoke
    {
        #region CollapsInvoke
        string host;
        string apihost;
        bool dash;
        Func<string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Action requesterror;

        public CollapsInvoke(string host, string apihost, bool dash, Func<string, ValueTask<string>> onget, Func<string, string> onstreamfile, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.dash = dash;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        public async ValueTask<EmbedModel?> Embed(string imdb_id, long kinopoisk_id, long orid)
        {
            string uri = $"{apihost}/embed/imdb/{imdb_id}";
            if (kinopoisk_id > 0)
                uri = $"{apihost}/embed/kp/{kinopoisk_id}";
            if (orid > 0)
                uri = $"{apihost}/embed/movie/{orid}";

            string content = await onget.Invoke(uri);
            if (string.IsNullOrEmpty(content))
            {
                requesterror?.Invoke();
                return null;
            }

            if (!content.Contains("seasons:"))
                return new EmbedModel() { content = content };

            RootObject[] root = null;

            try
            {
                root = JsonSerializer.Deserialize<RootObject[]>(Regex.Match(content, "seasons:([^\n\r]+)").Groups[1].Value);
                if (root == null || root.Length == 0)
                    return null;
            }
            catch { return null; }

            return new EmbedModel() { serial = root };
        }
        #endregion

        #region Html
        public string Html(EmbedModel md, string imdb_id, long kinopoisk_id, long orid, string title, string original_title, int s, bool rjson = false, List<HeadersModel> headers = null, VastConf vast = null)
        {
            if (md == null)
                return string.Empty;

            if (md.content != null)
            {
                #region –§–∏–ª—å–º
                string stream = Regex.Match(md.content, "hls: +\"(https?://[^\"]+\\.m3u[^\"]+)\"").Groups[1].Value;

                if (dash)
                {
                    string _dash = Regex.Match(md.content, "dasha?: +\"(https?://[^\"]+\\.mp[^\"]+)\"").Groups[1].Value;
                    if (!string.IsNullOrEmpty(_dash))
                        stream = _dash;
                }

                if (string.IsNullOrEmpty(stream))
                    return string.Empty;

                var mtpl = new MovieTpl(title, original_title, 1);

                string name = Regex.Match(md.content, "audio: +\\{\"names\":\\[\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrWhiteSpace(name))
                    name = "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é";

                #region subtitle
                SubtitleTpl? subtitles = null;

                try
                {
                    var subs = JsonSerializer.Deserialize<List<Cc>>(Regex.Match(md.content, "cc: +(\\[[^\n\r]+\\]),").Groups[1].Value);
                    if (subs != null)
                    {
                        subtitles = new SubtitleTpl(subs.Count);
                        foreach (var cc in subs)
                        {
                            if (cc.url != null)
                                subtitles.Value.Append(cc.name, onstreamfile.Invoke(cc.url));
                        }
                    }
                }
                catch { }
                #endregion

                string voicename = Regex.Match(md.content, "audio: +\\{\"names\":\\[\"([^\\]]+)\\]").Groups[1].Value;
                voicename = voicename.Replace("\"", "").Replace("delete", "").Replace(",", ", ");
                voicename = Regex.Replace(voicename, "[, ]+$", "");

                mtpl.Append(name, onstreamfile.Invoke(stream.Replace("\u0026", "&")), subtitles: subtitles, voice_name: voicename, headers: headers, vast: vast);

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                try
                {
                    if (s == -1)
                    {
                        var tpl = new SeasonTpl(md.serial.Length);

                        foreach (var season in md.serial.OrderBy(i => i.season))
                        {
                            string link = host + $"lite/collaps?rjson={rjson}&kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&orid={orid}&title={enc_title}&original_title={enc_original_title}&s={season.season}";
                            tpl.Append($"{season.season} —Å–µ–∑–æ–Ω", link, season.season);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        var episodes = md.serial.FirstOrDefault(i => i.season == s).episodes;
                        if (episodes == null)
                            return string.Empty;

                        var etpl = new EpisodeTpl(episodes.Length);
                        string sArch = s.ToString();

                        foreach (var episode in episodes)
                        {
                            string stream = episode.hls ?? episode.dasha ?? episode.dash;
                            if (dash && (episode.dasha ?? episode.dash) != null)
                                stream = episode.dasha ?? episode.dash;

                            if (string.IsNullOrEmpty(stream) || string.IsNullOrEmpty(episode.episode))
                                continue;

                            #region voicename
                            string voicename = string.Empty;

                            if (episode.audio.names != null)
                                voicename = Regex.Replace(string.Join(", ", episode.audio.names), "[, ]+$", "");
                            #endregion

                            #region subtitle
                            var subtitles = new SubtitleTpl(episode.cc?.Length ?? 0);

                            if (episode.cc != null && episode.cc.Length > 0)
                            {
                                foreach (var cc in episode.cc)
                                {
                                    if (cc.url != null)
                                        subtitles.Append(cc.name, onstreamfile.Invoke(cc.url));
                                }
                            }
                            #endregion

                            string file = onstreamfile.Invoke(stream.Replace("\u0026", "&"));
                            etpl.Append($"{episode.episode} —Å–µ—Ä–∏—è", title ?? original_title, sArch, episode.episode, file, subtitles: subtitles, voice_name: voicename, headers: headers, vast: vast);
                        }

                        return rjson ? etpl.ToJson() : etpl.ToHtml();
                    }
                }
                catch
                {
                    return string.Empty;
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/iRemux.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.iRemux;
using Shared.Models.Templates;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct iRemuxInvoke
    {
        #region iRemuxInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public iRemuxInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.onpost = onpost;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        async public ValueTask<EmbedModel> Embed(string title, string original_title, int year, string link)
        {
            var result = new EmbedModel();

            if (string.IsNullOrEmpty(link))
            {
                string search = await onget($"{apihost}/index.php?do=search&subaction=search&from_page=0&story={HttpUtility.UrlEncode(title ?? original_title)}");
                if (search == null)
                {
                    requesterror?.Invoke();
                    return null;
                }

                string stitle = title?.ToLower();
                string sorigtitle = original_title?.ToLower();

                foreach (string row in search.Split("item--announce").Skip(1))
                {
                    var g = Regex.Match(row, "class=\"item__title( [^\"]+)?\"><a href=\"(?<link>https?://[^\"]+)\">(?<name>[^<]+)</a>").Groups;

                    string name = g["name"].Value.ToLower();
                    if (name.Contains("—Å–µ–∑–æ–Ω") || name.Contains("—Å–µ—Ä–∏–∏") || name.Contains("—Å–µ—Ä–∏—è"))
                        continue;

                    if ((!string.IsNullOrEmpty(stitle) && name.Contains(stitle)) || (!string.IsNullOrEmpty(sorigtitle) && name.Contains(sorigtitle)))
                    {
                        if (string.IsNullOrEmpty(g["link"].Value))
                            continue;

                        if (name.Contains($"({year}/"))
                        {
                            result.similars.Add(new Similar()
                            {
                                title = name,
                                year = year.ToString(),
                                href = g["link"].Value
                            });
                        }
                    }
                }

                if (result.similars.Count == 0)
                {
                    if (search.Contains(">–ü–æ–∏—Å–∫ –ø–æ —Å–∞–π—Ç—É<"))
                        return new EmbedModel() { IsEmpty = true };

                    return null;
                }

                if (result.similars.Count > 1)
                    return result;

                link = result.similars[0].href;
            }

            string news = await onget(link);
            if (news == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string content = news.Split("page__desc")[1].Split("page__dl")[0];
            if (!content.Contains("cloud.mail.ru/public/"))
                return null;

            result.content = content.Replace("<!--colorend--></span><!--/colorend-->", "");
            return result;
        }
        #endregion

        #region Html
        public string Html(EmbedModel result, string title, string original_title, int year, bool rjson = false)
        {
            if (result == null || result.IsEmpty)
                return string.Empty;

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            #region similar
            if (result.content == null)
            {
                if (result.similars != null && result.similars.Count > 0)
                {
                    var stpl = new SimilarTpl(result.similars.Count);

                    foreach (var similar in result.similars)
                    {
                        string link = host + $"lite/remux?title={enc_title}&original_title={enc_original_title}&year={year}&href={HttpUtility.UrlEncode(similar.href)}";

                        stpl.Append(similar.title, similar.year, string.Empty, link);
                    }

                    return rjson ? stpl.ToJson() : stpl.ToHtml();
                }

                return string.Empty;
            }
            #endregion

            var mtpl = new MovieTpl(title, original_title, 4);

            foreach (Match m in Regex.Matches(result.content, $">([^<]+)(<[^>]+>)?<a href=\"https?://cloud.mail.ru/public/([^\"]+)\""))
            {
                string linkid = m.Groups[3].Value;
                if (string.IsNullOrEmpty(linkid))
                    continue;

                foreach (string q in new string[] { "2160p", "1080p", "720p", "480p" })
                {
                    string _qs = q == "480p" ? "1400" : q;
                    if (m.Groups[1].Value.Contains(_qs))
                    {
                        mtpl.Append(q, host + $"lite/remux/movie?linkid={linkid}&quality={q}&title={enc_title}&original_title={enc_original_title}", "call");
                        break;
                    }
                }
            }

            return rjson ? mtpl.ToJson(reverse: true) : mtpl.ToHtml(reverse: true);
        }
        #endregion


        #region Weblink
        async public ValueTask<string> Weblink(string linkid)
        {
            string html = await onget($"https://cloud.mail.ru/public/{linkid}");
            if (html == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string weblinkRow = StringConvert.FindLastText(html, "\"weblink_get\"", "}");
            if (weblinkRow == null)
                return null;

            string location = Regex.Match(weblinkRow, "\"url\": ?\"(https?://[^/]+)").Groups[1].Value;
            if (string.IsNullOrEmpty(location))
                return null;

            return $"{location}/weblink/view/{linkid}";
        }
        #endregion

        #region Movie
        public string Movie(in string weblink, in string quality, in string title, in string original_title, VastConf vast = null)
        {
            return VideoTpl.ToJson("play", onstreamfile?.Invoke(weblink), (title ?? original_title), quality: quality, vast: vast);
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/VideoDB.cs
```
Ôªøusing Shared.Models;
using Shared.Models.Online.VideoDB;
using Shared.Models.Templates;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct VideoDBInvoke
    {
        #region VideoDBInvoke
        string host;
        string apihost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Func<string, List<HeadersModel>, ValueTask<string>> onget;

        public VideoDBInvoke(string host, string apihost, Func<string, List<HeadersModel>, ValueTask<string>> onget, Func<string, string> onstreamfile, Func<string, string> onlog = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost!;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.onget = onget;
        }
        #endregion

        #region Embed
        public async ValueTask<EmbedModel> Embed(long kinopoisk_id)
        {
            string html = await onget.Invoke($"{apihost}/embed/AN?kinopoisk_id={kinopoisk_id}", null);

            if (html == null)
            {
                onlog?.Invoke("VideoDB: html null");
                return null;
            }

            return Embed(html);
        }

        public EmbedModel Embed(in string html)
        {
            if (string.IsNullOrEmpty(html))
                return null;

            string decodePlayer(in string _html)
            {
                try
                {
                    string base64 = Regex.Match(_html, "new Player\\(\"([^\n\r]+)\"\\);").Groups[1].Value.Remove(0, 73);
                    base64 = Regex.Replace(base64, "//[^=]+=", "");
                    string json = Encoding.UTF8.GetString(Convert.FromBase64String(base64));
                    //json = json.Split("\"player\",\"file\":")[1].Split(",\"hls\":")[0];

                    return json;
                }
                catch 
                {
                    return null;
                }
            }

            string file = decodePlayer(html);
            if (file == null)
            {
                onlog?.Invoke("VideoDB: file null");
                return null;
            }

            onlog?.Invoke("VideoDB: file OK");

            var pl = JsonNode.Parse(file)?["file"]?.Deserialize<RootObject[]>();
            if (pl == null || pl.Length == 0)
            {
                onlog?.Invoke("VideoDB: pl null");
                return null;
            }

            onlog?.Invoke("VideoDB: pl OK");

            string quality = file.Contains("2160p") ? "2160p" : file.Contains("1080p") ? "1080p" : file.Contains("720p") ? "720p" : "480p";
            return new EmbedModel() { pl = pl, movie = !file.Contains("\"folder\":"), quality = quality };
        }
        #endregion

        #region Html
        public string Html(EmbedModel root, string args, long kinopoisk_id, string title, string original_title, string t, int s, int sid, bool rjson, bool bwa = false, bool rhub = false)
        {
            if (root?.pl == null || root.pl.Length == 0)
                return string.Empty;

            if (!string.IsNullOrEmpty(args))
                args = $"&{args.Remove(0, 1)}";

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            if (root.movie)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, root.pl.Length);

                foreach (var pl in root.pl)
                {
                    string name = pl.title;
                    string file = pl.file;

                    if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(file))
                        continue;

                    #region streams
                    var streams = new List<(string link, string quality)>(7);

                    foreach (Match m in Regex.Matches(file, $"\\[(–ê–≤—Ç–æ|2160|1440|1080|720|480|360)p?\\]([^\"\\,\\[ ]+)"))
                    {
                        string link = m.Groups[2].Value;
                        if (string.IsNullOrEmpty(link))
                            continue;

                        string quality = file.Contains("2160p") ? "2160" : file.Contains("1080p") ? "1080" : file.Contains("720p") ? "720" : "480";
                        streams.Add((host + $"lite/videodb/manifest.m3u8?link={HttpUtility.UrlEncode(link)}{args}", quality));
                    }

                    if (streams.Count == 0)
                        continue;

                    streams.Reverse();
                    #endregion

                    #region subtitle (off)
                    //var subtitles = new SubtitleTpl();

                    //try
                    //{
                    //    int subx = 1;
                    //    var subs = pl.subtitle;
                    //    if (subs != null)
                    //    {
                    //        foreach (string cc in subs.Split(","))
                    //        {
                    //            if (string.IsNullOrWhiteSpace(cc) || !cc.EndsWith(".srt"))
                    //                continue;

                    //            subtitles.Append($"sub #{subx}", onstreamfile.Invoke(cc));
                    //            subx++;
                    //        }
                    //    }
                    //}
                    //catch { }
                    #endregion

                    if (bwa || rhub)
                    {
                        mtpl.Append(name, streams[0].link.Replace("/manifest.m3u8", "/manifest"), "call");
                    }
                    else
                    {
                        mtpl.Append(name, streams[0].link, quality: streams[0].quality);
                    }
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                if (s == -1)
                {
                    var tpl = new SeasonTpl(root.quality, root.pl.Length);

                    for(int i = 0; i < root.pl.Length; i++)
                    {
                        string name = root.pl?[i].title;
                        if (name == null)
                            continue;

                        string season = Regex.Match(name, "^([0-9]+)").Groups[1].Value;
                        if (string.IsNullOrEmpty(season))
                            continue;

                        tpl.Append(name, host + $"lite/videodb?rjson={rjson}&kinopoisk_id={kinopoisk_id}&rjson={rjson}&title={enc_title}&original_title={enc_original_title}&s={season}&sid={i}", season);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                }
                else
                {
                    var season = root.pl[sid].folder;
                    if (season == null)
                        return string.Empty;

                    var vtpl = new VoiceTpl();
                    var etpl = new EpisodeTpl();

                    var hashvoices = new HashSet<string>();

                    string sArhc = s.ToString();

                    foreach (var episode in season)
                    {
                        var episodes = episode.folder;
                        if (episodes == null || episodes.Length == 0)
                            continue;

                        foreach (var pl in episodes)
                        {
                            // MVO | LostFilm
                            string perevod = Regex.Replace(pl.title ?? "", "^[a-zA-Z]{3} \\| ", "");
                            if (!string.IsNullOrEmpty(perevod) && string.IsNullOrEmpty(t))
                                t = perevod;

                            #region –ü–µ—Ä–µ–≤–æ–¥—ã
                            if (!hashvoices.Contains(perevod))
                            {
                                hashvoices.Add(perevod);
                                string link = host + $"lite/videodb?rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&s={s}&sid={sid}&t={HttpUtility.UrlEncode(perevod)}";

                                vtpl.Append(perevod, t == perevod, link);
                            }
                            #endregion

                            if (perevod != t)
                                continue;

                            // 1 —ç–ø–∏–∑–æ–¥ 
                            string name = episode.title;
                            string file = pl.file;

                            if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(file))
                                continue;

                            var streamquality = new StreamQualityTpl();

                            foreach (Match m in Regex.Matches(file, $"\\[(1080|720|480|360)p?\\]([^\"\\,\\[ ]+)"))
                            {
                                string link = m.Groups[2].Value;
                                if (string.IsNullOrEmpty(link))
                                    continue;

                                streamquality.Insert(host + $"lite/videodb/manifest.m3u8?serial=true&link={HttpUtility.UrlEncode(link)}{args}", $"{m.Groups[1].Value}p");
                            }

                            if (!streamquality.Any())
                                continue;

                            if (bwa || rhub)
                            {
                                string streamlink = rhub ? streamquality.Firts().link : null;
                                etpl.Append(name, title ?? original_title, sArhc, Regex.Match(name, "^([0-9]+)").Groups[1].Value, streamquality.Firts().link.Replace("/manifest.m3u8", "/manifest"), "call", streamlink: streamlink);
                            }
                            else
                            {
                                etpl.Append(name, title ?? original_title, sArhc, Regex.Match(name, "^([0-9]+)").Groups[1].Value, streamquality.Firts().link, streamquality: streamquality);
                            }
                        }
                    }

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/FilmixTV.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.Filmix;
using Shared.Models.Online.FilmixTV;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Web;

namespace Shared.Engine.Online
{
    public class FilmixTVInvoke
    {
        #region FilmixTVInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;
        bool rjson;

        public FilmixTVInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null, bool rjson = false)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onpost = onpost;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
            this.rjson = rjson;
        }
        #endregion

        #region Search
        async public ValueTask<SearchResult> Search(string title, string original_title, int clarification, int year, bool similar)
        {
            if (string.IsNullOrWhiteSpace(title ?? original_title))
                return null;

            string uri = $"{apihost}/api-fx/list?search={HttpUtility.UrlEncode(clarification == 1 ? title : (original_title ?? title))}&limit=48";
            onlog?.Invoke(uri);

            string json = await onget.Invoke(uri);
            if (string.IsNullOrEmpty(json) || !json.Contains("\"status\":\"ok\""))
                return await Search2(title, original_title, year, clarification);

            List<SearchModel> root = null;

            try
            {
                root = JsonNode.Parse(json)?["items"]?.Deserialize<List<SearchModel>>();
            }
            catch { }

            if (root == null || root.Count == 0)
                return await Search2(title, original_title, year, clarification);

            var ids = new List<int>(root.Count);
            var stpl = new SimilarTpl(root.Count);

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            foreach (var item in root)
            {
                if (item == null)
                    continue;

                string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.original_name) ? $"{item.title} / {item.original_name}" : (item.title ?? item.original_name);

                stpl.Append(name, item.year.ToString(), string.Empty, host + $"lite/filmixtv?postid={item.id}&title={enc_title}&original_title={enc_original_title}", PosterApi.Size(item.poster));

                if ((!string.IsNullOrEmpty(stitle) && StringConvert.SearchName(item.title) == stitle) ||
                    (!string.IsNullOrEmpty(sorigtitle) && StringConvert.SearchName(item.original_name) == sorigtitle))
                {
                    if (item.year == year)
                        ids.Add(item.id);
                }
            }

            onlog?.Invoke("ids: " + ids.Count);

            if (ids.Count == 1 && !similar)
                return new SearchResult() { id = ids[0] };

            return new SearchResult() { similars = stpl };
        }
        #endregion

        #region Search2
        async ValueTask<SearchResult> Search2(string title, string original_title, int year, int clarification)
        {
            async Task<List<SearchModel>> gosearch(string story)
            {
                if (string.IsNullOrEmpty(story))
                    return null;

                string uri = $"http://filmixapp.cyou/api/v2/search?story={HttpUtility.UrlEncode(story)}&user_dev_apk=2.0.1&user_dev_id=&user_dev_name=Xiaomi&user_dev_os=11&user_dev_token=&user_dev_vendor=Xiaomi";
                onlog?.Invoke(uri);

                string json = await onget.Invoke(uri);
                if (json == null)
                    return null;

                List<SearchModel> root = null;

                try
                {
                    root = JsonSerializer.Deserialize<List<SearchModel>>(json);
                }
                catch { }

                if (root == null || root.Count == 0)
                    return null;

                return root;
            }

            var result = await gosearch(clarification == 1 ? original_title : title);
            if (result == null)
                result = await gosearch(clarification == 1 ? title : original_title);

            if (result == null)
                return null;

            var ids = new List<int>(result.Count);
            var stpl = new SimilarTpl(result.Count);

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            foreach (var item in result)
            {
                if (item == null)
                    continue;

                string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.original_title) ? $"{item.title} / {item.original_title}" : (item.title ?? item.original_title);

                stpl.Append(name, item.year.ToString(), string.Empty, host + $"lite/filmixtv?postid={item.id}&title={enc_title}&original_title={enc_original_title}", PosterApi.Size(item.poster));

                if ((!string.IsNullOrEmpty(stitle) && StringConvert.SearchName(item.title) == stitle) ||
                    (!string.IsNullOrEmpty(sorigtitle) && StringConvert.SearchName(item.original_title) == sorigtitle))
                {
                    if (item.year == year)
                        ids.Add(item.id);
                }
            }

            onlog?.Invoke("ids: " + ids.Count);

            if (ids.Count == 1)
                return new SearchResult() { id = ids[0] };

            return new SearchResult() { similars = stpl };
        }
        #endregion

        #region Post
        public Models.Online.FilmixTV.RootObject Post(in string json)
        {
            if (string.IsNullOrWhiteSpace(json))
            {
                requesterror?.Invoke();
                return null;
            }

            try
            {
                var rootMs = new Models.Online.FilmixTV.RootObject();

                if (JsonDocument.Parse(json).RootElement.ValueKind == JsonValueKind.Array)
                {
                    rootMs.Movies = JsonSerializer.Deserialize<MovieTV[]>(json);
                }
                else
                {
                    rootMs.SerialVoice = JsonSerializer.Deserialize<Dictionary<string, Dictionary<string, Season>>>(json);
                }

                return rootMs;
            }
            catch { return null; }
        }
        #endregion

        #region Html
        public string Html(Models.Online.FilmixTV.RootObject root, bool pro, int postid, string title, string original_title, int t, int? s, VastConf vast = null)
        {
            if (root == null)
                return string.Empty;

            #region –°–µ—Ä–∏–∞–ª
            if (root.SerialVoice != null)
            {
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                if (s == null)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    var maxQuality = root.SerialVoice.SelectMany(i => i.Value)
                        .SelectMany(season => season.Value.episodes)
                        .SelectMany(episode => episode.Value.files)
                        .Max(file => file.quality);

                    var tpl = new SeasonTpl($"{maxQuality}p");
                    var temp = new HashSet<int>();

                    foreach (var translation in root.SerialVoice)
                    {
                        foreach (var season in translation.Value)
                        {
                            if (temp.Contains(season.Value.season))
                                continue;

                            temp.Add(season.Value.season);

                            var link = $"{host}lite/filmixtv?rjson={rjson}&postid={postid}&title={enc_title}&original_title={enc_original_title}&s={season.Value.season}";
                            tpl.Append($"{season.Value.season} —Å–µ–∑–æ–Ω", link, season.Value.season);
                        }
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                    #endregion
                }
                else
                {
                    #region –ü–µ—Ä–µ–≤–æ–¥ 
                    int indexTranslate = 0;
                    var vtpl = new VoiceTpl();

                    foreach (var translation in root.SerialVoice)
                    {
                        foreach (var season in translation.Value)
                        {
                            if (season.Value.season == s)
                            {
                                string link = host + $"lite/filmixtv?rjson={rjson}&postid={postid}&title={enc_title}&original_title={enc_original_title}&s={s}&t={indexTranslate}";
                                bool active = t == indexTranslate;

                                if (t == -1)
                                    t = indexTranslate;

                                vtpl.Append(translation.Key, active, link);
                            }
                        }

                        indexTranslate++;
                    }
                    #endregion

                    var selectedSeason = root.SerialVoice.ElementAt(t).Value.FirstOrDefault(x => x.Value.season == s);

                    if (selectedSeason.Value.episodes == null)
                        return string.Empty;

                    var etpl = new EpisodeTpl(selectedSeason.Value.episodes.Count);

                    foreach (var episode in selectedSeason.Value.episodes)
                    {
                        var streamquality = new StreamQualityTpl();

                        var sortedFiles = episode.Value.files
                            .Where(file => pro || file.quality <= 720)
                            .OrderByDescending(file => file.quality);

                        foreach (var file in sortedFiles)
                            streamquality.Append(onstreamfile.Invoke(file.url), $"{file.quality}p");

                        if (!streamquality.Any())
                            continue;

                        etpl.Append($"{episode.Key.TrimStart('e')} —Å–µ—Ä–∏—è", title ?? original_title, selectedSeason.Value.season.ToString(), episode.Key.TrimStart('e'), streamquality.Firts().link, streamquality: streamquality, vast: vast);
                    }

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                }
            }
            #endregion

            #region –§–∏–ª—å–º
            else if (root.Movies != null)
            {
                var mtpl = new MovieTpl(title, original_title, root.Movies.Length);

                foreach (var item in root.Movies)
                {
                    var streamquality = new StreamQualityTpl();

                    foreach (var file in item.files)
                    {
                        if (!pro)
                        {
                            if (pro && file.quality > 480)
                                continue;

                            if (file.quality > 720)
                                continue;
                        }

                        streamquality.Append(onstreamfile.Invoke(file.url), $"{file.quality}p");
                    }

                    if (!streamquality.Any())
                        continue;

                    mtpl.Append(item.voiceover, streamquality.Firts().link, streamquality: streamquality, vast: vast);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
            }
            #endregion

            return string.Empty;
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Lumex.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.Lumex;
using Shared.Models.Online.Settings;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct LumexInvoke
    {
        #region LumexInvoke
        string host, scheme;
        bool hls;
        string apihost;
        string token;
        Func<string, string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public string onstream(string stream)
        {
            if (onstreamfile == null)
                return stream;

            return onstreamfile.Invoke(stream);
        }

        public LumexInvoke(LumexSettings init, Func<string, string, ValueTask<string>> onget, Func<string, string> onstreamfile, string host = null, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.scheme = init.scheme ?? "http";
            this.hls = init.hls;
            this.apihost = init.cors(init.apihost);
            this.token = init!.token;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
        }
        #endregion

        #region Search
        public async ValueTask<SimilarTpl> Search(string title, string original_title, int serial, int clarification, IEnumerable<DatumDB> database = null)
        {
            if (string.IsNullOrWhiteSpace(title ?? original_title))
                return default;

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            if (!string.IsNullOrEmpty(token))
            {
                #region api/short
                string uri = $"{apihost}/api/short?api_token={token}&title={HttpUtility.UrlEncode(clarification == 1 ? title : (original_title ?? title))}";

                string json = await onget.Invoke(uri, apihost);
                if (json == null)
                {
                    requesterror?.Invoke();
                    return default;
                }

                SearchRoot root = null;

                try
                {
                    root = JsonSerializer.Deserialize<SearchRoot>(json);
                    if (root?.data == null || root.data.Length == 0)
                        return default;
                }
                catch { return default; }

                var stpl = new SimilarTpl(root.data.Length);

                foreach (var item in root.data)
                {
                    if (serial != -1)
                    {
                        if ((serial == 0 && item.content_type != "movie") || (serial == 1 && item.content_type == "movie"))
                            continue;
                    }

                    if (clarification != 1)
                    {
                        bool isok = title != null && title.Length > 3 && item.title != null && item.title.ToLower().Contains(title.ToLower());
                        isok = isok ? true : original_title != null && original_title.Length > 3 && item.orig_title != null && item.orig_title.ToLower().Contains(original_title.ToLower());

                        if (!isok)
                            continue;
                    }

                    string year = item.add?.Split("-")?[0] ?? string.Empty;
                    string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.orig_title) ? $"{item.title} / {item.orig_title}" : (item.title ?? item.orig_title);

                    string details = $"imdb: {item.imdb_id} {stpl.OnlineSplit} kinopoisk: {item.kp_id}";

                    string img = PosterApi.Find(item.kp_id, item.imdb_id);
                    stpl.Append(name, year, details, host + $"lite/lumex?title={enc_title}&original_title={enc_original_title}&content_type={item.content_type}&content_id={item.id}&clarification={clarification}", img);
                }

                return stpl;
                #endregion
            }
            else if (database != null)
            {
                #region database
                int capacity = 100;
                if (database is ICollection<DatumDB> collection)
                    capacity = collection.Count > 100 ? 100 : collection.Count;

                var stpl = new SimilarTpl(capacity);

                foreach (var item in database)
                {
                    if (stpl.data.Count >= 100)
                        break;

                    if (item.kinopoisk_id == 0 && string.IsNullOrEmpty(item.imdb_id))
                        continue;

                    if (serial != -1)
                    {
                        if ((serial == 0 && item.content_type != "movie") || (serial == 1 && item.content_type == "movie"))
                            continue;
                    }

                    bool isok = false;

                    if (StringConvert.SearchName(original_title) != null)
                    {
                        if (StringConvert.SearchName(item.orig_title) == StringConvert.SearchName(original_title))
                            isok = true;
                    }

                    string stitle = StringConvert.SearchName(title);
                    if (!isok && stitle != null)
                    {
                        if (!string.IsNullOrEmpty(item.ru_title))
                        {
                            if (StringConvert.SearchName(item.ru_title, string.Empty)!.Contains(stitle))
                                isok = true;
                        }

                        if (!isok && StringConvert.SearchName(item.orig_title) != null && stitle != null)
                        {
                            if (StringConvert.SearchName(item.orig_title)!.Contains(stitle))
                                isok = true;
                        }
                    }

                    if (!isok)
                        continue;

                    string year = item.year?.Split("-")?[0] ?? string.Empty;
                    string name = !string.IsNullOrEmpty(item.ru_title) && !string.IsNullOrEmpty(item.orig_title) ? $"{item.ru_title} / {item.orig_title}" : (item.ru_title ?? item.orig_title);

                    string details = $"imdb: {item.imdb_id} {stpl.OnlineSplit} kinopoisk: {item.kinopoisk_id}";

                    string img = PosterApi.Find(item.kinopoisk_id, item.imdb_id);
                    stpl.Append(name, year, details, host + $"lite/lumex?title={enc_title}&original_title={enc_original_title}&content_type={item.content_type}&content_id={item.id}&clarification={clarification}", img);
                }

                return stpl;
                #endregion
            }

            return default;
        }
        #endregion

        #region Html
        public string Html(EmbedModel result, string args, long content_id, string content_type, string imdb_id, long kinopoisk_id, string title, string original_title, int clarification, string t, int s, bool rjson = false, bool bwa = false)
        {
            if (result?.media == null || result.media.Length == 0)
                return string.Empty;

            if (!string.IsNullOrEmpty(args))
                args = $"&{args.Remove(0, 1)}";

            if (result.content_type is "movie" or "anime")
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, result.media.Length);

                foreach (var media in result.media)
                {
                    var subtitles = new SubtitleTpl(media.subtitles?.Length ?? 0);
                    if (media.subtitles != null && media.subtitles.Length > 0)
                    {
                        foreach (string srt in media.subtitles)
                        {
                            string name = Regex.Match(srt, "/([^\\.\\/]+)\\.srt").Groups[1].Value;
                            subtitles.Append(name, onstream($"{scheme}:{srt}"));
                        }
                    }

                    string link = host + $"lite/lumex/video.m3u8?playlist={HttpUtility.UrlEncode(media.playlist)}&csrf={result.csrf}&max_quality={media.max_quality}{args}";

                    if (bwa || !hls)
                    {
                        mtpl.Append(media.translation_name, link.Replace(".m3u8", ""), "call", subtitles: subtitles, quality: media.max_quality?.ToString());
                    }
                    else
                    {
                        mtpl.Append(media.translation_name, link, subtitles: subtitles, quality: media.max_quality?.ToString());
                    }
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                try
                {
                    if (s == -1)
                    {
                        var tpl = new SeasonTpl(result.media.Length);

                        foreach (var media in result.media.OrderBy(s => s.season_id))
                        {
                            string link = host + $"lite/lumex?content_id={content_id}&content_type={content_type}&kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&rjson={rjson}&title={enc_title}&original_title={enc_original_title}&clarification={clarification}&s={media.season_id}{args}";    

                            tpl.Append($"{media.season_id} —Å–µ–∑–æ–Ω", link, media.season_id);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();
                        var tmpVoice = new HashSet<int>();

                        foreach (var media in result.media)
                        {
                            if (media.season_id != s)
                                continue;

                            foreach (var episode in media.episodes)
                            {
                                foreach (var voice in episode.media)
                                {
                                    if (tmpVoice.Contains(voice.translation_id))
                                        continue;

                                    tmpVoice.Add(voice.translation_id);

                                    if (string.IsNullOrEmpty(t))
                                        t = voice.translation_id.ToString();

                                    vtpl.Append(voice.translation_name, t == voice.translation_id.ToString(), host + $"lite/lumex?content_id={content_id}&content_type={content_type}&kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&rjson={rjson}&title={enc_title}&original_title={enc_original_title}&clarification={clarification}&s={s}&t={voice.translation_id}");
                                }
                            }
                        }
                        #endregion

                        if (string.IsNullOrEmpty(t))
                            t = "0";

                        var etpl = new EpisodeTpl();
                        string sArhc = s.ToString();

                        foreach (var media in result.media)
                        {
                            if (media.season_id != s)
                                continue;

                            foreach (var episode in media.episodes)
                            {
                                foreach (var voice in episode.media)
                                {
                                    if (voice.translation_id.ToString() != t)
                                        continue;

                                    var subtitles = new SubtitleTpl(media.subtitles?.Length ?? 0);
                                    if (media.subtitles != null && media.subtitles.Length > 0)
                                    {
                                        foreach (string srt in media.subtitles)
                                        {
                                            string name = Regex.Match(srt, "/([^\\.\\/]+)\\.srt").Groups[1].Value;
                                            subtitles.Append(name, onstream($"{scheme}:{srt}"));
                                        }
                                    }

                                    string link = host + $"lite/lumex/video.m3u8?playlist={HttpUtility.UrlEncode(voice.playlist)}&csrf={result.csrf}&max_quality={voice.max_quality}{args}";

                                    if (bwa || !hls)
                                    {
                                        etpl.Append($"{episode.episode_id} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.episode_id.ToString(), link.Replace(".m3u8", ""), "call", subtitles: subtitles);
                                    }
                                    else
                                    {
                                        etpl.Append($"{episode.episode_id} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.episode_id.ToString(), link, subtitles: subtitles);
                                    }
                                }
                            }
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                }
                catch
                {
                    return string.Empty;
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/CDNmovies.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;
using Shared.Models.Online.CDNmovies;

namespace Shared.Engine.Online
{
    public struct CDNmoviesInvoke
    {
        #region CDNmoviesInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Action requesterror;

        public CDNmoviesInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string> onstreamfile, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        public async ValueTask<Voice[]> Embed(long kinopoisk_id)
        {
            string html = await onget.Invoke($"{apihost}/serial/kinopoisk/{kinopoisk_id}");
            if (html == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string file = Regex.Match(html, "file:'([^\n\r]+)'").Groups[1].Value;
            if (string.IsNullOrEmpty(file))
                return null;

            Voice[] content;

            try
            {
                content = JsonSerializer.Deserialize<Voice[]>(file);
            }
            catch { return null; }

            if (content == null || content.Length == 0)
                return null;

            return content;
        }
        #endregion

        #region Html
        public string Html(Voice[] voices, long kinopoisk_id, string title, string original_title, int t, int s, int sid, VastConf vast = null, bool rjson = false)
        {
            if (voices == null || voices.Length == 0)
                return string.Empty;

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            #region –ü–µ—Ä–µ–≤–æ–¥ html
            var vtpl = new VoiceTpl(voices.Length);

            for (int i = 0; i < voices.Length; i++)
            {
                string link = host + $"lite/cdnmovies?rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&t={i}";
                vtpl.Append(voices[i].title, t == i, link);
            }
            #endregion

            if (s == -1)
            {
                #region –°–µ–∑–æ–Ω—ã
                var tpl = new SeasonTpl(voices[t].folder.Length);

                for (int i = 0; i < voices[t].folder.Length; i++)
                {
                    string season = Regex.Match(voices[t].folder[i].title, "([0-9]+)$").Groups[1].Value;
                    if (string.IsNullOrEmpty(season))
                        continue;

                    string link = host + $"lite/cdnmovies?rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&t={t}&s={season}&sid={i}";
                    tpl.Append($"{season} —Å–µ–∑–æ–Ω", link, season);
                }

                return rjson ? tpl.ToJson(vtpl) : (vtpl.ToHtml() + tpl.ToHtml());
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∏
                var etpl = new EpisodeTpl();
                string sArhc = s.ToString();

                foreach (var item in voices[t].folder[sid].folder)
                {
                    var streamquality = new StreamQualityTpl();

                    foreach (Match m in Regex.Matches(item.file, "\\[(360|240)p?\\]([^\\[\\|,\n\r\t ]+\\.(mp4|m3u8))"))
                    {
                        string link = m.Groups[2].Value;
                        if (string.IsNullOrEmpty(link))
                            continue;

                        streamquality.Insert(onstreamfile.Invoke(link), $"{m.Groups[1].Value}p");
                    }

                    string episode = Regex.Match(item.title, "([0-9]+)$").Groups[1].Value;
                    etpl.Append($"{episode} c–µ—Ä–∏—è", title ?? original_title, sArhc, episode, streamquality.Firts().link, streamquality: streamquality, vast: vast);
                }

                if (rjson)
                    return etpl.ToJson(vtpl);

                return vtpl.ToHtml() + etpl.ToHtml();
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Filmix.cs
```
Ôªøusing Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models;
using Shared.Models.Base;
using Shared.Models.Online.Filmix;
using Shared.Models.Online.Settings;
using Shared.Models.Templates;
using System.Collections.Concurrent;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public class FilmixInvoke
    {
        static ConcurrentDictionary<string, string> user_dev_ids = new ConcurrentDictionary<string, string>();

        #region FilmixInvoke
        FilmixSettings init;

        public bool disableSphinxSearch, reserve;

        public string token;
        string host, args;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string, List<HeadersModel>, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;
        bool rjson;

        public FilmixInvoke(FilmixSettings init, string host, string token, Func<string, ValueTask<string>> onget, Func<string, string, List<HeadersModel>, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null, bool rjson = false)
        {
            this.init = init;
            apihost = init.corsHost();
            reserve = init.reserve;
            this.token = token;
            this.host = host != null ? $"{host}/" : null;
            this.onget = onget;
            this.onpost = onpost;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
            this.rjson = rjson;

            string user_dev_id = user_dev_ids.GetOrAdd(token ?? string.Empty, (k) => UnicTo.Code(16));

            args = $"app_lang=ru_RU&user_dev_apk=2.2.10.0&user_dev_id={user_dev_id}&user_dev_name=Xiaomi+24069PC21G&user_dev_os=14&user_dev_token={token}&user_dev_vendor=Xiaomi";
        }
        #endregion

        #region Search
        async public Task<SearchResult> Search(string title, string original_title, int clarification, int year, bool similar)
        {
            if (string.IsNullOrWhiteSpace(title ?? original_title))
                return null;

            string uri = $"{apihost}/api/v2/search?story={HttpUtility.UrlEncode(clarification == 1 ? title : (original_title ?? title))}&{args}";
            onlog?.Invoke(uri);
            
            string json = await onget.Invoke(uri);
            if (json == null)
                return await Search2(title, original_title, clarification, year);

            List<SearchModel> root = null;

            try
            {
                root = JsonConvert.DeserializeObject<List<SearchModel>>(json);
            }
            catch { }

            if (root == null || root.Count == 0)
                return await Search2(title, original_title, clarification, year);

            var ids = new List<int>(root.Count);
            var stpl = new SimilarTpl(root.Count);

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            foreach (var item in root)
            {
                if (item == null)
                    continue;

                string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.original_title) ? $"{item.title} / {item.original_title}"  : (item.title ?? item.original_title);

                stpl.Append(name, item.year.ToString(), string.Empty, host + $"lite/filmix?postid={item.id}&title={enc_title}&original_title={enc_original_title}", PosterApi.Size(item.poster)); 

                if ((!string.IsNullOrEmpty(stitle) && StringConvert.SearchName(item.title) == stitle) ||
                    (!string.IsNullOrEmpty(sorigtitle) && StringConvert.SearchName(item.original_title) == sorigtitle))
                {
                    if (item.year == year)
                        ids.Add(item.id);
                }
            }

            onlog?.Invoke("ids: " + ids.Count);

            if (ids.Count == 1 && !similar)
                return new SearchResult() { id = ids[0] };

            return new SearchResult() { similars = stpl };
        }
        #endregion

        #region Search2
        async Task<SearchResult> Search2(string title, string original_title, int clarification, int year)
        {
            async Task<List<SearchModel>> gosearch(string story)
            {
                if (string.IsNullOrEmpty(story))
                    return null;

                string uri = $"https://api.filmix.tv/api-fx/list?search={HttpUtility.UrlEncode(story)}&limit=48";
                onlog?.Invoke(uri);

                string json = await onget.Invoke(uri);
                if (string.IsNullOrEmpty(json) || !json.Contains("\"status\":\"ok\""))
                    return null;

                List<SearchModel> root = null;

                try
                {
                    root = JObject.Parse(json)?["items"]?.ToObject<List<SearchModel>>();
                }
                catch { }

                if (root == null || root.Count == 0)
                    return null;

                return root;
            }

            var result = await gosearch(clarification == 1 ? original_title : title);
            if (result == null)
                result = await gosearch(clarification == 1 ? title : original_title);

            if (result == null)
                return await Search3(title, original_title, clarification, year);

            var ids = new List<int>(result.Count);
            var stpl = new SimilarTpl(result.Count);

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            foreach (var item in result)
            {
                if (item == null)
                    continue;

                string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.original_name) ? $"{item.title} / {item.original_name}" : (item.title ?? item.original_name);

                stpl.Append(name, item.year.ToString(), string.Empty, host + $"lite/filmix?postid={item.id}&title={enc_title}&original_title={enc_original_title}");

                if ((!string.IsNullOrEmpty(stitle) && StringConvert.SearchName(item.title) == stitle) ||
                    (!string.IsNullOrEmpty(sorigtitle) && StringConvert.SearchName(item.original_name) == sorigtitle))
                {
                    if (item.year == year)
                        ids.Add(item.id);
                }
            }

            onlog?.Invoke("ids: " + ids.Count);

            if (ids.Count == 1)
                return new SearchResult() { id = ids[0] };

            return new SearchResult() { similars = stpl };
        }
        #endregion

        #region Search3
        async Task<SearchResult> Search3(string title, string original_title, int clarification, int year)
        {
            return null;

            if (disableSphinxSearch)
            {
                requesterror?.Invoke();
                return null;
            }

            onlog?.Invoke("Search3");

            string html = await onpost.Invoke("https://filmix.my/engine/ajax/sphinx_search.php", $"scf=fx&story={HttpUtility.UrlEncode(clarification == 1 ? title : (original_title ?? title))}&search_start=0&do=search&subaction=search&years_ot=1902&years_do={DateTime.Today.Year}&kpi_ot=1&kpi_do=10&imdb_ot=1&imdb_do=10&sort_name=&undefined=asc&sort_date=&sort_favorite=&simple=1", HeadersModel.Init( 
                ("Origin", "https://filmix.my"),
                ("Referer", "https://filmix.my/search/"),
                ("X-Requested-With", "XMLHttpRequest"),
                ("Sec-Fetch-Site", "same-origin"),
                ("Sec-Fetch-Mode", "cors"),
                ("Sec-Fetch-Dest", "empty"),
                ("Cookie", "x-a-key=sinatra; FILMIXNET=2g5orcue70hmbkugbr7vi431l0; _ga_GYLWSWSZ3C=GS1.1.1703578122.1.0.1703578122.0.0.0; _ga=GA1.1.1855910641.1703578123")
            ));

            if (html == null)
            {
                requesterror?.Invoke();
                return null;
            }

            var rows = html.Split("</article>");

            var ids = new List<int>(rows.Length);
            var stpl = new SimilarTpl(rows.Length);

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            string stitle = title?.ToLower();
            string sorigtitle = original_title?.ToLower();

            foreach (string row in rows)
            {
                string ftitle = Regex.Match(row, "itemprop=\"name\" content=\"([^\"]+)\"").Groups[1].Value;
                string ftitle_orig = Regex.Match(row, "itemprop=\"alternativeHeadline\" content=\"([^\"]+)\"").Groups[1].Value;
                string fyear = Regex.Match(row, "itemprop=\"copyrightYear\"[^>]+>([0-9]{4})").Groups[1].Value;
                string fid = Regex.Match(row, "data-id=\"([0-9]+)\"").Groups[1].Value;

                if (int.TryParse(fid, out int id) && id > 0)
                {
                    string name = !string.IsNullOrEmpty(ftitle) && !string.IsNullOrEmpty(ftitle_orig) ? $"{ftitle} / {ftitle_orig}" : (ftitle ?? ftitle_orig);

                    stpl.Append(name, fyear, string.Empty, host + $"lite/filmix?postid={id}&title={enc_title}&original_title={enc_original_title}");

                    if ((!string.IsNullOrEmpty(stitle) && ftitle.ToLower() == stitle) ||
                        (!string.IsNullOrEmpty(sorigtitle) && ftitle_orig.ToLower() == sorigtitle))
                    {
                        if (fyear == year.ToString())
                            ids.Add(id);
                    }
                }
            }

            onlog?.Invoke("ids: " + ids.Count);

            if (ids.Count == 1)
                return new SearchResult() { id = ids[0] };

            return new SearchResult() { similars = stpl };
        }
        #endregion

        #region Post
        async public Task<RootObject> Post(int postid)
        {
            string uri = $"{apihost}/api/v2/post/{postid}?{args}";
            onlog?.Invoke(uri);

            string json = await onget.Invoke(uri);
            if (json == null)
            {
                requesterror?.Invoke();
                return null;
            }

            try
            {
                var root = JsonConvert.DeserializeObject<RootObject>(json.Replace("\"playlist\":[],", "\"playlist\":null,"), new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } });

                if (root?.player_links == null)
                    return null;

                return root;
            }
            catch { return null; }
        }
        #endregion

        #region Html
        public string Html(RootObject root, bool pro, int postid, string title, string original_title, int t, int? s, VastConf vast = null)
        {
            var player_links = root.player_links;
            if (player_links.movie == null && player_links.playlist == null)
                return string.Empty;

            int filmixservtime = DateTime.UtcNow.AddHours(2).Hour;
            bool hidefree720 = string.IsNullOrEmpty(token) /*&& filmixservtime >= 19 && filmixservtime <= 23*/;

            if (player_links.movie != null && player_links.movie.Length > 0)
            {
                #region –§–∏–ª—å–º
                if (player_links.movie.Length == 1 && player_links.movie[0].translation.ToLower().StartsWith("–∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ "))
                    return string.Empty;

                var cdns = reserve ? player_links.movie
                        .Select(e => Regex.Match(e.link, "^(https?://[^/]+)").Groups[1].Value)
                        .ToHashSet() : null;

                var mtpl = new MovieTpl(title, original_title, player_links.movie.Length);

                foreach (var v in player_links.movie)
                {
                    var streamquality = new StreamQualityTpl();

                    foreach (int q in new int[] { 2160, 1440, 1080, 720, 480 })
                    {
                        if (!pro)
                        {
                            if (hidefree720 && q > 480)
                                continue;

                            if (q > 720)
                                continue;
                        }

                        if (!v.link.Contains($"{q},"))
                            continue;

                        string l = Regex.Replace(v.link, "_\\[[0-9,]+\\]\\.mp4", $"_{q}.mp4");

                        if (init.hls && !Regex.IsMatch(l, "/(HDR10p?|HEVC)/"))
                        {
                            var m = Regex.Match(l, "^(https?://[^/]+)/s/([^/]+)/(.*)");
                            if (m.Success)
                                l = $"{m.Groups[1].Value}/hls/{m.Groups[3].Value}/index.m3u8?hash={m.Groups[2].Value}";
                        }

                        if (reserve)
                        {
                            foreach (string cdn in cdns)
                            {
                                if (!l.Contains(cdn))
                                {
                                    l += " or " + Regex.Replace(l, "^https?://[^/]+", cdn);
                                    break;
                                }
                            }
                        }

                        streamquality.Append(onstreamfile.Invoke(l), $"{q}p");
                    }

                    mtpl.Append(v.translation, streamquality.Firts().link, streamquality: streamquality, vast: vast);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                if (player_links.playlist == null || player_links.playlist.Count == 0)
                    return string.Empty;

                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                if (s == null)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    var tpl = new SeasonTpl(!string.IsNullOrEmpty(root?.quality) ? $"{root.quality.Replace("+", "")}p" : null, player_links.playlist.Count);

                    foreach (var season in player_links.playlist)
                    {
                        string link = host + $"lite/filmix?rjson={rjson}&postid={postid}&title={enc_title}&original_title={enc_original_title}&s={season.Key}";
                        tpl.Append($"{season.Key.Replace("-1", "1")} —Å–µ–∑–æ–Ω", link, season.Key);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                    #endregion
                }
                else
                {
                    string sArch = s?.ToString();

                    if (sArch == null)
                        return string.Empty;

                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var voices = player_links.playlist[sArch];

                    int indexTranslate = 0;
                    var vtpl = new VoiceTpl(voices.Count);

                    foreach (var translation in voices)
                    {
                        string link = host + $"lite/filmix?rjson={rjson}&postid={postid}&title={enc_title}&original_title={enc_original_title}&s={s}&t={indexTranslate}";
                        bool active = t == indexTranslate;

                        indexTranslate++;
                        vtpl.Append(translation.Key, active, link);
                    }
                    #endregion

                    #region Deserialize
                    Dictionary<string, Movie> episodes = null;

                    try
                    {
                        episodes = player_links.playlist[sArch].ElementAt(t).Value.ToObject<Dictionary<string, Movie>>();
                    }
                    catch
                    {
                        try
                        {
                            int episod_id = 0;
                            episodes = new Dictionary<string, Movie>();

                            foreach (var item in player_links.playlist[sArch].ElementAt(t).Value.ToObject<List<Movie>>())
                            {
                                episod_id++;
                                episodes.Add(episod_id.ToString(), item);
                            }
                        }
                        catch { }
                    }

                    if (episodes == null || episodes.Count == 0)
                        return string.Empty;
                    #endregion

                    var cdns = reserve ? episodes
                        .Select(e => Regex.Match(e.Value.link, "^(https?://[^/]+)").Groups[1].Value)
                        .ToHashSet() : null;

                    #region –°–µ—Ä–∏–∏
                    var etpl = new EpisodeTpl(episodes.Count);

                    foreach (var episode in episodes)
                    {
                        var streamquality = new StreamQualityTpl();

                        foreach (var lq in episode.Value.qualities.OrderByDescending(i => i))
                        {
                            if (!pro)
                            {
                                if (hidefree720 && lq > 480)
                                    continue;

                                if (lq > 720)
                                    continue;
                            }

                            string l = episode.Value.link.Replace("_%s.mp4", $"_{lq}.mp4");

                            if (init.hls && !Regex.IsMatch(l, "/(HDR10p?|HEVC)/"))
                            {
                                var m = Regex.Match(l, "^(https?://[^/]+)/s/([^/]+)/(.*)");
                                if (m.Success)
                                    l = $"{m.Groups[1].Value}/hls/{m.Groups[3].Value}/index.m3u8?hash={m.Groups[2].Value}";
                            }

                            if (reserve)
                            {
                                foreach (string cdn in cdns)
                                {
                                    if (!l.Contains(cdn))
                                    {
                                        l += " or " + Regex.Replace(l, "^https?://[^/]+", cdn);
                                        break;
                                    }
                                }
                            }

                            streamquality.Append(onstreamfile.Invoke(l), $"{lq}p");
                        }

                        int fis = s == -1 ? 1 : (s ?? 1);

                        etpl.Append($"{episode.Key} —Å–µ—Ä–∏—è", title ?? original_title, fis.ToString(), episode.Key, streamquality.Firts().link, streamquality: streamquality, vast: vast);
                    }
                    #endregion

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/VideoCDN.cs
```
Ôªøusing Org.BouncyCastle.Utilities.IO;
using Shared.Models.Online.Settings;
using Shared.Models.Online.VideoCDN;
using Shared.Models.Templates;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct VideoCDNInvoke
    {
        #region VideoCDNInvoke
        string host, scheme;
        string iframeapihost;
        string apihost;
        string token;
        bool usehls;
        Func<string, string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public string onstream(string stream)
        {
            if (onstreamfile == null)
                return stream;

            return onstreamfile.Invoke(stream);
        }

        public VideoCDNInvoke(OnlinesSettings init, Func<string, string, ValueTask<string>> onget, Func<string, string> onstreamfile, string host = null, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.scheme = init.scheme;
            this.iframeapihost = init.corsHost();
            this.apihost = init.cors(init.apihost);
            this.token = init!.token;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            usehls = init.hls;
            this.requesterror = requesterror;
        }
        #endregion

        #region Search
        public async ValueTask<SimilarTpl?> Search(string title, string original_title, int serial)
        {
            if (string.IsNullOrWhiteSpace(title ?? original_title))
                return null;

            string uri = $"{apihost}/api/short?api_token={token}&title={HttpUtility.UrlEncode(original_title ?? title)}";

            string json = await onget.Invoke(uri, apihost);
            if (json == null)
            {
                requesterror?.Invoke();
                return null;
            }

            SearchRoot root = null;

            try
            {
                root = JsonSerializer.Deserialize<SearchRoot>(json);
                if (root?.data == null || root.data.Length == 0)
                    return null;
            }
            catch { return null; }

            var stpl = new SimilarTpl(root.data.Length);

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            foreach (var item in root.data)
            {
                if (item.kp_id == 0 && string.IsNullOrEmpty(item.imdb_id))
                    continue;

                if (serial != -1)
                {
                    if ((serial == 0 && item.content_type != "movie") || (serial == 1 && item.content_type == "movie"))
                        continue;
                }

                bool isok = title != null && title.Length > 3 && item.title != null && item.title.ToLower().Contains(title.ToLower());
                isok = isok ? true : original_title != null && original_title.Length > 3 && item.orig_title != null && item.orig_title.ToLower().Contains(original_title.ToLower());

                if (!isok)
                    continue;

                string year = item.add?.Split("-")?[0] ?? string.Empty;
                string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.orig_title) ? $"{item.title} / {item.orig_title}" : (item.title ?? item.orig_title);

                string details = $"imdb: {item.imdb_id} {stpl.OnlineSplit} kinopoisk: {item.kp_id}";

                stpl.Append(name, year, details, host + $"lite/vcdn?title={enc_title}&original_title={enc_original_title}&kinopoisk_id={item.kp_id}&imdb_id={item.imdb_id}");
            }

            return stpl;
        }
        #endregion

        #region Embed
        public async ValueTask<EmbedModel> Embed(long kinopoisk_id, string imdb_id)
        {
            string args = kinopoisk_id > 0 ? $"kp_id={kinopoisk_id}&imdb_id={imdb_id}" : $"imdb_id={imdb_id}";
            string content = await onget.Invoke($"{iframeapihost}?{args}", "https://kinogo.ec/113447-venom-3-poslednij-tanec.html");
            if (content == null)
            {
                requesterror?.Invoke();
                return null;
            }

            var result = new EmbedModel();
            result.type = Regex.Match(content, "id=\"videoType\" value=\"([^\"]+)\"").Groups[1].Value;
            result.voices = new Dictionary<string, string>();

            if (content.Contains("</option>"))
            {
                result.voices.TryAdd("0", "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é");

                var match = new Regex("<option +value=\"([0-9]+)\"[^>]+>([^<]+)</option>").Match(Regex.Replace(content, "[\n\r\t]+", ""));
                while (match.Success)
                {
                    string translation_id = match.Groups[1].Value;
                    string translation = match.Groups[2].Value.Trim();

                    if (!string.IsNullOrEmpty(translation_id) && !string.IsNullOrEmpty(translation))
                        result.voices.TryAdd(translation_id, translation);

                    match = match.NextMatch();
                }
            }

            string Decode(string pass, string src)
            {
                try
                {
                    int passLen = pass.Length;
                    int srcLen = src.Length;
                    byte[] passArr = new byte[passLen];

                    for (int i = 0; i < passLen; i++)
                    {
                        passArr[i] = (byte)pass[i];
                    }

                    StringBuilder res = new StringBuilder();

                    for (int i = 0; i < srcLen; i += 2)
                    {
                        string hex = src.Substring(i, 2);
                        int code = Convert.ToInt32(hex, 16);
                        byte secret = (byte)(passArr[(i / 2) % passLen] % 255);
                        res.Append((char)(code ^ secret));
                    }

                    return res.ToString();
                }
                catch { return null; }
            }

            string files = null;
            string client_id = Regex.Match(content, "id=\"client_id\" value=\"([^\"]+)\"").Groups[1].Value;

            var m = Regex.Match(content, "<input type=\"hidden\" id=\"[^\"]+\" value=('|\")([^\"']+)");
            while (m.Success)
            {
                string sentry_id = m.Groups[2].Value;
                if (200 > sentry_id.Length || sentry_id.StartsWith("{"))
                {
                    m = m.NextMatch();
                    continue;
                }

                files = Decode(client_id, sentry_id);
                if (!string.IsNullOrEmpty(files))
                    break;

                m = m.NextMatch();
            }

            if (string.IsNullOrEmpty(files))
            {
                files = Regex.Match(content, "value='(\\{\"[0-9]+\"[^\']+)'").Groups[1].Value;
                if (string.IsNullOrEmpty(files))
                    return null;
            }    

            result.quality = files.Contains("1080p") ? "1080p" : files.Contains("720p") ? "720p" : "480p";

            try
            {
                if (result.type is "movie" or "anime")
                {
                    result.movie = JsonSerializer.Deserialize<Dictionary<string, string>>(files);
                    if (result.movie == null)
                        return null;
                }
                else
                {
                    result.serial = JsonSerializer.Deserialize<Dictionary<string, List<Season>>>(files);
                    if (result.serial == null)
                        return null;

                    #region voiceSeasons
                    result.voiceSeasons = new Dictionary<string, HashSet<int>>();

                    foreach (var voice in result.serial.OrderByDescending(k => k.Key == "0"))
                    {
                        if (result.voices.TryGetValue(voice.Key, out string name) && name != null)
                        {
                            foreach (var season in voice.Value)
                            {
                                if (result.voiceSeasons.TryGetValue(voice.Key, out HashSet<int> _s))
                                {
                                    _s.Add(season.id);
                                }
                                else
                                {
                                    result.voiceSeasons.TryAdd(voice.Key, new HashSet<int>() { season.id });
                                }
                            }
                        }
                    }
                    #endregion
                }
            }
            catch { return null; }

            return result;
        }
        #endregion

        #region Html
        public string Html(EmbedModel result, string imdb_id, long kinopoisk_id, string title, string original_title, string t, int s, bool rjson = false)
        {
            if (result == null)
                return string.Empty;

            if (result.type is "movie" or "anime")
            {
                #region –§–∏–ª—å–º
                if (result.movie == null || result.movie.Count == 0)
                    return string.Empty;

                var mtpl = new MovieTpl(title, original_title, result.movie.Count);

                foreach (var voice in result.movie)
                {
                    result.voices.TryGetValue(voice.Key, out string name);
                    if (string.IsNullOrEmpty(name))
                    {
                        if (result.movie.Count > 1)
                            continue;

                        name = "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é";
                    }

                    var streamquality = new StreamQualityTpl();

                    foreach (Match m in Regex.Matches(voice.Value, $"\\[(1080|720|480|360)p?\\]([^\\[\\|,\n\r\t ]+\\.(mp4|m3u8))"))
                    {
                        string link = m.Groups[2].Value;
                        if (string.IsNullOrEmpty(link))
                            continue;

                        if (usehls && !link.Contains(".m3u"))
                            link += ":hls:manifest.m3u8";
                        else if (!usehls && link.Contains(".m3u"))
                            link = link.Replace(":hls:manifest.m3u8", "");

                        streamquality.Insert(onstream($"{scheme}:{link}"), $"{m.Groups[1].Value}p");
                    }

                    mtpl.Append(name, streamquality.Firts().link, streamquality: streamquality);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                try
                {
                    if (result.serial == null || result.serial.Count == 0)
                        return string.Empty;

                    if (s == -1)
                    {
                        var seasons = new HashSet<int>();

                        foreach (var voice in result.serial)
                        {
                            foreach (var season in voice.Value)
                                seasons.Add(season.id);
                        }

                        var tpl = new SeasonTpl(result.quality, seasons.Count);

                        foreach (int id in seasons.OrderBy(s => s))
                        {
                            string link = host + $"lite/vcdn?kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&rjson={rjson}&title={enc_title}&original_title={enc_original_title}&s={id}";
                            tpl.Append($"{id} —Å–µ–∑–æ–Ω", link, id);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();

                        foreach (var voice in result.voiceSeasons)
                        {
                            if (!voice.Value.Contains(s))
                                continue;

                            if (result.voices.TryGetValue(voice.Key, out string name) && name != null)
                            {
                                if (string.IsNullOrEmpty(t))
                                    t = voice.Key;

                                vtpl.Append(name, t == voice.Key, host + $"lite/vcdn?kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&rjson={rjson}&title={enc_title}&original_title={enc_original_title}&s={s}&t={voice.Key}");
                            }
                        }
                        #endregion

                        if (string.IsNullOrEmpty(t))
                            t = "0";

                        var season = result.serial[t].First(i => i.id == s);
                        if (season.folder == null)
                            return string.Empty;

                        string sArhc = s.ToString();
                        var etpl = new EpisodeTpl(season.folder.Length);

                        foreach (var episode in season.folder)
                        {
                            var streamquality = new StreamQualityTpl();

                            foreach (Match m in Regex.Matches(episode.file ?? "", $"\\[(1080|720|480|360)p?\\]([^\\[\\|,\n\r\t ]+\\.(mp4|m3u8))"))
                            {
                                string link = m.Groups[2].Value;
                                if (string.IsNullOrEmpty(link))
                                    continue;

                                if (usehls && !link.Contains(".m3u"))
                                    link += ":hls:manifest.m3u8";
                                else if (!usehls && link.Contains(".m3u"))
                                    link = link.Replace(":hls:manifest.m3u8", "");

                                streamquality.Insert(onstream($"{scheme}:{link}"), $"{m.Groups[1].Value}p");
                            }

                            string e = episode.id.Split("_")[1];

                            etpl.Append($"{e} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, e, streamquality.Firts().link, streamquality: streamquality);
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                }
                catch
                {
                    return string.Empty;
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/FanCDN.cs
```
Ôªøusing Shared.Models;
using Shared.Models.Base;
using Shared.Models.Online.FanCDN;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct FanCDNInvoke
    {
        #region FanCDNInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;

        public FanCDNInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string> onstreamfile, Func<string, string> onlog = null)
        {
            this.host = host != null ? $"{host}/" : null; this.apihost = apihost;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
        }
        #endregion

        #region EmbedSearch
        async public ValueTask<EmbedModel> EmbedSearch(string title, string original_title, int year, int serial)
        {
            if (serial == 1)
            {
                return null;
            }
            else
            {
                if (string.IsNullOrEmpty(title) || year == 0)
                    return null;

                string search = await onget($"{apihost}/?do=search&subaction=search&story={HttpUtility.UrlEncode(title)}");
                if (string.IsNullOrEmpty(search))
                    return null;

                string href = null;

                foreach (string itemsearch in search.Split("item-search-serial"))
                {
                    string info = itemsearch.Split("torrent-link")?[0];
                    if (!string.IsNullOrEmpty(info) && (info.Contains($"({year - 1}") || info.Contains($"({year}") || info.Contains($"({year + 1}")))
                    {
                        string _info = StringConvert.SearchName(info);
                        if (_info.Contains(StringConvert.SearchName(title)) || (!string.IsNullOrEmpty(original_title) && _info.Contains(StringConvert.SearchName(original_title))))
                        {
                            href = Regex.Match(info, "<a href=\"(https?://[^\"]+\\.html)\"").Groups[1].Value;
                            break;
                        }
                    }
                }

                if (string.IsNullOrEmpty(href))
                    return null;

                string html = await onget(href);
                if (string.IsNullOrEmpty(html))
                    return null;


                string iframe_url = null;

                foreach (Match match in Regex.Matches(html, "(https?://fancdn\\.[^\"\n\r\t ]+)\""))
                {
                    string cdn = match.Groups[1].Value;
                    if (cdn.Contains("kinopoisk=") && cdn.Contains("key="))
                        iframe_url = cdn;
                }


                if (string.IsNullOrEmpty(iframe_url))
                    return null;

                return await Embed(iframe_url);
            }
        }
        #endregion

        #region EmbedToken
        async public ValueTask<EmbedModel> EmbedToken(long kinopoisk_id, string token)
        {
            if (kinopoisk_id == 0)
                return null;

            return await Embed($"https://fancdn.net/iframe/?kinopoisk={kinopoisk_id}&key={token}");
        }
        #endregion

        #region Embed
        async public ValueTask<EmbedModel> Embed(string iframe_url)
        {
            if (string.IsNullOrEmpty(iframe_url))
                return null;

            string iframe = await onget(iframe_url);
            if (string.IsNullOrEmpty(iframe))
                return null;

            iframe = Regex.Replace(iframe, "[\n\r\t]+", "").Replace("var ", "\n");

            string playlist = Regex.Match(iframe, "playlist ?= ?(\\[[^\n\r]+\\]);").Groups[1].Value;
            if (string.IsNullOrEmpty(playlist))
                return null;

            try
            {
                if (iframe.Contains("\"folder\""))
                {
                    var serial = JsonSerializer.Deserialize<Voice[]>(playlist);
                    if (serial == null || serial.Length == 0)
                        return null;

                    return new EmbedModel() { serial = serial };
                }
                else
                {
                    var movies = JsonSerializer.Deserialize<Episode[]>(playlist);
                    if (movies == null || movies.Length == 0)
                        return null;

                    return new EmbedModel() { movies = movies };
                }
            }
            catch { }

            return null;
        }
        #endregion

        #region Html
        public string Html(EmbedModel root, string imdb_id, long kinopoisk_id, string title, string original_title, int t = -1, int s = -1, bool rjson = false, VastConf vast = null, List<HeadersModel> headers = null)
        {
            if (root == null)
                return string.Empty;

            if (root.movies != null)
            {
                var mtpl = new MovieTpl(title, original_title, root.movies.Length);

                foreach (var m in root.movies)
                {
                    if (string.IsNullOrEmpty(m.file))
                        continue;

                    #region subtitle
                    var subtitles = new SubtitleTpl();

                    if (!string.IsNullOrEmpty(m.subtitles))
                    {
                        // [rus]rus1.srt,[eng]eng2.srt,[eng]eng3.srt
                        var match = new Regex("\\[([^\\]]+)\\]([^\\,]+)").Match(m.subtitles);
                        while (match.Success)
                        {
                            string srt = m.file.Replace("/hls.m3u8", "/") + match.Groups[2].Value;
                            subtitles.Append(match.Groups[1].Value, onstreamfile.Invoke(srt));
                            match = match.NextMatch();
                        }
                    }
                    #endregion

                    mtpl.Append(m.title, onstreamfile.Invoke(m.file), subtitles: subtitles, vast: vast, headers: headers);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                if (s == -1)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    var tpl = new SeasonTpl();
                    var hash = new HashSet<int>();

                    foreach (var voice in root.serial.OrderBy(i => i.seasons))
                    {
                        if (hash.Contains(voice.seasons))
                            continue;

                        hash.Add(voice.seasons);

                        string link = host + $"lite/fancdn?rjson={rjson}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&s={voice.seasons}";
                        tpl.Append($"{voice.seasons} —Å–µ–∑–æ–Ω", link, voice.seasons);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                    #endregion
                }
                else
                {
                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var vtpl = new VoiceTpl();

                    foreach (var voice in root.serial)
                    {
                        if (s != voice.seasons)
                            continue;

                        if (t == -1)
                            t = voice.id;

                        string link = host + $"lite/fancdn?rjson={rjson}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&s={s}&t={voice.id}";
                        bool active = t == voice.id;

                        vtpl.Append(voice.title, active, link);
                    }
                    #endregion

                    var episodes = root.serial.First(i => i.id == t).folder[s.ToString()].folder;

                    var etpl = new EpisodeTpl(episodes.Count);
                    string sArhc = s.ToString();

                    foreach (var episode in episodes)
                        etpl.Append($"{episode.Key} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.Key, onstreamfile.Invoke(episode.Value.file), vast: vast, headers: headers);

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/VoKino.cs
```
Ôªøusing Newtonsoft.Json.Linq;
using Shared.Models.Base;
using Shared.Models.Online.Settings;
using Shared.Models.Online.VoKino;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct VoKinoInvoke
    {
        #region VoKinoInvoke
        string host;
        string apihost;
        string token;
        Func<string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public VoKinoInvoke(string host, string apihost, string token, Func<string, ValueTask<string>> onget, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.token = token;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
        }
        #endregion

        public static void SendOnline(VokinoSettings init, List<(dynamic init, string name, string url, string plugin, int index)> online, JObject view)
        {
            var on = init.online;

            void send(string name, int x)
            {
                string url = "{localhost}/lite/vokino?balancer=" + name.ToLower();

                string displayname = $"{init.displayname ?? "VoKino"}";
                if (name != "VoKino")
                    displayname = $"{name} ({init.displayname ?? "VoKino"})";

                if (init.onlyBalancerName)
                    displayname = name;

                online.Add((init, displayname, url, (name == "VoKino" ? "vokino" : $"vokino-{name.ToLower()}"), init.displayindex > 0 ? (init.displayindex + x) : online.Count));
            }

            if (on.vokino && (view == null || view.ContainsKey("Vokino")))
                send("VoKino", 1);

            if (on.filmix && (view == null || view.ContainsKey("Filmix")))
                send("Filmix", 2);

            if (on.alloha && (view == null || view.ContainsKey("Alloha")))
                send("Alloha", 3);

            if (on.vibix && (view == null || view.ContainsKey("Vibix")))
                send("Vibix", 4);

            if (on.monframe && (view == null || view.ContainsKey("MonFrame")))
                send("MonFrame", 5);

            if (on.remux && (view == null || view.ContainsKey("Remux")))
                send("Remux", 6);

            if (on.ashdi && (view == null || view.ContainsKey("Ashdi")))
                send("Ashdi", 7);

            if (on.hdvb && (view == null || view.ContainsKey("Hdvb")))
                send("HDVB", 8);
        }

        #region Embed
        public async ValueTask<EmbedModel> Embed(string origid, long kinopoisk_id, string balancer, string t)
        {
            try
            {
                if (string.IsNullOrEmpty(balancer))
                {
                    string json = await onget($"{apihost}/v2/view/{origid ?? kinopoisk_id.ToString()}?token={token}");
                    if (json == null)
                    {
                        requesterror?.Invoke();
                        return null;
                    }

                    if (json.Contains("not found"))
                        return new EmbedModel() { IsEmpty = true };

                    var similars = new List<Similar>(10);

                    foreach (var item in JsonSerializer.Deserialize<JsonElement>(json).GetProperty("online").EnumerateObject())
                    {
                        string playlistUrl = item.Value.GetProperty("playlist_url").GetString();
                        if (string.IsNullOrEmpty(playlistUrl))
                            continue;

                        var model = new Similar()
                        {
                            title = item.Name,
                            balancer = Regex.Match(playlistUrl, "/v2/online/([^/]+)/").Groups[1].Value
                        };

                        if (item.Name == "Vokino")
                            similars.Insert(0, model);
                        else
                            similars.Add(model);
                    }

                    return new EmbedModel() { similars = similars };
                }
                else
                {
                    string uri = $"{apihost}/v2/online/{balancer}/{origid ?? kinopoisk_id.ToString()}?token={token}";
                    if (!string.IsNullOrEmpty(t))
                        uri += $"&{t}";

                    string json = await onget(uri);
                    if (json == null)
                    {
                        requesterror?.Invoke();
                        return null;
                    }

                    if (json.Contains("not found"))
                        return new EmbedModel() { IsEmpty = true };

                    var root = JsonSerializer.Deserialize<RootObject>(json);
                    if (root?.channels == null || root.channels.Length == 0)
                        return null;

                    return new EmbedModel() { menu = root.menu, channels = root.channels };
                }
            }
            catch { }

            return null;
        }
        #endregion

        #region Html
        public string Html(EmbedModel result, string origid, long kinopoisk_id, string title, string original_title, string balancer, string t, int s, VastConf vast = null, bool rjson = false)
        {
            if (result == null || result.IsEmpty)
                return string.Empty;

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            #region similar
            if (result.similars != null)
            {
                var stpl = new SimilarTpl(result.similars.Count);

                foreach (var similar in result.similars)
                {
                    string link = host + $"lite/vokino?rjson={rjson}&origid={origid}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&balancer={similar.balancer}";

                    stpl.Append(similar.title, string.Empty, string.Empty, link);
                }

                return rjson ? stpl.ToJson() : stpl.ToHtml();
            }
            #endregion

            if (result?.channels == null || result.channels.Length == 0)
                return string.Empty;

            #region –ü–µ—Ä–µ–≤–æ–¥—ã
            var voices = result?.menu?.FirstOrDefault(i => i.title == "–ü–µ—Ä–µ–≤–æ–¥")?.submenu;
            var vtpl = new VoiceTpl(voices != null ? voices.Length : 0);

            if (voices != null && voices.Length > 0)
            {
                foreach (var translation in voices)
                {
                    if (translation.playlist_url != null && translation.playlist_url.Contains("?"))
                    {
                        string _t = HttpUtility.UrlEncode(translation.playlist_url.Split("?")[1]);
                        vtpl.Append(translation.title, translation.selected, host + $"lite/vokino?rjson={rjson}&origid={origid}&kinopoisk_id={kinopoisk_id}&balancer={balancer}&title={enc_title}&original_title={enc_original_title}&t={_t}&s={s}");
                    }
                }
            }
            #endregion

            if (result!.channels.First().playlist_url == "submenu")
            {
                if (s == -1)
                {
                    var tpl = new SeasonTpl(quality: result.channels[0].quality_full?.Replace("2160p.", "4K "), result.channels.Length);

                    foreach (var ch in result.channels)
                    {
                        string sname = Regex.Match(ch.title, "^([0-9]+)").Groups[1].Value;
                        if (string.IsNullOrEmpty(sname))
                            sname = Regex.Match(ch.title, "([0-9]+)$").Groups[1].Value;

                        tpl.Append(ch.title, host + $"lite/vokino?rjson={rjson}&origid={origid}&kinopoisk_id={kinopoisk_id}&balancer={balancer}&title={enc_title}&original_title={enc_original_title}&t={t}&s={sname}", sname);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                }
                else
                {
                    var series = result.channels.First(i => i.title.StartsWith($"{s} ") || i.title.EndsWith($" {s}")).submenu;

                    var tpl = new EpisodeTpl(series.Length);

                    string sArhc = s.ToString();

                    foreach (var e in series)
                    {
                        string ename = Regex.Match(e.ident, "([0-9]+)$").Groups[1].Value;
                        tpl.Append(e.title, title ?? original_title, sArhc, ename, onstreamfile(e.stream_url), vast: vast);
                    }

                    if (rjson)
                        return tpl.ToJson(vtpl);

                    return vtpl.ToHtml() + tpl.ToHtml();
                }
            }
            else
            {
                var mtpl = new MovieTpl(title, original_title, result.channels.Length);

                foreach (var ch in result!.channels)
                {
                    string name = ch.quality_full;
                    if (!string.IsNullOrWhiteSpace(name.Replace("2160p.", "")))
                    {
                        name = name.Replace("2160p.", "4K ");

                        if (ch.extra != null && ch.extra.TryGetValue("size", out string size) && !string.IsNullOrEmpty(size))
                            name += $" - {size}";
                    }

                    mtpl.Append(name, onstreamfile(ch.stream_url), vast: vast);
                }

                if (rjson)
                    return mtpl.ToJson(vtpl: vtpl);

                return vtpl.ToHtml() + mtpl.ToHtml();
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Zetflix.cs
```
Ôªøusing Shared.Models;
using Shared.Models.Base;
using Shared.Models.Online.Zetflix;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct ZetflixInvoke
    {
        #region ZetflixInvoke
        string host, apihost;
        bool usehls;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Func<string, List<HeadersModel>, ValueTask<string>> onget;

        public ZetflixInvoke(string host, string apihost, bool hls, Func<string, List<HeadersModel>, ValueTask<string>> onget, Func<string, string> onstreamfile, Func<string, string> onlog = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.onget = onget;
            usehls = hls;
        }
        #endregion

        #region Embed
        public async ValueTask<EmbedModel> Embed(long kinopoisk_id, int s)
        {
            string html = await onget.Invoke($"{apihost}/iplayer/videodb.php?kp={kinopoisk_id}" + (s > 0 ? $"&season={s}" : ""), HeadersModel.Init(
                ("dnt", "1"),
                ("pragma", "no-cache"),
                ("referer", "https://www.google.com/"),
                ("upgrade-insecure-requests", "1")
            ));

            return Embed(html);
        }

        public EmbedModel Embed(in string html)
        {
            onlog?.Invoke(html ?? "html null");

            if (html == null)
                return null;

            string quality = html.Contains("1080p") ? "1080p" : html.Contains("720p") ? "720p" : "480p";
            string check_url = Regex.Match(html, "(https?://[^\\[\\|,\n\r\t ]+\\.mp4)").Groups[1].Value;

            string file = Regex.Match(html, "file:(\\[[^\n\r]+\\])(,|}\\) ;)").Groups[1].Value;
            if (string.IsNullOrWhiteSpace(file))
            {
                file = Regex.Match(html, "file:\"([^\"]+)\"").Groups[1].Value;
                if (!string.IsNullOrWhiteSpace(file))
                    return new EmbedModel() { pl = new List<RootObject>() { new RootObject() { file = file, title = "–î—É–±–ª—è–∂" } }, movie = true, quality = quality, check_url = check_url };

                return null;
            }

            file = Regex.Replace(file.Trim(), "(\\{|, )([a-z]+): ?", "$1\"$2\":")
                        .Replace("},]", "}]");

            List<RootObject> pl = null;

            try
            {
                pl = JsonSerializer.Deserialize<List<RootObject>>(file);
                if (pl == null || pl.Count == 0)
                    return null;
            }
            catch { return null; }

            return new EmbedModel() { pl = pl, movie = !file.Contains("\"comment\":"), quality = quality, check_url = check_url };
        }
        #endregion

        #region number_of_seasons
        public async ValueTask<int> number_of_seasons(long id)
        {
            int number_of_seasons = 1;
            string themoviedb = await onget.Invoke($"https://tmdb.mirror-kurwa.men/3/tv/{id}?api_key=4ef0d7355d9ffb5151e987764708ce96", null);

            if (themoviedb != null)
            {
                try
                {
                    var root = JsonSerializer.Deserialize<JsonObject>(themoviedb);
                    number_of_seasons = root["number_of_seasons"].GetValue<int>();
                    if (1 > number_of_seasons)
                        number_of_seasons = 1;
                }
                catch { }
            }

            if (0 >= number_of_seasons)
                number_of_seasons = 1;

            return number_of_seasons;
        }
        #endregion

        #region Html
        public string Html(EmbedModel root, int number_of_seasons, long kinopoisk_id, string title, string original_title, string t, int s, bool isbwa = false, bool rjson = false, VastConf vast = null)
        {
            if (root?.pl == null || root.pl.Count == 0)
                return string.Empty;

            if (root.movie)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, root.pl.Count);

                foreach (var pl in root.pl)
                {
                    string name = pl.title;
                    string file = pl.file;

                    if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(file))
                        continue;

                    var streamquality = new StreamQualityTpl();

                    foreach (Match m in Regex.Matches(file, $"\\[(1080|720|480|360)p?\\]([^\\[\\|,\n\r\t ]+\\.(mp4|m3u8))"))
                    {
                        string link = m.Groups[2].Value;
                        if (string.IsNullOrEmpty(link))
                            continue;

                        if (usehls && !link.Contains(".m3u"))
                            link += ":hls:manifest.m3u8";
                        else if (!usehls && link.Contains(".m3u"))
                            link = link.Replace(":hls:manifest.m3u8", "");

                        if (isbwa)
                            link = Regex.Replace(link, "/([0-9]+)\\.(m3u8|mp4)", $"/{m.Groups[1].Value}.$2");

                        streamquality.Insert(onstreamfile.Invoke(link), $"{m.Groups[1].Value}p");
                    }

                    mtpl.Append(name, streamquality.Firts().link, streamquality: streamquality, vast: vast);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                if (s == -1)
                {
                    var tpl = new SeasonTpl(root.quality);

                    for (int i = 1; i <= number_of_seasons; i++)
                    {
                        string link = host + $"lite/zetflix?rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&s={i}";
                        tpl.Append($"{i} —Å–µ–∑–æ–Ω", link, i);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                }
                else
                {
                    var vtpl = new VoiceTpl();
                    var etpl = new EpisodeTpl();
                    var hashvoices = new HashSet<string>();

                    string sArhc = s.ToString();

                    foreach (var episode in root.pl.AsEnumerable().Reverse())
                    {
                        var episodes = episode.folder;
                        if (episodes == null || episodes.Length == 0)
                            continue;

                        string perevod = episode.title;
                        if (perevod != null && string.IsNullOrEmpty(t))
                            t = perevod;

                        #region –ü–µ—Ä–µ–≤–æ–¥—ã
                        if (perevod != null && !hashvoices.Contains(perevod))
                        {
                            hashvoices.Add(perevod);
                            string link = host + $"lite/zetflix?rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&s={s}&t={HttpUtility.UrlEncode(perevod)}";

                            vtpl.Append(perevod, t == perevod, link);
                        }
                        #endregion

                        if (perevod != t)
                            continue;

                        foreach (var pl in episodes)
                        {
                            string name = pl.comment;
                            string file = pl.file;

                            if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(file))
                                continue;

                            var streamquality = new StreamQualityTpl();

                            foreach (Match m in Regex.Matches(file, $"\\[(1080|720|480|360)p?\\]([^\\[\\|,\n\r\t ]+\\.(mp4|m3u8))"))
                            {
                                string link = m.Groups[2].Value;
                                if (string.IsNullOrEmpty(link))
                                    continue;

                                if (usehls && !link.Contains(".m3u"))
                                    link += ":hls:manifest.m3u8";
                                else if (!usehls && link.Contains(".m3u"))
                                    link = link.Replace(":hls:manifest.m3u8", "");

                                if (isbwa)
                                    link = Regex.Replace(link, "/([0-9]+)\\.(m3u8|mp4)", $"/{m.Groups[1].Value}.$2");

                                streamquality.Insert(onstreamfile.Invoke(link), $"{m.Groups[1].Value}p");
                            }

                            etpl.Append(name, title ?? original_title, sArhc, Regex.Match(name, "^([0-9]+)").Groups[1].Value, streamquality.Firts().link, streamquality: streamquality, vast: vast);
                        }
                    }

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/KinoPub.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.KinoPub;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public class KinoPubInvoke
    {
        #region KinoPubInvoke
        string host, token;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public KinoPubInvoke(string host, string apihost, string token, Func<string, ValueTask<string>> onget, Func<string, string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.token = token;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
        }
        #endregion

        #region Search
        async public Task<SearchResult> Search(string title, string original_title, int year, int clarification, string imdb_id, long kinopoisk_id)
        {
            if (string.IsNullOrEmpty(title ?? original_title))
                return null;

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            #region goSearch
            async Task<SearchResult> goSearch(string q)
            {
                if (string.IsNullOrEmpty(q))
                    return null;

                string json = await onget($"{apihost}/v1/items/search?q={HttpUtility.UrlEncode(q)}&access_token={token}&field=title&perpage=200");
                if (json == null)
                {
                    requesterror?.Invoke();
                    return null;
                }

                try
                {
                    var items = JsonSerializer.Deserialize<SearchObject>(json)?.items;
                    if (items != null)
                    {
                        var ids = new List<int>(items.Length);
                        var result = new SearchResult() { similars = new SimilarTpl(items.Length) };

                        string _q = StringConvert.SearchName(q);

                        foreach (var item in items)
                        {
                            string img = PosterApi.Size(item.posters?.Skip(1)?.First().Value);
                            result.similars.Value.Append(item.title, item.year.ToString(), item.voice, host + $"lite/kinopub?postid={item.id}&title={enc_title}&original_title={enc_original_title}", img);

                            if ((item.kinopoisk > 0 && item.kinopoisk == kinopoisk_id) || $"tt{item.imdb}" == imdb_id)
                            {
                                if (item.type != "3d")
                                    result.id = item.id;
                            }
                            else
                            {
                                if (item.year == year || (item.year == year - 1) || (item.year == year + 1))
                                {
                                    string _t = StringConvert.SearchName(item.title);

                                    if (!string.IsNullOrEmpty(_t) && !string.IsNullOrEmpty(_q))
                                    {
                                        if (_t.StartsWith(_q) || _t.EndsWith(_q))
                                            ids.Add(item.id);
                                    }
                                }
                            }
                        }

                        if (ids.Count == 1 && result.id == 0)
                            result.id = ids[0];

                        return result;
                    }
                }
                catch { }

                return null;
            }
            #endregion

            if (clarification == 1)
                return await goSearch(title);

            return (await goSearch(original_title)) ?? (await goSearch(title));
        }
        #endregion

        #region Post
        async public Task<RootObject> Post(int postid)
        {
            string json = await onget($"{apihost}/v1/items/{postid}?access_token={token}");
            if (json == null)
            {
                requesterror?.Invoke();
                return null;
            }

            try
            {
                var root = JsonSerializer.Deserialize<RootObject>(json);
                if (root?.item.seasons == null && root?.item.videos == null)
                    return null;

                return root;
            }
            catch { return null; }
        }
        #endregion

        #region Html
        public string Html(RootObject root, string filetype, string title, string original_title, int postid, int s = -1, int t = -1, string codec = null, VastConf vast = null, bool rjson = false)
        {
            if (root == null)
                return string.Empty;

            if (root?.item.videos != null)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, root.item.videos.Length);

                if (filetype == "hls")
                {
                    foreach (var a in root.item.videos[0].audios)
                    {
                        var streamquality = new StreamQualityTpl();

                        foreach (var f in root.item.videos[0].files)
                        {
                            if (!string.IsNullOrEmpty(f.url.hls))
                                streamquality.Append(onstreamfile(f.url.hls.Replace("a1.m3u8", $"a{a.index}.m3u8"), null), f.quality);
                        }

                        if (!streamquality.Any())
                            continue;

                        string voice = a.type?.title ?? a.lang ?? "–æ—Ä–∏–≥–∏–Ω–∞–ª";
                        if (!string.IsNullOrEmpty(a?.author?.title))
                            voice += $" ({a.author.title})";

                        #region subtitle
                        var subtitles = new SubtitleTpl(root.item.videos[0]?.subtitles?.Length ?? 0);

                        if (root.item.videos[0].subtitles != null)
                        {
                            foreach (var sub in root.item.videos[0].subtitles)
                            {
                                if (sub.url != null)
                                    subtitles.Append(sub.lang, onstreamfile(sub.url, null));
                            }
                        }

                        string subtitles_call = null;
                        if (subtitles.IsEmpty())
                            subtitles_call = host + $"lite/kinopub/subtitles.json?mid={root.item.videos[0].id}";
                        #endregion

                        mtpl.Append(voice, streamquality.Firts().link, streamquality: streamquality, subtitles: subtitles, subtitles_call: subtitles_call, voice_name: a.codec, vast: vast);
                    }
                }
                else
                {
                    foreach (var v in root.item.videos)
                    {
                        #region voicename
                        string voicename = string.Empty;

                        if (v.audios != null)
                        {
                            foreach (var audio in v.audios)
                            {
                                if (audio.lang == "eng")
                                {
                                    if (!voicename.Contains(audio.lang))
                                        voicename += "eng, ";
                                }
                                else
                                {
                                    string a = audio?.author?.title ?? audio?.type?.title;
                                    if (a != null)
                                    {
                                        a = $"{a} ({audio.lang})";
                                        if (!voicename.Contains(a))
                                            voicename += $"{a}, ";
                                    }
                                }
                            }

                            voicename = Regex.Replace(voicename, "[, ]+$", "");
                        }
                        #endregion

                        if (filetype == "hls4")
                        {
                            if (v.files[0].url.hls4 != null)
                                mtpl.Append(v.files[0].quality, onstreamfile(v.files[0].url.hls4, null), voice_name: voicename, vast: vast);
                        }
                        else
                        {
                            if (v.files[0].url.http == null)
                                continue;

                            #region subtitle
                            var subtitles = new SubtitleTpl(v.subtitles?.Length ?? 0);

                            if (v.subtitles != null)
                            {
                                foreach (var sub in v.subtitles)
                                {
                                    if (sub.url != null)
                                        subtitles.Append(sub.lang, onstreamfile(sub.url, null));
                                }
                            }

                            string subtitles_call = null;
                            if (subtitles.IsEmpty())
                                subtitles_call = host + $"lite/kinopub/subtitles.json?mid={v.id}";
                            #endregion

                            var streamquality = new StreamQualityTpl(v.files.Select(f => (onstreamfile(f.url.http, f.file), f.quality)));
                            var first = streamquality.Firts();

                            mtpl.Append(first.quality, first.link, subtitles: subtitles, subtitles_call: subtitles_call, voice_name: voicename, streamquality: streamquality, vast: vast);
                        }
                    }
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                if (root?.item.seasons == null || root.item.seasons.Length == 0)
                    return string.Empty;

                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                if (s == -1)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    var tpl = new SeasonTpl(root.item.quality > 0 ? $"{root.item.quality}p" : null, root.item.seasons.Length);

                    foreach (var season in root.item.seasons)
                    {
                        string link = host + $"lite/kinopub?rjson={rjson}&postid={postid}&title={enc_title}&original_title={enc_original_title}&s={season.number}";
                        tpl.Append($"{season.number} —Å–µ–∑–æ–Ω", link, season.number);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∏
                    string sArhc = s.ToString();

                    if (filetype == "hls")
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();
                        var hash = new HashSet<string>();

                        foreach (var a in root.item.seasons.First(i => i.number == s).episodes[0].audios)
                        {
                            string voice = a?.author?.title ?? a?.type?.title;

                            int? idt = a?.author?.id;
                            if (idt == null)
                                idt = a?.type?.id ?? null;

                            if (idt == null)
                            {
                                if (a.lang == "eng")
                                {
                                    idt = 6;
                                    voice = "–û—Ä–∏–≥–∏–Ω–∞–ª";
                                }
                                else
                                {
                                    idt = 1;
                                    voice = "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é";
                                }
                            }

                            if (string.IsNullOrEmpty(voice))
                                continue;

                            if (t == -1)
                            {
                                t = (int)idt;
                                codec = a.codec;
                            }

                            if (!hash.Contains($"{voice}:{a.codec}"))
                            {
                                hash.Add($"{voice}:{a.codec}");

                                string link = host + $"lite/kinopub?rjson={rjson}&postid={postid}&title={enc_title}&original_title={enc_original_title}&s={s}&t={idt}&codec={a.codec}";
                                bool active = t == idt && (codec == null || codec == a.codec);

                                vtpl.Append($"{voice} ({a.codec})", active, link);
                            }
                            }
                            #endregion

                        #region –°–µ—Ä–∏–∏
                        var etpl = new EpisodeTpl();

                        foreach (var episode in root.item.seasons.First(i => i.number == s).episodes)
                        {
                            int voice_index = -1;
                            if (t == 1)
                            {
                                voice_index = t;
                            }
                            else
                            {
                                foreach (var a in episode.audios)
                                {
                                    int? idt = a?.author?.id;
                                    if (idt == null)
                                        idt = a?.type?.id;

                                    if ((idt != null && t == (int)idt && (codec == null || codec == a.codec)) ||
                                        (t == 6 && a.lang == "eng"))
                                    {
                                        voice_index = a!.index;
                                        break;
                                    }
                                }

                                if (voice_index == -1)
                                    break;
                            }

                            var streamquality = new StreamQualityTpl();

                            foreach (var f in episode.files)
                            {
                                if (!string.IsNullOrEmpty(f.url.hls))
                                    streamquality.Append(onstreamfile(f.url.hls.Replace("a1.m3u8", $"a{voice_index}.m3u8"), null), f.quality);
                            }

                            #region subtitle
                            var subtitles = new SubtitleTpl(episode.subtitles?.Length ?? 0);

                            if (episode.subtitles != null)
                            {
                                foreach (var sub in episode.subtitles)
                                {
                                    if (sub.url != null)
                                        subtitles.Append(sub.lang, onstreamfile(sub.url, null));
                                }
                            }

                            string subtitles_call = null;
                            if (subtitles.IsEmpty())
                                subtitles_call = host + $"lite/kinopub/subtitles.json?mid={episode.id}";
                            #endregion

                            etpl.Append($"{episode.number} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.number.ToString(), streamquality.Firts().link, streamquality: streamquality, subtitles: subtitles, subtitles_call: subtitles_call, vast: vast);
                        }
                        #endregion

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                    else
                    {
                        var episodes = root.item.seasons.First(i => i.number == s).episodes;

                        var etpl = new EpisodeTpl(episodes.Length);

                        foreach (var episode in episodes)
                        {
                            #region voicename
                            string voicename = string.Empty;

                            if (episode.audios != null)
                            {
                                foreach (var audio in episode.audios)
                                {
                                    string a = audio.author?.title ?? audio.lang;
                                    if (a != null && !voicename.Contains(a) && a != "rus")
                                        voicename += $"{a}, ";
                                }

                                voicename = Regex.Replace(voicename, "[, ]+$", "");
                            }
                            #endregion

                            if (filetype == "hls4")
                            {
                                if (episode.files[0].url.hls4 == null)
                                    continue;

                                etpl.Append($"{episode.number} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.number.ToString(), onstreamfile(episode.files[0].url.hls4, null), voice_name: voicename, vast: vast);
                            }
                            else
                            {
                                if (episode.files[0].url.http == null)
                                    continue;

                                #region subtitle
                                var subtitles = new SubtitleTpl(episode.subtitles?.Length ?? 0);

                                if (episode.subtitles != null)
                                {
                                    foreach (var sub in episode.subtitles)
                                    {
                                        if (sub.url != null)
                                            subtitles.Append(sub.lang, onstreamfile(sub.url, null));
                                    }
                                }

                                string subtitles_call = null;
                                if (subtitles.IsEmpty())
                                    subtitles_call = host + $"lite/kinopub/subtitles.json?mid={episode.id}";
                                #endregion

                                #region streams
                                var streamquality = new StreamQualityTpl();

                                foreach (var f in episode.files)
                                {
                                    if (f.url.http != null)
                                        streamquality.Append(onstreamfile(f.url.http, f.file), f.quality);
                                }
                                #endregion

                                etpl.Append($"{episode.number} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.number.ToString(), streamquality.Firts().link, subtitles: subtitles, subtitles_call: subtitles_call, voice_name: voicename, streamquality: streamquality, vast: vast);
                            }
                        }

                        return rjson ? etpl.ToJson() : etpl.ToHtml();
                    }
                    #endregion
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Redheadsound.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.Redheadsound;
using Shared.Models.Templates;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct RedheadsoundInvoke
    {
        #region RedheadsoundInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public RedheadsoundInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.onpost = onpost;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        async public Task<EmbedModel> Embed(string title, int year)
        {
            if (string.IsNullOrEmpty(title))
                return null;

            string mainHtml = await onget(apihost);
            string user_hash = Regex.Match(mainHtml ?? "", "var dle_login_hash([\t ]+)?=([\t ]+)?'(?<hash>[a-f0-9]+)'").Groups["hash"].Value;
            if (string.IsNullOrEmpty(user_hash))
                return null;

            string search = await onpost($"{apihost}/engine/ajax/controller.php?mod=search", $"query={HttpUtility.UrlEncode(title)}&skin=rhs_new&user_hash={user_hash}");
            if (search == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string link = null, reservedlink = null;
            foreach (var node in HtmlParse.Nodes(search, "//div[@class='move-item']"))
            {
                string rowTitle = StringConvert.SearchName(node.SelectText(".//h4[@class='title']//a"));
                if (rowTitle == null)
                    continue;

                if (rowTitle.Contains(StringConvert.SearchName(title)))
                {
                    string rlnk = node.SelectText(".//a[@class='move-item__img']", "href");
                    if (rlnk == null)
                        continue;

                    reservedlink = rlnk;

                    if (node.SelectText(".//span[contains(@class, 'year')]//a") == year.ToString())
                    {
                        link = reservedlink;
                        break;
                    }
                }
            }

            if (string.IsNullOrEmpty(link))
            {
                if (string.IsNullOrEmpty(reservedlink))
                {
                    if (search.Contains("notfound"))
                        return new EmbedModel() { IsEmpty = true };

                    return null;
                }

                link = reservedlink;
            }

            string news = await onget(link);
            if (news == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string iframeUri = Regex.Match(news, "videoUrl([\t ]+)?=([\t ]+)?'(?<uri>https?://[^']+)'").Groups["uri"].Value;
            if (string.IsNullOrEmpty(iframeUri))
                return null;

            string iframe = await onget(iframeUri);
            if (string.IsNullOrEmpty(iframe))
            {
                requesterror?.Invoke();
                return null;
            }

            string contentUrl = Regex.Match(iframe, "\"contentUrl\": ?\"([^\"]+)\"").Groups[1].Value;
            if (string.IsNullOrEmpty(contentUrl))
                return null;

            return new EmbedModel() { iframe = contentUrl };
        }
        #endregion

        #region Html
        public string Html(EmbedModel content, string title, VastConf vast = null, bool rjson = false)
        {
            if (content == null || content.IsEmpty)
                return string.Empty;

            var mtpl = new MovieTpl(title, null, 1);

            mtpl.Append("1080p", onstreamfile(content.iframe.Replace("&amp;", "&")));

            return rjson ? mtpl.ToJson() : mtpl.ToHtml();
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Kinoukr.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.Eneyida;
using Shared.Models.Templates;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct KinoukrInvoke
    {
        #region unic
        static string ArrayList => "qwertyuioplkjhgfdsazxcvbnm";
        static string ArrayListToNumber => "1234567890";
        public static string unic(int size = 8, bool IsNumberCode = false)
        {
            StringBuilder array = new StringBuilder();
            for (int i = 0; i < size; i++)
            {
                array.Append(IsNumberCode ? ArrayListToNumber[Random.Shared.Next(0, ArrayListToNumber.Length)] : ArrayList[Random.Shared.Next(0, ArrayList.Length)]);
            }

            return array.ToString();
        }
        #endregion

        #region KinoukrInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public KinoukrInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onpost = onpost;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        public async ValueTask<EmbedModel> Embed(string original_title, int year, string href)
        {
            if (string.IsNullOrWhiteSpace(href) && (string.IsNullOrWhiteSpace(original_title) || year == 0))
                return null;

            return null;

            string link = href;
            var result = new EmbedModel();

            if (string.IsNullOrWhiteSpace(link))
            {
                onlog?.Invoke("search start");
                //string? search = await onget.Invoke($"{apihost}/index.php?do=search&subaction=search&from_page=0&story={HttpUtility.UrlEncode(original_title)}");

                // $"{apihost}/index.php?do=search"
                string search = await onpost.Invoke($"{apihost}/{unic(4, true)}-{unic(Random.Shared.Next(4, 8))}-{unic(Random.Shared.Next(5, 10))}.html", $"do=search&subaction=search&story={HttpUtility.UrlEncode(original_title)}");
                if (search == null)
                {
                    requesterror?.Invoke();
                    return null;
                }

                onlog?.Invoke("search ok");

                foreach (string row in search.Split("\"short clearfix with-mask\"").Skip(1))
                {
                    if (row.Contains(">–ê–Ω–æ–Ω—Å</div>") || row.Contains(">–¢—Ä–µ–π–ª–µ—Ä</div>"))
                        continue;

                    string newslink = Regex.Match(row, "href=\"(https?://[^/]+/[^\"]+\\.html)\"").Groups[1].Value;
                    if (string.IsNullOrWhiteSpace(newslink))
                        continue;

                    string name = Regex.Match(row, "class=\"short-title\" [^>]+>([^<]+)<").Groups[1].Value;
                    if (result.similars == null)
                        result.similars = new List<Similar>();

                    result.similars.Add(new Similar() 
                    {
                        title = name,
                        href = newslink
                    });
                }

                if (result.similars == null || result.similars.Count == 0)
                {
                    if (search.Contains(">–ü–æ—à—É–∫ –ø–æ —Å–∞–π—Ç—É<"))
                        return new EmbedModel() { IsEmpty = true };

                    return null;
                }

                if (result.similars.Count > 1)
                    return result;

                link = result.similars[0].href;
            }

            onlog?.Invoke("link: " + link);
            string news = await onget.Invoke(link);
            if (news == null)
            {
                requesterror?.Invoke();
                return null;
            }

            result.quel = Regex.Match(news, "class=\"m-meta m-qual\">([^<]+)<").Groups[1].Value;

            string iframeUri = Regex.Match(news, "src=\"(https?://tortuga\\.[a-z]+/[^\"]+)\"").Groups[1].Value;
            if (string.IsNullOrEmpty(iframeUri))
            {
                iframeUri = Regex.Match(news, "src=\"(https?://ashdi\\.vip/[^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(iframeUri))
                    return null;
            }

            onlog?.Invoke("iframeUri: " + iframeUri);
            string content = await onget.Invoke(iframeUri);
            if (content == null || !content.Contains("file:"))
            {
                requesterror?.Invoke();
                return null;
            }

            string player = StringConvert.FindLastText(content, "new Playerjs", "</script>");
            if (player == null)
                return null;

            if (Regex.IsMatch(content, "file: ?'\\["))
            {
                Models.Online.Tortuga.Voice[] root = null;

                try
                {
                    root = JsonSerializer.Deserialize<Models.Online.Tortuga.Voice[]>(Regex.Match(content, "file: ?'([^\n\r]+)',").Groups[1].Value);
                    if (root == null || root.Length == 0)
                        return null;
                }
                catch { return null; }

                result.serial = root;
            }
            else
            {
                result.content = player;
                onlog?.Invoke("content: " + result.content);
            }

            return result;
        }
        #endregion

        #region EmbedKurwa
        public async ValueTask<EmbedModel> EmbedKurwa(int clarification, string title, string original_title, int year, string href)
        {
            string iframeUri = href;
            var result = new EmbedModel();

            if (string.IsNullOrEmpty(iframeUri))
            {
                string arg = clarification == 1 || string.IsNullOrWhiteSpace(original_title) 
                    ? $"name={HttpUtility.UrlEncode(title)}" 
                    : $"eng_name={HttpUtility.UrlEncode(original_title)}";

                string json = await onget.Invoke("http://194.246.82.144/ukr?" + arg);
                if (json == null)
                {
                    requesterror?.Invoke();
                    return null;
                }

                result.similars = new List<Similar>();

                try
                {
                    foreach (var item in JsonSerializer.Deserialize<BobrKurwa[]>(json))
                    {
                        var model = new Similar()
                        {
                            href = item.tortuga ?? item.ashdi,
                            title = $"{item.name} / {item.eng_name}",
                            year = item.year
                        };

                        if (item.year == year.ToString())
                            result.similars.Insert(0, model);
                        else
                            result.similars.Add(model);
                    }
                }
                catch { }

                if (result.similars.Count == 0)
                    return new EmbedModel() { IsEmpty = true };

                if (result.similars.Count > 1 && result.similars[0].year != year.ToString())
                    return result;

                iframeUri = result.similars[0].href;
            }

            onlog?.Invoke("iframeUri: " + iframeUri);
            string content = await onget.Invoke(iframeUri);
            if (content == null || !content.Contains("file:"))
            {
                requesterror?.Invoke();
                return null;
            }

            if (iframeUri.Contains("ashdi"))
            {
                result.source_type = "ashdi";

                if (Regex.IsMatch(content, "file: ?'\\["))
                {
                    Models.Online.Ashdi.Voice[] root = null;

                    try
                    {
                        root = JsonSerializer.Deserialize<Models.Online.Ashdi.Voice[]>(Regex.Match(content, "file: ?'([^\n\r]+)',").Groups[1].Value);
                        if (root == null || root.Length == 0)
                            return null;
                    }
                    catch { return null; }

                    result.serial_ashdi = root;
                }
                else
                {
                    result.content = content;
                    onlog?.Invoke("content: " + result.content);
                }

                return result;
            }
            else
            {
                result.source_type = "tortuga";

                if (Regex.IsMatch(content, "file: ?'"))
                {
                    Models.Online.Tortuga.Voice[] root = null;

                    try
                    {
                        string file = Regex.Match(content, "file: ?'([^\n\r]+)',").Groups[1].Value;
                        if (file.EndsWith("=="))
                        {
                            file = Regex.Replace(file, "==$", "");
                            file = string.Join("", CrypTo.DecodeBase64(file).Reverse());
                        }

                        root = JsonSerializer.Deserialize<Models.Online.Tortuga.Voice[]>(file);
                        if (root == null || root.Length == 0)
                            return null;
                    }
                    catch { return null; }

                    result.serial = root;
                }
                else
                {
                    string player = StringConvert.FindLastText(content, "new TortugaCore", "</script>");

                    result.content = player ?? content;
                    onlog?.Invoke("content: " + result.content);
                }
            }

            return result;
        }
        #endregion

        #region getIframeSource
        public async ValueTask<string> getIframeSource(string link)
        {
            if (string.IsNullOrWhiteSpace(link))
                return null;

            string news = await onget.Invoke(link);
            if (news == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string iframeUri = Regex.Match(news, "src=\"(https?://tortuga\\.[a-z]+/[^\"]+)\"").Groups[1].Value;
            if (string.IsNullOrEmpty(iframeUri))
            {
                iframeUri = Regex.Match(news, "src=\"(https?://ashdi\\.vip/[^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(iframeUri))
                    return null;
            }

            return iframeUri;
        }
        #endregion

        #region Html
        public string Html(EmbedModel result, int clarification, string title, string original_title, int year, string t, int s, string href, VastConf vast = null, bool rjson = false)
        {
            if (result == null || result.IsEmpty)
                return string.Empty;

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);
            string enc_href = HttpUtility.UrlEncode(href);

            #region similar
            if (result.content == null && result.serial == null && result.serial_ashdi == null)
            {
                if (string.IsNullOrWhiteSpace(href) && result.similars != null && result.similars.Count > 0)
                {
                    var stpl = new SimilarTpl(result.similars.Count);

                    foreach (var similar in result.similars)
                    {
                        string link = host + $"lite/kinoukr?rjson={rjson}&clarification={clarification}&title={enc_title}&original_title={enc_original_title}&year={year}&href={HttpUtility.UrlEncode(similar.href)}";

                        stpl.Append(similar.title, similar.year, string.Empty, link);
                    }

                    return rjson ? stpl.ToJson() : stpl.ToHtml();
                }

                return string.Empty;
            }
            #endregion

            if (result.source_type == "ashdi")
            {
                var invk = new AshdiInvoke(host, apihost, onget, onstreamfile, onlog: onlog, requesterror: requesterror);
                int.TryParse(t, out int _t);

                var md = new Models.Online.Ashdi.EmbedModel()
                {
                    content = result.content,
                    serial = result.serial_ashdi
                };

                return invk.Html(md, 0, title, original_title, _t, s, vast, rjson, host + $"lite/kinoukr?rjson={rjson}&clarification={clarification}&title={enc_title}&original_title={enc_original_title}&year={year}&href={enc_href}");
            }

            if (result.content != null)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, 1);

                string hls = Regex.Match(result.content, "file: ?(\"|')(?<hls>https?://[^\"']+/index\\.m3u8)(\"|')").Groups["hls"].Value;
                if (string.IsNullOrWhiteSpace(hls))
                {
                    string base64 = Regex.Match(result.content, "file: ?(\"|')(?<base64>[^\"']+)(\"|')").Groups["base64"].Value;
                           base64 = Regex.Replace(base64, "==$", "");

                    hls = string.Join("", CrypTo.DecodeBase64(base64).Reverse());

                    if (string.IsNullOrWhiteSpace(hls))
                        return string.Empty;
                }

                #region subtitle
                var subtitles = new SubtitleTpl();
                string subtitle = new Regex("\"subtitle\": ?\"([^\"]+)\"").Match(result.content).Groups[1].Value;

                if (!string.IsNullOrEmpty(subtitle))
                {
                    var match = new Regex("\\[([^\\]]+)\\](https?://[^\\,]+)").Match(subtitle);
                    while (match.Success)
                    {
                        subtitles.Append(match.Groups[1].Value, onstreamfile.Invoke(match.Groups[2].Value));
                        match = match.NextMatch();
                    }
                }
                #endregion

                mtpl.Append(string.IsNullOrEmpty(result.quel) ? "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é" : result.quel, onstreamfile.Invoke(hls), subtitles: subtitles, vast: vast);

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                try
                {
                    if (s == -1)
                    {
                        #region –°–µ–∑–æ–Ω—ã
                        var tpl = new SeasonTpl();

                        foreach (var season in result.serial)
                        {
                            string link = host + $"lite/kinoukr?rjson={rjson}&clarification={clarification}&title={enc_title}&original_title={enc_original_title}&year={year}&href={enc_href}&s={season.season}";

                            tpl.Append(season.title, link, season.season);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                        #endregion
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();
                        var hashVoice = new HashSet<string>();

                        foreach (var season in result.serial)
                        {
                            foreach (var episode in season.folder)
                            {
                                foreach (var voice in episode.folder)
                                {
                                    if (hashVoice.Contains(voice.title))
                                        continue;
                                    hashVoice.Add(voice.title);

                                    if (string.IsNullOrEmpty(t))
                                        t = voice.title;

                                    string link = host + $"lite/kinoukr?rjson={rjson}&clarification={clarification}&title={enc_title}&original_title={enc_original_title}&year={year}&href={enc_href}&s={s}&t={voice.title}";
                                    vtpl.Append(voice.title, t == voice.title, link);
                                }
                            }
                        }
                        #endregion

                        string sArhc = s.ToString();
                        var episodes = result.serial.First(i => i.season == sArhc).folder;
                        var etpl = new EpisodeTpl(episodes.Length);

                        foreach (var episode in episodes)
                        {
                            var video = episode.folder.FirstOrDefault(i => i.title == t);
                            if (video.file == null)
                                continue;

                            #region subtitle
                            var subtitles = new SubtitleTpl();

                            if (!string.IsNullOrEmpty(video.subtitle))
                            {
                                var match = new Regex("\\[([^\\]]+)\\](https?://[^\\,]+)").Match(video.subtitle);
                                while (match.Success)
                                {
                                    subtitles.Append(match.Groups[1].Value, onstreamfile.Invoke(match.Groups[2].Value));
                                    match = match.NextMatch();
                                }
                            }
                            #endregion

                            string file = onstreamfile.Invoke(video.file);
                            etpl.Append(episode.title, title ?? original_title, sArhc, episode.number, file, subtitles: subtitles, vast: vast);
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                }
                catch
                {
                    return string.Empty;
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Ashdi.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.Ashdi;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct AshdiInvoke
    {
        #region AshdiInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public AshdiInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        public async ValueTask<EmbedModel> Embed(long kinopoisk_id)
        {
            string product = await onget.Invoke($"{apihost}/api/product/read_api.php?kinopoisk={kinopoisk_id}");
            if (product == null)
            {
                requesterror?.Invoke();
                return null;
            }

            if (product.Contains("Product does not exist"))
                return new EmbedModel() { IsEmpty = true };

            string iframeuri = Regex.Match(product, "src=\"(https?://[^\"]+)\"").Groups[1].Value;
            if (string.IsNullOrWhiteSpace(iframeuri))
            {
                requesterror?.Invoke();
                return null;
            }

            string content = await onget.Invoke(iframeuri);
            if (content == null || !content.Contains("Playerjs"))
            {
                requesterror?.Invoke();
                return null;
            }

            if (!Regex.IsMatch(content, "file:([\t ]+)?'\\[\\{"))
                return new EmbedModel() { content = content };

            Voice[] root = null;

            try
            {
                root = JsonSerializer.Deserialize<Voice[]>(Regex.Match(content, "file:([\t ]+)?'([^\n\r]+)',").Groups[2].Value);
                if (root == null || root.Length == 0)
                    return null;
            }
            catch { return null; }

            return new EmbedModel() { serial = root };
        }
        #endregion

        #region Html
        public string Html(EmbedModel md, long kinopoisk_id, string title, string original_title, int t, int s, VastConf vast = null, bool rjson = false, string mybaseurl = null)
        {
            if (md == null || md.IsEmpty || (string.IsNullOrEmpty(md.content) && md.serial == null))
                return string.Empty;

            string fixStream(string _l) => _l.Replace("0yql3tj", "oyql3tj");

            if (md.content != null)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, 1);

                string hls = Regex.Match(md.content, "file:([\t ]+)?(\"|')([\t ]+)?(?<hls>https?://[^\"'\n\r\t ]+/index.m3u8)").Groups["hls"].Value;
                if (string.IsNullOrEmpty(hls))
                    return string.Empty;

                #region subtitle
                SubtitleTpl? subtitles = null;
                string subtitle = new Regex("subtitle(\")?:\"([^\"]+)\"").Match(md.content).Groups[2].Value;

                if (!string.IsNullOrEmpty(subtitle))
                {
                    var match = new Regex("\\[([^\\]]+)\\](https?://[^\\,]+)").Match(subtitle);
                    subtitles = new SubtitleTpl(match.Length);

                    while (match.Success)
                    {
                        subtitles.Value.Append(match.Groups[1].Value, onstreamfile.Invoke(fixStream(match.Groups[2].Value)));
                        match = match.NextMatch();
                    }
                }
                #endregion

                mtpl.Append("–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é", onstreamfile.Invoke(fixStream(hls)), subtitles: subtitles, vast: vast);

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                try
                {
                    if (s == -1)
                    {
                        var tpl = new SeasonTpl();
                        var hashseason = new HashSet<string>();

                        foreach (var voice in md.serial)
                        {
                            foreach (var season in voice.folder)
                            {
                                if (hashseason.Contains(season.title))
                                    continue;

                                hashseason.Add(season.title);
                                string numberseason = Regex.Match(season.title, "([0-9]+)$").Groups[1].Value;
                                if (string.IsNullOrEmpty(numberseason))
                                    continue;

                                string baseUrl = mybaseurl ?? (host + $"lite/ashdi?rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}");
                                string link = $"{baseUrl}&s={numberseason}";

                                tpl.Append(season.title, link, numberseason);
                            }
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();

                        for (int i = 0; i < md.serial.Length; i++)
                        {
                            if (md.serial[i].folder.FirstOrDefault(i => i.title.EndsWith($" {s}")).title == null)
                                continue;

                            if (t == -1)
                                t = i;

                            string baseUrl = mybaseurl ?? (host + $"lite/ashdi?rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}");
                            string link = $"{baseUrl}&s={s}&t={i}";

                            vtpl.Append(md.serial[i].title, t == i, link);
                        }
                        #endregion

                        string sArch = s.ToString();
                        var episodes = md.serial[t].folder.First(i => i.title.EndsWith($" {s}")).folder;

                        var etpl = new EpisodeTpl(episodes.Length);

                        foreach (var episode in episodes)
                        {
                            #region subtitle
                            SubtitleTpl? subtitles = null;

                            if (!string.IsNullOrEmpty(episode.subtitle))
                            {
                                var match = new Regex("\\[([^\\]]+)\\](https?://[^\\,]+)").Match(episode.subtitle);
                                subtitles = new SubtitleTpl(match.Length);

                                while (match.Success)
                                {
                                    subtitles.Value.Append(match.Groups[1].Value, onstreamfile.Invoke(fixStream(match.Groups[2].Value)));
                                    match = match.NextMatch();
                                }
                            }
                            #endregion

                            string file = onstreamfile.Invoke(fixStream(episode.file));
                            etpl.Append(episode.title, title ?? original_title, sArch, Regex.Match(episode.title, "([0-9]+)$").Groups[1].Value, file, subtitles: subtitles, vast: vast);
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                }
                catch
                {
                    return string.Empty;
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Eneyida.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.Eneyida;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct EneyidaInvoke
    {
        #region EneyidaInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public EneyidaInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onpost = onpost;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        public async ValueTask<EmbedModel> Embed(string original_title, int year, string href, bool similar)
        {
            if (string.IsNullOrWhiteSpace(href) && (string.IsNullOrWhiteSpace(original_title) || year == 0))
                return null;

            string link = href;
            var result = new EmbedModel();

            if (string.IsNullOrEmpty(link))
            {
                onlog?.Invoke("search start");
                string search = await onpost.Invoke($"{apihost}/index.php?do=search", $"do=search&subaction=search&search_start=0&result_from=1&story={HttpUtility.UrlEncode(original_title)}");
                if (search == null)
                {
                    requesterror?.Invoke();
                    return null;
                }

                onlog?.Invoke("search ok");

                var rows = search.Split("<article ");
                string stitle = StringConvert.SearchName(original_title?.ToLower());

                foreach (string row in rows.Skip(1))
                {
                    if (row.Contains(">–ê–Ω–æ–Ω—Å</div>") || row.Contains(">–¢—Ä–µ–π–ª–µ—Ä</div>"))
                        continue;

                    string newslink = Regex.Match(row, "href=\"(https?://[^/]+/[^\"]+\\.html)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(newslink))
                        continue;

                    // <div class="short_subtitle"><a href="https://eneyida.tv/xfsearch/year/2025/">2025</a> &bull; Thunderbolts</div>
                    var g = Regex.Match(row, "class=\"short_subtitle\">(<a [^>]+>([0-9]{4})</a>)?([^<]+)</div>").Groups;

                    string name = g[3].Value.Replace("&bull;", "").Trim();
                    if (string.IsNullOrEmpty(name))
                        continue;

                    if (result.similars == null)
                        result.similars = new List<Similar>(rows.Length);

                    string uaname = Regex.Match(row, "id=\"short_title\"[^>]+>([^<]+)<").Groups[1].Value;
                    string img = Regex.Match(row, "data-src=\"/([^\"]+)\"").Groups[1].Value;

                    result.similars.Add(new Similar()
                    {
                        title = $"{uaname} / {name}",
                        year = g[2].Value,
                        href = newslink,
                        img = string.IsNullOrEmpty(img) ? null : $"{apihost}/{img}"
                    });

                    if (StringConvert.SearchName(name) == stitle && g[2].Value == year.ToString())
                    {
                        link = newslink;
                        break;
                    }
                }

                if (similar)
                    return result;

                if (string.IsNullOrEmpty(link))
                {
                    if (result.similars.Count > 0)
                        return result;

                    if (search.Contains(">–ü–æ—à—É–∫ –ø–æ —Å–∞–π—Ç—É<"))
                        return new EmbedModel() { IsEmpty = true };

                    return null;
                }
            }

            onlog?.Invoke("link: " + link);
            string news = await onget.Invoke(link);
            if (news == null)
            {
                requesterror?.Invoke();
                return null;
            }

            if (news.Contains("full_content fx_row"))
                result.quel = Regex.Match(news.Split("full_content fx_row")[1].Split("full__favourite")[0], " (1080p|720p|480p)</div>").Groups[1].Value;

            string iframeUri = Regex.Match(news, "<iframe width=\"100%\" height=\"400\" src=\"(https?://[^/]+/[^\"]+/[0-9]+)\"").Groups[1].Value;
            if (string.IsNullOrEmpty(iframeUri))
                return null;

            onlog?.Invoke("iframeUri: " + iframeUri);
            string content = await onget.Invoke(iframeUri);
            if (content == null || !content.Contains("file:"))
            {
                requesterror?.Invoke();
                return null;
            }

            if (Regex.IsMatch(content, "file: ?'\\["))
            {
                Models.Online.Tortuga.Voice[] root = null;

                try
                {
                    root = JsonSerializer.Deserialize<Models.Online.Tortuga.Voice[]>(Regex.Match(content, "file: ?'([^\n\r]+)',").Groups[1].Value);
                    if (root == null || root.Length == 0)
                        return null;
                }
                catch { return null; }

                result.serial = root;
            }
            else
            {
                result.content = content;
            }

            return result;
        }
        #endregion

        #region Html
        public string Html(EmbedModel result, int clarification, string title, string original_title, int year, int t, int s, string href, VastConf vast = null, bool rjson = false)
        {
            if (result == null || result.IsEmpty)
                return string.Empty;

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            #region similar
            if (result.content == null && result.serial == null)
            {
                if (string.IsNullOrWhiteSpace(href) && result.similars != null && result.similars.Count > 0)
                {
                    var stpl = new SimilarTpl(result.similars.Count);

                    foreach (var similar in result.similars)
                    {
                        string link = host + $"lite/eneyida?clarification={clarification}&title={enc_title}&original_title={enc_original_title}&year={year}&href={HttpUtility.UrlEncode(similar.href)}";

                        stpl.Append(similar.title, similar.year, string.Empty, link, PosterApi.Size(similar.img));
                    }

                    return rjson ? stpl.ToJson() : stpl.ToHtml();
                }

                return string.Empty;
            }
            #endregion

            if (result.content != null)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title);

                string hls = Regex.Match(result.content, "file: ?\"(https?://[^\"]+/index.m3u8)\"").Groups[1].Value;
                if (string.IsNullOrWhiteSpace(hls))
                    return string.Empty;

                #region subtitle
                SubtitleTpl subtitles = new SubtitleTpl();
                string subtitle = new Regex("subtitle: ?\"([^\"]+)\"").Match(result.content).Groups[1].Value;

                if (!string.IsNullOrEmpty(subtitle))
                {
                    var match = new Regex("\\[([^\\]]+)\\](https?://[^\\,]+)").Match(subtitle);
                    while (match.Success)
                    {
                        subtitles.Append(match.Groups[1].Value, onstreamfile.Invoke(match.Groups[2].Value));
                        match = match.NextMatch();
                    }
                }
                #endregion

                mtpl.Append(string.IsNullOrEmpty(result.quel) ? "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é" : result.quel, onstreamfile.Invoke(hls), subtitles: subtitles, vast: vast);

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_href = HttpUtility.UrlEncode(href);

                try
                {
                    if (s == -1)
                    {
                        #region –°–µ–∑–æ–Ω—ã
                        var tpl = new SeasonTpl();

                        foreach (var season in result.serial)
                        {
                            string numberseason = Regex.Match(season.title, "^([0-9]+)").Groups[1].Value;
                            if (string.IsNullOrEmpty(numberseason))
                                continue;

                            string link = host + $"lite/eneyida?rjson={rjson}&clarification={clarification}&title={enc_title}&original_title={enc_original_title}&year={year}&href={enc_href}&s={numberseason}";

                            tpl.Append(season.title, link, numberseason);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                        #endregion
                    }
                    else
                    {
                        var season = result.serial.First(i => i.title.StartsWith($"{s} "));

                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();

                        for (int i = 0; i < season.folder.Length; i++)
                        {
                            if (t == -1)
                                t = i;

                            string link = host + $"lite/eneyida?rjson={rjson}&clarification={clarification}&title={enc_title}&original_title={enc_original_title}&year={year}&href={enc_href}&s={s}&t={i}";

                            vtpl.Append(season.folder[i].title, t == i, link);
                        }
                        #endregion

                        string sArch = s.ToString();
                        var episodes = season.folder[t].folder;

                        var etpl = new EpisodeTpl(episodes.Length);

                        foreach (var episode in episodes)
                        {
                            #region subtitle
                            SubtitleTpl? subtitles = null;

                            if (!string.IsNullOrEmpty(episode.subtitle))
                            {
                                var match = new Regex("\\[([^\\]]+)\\](https?://[^\\,]+)").Match(episode.subtitle);
                                subtitles = new SubtitleTpl(match.Length);

                                while (match.Success)
                                {
                                    subtitles.Value.Append(match.Groups[1].Value, onstreamfile.Invoke(match.Groups[2].Value));
                                    match = match.NextMatch();
                                }
                            }
                            #endregion

                            string file = onstreamfile.Invoke(episode.file);
                            etpl.Append(episode.title, title ?? original_title, sArch, Regex.Match(episode.title, "^([0-9]+)").Groups[1].Value, file, subtitles: subtitles, vast: vast);
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                }
                catch
                {
                    return string.Empty;
                }
                #endregion
            }
        }
        #endregion
    }
}
```

## File: Shared/Engine/Online/Kodik.cs
```
Ôªøusing HtmlAgilityPack;
using Shared.Models;
using Shared.Models.Base;
using Shared.Models.Online.Kodik;
using Shared.Models.Templates;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct KodikInvoke
    {
        #region KodikInvoke
        static Dictionary<string, string> psingles = new Dictionary<string, string>();
        static readonly HybridCache hybridCache = new HybridCache();
        readonly IEnumerable<Result> fallbackDatabase;

        string host;
        string apihost, token, videopath;
        bool usehls, cdn_is_working;
        Func<string, List<HeadersModel>, ValueTask<string>> onget;
        Func<string, string, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public KodikInvoke(string host, string apihost, string token, bool hls, bool cdn_is_working, string videopath, IEnumerable<Result> fallbackDatabase, Func<string, List<HeadersModel>, ValueTask<string>> onget, Func<string, string, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.token = token;
            this.videopath = videopath;
            this.fallbackDatabase = fallbackDatabase;
            this.onget = onget;
            this.onpost = onpost;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.usehls = hls;
            this.cdn_is_working = cdn_is_working;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        async public ValueTask<List<Result>> Embed(string imdb_id, long kinopoisk_id, int s)
        {
            if (string.IsNullOrEmpty(imdb_id) && kinopoisk_id == 0)
                return null;

            string json = null;
            List<Result> results = null;

            if (!string.IsNullOrWhiteSpace(token))
            {
                string url = $"{apihost}/search?token={token}&limit=100&with_episodes=true";
                if (kinopoisk_id > 0)
                    url += $"&kinopoisk_id={kinopoisk_id}";

                if (!string.IsNullOrWhiteSpace(imdb_id))
                    url += $"&imdb_id={imdb_id}";

                if (s > 0)
                    url += $"&season={s}";

                try
                {
                    json = await onget(url, null);

                    if (string.IsNullOrWhiteSpace(json))
                    {
                        requesterror?.Invoke();
                    }
                    else
                    {
                        var root = JsonSerializer.Deserialize<RootObject>(json);
                        if (root?.results != null)
                            results = root.results;
                        else
                            requesterror?.Invoke();
                    }
                }
                catch
                {
                    requesterror?.Invoke();
                }
            }

            if (json == null || json.Contains("–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω—ã–π —Ç–æ–∫–µ–Ω"))
            {
                if (results == null)
                    results = FallbackByIds(imdb_id, kinopoisk_id, s);
            }

            return results;
        }


        public async ValueTask<EmbedModel> Embed(string title, string original_title, int clarification)
        {
            try
            {
                if (string.IsNullOrEmpty(title) && string.IsNullOrEmpty(original_title))
                    return null;

                string json = null;
                List<Result> results = null;

                if (!string.IsNullOrWhiteSpace(token))
                {
                    string url = $"{apihost}/search?token={token}&limit=100&title={HttpUtility.UrlEncode(original_title ?? title)}&with_episodes=true&with_material_data=true";

                    try
                    {
                        json = await onget(url, null);

                        if (string.IsNullOrWhiteSpace(json))
                        {
                            requesterror?.Invoke();
                        }
                        else
                        {
                            var root = JsonSerializer.Deserialize<RootObject>(json);
                            if (root?.results != null)
                                results = root.results;
                            else
                                requesterror?.Invoke();
                        }
                    }
                    catch
                    {
                        requesterror?.Invoke();
                    }
                }

                if (json == null || json.Contains("–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω—ã–π —Ç–æ–∫–µ–Ω"))
                {
                    if (results == null)
                        results = FallbackByTitle(title, original_title);
                }

                if (results == null)
                    return null;

                var hash = new HashSet<string>();
                var stpl = new SimilarTpl(results.Count);
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                foreach (var similar in results)
                {
                    string pick = similar.title?.ToLower()?.Trim();
                    if (string.IsNullOrEmpty(pick))
                        continue;

                    if (hash.Contains(pick))
                        continue;

                    hash.Add(pick);

                    string name = !string.IsNullOrEmpty(similar.title) && !string.IsNullOrEmpty(similar.title_orig) ? $"{similar.title} / {similar.title_orig}" : (similar.title ?? similar.title_orig);

                    string details = similar.translation.title;
                    if (similar.last_season > 0)
                        details += $"{stpl.OnlineSplit} {similar.last_season}–π —Å–µ–∑–æ–Ω";

                    var matd = similar.material_data;
                    string img = PosterApi.Size(matd.anime_poster_url ?? matd.drama_poster_url ?? matd.poster_url);
                    stpl.Append(name, similar.year?.ToString(), details, host + $"lite/kodik?title={enc_title}&original_title={enc_original_title}&clarification={clarification}&pick={HttpUtility.UrlEncode(pick)}", img);
                }

                return new EmbedModel()
                {
                    stpl = stpl,
                    result = results
                };
            }
            catch { return null; }
        }

        public List<Result> Embed(List<Result> results, string pick)
        {
            var content = new List<Result>(results.Count);

            foreach (var i in results)
            {
                if (i.title == null || i.title.ToLower().Trim() != pick)
                    continue;

                content.Add(i);
            }

            return content;
        }
        #endregion

        #region Html
        public async ValueTask<string> Html(List<Result> results, string args, string imdb_id, long kinopoisk_id, string title, string original_title, int clarification, string pick, string kid, int s, bool showstream, bool rjson)
        {
            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            if (results[0].type is "foreign-movie" or "soviet-cartoon" or "foreign-cartoon" or "russian-cartoon" or "anime" or "russian-movie")
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, results.Count);

                foreach (var data in results)
                {
                    string url = host + $"lite/kodik/video?title={enc_title}&original_title={enc_original_title}&link={HttpUtility.UrlEncode(data.link)}";

                    string streamlink = null;
                    if (showstream)
                    {
                        streamlink = usehls ? $"{url.Replace("/video", $"/{videopath}.m3u8")}&play=true" : $"{url.Replace("/video", $"/{videopath}")}&play=true";

                        if (!string.IsNullOrEmpty(args))
                            streamlink += $"&{args.Remove(0, 1)}";
                    }

                    mtpl.Append(data.translation.title, url, "call", streamlink);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_pick = HttpUtility.UrlEncode(pick);

                if (s == -1)
                {
                    var tpl = new SeasonTpl(results.Count);
                    var hash = new HashSet<int>();

                    foreach (var item in results.AsEnumerable().Reverse())
                    {
                        int season = item.last_season;
                        string link = host + $"lite/kodik?rjson={rjson}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&clarification={clarification}&pick={enc_pick}&s={season}";

                        if (hash.Contains(season))
                            continue;

                        hash.Add(season);
                        tpl.Append($"{season} —Å–µ–∑–æ–Ω", link, season);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                }
                else
                {
                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var vtpl = new VoiceTpl();
                    HashSet<string> hash = new HashSet<string>();

                    foreach (var item in results)
                    {
                        string id = item.id;
                        if (string.IsNullOrEmpty(id))
                            continue;

                        string name = item.translation.title ?? "–æ—Ä–∏–≥–∏–Ω–∞–ª";
                        if (hash.Contains(name))
                            continue;

                        if (item.last_season != s)
                        {
                            if (item.seasons == null || !item.seasons.ContainsKey(s.ToString()))
                                continue;
                        }

                        hash.Add(name);

                        if (string.IsNullOrEmpty(kid))
                            kid = id;

                        string link = host + $"lite/kodik?rjson={rjson}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&clarification={clarification}&pick={enc_pick}&s={s}&kid={id}";

                        vtpl.Append(name, kid == id, link);
                    }
                    #endregion

                    var selected = results.FirstOrDefault(i => i.id == kid);
                    if (string.IsNullOrEmpty(selected.id))
                        selected = results[0];

                    var series = await ResolveEpisodesAsync(selected, s);
                    if (series == null || series.Count == 0)
                        return string.Empty;

                    var etpl = new EpisodeTpl(series.Count);

                    string sArhc = s.ToString();

                    foreach (var episode in series)
                    {
                        string url = host + $"lite/kodik/video?title={enc_title}&original_title={enc_original_title}&link={HttpUtility.UrlEncode(episode.Value)}&episode={episode.Key}";

                        string streamlink = null;
                        if (showstream)
                        {
                            streamlink = usehls ? $"{url.Replace("/video", $"/{videopath}.m3u8")}&play=true" : $"{url.Replace("/video", $"/{videopath}")}&play=true";

                            if (!string.IsNullOrEmpty(args))
                                streamlink += $"&{args.Remove(0, 1)}";
                        }

                        etpl.Append($"{episode.Key} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.Key, url, "call", streamlink: streamlink);
                    }

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                }
                #endregion
            }
        }
        #endregion


        #region VideoParse
        async public ValueTask<List<StreamModel>> VideoParse(string linkhost, string link)
        {
            string iframe = await onget($"https:{link}", null);
            if (iframe == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string uri = null;
            string player_single = Regex.Match(iframe, "src=\"/(assets/js/app\\.player_[^\"]+\\.js)\"").Groups[1].Value;
            if (!string.IsNullOrEmpty(player_single))
            {
                if (!psingles.TryGetValue(player_single, out uri))
                {
                    string playerjs = await onget($"{linkhost}/{player_single}", null);

                    if (playerjs == null)
                    {
                        requesterror?.Invoke();
                        return null;
                    }

                    uri = DecodeUrlBase64(Regex.Match(playerjs, "type:\"POST\",url:atob\\(\"([^\"]+)\"\\)").Groups[1].Value);
                    if (!string.IsNullOrEmpty(uri))
                        psingles.TryAdd(player_single, uri);
                }
            }

            if (string.IsNullOrEmpty(uri))
                return null;

            string _frame = Regex.Replace(iframe.Split("advertDebug")[1].Split("preview-icons")[0], "[\n\r\t ]+", "");
            string domain = Regex.Match(_frame, "domain=\"([^\"]+)\"").Groups[1].Value;
            string d_sign = Regex.Match(_frame, "d_sign=\"([^\"]+)\"").Groups[1].Value;
            string pd = Regex.Match(_frame, "pd=\"([^\"]+)\"").Groups[1].Value;
            string pd_sign = Regex.Match(_frame, "pd_sign=\"([^\"]+)\"").Groups[1].Value;
            string ref_domain = Regex.Match(_frame, "ref=\"([^\"]+)\"").Groups[1].Value;
            string ref_sign = Regex.Match(_frame, "ref_sign=\"([^\"]+)\"").Groups[1].Value;
            string type = Regex.Match(_frame, "videoInfo.type='([^']+)'").Groups[1].Value;
            string hash = Regex.Match(_frame, "videoInfo.hash='([^']+)'").Groups[1].Value;
            string id = Regex.Match(_frame, "videoInfo.id='([^']+)'").Groups[1].Value;

            string json = await onpost($"{linkhost + uri}", $"d={domain}&d_sign={d_sign}&pd={pd}&pd_sign={pd_sign}&ref={ref_domain}&ref_sign={ref_sign}&bad_user=false&cdn_is_working={cdn_is_working.ToString().ToLower()}&type={type}&hash={hash}&id={id}&info=%7B%7D");
            if (json == null || !json.Contains("\"src\":\""))
            {
                requesterror?.Invoke();
                return null;
            }

            var streams = new List<StreamModel>(4);

            var match = new Regex("\"([0-9]+)p?\":\\[\\{\"src\":\"([^\"]+)", RegexOptions.IgnoreCase).Match(json);
            while (match.Success)
            {
                if (!string.IsNullOrWhiteSpace(match.Groups[2].Value))
                {
                    string m3u = match.Groups[2].Value;
                    if (!m3u.Contains("manifest.m3u8"))
                    {
                        int zCharCode = Convert.ToInt32('Z');

                        string src = Regex.Replace(match.Groups[2].Value, "[a-zA-Z]", e =>
                        {
                            int eCharCode = Convert.ToInt32(e.Value[0]);
                            return ((eCharCode <= zCharCode ? 90 : 122) >= (eCharCode = eCharCode + 18) ? (char)eCharCode : (char)(eCharCode - 26)).ToString();
                        });

                        m3u = DecodeUrlBase64(src);
                    }

                    if (m3u.StartsWith("//"))
                        m3u = $"https:{m3u}";

                    if (!usehls && m3u.Contains(".m3u"))
                        m3u = m3u.Replace(":hls:manifest.m3u8", "");

                    streams.Add(new StreamModel() { q = $"{match.Groups[1].Value}p", url = m3u });
                }

                match = match.NextMatch();
            }

            if (streams.Count == 0)
                return null;

            streams.Reverse();

            return streams;
        }

        public string VideoParse(List<StreamModel> streams, string title, string original_title, int episode, bool play, VastConf vast = null)
        {
            if (streams == null || streams.Count == 0)
                return string.Empty;

            if (play)
                return onstreamfile(streams[0].url);

            string name = title ?? original_title ?? "auto";
            if (episode > 0)
                name += $" ({episode} —Å–µ—Ä–∏—è)";

            var streamquality = new StreamQualityTpl();
            foreach (var l in streams)
                streamquality.Append(onstreamfile(l.url), l.q);

            return VideoTpl.ToJson("play", onstreamfile(streams[0].url), name, streamquality: streamquality, vast: vast);
        }
        #endregion

        #region DecodeUrlBase64
        static string DecodeUrlBase64(string s)
        {
            return Encoding.UTF8.GetString(Convert.FromBase64String(s.Replace('-', '+').Replace('_', '/').PadRight(4 * ((s.Length + 3) / 4), '=')));
        }
        #endregion


        #region [Codex AI]
        List<Result> FallbackByIds(string imdb_id, long kinopoisk_id, int season)
        {
            var data = fallbackDatabase;
            if (data == null)
                return null;

            bool requireImdb = !string.IsNullOrEmpty(imdb_id);
            bool requireKinopoisk = kinopoisk_id > 0;

            var matches = data.Where(item =>
            {
                bool imdbMatch = !requireImdb || string.Equals(item.imdb_id, imdb_id, StringComparison.OrdinalIgnoreCase);
                bool kinopoiskMatch = !requireKinopoisk || item.kinopoisk_id == kinopoisk_id.ToString();
                return imdbMatch && kinopoiskMatch;
            }).ToList();

            if (matches.Count == 0)
                return null;

            return matches.Count == 0 ? null : matches;
        }

        List<Result> FallbackByTitle(string title, string originalTitle)
        {
            var data = fallbackDatabase;
            if (data == null)
                return null;

            bool hasTitle = !string.IsNullOrWhiteSpace(title);
            bool hasOriginal = !string.IsNullOrWhiteSpace(originalTitle);

            var strictMatches = new List<Result>();
            List<Result> fallbackMatches = (hasTitle || hasOriginal) ? new List<Result>() : null;

            foreach (var item in data)
            {
                bool titleMatch = !hasTitle || TitleMatches(item.title, title) || TitleMatches(item.title_orig, title);
                bool originalMatch = !hasOriginal || TitleMatches(item.title, originalTitle) || TitleMatches(item.title_orig, originalTitle);

                if (titleMatch && originalMatch)
                {
                    strictMatches.Add(item);
                    continue;
                }

                if (fallbackMatches == null)
                    continue;

                if (TitleMatches(item.title, title) ||
                    TitleMatches(item.title_orig, title) ||
                    TitleMatches(item.title, originalTitle) ||
                    TitleMatches(item.title_orig, originalTitle))
                {
                    fallbackMatches.Add(item);
                }
            }

            var matches = strictMatches.Count > 0 ? strictMatches : fallbackMatches;

            return matches == null || matches.Count == 0 ? null : matches;
        }

        static bool TitleMatches(string source, string target)
        {
            if (string.IsNullOrWhiteSpace(source) || string.IsNullOrWhiteSpace(target))
                return false;

            string normalizedSource = StringConvert.SearchName(source);
            string normalizedTarget = StringConvert.SearchName(target);

            if (string.IsNullOrWhiteSpace(normalizedSource) || string.IsNullOrWhiteSpace(normalizedTarget))
                return false;

            return normalizedSource.Contains(normalizedTarget);
        }

        async ValueTask<Dictionary<string, string>> ResolveEpisodesAsync(Result selected, int season)
        {
            if (season <= 0)
                return null;

            string seasonKey = season.ToString();

            if (selected.seasons != null &&
                selected.seasons.TryGetValue(seasonKey, out var seasonInfo) &&
                seasonInfo.episodes != null &&
                seasonInfo.episodes.Count > 0)
            {
                return seasonInfo.episodes;
            }

            var seasonsFromHtml = await LoadSeasonsFromHtml(selected);
            if (seasonsFromHtml != null &&
                seasonsFromHtml.TryGetValue(seasonKey, out seasonInfo) &&
                seasonInfo.episodes != null &&
                seasonInfo.episodes.Count > 0)
            {
                return seasonInfo.episodes;
            }

            return null;
        }

        async ValueTask<Dictionary<string, Season>> LoadSeasonsFromHtml(Result selected)
        {
            if (string.IsNullOrWhiteSpace(selected.id) || string.IsNullOrWhiteSpace(selected.link) || onget == null)
                return null;

            string cacheKey = $"kodik:series:{selected.id}";
            if (hybridCache.TryGetValue(cacheKey, out Dictionary<string, Season> cached))
                return cached;

            try
            {
                string html = await onget($"https:{selected.link}", null);
                if (string.IsNullOrWhiteSpace(html))
                {
                    requesterror?.Invoke();
                    return null;
                }

                var doc = new HtmlDocument();
                doc.LoadHtml(html);

                var optionsRoot = doc.DocumentNode.SelectSingleNode("//div[contains(@class,'series-options')]");
                if (optionsRoot == null)
                    return null;

                var seasons = new Dictionary<string, Season>();

                var seasonNodes = optionsRoot.SelectNodes(".//div[contains(@class,'season-')]");
                if (seasonNodes == null)
                    return null;

                foreach (var seasonNode in seasonNodes)
                {
                    string classes = seasonNode.GetAttributeValue("class", string.Empty);
                    var match = Regex.Match(classes, "season-([0-9]+)");
                    if (!match.Success)
                        continue;

                    string seasonKey = match.Groups[1].Value;
                    if (string.IsNullOrEmpty(seasonKey))
                        continue;

                    var options = seasonNode.SelectNodes(".//option");
                    if (options == null || options.Count == 0)
                        continue;

                    var episodes = new Dictionary<string, string>();

                    foreach (var option in options)
                    {
                        string episodeNumber = option.GetAttributeValue("value", null) ?? option.InnerText;
                        episodeNumber = episodeNumber?.Trim();
                        if (string.IsNullOrEmpty(episodeNumber))
                            continue;

                        string episodeLink = BuildEpisodeLink(option);
                        if (string.IsNullOrEmpty(episodeLink))
                            continue;

                        if (!episodes.ContainsKey(episodeNumber))
                            episodes[episodeNumber] = episodeLink;
                    }

                    if (episodes.Count > 0)
                    {
                        seasons[seasonKey] = new Season
                        {
                            link = selected.link,
                            episodes = episodes
                        };
                    }
                }

                if (seasons.Count == 0)
                    return null;

                hybridCache.Set(cacheKey, seasons, TimeSpan.FromMinutes(20));
                return seasons;
            }
            catch
            {
                return null;
            }
        }

        static string BuildEpisodeLink(HtmlNode option)
        {
            string dataId = option.GetAttributeValue("data-id", null);
            string dataHash = option.GetAttributeValue("data-hash", null);

            if (string.IsNullOrWhiteSpace(dataId) || string.IsNullOrWhiteSpace(dataHash))
                return null;

            return $"//kodik.info/seria/{dataId}/{dataHash}/720p";
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/AniLibria.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.AniLibria;
using Shared.Models.Templates;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct AniLibriaInvoke
    {
        #region AniLibriaInvoke
        string host;
        string apihost;
        Func<string, ValueTask<List<RootObject>>> onget;
        Func<string, string> onstreamfile;
        Action requesterror;

        public AniLibriaInvoke(string host, string apihost, Func<string, ValueTask<List<RootObject>>> onget, Func<string, string> onstreamfile, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        public async ValueTask<List<RootObject>> Embed(string title)
        {
            List<RootObject> search = await onget($"{apihost}/v2/searchTitles?search=" + HttpUtility.UrlEncode(title));
            if (search == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string stitle = StringConvert.SearchName(title);

            var result = new List<RootObject>(search.Count);

            foreach (var item in search)
            {
                if (item.names.ru != null && StringConvert.SearchName(item.names.ru).StartsWith(stitle))
                    result.Add(item);
                else if (item.names.en != null && StringConvert.SearchName(item.names.en).StartsWith(stitle))
                    result.Add(item);
            }

            if (result.Count == 0)
                return search;

            return result;
        }
        #endregion

        #region Html
        public string Html(List<RootObject> result, string title, string code, int year, bool rjson = false, VastConf vast = null, bool similar = false)
        {
            if (result == null || result.Count == 0)
                return string.Empty;

            string stitle = StringConvert.SearchName(title);

            if (!similar && (!string.IsNullOrEmpty(code) || (result.Count == 1 && result[0].season.year == year && (StringConvert.SearchName(result[0].names.ru) == stitle || StringConvert.SearchName(result[0].names.en) == stitle))))
            {
                #region –°–µ—Ä–∏–∏
                var root = string.IsNullOrEmpty(code) ? result[0] : result.Find(i => i.code == code);
                var episodes = root.player.playlist.Select(i => i.Value);

                var etpl = new EpisodeTpl(episodes.Count());

                foreach (var episode in episodes)
                {
                    var streamquality = new StreamQualityTpl();

                    foreach (var f in new List<(string quality, string url)> { ("1080p", episode.hls.fhd), ("720p", episode.hls.hd), ("480p", episode.hls.sd) })
                    {
                        if (string.IsNullOrWhiteSpace(f.url))
                            continue;

                        streamquality.Append(onstreamfile($"https://{root.player.host}{f.url}"), f.quality);
                    }

                    string season = StringConvert.SearchName(root.names.ru) == stitle || StringConvert.SearchName(root.names.en) == stitle ? "1" : "0";
                    if (season == "0")
                    {
                        season = Regex.Match(code ?? "", "-([0-9]+)(nd|th)").Groups[1].Value;
                        if (string.IsNullOrEmpty(season))
                        {
                            season = Regex.Match(code ?? "", "season-([0-9]+)").Groups[1].Value;
                            if (string.IsNullOrEmpty(season))
                                season = string.IsNullOrEmpty(code) ? "0" : "1";
                        }
                    }

                    etpl.Append($"{episode.serie} —Å–µ—Ä–∏—è", title, season, episode.serie.ToString(), streamquality.Firts().link, streamquality: streamquality, vast: vast);
                }

                return rjson ? etpl.ToJson() : etpl.ToHtml();
                #endregion
            }
            else
            {
                #region –ü–æ–∏—Å–∫
                var stpl = new SimilarTpl(result.Count);
                string enc_title = HttpUtility.UrlEncode(title);

                foreach (var root in result)
                {
                    string name = !string.IsNullOrEmpty(root.names.ru) && !string.IsNullOrEmpty(root.names.en) ? $"{root.names.ru} / {root.names.en}" : (root.names.ru ?? root.names.en);

                    string img = root.posters.original.url;
                    if (!string.IsNullOrEmpty(img))
                        img = "https://anilibria.tv" + img;

                    stpl.Append(name, root.season.year.ToString(), string.Empty, host + $"lite/anilibria?title={enc_title}&code={root.code}", PosterApi.Size(img));
                }

                return rjson ? stpl.ToJson() : stpl.ToHtml();
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Kinobase.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.Kinobase;
using Shared.Models.Online.Settings;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct KinobaseInvoke
    {
        #region KinobaseInvoke
        KinobaseSettings init;
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public KinobaseInvoke(string host, KinobaseSettings init, Func<string, ValueTask<string>> onget, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.init = init;
            this.host = host != null ? $"{host}/" : null;
            apihost = init.host;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
        }
        #endregion

        #region Search
        async public Task<SearchModel> Search(string title, int year)
        {
            if (string.IsNullOrEmpty(title))
                return null;

            string content = await onget($"{apihost}/search?query={HttpUtility.UrlEncode(title)}");
            if (content == null)
            {
                requesterror?.Invoke();
                return null;
            }

            var rows = content.Split("<li class=\"item\">");
            string link = null;

            var similar = new SimilarTpl(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                if (row.Contains(">–¢—Ä–µ–π–ª–µ—Ä</span>"))
                    continue;

                string name = Regex.Match(row, "<div class=\"title\"><[^>]+>([^<]+)").Groups[1].Value;
                string _year = Regex.Match(row, "<span class=\"year\">([0-9]+)").Groups[1].Value;
                string img = Regex.Match(row, "<img src=\"/([^\"]+)\"").Groups[1].Value;
                if (!string.IsNullOrEmpty(img))
                    img = $"{apihost}/{img}";

                string rlnk = Regex.Match(row, "href=\"/([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(rlnk) || string.IsNullOrEmpty(name))
                    continue;

                string uri = host + $"lite/kinobase?href={HttpUtility.UrlEncode(rlnk)}";
                similar.Append(name, _year, string.Empty, uri, PosterApi.Size(img));

                if (StringConvert.SearchName(name) == StringConvert.SearchName(title) && _year == year.ToString())
                {
                    if (string.IsNullOrEmpty(link))
                        link = rlnk;
                }
            }

            if (string.IsNullOrEmpty(link))
            {
                if (!content.Contains(">–ü–æ –∑–∞–ø—Ä–æ—Å—É") && similar.data.Count == 0)
                {
                    requesterror?.Invoke();
                    return null;
                }
            }

            return new SearchModel() 
            {
                link = link,
                similar = similar
            };
        }
        #endregion

        #region Embed
        async public Task<EmbedModel> Embed(string link, bool playerjs)
        {
            if (string.IsNullOrEmpty(link))
                return null;

            string news = await onget($"{apihost}/{link}");
            if (string.IsNullOrEmpty(news))
            {
                requesterror?.Invoke();
                return null;
            }

            if (playerjs)
            {
                try
                {
                    string video = Regex.Match(news, "id=\"playerjsfile\">([^<]+)<").Groups[1].Value;
                    if (string.IsNullOrEmpty(video))
                    {
                        if (news.Contains("<div class=\"alert\""))
                        {
                            var h3Match = Regex.Match(news, "<div class=\"alert\">\\s*<h3>([^<]+)</h3>");
                            return new EmbedModel() { IsEmpty = true, errormsg = h3Match.Success ? h3Match.Groups[1].Value.Trim() : "–û—à–∏–±–∫–∞ alert" };
                        }

                        return null;
                    }

                    if (video.EndsWith("]"))
                    {
                        var res = JsonSerializer.Deserialize<Season[]>(video);
                        if (res == null || res.Length == 0)
                            return null;

                        return new EmbedModel()
                        {
                            serial = res,
                            quality = (video.Contains("2160.") || video.Contains("2160_")) ? "2160p" : (video.Contains("1440.") || video.Contains("1440_")) ? "1440p" : (video.Contains("1080.") || video.Contains("1080_")) ? "1080p" : video.Contains("720.") ? "720p" : video.Contains("480.") ? "480p" : "360p"
                        };
                    }
                    else
                    {
                        return new EmbedModel() { content = video };
                    }
                }
                catch { return null; }
            }
            else
            {
                #region uppod.js
                if (news.Contains("id=\"playlists\""))
                {
                    try
                    {
                        string video = Regex.Match(news, "id=\"playlists\">([^<]+)<").Groups[1].Value;
                        if (string.IsNullOrEmpty(video))
                        {
                            requesterror?.Invoke();
                            return null;
                        }

                        var res = JsonSerializer.Deserialize<Season[]>(video);
                        if (res == null || res.Length == 0)
                            return null;

                        return new EmbedModel()
                        {
                            serial = res,
                            quality = video.Contains("1080.") ? "1080p" : video.Contains("720.") ? "720p" : video.Contains("480.") ? "480p" : "360p"
                        };
                    }
                    catch { return null; }
                }
                else
                {
                    string video = StringConvert.FindLastText(news, "id=\"videoplayer\"", "</div>");
                    if (string.IsNullOrEmpty(video))
                    {
                        requesterror?.Invoke();
                        return null;
                    }

                    return new EmbedModel() { content = video };
                }
                #endregion
            }
        }
        #endregion

        #region Html
        public string Html(EmbedModel md, string title, string href, int s, string t, bool rjson = false)
        {
            if (md == null || md.IsEmpty)
                return string.Empty;

            if (md.content != null)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title);

                if (init.playerjs)
                {
                    if (md.content.Contains("{"))
                    {
                        var voices = md.content.Split("{");
                        var hash = new HashSet<string>();

                        foreach (string line in voices)
                        {
                            string voice = Regex.Match(line, "([^\\}]+)\\}").Groups[1].Value.Trim();
                            if (!string.IsNullOrEmpty(voice) && !hash.Contains(voice))
                            {
                                hash.Add(voice);

                                var streamquality = new StreamQualityTpl();

                                foreach (string q in new string[] { "2160", "1440", "1080", "720", "480", "360" })
                                {
                                    foreach (var line2 in voices)
                                    {
                                        if (line2.Contains(voice) && (line2.Contains($"_{q}") || line2.Contains($"_{q}")))
                                        {
                                            string links = Regex.Match(line2, "\\}([^\\[,;]+)").Groups[1].Value;
                                            if (string.IsNullOrEmpty(links))
                                                continue;

                                            streamquality.Append(onstreamfile.Invoke(links), $"{q}p");
                                        }
                                    }
                                }
                                
                                mtpl.Append(voice, streamquality.Firts().link, streamquality: streamquality);
                            }
                        }
                    }
                    else
                    {
                        var streamquality = new StreamQualityTpl();

                        foreach (string q in new string[] { "2160", "1440", "1080", "720", "480", "360" })
                        {
                            string link = Regex.Match(md.content, $"\\[{q}p\\]([^\\[,; ]+)").Groups[1].Value;
                            if (string.IsNullOrEmpty(link))
                                continue;

                            streamquality.Append(onstreamfile.Invoke(link), $"{q}p");
                        }

                        mtpl.Append("–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é", streamquality.Firts().link, streamquality: streamquality);
                    }
                }
                else
                {
                    var streamquality = new StreamQualityTpl();

                    foreach (string q in new string[] { "1080", "720", "480", "360" })
                    {
                        string link = Regex.Match(md.content, $"(https?://[^\"\\[\\|,;\n\r\t ]+_{q}(_10)?.(mp4|m3u8))").Groups[1].Value;
                        if (string.IsNullOrEmpty(link))
                            continue;

                        streamquality.Append(onstreamfile.Invoke(link), $"{q}p");
                    }

                    var first = streamquality.Firts();
                    mtpl.Append(first.quality, first.link, streamquality: streamquality);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string sArhc = s.ToString();

                if (init.playerjs)
                {
                    if (md.serial.First().folder == null)
                    {
                        if (s == -1)
                        {
                            var tpl = new SeasonTpl(md.quality);
                            string link = host + $"lite/kinobase?title={enc_title}&href={HttpUtility.UrlEncode(href)}&t={HttpUtility.UrlEncode(t)}&s=1";
                            tpl.Append("1 —Å–µ–∑–æ–Ω", link, 1);

                            return rjson ? tpl.ToJson() : tpl.ToHtml();
                        }
                        else
                        {
                            return renderSeason(md.serial, host, onstreamfile);
                        }
                    }
                    else
                    {
                        if (s == -1)
                        {
                            var tpl = new SeasonTpl(md.quality);

                            foreach (var item in md.serial)
                            {
                                string season = Regex.Match(item.title.Trim(), "^([0-9]+)").Groups[1].Value;
                                string link = host + $"lite/kinobase?title={enc_title}&href={HttpUtility.UrlEncode(href)}&t={HttpUtility.UrlEncode(t)}&s={season}";
                                tpl.Append($"{season} —Å–µ–∑–æ–Ω", link, season);
                            }

                            return rjson ? tpl.ToJson() : tpl.ToHtml();
                        }
                        else
                        {
                            return renderSeason(md.serial.First(i => i.title.StartsWith($"{s} ")).folder, host, onstreamfile);
                        }
                    }

                    string renderSeason(Season[] episodes, string host, Func<string, string> onstreamfile)
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();

                        {
                            var hash_voices = new HashSet<string>();
                            var m = Regex.Match(episodes.First().file, "\\{([^\\}]+)");
                            while (m.Success)
                            {
                                string voice = m.Groups[1].Value.Trim();
                                if (!hash_voices.Contains(voice))
                                {
                                    hash_voices.Add(voice);

                                    if (string.IsNullOrEmpty(t))
                                        t = voice;

                                    string link = host + $"lite/kinobase?title={enc_title}&href={HttpUtility.UrlEncode(href)}&t={HttpUtility.UrlEncode(voice)}&s={s}";
                                    bool active = t == voice;

                                    vtpl.Append(voice, active, link);
                                }

                                m = m.NextMatch();
                            }
                        }
                        #endregion

                        var etpl = new EpisodeTpl(episodes.Length);

                        foreach (var episode in episodes)
                        {
                            if (string.IsNullOrEmpty(episode.file) || (t != null && !episode.file.Contains(t)))
                                continue;

                            var streamquality = new StreamQualityTpl();

                            foreach (string quality in new List<string> { "2160", "1440", "1080", "720", "480", "360" })
                            {
                                string qline = Regex.Match(episode.file, $"\\[{quality}p( [^\\]]+)?\\]([^\\[]+)").Groups[2].Value;
                                if (string.IsNullOrEmpty(qline))
                                    continue;

                                if (string.IsNullOrEmpty(t))
                                {
                                    string links = Regex.Match(qline, "({[^\\}]+})?([^\\}\\{\\[,;]+)").Groups[2].Value;
                                    if (string.IsNullOrEmpty(links))
                                        continue;

                                    streamquality.Append(onstreamfile.Invoke(links), $"{quality}p");
                                }
                                else
                                {
                                    string links = Regex.Match(qline, "{" + Regex.Escape(t) + "}" + "([^,;]+)").Groups[1].Value;
                                    if (string.IsNullOrEmpty(links))
                                        continue;

                                    streamquality.Append(onstreamfile.Invoke(links), $"{quality}p");
                                }
                            }

                            #region subtitle
                            var subtitles = new SubtitleTpl();

                            if (!string.IsNullOrEmpty(episode.subtitle))
                            {
                                var m = Regex.Match(episode.subtitle, "\\[([^\\]]+)\\]([^\t ]+)");
                                while (m.Success)
                                {
                                    subtitles.Append(m.Groups[1].Value, onstreamfile.Invoke(m.Groups[2].Value));

                                    m = m.NextMatch();
                                }
                            }
                            #endregion

                            etpl.Append(episode.title, title, sArhc, Regex.Match(episode.title, "^([0-9]+)").Groups[1].Value, streamquality.Firts().link, subtitles: subtitles, streamquality: streamquality);
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                }
                else
                {
                    #region uppod.js
                    string finEpisode(Season[] data, Func<string, string> onstreamfile)
                    {
                        var etpl = new EpisodeTpl(data.Length);

                        foreach (var episode in data)
                        {
                            if (string.IsNullOrEmpty(episode.file))
                                continue;

                            var streamquality = new StreamQualityTpl();

                            foreach (string quality in new List<string> { "1080", "720", "480", "360" })
                            {
                                string link = Regex.Match(episode.file, $"(https?://[^\"\\[\\|,;\n\r\t ]+_{quality}.(mp4|m3u8))").Groups[1].Value;
                                if (string.IsNullOrEmpty(link))
                                    continue;

                                streamquality.Append(onstreamfile.Invoke(link), $"{quality}p");
                            }

                            etpl.Append(episode.title, title, sArhc, Regex.Match(episode.title, "^([0-9]+)").Groups[1].Value, streamquality.Firts().link, streamquality: streamquality);
                        }

                        return rjson ? etpl.ToJson() : etpl.ToHtml();
                    }

                    if (md.serial.First().folder == null)
                    {
                        if (s == -1)
                        {
                            var tpl = new SeasonTpl(md.quality);
                            string link = host + $"lite/kinobase?title={enc_title}&href={HttpUtility.UrlEncode(href)}&s=1";
                            tpl.Append("1 —Å–µ–∑–æ–Ω", link, 1);

                            return rjson ? tpl.ToJson() : tpl.ToHtml();
                        }
                        else
                        {
                            return finEpisode(md.serial, onstreamfile);
                        }
                    }
                    else
                    {
                        if (s == -1)
                        {
                            var tpl = new SeasonTpl(md.quality);

                            foreach (var item in md.serial)
                            {
                                string season = Regex.Match(item.title.Trim(), "^([0-9]+)").Groups[1].Value;
                                string link = host + $"lite/kinobase?title={enc_title}&href={HttpUtility.UrlEncode(href)}&s={season}";
                                tpl.Append($"{season} —Å–µ–∑–æ–Ω", link, season);
                            }

                            return rjson ? tpl.ToJson() : tpl.ToHtml();
                        }
                        else
                        {
                            return finEpisode(md.serial.First(i => i.title.StartsWith($"{s} ")).folder, onstreamfile);
                        }
                    }
                    #endregion
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/VDBmovies.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.VDBmovies;
using Shared.Models.Templates;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct VDBmoviesInvoke
    {
        #region VDBmoviesInvoke
        string host;
        bool usehls;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;

        public VDBmoviesInvoke(string host, bool hls, Func<string, string> onstreamfile, Func<string, string> onlog = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            usehls = hls;
        }
        #endregion

        #region EvalCode
        public string EvalCode(in string file)
        {
            return @"(function () {
                    var enc = function enc(str) {
	                return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p1) {
	                    return String.fromCharCode('0x' + p1);
	                }));
                    };

                    var dec = function dec(str) {
	                return decodeURIComponent(atob(str).split('').map(function (c) {
	                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
	                }).join(''));
                    };

                    var trashList = ['wNp2wBTNcPRQvTC0_CpxCsq_8T1u9Q', 'md-Od2G9RWOgSa5HoBSSbWrCyIqQyY', 'kzuOYQqB_QSOL-xzN_Kz3kkgkHhHit', '6-xQWMh7ertLp8t_M9huUDk1M0VrYJ', 'RyTwtf15_GLEsXxnpU4Ljjd0ReY-VH'];
                    var x = '" + file + @"'.substring(2);
                    trashList.forEach(function (trash) {
	                x = x.replace('//' + enc(trash), '');
                    });

                    try {
	                x = dec(x);
                    } catch (e) {
	                x = '';
                    }

                    return x;
                })();
            ";
        }
        #endregion

        #region DecodeEval
        public string DecodeEval(in string file)
        {
            Func<string, string> enc = str =>
            {
                var bytes = Encoding.UTF8.GetBytes(str);
                return Convert.ToBase64String(bytes);
            };

            Func<string, string> dec = str =>
            {
                var bytes = Convert.FromBase64String(str);
                return Encoding.UTF8.GetString(bytes);
            };

            List<string> trashList = new List<string>
            {
                "wNp2wBTNcPRQvTC0_CpxCsq_8T1u9Q",
                "md-Od2G9RWOgSa5HoBSSbWrCyIqQyY",
                "kzuOYQqB_QSOL-xzN_Kz3kkgkHhHit",
                "6-xQWMh7ertLp8t_M9huUDk1M0VrYJ",
                "RyTwtf15_GLEsXxnpU4Ljjd0ReY-VH"
            };

            string x = file.Substring(2);

            foreach (var trash in trashList)
                x = x.Replace("//" + enc(trash), "");

            try
            {
                x = dec(x);
            }
            catch
            {
                x = string.Empty;
            }

            return x;
        }
        #endregion

        #region Embed
        public EmbedModel Embed(in string json)
        {
            if (string.IsNullOrEmpty(json))
                return null;

            string quality = json.Contains("1080p") ? "1080p" : json.Contains("720p") ? "720p" : json.Contains("480p") ? "480p" : "360p";

            try
            {
                if (json.Contains("\"folder\""))
                {
                    var serial = JsonSerializer.Deserialize<Models.Online.CDNmovies.Voice[]>(json);
                    if (serial == null || serial.Length == 0)
                        return null;

                    return new EmbedModel() { serial = serial, quality = quality };
                }
                else
                {
                    var movies = JsonSerializer.Deserialize<Episode[]>(json);
                    if (movies == null || movies.Length == 0)
                        return null;

                    return new EmbedModel() { movies = movies, quality = quality };
                }
            }
            catch { return null; }
        }
        #endregion

        #region Html
        public string Html(EmbedModel root, string orid, string imdb_id, long kinopoisk_id, string title, string original_title, string t, int s, int sid, VastConf vast = null, bool rjson = false)
        {
            if (root == null)
                return string.Empty;

            if (root.movies != null)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, root.movies.Length);

                foreach (var m in root.movies)
                {
                    #region subtitle
                    var subtitles = new SubtitleTpl();

                    if (!string.IsNullOrEmpty(m.subtitle))
                    {
                        var match = new Regex("\\[([^\\]]+)\\](https?://[^\\,]+)").Match(m.subtitle);
                        while (match.Success)
                        {
                            subtitles.Append(match.Groups[1].Value, match.Groups[2].Value);
                            match = match.NextMatch();
                        }
                    }
                    #endregion

                    if (string.IsNullOrEmpty(m.file))
                        continue;

                    var streamquality = new StreamQualityTpl();

                    foreach (Match mf in Regex.Matches(m.file, "\\[([^\\]]+)\\](https?://[^\\[\\|,\n\r\t ]+\\.m3u8)"))
                    {
                        string link = mf.Groups[2].Value;
                        if (!usehls)
                            link = link.Replace(":hls:manifest.m3u8", "");

                        streamquality.Insert(onstreamfile.Invoke(link), mf.Groups[1].Value);
                    }

                    mtpl.Append(m.title, streamquality.Firts().link, subtitles: subtitles, streamquality: streamquality, vast: vast);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                if (s == -1)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    var tpl = new SeasonTpl(root.quality, root.serial.Length);

                    for (int i = 0; i < root.serial.Length; i++)
                    {
                        string season = Regex.Match(root.serial[i].title, "^([0-9]+)").Groups[1].Value;
                        if (string.IsNullOrEmpty(season))
                            continue;

                        tpl.Append($"{season} —Å–µ–∑–æ–Ω", host + $"lite/vdbmovies?orid={orid}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&rjson={rjson}&title={enc_title}&original_title={enc_original_title}&s={season}&sid={i}", season);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∏
                    var vtpl = new VoiceTpl();
                    var etpl = new EpisodeTpl();

                    var hashvoices = new HashSet<string>();

                    string sArhc = s.ToString();

                    foreach (var episode in root.serial[sid].folder)
                    {
                        string ename = Regex.Match(episode.title, "^([0-9]+)").Groups[1].Value;

                        foreach (var voice in episode.folder)
                        {
                            string perevod = voice.title;
                            if (string.IsNullOrEmpty(t))
                                t = perevod;

                            if (!hashvoices.Contains(perevod))
                            {
                                hashvoices.Add(perevod);
                                vtpl.Append(perevod, t == perevod, host + $"lite/vdbmovies?orid={orid}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&rjson={rjson}&title={enc_title}&original_title={enc_original_title}&s={s}&sid={sid}&t={HttpUtility.UrlEncode(perevod)}");
                            }

                            if (perevod != t)
                                continue;

                            var streamquality = new StreamQualityTpl();

                            foreach (Match mf in Regex.Matches(voice.file, "\\[([^\\]]+)\\](https?://[^\\[\\|,\n\r\t ]+\\.m3u8)"))
                            {
                                string link = mf.Groups[2].Value;
                                if (!usehls)
                                    link = link.Replace(":hls:manifest.m3u8", "");

                                streamquality.Insert(onstreamfile.Invoke(link), mf.Groups[1].Value);
                            }

                            etpl.Append($"{ename} c–µ—Ä–∏—è", title ?? original_title, sArhc, ename, streamquality.Firts().link, streamquality: streamquality, vast: vast);
                        }
                    }

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                    #endregion
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Rezka.cs
```
Ôªøusing Shared.Models;
using Shared.Models.Base;
using Shared.Models.Online;
using Shared.Models.Online.Rezka;
using Shared.Models.Online.Settings;
using Shared.Models.Templates;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public class RezkaInvoke
    {
        #region RezkaInvoke
        RezkaSettings init;
        string host, scheme;
        string apihost;
        bool usehls, userprem, usereserve;
        Func<string, List<HeadersModel>, ValueTask<string>> onget;
        Func<string, string, List<HeadersModel>, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public string requestlog = string.Empty;

        static Dictionary<long, string> basereferer = new Dictionary<long, string>();

        void log(string msg)
        {
            return;
            requestlog += $"{msg}\n\n===========================================\n\n\n";
            onlog?.Invoke($"rezka: {msg}\n");
        }

        public RezkaInvoke(string host, RezkaSettings init, Func<string, List<HeadersModel>, ValueTask<string>> onget, Func<string, string, List<HeadersModel>, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.init = init;
            apihost = init.corsHost();
            scheme = init.scheme;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.onpost = onpost;
            usehls = init.hls;
            usereserve = init.reserve;
            userprem = init.premium;
            this.requesterror = requesterror;

            if (apihost.Contains("="))
            {
                char[] buffer = apihost.ToCharArray();
                for (int i = 0; i < buffer.Length; i++)
                {
                    char letter = buffer[i];
                    letter = (char)(letter - 3);
                    buffer[i] = letter;
                }

                apihost = new string(buffer);
            }
        }
        #endregion

        #region Search
        async public Task<SearchModel> Search(string title, string original_title, int clarification, int year)
        {
            var result = new SearchModel();
            string reservedlink = null;

            var base_headers = HeadersModel.Init(init.headers,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("cache-control", "no-cache"),
                ("dnt", "1"),
                ("pragma", "no-cache"),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-mode", "navigate"),
                ("sec-fetch-site", "same-origin"),
                ("sec-fetch-user", "?1"),
                ("upgrade-insecure-requests", "1")
            );

            result.search_uri = $"{apihost}/search/?do=search&subaction=search&q={HttpUtility.UrlEncode(clarification == 1 ? title : (original_title ?? title))}";

            string search = await onget(result.search_uri, HeadersModel.Join(base_headers, HeadersModel.Init(("referer", $"{apihost}/"))));
            if (search == null)
            {
                log("search error");
                requesterror?.Invoke();
                return null;
            }

            if (search.Contains("class=\"error-code\"") && search.ToLower().Contains("–æ—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞"))
            {
                if (search.Contains("(105)") || search.Contains(">105<") || search.Contains("(403)") || search.Contains(">403<"))
                    return new SearchModel() { IsEmpty = true, content = "–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ (105)<br>IP-–∞–¥—Ä–µ—Å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω<br><br>" };

                if (search.Contains("(101)") || search.Contains(">101<"))
                    return new SearchModel() { IsEmpty = true, content = "–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ (101)<br>–ê–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω<br><br>" };

                var accessError = Regex.Match(search, "–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞[ \t]+\\(([0-9]+)\\)", RegexOptions.IgnoreCase).Groups;
                return new SearchModel() { IsEmpty = true, content = $"–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ ({accessError[1].Value})" };
            }

            log("search OK");

            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            var rows = search.Split("\"b-content__inline_item\"");
            foreach (string row in rows.Skip(1))
            {
                var g = Regex.Match(row, "href=\"https?://[^/]+/([^\"]+)\">([^<]+)</a> ?<div>([0-9]{4})").Groups;

                if (string.IsNullOrEmpty(g[1].Value))
                    continue;

                string name = g[2].Value.Trim();
                if (string.IsNullOrEmpty(name))
                    continue;

                if (result.similar == null)
                    result.similar = new List<SimilarModel>(rows.Length);

                string img = Regex.Match(row, "<img src=\"([^\"]+)\"").Groups[1].Value;
                result.similar.Add(new SimilarModel(name, g[3].Value, g[1].Value, img));

                if ((stitle != null && (name.Contains(" / ") && StringConvert.SearchName(name).Contains(stitle) || StringConvert.SearchName(name) == stitle)) || 
                    (sorigtitle != null && (name.Contains(" / ") && StringConvert.SearchName(name).Contains(sorigtitle) || StringConvert.SearchName(name) == sorigtitle)))
                {
                    reservedlink = g[1].Value;

                    if (string.IsNullOrEmpty(result.href) && year > 0 && g[3].Value == year.ToString())
                        result.href = reservedlink;
                }
            }

            if (string.IsNullOrEmpty(result.href))
            {
                if (string.IsNullOrEmpty(reservedlink))
                {
                    if (result?.similar != null && result.similar.Count > 0)
                        return result;

                    if (search.Contains("–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞"))
                        return new SearchModel() { IsEmpty = true };

                    log("link null");
                    return null;
                }

                result.href = reservedlink;
            }

            return result;
        }
        #endregion

        #region Embed
        async public ValueTask<EmbedModel> Embed(string href, string search_uri)
        {
            if (!href.StartsWith("http"))
                href = $"{apihost}/{href}";

            var result = new EmbedModel();

            var base_headers = HeadersModel.Init(init.headers,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("cache-control", "no-cache"),
                ("dnt", "1"),
                ("pragma", "no-cache"),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-mode", "navigate"),
                ("sec-fetch-site", "same-origin"),
                ("sec-fetch-user", "?1"),
                ("upgrade-insecure-requests", "1")
            );

            result.id = Regex.Match(href, "/([0-9]+)-[^/]+\\.html").Groups[1].Value;
            if (long.TryParse(result.id, out long id) && id > 0)
                basereferer.TryAdd(id, href);

            if (!string.IsNullOrEmpty(search_uri))
                base_headers.Add(new HeadersModel("referer", search_uri));

            result.content = await onget(href, base_headers);
            if (result.content == null || string.IsNullOrEmpty(result.id))
            {
                if (result.content == null)
                    requesterror?.Invoke();

                log($"content {href}\nNullOrEmpty");
                return null;
            }

            log($"content {href}\nOK");
            return result;
        }
        #endregion

        #region EmbedID
        async public Task<EmbedModel> EmbedID(long kinopoisk_id, string imdb_id)
        {
            string search = await onpost($"{apihost}/engine/ajax/search.php", "q=%2B" + (!string.IsNullOrEmpty(imdb_id) ? imdb_id : kinopoisk_id.ToString()), null);
            if (search == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string link = null;
            var result = new EmbedModel();

            foreach (string row in search.Split("<li>").Skip(1))
            {
                string href = Regex.Match(row, "href=\"(https?://[^\"]+)\"").Groups[1].Value;
                string name = Regex.Match(row, "<span class=\"enty\">([^<]+)</span>").Groups[1].Value;
                string year = Regex.Match(row, ", ([0-9]{4})(\\)| -)").Groups[1].Value;

                if (string.IsNullOrEmpty(href) || string.IsNullOrEmpty(name))
                    continue;

                if (result.similar == null)
                    result.similar = new List<SimilarModel>();

                result.similar.Add(new SimilarModel(name, year, href, null));
                link = href;
            }

            if (result?.similar != null && result.similar.Count > 1)
                return result;

            if (string.IsNullOrEmpty(link))
            {
                if (search.Contains("b-search__section_title"))
                    return new EmbedModel() { IsEmpty = true };

                return null;
            }

            result!.id = Regex.Match(link, "/([0-9]+)-[^/]+\\.html").Groups[1].Value;
            result.content = await onget(link, null);
            if (result.content == null || string.IsNullOrEmpty(result.id))
            {
                if (result.content == null)
                    requesterror?.Invoke();

                return null;
            }

            return result;
        }
        #endregion

        #region Html
        public string Html(EmbedModel result, string args, string title, string original_title, int s, string href, bool showstream, bool rjson = false)
        {
            if (result == null || result.IsEmpty || result.content == null)
                return string.Empty;

            if (!string.IsNullOrEmpty(args))
                args = $"&{args.Remove(0, 1)}";

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);
            string enc_href = HttpUtility.UrlEncode(href);

            if (!result.content.Contains("data-season_id="))
            {
                #region –§–∏–ª—å–º
                var match = new Regex("<[^>]+ data-translator_id=\"([0-9]+)\"([^>]+)?>(?<voice>[^<]+)(<img title=\"(?<imgname>[^\"]+)\" [^>]+/>)?").Match(result.content);

                var mtpl = new MovieTpl(title, original_title, match.Length);

                if (match.Success)
                {
                    while (match.Success)
                    {
                        if (!string.IsNullOrEmpty(match.Groups[1].Value) && !string.IsNullOrEmpty(match.Groups["voice"].Value))
                        {
                            if (!userprem && match.Groups[0].Value.Contains("prem_translator"))
                            {
                                match = match.NextMatch();
                                continue;
                            }

                            string favs = Regex.Match(result.content, "id=\"ctrl_favs\" value=\"([^\"]+)\"").Groups[1].Value;
                            string link = host + $"lite/rezka/movie?title={enc_title}&original_title={enc_original_title}&id={result.id}&t={match.Groups[1].Value}&favs={favs}";

                            string voice_href = Regex.Match(match.Groups[0].Value, "href=\"(https?://[^/]+)?/([^\"]+)\"").Groups[2].Value;
                            if (!string.IsNullOrEmpty(voice_href))
                                link += $"&voice={HttpUtility.UrlEncode(voice_href)}";

                            #region voice
                            string voice = match.Groups["voice"].Value.Trim();

                            if (!string.IsNullOrEmpty(match.Groups["imgname"].Value) && !voice.ToLower().Contains(match.Groups["imgname"].Value.ToLower().Trim()))
                                voice += $" ({match.Groups["imgname"].Value.Trim()})";

                            if (voice == "-" || string.IsNullOrEmpty(voice))
                                voice = "–û—Ä–∏–≥–∏–Ω–∞–ª";
                            #endregion

                            if (match.Groups[2].Value.Contains("data-director=\"1\""))
                                link += "&director=1";

                            string stream = null;
                            if (showstream)
                            {
                                stream = usehls ? $"{link.Replace("/movie", "/movie.m3u8")}&play=true" : $"{link}&play=true";
                                stream += args;
                            }

                            mtpl.Append(voice, link, "call", stream);
                        }

                        match = match.NextMatch();
                    }
                }
                else
                {
                    var links = getStreamLink(Regex.Match(result.content, "\"id\":\"cdnplayer\",\"streams\":\"([^\"]+)\"").Groups[1].Value.Replace("\\", ""));
                    if (links.Count == 0)
                        return string.Empty;

                    var streamquality = new StreamQualityTpl(links.Select(l => (onstreamfile(l.stream_url!), l.title!)));
                    var first = streamquality.Firts();

                    mtpl.Append(first.quality, onstreamfile(first.link), streamquality: streamquality);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string trs = new Regex("\\.initCDNSeriesEvents\\([0-9]+, ([0-9]+),").Match(result.content).Groups[1].Value;
                if (string.IsNullOrWhiteSpace(trs))
                    return string.Empty;

                #region –ü–µ—Ä–µ–≤–æ–¥
                var vtpl = new VoiceTpl();

                if (result.content.Contains("data-translator_id="))
                {
                    var match = new Regex("<[a-z]+ [^>]+ data-translator_id=\"(?<translator>[0-9]+)\"([^>]+)?>(?<name>[^<]+)(<img title=\"(?<imgname>[^\"]+)\" [^>]+/>)?").Match(result.content);
                    while (match.Success)
                    {
                        if (!userprem && match.Groups[0].Value.Contains("prem_translator"))
                        {
                            match = match.NextMatch();
                            continue;
                        }

                        string name = match.Groups["name"].Value.Trim();
                        if (!string.IsNullOrEmpty(match.Groups["imgname"].Value) && !name.ToLower().Contains(match.Groups["imgname"].Value.ToLower().Trim()))
                            name += $" ({match.Groups["imgname"].Value})";

                        string link = host + $"lite/rezka/serial?rjson={rjson}&title={enc_title}&original_title={enc_original_title}&href={enc_href}&id={result.id}&t={match.Groups["translator"].Value}";

                        string voice_href = Regex.Match(match.Groups[0].Value, "href=\"(https?://[^/]+)?/([^\"]+)\"").Groups[2].Value;
                        if (!string.IsNullOrEmpty(voice_href) && init.ajax != null && init.ajax.Value == false)
                        {
                            string voice = HttpUtility.UrlEncode(voice_href);
                            link = host + $"lite/rezka?rjson={rjson}&title={enc_title}&original_title={enc_original_title}&href={voice}&id={result.id}&t={match.Groups["translator"].Value}";
                        }

                        vtpl.Append(name, match.Groups["translator"].Value == trs, link);

                        match = match.NextMatch();
                    }
                }
                #endregion

                var tpl = new SeasonTpl();
                var etpl = new EpisodeTpl();
                HashSet<string> eshash = new HashSet<string>();

                string sArhc = s.ToString();

                var m = Regex.Match(result.content, "data-cdn_url=\"(?<cdn>[^\"]+)\" [^>]+ data-season_id=\"(?<season>[0-9]+)\" data-episode_id=\"(?<episode>[0-9]+)\"([^>]+)?>(?<name>[^>]+)</[a-z]+>");
                while (m.Success)
                {
                    if (s == -1)
                    {
                        #region –°–µ–∑–æ–Ω—ã
                        string sname = $"{m.Groups["season"].Value} —Å–µ–∑–æ–Ω";
                        if (!string.IsNullOrEmpty(m.Groups["season"].Value) && !eshash.Contains(sname))
                        {
                            eshash.Add(sname);
                            string link = host + $"lite/rezka?rjson={rjson}&title={enc_title}&original_title={enc_original_title}&href={enc_href}&t={trs}&s={m.Groups["season"].Value}";

                            tpl.Append(sname, link, m.Groups["season"].Value);
                        }
                        #endregion
                    }
                    else
                    {
                        #region –°–µ—Ä–∏–∏
                        if (m.Groups["season"].Value == s.ToString() && !eshash.Contains(m.Groups["name"].Value))
                        {
                            eshash.Add(m.Groups["name"].Value);
                            string link = host + $"lite/rezka/movie?title={enc_title}&original_title={enc_original_title}&id={result.id}&t={trs}&s={s}&e={m.Groups["episode"].Value}";

                            string voice_href = Regex.Match(m.Groups[0].Value, "href=\"(https?://[^/]+)?/([^\"]+)\"").Groups[2].Value;
                            if (!string.IsNullOrEmpty(voice_href))
                                link += $"&voice={HttpUtility.UrlEncode(voice_href)}";

                            string stream = null;
                            if (showstream)
                            {
                                stream = usehls ? $"{link.Replace("/movie", "/movie.m3u8")}&play=true" : $"{link}&play=true";
                                stream += args;
                            }

                            etpl.Append(m.Groups["name"].Value, title ?? original_title, sArhc, m.Groups["episode"].Value, link, "call", streamlink: stream);
                        }
                        #endregion
                    }

                    m = m.NextMatch();
                }

                if (rjson)
                    return s == -1 ? tpl.ToJson(vtpl) : etpl.ToJson(vtpl);

                if (s == -1)
                    return vtpl.ToHtml() + tpl.ToHtml();

                return vtpl.ToHtml() + etpl.ToHtml();
                #endregion
            }
        }
        #endregion


        #region Serial
        async public ValueTask<Episodes> SerialEmbed(long id, int t)
        {
            string uri = $"{apihost}/ajax/get_cdn_series/?t={((DateTimeOffset)DateTime.Now).ToUnixTimeSeconds()}{Random.Shared.Next(101, 999)}";
            string data = $"id={id}&translator_id={t}&action=get_episodes";

            Episodes root = null;

            try
            {
                var headers = HeadersModel.Init(init.headers,
                    ("accept", "application/json, text/javascript, */*; q=0.01"),
                    ("cache-control", "no-cache"),
                    ("dnt", "1"),
                    ("origin", apihost),
                    ("pragma", "no-cache"),
                    ("sec-fetch-dest", "empty"),
                    ("sec-fetch-mode", "cors"),
                    ("sec-fetch-site", "same-origin"),
                    ("x-requested-with", "XMLHttpRequest")
                );

                if (basereferer.TryGetValue(id, out string referer) && !string.IsNullOrEmpty(referer))
                    headers = HeadersModel.Join(headers, HeadersModel.Init(("referer", referer)));

                string json = await onpost(uri, data, headers);
                if (json == null)
                {
                    log("json null");
                    requesterror?.Invoke();
                    return null;
                }

                root = JsonSerializer.Deserialize<Episodes>(json);
            }
            catch { }

            if (root == null)
            {
                log("root null");
                return null;
            }

            log("root OK");

            string episodes = root.episodes;
            if (string.IsNullOrWhiteSpace(episodes) || episodes.ToLower() == "false")
            {
                log("episodes null");
                return null;
            }

            return root;
        }

        public string Serial(Episodes root, EmbedModel result, string args, string title, string original_title, string href, long id, int t, int s, bool showstream, bool rjson = false)
        {
            if (root == null || result == null)
                return string.Empty;

            if (!string.IsNullOrEmpty(args))
                args = $"&{args.Remove(0, 1)}";

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);
            string enc_href = HttpUtility.UrlEncode(href);

            #region –ü–µ—Ä–µ–≤–æ–¥
            var vtpl = new VoiceTpl();

            {
                if (string.IsNullOrWhiteSpace(href))
                    return string.Empty;

                if (result?.content != null)
                {
                    if (result.content.Contains("data-translator_id="))
                    {
                        var match = new Regex("<[a-z]+ [^>]+ data-translator_id=\"(?<translator>[0-9]+)\"([^>]+)?>(?<name>[^<]+)(<img title=\"(?<imgname>[^\"]+)\" [^>]+/>)?").Match(result.content);
                        while (match.Success)
                        {
                            if (!userprem && match.Groups[0].Value.Contains("prem_translator"))
                            {
                                match = match.NextMatch();
                                continue;
                            }

                            string name = match.Groups["name"].Value.Trim() + (string.IsNullOrWhiteSpace(match.Groups["imgname"].Value) ? "" : $" ({match.Groups["imgname"].Value})");
                            string link = host + $"lite/rezka/serial?rjson={rjson}&title={enc_title}&original_title={enc_original_title}&href={enc_href}&id={id}&t={match.Groups["translator"].Value}";

                            vtpl.Append(name, match.Groups["translator"].Value == t.ToString(), link);

                            match = match.NextMatch();
                        }
                    }
                }
            }
            #endregion

            if (s == -1)
            {
                #region –°–µ–∑–æ–Ω—ã
                var tpl = new SeasonTpl(root.seasons.Length);

                var match = new Regex("data-tab_id=\"(?<season>[0-9]+)\"([^>]+)?>(?<name>[^<]+)</[a-z]+>").Match(root.seasons);
                while (match.Success)
                {
                    string link = host + $"lite/rezka/serial?rjson={rjson}&title={enc_title}&original_title={enc_original_title}&href={enc_href}&id={id}&t={t}&s={match.Groups["season"].Value}";

                    tpl.Append($"{match.Groups["season"].Value} —Å–µ–∑–æ–Ω", link, match.Groups["season"].Value);

                    match = match.NextMatch();
                }

                return rjson ? tpl.ToJson(vtpl) : tpl.ToHtml(vtpl);
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∏
                var etpl = new EpisodeTpl();

                string sArhc = s.ToString();

                var m = new Regex($"data-season_id=\"{s}\" data-episode_id=\"(?<episode>[0-9]+)\"([^>]+)?>(?<name>[^<]+)</li>").Match(root.episodes);
                while (m.Success)
                {
                    if (!string.IsNullOrEmpty(m.Groups["episode"].Value) && !string.IsNullOrEmpty(m.Groups["name"].Value))
                    {
                        string link = host + $"lite/rezka/movie?title={enc_title}&original_title={enc_original_title}&id={id}&t={t}&s={s}&e={m.Groups["episode"].Value}";

                        string voice_href = Regex.Match(m.Groups[0].Value, "href=\"(https?://[^/]+)?/([^\"]+)\"").Groups[2].Value;
                        if (!string.IsNullOrEmpty(voice_href))
                            link += $"&voice={HttpUtility.UrlEncode(voice_href)}";

                        string stream = usehls ? $"{link.Replace("/movie", "/movie.m3u8")}&play=true" : $"{link}&play=true";

                        etpl.Append(m.Groups["name"].Value, title ?? original_title, sArhc, m.Groups["episode"].Value, link, "call", streamlink: (showstream ? $"{stream}{args}" : null));
                    }

                    m = m.NextMatch();
                }

                if (rjson)
                    return etpl.ToJson(vtpl);

                return vtpl.ToHtml() + etpl.ToHtml();
                #endregion
            }
        }
        #endregion

        #region Movie
        async public ValueTask<MovieModel> Movie(long id, int t, int director, int s, int e, string favs)
        {
            string data = null;
            string uri = $"{apihost}/ajax/get_cdn_series/?t={((DateTimeOffset)DateTime.Now).ToUnixTimeSeconds()}{Random.Shared.Next(101, 999)}";

            if (s == -1)
            {
                data = $"id={id}&translator_id={t}&is_camrip=0&is_ads=0&is_director={director}&favs={favs}&action=get_movie";
            }
            else
            {
                data = $"id={id}&translator_id={t}&season={s}&episode={e}&favs={favs}&action=get_stream";
            }

            var headers = HeadersModel.Init(init.headers,
                ("accept", "application/json, text/javascript, */*; q=0.01"),
                ("cache-control", "no-cache"),
                ("dnt", "1"),
                ("origin", apihost),
                ("pragma", "no-cache"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "same-origin"),
                ("x-requested-with", "XMLHttpRequest")
            );

            if (basereferer.TryGetValue(id, out string referer) && !string.IsNullOrEmpty(referer))
                headers = HeadersModel.Join(headers, HeadersModel.Init(("referer", referer)));

            string json = await onpost(uri, data, headers);
            if (string.IsNullOrEmpty(json))
            {
                log("json null");
                requesterror?.Invoke();
                return null;
            }

            log("json OK");

            Dictionary<string, object> root = null;

            try
            {
                root = JsonSerializer.Deserialize<Dictionary<string, object>>(json);
            }
            catch
            {
                log("Deserialize error");
                requesterror?.Invoke();
                return null;
            }

            string url = root.ContainsKey("url") ? root["url"]?.ToString() : null;
            if (string.IsNullOrEmpty(url) || url.ToLower() == "false")
            {
                log("url null");
                requesterror?.Invoke();
                return null;
            }

            var links = getStreamLink(url);
            if (links.Count == 0)
            {
                log("links null");
                return null;
            }

            string subtitlehtml = null;

            try
            {
                subtitlehtml = root?["subtitle"]?.ToString();
            }
            catch { }

            return new MovieModel() { links = links, subtitlehtml = subtitlehtml };
        }

        async public ValueTask<MovieModel> Movie(string href)
        {
            var headers = HeadersModel.Init(init.headers,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("cache-control", "no-cache"),
                ("dnt", "1"),
                ("pragma", "no-cache"),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-mode", "navigate"),
                ("sec-fetch-site", "same-origin"),
                ("sec-fetch-user", "?1"),
                ("upgrade-insecure-requests", "1")
            );

            string html = await onget($"{apihost}/{href}", headers);
            if (string.IsNullOrEmpty(html))
            {
                requesterror?.Invoke();
                return null;
            }

            string url = Regex.Match(html, "\"streams\"\\s*:\\s*\"(.*?)\"\\s*,").Groups[1].Value;
            if (string.IsNullOrEmpty(url) || url.ToLower() == "false")
            {
                requesterror?.Invoke();
                return null;
            }

            var links = getStreamLink(url.Replace("\\", ""));
            if (links.Count == 0)
                return null;

            return new MovieModel() 
            { 
                links = links,
                subtitlehtml = Regex.Match(html, "\"subtitle\":\"([^\"]+)\"").Groups[1].Value 
            };
        }

        public string Movie(MovieModel md, string title, string original_title, bool play, VastConf vast = null)
        {
            if (play)
                return onstreamfile(md.links[0].stream_url!);

            #region subtitles
            var subtitles = new SubtitleTpl();

            try
            {
                if (!string.IsNullOrWhiteSpace(md.subtitlehtml))
                {
                    var m = Regex.Match(md.subtitlehtml, "\\[([^\\]]+)\\](https?://[^\n\r,']+\\.vtt)");
                    while (m.Success)
                    {
                        if (!string.IsNullOrEmpty(m.Groups[1].Value) && !string.IsNullOrEmpty(m.Groups[2].Value))
                            subtitles.Append(m.Groups[1].Value, onstreamfile(m.Groups[2].Value));

                        m = m.NextMatch();
                    }
                }
            }
            catch { }
            #endregion

            var streamquality = new StreamQualityTpl();
            foreach (var l in md.links)
                streamquality.Append(onstreamfile(l.stream_url!), l.title);

            return VideoTpl.ToJson("play", onstreamfile(md.links[0].stream_url!), (title ?? original_title ?? "auto"), 
                streamquality: streamquality, 
                subtitles: subtitles, 
                vast: vast, 
                hls_manifest_timeout: (int)TimeSpan.FromSeconds(20).TotalMilliseconds
            );
        }
        #endregion


        #region decodeBase64
        static string decodeBase64(in string data)
        {
            if (data.StartsWith("#"))
            {
                try
                {
                    string[] trashList = ["JCQhIUAkJEBeIUAjJCRA", "QEBAQEAhIyMhXl5e", "IyMjI14hISMjIUBA", "Xl5eIUAjIyEhIyM=", "JCQjISFAIyFAIyM="];

                    string _data = data.Remove(0, 2);

                    foreach (string trash in trashList)
                        _data = _data.Replace($"//_//{trash}", "");

                    try
                    {
                        return Encoding.UTF8.GetString(Convert.FromBase64String(_data));
                    }
                    catch
                    {
                        _data = Regex.Replace(_data, "//[^/]+_//", "").Replace("//_//", "");
                        _data = Encoding.UTF8.GetString(Convert.FromBase64String(_data));

                        return _data;
                    }
                }
                catch
                {
                    string[] trashList = ["QEA=", "QCM=", "QCE=", "QF4=", "QCQ=", "I0A=", "IyM=", "IyE=", "I14=", "IyQ=", "IUA=", "ISM=", "ISE=", "IV4=", "ISQ=", "XkA=", "XiM=", "XiE=", "Xl4=", "XiQ=", "JEA=", "JCM=", "JCE=", "JF4=", "JCQ=", "QEBA", "QEAj", "QEAh", "QEBe", "QEAk", "QCNA", "QCMj", "QCMh", "QCNe", "QCMk", "QCFA", "QCEj", "QCEh", "QCFe", "QCEk", "QF5A", "QF4j", "QF4h", "QF5e", "QF4k", "QCRA", "QCQj", "QCQh", "QCRe", "QCQk", "I0BA", "I0Aj", "I0Ah", "I0Be", "I0Ak", "IyNA", "IyMj", "IyMh", "IyNe", "IyMk", "IyFA", "IyEj", "IyEh", "IyFe", "IyEk", "I15A", "I14j", "I14h", "I15e", "I14k", "IyRA", "IyQj", "IyQh", "IyRe", "IyQk", "IUBA", "IUAj", "IUAh", "IUBe", "IUAk", "ISNA", "ISMj", "ISMh", "ISNe", "ISMk", "ISFA", "ISEj", "ISEh", "ISFe", "ISEk", "IV5A", "IV4j", "IV4h", "IV5e", "IV4k", "ISRA", "ISQj", "ISQh", "ISRe", "ISQk", "XkBA", "XkAj", "XkAh", "XkBe", "XkAk", "XiNA", "XiMj", "XiMh", "XiNe", "XiMk", "XiFA", "XiEj", "XiEh", "XiFe", "XiEk", "Xl5A", "Xl4j", "Xl4h", "Xl5e", "Xl4k", "XiRA", "XiQj", "XiQh", "XiRe", "XiQk", "JEBA", "JEAj", "JEAh", "JEBe", "JEAk", "JCNA", "JCMj", "JCMh", "JCNe", "JCMk", "JCFA", "JCEj", "JCEh", "JCFe", "JCEk", "JF5A", "JF4j", "JF4h", "JF5e", "JF4k", "JCRA", "JCQj", "JCQh", "JCRe", "JCQk"];

                    string _data = data.Remove(0, 2).Replace("//_//", "");

                    foreach (string trash in trashList)
                        _data = _data.Replace(trash, "");

                    _data = Regex.Replace(_data, "//[^/]+_//", "").Replace("//_//", "");
                    _data = Encoding.UTF8.GetString(Convert.FromBase64String(_data));

                    return _data;
                }
            }

            return data;
        }
        #endregion

        #region getStreamLink
        List<ApiModel> getStreamLink(in string _data)
        {
            string data = decodeBase64(_data);
            var links = new List<ApiModel>(6);

            #region getLink
            string getLink(string _q)
            {
                string qline = Regex.Match(data, $"\\[({_q}|[^\\]]+{_q}[^\\]]+)\\]([^,\\[]+)").Groups[2].Value;
                if (!qline.Contains(".mp4") && !qline.Contains(".m3u8"))
                    return null;

                if (usereserve && qline.Contains(" or "))
                {
                    return string.Join(" or ", qline.Split(" or ").Select(i =>
                    {
                        string l = Regex.Match(i, "(https?://[^\\[\n\r, ]+)").Groups[1].Value;
                        if (usehls)
                        {
                            if (l.EndsWith(".m3u8"))
                                return l;

                            return l + ":hls:manifest.m3u8";
                        }

                        return l.Replace(":hls:manifest.m3u8", "");
                    }));
                }
                else
                {
                    string link = Regex.Match(qline, "(https?://[^\\[\n\r, ]+)").Groups[1].Value;
                    if (string.IsNullOrEmpty(link))
                        return null;

                    if (usehls)
                    {
                        if (link.EndsWith(".m3u8"))
                            return link;

                        return link + ":hls:manifest.m3u8";
                    }

                    return link.Replace(":hls:manifest.m3u8", "");
                }
            }
            #endregion

            #region –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ—Å—Ç—É–ø–Ω–æ–µ
            var qualities = new List<string> { "2160p", "1440p", "1080p", "720p", "480p" };
            if (userprem)
                qualities.InsertRange(2, new List<string> { "1080p Ultra" });

            foreach (string q in qualities)
            {
                string link = null;

                switch (q)
                {
                    case "2160p":
                        link = getLink("4K") ?? getLink(q);
                        break;
                    case "1440p":
                        link = getLink("2K") ?? getLink(q);
                        break;
                    case "1080p":
                        link = userprem ? getLink(q) : (getLink(q) ?? getLink("1080p Ultra"));
                        break;
                    default:
                        link = getLink(q);
                        break;
                }

                if (string.IsNullOrEmpty(link))
                    continue;

                if (scheme == "http")
                    link = link.Replace("https:", "http:");

                string realq = q;

                switch (q)
                {
                    case "1080p Ultra":
                        realq = "1080p";
                        break;
                    case "1080p":
                        realq = "720p";
                        break;
                    case "720p":
                        realq = "480p";
                        break;
                    case "480p":
                        realq = "360p";
                        break;
                }

                links.Add(new ApiModel()
                {
                    title = realq,
                    stream_url = link
                });
            }
            #endregion

            return links;
        }
        #endregion


        #region fixcdn
        public static string fixcdn(string country, string uacdn, string link)
        {
            if (uacdn != null && country == "UA" && !link.Contains(".vtt"))
                return Regex.Replace(link, "https?://[^/]+", uacdn);

            return link;
        }
        #endregion

        #region StreamProxyHeaders
        public static List<HeadersModel> StreamProxyHeaders(RezkaSettings init) => HeadersModel.Init(init.headers,
            ("accept", "*/*"),
            ("cache-control", "no-cache"),
            ("dnt", "1"),
            ("origin", init.host),
            ("pragma", "no-cache"),
            ("referer", $"{init.host}/"),
            ("sec-fetch-dest", "empty"),
            ("sec-fetch-mode", "cors"),
            ("sec-fetch-site", "cross-site")
        );
        #endregion
    }
}

```

## File: JacRed/ApiController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Jackett;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;

namespace JacRed.Controllers
{
    public class ApiController : JacBaseController
    {
        #region Conf
        [Route("api/v1.0/conf")]
        public JsonResult JacConf(string apikey)
        {
            return Json(new
            {
                apikey = string.IsNullOrWhiteSpace(AppInit.conf.apikey) || apikey == AppInit.conf.apikey
            });
        }
        #endregion

        #region Indexers
        [Route("/api/v2.0/indexers/{status}/results")]
        async public Task<ActionResult> Indexers(string apikey, string query, string title, string title_original, int year, Dictionary<string, string> category, int is_serial = -1)
        {
            if (string.IsNullOrEmpty(ModInit.conf.typesearch))
                return Content("typesearch == null");

            #region –ó–∞–ø—Ä–æ—Å —Å NUM
            bool rqnum = !HttpContext.Request.QueryString.Value.Contains("&is_serial=") && HttpContext.Request.Headers.UserAgent.ToString() == "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36";

            if (rqnum && query != null)
            {
                var mNum = Regex.Match(query, "^([^a-z-A-Z]+) ([^–∞-—è-–ê-–Ø]+) ([0-9]{4})$");

                if (mNum.Success)
                {
                    if (Regex.IsMatch(mNum.Groups[2].Value, "[a-zA-Z0-9]{2}"))
                    {
                        var g = mNum.Groups;
                        title = g[1].Value;
                        title_original = g[2].Value;
                        year = int.Parse(g[3].Value);
                    }
                }
                else
                {
                    if (Regex.IsMatch(query, "^([^a-z-A-Z]+) ((19|20)[0-9]{2})$"))
                        return Content(JsonConvert.SerializeObject(new { Results = new List<object>(), jacred = ModInit.conf.typesearch == "red" }), "application/json; charset=utf-8");

                    mNum = Regex.Match(query, "^([^a-z-A-Z]+) ([^–∞-—è-–ê-–Ø]+)$");

                    if (mNum.Success)
                    {
                        if (Regex.IsMatch(mNum.Groups[2].Value, "[a-zA-Z0-9]{2}"))
                        {
                            var g = mNum.Groups;
                            title = g[1].Value;
                            title_original = g[2].Value;
                        }
                    }
                }
            }
            #endregion

            if (!HttpContext.Request.QueryString.Value.ToLower().Contains("&category[]="))
                category = null;

            IEnumerable<TorrentDetails> torrents = null;

            if (ModInit.conf.typesearch == "red")
            {
                #region red
                string memoryKey = $"{ModInit.conf.typesearch}:{query}:{rqnum}:{title}:{title_original}:{year}:{is_serial}";
                if (!hybridCache.TryGetValue(memoryKey, out List<TorrentDetails> _redCache, inmemory: false))
                {
                    var res = RedApi.Indexers(rqnum, apikey, query, title, title_original, year, is_serial, category);

                    _redCache = res.torrents.ToList();

                    if (res.setcache && !red.evercache.enable)
                        hybridCache.Set(memoryKey, _redCache, DateTime.Now.AddMinutes(5), inmemory: false);
                }

                if (ModInit.conf.merge == "jackett")
                {
                    torrents = mergeTorrents
                    (
                        _redCache,
                        await JackettApi.Indexers(host, query, title, title_original, year, is_serial, category)
                    );
                }
                else
                { 
                    torrents = _redCache;
                }
                #endregion
            }
            else if (ModInit.conf.typesearch == "webapi")
            {
                #region webapi
                if (ModInit.conf.merge == "jackett")
                {
                    var t1 = WebApi.Indexers(query, title, title_original, year, is_serial, category);
                    var t2 = JackettApi.Indexers(host, query, title, title_original, year, is_serial, category);

                    await Task.WhenAll(t1, t2);

                    torrents = mergeTorrents(t1.Result, t2.Result);
                }
                else
                {
                    torrents = await WebApi.Indexers(query, title, title_original, year, is_serial, category);
                }
                #endregion
            }
            else if (ModInit.conf.typesearch == "jackett")
            {
                torrents = await JackettApi.Indexers(host, query, title, title_original, year, is_serial, category);
            }

            return Content(JsonConvert.SerializeObject(new
            {
                Results = torrents.OrderByDescending(i => i.createTime).Take(2_000).Select(i => new
                {
                    Tracker = i.trackerName,
                    Details = i.url != null && i.url.StartsWith("http") ? i.url : null,
                    Title = i.title,
                    Size = (long)(0 >= i.size ? getSizeInfo(i.sizeName) : i.size),
                    PublishDate = i.createTime,
                    Category = getCategoryIds(i, out string categoryDesc),
                    CategoryDesc = categoryDesc,
                    Seeders = i.sid,
                    Peers = i.pir,
                    MagnetUri = i.magnet,
                    Link = i.parselink != null ? $"{i.parselink}&apikey={apikey}" : null,
                    Info = ModInit.conf.typesearch != "red" || rqnum ? null : new
                    {
                        i.name,
                        i.originalname,
                        i.relased,
                        i.quality,
                        i.videotype,
                        i.sizeName,
                        i.voices,
                        seasons = i.seasons != null && i.seasons.Count > 0 ? i.seasons : null,
                        i.types
                    },
                    languages = !rqnum && i.languages != null && i.languages.Count > 0 ? i.languages : null,
                    ffprobe = rqnum ? null : i.ffprobe
                }),
                jacred = ModInit.conf.typesearch == "red"

            }, new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }), "application/json; charset=utf-8");
        }
        #endregion

        #region Api
        [Route("/api/v1.0/torrents")]
        async public Task<ActionResult> Api(string apikey, string search, string altname, bool exact, string type, string sort, string tracker, string voice, string videotype, long relased, long quality, long season)
        {
            if (string.IsNullOrEmpty(ModInit.conf.typesearch))
                return Content("typesearch == null");

            #region search kp/imdb
            if (!string.IsNullOrWhiteSpace(search) && Regex.IsMatch(search.Trim(), "^(tt|kp)[0-9]+$"))
            {
                string memkey = $"api/v1.0/torrents:{search}";
                if (!hybridCache.TryGetValue(memkey, out (string original_name, string name) cache, inmemory: false))
                {
                    search = search.Trim();
                    string uri = $"&imdb={search}";
                    if (search.StartsWith("kp"))
                        uri = $"&kp={search.Remove(0, 2)}";

                    var root = await Http.Get<JObject>("https://api.alloha.tv/?token=04941a9a3ca3ac16e2b4327347bbc1" + uri, timeoutSeconds: 10);
                    cache.original_name = root?.Value<JObject>("data")?.Value<string>("original_name");
                    cache.name = root?.Value<JObject>("data")?.Value<string>("name");

                    hybridCache.Set(memkey, cache, DateTime.Now.AddDays(1), inmemory: false);
                }

                if (!string.IsNullOrWhiteSpace(cache.name) && !string.IsNullOrWhiteSpace(cache.original_name))
                {
                    search = cache.original_name;
                    altname = cache.name;
                }
                else
                {
                    search = cache.original_name ?? cache.name;
                }
            }
            #endregion

            IEnumerable<TorrentDetails> torrents = null;

            if (ModInit.conf.typesearch == "red")
            {
                #region red
                torrents = RedApi.Api(search, altname, exact, type, sort, tracker, voice, videotype, relased, quality, season);

                if (ModInit.conf.merge == "jackett")
                {
                    torrents = mergeTorrents
                    (
                        torrents,
                        await JackettApi.Api(host, search)
                    );
                }
                #endregion
            }
            else if (ModInit.conf.typesearch == "webapi")
            {
                #region webapi
                if (ModInit.conf.merge == "jackett")
                {
                    var t1 = WebApi.Api(search);
                    var t2 = JackettApi.Api(host, search);

                    await Task.WhenAll(t1, t2);

                    torrents = mergeTorrents(t1.Result, t2.Result);
                }
                else
                {
                    torrents = await WebApi.Api(search);
                }
                #endregion
            }
            else if (ModInit.conf.typesearch == "jackett")
            {
                torrents = await JackettApi.Api(host, search);
            }

            return Content(JsonConvert.SerializeObject(torrents.Take(2_000).Select(i => new
            {
                tracker = i.trackerName,
                url = i.url != null && i.url.StartsWith("http") ? i.url : null,
                i.title,
                size = 0 > i.size ? getSizeInfo(i.sizeName) : i.size,
                i.sizeName,
                i.createTime,
                i.sid,
                i.pir,
                magnet = i.magnet ?? $"{i.parselink}&apikey={apikey}",
                i.name,
                i.originalname,
                i.relased,
                i.videotype,
                i.quality,
                i.voices,
                i.seasons,
                i.types

            }), new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }), "application/json; charset=utf-8");
        }
        #endregion


        #region getSizeInfo
        long getSizeInfo(string sizeName)
        {
            if (string.IsNullOrWhiteSpace(sizeName))
                return 0;

            try
            {
                double size = 0.1;
                var gsize = Regex.Match(sizeName, "([0-9\\.,]+) (Mb|–ú–ë|GB|–ì–ë|TB|–¢–ë)", RegexOptions.IgnoreCase).Groups;
                if (!string.IsNullOrWhiteSpace(gsize[2].Value))
                {
                    if (double.TryParse(gsize[1].Value.Replace(",", "."), NumberStyles.Any, CultureInfo.InvariantCulture, out size) && size != 0)
                    {
                        if (gsize[2].Value.ToLower() is "gb" or "–≥–±")
                            size *= 1024;

                        if (gsize[2].Value.ToLower() is "tb" or "—Ç–±")
                            size *= 1048576;

                        return (long)(size * 1048576);
                    }
                }
            }
            catch { }

            return 0;
        }
        #endregion

        #region getCategoryIds
        HashSet<int> getCategoryIds(TorrentDetails t, out string categoryDesc)
        {
            categoryDesc = null;
            HashSet<int> categoryIds = new HashSet<int>();

            if (t.types == null)
                return categoryIds;

            foreach (string type in t.types)
            {
                switch (type)
                {
                    case "movie":
                        categoryDesc = "Movies";
                        categoryIds.Add(2000);
                        break;

                    case "serial":
                        categoryDesc = "TV";
                        categoryIds.Add(5000);
                        break;

                    case "documovie":
                    case "docuserial":
                        categoryDesc = "TV/Documentary";
                        categoryIds.Add(5080);
                        break;

                    case "tvshow":
                        categoryDesc = "TV/Foreign";
                        categoryIds.Add(5020);
                        categoryIds.Add(2010);
                        break;

                    case "anime":
                        categoryDesc = "TV/Anime";
                        categoryIds.Add(5070);
                        break;
                }
            }

            return categoryIds;
        }
        #endregion

        #region mergeTorrents
        static IEnumerable<TorrentDetails> mergeTorrents(IEnumerable<TorrentDetails> red, IEnumerable<TorrentDetails> jac)
        {
            if (red == null && jac == null)
                return new List<TorrentDetails>();

            if (red == null || !red.Any())
                return jac;

            if (jac == null || !jac.Any())
                return red;

            var torrents = new Dictionary<string, TorrentDetails>();

            foreach (var i in red.Concat(jac))
            {
                if (string.IsNullOrEmpty(i.url) || !i.url.StartsWith("http"))
                    continue;

                void add(string url) { torrents.TryAdd(Regex.Replace(url, "^https?://[^/]+/", ""), (TorrentDetails)i.Clone()); }

                if (i.urls != null && i.urls.Count > 0)
                {
                    foreach (string u in i.urls)
                        add(u);
                }
                else
                {
                    add(i.url);
                }
            }

            return torrents.Values;
        }
        #endregion
    }
}

```

## File: JacRed/ModInit.cs
```
Ôªøusing JacRed.Models.AppConf;
using Newtonsoft.Json;
using System.Threading;

namespace Jackett
{
    public class ModInit
    {
        #region ModInit
        static (ModInit, DateTime) cacheconf = default;

        public static ModInit conf
        {
            get
            {
                if (cacheconf.Item1 == null)
                {
                    if (!File.Exists("module/JacRed.conf"))
                        return new ModInit();
                }

                var lastWriteTime = File.GetLastWriteTime("module/JacRed.conf");

                if (cacheconf.Item2 != lastWriteTime)
                {
                    var jss = new JsonSerializerSettings { Error = (se, ev) => 
                    { 
                        ev.ErrorContext.Handled = true; 
                        Console.WriteLine("module/JacRed.conf - " + ev.ErrorContext.Error + "\n\n"); 
                    }};

                    string json = File.ReadAllText("module/JacRed.conf");
                    if (!json.TrimStart().StartsWith("{"))
                        json = "{"+json+"}";

                    cacheconf.Item1 = JsonConvert.DeserializeObject<ModInit>(json, jss);
                    cacheconf.Item2 = lastWriteTime;
                }

                return cacheconf.Item1;
            }
        }
        #endregion

        public static void loaded()
        {
            Directory.CreateDirectory("cache/jacred");
            File.WriteAllText("module/JacRed.current.conf", JsonConvert.SerializeObject(conf, Formatting.Indented));

            ThreadPool.QueueUserWorkItem(async _ => await SyncCron.Run());
            ThreadPool.QueueUserWorkItem(async _ => await FileDB.Cron());
            ThreadPool.QueueUserWorkItem(async _ => await FileDB.CronFast());


            ThreadPool.QueueUserWorkItem(async _ =>
            {
                while (true)
                {
                    await Task.Delay(TimeSpan.FromMinutes(5));

                    try
                    {
                        if (conf.typesearch == "jackett" || conf.merge == "jackett")
                        {
                            async ValueTask<bool> showdown(string name, TrackerSettings settings)
                            {
                                if (!settings.monitor_showdown)
                                    return false;

                                var proxyManager = new ProxyManager(name, settings);
                                string html = await Http.Get($"{settings.host}", timeoutSeconds: conf.Jackett.timeoutSeconds, proxy: proxyManager.Get(), weblog: false);
                                return html == null;
                            }

                            conf.Jackett.Rutor.showdown = await showdown("rutor", conf.Jackett.Rutor);
                            conf.Jackett.Megapeer.showdown = await showdown("megapeer", conf.Jackett.Megapeer);
                            conf.Jackett.TorrentBy.showdown = await showdown("torrentby", conf.Jackett.TorrentBy);
                            conf.Jackett.Kinozal.showdown = await showdown("kinozal", conf.Jackett.Kinozal);
                            conf.Jackett.NNMClub.showdown = await showdown("nnmclub", conf.Jackett.NNMClub);
                            conf.Jackett.Bitru.showdown = await showdown("bitru", conf.Jackett.Bitru);
                            conf.Jackett.Toloka.showdown = await showdown("toloka", conf.Jackett.Toloka);
                            conf.Jackett.Rutracker.showdown = await showdown("rutracker", conf.Jackett.Rutracker);
                            conf.Jackett.BigFanGroup.showdown = await showdown("bigfangroup", conf.Jackett.BigFanGroup);
                            conf.Jackett.Selezen.showdown = await showdown("selezen", conf.Jackett.Selezen);
                            conf.Jackett.Lostfilm.showdown = await showdown("lostfilm", conf.Jackett.Lostfilm);
                            conf.Jackett.Anilibria.showdown = await showdown("anilibria", conf.Jackett.Anilibria);
                            conf.Jackett.Animelayer.showdown = await showdown("animelayer", conf.Jackett.Animelayer);
                            conf.Jackett.Anifilm.showdown = await showdown("anifilm", conf.Jackett.Anifilm);
                        }
                    }
                    catch { }
                }
            });
        }


        /// <summary>
        /// red
        /// jackett
        /// webapi
        /// </summary>
        public string typesearch = "webapi";

        public string merge = "jackett";

        public string webApiHost = "http://redapi.cfhttp.top";

        public string filter { get; set; }

        public string filter_ignore { get; set; }


        public RedConf Red = new RedConf();

        public JacConf Jackett = new JacConf();
    }
}

```

## File: JacRed/GlobalUsings.cs
```
Ôªøglobal using System;
global using System.Web;
global using System.Threading.Tasks;
global using System.Collections.Generic;
global using System.Text.RegularExpressions;
global using System.Collections.Concurrent;
global using System.Globalization;
global using System.IO;
global using System.Linq;
global using HtmlAgilityPack;
global using Shared;
global using Shared.Models;
global using Shared.Engine;
global using JacRed.Engine;
global using Shared.Engine.JacRed;
global using Shared.Models.JacRed;
```

## File: JacRed/Models/WriteTaskModel.cs
```
Ôªønamespace JacRed.Models
{
    public class WriteTaskModel
    {
        public FileDB db { get; set; }

        public int openconnection { get; set; }

        public int countread { get; set; }

        public DateTime lastread { get; set; }

        public DateTime create { get; set; } = DateTime.Now;
    }
}

```

## File: JacRed/Models/AniLibria/RootObject.cs
```
Ôªønamespace JacRed.Models.AniLibria
{
    public class RootObject
    {
        public Names names { get; set; }

        public string code { get; set; }

        public Torrents torrents { get; set; }

        public Season season { get; set; }

        public long updated { get; set; }

        public long last_change { get; set; }
    }
}

```

## File: JacRed/Models/AniLibria/Torrent.cs
```
Ôªønamespace JacRed.Models.AniLibria
{
    public class Torrent
    {
        public Series series { get; set; }

        public Quality quality { get; set; }

        public int leechers { get; set; }

        public int seeders { get; set; }

        public string url { get; set; }

        public long total_size { get; set; }
    }
}

```

## File: JacRed/Models/AniLibria/Series.cs
```
Ôªønamespace JacRed.Models.AniLibria
{
    public class Series
    {
        public string @string { get; set; }
    }
}

```

## File: JacRed/Models/AniLibria/Quality.cs
```
Ôªønamespace JacRed.Models.AniLibria
{
    public class Quality
    {
        public string @string { get; set; }

        public int resolution { get; set; }

        public string encoder { get; set; }
    }
}

```

## File: JacRed/Models/AniLibria/Torrents.cs
```
Ôªønamespace JacRed.Models.AniLibria
{
    public class Torrents
    {
        public List<Torrent> list { get; set; }
    }
}

```

## File: JacRed/Models/AniLibria/Names.cs
```
Ôªønamespace JacRed.Models.AniLibria
{
    public class Names
    {
        public string ru { get; set; }

        public string en { get; set; }
    }
}

```

## File: JacRed/Models/AniLibria/Season.cs
```
Ôªønamespace JacRed.Models.AniLibria
{
    public class Season
    {
        public int year { get; set; }

        public int code { get; set; }
    }
}

```

## File: JacRed/Models/AppConf/JacConf.cs
```
Ôªønamespace JacRed.Models.AppConf
{
    public class JacConf
    {
        public int cacheToMinutes = 5;

        public string search_lang = "query";

        public int timeoutSeconds = 8;


        public TrackerSettings Rutor = new TrackerSettings("https://rutor.info"/*, priority: "torrent"*/);

        public TrackerSettings Megapeer = new TrackerSettings("https://megapeer.vip", enable: false);

        public TrackerSettings TorrentBy = new TrackerSettings("https://torrent.by"/*, priority: "torrent"*/);

        public TrackerSettings Kinozal = new TrackerSettings("https://kinozal.tv");

        public TrackerSettings NNMClub = new TrackerSettings("https://nnmclub.to");

        public TrackerSettings Bitru = new TrackerSettings("https://bitru.org");

        public TrackerSettings Toloka = new TrackerSettings("https://toloka.to");

        public TrackerSettings Rutracker = new TrackerSettings("https://rutracker.org"/*, priority: "torrent"*/);

        public TrackerSettings BigFanGroup = new TrackerSettings("https://bigfangroup.org");

        public TrackerSettings Selezen = new TrackerSettings("https://open.selezen.org"/*, priority: "torrent"*/);

        public TrackerSettings Lostfilm = new TrackerSettings("https://www.lostfilm.tv");

        public TrackerSettings Anilibria = new TrackerSettings("https://www.anilibria.tv");

        public TrackerSettings Animelayer = new TrackerSettings("http://animelayer.ru");

        public TrackerSettings Anifilm = new TrackerSettings("https://anifilm.pro");
    }
}

```

## File: JacRed/Models/AppConf/TrackerSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace JacRed.Models.AppConf
{
    public class TrackerSettings : Iproxy
    {
        public TrackerSettings(string host, bool enable = true, bool useproxy = false, LoginSettings login = null, string priority = null)
        {
            this.host = host;
            this.enable = enable;
            this.useproxy = useproxy;

            if (login != null)
                this.login = login;

            this.priority = priority;
        }


        public string host { get; set; }

        public bool enable { get; set; }

        public bool showdown { get; set; }

        public bool monitor_showdown { get; set; } = true;

        public string priority { get; set; }

        public LoginSettings login { get; set; } = new LoginSettings();

        public string cookie { get; set; }


        public bool useproxy { get; set; }

        public bool useproxystream { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }
    }
}

```

## File: JacRed/Models/AppConf/Evercache.cs
```
Ôªønamespace JacRed.Models.AppConf
{
    public class Evercache
    {
        public bool enable = false;

        public int validHour = 1;

        public int maxOpenWriteTask { get; set; } = 1000;

        public int dropCacheTake { get; set; } = 100;
    }
}

```

## File: JacRed/Models/AppConf/RedConf.cs
```
Ôªønamespace JacRed.Models.AppConf
{
    public class RedConf
    {
        public string syncapi = "http://redapi.cfhttp.top";

        public int syntime = 60;

        public string[] trackers = new string[] { "rutracker", "rutor", "kinozal", "nnmclub", "megapeer", "bitru", "toloka", "lostfilm", "baibako", "torrentby", "hdrezka", "selezen", "animelayer", "anilibria", "anifilm" };

        public int maxreadfile = 300;

        public bool mergeduplicates = true;

        public bool mergenumduplicates = true;

        public Evercache evercache = new Evercache();
    }
}

```

## File: JacRed/Models/AppConf/LoginSettings.cs
```
Ôªønamespace JacRed.Models.AppConf
{
    public class LoginSettings
    {
        public string u { get; set; }

        public string p { get; set; }
    }
}

```

## File: JacRed/Models/Sync/RootObject.cs
```
Ôªønamespace JacRed.Models.Sync
{
    public class RootObject
    {
        public bool nextread { get; set; }

        public List<Collection> collections { get; set; }
    }
}

```

## File: JacRed/Models/Sync/Value.cs
```
Ôªønamespace JacRed.Models.Sync
{
    public class Value
    {
        public DateTime time { get; set; }

        public long fileTime { get; set; }

        public Dictionary<string, TorrentDetails> torrents { get; set; }
    }
}

```

## File: JacRed/Models/Sync/Collection.cs
```
Ôªønamespace JacRed.Models.Sync
{
    public class Collection
    {
        public string Key { get; set; }

        public Value Value { get; set; }
    }
}

```

## File: JacRed/Controllers/KinozalController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;

namespace JacRed.Controllers
{
    [Route("kinozal/[action]")]
    public class KinozalController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string[] cats)
        {
            if (!jackett.Kinozal.enable || jackett.Kinozal.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cats));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string id)
        {
            if (!jackett.Kinozal.enable)
                return Content("disable");

            var proxyManager = new ProxyManager("kinozal", jackett.Kinozal);

            #region Download
            if (jackett.Kinozal.cookie != null || Cookie != null)
            {
                var _t = await Http.Download("http://dl.kinozal.tv/download.php?id=" + id, proxy: proxyManager.Get(), cookie: jackett.Kinozal.cookie ?? Cookie, referer: jackett.Kinozal.host, timeoutSeconds: 10);
                if (_t != null && BencodeTo.Magnet(_t) != null)
                    return File(_t, "application/x-bittorrent");
            }
            #endregion

            string srv_details = await Http.Post($"{jackett.Kinozal.host}/get_srv_details.php?id={id}&action=2", $"id={id}&action=2", "__cfduid=d476ac2d9b5e18f2b67707b47ebd9b8cd1560164391; uid=20520283; pass=ouV5FJdFCd;", proxy: proxyManager.Get(), timeoutSeconds: 10);
            if (srv_details != null)
            {
                string torrentHash = new Regex("<ul><li>–ò–Ω—Ñ–æ —Ö–µ—à: +([^<]+)</li>").Match(srv_details).Groups[1].Value;
                if (!string.IsNullOrEmpty(torrentHash))
                    return Redirect($"magnet:?xt=urn:btih:{torrentHash}");
            }

            proxyManager.Refresh();
            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string[] cats)
        {
            var torrents = new List<TorrentDetails>();
            var proxyManager = new ProxyManager("kinozal", jackett.Kinozal);

            string html = await Http.Get($"{jackett.Kinozal.host}/browse.php?s={HttpUtility.UrlEncode(query)}&g=0&c=0&v=0&d=0&w=0&t=0&f=0", proxy: proxyManager.Get(), timeoutSeconds: jackett.timeoutSeconds);

            if (html != null && html.Contains("–ö–∏–Ω–æ–∑–∞–ª.–¢–í</title>"))
            {
                if (!html.Contains(">–í—ã—Ö–æ–¥</a>") && !string.IsNullOrWhiteSpace(jackett.Kinozal.login.u) && !string.IsNullOrWhiteSpace(jackett.Kinozal.login.p))
                    TakeLogin();
            }
            else if (html == null)
            {
                consoleErrorLog("kinozal");
                proxyManager.Refresh();
                return null;
            }

            foreach (string row in Regex.Split(html, "<tr class=('first bg'|bg)>").Skip(1))
            {
                if (string.IsNullOrWhiteSpace(row))
                    continue;

                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string pattern, int index = 1)
                {
                    string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim());
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è
                DateTime createTime = default;

                if (row.Contains("<td class='s'>—Å–µ–≥–æ–¥–Ω—è"))
                {
                    createTime = DateTime.Today;
                }
                else if (row.Contains("<td class='s'>–≤—á–µ—Ä–∞"))
                {
                    createTime = DateTime.Today.AddDays(-1);
                }
                else
                {
                    createTime = tParse.ParseCreateTime(Match("<td class='s'>([0-9]{2}.[0-9]{2}.[0-9]{4}) –≤ [0-9]{2}:[0-9]{2}"), "dd.MM.yyyy");
                }
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                string url = Match("href=\"/(details.php\\?id=[0-9]+)\"");
                string tracker = Match("src=\"/pic/cat/([0-9]+)\\.gif\"");
                string title = Match("class=\"r[0-9]+\">([^<]+)");
                string _sid = Match("<td class='sl_s'>([0-9]+)");
                string _pir = Match("<td class='sl_p'>([0-9]+)");
                string sizeName = Match("<td class='s'>([0-9\\.,]+ (–ú–ë|–ì–ë))");

                if (string.IsNullOrWhiteSpace(url) || string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(tracker))
                    continue;
                #endregion

                // Id –Ω–æ–≤–æ—Å—Ç–∏
                string id = Match("href=\"/details.php\\?id=([0-9]+)\"");
                if (string.IsNullOrEmpty(id))
                    continue;

                #region types
                string[] types = new string[] { };
                switch (tracker)
                {
                    case "1002":
                    case "8":
                    case "6":
                    case "15":
                    case "17":
                    case "35":
                    case "39":
                    case "13":
                    case "14":
                    case "24":
                    case "11":
                    case "10":
                    case "9":
                    case "47":
                    case "18":
                    case "37":
                    case "12":
                    case "7":
                    case "16":
                        types = new string[] { "movie" };
                        break;
                    case "45":
                    case "46":
                        types = new string[] { "serial" };
                        break;
                    case "21":
                    case "22":
                        types = new string[] { "multfilm", "multserial" };
                        break;
                    case "20":
                        types = new string[] { "anime" };
                        break;
                    case "1006":
                    case "48":
                    case "49":
                    case "50":
                    case "38":
                        types = new string[] { "tvshow" };
                        break;
                }

                if (cats != null)
                {
                    if (types == null)
                        continue;

                    bool isok = false;
                    foreach (string cat in cats)
                    {
                        if (types.Contains(cat))
                            isok = true;
                    }

                    if (!isok)
                        continue;
                }
                #endregion

                int.TryParse(_sid, out int sid);
                int.TryParse(_pir, out int pir);

                torrents.Add(new TorrentDetails()
                {
                    types = types,
                    url = $"{jackett.Kinozal.host}/{url}",
                    title = title,
                    sid = sid,
                    pir = pir,
                    sizeName = sizeName,
                    createTime = createTime,
                    parselink = $"{host}/kinozal/parsemagnet?id={id}"
                });
            }

            return torrents;
        }
        #endregion


        #region Cookie / TakeLogin
        static string Cookie;

        async static void TakeLogin()
        {
            string authKey = "kinozal:TakeLogin()";
            if (Startup.memoryCache.TryGetValue(authKey, out _))
                return;

            Startup.memoryCache.Set(authKey, 0, AppInit.conf.multiaccess ? TimeSpan.FromMinutes(2) : TimeSpan.FromSeconds(20));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(jackett.timeoutSeconds);
                        client.MaxResponseContentBufferSize = 2000000; // 2MB
                        client.DefaultRequestHeaders.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36");
                        client.DefaultRequestHeaders.Add("cache-control", "no-cache");
                        client.DefaultRequestHeaders.Add("dnt", "1");
                        client.DefaultRequestHeaders.Add("origin", jackett.Kinozal.host);
                        client.DefaultRequestHeaders.Add("pragma", "no-cache");
                        client.DefaultRequestHeaders.Add("referer", $"{jackett.Kinozal.host}/");
                        client.DefaultRequestHeaders.Add("upgrade-insecure-requests", "1");

                        var postParams = new Dictionary<string, string>
                    {
                        { "username", jackett.Kinozal.login.u },
                        { "password", jackett.Kinozal.login.p },
                        { "returnto", "" }
                    };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync($"{jackett.Kinozal.host}/takelogin.php", postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string uid = null, pass = null;
                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrWhiteSpace(line))
                                            continue;

                                        if (line.Contains("uid="))
                                            uid = new Regex("uid=([0-9]+)").Match(line).Groups[1].Value;

                                        if (line.Contains("pass="))
                                            pass = new Regex("pass=([^;]+)(;|$)").Match(line).Groups[1].Value;
                                    }

                                    if (!string.IsNullOrWhiteSpace(uid) && !string.IsNullOrWhiteSpace(pass))
                                        Cookie = $"uid={uid}; pass={pass};";
                                }
                            }
                        }
                    }
                }
            }
            catch { }
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/RutrackerController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;

namespace JacRed.Controllers
{
    [Route("rutracker/[action]")]
    public class RutrackerController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string[] cats)
        {
            if (!jackett.Rutracker.enable || string.IsNullOrEmpty(jackett.Rutracker.cookie ?? jackett.Rutracker.login.u) || jackett.Rutracker.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cats));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string id)
        {
            if (!jackett.Rutracker.enable)
                return Content("disable");

            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
                return Content("cookie == null");

            var proxyManager = new ProxyManager("rutracker", jackett.Rutracker);

            #region Download
            if (jackett.Rutracker.priority == "torrent")
            {
                var _t = await Http.Download($"{jackett.Rutracker.host}/forum/dl.php?t={id}", proxy: proxyManager.Get(), cookie: cookie, referer: jackett.Rutracker.host);
                if (_t != null && BencodeTo.Magnet(_t) != null)
                    return File(_t, "application/x-bittorrent");
            }
            #endregion

            #region Magnet
            var fullNews = await Http.Get($"{jackett.Rutracker.host}/forum/viewtopic.php?t=" + id, proxy: proxyManager.Get(), cookie: cookie);
            if (fullNews != null)
            {
                string magnet = Regex.Match(fullNews, "href=\"(magnet:[^\"]+)\" class=\"(med )?med magnet-link\"").Groups[1].Value;
                if (!string.IsNullOrWhiteSpace(magnet))
                    return Redirect(magnet);
            }
            #endregion

            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string[] cats)
        {
            var torrents = new List<TorrentDetails>();
            var proxyManager = new ProxyManager("rutracker", jackett.Rutracker);

            #region –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
            {
                consoleErrorLog("rutracker");
                return null;
            }
            #endregion

            #region –ö–µ—à html
            string html = await Http.Get($"{jackett.Rutracker.host}/forum/tracker.php?nm=" + HttpUtility.UrlEncode(query), proxy: proxyManager.Get(), cookie: cookie, timeoutSeconds: jackett.timeoutSeconds);

            if (html != null)
            {
                if (!html.Contains("id=\"logged-in-username\""))
                {
                    consoleErrorLog("rutracker");
                    return null;
                }
            }
            #endregion

            foreach (string row in html.Split("class=\"tCenter hl-tr\"").Skip(1))
            {
                if (string.IsNullOrWhiteSpace(row))
                    continue;

                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string pattern, int index = 1)
                {
                    string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim());
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                string title = Match("href=\"viewtopic.php\\?t=[0-9]+\">([^\n\r]+)</a>");
                title = Regex.Replace(title, "<[^>]+>", "");

                DateTime createTime = tParse.ParseCreateTime(Match("<p>([0-9]{2}-[^-<]+-[0-9]{2})</p>").Replace("-", " "), "dd.MM.yy");
                string viewtopic = Match("href=\"viewtopic.php\\?t=([0-9]+)\"");
                string tracker = Match("href=\"tracker.php\\?f=([0-9]+)");
                string _sid = Match("class=\"seedmed\">([0-9]+)");
                string _pir = Match("title=\"–õ–∏—á–∏\">([0-9]+)");
                string sizeName = Match("href=\"dl.php\\?t=[0-9]+\">([^<]+) &#8595;</a>").Replace("&nbsp;", " ");

                if (string.IsNullOrWhiteSpace(viewtopic) || string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(tracker))
                    continue;
                #endregion

                #region types
                string[] types = null;
                switch (tracker)
                {
                    case "22":
                    case "1666":
                    case "941":
                    case "1950":
                    case "2090":
                    case "2221":
                    case "2091":
                    case "2092":
                    case "2093":
                    case "2200":
                    case "2540":
                    case "934":
                    case "505":
                    case "124":
                    case "1457":
                    case "2199":
                    case "313":
                    case "312":
                    case "1247":
                    case "2201":
                    case "2339":
                    case "140":
                    case "252":
                    case "2198":
                        types = new string[] { "movie" };
                        break;
                    case "2343":
                    case "930":
                    case "2365":
                    case "208":
                    case "539":
                    case "209":
                        types = new string[] { "multfilm" };
                        break;
                    case "921":
                    case "815":
                    case "1460":
                        types = new string[] { "multserial" };
                        break;
                    case "842":
                    case "235":
                    case "242":
                    case "819":
                    case "1531":
                    case "721":
                    case "1102":
                    case "1120":
                    case "1214":
                    case "489":
                    case "387":
                    case "9":
                    case "81":
                    case "119":
                    case "1803":
                    case "266":
                    case "193":
                    case "1690":
                    case "1459":
                    case "825":
                    case "1248":
                    case "1288":
                    case "325":
                    case "534":
                    case "694":
                    case "704":
                    case "915":
                    case "1939":
                        types = new string[] { "serial" };
                        break;
                    case "1105":
                    case "2491":
                    case "1389":
                        types = new string[] { "anime" };
                        break;
                    case "709":
                        types = new string[] { "documovie" };
                        break;
                    case "46":
                    case "671":
                    case "2177":
                    case "2538":
                    case "251":
                    case "98":
                    case "97":
                    case "851":
                    case "2178":
                    case "821":
                    case "2076":
                    case "56":
                    case "2123":
                    case "876":
                    case "2139":
                    case "1467":
                    case "1469":
                    case "249":
                    case "552":
                    case "500":
                    case "2112":
                    case "1327":
                    case "1468":
                    case "2168":
                    case "2160":
                    case "314":
                    case "1281":
                    case "2110":
                    case "979":
                    case "2169":
                    case "2164":
                    case "2166":
                    case "2163":
                        types = new string[] { "docuserial", "documovie" };
                        break;
                    case "24":
                    case "1959":
                    case "939":
                    case "1481":
                    case "113":
                    case "115":
                    case "882":
                    case "1482":
                    case "393":
                    case "2537":
                    case "532":
                    case "827":
                        types = new string[] { "tvshow" };
                        break;
                    case "2103":
                    case "2522":
                    case "2485":
                    case "2486":
                    case "2479":
                    case "2089":
                    case "1794":
                    case "845":
                    case "2312":
                    case "343":
                    case "2111":
                    case "1527":
                    case "2069":
                    case "1323":
                    case "2009":
                    case "2000":
                    case "2010":
                    case "2006":
                    case "2007":
                    case "2005":
                    case "259":
                    case "2004":
                    case "1999":
                    case "2001":
                    case "2002":
                    case "283":
                    case "1997":
                    case "2003":
                    case "1608":
                    case "1609":
                    case "2294":
                    case "1229":
                    case "1693":
                    case "2532":
                    case "136":
                    case "592":
                    case "2533":
                    case "1952":
                    case "1621":
                    case "2075":
                    case "1668":
                    case "1613":
                    case "1614":
                    case "1623":
                    case "1615":
                    case "1630":
                    case "2425":
                    case "2514":
                    case "1616":
                    case "2014":
                    case "1442":
                    case "1491":
                    case "1987":
                    case "1617":
                    case "1620":
                    case "1998":
                    case "1343":
                    case "751":
                    case "1697":
                    case "255":
                    case "260":
                    case "261":
                    case "256":
                    case "1986":
                    case "660":
                    case "1551":
                    case "626":
                    case "262":
                    case "1326":
                    case "978":
                    case "1287":
                    case "1188":
                    case "1667":
                    case "1675":
                    case "257":
                    case "875":
                    case "263":
                    case "2073":
                    case "550":
                    case "2124":
                    case "1470":
                    case "528":
                    case "486":
                    case "854":
                    case "2079":
                    case "1336":
                    case "2171":
                    case "1339":
                    case "2455":
                    case "1434":
                    case "2350":
                    case "1472":
                    case "2068":
                    case "2016":
                        types = new string[] { "sport" };
                        break;
                }

                if (cats != null)
                {
                    if (types == null)
                        continue;

                    bool isok = false;
                    foreach (string cat in cats)
                    {
                        if (types.Contains(cat))
                            isok = true;
                    }

                    if (!isok)
                        continue;
                }
                #endregion

                int.TryParse(_sid, out int sid);
                int.TryParse(_pir, out int pir);

                torrents.Add(new TorrentDetails()
                {
                    types = types,
                    url = $"{jackett.Rutracker.host}/forum/viewtopic.php?t={viewtopic}",
                    title = title,
                    sid = sid,
                    pir = pir,
                    sizeName = sizeName,
                    createTime = createTime,
                    parselink = $"{host}/rutracker/parsemagnet?id={viewtopic}"
                });
            }

            return torrents;
        }
        #endregion


        #region getCookie
        async static ValueTask<string> getCookie()
        {
            if (!string.IsNullOrEmpty(jackett.Rutracker.cookie))
                return jackett.Rutracker.cookie;

            string authKey = "Rutracker:TakeLogin()";
            if (Startup.memoryCache.TryGetValue(authKey, out string _cookie))
                return _cookie;

            if (Startup.memoryCache.TryGetValue($"{authKey}:error", out _))
                return null;

            Startup.memoryCache.Set($"{authKey}:error", 0, TimeSpan.FromSeconds(20));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(jackett.timeoutSeconds);
                        client.MaxResponseContentBufferSize = 2000000; // 2MB
                        client.DefaultRequestHeaders.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36");

                        var postParams = new Dictionary<string, string>
                    {
                        { "login_username", jackett.Rutracker.login.u },
                        { "login_password", jackett.Rutracker.login.p },
                        { "login", "–í—Ö–æ–¥" }
                    };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync($"{jackett.Rutracker.host}/forum/login.php", postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string session = null;
                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrWhiteSpace(line))
                                            continue;

                                        if (line.Contains("bb_session="))
                                            session = new Regex("bb_session=([^;]+)(;|$)").Match(line).Groups[1].Value;
                                    }

                                    if (!string.IsNullOrWhiteSpace(session))
                                    {
                                        string cookie = $"bb_ssl=1; bb_session={session};";
                                        Startup.memoryCache.Set(authKey, cookie, DateTime.Today.AddDays(1));
                                        return cookie;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch { }

            return null;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/RutorController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace JacRed.Controllers
{
    [Route("rutor/[action]")]
    public class RutorController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string cat, bool isua = false, string parsecat = null)
        {
            if (!jackett.Rutor.enable || jackett.Rutor.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cat, isua, parsecat));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(int id, string magnet)
        {
            if (!jackett.Rutor.enable || jackett.Rutor.priority != "torrent")
                return Content("disable");

            var proxyManager = new ProxyManager("rutor", jackett.Rutor);

            byte[] _t = await Http.Download($"{Regex.Replace(jackett.Rutor.host, "^(https?:)//", "$1//d.")}/download/{id}", referer: jackett.Rutor.host, proxy: proxyManager.Get());
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            proxyManager.Refresh();

            if (string.IsNullOrEmpty(magnet))
                return Content("empty");

            return Redirect(magnet);
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string cat, bool isua, string parsecat)
        {
            // fix search
            query = query.Replace("\"", " ").Replace("'", " ").Replace("?", " ").Replace("&", " ");

            var proxyManager = new ProxyManager("rutor", jackett.Rutor);

            string html = await Http.Get($"{jackett.Rutor.host}/search" + (cat == "0" ? $"/{HttpUtility.UrlEncode(query)}" : $"/0/{cat}/000/0/{HttpUtility.UrlEncode(query)}"), proxy: proxyManager.Get(), timeoutSeconds: jackett.timeoutSeconds);

            if (html == null || !html.Contains("id=\"logo\""))
            {
                consoleErrorLog("rutor");
                proxyManager.Refresh();
                return null;
            }

            var doc = new HtmlDocument();
            doc.LoadHtml(html.Replace("&nbsp;", " ").Replace("¬†", " ")); // –ú–µ–Ω—è–µ–º –Ω–µ–ø–æ–Ω—è—Ç–Ω—ã–π —Å–∏–º–≤–æ–ª –ø–æ—Ö–æ–∂–∏–π –Ω–∞ –ø—Ä–æ–±–ª–µ–ª, –Ω–∞ –æ–±—ã—á–Ω—ã–π –ø—Ä–æ–±–ª–µ–ª

            var nodes = doc.DocumentNode.SelectNodes("//tr[@class='gai' or @class='tum']");
            if (nodes == null || nodes.Count == 0)
                return null;

            var torrents = new List<TorrentDetails>();

            foreach (var row in nodes)
            {
                var hc = new HtmlCommon(row);

                string url = hc.Match("href=\"/(torrent/[^\"]+)\"");
                string viewtopic = Regex.Match(url, "torrent/([0-9]+)").Groups[1].Value;

                string title = hc.NodeValue(".//a[contains(@href, '/torrent/')]");
                string sid = hc.NodeValue(".//span[@class='green']", removeChild: ".//img");
                string pir = hc.NodeValue(".//span[@class='red']");
                string sizeName = hc.NodeValue(".//td[@align='right' and contains(text(), 'GB') or contains(text(), 'MB')]");
                string createTime = hc.NodeValue(".//td");
                string magnet = hc.Match("href=\"(magnet:\\?xt=[^\"]+)\"");

                if (string.IsNullOrEmpty(title) || string.IsNullOrEmpty(magnet) || title.ToLower().Contains("—Ç—Ä–µ–π–ª–µ—Ä"))
                    continue;

                if (isua && !title.Contains(" UKR"))
                    continue;

                torrents.Add(new TorrentDetails()
                {
                    url = $"{jackett.Rutor.host}/{url}",
                    title = title,
                    sid = HtmlCommon.Integer(sid),
                    pir = HtmlCommon.Integer(pir),
                    sizeName = sizeName,
                    magnet = jackett.Rutor.priority == "torrent" ? null : magnet,
                    parselink = jackett.Rutor.priority == "torrent" ? $"{host}/rutor/parsemagnet?id={viewtopic}&magnet={HttpUtility.UrlEncode(magnet)}" : null,
                    createTime = tParse.ParseCreateTime(createTime, "dd.MM.yy")
                });
            }

            return torrents;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/MegapeerController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using System.Text;

namespace JacRed.Controllers
{
    [Route("megapeer/[action]")]
    public class MegapeerController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string cat)
        {
            if (!jackett.Megapeer.enable || jackett.Megapeer.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cat));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string id)
        {
            if (!jackett.Megapeer.enable)
                return Content("disable");

            var proxyManager = new ProxyManager("megapeer", jackett.Megapeer);

            byte[] _t = await Http.Download($"{jackett.Megapeer.host}/download/{id}", referer: jackett.Megapeer.host, proxy: proxyManager.Get());
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            proxyManager.Refresh();
            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string cat)
        {
            #region html
            var proxyManager = new ProxyManager("megapeer", jackett.Megapeer);

            string html = await Http.Get($"{jackett.Megapeer.host}/browse.php?search={HttpUtility.UrlEncode(query, Encoding.GetEncoding(1251))}&cat={cat}", encoding: Encoding.GetEncoding(1251), proxy: proxyManager.Get(), timeoutSeconds: jackett.timeoutSeconds, headers: HeadersModel.Init(
                ("dnt", "1"),
                ("pragma", "no-cache"),
                ("referer", $"{jackett.Megapeer.host}"),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-mode", "navigate"),
                ("sec-fetch-site", "same-origin"),
                ("sec-fetch-user", "?1"),
                ("upgrade-insecure-requests", "1")
            ));

            if (html == null || !html.Contains("id=\"logo\"") || html.Contains("<H1>–†–∞–∑–¥–∞—á–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ"))
            {
                consoleErrorLog("megapeer");
                proxyManager.Refresh();
                return null;
            }
            #endregion

            var doc = new HtmlDocument();
            doc.LoadHtml(html.Replace("&nbsp;", " "));

            var nodes = doc.DocumentNode.SelectNodes("//tr[@class='table_fon']");
            if (nodes == null || nodes.Count == 0)
                return null;

            var torrents = new List<TorrentDetails>();

            foreach (var row in nodes)
            {
                var hc = new HtmlCommon(row);

                string url = hc.Match("href=\"/(torrent/[^\"]+)\"");
                string title = hc.NodeValue(".//a[@class='url']");
                title = Regex.Replace(title, "<[^>]+>", "");

                string sizeName = hc.NodeValue(".//td[@align='right' and contains(text(), 'GB') or contains(text(), 'MB')]");
                string downloadid = hc.Match("href=\"/?download/([0-9]+)\"");
                string createTime = hc.NodeValue(".//td");

                if (string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(downloadid))
                    continue;

                torrents.Add(new TorrentDetails()
                {
                    url = $"{jackett.Megapeer.host}/{url}",
                    title = title,
                    sid = HtmlCommon.Integer(hc.NodeValue(".//font[@color='#008000']")),
                    pir = HtmlCommon.Integer(hc.NodeValue(".//font[@color='#8b0000']")),
                    sizeName = sizeName,
                    parselink = $"{host}/megapeer/parsemagnet?id={downloadid}",
                    createTime = tParse.ParseCreateTime(createTime, "dd.MM.yy")
                });
            }

            return torrents;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/AnimeLayerController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;

namespace JacRed.Controllers
{
    [Route("animelayer/[action]")]
    public class AnimeLayerController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query)
        {
            if (!jackett.Animelayer.enable || string.IsNullOrEmpty(jackett.Animelayer.cookie ?? jackett.Animelayer.login.u) || jackett.Animelayer.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string url)
        {
            if (!jackett.Animelayer.enable)
                return Content("disable");

            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
                return Content("cookie == null");

            var proxyManager = new ProxyManager("animelayer", jackett.Animelayer);

            byte[] _t = await Http.Download($"{url}download/", proxy: proxyManager.Get(), cookie: cookie, referer: jackett.Animelayer.host);
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query)
        {
            #region –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
            {
                consoleErrorLog("animelayer");
                return null;
            }
            #endregion

            var torrents = new List<TorrentDetails>();
            var proxyManager = new ProxyManager("animelayer", jackett.Animelayer);

            #region html
            string html = await Http.Get($"{jackett.Animelayer.host}/torrents/anime/?q={HttpUtility.UrlEncode(query)}", proxy: proxyManager.Get(), cookie: cookie, timeoutSeconds: jackett.timeoutSeconds);

            if (html != null && html.Contains("id=\"wrapper\""))
            {
                if (!html.Contains($">{jackett.Animelayer.login.u}<"))
                {
                    consoleErrorLog("animelayer");
                    return null;
                }
            }
            else if (html == null)
            {
                consoleErrorLog("animelayer");
                return null;
            }
            #endregion

            foreach (string row in html.Split("class=\"torrent-item torrent-item-medium panel\"").Skip(1))
            {
                if (string.IsNullOrWhiteSpace(row))
                    continue;

                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string pattern, int index = 1)
                {
                    string res = new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim();
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è
                DateTime createTime = default;

                if (Regex.IsMatch(row, "(–î–æ–±–∞–≤–ª|–û–±–Ω–æ–≤–ª)[^<]+</span>(&nbsp;)?[0-9]+ [^ ]+ [0-9]{4}"))
                {
                    createTime = tParse.ParseCreateTime(Match(">(–î–æ–±–∞–≤–ª|–û–±–Ω–æ–≤–ª)[^<]+</span>(&nbsp;)?([0-9]+ [^ ]+ [0-9]{4})", 3), "dd.MM.yyyy");
                }
                else
                {
                    string date = Match("(–î–æ–±–∞–≤–ª|–û–±–Ω–æ–≤–ª)[^<]+</span>([^\n]+) –≤", 2);
                    if (!string.IsNullOrWhiteSpace(date))
                        createTime = tParse.ParseCreateTime($"{date} {DateTime.Today.Year}", "dd.MM.yyyy");
                }
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                var gurl = Regex.Match(row, "<a href=\"/(torrent/[a-z0-9]+)/?\">([^<]+)</a>").Groups;

                string url = gurl[1].Value;
                string title = gurl[2].Value;

                string _sid = Match("class=\"icon s-icons-upload\"></i>(&nbsp;)?([0-9]+)", 2);
                string _pir = Match("class=\"icon s-icons-download\"></i>(&nbsp;)?([0-9]+)", 2);
                string sizeName = Match("<i class=\"icon s-icons-download\"></i>[^<]+<span class=\"gray\">[^<]+</span>[\n\r\t ]+([^\n\r<]+)").Trim();

                if (string.IsNullOrWhiteSpace(url) || string.IsNullOrWhiteSpace(title))
                    continue;

                if (Regex.IsMatch(row, "–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ: ?</strong>1920x1080"))
                    title += " [1080p]";
                else if (Regex.IsMatch(row, "–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ: ?</strong>1280x720"))
                    title += " [720p]";
                #endregion

                int.TryParse(_sid, out int sid);
                int.TryParse(_pir, out int pir);

                torrents.Add(new TorrentDetails()
                {
                    types = new string[] { "anime" },
                    url = $"{jackett.Animelayer.host}/{url}/",
                    title = title,
                    sid = sid,
                    pir = pir,
                    sizeName = sizeName,
                    createTime = createTime,
                    parselink = $"{host}/animelayer/parsemagnet?url={HttpUtility.UrlEncode(url)}"
                });
            }

            return torrents;
        }
        #endregion


        #region getCookie
        async static ValueTask<string> getCookie()
        {
            if (!string.IsNullOrEmpty(jackett.Animelayer.cookie))
                return jackett.Animelayer.cookie;

            string authKey = "Animelayer:TakeLogin()";
            if (Startup.memoryCache.TryGetValue(authKey, out string _cookie))
                return _cookie;

            if (Startup.memoryCache.TryGetValue($"{authKey}:error", out _))
                return null;

            Startup.memoryCache.Set($"{authKey}:error", 0, TimeSpan.FromSeconds(20));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(jackett.timeoutSeconds);
                        client.MaxResponseContentBufferSize = 2000000; // 2MB
                        client.DefaultRequestHeaders.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36");

                        var postParams = new Dictionary<string, string>
                    {
                        { "login", jackett.Animelayer.login.u },
                        { "password", jackett.Animelayer.login.p }
                    };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync($"{jackett.Animelayer.host}/auth/login/", postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string layer_id = null, layer_hash = null, PHPSESSID = null;
                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrWhiteSpace(line))
                                            continue;

                                        if (line.Contains("layer_id="))
                                            layer_id = new Regex("layer_id=([^;]+)(;|$)").Match(line).Groups[1].Value;

                                        if (line.Contains("layer_hash="))
                                            layer_hash = new Regex("layer_hash=([^;]+)(;|$)").Match(line).Groups[1].Value;

                                        if (line.Contains("PHPSESSID="))
                                            PHPSESSID = new Regex("PHPSESSID=([^;]+)(;|$)").Match(line).Groups[1].Value;
                                    }

                                    if (!string.IsNullOrWhiteSpace(layer_id) && !string.IsNullOrWhiteSpace(layer_hash) && !string.IsNullOrWhiteSpace(PHPSESSID))
                                    {
                                        string cookie = $"layer_id={layer_id}; layer_hash={layer_hash}; PHPSESSID={PHPSESSID};";
                                        Startup.memoryCache.Set(authKey, cookie, DateTime.Today.AddDays(1));
                                        return cookie;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch { }

            return null;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/TolokaController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;

namespace JacRed.Controllers
{
    [Route("toloka/[action]")]
    public class TolokaController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string[] cats)
        {
            if (!jackett.Toloka.enable || string.IsNullOrEmpty(jackett.Toloka.cookie ?? jackett.Toloka.login.u) || jackett.Toloka.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cats));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string id)
        {
            if (!jackett.Toloka.enable)
                return Content("disable");

            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
                return Content("cookie == null");

            var proxyManager = new ProxyManager("toloka", jackett.Toloka);

            byte[] _t = await Http.Download($"{jackett.Toloka.host}/download.php?id={id}", proxy: proxyManager.Get(), cookie: cookie, referer: jackett.Toloka.host);
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string[] cats)
        {
            #region –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
            {
                consoleErrorLog("toloka");
                return null;
            }
            #endregion

            #region html
            var proxyManager = new ProxyManager("toloka", jackett.Toloka);

            string html = await Http.Get($"{jackett.Toloka.host}/tracker.php?prev_sd=0&prev_a=0&prev_my=0&prev_n=0&prev_shc=0&prev_shf=1&prev_sha=1&prev_cg=0&prev_ct=0&prev_at=0&prev_nt=0&prev_de=0&prev_nd=0&prev_tcs=1&prev_shs=0&f%5B%5D=-1&o=1&s=2&tm=-1&shf=1&sha=1&tcs=1&sns=-1&sds=-1&nm={HttpUtility.UrlEncode(query)}&pn=&send=%D0%9F%D0%BE%D1%88%D1%83%D0%BA", proxy: proxyManager.Get(), cookie: cookie, timeoutSeconds: jackett.timeoutSeconds);

            if (html != null && html.Contains("<html lang=\"uk\""))
            {
                if (!html.Contains(">–í–∏—Ö—ñ–¥"))
                {
                    consoleErrorLog("toloka");
                    return null;
                }
            }
            #endregion

            var torrents = new List<TorrentDetails>();

            foreach (string row in html.Split("</tr>"))
            {
                if (string.IsNullOrWhiteSpace(row) || Regex.IsMatch(row, "–ó–±—ñ—Ä –∫–æ—à—Ç—ñ–≤", RegexOptions.IgnoreCase))
                    continue;

                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string pattern, int index = 1)
                {
                    string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim());
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è
                string _createTime = Match("class=\"gensmall\">([0-9]{4}-[0-9]{2}-[0-9]{2})").Replace("-", ".");
                DateTime.TryParse(_createTime, out DateTime createTime);
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                string url = Match("class=\"topictitle genmed\"><a class=\"[^\"]+\" href=\"(t[0-9]+)\"");
                string title = Match("class=\"topictitle genmed\"><a [^>]+><b>([^<]+)</b></a>");
                string downloadid = Match("href=\"download.php\\?id=([0-9]+)\"");
                string tracker = Match("class=\"gen\" href=\"tracker.php\\?f=([0-9]+)");
                string _sid = Match("class=\"seedmed\"><b>([0-9]+)");
                string _pir = Match("class=\"leechmed\"><b>([0-9]+)");
                string sizeName = Match("class=\"gensmall\">([0-9\\.]+ (MB|GB))</td>");

                if (string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(downloadid) || string.IsNullOrWhiteSpace(tracker) || sizeName == "0 B")
                    continue;
                #endregion

                #region –ü–∞—Ä—Å–∏–º —Ä–∞–∑–¥–∞—á–∏
                int relased = 0;
                string name = null, originalname = null;

                if (tracker is "16" or "96" or "19" or "139" or "12" or "131" or "84" or "42")
                {
                    #region –§–∏–ª—å–º—ã
                    // –ù–µ–∑–≤–æ—Ä–æ—Ç–Ω—ñ—Å—Ç—å / Irr√©versible / Irreversible (2002) AVC Ukr/Fre | Sub Eng
                    var g = Regex.Match(title, "^([^/\\(\\[]+)/[^/\\(\\[]+/([^/\\(\\[]+) \\(([0-9]{4})(\\)|-)").Groups;
                    if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value) && !string.IsNullOrWhiteSpace(g[3].Value))
                    {
                        name = g[1].Value.Trim();
                        originalname = g[2].Value.Trim();

                        if (int.TryParse(g[3].Value, out int _yer))
                            relased = _yer;
                    }
                    else
                    {
                        // –ú—ñ–π —Ä—ñ–∫ —É –ù—å—é-–ô–æ—Ä–∫—É / My Salinger Year (2020) Ukr/Eng
                        g = Regex.Match(title, "^([^/\\(\\[]+)/([^/\\(\\[]+) \\(([0-9]{4})(\\)|-)").Groups;
                        if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value) && !string.IsNullOrWhiteSpace(g[3].Value))
                        {
                            name = g[1].Value.Trim();
                            originalname = g[2].Value.Trim();

                            if (int.TryParse(g[3].Value, out int _yer))
                                relased = _yer;
                        }
                        else
                        {
                            // –•—Ä–æ–Ω—ñ–∫–∞ –Ω–∞–¥—ñ–π —Ç–∞ —ñ–ª—é–∑—ñ–π. –î–∑–µ—Ä–∫–∞–ª–æ —ñ—Å—Ç–æ—Ä—ñ—ó. (83 —Å–µ—Ä—ñ—ó) (2001-2003) PDTVRip
                            g = Regex.Match(title, "^([^/\\(\\[]+) \\([^\\)]+\\) \\(([0-9]{4})(\\)|-)").Groups;
                            if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                            {
                                name = g[1].Value;

                                if (int.TryParse(g[2].Value, out int _yer))
                                    relased = _yer;
                            }
                            else
                            {
                                // –ë–µ—Ä–µ—Å—Ç–µ—á–∫–æ. –ë–∏—Ç–≤–∞ –∑–∞ –£–∫—Ä–∞—ó–Ω—É (2015-2016) DVDRip-AVC
                                g = Regex.Match(title, "^([^/\\(\\[]+) \\(([0-9]{4})(\\)|-)").Groups;
                                if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                                {
                                    name = g[1].Value;

                                    if (int.TryParse(g[2].Value, out int _yer))
                                        relased = _yer;
                                }
                            }
                        }
                    }
                    #endregion
                }
                else if (tracker is "32" or "173" or "174" or "44" or "230" or "226" or "227" or "228" or "229" or "127" or "124" or "125" or "132")
                {
                    #region –°–µ—Ä–∏–∞–ª—ã
                    // –ê—Ç–∞–∫–∞ —Ç–∏—Ç–∞–Ω—ñ–≤ (Attack on Titan) (–°–µ–∑–æ–Ω 1) / Shingeki no Kyojin (Season 1) (2013) BDRip 720—Ä
                    var g = Regex.Match(title, "^([^/\\(\\[]+) \\([^\\)]+\\) \\([^\\)]+\\) ?/([^/\\(\\[]+) \\([^\\)]+\\) \\(([0-9]{4})(\\)|-)").Groups;
                    if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value) && !string.IsNullOrWhiteSpace(g[3].Value))
                    {
                        name = g[1].Value.Trim();
                        originalname = g[2].Value.Trim();

                        if (int.TryParse(g[3].Value, out int _yer))
                            relased = _yer;
                    }
                    else
                    {
                        // –î—ñ–º –∑ –ø—Ä–∏—Å–ª—É–≥–æ—é (–°–µ–∑–æ–Ω 2, —Å–µ—Ä—ñ—ó 1-8) / Servant (Season 2, episodes 1-8) (2021) WEB-DLRip-AVC Ukr/Eng
                        g = Regex.Match(title, "^([^/\\(\\[]+) \\([^\\)]+\\) ?/([^/\\(\\[]+) \\([^\\)]+\\) \\(([0-9]{4})(\\)|-)").Groups;
                        if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value) && !string.IsNullOrWhiteSpace(g[3].Value))
                        {
                            name = g[1].Value.Trim();
                            originalname = g[2].Value.Trim();

                            if (int.TryParse(g[3].Value, out int _yer))
                                relased = _yer;
                        }
                        else
                        {
                            // –î–µ—Ç–µ–∫—Ç–∏–≤–Ω–µ –∞–≥–µ–Ω—Ç—Å—Ç–≤–æ –ø—Ä–µ–∫—Ä–∞—Å–Ω–∏—Ö —Ö–ª–æ–ø—á–∏–∫—ñ–≤ (08 –∑ 12) / Bishounen Tanteidan (2021) BDRip 1080p Ukr/Jap | Ukr Sub
                            g = Regex.Match(title, "^([^/\\(\\[]+) (\\(|\\[)[^\\)\\]]+(\\)|\\]) ?/([^/\\(\\[]+) \\(([0-9]{4})(\\)|-)").Groups;
                            if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[4].Value) && !string.IsNullOrWhiteSpace(g[5].Value))
                            {
                                name = g[1].Value.Trim();
                                originalname = g[4].Value.Trim();

                                if (int.TryParse(g[5].Value, out int _yer))
                                    relased = _yer;
                            }
                            else
                            {
                                // –Ø–π—Ü—è –î—Ä–∞–∫–æ–Ω–∞ / Dragon Ball (01-31 –∑ 153) (1986-1989) BDRip 1080p H.265
                                // –¢–æ–º–æ ‚Äî –¥—ñ–≤—á–∏–Ω–∞! / Tomo-chan wa Onnanoko! (–°–µ–∑–æ–Ω 1, —Å–µ—Ä—ñ—ó 01-02 –∑ 13) (2023) WEBDL 1080p H.265 Ukr/Jap | sub Ukr
                                g = Regex.Match(title, "^([^/\\(\\[]+)/([^/\\(\\[]+) \\([^\\)]+\\) \\(([0-9]{4})(\\)|-)").Groups;
                                if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value) && !string.IsNullOrWhiteSpace(g[3].Value))
                                {
                                    name = g[1].Value.Trim();
                                    originalname = g[2].Value.Trim();

                                    if (int.TryParse(g[3].Value, out int _yer))
                                        relased = _yer;
                                }
                                else
                                {
                                    // –õ—é–¥–∏–Ω–∞-–±–µ–Ω–∑–æ–ø–∏–ª–∞ / „ÉÅ„Çß„É≥„ÇΩ„Éº„Éû„É≥ /Chainsaw Man (—Å–µ–∑–æ–Ω 1, —Å–µ—Ä—ñ—ó 8 –∑ 12) (2022) WEBRip 1080p
                                    g = Regex.Match(title, "^([^/\\(\\[]+)/[^/\\(\\[]+/([^/\\(\\[]+) \\([^\\)]+\\) \\(([0-9]{4})(\\)|-)").Groups;
                                    if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value) && !string.IsNullOrWhiteSpace(g[3].Value))
                                    {
                                        name = g[1].Value.Trim();
                                        originalname = g[2].Value.Trim();

                                        if (int.TryParse(g[3].Value, out int _yer))
                                            relased = _yer;
                                    }
                                    else
                                    {
                                        // –ú–∞—Å—Ç–µ—Ä–®–µ—Ñ. 10 —Å–µ–∑–æ–Ω (1-18 –µ–ø—ñ–∑–æ–¥–∏) (2020) IPTVRip 400p
                                        g = Regex.Match(title, "^([^/\\(\\[]+) \\([^\\)]+\\) \\(([0-9]{4})(\\)|-)").Groups;
                                        if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                                        {
                                            name = g[1].Value.Trim();

                                            if (int.TryParse(g[2].Value, out int _yer))
                                                relased = _yer;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
                #endregion

                #region types
                string[] types = null;
                switch (tracker)
                {
                    case "16":
                    case "96":
                    case "42":
                        types = new string[] { "movie" };
                        break;
                    case "19":
                    case "139":
                    case "84":
                        types = new string[] { "multfilm" };
                        break;
                    case "32":
                    case "173":
                    case "124":
                        types = new string[] { "serial" };
                        break;
                    case "174":
                    case "44":
                    case "125":
                        types = new string[] { "multserial" };
                        break;
                    case "226":
                    case "227":
                    case "228":
                    case "229":
                    case "230":
                    case "12":
                    case "131":
                        types = new string[] { "docuserial", "documovie" };
                        break;
                    case "127":
                        types = new string[] { "anime" };
                        break;
                    case "132":
                        types = new string[] { "tvshow" };
                        break;
                }

                if (cats != null)
                {
                    if (types == null)
                        continue;

                    bool isok = false;
                    foreach (string cat in cats)
                    {
                        if (types.Contains(cat))
                            isok = true;
                    }

                    if (!isok)
                        continue;
                }
                #endregion

                int.TryParse(_sid, out int sid);
                int.TryParse(_pir, out int pir);

                torrents.Add(new TorrentDetails()
                {
                    types = types,
                    url = $"{jackett.Toloka.host}/{url}",
                    title = title,
                    sid = sid,
                    pir = pir,
                    sizeName = sizeName,
                    createTime = createTime,
                    parselink = $"{host}/toloka/parsemagnet?id={downloadid}",
                    name = name,
                    originalname = originalname,
                    relased = relased
                });
            }

            return torrents;
        }
        #endregion


        #region getCookie
        async static ValueTask<string> getCookie()
        {
            if (!string.IsNullOrEmpty(jackett.Toloka.cookie))
                return jackett.Toloka.cookie;

            string authKey = "Toloka:TakeLogin()";
            if (Startup.memoryCache.TryGetValue(authKey, out string _cookie))
                return _cookie;

            if (Startup.memoryCache.TryGetValue($"{authKey}:error", out _))
                return null;

            Startup.memoryCache.Set($"{authKey}:error", 0, TimeSpan.FromSeconds(20));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(jackett.timeoutSeconds);
                        client.MaxResponseContentBufferSize = 2000000; // 2MB
                        client.DefaultRequestHeaders.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36");

                        var postParams = new Dictionary<string, string>
                    {
                        { "username", jackett.Toloka.login.u },
                        { "password", jackett.Toloka.login.p },
                        { "autologin", "on" },
                        { "ssl", "on" },
                        { "redirect", "index.php?" },
                        { "login", "–í—Ö—ñ–¥" }
                    };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync($"{jackett.Toloka.host}/login.php", postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string toloka_sid = null, toloka_data = null;
                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrWhiteSpace(line))
                                            continue;

                                        if (line.Contains("toloka_sid="))
                                            toloka_sid = new Regex("toloka_sid=([^;]+)(;|$)").Match(line).Groups[1].Value;

                                        if (line.Contains("toloka_data="))
                                            toloka_data = new Regex("toloka_data=([^;]+)(;|$)").Match(line).Groups[1].Value;
                                    }

                                    if (!string.IsNullOrWhiteSpace(toloka_sid) && !string.IsNullOrWhiteSpace(toloka_data))
                                    {
                                        string cookie = $"toloka_sid={toloka_sid}; toloka_ssl=1; toloka_data={toloka_data};";
                                        Startup.memoryCache.Set(authKey, cookie, DateTime.Today.AddDays(1));
                                        return cookie;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch { }

            return null;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/NNMClubController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using System.Text;

namespace JacRed.Controllers
{
    [Route("nnmclub/[action]")]
    public class NNMClubController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string[] cats)
        {
            if (!jackett.NNMClub.enable || jackett.NNMClub.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cats));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string id)
        {
            if (!jackett.NNMClub.enable)
                return Content("disable");

            var proxyManager = new ProxyManager("nnmclub", jackett.NNMClub);

            #region html
            string html = await Http.Get($"{jackett.NNMClub.host}/forum/viewtopic.php?t=" + id, proxy: proxyManager.Get());
            string magnet = new Regex("href=\"(magnet:[^\"]+)\" title=\"–ü—Ä–∏–º–∞–≥–Ω–∏—Ç–∏—Ç—å—Å—è\"").Match(html ?? string.Empty).Groups[1].Value;

            if (html == null)
            {
                proxyManager.Refresh();
                return Content("error");
            }
            #endregion

            #region download torrent
            if (jackett.NNMClub.cookie != null || Cookie != null)
            {
                string downloadid = new Regex("href=\"download\\.php\\?id=([0-9]+)\"").Match(html).Groups[1].Value;
                if (!string.IsNullOrWhiteSpace(downloadid))
                {
                    byte[] _t = await Http.Download($"{jackett.NNMClub.host}/forum/download.php?id={downloadid}", proxy: proxyManager.Get(), cookie: jackett.NNMClub.cookie ?? Cookie, referer: jackett.NNMClub.host);
                    if (_t != null && BencodeTo.Magnet(_t) != null)
                        return File(_t, "application/x-bittorrent");
                }
            }
            #endregion

            if (string.IsNullOrEmpty(magnet))
            {
                proxyManager.Refresh();
                return Content("error");
            }

            return Redirect(magnet);
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string[] cats)
        {
            var torrents = new List<TorrentDetails>();
            var proxyManager = new ProxyManager("nnmclub", jackett.NNMClub);

            #region html
            string data = $"prev_sd=0&prev_a=0&prev_my=0&prev_n=0&prev_shc=0&prev_shf=1&prev_sha=1&prev_shs=0&prev_shr=0&prev_sht=0&o=1&s=2&tm=-1&shf=1&sha=1&ta=-1&sns=-1&sds=-1&nm={HttpUtility.UrlEncode(query, Encoding.GetEncoding(1251))}&pn=&submit=%CF%EE%E8%F1%EA";
            string html = await Http.Post($"{jackett.NNMClub.host}/forum/tracker.php", new System.Net.Http.StringContent(data, Encoding.UTF8, "application/x-www-form-urlencoded"), encoding: Encoding.GetEncoding(1251), proxy: proxyManager.Get(), timeoutSeconds: jackett.timeoutSeconds);

            if (html != null && html.Contains("NNM-Club</title>"))
            {
                if (!html.Contains(">–í—ã—Ö–æ–¥") && !string.IsNullOrWhiteSpace(jackett.NNMClub.login.u) && !string.IsNullOrWhiteSpace(jackett.NNMClub.login.p))
                    TakeLogin();
            }
            else if (html == null)
            {
                consoleErrorLog("nnmclub");
                proxyManager.Refresh();
                return null;
            }
            #endregion

            foreach (string row in html.Split("</tr>"))
            {
                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string pattern, int index = 1)
                {
                    string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim());
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                string url = Match("href=\"(viewtopic.php\\?t=[0-9]+)\"");
                string viewtopic = Match("href=\"viewtopic.php\\?t=([0-9]+)\"");
                string tracker = Match("class=\"gen\" href=\"tracker.php\\?f=([0-9]+)");

                string title = Match("class=\"genmed topictitle\" [^>]+><b>([^<]+)</b>");
                string _sid = Match("class=\"seedmed\"><b>([0-9]+)</b><");
                string _pir = Match("class=\"leechmed\"><b>([0-9]+)</b></td>");
                string sizeName = Match("class=\"gensmall\"><u>[^<]+</u> ([^<]+)</td>");

                if (string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(url) || string.IsNullOrWhiteSpace(viewtopic) || string.IsNullOrWhiteSpace(tracker))
                    continue;

                if (tracker == "913" && !title.Contains("UKR"))
                    continue;
                #endregion

                #region types
                string[] types = null;
                switch (tracker)
                {
                    case "270":
                    case "221":
                    case "882":
                    case "225":
                    case "227":
                    case "913":
                    case "218":
                    case "954":
                    case "1293":
                    case "1296":
                    case "1299":
                    case "682":
                    case "884":
                    case "693":
                        types = new string[] { "movie" };
                        break;
                    case "769":
                    case "768":
                        types = new string[] { "serial" };
                        break;
                    case "713":
                    case "576":
                    case "610":
                        types = new string[] { "docuserial", "documovie" };
                        break;
                    case "731":
                    case "733":
                    case "1329":
                    case "1330":
                    case "1331":
                    case "1332":
                    case "1336":
                    case "1337":
                    case "1338":
                    case "1339":
                        types = new string[] { "multfilm" };
                        break;
                    case "658":
                    case "232":
                        types = new string[] { "multserial" };
                        break;
                    case "623":
                    case "622":
                    case "621":
                    case "632":
                    case "627":
                    case "626":
                    case "625":
                    case "644":
                        types = new string[] { "anime" };
                        break;
                }

                if (cats != null)
                {
                    if (types == null)
                        continue;

                    bool isok = false;
                    foreach (string cat in cats)
                    {
                        if (types.Contains(cat))
                            isok = true;
                    }

                    if (!isok)
                        continue;
                }
                #endregion

                int.TryParse(_sid, out int sid);
                int.TryParse(_pir, out int pir);

                torrents.Add(new TorrentDetails()
                {
                    types = types,
                    url = $"{jackett.NNMClub.host}/{url}",
                    title = title,
                    sid = sid,
                    pir = pir,
                    sizeName = sizeName,
                    parselink = $"{host}/nnmclub/parsemagnet?id={viewtopic}",
                    createTime = tParse.ParseCreateTime(Match("title=\"–î–æ–±–∞–≤–ª–µ–Ω–æ\" class=\"gensmall\"><u>[0-9]+</u> ([0-9]{2}-[0-9]{2}-[0-9]{4}<br>[^<]+)</td>").Replace("<br>", " "), "dd-MM-yyyy HH:mm")
                });
            }

            return torrents;
        }
        #endregion


        #region Cookie / TakeLogin
        static string Cookie;

        async static void TakeLogin()
        {
            string authKey = "nnmclub:TakeLogin()";
            if (Startup.memoryCache.TryGetValue(authKey, out _))
                return;

            Startup.memoryCache.Set(authKey, 0, AppInit.conf.multiaccess ? TimeSpan.FromMinutes(2) : TimeSpan.FromSeconds(20));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(jackett.timeoutSeconds);
                        client.MaxResponseContentBufferSize = 2000000; // 2MB
                        client.DefaultRequestHeaders.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36");
                        client.DefaultRequestHeaders.Add("cache-control", "no-cache");
                        client.DefaultRequestHeaders.Add("dnt", "1");
                        client.DefaultRequestHeaders.Add("origin", jackett.NNMClub.host);
                        client.DefaultRequestHeaders.Add("pragma", "no-cache");
                        client.DefaultRequestHeaders.Add("referer", $"{jackett.NNMClub.host}/");
                        client.DefaultRequestHeaders.Add("upgrade-insecure-requests", "1");

                        var postParams = new Dictionary<string, string>
                    {
                        { "redirect", "%2F" },
                        { "username", jackett.NNMClub.login.u },
                        { "password", jackett.NNMClub.login.p },
                        { "autologin", "on" },
                        { "login", "%C2%F5%EE%E4" }
                    };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync($"{jackett.NNMClub.host}/forum/login.php", postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string data = null, sid = null;
                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrWhiteSpace(line))
                                            continue;

                                        if (line.Contains("phpbb2mysql_4_data="))
                                            data = new Regex("phpbb2mysql_4_data=([^;]+)(;|$)").Match(line).Groups[1].Value;

                                        if (line.Contains("phpbb2mysql_4_sid="))
                                            sid = new Regex("phpbb2mysql_4_sid=([^;]+)(;|$)").Match(line).Groups[1].Value;
                                    }

                                    if (!string.IsNullOrWhiteSpace(data) && !string.IsNullOrWhiteSpace(sid))
                                        Cookie = $"phpbb2mysql_4_data={data}; phpbb2mysql_4_sid={sid};";
                                }
                            }
                        }
                    }
                }
            }
            catch { }
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/BitruController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace JacRed.Controllers
{
    [Route("bitru/[action]")]
    public class BitruController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string[] cats)
        {
            if (!jackett.Bitru.enable || jackett.Bitru.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cats));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string id, bool usecache)
        {
            if (!jackett.Bitru.enable)
                return Content("disable");

            var proxyManager = new ProxyManager("bitru", jackett.Bitru);

            byte[] _t = await Http.Download($"{jackett.Bitru.host}/download.php?id={id}", referer: $"{jackett.Bitru}/details.php?id={id}", proxy: proxyManager.Get());
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            proxyManager.Refresh();
            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string[] cats)
        {
            #region html
            var proxyManager = new ProxyManager("bitru", jackett.Bitru);

            string html = await Http.Get($"{jackett.Bitru.host}/browse.php?s={HttpUtility.HtmlEncode(query)}&sort=&tmp=&cat=&subcat=&year=&country=&sound=&soundtrack=&subtitles=#content", proxy: proxyManager.Get(), timeoutSeconds: jackett.timeoutSeconds);

            if (html == null || !html.Contains("id=\"logo\""))
            {
                consoleErrorLog("bitru");
                proxyManager.Refresh();
                return null;
            }
            #endregion

            var torrents = new List<TorrentDetails>();

            foreach (string row in html.Split("<div class=\"b-title\"").Skip(1))
            {
                if (string.IsNullOrWhiteSpace(row) || row.Contains(">–ê–Ω–∏–º–µ</a>"))
                    continue;

                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string pattern, int index = 1)
                {
                    string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim());
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è
                DateTime createTime = default;

                if (row.Contains("<span>–°–µ–≥–æ–¥–Ω—è"))
                {
                    createTime = DateTime.Today;
                }
                else if (row.Contains("<span>–í—á–µ—Ä–∞"))
                {
                    createTime = DateTime.Today.AddDays(-1);
                }
                else
                {
                    createTime = tParse.ParseCreateTime(Match("<div class=\"ellips\">(<i [^>]+></i>)?<span>([0-9]{2} [^ ]+ [0-9]{4}) –≤ [0-9]{2}:[0-9]{2} –æ—Ç <a", 2), "dd.MM.yyyy");
                }
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                string url = Match("href=\"(details.php\\?id=[0-9]+)\"");
                string newsid = Match("href=\"details.php\\?id=([0-9]+)\"");
                string cat = Match("<a href=\"browse.php\\?tmp=(movie|serial)&");

                string title = Match("<div class=\"it-title\">([^<]+)</div>");
                string _sid = Match("<span class=\"b-seeders\">([0-9]+)");
                string _pir = Match("<span class=\"b-leechers\">([0-9]+)");
                string sizeName = Match("title=\"–†–∞–∑–º–µ—Ä\">([^<]+)</td>");

                if (string.IsNullOrWhiteSpace(cat) || string.IsNullOrWhiteSpace(newsid) || string.IsNullOrWhiteSpace(title))
                    continue;

                if (!title.ToLower().Contains(query.ToLower()))
                    continue;
                #endregion

                #region types
                string[] types = null;
                switch (cat)
                {
                    case "movie":
                        types = new string[] { "movie" };
                        break;
                    case "serial":
                        types = new string[] { "serial" };
                        break;
                }

                if (cats != null)
                {
                    if (types == null)
                        continue;

                    bool isok = false;
                    foreach (string c in cats)
                    {
                        if (types.Contains(c))
                            isok = true;
                    }

                    if (!isok)
                        continue;
                }
                #endregion

                int.TryParse(_sid, out int sid);
                int.TryParse(_pir, out int pir);

                torrents.Add(new TorrentDetails()
                {
                    types = types,
                    url = $"{jackett.Bitru.host}/{url}",
                    title = title,
                    sid = sid,
                    pir = pir,
                    sizeName = sizeName,
                    createTime = createTime,
                    parselink = $"{host}/bitru/parsemagnet?id={newsid}"
                });
            }

            return torrents;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/LostfilmController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;

namespace JacRed.Controllers
{
    [Route("lostfilm/[action]")]
    public class LostfilmController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query)
        {
            if (!jackett.Lostfilm.enable || string.IsNullOrEmpty(jackett.Lostfilm.cookie ?? jackett.Lostfilm.login.u) || jackett.Lostfilm.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string episodeid)
        {
            if (!jackett.Lostfilm.enable)
                return Content("disable");

            var _t = await getTorrent(episodeid);
            if (_t != null)
                return File(_t, "application/x-bittorrent");

            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query)
        {
            var proxyManager = new ProxyManager("lostfilm", jackett.Lostfilm);

            #region html
            bool validrq = false;
            string html = await Http.Get($"{jackett.Lostfilm.host}/search/?q={HttpUtility.UrlEncode(query)}", timeoutSeconds: jackett.timeoutSeconds, proxy: proxyManager.Get());

            if (html != null && html.Contains("onClick=\"FollowSerial("))
            {
                string serie = Regex.Match(html, "href=\"/series/([^\"]+)\" class=\"no-decoration\"").Groups[1].Value;
                if (!string.IsNullOrWhiteSpace(serie))
                {
                    html = await Http.Get($"{jackett.Lostfilm.host}/series/{serie}/seasons/", timeoutSeconds: jackett.timeoutSeconds);
                    if (html != null && html.Contains("LostFilm.TV"))
                        validrq = true;
                }
            }

            if (!validrq)
            {
                consoleErrorLog("lostfilm");
                return null;
            }
            #endregion

            var torrents = new List<TorrentDetails>();

            foreach (string row in html.Split("<tr>").Skip(1))
            {
                if (string.IsNullOrWhiteSpace(row))
                    continue;

                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string val, string pattern, int index = 1)
                {
                    string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(val).Groups[index].Value.Trim());
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                DateTime createTime = tParse.ParseCreateTime(Match(row, "data-released=\"([0-9]{2}\\.[0-9]{2}\\.[0-9]{4})\">([^<]+)</span>"), "dd.MM.yyyy");

                string url = Match(html, "href=\"/(series/[^/]+/seasons)\" class=\"item  active\">–ì–∏–¥ –ø–æ —Å–µ—Ä–∏—è–º</a>");
                string sinfo = Match(row, "title=\"–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–µ—Ä–∏–∏\">([^<]+)</td>");
                string name = Match(html, "<h1 class=\"title-ru\" itemprop=\"name\">([^<]+)</h1>");
                string originalname = Match(html, "<h2 class=\"title-en\" itemprop=\"alternativeHeadline\">([^<]+)</h2>");

                if (string.IsNullOrWhiteSpace(url) || string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(originalname) || string.IsNullOrWhiteSpace(sinfo))
                    continue;
                #endregion

                string episodeid = Match(row, "onclick=\"PlayEpisode\\('([0-9]+)'\\)\"");
                if (string.IsNullOrWhiteSpace(episodeid))
                    continue;

                torrents.Add(new TorrentDetails()
                {
                    types = new string[] { "serial" },
                    url = $"{jackett.Lostfilm.host}/{url}",
                    title = $"{name} / {originalname} / {sinfo} [{createTime.Year}, 1080p]",
                    sid = 1,
                    createTime = createTime,
                    parselink = $"{host}/lostfilm/parsemagnet?episodeid={episodeid}",
                    name = name,
                    originalname = originalname,
                    relased = createTime.Year
                });
            }

            return torrents;
        }
        #endregion


        #region getTorrent
        async Task<byte[]> getTorrent(string episodeid)
        {
            try
            {
                string cookie = await getCookie();
                if (string.IsNullOrEmpty(cookie))
                    return null;

                var proxyManager = new ProxyManager("lostfilm", jackett.Lostfilm);
                var proxy = proxyManager.Get();

                // –ü–æ–ª—É—á–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –ø–æ–∏—Å–∫
                string v_search = await Http.Get($"{jackett.Lostfilm.host}/v_search.php?a={episodeid}", proxy: proxy, cookie: cookie);
                string retreSearchUrl = new Regex("url=(\")?(https?://[^/]+/[^\"]+)").Match(v_search ?? "").Groups[2].Value.Trim();
                if (!string.IsNullOrWhiteSpace(retreSearchUrl))
                {
                    // –ó–∞–≥—Ä—É–∂–∞–µ–º HTML –ø–æ–∏—Å–∫–∞
                    string shtml = await Http.Get(retreSearchUrl, proxy: proxy, cookie: cookie);
                    if (!string.IsNullOrWhiteSpace(shtml))
                    {
                        var match = new Regex("<div class=\"inner-box--link main\"><a href=\"([^\"]+)\">([^<]+)</a></div>").Match(Regex.Replace(shtml, "[\n\r\t]+", ""));
                        while (match.Success)
                        {
                            if (Regex.IsMatch(match.Groups[2].Value, "(2160p|2060p|1440p|1080p|720p)", RegexOptions.IgnoreCase))
                            {
                                string torrentFile = match.Groups[1].Value;
                                string quality = Regex.Match(match.Groups[2].Value, "(2160p|2060p|1440p|1080p|720p)").Groups[1].Value;

                                if (!string.IsNullOrWhiteSpace(torrentFile) && !string.IsNullOrWhiteSpace(quality))
                                {
                                    byte[] torrent = await Http.Download(torrentFile, referer: $"{jackett.Lostfilm.host}/", proxy: proxy, cookie: cookie);
                                    if (BencodeTo.Magnet(torrent) != null)
                                        return torrent;
                                }
                            }

                            match = match.NextMatch();
                        }
                    }
                }
            }
            catch { }

            return null;
        }
        #endregion

        #region getCookie
        async static ValueTask<string> getCookie()
        {
            if (!string.IsNullOrEmpty(jackett.Lostfilm.cookie))
                return jackett.Lostfilm.cookie;

            string authKey = "Lostfilm:TakeLogin()";
            if (Startup.memoryCache.TryGetValue(authKey, out string _cookie))
                return _cookie;

            if (Startup.memoryCache.TryGetValue($"{authKey}:error", out _))
                return null;

            Startup.memoryCache.Set($"{authKey}:error", 0, TimeSpan.FromSeconds(20));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(jackett.timeoutSeconds);
                        client.MaxResponseContentBufferSize = 2000000; // 2MB
                        client.DefaultRequestHeaders.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36");

                        var postParams = new Dictionary<string, string>
                    {
                        { "act", "users" },
                        { "type", "login" },
                        { "mail", jackett.Lostfilm.login.u },
                        { "pass", jackett.Lostfilm.login.p },
                        { "need_captcha", "" },
                        { "captcha", "" },
                        { "rem", "1" }
                    };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync($"{jackett.Lostfilm.host}/ajaxik.users.php", postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string cookie = string.Empty;
                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrWhiteSpace(line))
                                            continue;

                                        cookie += " " + line;
                                    }

                                    if (cookie.Contains("lf_session=") && cookie.Contains("lnk_uid="))
                                    {
                                        cookie = Regex.Replace(cookie.Trim(), ";$", "");
                                        Startup.memoryCache.Set(authKey, cookie, DateTime.Today.AddDays(1));
                                        return cookie;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch { }

            return null;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/SelezenController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;

namespace JacRed.Controllers
{
    [Route("selezen/[action]")]
    public class SelezenController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query)
        {
            if (!jackett.Selezen.enable || string.IsNullOrEmpty(jackett.Selezen.cookie ?? jackett.Selezen.login.u) || jackett.Selezen.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string url)
        {
            if (!jackett.Selezen.enable)
                return Content("disable");

            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
                return Content("cookie == null");

            var proxyManager = new ProxyManager("selezen", jackett.Selezen);

            string html = await Http.Get(url, cookie: cookie, proxy: proxyManager.Get());
            string magnet = new Regex("href=\"(magnet:[^\"]+)\"").Match(html ?? string.Empty).Groups[1].Value;

            if (html == null)
                return Content("error");

            #region Download
            if (jackett.Selezen.priority == "torrent")
            {
                string id = new Regex("href=\"/index.php\\?do=download&id=([0-9]+)").Match(html).Groups[1].Value;
                if (!string.IsNullOrWhiteSpace(id))
                {
                    var _t = await Http.Download($"{jackett.Selezen.host}/index.php?do=download&id={id}", cookie: cookie, referer: jackett.Selezen.host, timeoutSeconds: 10);
                    if (_t != null && BencodeTo.Magnet(_t) != null)
                        return File(_t, "application/x-bittorrent");
                }
            }
            #endregion

            if (string.IsNullOrWhiteSpace(magnet))
                return Content("error");

            return Redirect(magnet);
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query)
        {
            #region –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
            {
                consoleErrorLog("selezen");
                return null;
            }
            #endregion

            #region html
            var proxyManager = new ProxyManager("selezen", jackett.Selezen);

            string html = await Http.Post($"{jackett.Selezen.host}/index.php?do=search", $"do=search&subaction=search&search_start=0&full_search=0&result_from=1&story={HttpUtility.UrlEncode(query)}&titleonly=0&searchuser=&replyless=0&replylimit=0&searchdate=0&beforeafter=after&sortby=date&resorder=desc&showposts=0&catlist%5B%5D=9", proxy: proxyManager.Get(), cookie: cookie, timeoutSeconds: jackett.timeoutSeconds);

            if (html != null && html.Contains("dle_root"))
            {
                if (!html.Contains($">{jackett.Selezen.login.u}<"))
                {
                    consoleErrorLog("selezen");
                    return null;
                }
            }
            #endregion

            var torrents = new List<TorrentDetails>();

            foreach (string row in html.Split("class=\"card radius-10 overflow-hidden\"").Skip(1))
            {
                if (string.IsNullOrWhiteSpace(row) || row.Contains(">–ê–Ω–∏–º–µ</a>") || row.Contains(" [S0"))
                    continue;

                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string pattern, int index = 1)
                {
                    string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim());
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                var g = Regex.Match(row, "<a href=\"(https?://[^<]+)\"><h4 class=\"card-title\">([^<]+)</h4>").Groups;
                string url = g[1].Value;
                string title = g[2].Value;

                string _sid = Match("<i class=\"bx bx-chevrons-up\"></i>([0-9 ]+)").Trim();
                string _pir = Match("<i class=\"bx bx-chevrons-down\"></i>([0-9 ]+)").Trim();
                string sizeName = Match("<span class=\"bx bx-download\"></span>([^<]+)</a>").Trim();
                DateTime createTime = tParse.ParseCreateTime(Match("class=\"bx bx-calendar\"></span> ?([0-9]{2}\\.[0-9]{2}\\.[0-9]{4} [0-9]{2}:[0-9]{2})</a>"), "dd.MM.yyyy HH:mm");

                if (string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(url))
                    continue;
                #endregion

                #region types
                string[] types = new string[] { "movie" };
                if (row.Contains(">–ú—É–ª—å—Ç") || row.Contains(">–º—É–ª—å—Ç"))
                    types = new string[] { "multfilm" };
                #endregion

                int.TryParse(_sid, out int sid);
                int.TryParse(_pir, out int pir);

                torrents.Add(new TorrentDetails()
                {
                    types = types,
                    url = url,
                    title = title,
                    sid = sid,
                    pir = pir,
                    sizeName = sizeName,
                    createTime = createTime,
                    parselink = $"{host}/selezen/parsemagnet?url={HttpUtility.UrlEncode(url)}"
                });
            }

            return torrents;
        }
        #endregion


        #region getCookie
        async static ValueTask<string> getCookie()
        {
            if (!string.IsNullOrEmpty(jackett.Selezen.cookie))
                return jackett.Selezen.cookie;

            string authKey = "selezen:TakeLogin()";
            if (Startup.memoryCache.TryGetValue(authKey, out string _cookie))
                return _cookie;

            if (Startup.memoryCache.TryGetValue($"{authKey}:error", out _))
                return null;

            Startup.memoryCache.Set($"{authKey}:error", 0, TimeSpan.FromSeconds(20));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(jackett.timeoutSeconds);
                        client.MaxResponseContentBufferSize = 2000000; // 2MB
                        client.DefaultRequestHeaders.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36");

                        var postParams = new Dictionary<string, string>
                    {
                        { "login_name", jackett.Selezen.login.u },
                        { "login_password", jackett.Selezen.login.p },
                        { "login_not_save", "1" },
                        { "login", "submit" }
                    };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync(jackett.Selezen.host, postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string PHPSESSID = null;
                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrWhiteSpace(line))
                                            continue;

                                        if (line.Contains("PHPSESSID="))
                                            PHPSESSID = new Regex("PHPSESSID=([^;]+)(;|$)").Match(line).Groups[1].Value;
                                    }

                                    if (!string.IsNullOrWhiteSpace(PHPSESSID))
                                    {
                                        string cookie = $"PHPSESSID={PHPSESSID}; _ym_isad=2;";
                                        Startup.memoryCache.Set(authKey, cookie, DateTime.Today.AddDays(1));
                                        return cookie;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch { }

            return null;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/AniLibriaController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using JacRed.Models.AniLibria;

namespace JacRed.Controllers
{
    [Route("anilibria/[action]")]
    public class AniLibriaController : JacBaseController
    {
        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string url, string code)
        {
            if (!jackett.Anilibria.enable || jackett.Anilibria.showdown)
                return Content("disable");

            var proxyManager = new ProxyManager("anilibria", jackett.Anilibria);

            byte[] _t = await Http.Download($"{jackett.Anilibria.host}/{url}", referer: $"{jackett.Anilibria.host}/release/{code}.html", proxy: proxyManager.Get());
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            proxyManager.Refresh();
            return Content("error");
        }
        #endregion

        #region parsePage
        async public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query)
        {
            if (!jackett.Anilibria.enable)
                return false;

            var proxyManager = new ProxyManager("anilibria", jackett.Anilibria);

            var roots = await Http.Get<List<RootObject>>("https://api.anilibria.tv/v2/searchTitles?search=" + HttpUtility.UrlEncode(query), timeoutSeconds: jackett.timeoutSeconds, proxy: proxyManager.Get(), IgnoreDeserializeObject: true);
            if (roots == null || roots.Count == 0)
            {
                consoleErrorLog("anilibria");
                proxyManager.Refresh();
                return false;
            }

            foreach (var root in roots)
            {
                DateTime createTime = new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(root.last_change > root.updated ? root.last_change : root.updated);

                foreach (var torrent in root.torrents.list)
                {
                    if (string.IsNullOrWhiteSpace(root.code) || 480 >= torrent.quality.resolution && string.IsNullOrWhiteSpace(torrent.quality.encoder) && string.IsNullOrWhiteSpace(torrent.url))
                        continue;

                    torrents.Add(new TorrentDetails()
                    {
                        trackerName = "anilibria.tv",
                        types = new string[] { "anime" },
                        url = $"{jackett.Anilibria.host}/release/{root.code}.html",
                        title = $"{root.names.ru} / {root.names.en} {root.season.year} (s{root.season.code}, e{torrent.series.@string}) [{torrent.quality.@string}]",
                        sid = torrent.seeders,
                        pir = torrent.leechers,
                        createTime = createTime,
                        parselink = $"{host}/anilibria/parsemagnet?url={HttpUtility.UrlEncode(torrent.url)}&code={root.code}",
                        sizeName = tParse.BytesToString(torrent.total_size),
                        name = root.names.ru,
                        originalname = root.names.en,
                        relased = root.season.year
                    });
                }
            }


            return true;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/TorrentByController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace JacRed.Controllers
{
    [Route("torrentby/[action]")]
    public class TorrentByController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string cat)
        {
            if (!jackett.TorrentBy.enable || jackett.TorrentBy.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cat));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(int id, string magnet)
        {
            if (!jackett.TorrentBy.enable || jackett.TorrentBy.priority != "torrent")
                return Content("disable");

            var proxyManager = new ProxyManager("torrentby", jackett.TorrentBy);

            var _t = await Http.Download($"{jackett.TorrentBy.host}/d.php?id={id}", referer: jackett.TorrentBy.host, proxy: proxyManager.Get());
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            proxyManager.Refresh();

            if (string.IsNullOrEmpty(magnet))
                return Content("empty");

            return Redirect(magnet);
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string cat)
        {
            #region html
            var proxyManager = new ProxyManager("torrentby", jackett.TorrentBy);

            string html = await Http.Get($"{jackett.TorrentBy.host}/search/?search={HttpUtility.UrlEncode(query)}&category={cat}", proxy: proxyManager.Get(), timeoutSeconds: jackett.timeoutSeconds);

            if (html == null || !html.Contains("id=\"find\""))
            {
                consoleErrorLog("torrentby");
                proxyManager.Refresh();
                return null;
            }
            #endregion

            var doc = new HtmlDocument();
            doc.LoadHtml(html.Replace("&nbsp;", " "));

            var nodes = doc.DocumentNode.SelectNodes("//tr[contains(@class, 'ttable_col')]");
            if (nodes == null || nodes.Count == 0)
                return null;

            var torrents = new List<TorrentDetails>();

            foreach (var row in nodes)
            {
                var hc = new HtmlCommon(row);

                #region –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è
                DateTime createTime = default;

                if (row.InnerHtml.Contains("–°–µ–≥–æ–¥–Ω—è"))
                {
                    createTime = DateTime.Today;
                }
                else if (row.InnerHtml.Contains("–í—á–µ—Ä–∞"))
                {
                    createTime = DateTime.Today.AddDays(-1);
                }
                else
                {
                    string _createTime = hc.Match(">([0-9]{4}-[0-9]{2}-[0-9]{2})</td>").Replace("-", " ");
                    DateTime.TryParseExact(_createTime, "yyyy MM dd", new CultureInfo("ru-RU"), DateTimeStyles.None, out createTime);
                }
                #endregion

                string url = hc.NodeValue(".//a[@name='search_select']", "href");
                string viewtopic = Regex.Match(url, "^/([0-9]+)").Groups[1].Value;

                string title = hc.NodeValue(".//a[@name='search_select']");
                title = Regex.Replace(title, "<[^>]+>", "");

                string magnet = hc.Match("href=\"(magnet:\\?xt=[^\"]+)\"");

                if (string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(magnet))
                    continue;

                torrents.Add(new TorrentDetails()
                {
                    url = $"{jackett.TorrentBy.host}/{url.Remove(0, 1)}",
                    title = title,
                    sid = HtmlCommon.Integer(hc.NodeValue(".//font[@color='green']")),
                    pir = HtmlCommon.Integer(hc.NodeValue(".//font[@color='red']")),
                    sizeName = hc.NodeValue(".//td[contains(text(), 'GB') or contains(text(), 'MB')]"),
                    magnet = jackett.TorrentBy.priority == "torrent" ? null : magnet,
                    parselink = jackett.TorrentBy.priority == "torrent" ? $"{host}/torrentby/parsemagnet?id={viewtopic}&magnet={HttpUtility.UrlEncode(magnet)}" : null,
                    createTime = createTime
                });
            }

            return torrents;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/AnifilmController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace JacRed.Controllers
{
    [Route("anifilm/[action]")]
    public class AnifilmController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query)
        {
            if (!jackett.Anifilm.enable || jackett.Anifilm.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string url)
        {
            if (!jackett.Anifilm.enable)
                return Content("disable");

            var proxyManager = new ProxyManager("anifilm", jackett.Anifilm);

            var fullNews = await Http.Get($"{jackett.Anifilm.host}/{url}", proxy: proxyManager.Get());
            if (fullNews == null)
                return Content("error");

            string tid = null;
            string[] releasetorrents = fullNews.Split("<li class=\"release__torrents-item\">");

            string _rnews = releasetorrents.FirstOrDefault(i => i.Contains("href=\"/releases/download-torrent/") && i.Contains(" 1080p "));
            if (!string.IsNullOrWhiteSpace(_rnews))
                tid = Regex.Match(_rnews, "href=\"/(releases/download-torrent/[0-9]+)\">—Å–∫–∞—á–∞—Ç—å</a>").Groups[1].Value;

            if (string.IsNullOrWhiteSpace(tid))
                tid = Regex.Match(fullNews, "href=\"/(releases/download-torrent/[0-9]+)\">—Å–∫–∞—á–∞—Ç—å</a>").Groups[1].Value;

            if (!string.IsNullOrWhiteSpace(tid))
            {
                var _t = await Http.Download($"{jackett.Anifilm.host}/{tid}", referer: $"{jackett.Anifilm.host}/", proxy: proxyManager.Get());
                if (_t != null && BencodeTo.Magnet(_t) != null)
                    return File(_t, "application/x-bittorrent");
            }

            proxyManager.Refresh();
            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query)
        {
            #region html
            var proxyManager = new ProxyManager("anifilm", jackett.Anifilm);

            string html = await Http.Get($"{jackett.Anifilm.host}/releases?title={HttpUtility.UrlEncode(query)}", timeoutSeconds: jackett.timeoutSeconds, proxy: proxyManager.Get());

            if (html == null || !html.Contains("id=\"ui-components\""))
            {
                consoleErrorLog("anifilm");
                proxyManager.Refresh();
                return null;
            }
            #endregion

            var torrents = new List<TorrentDetails>();

            if (html.Contains("class=\"releases__item\""))
            {
                foreach (string row in html.Split("class=\"releases__item\"").Skip(1))
                {
                    if (string.IsNullOrWhiteSpace(row))
                        continue;

                    #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                    string Match(string pattern, int index = 1)
                    {
                        string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim());
                        res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                        return res.Trim();
                    }
                    #endregion

                    #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                    string url = Match("<a href=\"/(releases/[^\"]+)\"");
                    string name = Match("<a class=\"releases__title-russian\" [^>]+>([^<]+)</a>");
                    string originalname = Match("<span class=\"releases__title-original\">([^<]+)</span>");
                    string episodes = Match("([0-9]+(-[0-9]+)?) –∏–∑ [0-9]+ —ç–ø.,");

                    if (string.IsNullOrWhiteSpace(url) || string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(originalname))
                        continue;

                    int.TryParse(Match("<a href=\"/releases/releases/[^\"]+\">([0-9]{4})</a> –≥\\."), out int relased);

                    string title = $"{name} / {originalname}";

                    if (!string.IsNullOrWhiteSpace(episodes))
                        title += $" ({episodes})";

                    var createTime = DateTime.Now.AddYears(-1);

                    if (relased > 0)
                    {
                        title += $" [{relased}]";
                        createTime = tParse.ParseCreateTime($"01.01.{relased}", "dd.MM.yyyy");
                    }
                    #endregion

                    torrents.Add(new TorrentDetails()
                    {
                        types = new string[] { "anime" },
                        url = $"{jackett.Anifilm.host}/{url}",
                        title = title,
                        sid = 1,
                        createTime = createTime,
                        parselink = $"{host}/anifilm/parsemagnet?url={HttpUtility.UrlEncode(url)}",
                        name = name,
                        originalname = originalname,
                        relased = relased
                    });
                }
            }
            else
            {
                string url = Regex.Match(html, "property=\"og:url\" content=\"https?://[^/]+/([^\"]+)\"").Groups[1].Value;
                string name = Regex.Match(html, "itemprop=\"name\">([^<]+)").Groups[1].Value;
                string alternative = Regex.Match(html, "itemprop=\"alternativeHeadline\">([^<]+)").Groups[1].Value;

                if (!string.IsNullOrEmpty(name))
                {
                    torrents.Add(new TorrentDetails()
                    {
                        types = new string[] { "anime" },
                        url = $"{jackett.Anifilm.host}/{url}",
                        title = name + (!string.IsNullOrEmpty(alternative) ? $" / {alternative}" : ""),
                        sid = 1,
                        parselink = $"{host}/anifilm/parsemagnet?url={HttpUtility.UrlEncode(url)}"
                    });
                }
            }

            return torrents;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/BigFanGroup.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace JacRed.Controllers
{
    [Route("bigfangroup/[action]")]
    public class BigFanGroup : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string[] cats)
        {
            if (!jackett.BigFanGroup.enable || jackett.BigFanGroup.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cats));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string id)
        {
            if (!jackett.BigFanGroup.enable)
                return Content("disable");

            var proxyManager = new ProxyManager("bigfangroup", jackett.BigFanGroup);

            var _t = await Http.Download($"{jackett.BigFanGroup.host}/download.php?id={id}", proxy: proxyManager.Get(), referer: jackett.BigFanGroup.host);
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string[] cats)
        {
            var torrents = new List<TorrentDetails>();
            var proxyManager = new ProxyManager("bigfangroup", jackett.BigFanGroup);

            #region –ö–µ—à html
            string html = await Http.Get($"{jackett.BigFanGroup.host}/browse.php?search=" + HttpUtility.UrlEncode(query), proxy: proxyManager.Get(), timeoutSeconds: jackett.timeoutSeconds);

            if (html == null || !html.Contains("id=\"searchinput\""))
            {
                consoleErrorLog("bigfangroup");
                return null;
            }
            #endregion

            var doc = new HtmlDocument();
            doc.LoadHtml(html.Replace("&nbsp;", " "));

            var nodes = doc.DocumentNode.SelectNodes("//tbody//tr");
            if (nodes == null || nodes.Count == 0)
                return null;

            foreach (var row in nodes)
            {
                var hc = new HtmlCommon(row);

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                string title = hc.NodeValue(".//a//b");

                DateTime createTime = tParse.ParseCreateTime(hc.NodeValue(".//img[@src='pic/time.png']", "title").Split(" –≤")[0], "dd.MM.yyyy");
                string viewtopic = hc.Match("href=\"details.php\\?id=([0-9]+)");
                string tracker = hc.Match("href=\"browse.php\\?cat=([0-9]+)");
                string sid = hc.NodeValue(".//font[@color='#000000']");
                string pir = hc.Match("todlers=[0-9]+\">([0-9]+)</a>");
                string sizeName = hc.NodeValue(".//td[contains(text(), 'GB') or contains(text(), 'MB')]");

                if (string.IsNullOrEmpty(viewtopic) || string.IsNullOrEmpty(tracker) || string.IsNullOrEmpty(title) || title.Contains(" | –ö–ü–ö"))
                    continue;
                #endregion

                #region types
                string[] types = null;
                switch (tracker)
                {
                    case "13":
                    case "52":
                    case "33":
                    case "48":
                    case "21":
                    case "39":
                    case "18":
                    case "24":
                    case "36":
                    case "53":
                    case "19":
                    case "31":
                    case "29":
                    case "27":
                    case "22":
                    case "26":
                    case "23":
                    case "30":
                        types = new string[] { "movie" };
                        break;
                    case "12":
                    case "20":
                    case "47":
                        types = new string[] { "multfilm" };
                        types = new string[] { "multserial" };
                        break;
                    case "11":
                        types = new string[] { "serial" };
                        break;
                    case "49":
                    case "32":
                    case "28":
                        types = new string[] { "docuserial", "documovie" };
                        break;
                    case "25":
                        types = new string[] { "tvshow" };
                        break;
                }

                if (cats != null)
                {
                    if (types == null)
                        continue;

                    bool isok = false;
                    foreach (string cat in cats)
                    {
                        if (types.Contains(cat))
                            isok = true;
                    }

                    if (!isok)
                        continue;
                }
                #endregion

                torrents.Add(new TorrentDetails()
                {
                    types = types,
                    url = $"{jackett.BigFanGroup.host}/forum/viewtopic.php?t={viewtopic}",
                    title = title,
                    sid = HtmlCommon.Integer(sid),
                    pir = HtmlCommon.Integer(pir),
                    sizeName = sizeName,
                    createTime = createTime,
                    parselink = $"{host}/bigfangroup/parsemagnet?id={viewtopic}"
                });
            }

            return torrents;
        }
        #endregion
    }
}

```

## File: JacRed/Engine/JacBaseController.cs
```
Ôªøusing Jackett;
using JacRed.Models.AppConf;

namespace JacRed.Engine
{
    public class JacBaseController : BaseController
    {
        public static RedConf red => ModInit.conf.Red;

        public static JacConf jackett => ModInit.conf.Jackett;


        async public static Task<bool> Joinparse(ConcurrentBag<TorrentDetails> torrents, Func<ValueTask<List<TorrentDetails>>> parse)
        {
            var result = await parse();

            if (result != null && result.Count > 0)
            {
                foreach (TorrentDetails torrent in result)
                    torrents.Add(torrent);

                return true;
            }

            return false;
        }

        public static void consoleErrorLog(string plugin)
        {
            Console.WriteLine($"JacRed: InternalServerError - {plugin}");
        }
    }
}

```

## File: JacRed/Engine/JsonStream.cs
```
Ôªøusing Newtonsoft.Json;
using System.IO.Compression;

namespace JacRed.Engine.CORE
{
    public static class JsonStream
    {
        #region Read
        public static T Read<T>(string path)
        {
            try
            {
                var settings = new JsonSerializerSettings
                {
                    Error = (se, ev) => { ev.ErrorContext.Handled = true; }
                };

                var serializer = JsonSerializer.Create(settings);

                using (Stream file = new GZipStream(File.OpenRead(path), CompressionMode.Decompress))
                {
                    using (var sr = new StreamReader(file))
                    {
                        using (var jsonTextReader = new JsonTextReader(sr))
                        {
                            return serializer.Deserialize<T>(jsonTextReader);
                        }
                    }
                }
            }
            catch { return default; }
        }
        #endregion

        #region Write
        public static void Write(string path, object db)
        {
            try
            {
                //var settings = new JsonSerializerSettings()
                //{
                //    Formatting = Formatting.Indented
                //};

                var serializer = JsonSerializer.Create(); // settings

                using (var sw = new StreamWriter(new GZipStream(File.OpenWrite(path), CompressionMode.Compress)))
                {
                    using (var jsonTextWriter = new JsonTextWriter(sw))
                    {
                        serializer.Serialize(jsonTextWriter, db);
                    }
                }
            }
            catch { }
        }
        #endregion
    }
}

```

## File: JacRed/Engine/WebApi.cs
```
Ôªøusing Jackett;
using Newtonsoft.Json.Linq;
using System.Text;
using Shared.Models.JacRed.Tracks;

namespace JacRed.Engine
{
    public static class WebApi
    {
        #region Indexers
        async public static Task<List<TorrentDetails>> Indexers(string query, string title, string title_original, int year, int is_serial, Dictionary<string, string> category)
        {
            var queryString = new StringBuilder();

            if (!string.IsNullOrEmpty(title))
                queryString.Append($"&title={HttpUtility.UrlEncode(title)}");

            if (!string.IsNullOrEmpty(title_original))
                queryString.Append($"&title_original={HttpUtility.UrlEncode(title_original)}");

            if (year > 0)
                queryString.Append($"&year={year}");

            if (is_serial > 0)
                queryString.Append($"&is_serial={is_serial}");

            if (category != null && category.Count > 0)
                queryString.Append($"&category[]={category.First().Value}");

            var root = await Http.Get<JObject>($"{ModInit.conf.webApiHost}/api/v2.0/indexers/all/results?query={HttpUtility.UrlEncode(query)}" + queryString.ToString(), timeoutSeconds: 8);
            if (root == null)
                return new List<TorrentDetails>();

            var results = root.GetValue("Results")?.ToObject<JArray>();
            if (results == null || results.Count == 0)
                return new List<TorrentDetails>();

            var torrents = new List<TorrentDetails>(results.Count);

            foreach (var torrent in results)
            {
                try
                {
                    string name = torrent.Value<string>("Title");
                    string tracker = torrent.Value<string>("Tracker");

                    if (ModInit.conf.Red.trackers != null)
                    {
                        if (!tracker.Contains(","))
                        {
                            if (!ModInit.conf.Red.trackers.Contains(tracker))
                                continue;
                        }
                        else
                        {
                            /*
                             * –≠—Ç–æ—Ç –∫–æ–¥ —Ñ–∏–ª—å—Ç—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤ –ø–æ —Å–ø–∏—Å–∫—É —Ä–∞–∑—Ä–µ—à—ë–Ω–Ω—ã—Ö —Ç—Ä–µ–∫–µ—Ä–æ–≤, –∫–æ—Ç–æ—Ä—ã–π —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ ModInit.conf.Red.trackers. 
                             * –ï—Å–ª–∏ —É —Ç–æ—Ä—Ä–µ–Ω—Ç–∞ –≤ –ø–æ–ª–µ Tracker —É–∫–∞–∑–∞–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç—Ä–µ–∫–µ—Ä–æ–≤ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, —Ç–æ –æ–Ω –±—É–¥–µ—Ç –¥–æ–ø—É—â–µ–Ω —Ç–æ–ª—å–∫–æ –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –∏–∑ —ç—Ç–∏—Ö —Ç—Ä–µ–∫–µ—Ä–æ–≤ –µ—Å—Ç—å –≤ —Ä–∞–∑—Ä–µ—à—ë–Ω–Ω–æ–º —Å–ø–∏—Å–∫–µ.
                             */
                            var trackers = tracker.Split(',');
                            if (!ModInit.conf.Red.trackers.Any(t => trackers.Contains(t)))
                                continue;
                        }
                    }

                    if (!string.IsNullOrEmpty(ModInit.conf.filter) && !Regex.IsMatch(name, ModInit.conf.filter, RegexOptions.IgnoreCase))
                        continue;

                    if (!string.IsNullOrEmpty(ModInit.conf.filter_ignore) && Regex.IsMatch(name, ModInit.conf.filter_ignore, RegexOptions.IgnoreCase))
                        continue;

                    torrents.Add(new TorrentDetails()
                    {
                        trackerName = tracker,
                        url = torrent.Value<string>("Details"),
                        title = name,
                        sid = torrent.Value<int>("Seeders"),
                        pir = torrent.Value<int>("Peers"),
                        size = torrent.Value<double>("Size"),
                        magnet = torrent.Value<string>("MagnetUri"),
                        createTime = torrent.Value<DateTime>("PublishDate"),
                        ffprobe = torrent["ffprobe"]?.ToObject<List<ffStream>>()
                    });
                }
                catch { }
            }

            return torrents;
        }
        #endregion

        #region Api
        public static Task<List<TorrentDetails>> Api(string search)
        {
            return Indexers(search, null, null, 0, 0, null);
        }
        #endregion
    }
}

```

## File: JacRed/Engine/SyncCron.cs
```
Ôªøusing Jackett;
using JacRed.Models.Sync;

namespace JacRed.Engine
{
    public static class SyncCron
    {
        static long lastsync = -1;

        async public static Task Run()
        {
            bool reset = true;
            await Task.Delay(TimeSpan.FromMinutes(2));

            DateTime lastSave = DateTime.Now;

            while (true)
            {
                try
                {
                    if (File.Exists(@"C:\ProgramData\lampac\disablesync"))
                        break;

                    if (ModInit.conf.typesearch == "red" && !string.IsNullOrWhiteSpace(ModInit.conf.Red.syncapi))
                    {
                        if (lastsync == -1 && File.Exists("cache/jacred/lastsync.txt"))
                            lastsync = long.Parse(File.ReadAllText("cache/jacred/lastsync.txt"));

                        var root = await Http.Get<RootObject>($"{ModInit.conf.Red.syncapi}/sync/fdb/torrents?time={lastsync}", timeoutSeconds: 300, MaxResponseContentBufferSize: 100_000_000, weblog: false);

                        if (root?.collections == null)
                        {
                            if (reset)
                            {
                                reset = false;
                                await Task.Delay(TimeSpan.FromMinutes(1));
                                continue;
                            }
                        }
                        else if (root.collections.Count > 0)
                        {
                            reset = true;
                            foreach (var collection in root.collections)
                            {
                                bool updateMasterDb = false;

                                using (var fdb = FileDB.Open(collection.Key, empty: true))
                                {
                                    foreach (var torrent in collection.Value.torrents)
                                    {
                                        if (torrent.Value.types == null || torrent.Value.types.Contains("sport"))
                                            continue;

                                        fdb.Database.AddOrUpdate(torrent.Key, torrent.Value, (k, v) => torrent.Value);
                                        updateMasterDb = true;
                                    }
                                }

                                if (updateMasterDb)
                                {
                                    if (FileDB.masterDb.ContainsKey(collection.Key))
                                    {
                                        FileDB.masterDb[collection.Key] = collection.Value.time;
                                    }
                                    else
                                    {
                                        FileDB.masterDb.TryAdd(collection.Key, collection.Value.time);
                                    }
                                }
                            }

                            lastsync = root.collections.Last().Value.fileTime;

                            if (root.nextread)
                            {
                                if (DateTime.Now > lastSave.AddMinutes(5))
                                {
                                    lastSave = DateTime.Now;
                                    FileDB.SaveChangesToFile();
                                    File.WriteAllText("cache/jacred/lastsync.txt", lastsync.ToString());
                                }

                                continue;
                            }
                        }

                        FileDB.SaveChangesToFile();
                        File.WriteAllText("cache/jacred/lastsync.txt", lastsync.ToString());
                    }
                    else
                    {
                        await Task.Delay(TimeSpan.FromMinutes(1));
                        continue;
                    }
                }
                catch
                {
                    try
                    {
                        if (lastsync > 0)
                        {
                            FileDB.SaveChangesToFile();
                            File.WriteAllText("cache/jacred/lastsync.txt", lastsync.ToString());
                        }
                    }
                    catch { }
                }

                await Task.Delay(1000 * Random.Shared.Next(60, 300));
                await Task.Delay(1000 * 60 * (20 > ModInit.conf.Red.syntime ? 20 : ModInit.conf.Red.syntime));

                reset = true;
                lastSave = DateTime.Now;
            }
        }
    }
}

```

## File: JacRed/Engine/RedApi.cs
```
Ôªøusing MonoTorrent;
using JacRed.Models.AppConf;
using Jackett;

namespace JacRed.Engine
{
    public static class RedApi
    {
        static RedConf red => ModInit.conf.Red;

        #region Indexers
        public static (IEnumerable<TorrentDetails> torrents, bool setcache) Indexers(bool rqnum, string apikey, string query, string title, string title_original, int year, int is_serial, Dictionary<string, string> category)
        {
            bool setcache = false;
            var torrents = new Dictionary<string, TorrentDetails>();

            #region category
            if (is_serial == 0 && category != null)
            {
                string cat = category.FirstOrDefault().Value;
                if (cat != null)
                {
                    if (cat.Contains("5020") || cat.Contains("2010"))
                        is_serial = 3; // tvshow
                    else if (cat.Contains("5080"))
                        is_serial = 4; // –¥–æ–∫
                    else if (cat.Contains("5070"))
                        is_serial = 5; // –∞–Ω–∏–º–µ
                    else if (is_serial == 0)
                    {
                        if (cat.StartsWith("20"))
                            is_serial = 1; // —Ñ–∏–ª—å–º
                        else if (cat.StartsWith("50"))
                            is_serial = 2; // —Å–µ—Ä–∏–∞–ª
                    }
                }
            }
            #endregion

            #region AddTorrents
            void AddTorrents(TorrentDetails t)
            {
                if (t.url == null)
                    return;

                if (!string.IsNullOrEmpty(ModInit.conf.filter) && !Regex.IsMatch(t.title, ModInit.conf.filter, RegexOptions.IgnoreCase))
                    return;

                if (!string.IsNullOrEmpty(ModInit.conf.filter_ignore) && Regex.IsMatch(t.title, ModInit.conf.filter_ignore, RegexOptions.IgnoreCase))
                    return;

                if (InvkEvent.conf.RedApi?.AddTorrents != null)
                {
                    if (!InvkEvent.RedApi("addtorrent", t))
                        return;
                }
                else
                {
                    EventListener.RedApiAddTorrents?.Invoke(t);
                }

                if (torrents.TryGetValue(t.url, out TorrentDetails val))
                {
                    if (t.updateTime > val.updateTime)
                        torrents[t.url] = t;
                }
                else
                {
                    torrents.TryAdd(t.url, t);
                }
            }
            #endregion

            if (!string.IsNullOrWhiteSpace(title) || !string.IsNullOrWhiteSpace(title_original))
            {
                #region –¢–æ—á–Ω—ã–π –ø–æ–∏—Å–∫
                setcache = true;

                string _n = StringConvert.SearchName(title);
                string _o = StringConvert.SearchName(title_original);

                // –ë—ã—Å—Ç—Ä–∞—è –≤—ã–±–æ—Ä–∫–∞ –ø–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—é –∫–ª—é—á–∞ –≤ –∏–º–µ–Ω–∏
                var mdb = FileDB.masterDb.Where(i => _n != null && i.Key.StartsWith($"{_n}:") || _o != null && i.Key.EndsWith($":{_o}"));
                if (!red.evercache.enable || red.evercache.validHour > 0)
                    mdb = mdb.Take(red.maxreadfile);

                foreach (var val in mdb)
                {
                    using (var fdb = FileDB.Open(val.Key))
                    {
                        foreach (var t in fdb.Database.Values)
                        {
                            if (t.types == null || t.title.Contains(" –ö–ü–ö"))
                                continue;

                            string name = StringConvert.SearchName(t.name);
                            string originalname = StringConvert.SearchName(t.originalname);

                            // –¢–æ—á–Ω–∞—è –≤—ã–±–æ—Ä–∫–∞ –ø–æ name –∏–ª–∏ originalname
                            if (_n != null && _n == name || _o != null && _o == originalname)
                            {
                                if (is_serial == 1)
                                {
                                    #region –§–∏–ª—å–º
                                    if (t.types.Contains("movie") || t.types.Contains("multfilm") || t.types.Contains("anime") || t.types.Contains("documovie"))
                                    {
                                        if (Regex.IsMatch(t.title, " (—Å–µ–∑–æ–Ω|—Å–µ—Ä–∏(–∏|—è|–π))", RegexOptions.IgnoreCase))
                                            continue;

                                        if (year > 0)
                                        {
                                            if (t.relased == year || t.relased == year - 1 || t.relased == year + 1)
                                                AddTorrents(t);
                                        }
                                        else
                                        {
                                            AddTorrents(t);
                                        }
                                    }
                                    #endregion
                                }
                                else if (is_serial == 2)
                                {
                                    #region –°–µ—Ä–∏–∞–ª
                                    if (t.types.Contains("serial") || t.types.Contains("multserial") || t.types.Contains("anime") || t.types.Contains("docuserial") || t.types.Contains("tvshow"))
                                    {
                                        if (year > 0)
                                        {
                                            if (t.relased >= year - 1)
                                                AddTorrents(t);
                                        }
                                        else
                                        {
                                            AddTorrents(t);
                                        }
                                    }
                                    #endregion
                                }
                                else if (is_serial == 3)
                                {
                                    #region tvshow
                                    if (t.types.Contains("tvshow"))
                                    {
                                        if (year > 0)
                                        {
                                            if (t.relased >= year - 1)
                                                AddTorrents(t);
                                        }
                                        else
                                        {
                                            AddTorrents(t);
                                        }
                                    }
                                    #endregion
                                }
                                else if (is_serial == 4)
                                {
                                    #region docuserial / documovie
                                    if (t.types.Contains("docuserial") || t.types.Contains("documovie"))
                                    {
                                        if (year > 0)
                                        {
                                            if (t.relased >= year - 1)
                                                AddTorrents(t);
                                        }
                                        else
                                        {
                                            AddTorrents(t);
                                        }
                                    }
                                    #endregion
                                }
                                else if (is_serial == 5)
                                {
                                    #region anime
                                    if (t.types.Contains("anime"))
                                    {
                                        if (year > 0)
                                        {
                                            if (t.relased >= year - 1)
                                                AddTorrents(t);
                                        }
                                        else
                                        {
                                            AddTorrents(t);
                                        }
                                    }
                                    #endregion
                                }
                                else
                                {
                                    #region –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ
                                    if (year > 0)
                                    {
                                        if (t.types.Contains("movie") || t.types.Contains("multfilm") || t.types.Contains("documovie"))
                                        {
                                            if (t.relased == year || t.relased == year - 1 || t.relased == year + 1)
                                                AddTorrents(t);
                                        }
                                        else
                                        {
                                            if (t.relased >= year - 1)
                                                AddTorrents(t);
                                        }
                                    }
                                    else
                                    {
                                        AddTorrents(t);
                                    }
                                    #endregion
                                }
                            }
                        }
                    }
                }
                #endregion
            }
            else if (!string.IsNullOrWhiteSpace(query) && query.Length > 1)
            {
                #region –û–±—ã—á–Ω—ã–π –ø–æ–∏—Å–∫
                string _s = StringConvert.SearchName(query);

                #region torrentsSearch
                void torrentsSearch(bool exact)
                {
                    var mdb = FileDB.masterDb.Where(i => i.Key.Contains(_s));
                    if (!red.evercache.enable || red.evercache.validHour > 0)
                        mdb = mdb.Take(red.maxreadfile);

                    foreach (var val in mdb)
                    {
                        using (var fdb = FileDB.Open(val.Key))
                        {
                            foreach (var t in fdb.Database.Values)
                            {
                                if (exact)
                                {
                                    if (StringConvert.SearchName(t.name) != _s && StringConvert.SearchName(t.originalname) != _s)
                                        continue;
                                }

                                if (t.types == null || t.title.Contains(" –ö–ü–ö"))
                                    continue;

                                if (is_serial == 1)
                                {
                                    if (t.types.Contains("movie") || t.types.Contains("multfilm") || t.types.Contains("anime") || t.types.Contains("documovie"))
                                        AddTorrents(t);
                                }
                                else if (is_serial == 2)
                                {
                                    if (t.types.Contains("serial") || t.types.Contains("multserial") || t.types.Contains("anime") || t.types.Contains("docuserial") || t.types.Contains("tvshow"))
                                        AddTorrents(t);
                                }
                                else if (is_serial == 3)
                                {
                                    if (t.types.Contains("tvshow"))
                                        AddTorrents(t);
                                }
                                else if (is_serial == 4)
                                {
                                    if (t.types.Contains("docuserial") || t.types.Contains("documovie"))
                                        AddTorrents(t);
                                }
                                else if (is_serial == 5)
                                {
                                    if (t.types.Contains("anime"))
                                        AddTorrents(t);
                                }
                                else
                                {
                                    AddTorrents(t);
                                }
                            }
                        }

                    }
                }
                #endregion

                if (is_serial == -1)
                    torrentsSearch(exact: false);
                else
                {
                    torrentsSearch(exact: true);
                    if (torrents.Count == 0)
                        torrentsSearch(exact: false);
                }
                #endregion
            }

            #region –û–±—ä–µ–¥–∏–Ω–∏—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã
            IEnumerable<TorrentDetails> tsort = null;

            if (ModInit.conf.typesearch == "red" && ((!rqnum && red.mergeduplicates) || (rqnum && red.mergenumduplicates)))
            {
                var temp = new Dictionary<string, (TorrentDetails torrent, string title, string Name, List<string> AnnounceUrls)>();

                foreach (var torrent in torrents.Values
                                                .Where(i => red.trackers == null || red.trackers.Contains(i.trackerName))
                                                .OrderByDescending(i => i.createTime)
                                                .ThenBy(i => i.trackerName == "selezen").ToList())
                {
                    if (torrent.magnet == null)
                        continue;

                    var magnetLink = MagnetLink.Parse(torrent.magnet);
                    string hex = magnetLink.InfoHashes.V1.ToHex();

                    if (!temp.TryGetValue(hex, out _))
                    {
                        temp.TryAdd(hex, ((TorrentDetails)torrent.Clone(), torrent.trackerName == "kinozal" ? torrent.title : null, magnetLink.Name, magnetLink.AnnounceUrls?.ToList() ?? new List<string>()));
                    }
                    else
                    {
                        var t = temp[hex];
                        t.torrent.trackerName += $", {torrent.trackerName}";

                        #region urls
                        if (t.torrent.urls == null)
                            t.torrent.urls = new HashSet<string> { t.torrent.url };

                        t.torrent.urls.Add(torrent.url);
                        #endregion

                        #region UpdateMagnet
                        void UpdateMagnet()
                        {
                            string magnet = $"magnet:?xt=urn:btih:{hex.ToLower()}";

                            if (!string.IsNullOrWhiteSpace(t.Name))
                                magnet += $"&dn={HttpUtility.UrlEncode(t.Name)}";

                            if (t.AnnounceUrls != null && t.AnnounceUrls.Count > 0)
                            {
                                foreach (string announce in t.AnnounceUrls)
                                {
                                    string tr = announce.Contains("/") || announce.Contains(":") ? HttpUtility.UrlEncode(announce) : announce;

                                    if (!magnet.Contains(tr))
                                        magnet += $"&tr={tr}";
                                }
                            }

                            t.torrent.magnet = magnet;
                        }
                        #endregion

                        if (string.IsNullOrWhiteSpace(t.Name) && !string.IsNullOrWhiteSpace(magnetLink.Name))
                        {
                            t.Name = magnetLink.Name;
                            temp[hex] = t;
                            UpdateMagnet();
                        }

                        if (magnetLink.AnnounceUrls != null && magnetLink.AnnounceUrls.Count > 0)
                        {
                            t.AnnounceUrls.AddRange(magnetLink.AnnounceUrls);
                            UpdateMagnet();
                        }

                        #region UpdateTitle
                        void UpdateTitle()
                        {
                            if (string.IsNullOrWhiteSpace(t.title))
                                return;

                            string title = t.title;

                            if (t.torrent.voices != null && t.torrent.voices.Count > 0)
                                title += $" | {string.Join(" | ", t.torrent.voices)}";

                            t.torrent.title = title;
                        }

                        if (torrent.trackerName == "kinozal")
                        {
                            t.title = torrent.title;
                            temp[hex] = t;
                            UpdateTitle();
                        }

                        if (torrent.voices != null && torrent.voices.Count > 0)
                        {
                            if (t.torrent.voices == null)
                            {
                                t.torrent.voices = torrent.voices;
                            }
                            else
                            {
                                foreach (var v in torrent.voices)
                                    t.torrent.voices.Add(v);
                            }

                            UpdateTitle();
                        }
                        #endregion

                        if (torrent.trackerName != "selezen")
                        {
                            if (torrent.sid > t.torrent.sid)
                                t.torrent.sid = torrent.sid;

                            if (torrent.pir > t.torrent.pir)
                                t.torrent.pir = torrent.pir;
                        }

                        if (torrent.createTime > t.torrent.createTime)
                            t.torrent.createTime = torrent.createTime;

                        if (torrent.voices != null && torrent.voices.Count > 0)
                        {
                            if (t.torrent.voices == null)
                                t.torrent.voices = new HashSet<string>();

                            foreach (var v in torrent.voices)
                                t.torrent.voices.Add(v);
                        }

                        if (torrent.languages != null && torrent.languages.Count > 0)
                        {
                            if (t.torrent.languages == null)
                                t.torrent.languages = new HashSet<string>();

                            foreach (var v in torrent.languages)
                                t.torrent.languages.Add(v);
                        }

                        if (t.torrent.ffprobe == null)
                            t.torrent.ffprobe = torrent.ffprobe;
                    }
                }

                tsort = temp.Select(i => i.Value.torrent);
            }
            else
            {
                tsort = torrents.Values.Where(i => red.trackers == null || red.trackers.Contains(i.trackerName));
            }
            #endregion

            if (apikey == "rus")
                return (tsort.Where(i => i.languages != null && i.languages.Contains("rus") || i.types != null && (i.types.Contains("sport") || i.types.Contains("tvshow") || i.types.Contains("docuserial"))), setcache);

            return (tsort, setcache);
        }
        #endregion

        #region Api
        public static IEnumerable<TorrentDetails> Api(string search, string altname, bool exact, string type, string sort, string tracker, string voice, string videotype, long relased, long quality, long season)
        {
            var torrents = new Dictionary<string, TorrentDetails>();

            #region AddTorrents
            void AddTorrents(TorrentDetails t)
            {
                if (torrents.TryGetValue(t.url, out TorrentDetails val))
                {
                    if (t.updateTime > val.updateTime)
                        torrents[t.url] = t;
                }
                else
                {
                    torrents.TryAdd(t.url, t);
                }
            }
            #endregion

            if (string.IsNullOrWhiteSpace(search) || search.Length == 1)
                return new List<TorrentDetails>();

            string _s = StringConvert.SearchName(search);
            string _altsearch = StringConvert.SearchName(altname);

            if (exact)
            {
                #region –¢–æ—á–Ω—ã–π –ø–æ–∏—Å–∫
                foreach (var mdb in FileDB.masterDb.Where(i => i.Key.StartsWith($"{_s}:") || i.Key.EndsWith($":{_s}") || _altsearch != null && i.Key.Contains(_altsearch)))
                {
                    using (var fdb = FileDB.Open(mdb.Key))
                    {
                        foreach (var t in fdb.Database.Values)
                        {
                            if (t.types == null)
                                continue;

                            if (string.IsNullOrWhiteSpace(type) || t.types.Contains(type))
                            {
                                string _n = StringConvert.SearchName(t.name);
                                string _o = StringConvert.SearchName(t.originalname);

                                if (_n == _s || _o == _s || _altsearch != null && (_n == _altsearch || _o == _altsearch))
                                    AddTorrents(t);
                            }
                        }
                    }
                }
                #endregion
            }
            else
            {
                #region –ü–æ–∏—Å–∫ –ø–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—é –∫–ª—é—á–∞ –≤ –∏–º–µ–Ω–∏
                var mdb = FileDB.masterDb.Where(i => i.Key.Contains(_s) || _altsearch != null && i.Key.Contains(_altsearch));
                if (!red.evercache.enable || red.evercache.validHour > 0)
                    mdb = mdb.Take(red.maxreadfile);

                foreach (var val in mdb)
                {
                    using (var fdb = FileDB.Open(val.Key))
                    {
                        foreach (var t in fdb.Database.Values)
                        {
                            if (t.types == null)
                                continue;

                            if (string.IsNullOrWhiteSpace(type) || t.types.Contains(type))
                                AddTorrents(t);
                        }
                    }
                }
                #endregion
            }

            if (torrents.Count == 0)
                return new List<TorrentDetails>();

            IEnumerable<TorrentDetails> query = torrents.Values;

            #region sort
            switch (sort ?? string.Empty)
            {
                case "sid":
                    query = query.OrderByDescending(i => i.sid);
                    break;
                case "pir":
                    query = query.OrderByDescending(i => i.pir);
                    break;
                case "size":
                    query = query.OrderByDescending(i => i.size);
                    break;
                default:
                    query = query.OrderByDescending(i => i.createTime);
                    break;
            }
            #endregion

            if (!string.IsNullOrWhiteSpace(tracker))
                query = query.Where(i => i.trackerName == tracker);

            if (relased > 0)
                query = query.Where(i => i.relased == relased);

            if (quality > 0)
                query = query.Where(i => i.quality == quality);

            if (!string.IsNullOrWhiteSpace(videotype))
                query = query.Where(i => i.videotype == videotype);

            if (!string.IsNullOrWhiteSpace(voice))
                query = query.Where(i => i.voices.Contains(voice));

            if (season > 0)
                query = query.Where(i => i.seasons.Contains((int)season));

            return query.Where(i => red.trackers == null || red.trackers.Contains(i.trackerName));
        }
        #endregion
    }
}

```

## File: JacRed/Engine/JackettApi.cs
```
Ôªøusing Jackett;
using JacRed.Controllers;
using JacRed.Models.AppConf;
using System.Reflection;

namespace JacRed.Engine
{
    public static class JackettApi
    {
        static JacConf jackett => ModInit.conf.Jackett;

        #region Indexers
        async public static Task<List<TorrentDetails>> Indexers(string host, string query, string title, string title_original, int year, int is_serial, Dictionary<string, string> category)
        {
            var hybridCache = new HybridCache();

            string mkey = $"JackettApi:{query}:{title}:{year}:{is_serial}";
            if (hybridCache.TryGetValue(mkey, out List<TorrentDetails> cache, inmemory: false))
                return cache;

            var torrents = new ConcurrentBag<TorrentDetails>();

            #region search
            string search = jackett.search_lang == "query" ? query : jackett.search_lang == "title" ? title : title_original;

            if (string.IsNullOrWhiteSpace(search))
            {
                search = query ?? title ?? title_original;
                if (string.IsNullOrWhiteSpace(search))
                    return torrents.ToList();
            }
            #endregion

            #region category
            if (category != null)
            {
                string cat = category.FirstOrDefault().Value;
                if (cat != null)
                {
                    if (cat.Contains("5020") || cat.Contains("2010"))
                        is_serial = 3; // tvshow
                    else if (cat.Contains("5080"))
                        is_serial = 4; // –¥–æ–∫
                    else if (cat.Contains("5070"))
                        is_serial = 5; // –∞–Ω–∏–º–µ
                    else if (is_serial == 0)
                    {
                        if (cat.StartsWith("20"))
                            is_serial = 1; // —Ñ–∏–ª—å–º
                        else if (cat.StartsWith("50"))
                            is_serial = 2; // —Å–µ—Ä–∏–∞–ª
                    }
                }
            }
            #endregion

            #region modpars
            void modpars(List<Task> tasks, string cat)
            {
                if (AppInit.modules != null && AppInit.modules.Count > 0)
                {
                    foreach (var item in AppInit.modules)
                    {
                        foreach (var mod in item.jac)
                        {
                            if (mod.enable)
                            {
                                try
                                {
                                    if (item.assembly.GetType(mod.@namespace) is Type t && t.GetMethod("parsePage") is MethodInfo m)
                                    {
                                        var task = (Task)m.Invoke(null, new object[] { host, torrents, search, cat });
                                        if (task != null)
                                            tasks.Add(task);
                                    }
                                }
                                catch { }
                            }
                        }
                    }
                }
            }
            #endregion

            #region –ü–∞—Ä—Å–∏–º —Ç–æ—Ä—Ä–µ–Ω—Ç—ã
            if (is_serial == 1)
            {
                #region –§–∏–ª—å–º
                var tasks = new List<Task>
                {
                    RutorController.search(host, torrents, search, "1"),  // movie
                    RutorController.search(host, torrents, search, "5"),  // movie
                    RutorController.search(host, torrents, search, "7"),  // multfilm
                    RutorController.search(host, torrents, search, "12"), // documovie
                    RutorController.search(host, torrents, search, "17", true, "1"), // UKR

                    MegapeerController.search(host, torrents, search, "79"),  // –ù–∞—à–∏ —Ñ–∏–ª—å–º—ã
                    MegapeerController.search(host, torrents, search, "80"),  // –ó–∞—Ä—É–±–µ–∂–Ω—ã–µ —Ñ–∏–ª—å–º—ã
                    MegapeerController.search(host, torrents, search, "76"),  // –ú—É–ª—å—Ç–∏–ø–ª–∏–∫–∞—Ü–∏—è

                    TorrentByController.search(host, torrents, search, "1"), // movie
                    TorrentByController.search(host, torrents, search, "2"), // movie
                    TorrentByController.search(host, torrents, search, "5"), // multfilm

                    KinozalController.search(host, torrents, search, new string[] { "movie", "multfilm", "tvshow" }),
                    NNMClubController.search(host, torrents, search, new string[] { "movie", "multfilm", "documovie" }),
                    TolokaController.search(host, torrents, search, new string[] { "movie", "multfilm", "documovie" }),
                    RutrackerController.search(host, torrents, search, new string[] { "movie", "multfilm", "documovie" }),
                    BitruController.search(host, torrents, search, new string[] { "movie" }),
                    SelezenController.search(host, torrents, search),
                    BigFanGroup.search(host, torrents, search, new string[] { "movie", "multfilm", "documovie" })
                };

                modpars(tasks, "movie");

                await Task.WhenAll(tasks);
                #endregion
            }
            else if (is_serial == 2)
            {
                #region –°–µ—Ä–∏–∞–ª
                var tasks = new List<Task>
                {
                    RutorController.search(host, torrents, search, "4"),  // serial
                    RutorController.search(host, torrents, search, "16"), // serial
                    RutorController.search(host, torrents, search, "7"),  // multserial
                    RutorController.search(host, torrents, search, "12"), // docuserial
                    RutorController.search(host, torrents, search, "6"),  // tvshow
                    RutorController.search(host, torrents, search, "17", true, "4"), // UKR

                    MegapeerController.search(host, torrents, search, "5"),  // serial
                    MegapeerController.search(host, torrents, search, "6"),  // serial
                    MegapeerController.search(host, torrents, search, "55"), // docuserial
                    MegapeerController.search(host, torrents, search, "57"), // tvshow
                    MegapeerController.search(host, torrents, search, "76"), // multserial

                    TorrentByController.search(host, torrents, search, "3"),  // serial
                    TorrentByController.search(host, torrents, search, "5"),  // multserial
                    TorrentByController.search(host, torrents, search, "4"),  // tvshow
                    TorrentByController.search(host, torrents, search, "12"), // tvshow

                    KinozalController.search(host, torrents, search, new string[] { "serial", "multserial", "tvshow" }),
                    NNMClubController.search(host, torrents, search, new string[] { "serial", "multserial", "docuserial" }),
                    TolokaController.search(host, torrents, search, new string[] { "serial", "multserial", "docuserial" }),
                    RutrackerController.search(host, torrents, search, new string[] { "serial", "multserial", "docuserial" }),
                    BitruController.search(host, torrents, search, new string[] { "serial" }),
                    LostfilmController.search(host, torrents, search),
                    BigFanGroup.search(host, torrents, search, new string[] { "serial", "multserial", "docuserial", "tvshow" })
                };

                modpars(tasks, "serial");

                await Task.WhenAll(tasks);
                #endregion
            }
            else if (is_serial == 3)
            {
                #region tvshow
                var tasks = new List<Task>
                {
                    RutorController.search(host, torrents, search, "6"),
                    MegapeerController.search(host, torrents, search, "57"),
                    TorrentByController.search(host, torrents, search, "4"),
                    TorrentByController.search(host, torrents, search, "12"),
                    KinozalController.search(host, torrents, search, new string[] { "tvshow" }),
                    NNMClubController.search(host, torrents, search, new string[] { "docuserial", "documovie" }),
                    TolokaController.search(host, torrents, search, new string[] { "docuserial", "documovie" }),
                    RutrackerController.search(host, torrents, search, new string[] { "tvshow" }),
                    BigFanGroup.search(host, torrents, search, new string[] { "tvshow" })
                };

                modpars(tasks, "tvshow");

                await Task.WhenAll(tasks);
                #endregion
            }
            else if (is_serial == 4)
            {
                #region docuserial / documovie
                var tasks = new List<Task>
                {
                    RutorController.search(host, torrents, search, "12"),
                    MegapeerController.search(host, torrents, search, "55"),
                    NNMClubController.search(host, torrents, search, new string[] { "docuserial", "documovie" }),
                    TolokaController.search(host, torrents, search, new string[] { "docuserial", "documovie" }),
                    RutrackerController.search(host, torrents, search, new string[] { "docuserial", "documovie" }),
                    BigFanGroup.search(host, torrents, search, new string[] { "docuserial", "documovie" })
                };

                modpars(tasks, "documental");

                await Task.WhenAll(tasks);
                #endregion
            }
            else if (is_serial == 5)
            {
                #region anime
                string animesearch = title ?? query;

                var tasks = new List<Task>
                {
                    RutorController.search(host, torrents, animesearch, "10"),
                    TorrentByController.search(host, torrents, animesearch, "6"),
                    KinozalController.search(host, torrents, animesearch, new string[] { "anime" }),
                    NNMClubController.search(host, torrents, animesearch, new string[] { "anime" }),
                    RutrackerController.search(host, torrents, animesearch, new string[] { "anime" }),
                    TolokaController.search(host, torrents, search, new string[] { "anime" }),
                    AniLibriaController.search(host, torrents, animesearch),
                    AnimeLayerController.search(host, torrents, animesearch),
                    AnifilmController.search(host, torrents, animesearch)
                };

                modpars(tasks, "anime");

                await Task.WhenAll(tasks);
                #endregion
            }
            else
            {
                #region –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ
                var tasks = new List<Task>
                {
                    RutorController.search(host, torrents, search, "0"),
                    MegapeerController.search(host, torrents, search, "0"),
                    TorrentByController.search(host, torrents, search, "0"),
                    KinozalController.search(host, torrents, search, null),
                    NNMClubController.search(host, torrents, search, null),
                    BitruController.search(host, torrents, search, null),
                    RutrackerController.search(host, torrents, search, null),
                    TolokaController.search(host, torrents, search, null),
                    AniLibriaController.search(host, torrents, search),
                    AnimeLayerController.search(host, torrents, search),
                    AnifilmController.search(host, torrents, search),
                    SelezenController.search(host, torrents, search),
                    LostfilmController.search(host, torrents, search),
                    BigFanGroup.search(host, torrents, search, null)
                };

                modpars(tasks, "search");

                await Task.WhenAll(tasks);
                #endregion
            }
            #endregion

            var hash = new HashSet<string>();
            var finaly = new List<TorrentDetails>(torrents.Count);

            foreach (var t in torrents)
            {
                if (t.trackerName == null)
                    t.trackerName = Regex.Match(t.url, "https?://([^/]+)").Groups[1].Value;

                if (!string.IsNullOrEmpty(ModInit.conf.filter) && !Regex.IsMatch(t.title, ModInit.conf.filter, RegexOptions.IgnoreCase))
                    continue;

                if (!string.IsNullOrEmpty(ModInit.conf.filter_ignore) && Regex.IsMatch(t.title, ModInit.conf.filter_ignore, RegexOptions.IgnoreCase))
                    continue;

                if (!hash.Contains(t.url))
                {
                    hash.Add(t.url);
                    finaly.Add(t);
                }
            }

            var result = finaly.AsEnumerable();

            if (is_serial == 1 && year > 0)
                result = result.Where(i => i.title.Contains(year.ToString()) || i.title.Contains($"{year+1}") || i.title.Contains($"{year-1}"));

            if (ModInit.conf.Jackett.cacheToMinutes > 0)
                hybridCache.Set(mkey, result.ToList(), DateTime.Now.AddMinutes(ModInit.conf.Jackett.cacheToMinutes), inmemory: false);

            return result.ToList();
        }
        #endregion

        #region Api
        public static Task<List<TorrentDetails>> Api(string host, string search)
        {
            return Indexers(host, search, null, null, 0, 0, null);
        }
        #endregion
    }
}

```

## File: JacRed/Engine/FileDB/staticDB.cs
```
Ôªøusing Jackett;
using JacRed.Engine.CORE;
using JacRed.Models;

namespace JacRed.Engine
{
    public partial class FileDB : IDisposable
    {
        #region FileDB
        /// <summary>
        /// $"{search_name}:{search_originalname}"
        /// –í–µ—Ä—Ö–Ω–µ–µ –≤—Ä–µ–º—è –∏–∑–º–µ–Ω–µ–Ω–∏—è 
        /// </summary>
        public static ConcurrentDictionary<string, DateTime> masterDb = new ConcurrentDictionary<string, DateTime>();

        static ConcurrentDictionary<string, WriteTaskModel> openWriteTask = new ConcurrentDictionary<string, WriteTaskModel>();

        static FileDB()
        {
            if (File.Exists("cache/jacred/masterDb.bz"))
                masterDb = JsonStream.Read<ConcurrentDictionary<string, DateTime>>("cache/jacred/masterDb.bz");

            if (masterDb == null)
            {
                if (File.Exists($"cache/jacred/masterDb_{DateTime.Today:dd-MM-yyyy}.bz"))
                    masterDb = JsonStream.Read<ConcurrentDictionary<string, DateTime>>($"cache/jacred/masterDb_{DateTime.Today:dd-MM-yyyy}.bz");

                if (masterDb == null && File.Exists($"cache/jacred/masterDb_{DateTime.Today.AddDays(-1):dd-MM-yyyy}.bz"))
                    masterDb = JsonStream.Read<ConcurrentDictionary<string, DateTime>>($"cache/jacred/masterDb_{DateTime.Today.AddDays(-1):dd-MM-yyyy}.bz");

                if (masterDb == null)
                    masterDb = new ConcurrentDictionary<string, DateTime>();

                if (File.Exists("cache/jacred/lastsync.txt"))
                    File.Delete("cache/jacred/lastsync.txt");
            }
        }
        #endregion

        #region pathDb
        static string pathDb(string key)
        {
            string md5key = CrypTo.md5(key);

            Directory.CreateDirectory($"cache/jacred/fdb/{md5key.Substring(0, 2)}");
            return $"cache/jacred/fdb/{md5key.Substring(0, 2)}/{md5key.Substring(2)}";
        }
        #endregion

        #region Open
        public static FileDB Open(string key, bool empty = false)
        {
            if (empty)
            {
                openWriteTask.TryRemove(key, out _);
                return new FileDB(key, empty: empty);
            }

            if (openWriteTask.TryGetValue(key, out WriteTaskModel val))
            {
                val.countread++;
                val.openconnection += 1;
                val.lastread = DateTime.UtcNow;
                return val.db;
            }
            else
            {
                var fdb = new FileDB(key);
                openWriteTask.TryAdd(key, new WriteTaskModel() { db = fdb, openconnection = 1, countread = 1, lastread = DateTime.UtcNow });
                return fdb;
            }
        }
        #endregion

        #region SaveChangesToFile
        public static void SaveChangesToFile()
        {
            try
            {
                JsonStream.Write("cache/jacred/masterDb.bz", masterDb);

                if (!File.Exists($"cache/jacred/masterDb_{DateTime.Today:dd-MM-yyyy}.bz"))
                    File.Copy("cache/jacred/masterDb.bz", $"cache/jacred/masterDb_{DateTime.Today:dd-MM-yyyy}.bz");

                if (File.Exists($"cache/jacred/masterDb_{DateTime.Today.AddDays(-2):dd-MM-yyyy}.bz"))
                    File.Delete($"cache/jacred/masterDb_{DateTime.Today.AddDays(-2):dd-MM-yyyy}.bz");
            }
            catch { }
        }
        #endregion


        #region Cron
        async public static Task Cron()
        {
            while (true)
            {
                await Task.Delay(TimeSpan.FromMinutes(10));

                if (!ModInit.conf.Red.evercache.enable || 0 >= ModInit.conf.Red.evercache.validHour)
                    continue;

                try
                {
                    var deleteKeys = openWriteTask
                        .Where(i => DateTime.UtcNow > i.Value.lastread.AddHours(ModInit.conf.Red.evercache.validHour))
                        .Select(i => i.Key)
                        .ToArray();

                    foreach (string key in deleteKeys) 
                        openWriteTask.TryRemove(key, out _);
                }
                catch { }
            }
        }

        async public static Task CronFast()
        {
            while (true)
            {
                await Task.Delay(TimeSpan.FromSeconds(20));

                if (!ModInit.conf.Red.evercache.enable || 0 >= ModInit.conf.Red.evercache.validHour)
                    continue;

                try
                {
                    if (openWriteTask.Count > ModInit.conf.Red.evercache.maxOpenWriteTask)
                    {
                        var deleteKeys = openWriteTask
                            .Where(i => DateTime.Now > i.Value.create.AddMinutes(10))
                            .OrderBy(i => i.Value.countread).ThenBy(i => i.Value.lastread)
                            .Take(ModInit.conf.Red.evercache.dropCacheTake)
                            .Select(i => i.Key)
                            .ToArray();

                        foreach (string key in deleteKeys)
                            openWriteTask.TryRemove(key, out _);
                    }
                }
                catch { }
            }
        }
        #endregion
    }
}

```

## File: JacRed/Engine/FileDB/FileDB.cs
```
Ôªøusing Jackett;
using JacRed.Engine.CORE;
using JacRed.Models;

namespace JacRed.Engine
{
    public partial class FileDB : IDisposable
    {
        string fdbkey;

        public ConcurrentDictionary<string, TorrentDetails> Database = new ConcurrentDictionary<string, TorrentDetails>();

        FileDB(string key, bool empty = false)
        {
            fdbkey = key;
            string fdbpath = pathDb(key);
             
            if (!empty && File.Exists(fdbpath))
                Database = JsonStream.Read<ConcurrentDictionary<string, TorrentDetails>>(fdbpath) ?? new ConcurrentDictionary<string, TorrentDetails>();
        }
        

        public void Dispose()
        {
            if (Database.Count > 0)
                JsonStream.Write(pathDb(fdbkey), Database);

            if (openWriteTask.TryGetValue(fdbkey, out WriteTaskModel val))
            {
                val.openconnection -= 1;
                if (0 >= val.openconnection)
                {
                    if (!ModInit.conf.Red.evercache.enable || (ModInit.conf.Red.evercache.enable && ModInit.conf.Red.evercache.validHour > 0))
                        openWriteTask.TryRemove(fdbkey, out _);
                }
            }
        }
    }
}

```

## File: Lampac/Startup.cs
```
using Lampac.Engine;
using Lampac.Engine.Middlewares;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.HttpOverrides;
using Microsoft.AspNetCore.Mvc.ApplicationParts;
using Microsoft.AspNetCore.Mvc.Infrastructure;
using Microsoft.AspNetCore.ResponseCompression;
using Microsoft.AspNetCore.StaticFiles;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.DependencyModel;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Http;
using Newtonsoft.Json;
using Shared;
using Shared.Engine;
using Shared.Models.Module;
using Shared.Models.Module.Entrys;
using Shared.PlaywrightCore;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Reflection;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac
{
    public class Startup
    {
        #region Startup
        static IApplicationBuilder _app = null;

        public static bool IsShutdown { get; private set; }

        public IConfiguration Configuration { get; }

        public static IServiceCollection serviceCollection { get; private set; }

        public static IMemoryCache memoryCache { get; private set; }

        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }
        #endregion

        #region ConfigureServices
        public void ConfigureServices(IServiceCollection services)
        {
            serviceCollection = services;

            #region IHttpClientFactory
            services.AddHttpClient("proxy").ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = false,
                AutomaticDecompression = DecompressionMethods.None,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                UseCookies = false
            });

            services.AddHttpClient("proxyimg").ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = true,
                AutomaticDecompression = DecompressionMethods.None,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                UseCookies = false
            });

            services.AddHttpClient("base").ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = true,
                AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                UseCookies = false
            });

            services.AddHttpClient("baseNoRedirect").ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = false,
                AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                UseCookies = false
            });

            services.AddHttpClient("http2", client =>
            {
                client.DefaultRequestVersion = HttpVersion.Version20;
                client.DefaultVersionPolicy = HttpVersionPolicy.RequestVersionOrLower;
            })
            .ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = true,
                AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                EnableMultipleHttp2Connections = true,
                UseCookies = false
            });

            services.AddHttpClient("http2proxyimg", client =>
            {
                client.DefaultRequestVersion = HttpVersion.Version20;
                client.DefaultVersionPolicy = HttpVersionPolicy.RequestVersionOrLower;
            })
            .ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = true,
                AutomaticDecompression = DecompressionMethods.None,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                EnableMultipleHttp2Connections = true,
                UseCookies = false
            });

            services.AddHttpClient("http2NoRedirect", client =>
            {
                client.DefaultRequestVersion = HttpVersion.Version20;
                client.DefaultVersionPolicy = HttpVersionPolicy.RequestVersionOrLower;
            })
            .ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = false,
                AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                EnableMultipleHttp2Connections = true,
                UseCookies = false
            });

            services.AddHttpClient("http3", client =>
            {
                client.DefaultRequestVersion = HttpVersion.Version30;
                client.DefaultVersionPolicy = HttpVersionPolicy.RequestVersionOrLower;
            })
            .ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = true,
                AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                EnableMultipleHttp2Connections = true,
                UseCookies = false
            });

            services.RemoveAll<IHttpMessageHandlerBuilderFilter>();
            #endregion

            services.Configure<CookiePolicyOptions>(options =>
            {
                options.CheckConsentNeeded = context => true;
                options.MinimumSameSitePolicy = SameSiteMode.None;
            });

            if (AppInit.conf.listen.compression)
            {
                services.AddResponseCompression(options =>
                {
                    options.MimeTypes = ResponseCompressionDefaults.MimeTypes.Concat(["image/svg+xml"]);
                });
            }

            services.AddSignalR(o =>
            {
                o.EnableDetailedErrors = true;
                o.MaximumParallelInvocationsPerClient = 2;
                o.MaximumReceiveMessageSize = 1024 * 1024 * 10; // 10MB
                o.StreamBufferCapacity = 1024 * 1024;           // 1MB
            });

            services.AddSingleton<IActionDescriptorChangeProvider>(DynamicActionDescriptorChangeProvider.Instance);
            services.AddSingleton(DynamicActionDescriptorChangeProvider.Instance);

            IMvcBuilder mvcBuilder = services.AddControllersWithViews();

            mvcBuilder.AddJsonOptions(options => {
                //options.JsonSerializerOptions.IgnoreNullValues = true;
                options.JsonSerializerOptions.DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault;
            });

            #region module/references
            string referencesPath = Path.Combine(Environment.CurrentDirectory, "module", "references");
            if (Directory.Exists(referencesPath))
            {
                var current = AppDomain.CurrentDomain.GetAssemblies();
                foreach (string dllFile in Directory.GetFiles(referencesPath, "*.dll", SearchOption.AllDirectories))
                {
                    try
                    {
                        string loadedName = Path.GetFileNameWithoutExtension(dllFile);
                        if (current.Any(a => string.Equals(a.GetName().Name, loadedName, StringComparison.OrdinalIgnoreCase)))
                            continue;

                        Assembly loadedAssembly = Assembly.LoadFrom(dllFile);
                        mvcBuilder.AddApplicationPart(loadedAssembly);
                        Console.WriteLine($"load reference: {Path.GetFileName(dllFile)}");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Failed to load reference {dllFile}: {ex.Message}");
                    }
                }
            }
            #endregion

            ModuleRepository.Configuration(mvcBuilder);

            #region compilation modules
            if (AppInit.modules != null)
            {
                // mod.dll
                foreach (var mod in AppInit.modules)
                {
                    try
                    {
                        Console.WriteLine("load module: " + mod.dll);
                        mvcBuilder.AddApplicationPart(mod.assembly);
                    }
                    catch (Exception ex) { Console.WriteLine(ex.Message + "\n"); }
                }
            }

            //  dll  source
            if (File.Exists("module/manifest.json"))
            {
                var jss = new JsonSerializerSettings
                {
                    Error = (se, ev) =>
                    {
                        ev.ErrorContext.Handled = true;
                        Console.WriteLine("module/manifest.json - " + ev.ErrorContext.Error + "\n\n");
                    }
                };

                var mods = JsonConvert.DeserializeObject<List<RootModule>>(File.ReadAllText("module/manifest.json"), jss);
                if (mods == null)
                    return;

                #region CompilationMod
                List<PortableExecutableReference> references = null;

                void CompilationMod(RootModule mod)
                {
                    if (!mod.enable || AppInit.modules.FirstOrDefault(i => i.dll == mod.dll) != null)
                        return;

                    if (mod.dll.EndsWith(".dll"))
                    {
                        try
                        {
                            mod.assembly = Assembly.LoadFrom(mod.dll);

                            AppInit.modules.Add(mod);
                            mvcBuilder.AddApplicationPart(mod.assembly);
                            Console.WriteLine($"load module: {Path.GetFileName(mod.dll)}");
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"Failed to load reference {mod.dll}: {ex.Message}");
                        }

                        return;
                    }

                    string path = Directory.Exists(mod.dll) ? mod.dll : $"{Environment.CurrentDirectory}/module/{mod.dll}";
                    if (Directory.Exists(path))
                    {
                        var syntaxTree = new List<SyntaxTree>();

                        foreach (string file in Directory.GetFiles(path, "*.cs", SearchOption.AllDirectories))
                        {
                            string _file = file.Replace("\\", "/").Replace(path.Replace("\\", "/"), "").Replace(Environment.CurrentDirectory.Replace("\\", "/"), "");
                            if (Regex.IsMatch(_file, "(\\.vs|bin|obj|Properties)/", RegexOptions.IgnoreCase))
                                continue;

                            syntaxTree.Add(CSharpSyntaxTree.ParseText(File.ReadAllText(file)));
                        }

                        if (references == null)
                        {
                            var dependencyContext = DependencyContext.Default;
                            var assemblies = dependencyContext.RuntimeLibraries
                                .SelectMany(library => library.GetDefaultAssemblyNames(dependencyContext))
                                .Select(Assembly.Load)
                                .ToList();

                            references = assemblies.Select(assembly => MetadataReference.CreateFromFile(assembly.Location)).ToList();
                        }

                        if (mod.references != null)
                        {
                            foreach (string refns in mod.references)
                            {
                                string dlrns = Path.Combine(Environment.CurrentDirectory, "module", "references", refns);
                                if (!File.Exists(dlrns))
                                    dlrns = Path.Combine(Environment.CurrentDirectory, "module", mod.dll, refns);

                                if (File.Exists(dlrns) && references.FirstOrDefault(a => Path.GetFileName(a.FilePath) == refns) == null)
                                {
                                    var assembly = Assembly.LoadFrom(dlrns);
                                    references.Add(MetadataReference.CreateFromFile(assembly.Location));
                                }
                            }
                        }

                        CSharpCompilation compilation = CSharpCompilation.Create(Path.GetFileName(mod.dll), syntaxTree, references: references, options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

                        using (var ms = new MemoryStream())
                        {
                            var result = compilation.Emit(ms);

                            if (!result.Success)
                            {
                                Console.WriteLine($"\ncompilation error: {mod.dll}");
                                foreach (var diagnostic in result.Diagnostics)
                                {
                                    if (diagnostic.Severity == DiagnosticSeverity.Error)
                                        Console.WriteLine(diagnostic);
                                }
                                Console.WriteLine();
                            }
                            else
                            {
                                ms.Seek(0, SeekOrigin.Begin);
                                mod.assembly = Assembly.Load(ms.ToArray());

                                Console.WriteLine("compilation module: " + mod.dll);
                                mod.index = mod.index != 0 ? mod.index : (100 + AppInit.modules.Count);
                                AppInit.modules.Add(mod);
                                mvcBuilder.AddApplicationPart(mod.assembly);
                                WatchersDynamicModule(null, mvcBuilder, mod, path);
                            }
                        }
                    }
                }
                #endregion

                foreach (var mod in mods)
                    CompilationMod(mod);

                foreach (string folderMod in Directory.GetDirectories("module/"))
                {
                    string manifest = $"{Environment.CurrentDirectory}/{folderMod}/manifest.json";
                    if (!File.Exists(manifest))
                        continue;

                    var mod = JsonConvert.DeserializeObject<RootModule>(File.ReadAllText(manifest), jss);
                    if (mod != null)
                    {
                        if (mod.dll == null)
                            mod.dll = folderMod.Split("/")[1];
                        else if (mod.dll.EndsWith(".dll"))
                            mod.dll = Path.Combine(folderMod, mod.dll);

                        CompilationMod(mod);
                    }
                }

                if (references != null)
                    CSharpEval.appReferences = references;
            }

            if (AppInit.modules != null)
                AppInit.modules = AppInit.modules.OrderBy(i => i.index).ToList();

            Console.WriteLine();
            #endregion
        }
        #endregion


        public void Configure(IApplicationBuilder app, IWebHostEnvironment env, IMemoryCache memory, IHttpClientFactory httpClientFactory, IHostApplicationLifetime applicationLifetime)
        {
            _app = app;
            memoryCache = memory;
            Shared.Startup.Configure(app, memory);
            HybridCache.Configure(memory);
            ProxyManager.Configure(memory);
            Http.httpClientFactory = httpClientFactory;

            #region modules loaded
            if (AppInit.modules != null)
            {
                foreach (var mod in AppInit.modules)
                {
                    try
                    {
                        if (mod.dll == "DLNA.dll")
                            mod.initspace = "DLNA.ModInit";

                        if (mod.dll == "SISI.dll")
                            mod.initspace = "SISI.ModInit";

                        if (mod.dll == "Tracks.dll" || mod.dll == "TorrServer.dll")
                            mod.version = 2;

                        LoadedModule(app, mod);
                    }
                    catch (Exception ex) { Console.WriteLine($"Module {mod.NamespacePath(mod.initspace)}: {ex.Message}\n\n"); }
                }
            }
            #endregion

            if (!AppInit.conf.multiaccess)
                app.UseDeveloperExceptionPage();

            applicationLifetime.ApplicationStopping.Register(OnShutdown);

            applicationLifetime.ApplicationStarted.Register(() =>
            {
                if (!string.IsNullOrEmpty(AppInit.conf.listen.sock))
                    _ = Bash.Run($"while [ ! -S /var/run/{AppInit.conf.listen.sock}.sock ]; do sleep 1; done && chmod 666 /var/run/{AppInit.conf.listen.sock}.sock").ConfigureAwait(false);
            });

            #region UseForwardedHeaders
            var forwarded = new ForwardedHeadersOptions
            {
                ForwardLimit = null,
                ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto
            };

            if (AppInit.conf.KnownProxies != null && AppInit.conf.KnownProxies.Count > 0)
            {
                foreach (var k in AppInit.conf.KnownProxies)
                    forwarded.KnownNetworks.Add(new Microsoft.AspNetCore.HttpOverrides.IPNetwork(IPAddress.Parse(k.ip), k.prefixLength));
            }

            app.UseForwardedHeaders(forwarded);
            #endregion

            app.UseWebSockets();
            app.UseRouting();

            if (AppInit.conf.listen.compression)
                app.UseResponseCompression();

            app.UseModHeaders();
            app.UseRequestStatistics();
            app.UseRequestInfo();
            app.UseAnonymousRequest();

            app.UseAlwaysRjson();
            app.UseModule(first: true);
            app.UseOverrideResponse(first: true);

            #region UseStaticFiles
            app.UseStaticFiles(new StaticFileOptions
            {
                ServeUnknownFileTypes = true,
                DefaultContentType = "application/octet-stream",
                ContentTypeProvider = new FileExtensionContentTypeProvider() 
                {
                    Mappings =
                    {
                        [".m4s"]  = "video/mp4",
                        [".ts"]   = "video/mp2t",
                        [".mp4"]  = "video/mp4",
                        [".mkv"]  = "video/x-matroska",
                        [".m3u"]  = "application/x-mpegURL",
                        [".m3u8"] = "application/vnd.apple.mpegurl",
                        [".webm"] = "video/webm",
                        [".mov"]  = "video/quicktime",
                        [".avi"]  = "video/x-msvideo",
                        [".wmv"]  = "video/x-ms-wmv",
                        [".flv"]  = "video/x-flv",
                        [".ogv"]  = "video/ogg",
                        [".m2ts"] = "video/MP2T",
                        [".vob"]  = "video/x-ms-vob",

                        [".apk"]  = "application/vnd.android.package-archive",
                        [".aab"]  = "application/vnd.android.appbundle",
                        [".xapk"]  = "application/vnd.android.package-archive",
                        [".apkm"]  = "application/vnd.android.package-archive",
                        [".obb"]  = "application/octet-stream",

                        [".exe"]  = "application/vnd.microsoft.portable-executable",
                        [".msi"]  = "application/x-msi",
                        [".bat"]  = "application/x-msdownload",
                        [".cmd"]  = "application/x-msdownload",
                        [".msix"]        = "application/msix",
                        [".msixbundle"]  = "application/msixbundle",
                        [".appx"]        = "application/appx",
                        [".appxbundle"]  = "application/appxbundle",

                        [".deb"]  = "application/vnd.debian.binary-package",
                        [".rpm"]  = "application/x-rpm",
                        [".sh"]   = "application/x-sh",
                        [".bin"]  = "application/octet-stream",
                        [".run"]  = "application/x-msdownload",
                        [".appimage"] = "application/octet-stream",

                        [".pkg"]  = "application/octet-stream",
                        [".dmg"]  = "application/x-apple-diskimage",

                        [".zip"] = "application/zip",
                        [".rar"] = "application/vnd.rar",
                        [".7z"]  = "application/x-7z-compressed",
                        [".gz"]  = "application/gzip",
                        [".tar"] = "application/x-tar",
                        [".tgz"] = "application/gzip",

                        [".iso"] = "application/x-iso9660-image"
                    }
                }
            });
            #endregion

            app.UseWAF();
            app.UseAccsdb();

            app.MapWhen(context => context.Request.Path.Value.StartsWith("/proxy/") || context.Request.Path.Value.StartsWith("/proxy-dash/"), proxyApp =>
            {
                proxyApp.UseProxyAPI();
            });

            app.MapWhen(context => context.Request.Path.Value.StartsWith("/proxyimg"), proxyApp =>
            {
                proxyApp.UseProxyIMG();
            });

            app.MapWhen(context => context.Request.Path.Value.StartsWith("/cub/"), proxyApp =>
            {
                proxyApp.UseProxyCub();
            });

            app.MapWhen(context => context.Request.Path.Value.StartsWith("/tmdb/"), proxyApp =>
            {
                proxyApp.UseProxyTmdb();
            });

            app.UseModule(first: false);
            app.UseOverrideResponse(first: false);

            app.Map("/nws", builder =>
            {
                builder.Run(nws.HandleWebSocketAsync);
            });

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapHub<soks>("/ws");
                endpoints.MapControllers();
            });
        }


        #region OnShutdown
        void OnShutdown()
        {
            if (Program._reload)
                return;

            IsShutdown = true;
            Shared.Startup.IsShutdown = true;

            Chromium.FullDispose();
            Firefox.FullDispose();
            nws.FullDispose();
            soks.FullDispose();

            DisposeModule(null);
        }
        #endregion

        #region WatchRebuildModule
        static readonly Dictionary<string, FileSystemWatcher> moduleWatchers = new();

        static readonly object moduleWatcherLock = new object();

        void WatchersDynamicModule(IApplicationBuilder app, IMvcBuilder mvcBuilder, RootModule mod, string path)
        {
            if (!mod.dynamic)
                return;

            path = Path.GetFullPath(path);

            lock (moduleWatcherLock)
            {
                if (moduleWatchers.ContainsKey(path))
                    return;

                var watcher = new FileSystemWatcher(path)
                {
                    IncludeSubdirectories = true,
                    NotifyFilter = NotifyFilters.FileName | NotifyFilters.LastWrite | NotifyFilters.Size
                };

                watcher.Filters.Add("*.cs");
                watcher.Filters.Add("manifest.json");

                CancellationTokenSource debounceCts = null;
                object debounceLock = new object();

                void Recompile(object sender, FileSystemEventArgs e)
                {
                    string _file = e.FullPath.Replace("\\", "/").Replace(path.Replace("\\", "/"), "").Replace(Environment.CurrentDirectory.Replace("\\", "/"), "");
                    if (Regex.IsMatch(_file, "(\\.vs|bin|obj|Properties)/", RegexOptions.IgnoreCase))
                        return;

                    CancellationTokenSource cts;

                    lock (debounceLock)
                    {
                        debounceCts?.Cancel();
                        debounceCts = new CancellationTokenSource();
                        cts = debounceCts;
                    }

                    _ = Task.Run(async () =>
                    {
                        await Task.Delay(TimeSpan.FromSeconds(2), cts.Token);

                        if (cts.IsCancellationRequested)
                            return;

                        watcher.EnableRaisingEvents = false;

                        try
                        {
                            var parts = mvcBuilder.PartManager.ApplicationParts
                                .OfType<AssemblyPart>()
                                .Where(p => p.Assembly == mod.assembly)
                                .ToList();

                            #region update manifest.json
                            string manifestPath = Path.Combine(path, "manifest.json");
                            RootModule manifestMod = null;

                            if (File.Exists(manifestPath))
                            {
                                try
                                {
                                    manifestMod = JsonConvert.DeserializeObject<RootModule>(File.ReadAllText(manifestPath));

                                    var excludedProperties = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
                                    {
                                        nameof(RootModule.dynamic),
                                        nameof(RootModule.index),
                                        nameof(RootModule.dll),
                                        nameof(RootModule.assembly),
                                        nameof(RootModule.initspace)
                                    };

                                    foreach (var property in typeof(RootModule).GetProperties(BindingFlags.Public | BindingFlags.Instance))
                                    {
                                        if (!property.CanRead || !property.CanWrite || excludedProperties.Contains(property.Name))
                                            continue;

                                        property.SetValue(mod, property.GetValue(manifestMod));
                                    }
                                }
                                catch (Exception manifestEx)
                                {
                                    Console.WriteLine($"Failed to update manifest for {mod.dll}: {manifestEx.Message}");
                                }
                            }
                            #endregion

                            var assembly = CSharpEval.Compilation(mod);
                            if (assembly != null)
                            {
                                DisposeModule(mod);

                                foreach (var part in parts)
                                    mvcBuilder.PartManager.ApplicationParts.Remove(part);

                                if (manifestMod != null)
                                    mod.initspace = manifestMod.initspace;

                                mod.assembly = assembly;
                                LoadedModule(app, mod);

                                mvcBuilder.PartManager.ApplicationParts.Add(new AssemblyPart(mod.assembly));
                                DynamicActionDescriptorChangeProvider.Instance.NotifyChanges();

                                MiddlewaresModuleEntry.EnsureCache(forced: true);
                                OnlineModuleEntry.EnsureCache(forced: true);
                                SisiModuleEntry.EnsureCache(forced: true);

                                Console.WriteLine("rebuild module: " + mod.dll);
                            }
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"Failed to rebuild module {mod.dll}: {ex.Message}");
                        }
                        finally
                        {
                            watcher.EnableRaisingEvents = true;
                        }
                    });
                }

                watcher.Changed += Recompile;
                watcher.Created += Recompile;
                watcher.Deleted += Recompile;
                watcher.Renamed += Recompile;

                watcher.EnableRaisingEvents = true;
                moduleWatchers[path] = watcher;
            }
        }
        #endregion

        #region LoadedModule
        void LoadedModule(IApplicationBuilder app, RootModule mod)
        {
            if (mod == null)
                return;

            if (mod.initspace != null && mod.assembly.GetType(mod.NamespacePath(mod.initspace)) is Type t && t.GetMethod("loaded") is MethodInfo m)
            {
                if (mod.version >= 2)
                {
                    m.Invoke(null, [
                        new InitspaceModel()
                        {
                            path = $"module/{mod.dll}",
                            soks = new soks(),
                            nws = new nws(),
                            memoryCache = memoryCache,
                            configuration = Configuration,
                            services = serviceCollection,
                            app = app ?? _app
                        }
                    ]);
                }
                else
                    m.Invoke(null, []);
            }
        }
        #endregion

        #region DisposeModule
        void DisposeModule(RootModule module)
        {
            if (AppInit.modules == null)
                return;

            if (module != null)
            {
                try
                {
                    if (module.initspace != null && module.assembly.GetType(module.NamespacePath(module.initspace)) is Type t && t.GetMethod("Dispose") is MethodInfo m)
                        m.Invoke(null, []);
                }
                catch { }
            }
            else
            {
                foreach (var mod in AppInit.modules)
                {
                    try
                    {
                        if (mod.initspace != null && mod.assembly.GetType(mod.NamespacePath(mod.initspace)) is Type t && t.GetMethod("Dispose") is MethodInfo m)
                            m.Invoke(null, []);
                    }
                    catch { }
                }
            }
        }
        #endregion
    }
}

```

## File: Lampac/Program.cs
```
using Lampac.Engine;
using Lampac.Engine.CRON;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.SignalR;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Hosting;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Models.Base;
using Shared.Models.SISI.Base;
using Shared.Models.SQL;
using Shared.PlaywrightCore;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Runtime.Loader;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace Lampac
{
    public class Program
    {
        #region static
        public static bool _reload = true;

        static IHost _host;

        public static List<(IPAddress prefix, int prefixLength)> cloudflare_ips = new List<(IPAddress prefix, int prefixLength)>();

        static Timer _usersTimer, _kitTimer;
        #endregion

        #region Main
        public static void Main(string[] args)
        {
            var assemblies = AppDomain.CurrentDomain.GetAssemblies();

            bool IsAssemblyLoaded(AssemblyName assemblyName)
            {
                foreach (var assembly in assemblies)
                {
                    if (assembly.GetName().Name == assemblyName.Name)
                        return true;
                }

                return false;
            }

            foreach (string dllPath in Directory.GetFiles(Path.Combine(AppContext.BaseDirectory, "runtimes", "references"), "*.dll"))
            {
                try
                {
                    AssemblyName assemblyName = AssemblyName.GetAssemblyName(dllPath);
                    if (!IsAssemblyLoaded(assemblyName))
                        Assembly.LoadFrom(dllPath);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Failed to load {dllPath}: {ex.Message}");
                }
            }


            AssemblyLoadContext.Default.Resolving += (context, assemblyName) =>
            {
                foreach (string name in new string[] { $"ru/{assemblyName.Name}", assemblyName.Name })
                {
                    string assemblyPath = Path.Combine(AppContext.BaseDirectory, "runtimes", "references", name);
                    if (File.Exists(assemblyPath))
                        return context.LoadFromAssemblyPath(assemblyPath);
                }

                return null;
            };

            Run(args);
        }
        #endregion

        #region Run
        static void Run(string[] args)
        {
            CultureInfo.CurrentCulture = new CultureInfo("ru-RU");
            Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);

            #region GC
            var gc = AppInit.conf.GC;
            if (gc != null && gc.enable && (gc.aggressive || AppInit.conf.multiaccess == false))
            {
                if (gc.Concurrent.HasValue)
                    AppContext.SetSwitch("System.GC.Concurrent", gc.Concurrent.Value);

                if (gc.ConserveMemory.HasValue)
                    AppContext.SetData("System.GC.ConserveMemory", gc.ConserveMemory.Value);

                if (gc.HighMemoryPercent.HasValue)
                    AppContext.SetData("System.GC.HighMemoryPercent", gc.HighMemoryPercent.Value);

                if (gc.RetainVM.HasValue)
                    AppContext.SetSwitch("System.GC.RetainVM", gc.RetainVM.Value);
            }
            #endregion

            Http.onlog += (e, log) =>
            {
                nws.SendLog(log, "http");
                soks.SendLog(log, "http");
            };

            RchClient.hub += (e, req) =>
            {
                _ = nws.SendRchRequestAsync(req.connectionId, req.rchId, req.url, req.data, req.headers, req.returnHeaders).ConfigureAwait(false);
                _ = soks.hubClients?.Client(req.connectionId)?.SendAsync("RchClient", req.rchId, req.url, req.data, req.headers, req.returnHeaders)?.ConfigureAwait(false);
            };

            string init = JsonConvert.SerializeObject(AppInit.conf, Formatting.Indented, new JsonSerializerSettings()
            {
                NullValueHandling = NullValueHandling.Ignore
            });

            Console.WriteLine(init + "\n");
            File.WriteAllText("current.conf", JsonConvert.SerializeObject(AppInit.conf, Formatting.Indented));

            ThreadPool.GetMinThreads(out int workerThreads, out int completionPortThreads);
            ThreadPool.SetMinThreads(Math.Max(4096, workerThreads), Math.Max(1024, completionPortThreads));

            #region passwd
            if (!File.Exists("passwd"))
            {
                AppInit.rootPasswd = Guid.NewGuid().ToString();
                File.WriteAllText("passwd", AppInit.rootPasswd);
            }
            else
            {
                AppInit.rootPasswd = File.ReadAllText("passwd");
                AppInit.rootPasswd = Regex.Replace(AppInit.rootPasswd, "[\n\r\t ]+", "").Trim();
            }
            #endregion

            #region vers.txt
            if (!File.Exists("data/vers.txt"))
                File.WriteAllText("data/vers.txt", BaseController.appversion);

            if (!File.Exists("data/vers-minor.txt"))
                File.WriteAllText("data/vers-minor.txt", "1");
            #endregion

            #region SQL
            ExternalidsContext.Initialization();
            HybridCacheContext.Initialization();
            SisiContext.Initialization();
            ProxyLinkContext.Initialization();
            PlaywrightContext.Initialization();
            SyncUserContext.Initialization();
            #endregion

            #region migration
            if (Directory.Exists("cache/storage") || Directory.Exists("cache/bookmarks/sisi"))
            {
                Console.WriteLine("run migration");

                #region cache/storage
                if (Directory.Exists("cache/storage"))
                {
                    string sourceDir = "cache/storage";
                    string targetDir = "database/storage";

                    void CopyAll(string source, string target)
                    {
                        Directory.CreateDirectory(target);

                        foreach (string file in Directory.GetFiles(source))
                        {
                            string destFile = Path.Combine(target, Path.GetFileName(file));
                            File.Copy(file, destFile, true);
                        }

                        foreach (string dir in Directory.GetDirectories(source))
                        {
                            string destDir = Path.Combine(target, Path.GetFileName(dir));
                            CopyAll(dir, destDir);
                        }
                    }

                    CopyAll(sourceDir, targetDir);

                    Directory.Move("cache/storage", "cache/storage.bak");
                }
                #endregion

                #region cache/bookmarks/sisi
                if (Directory.Exists("cache/bookmarks/sisi"))
                {
                    using (var sqlDb = new SisiContext())
                    {
                        var existing = new HashSet<string>(
                            sqlDb.bookmarks
                                 .AsNoTracking()
                                 .Select(i => $"{i.user}:{i.uid}")
                        );

                        foreach (string folder in Directory.GetDirectories("cache/bookmarks/sisi"))
                        {
                            string folderName = Path.GetFileName(folder);

                            foreach (string file in Directory.GetFiles(folder))
                            {
                                try
                                {
                                    string md5user = folderName + Path.GetFileName(file);
                                    var bookmarks = JsonConvert.DeserializeObject<List<PlaylistItem>>(File.ReadAllText(file));

                                    if (bookmarks == null || bookmarks.Count == 0)
                                        continue;

                                    DateTime now = DateTime.UtcNow;

                                    for (int i = 0; i < bookmarks.Count; i++)
                                    {
                                        var pl = bookmarks[i];

                                        if (pl?.bookmark == null || string.IsNullOrEmpty(pl.bookmark.uid))
                                            continue;

                                        if (!existing.Add($"{md5user}:{pl.bookmark.uid}"))
                                            continue;

                                        sqlDb.bookmarks.Add(new SisiBookmarkSqlModel
                                        {
                                            user = md5user,
                                            uid = pl.bookmark.uid,
                                            created = now.AddSeconds(-i),
                                            json = JsonConvert.SerializeObject(pl),
                                            name = pl.name,
                                            model = pl.model?.name
                                        });
                                    }
                                }
                                catch { }
                            }
                        }

                        sqlDb.SaveChanges();
                    }

                    Directory.Move("cache/bookmarks/sisi", "cache/bookmarks/sisi.bak");
                }
                #endregion
            }
            #endregion

            #region Playwright
            if (AppInit.conf.chromium.enable || AppInit.conf.firefox.enable)
            {
                if (!AppInit.conf.multiaccess)
                    Environment.SetEnvironmentVariable("NODE_OPTIONS", "--max-old-space-size=256");

                ThreadPool.QueueUserWorkItem(async _ =>
                {
                    if (await PlaywrightBase.InitializationAsync())
                    {
                        if (AppInit.conf.chromium.enable)
                            _ = Chromium.CreateAsync().ConfigureAwait(false);

                        if (AppInit.conf.firefox.enable)
                            _ = Firefox.CreateAsync().ConfigureAwait(false);
                    }
                });

                Chromium.CronStart();
                Firefox.CronStart();
            }
            #endregion

            #region cloudflare_ips
            ThreadPool.QueueUserWorkItem(async _ => 
            {
                string ips = await Http.Get("https://www.cloudflare.com/ips-v4");
                if (ips == null || !ips.Contains("173.245."))
                    ips = File.Exists("data/cloudflare/ips-v4.txt") ? File.ReadAllText("data/cloudflare/ips-v4.txt") : null;

                if (ips != null)
                {
                    string ips_v6 = await Http.Get("https://www.cloudflare.com/ips-v6");
                    if (ips_v6 == null || !ips_v6.Contains("2400:cb00"))
                        ips_v6 = File.Exists("data/cloudflare/ips-v6.txt") ? File.ReadAllText("data/cloudflare/ips-v6.txt") : null;

                    if (ips_v6 != null)
                    {
                        foreach (string ip in (ips + "\n" + ips_v6).Split('\n'))
                        {
                            if (string.IsNullOrEmpty(ip) || !ip.Contains("/"))
                                continue;

                            try
                            {
                                string[] ln = ip.Split('/');
                                cloudflare_ips.Add((IPAddress.Parse(ln[0].Trim()), int.Parse(ln[1].Trim())));
                            }
                            catch { }
                        }
                    }
                }

                Console.WriteLine($"cloudflare_ips: {cloudflare_ips.Count}");
            });
            #endregion

            #region fix update.sh
            if (File.Exists("update.sh"))
            {
                var olds = new string[] 
                {
                    "02a7e97392e63b7e9e35a39ce475d6f8",
                    "6354eab8b101af90cb247fc8c977dd6b",
                    "b94b42ff158682661761a0b50a808a3b",
                    "97b0d657786b14e6a2faf7186de0556c",
                    "6b60a4d2173e99b11ecf4e792a24f598",
                    "cae6f0e79bbb2e6832922f25614d83a1",
                    "97b0d657786b14e6a2faf7186de0556c",
                    "cae6f0e79bbb2e6832922f25614d83a1",
                    "587794ca93c8d0318332858cf0e71e98",
                    "174ac2b94c5aa0e5ac086f843fd086a6",
                    "9c258d50e9eb06316efdf33de8b66dc3",
                    "bb4d6f2ba74b6a25dc3e4638c7f5282a",
                    "9607ae5805eaf5d06220298581a99beb",
                    "30078b973188c696273e10d6ef0ebbb2",
                    "92f5e2e03d2cc2697f2ee00becdb4696",
                    "b565c7e163485b8f8cc258b95f2891b6",
                    "ec6659f1f91f1f6ec0c734ff2111c7d7"
                };

                try
                {
                    if (olds.Contains(CrypTo.md5(File.ReadAllText("update.sh"))))
                    {
                        ThreadPool.QueueUserWorkItem(async _ => 
                        {
                            string new_update = await Http.Get("https://raw.githubusercontent.com/immisterio/Lampac/refs/heads/main/update.sh");
                            if (new_update != null && new_update.Contains("DEST=\"/home/lampac\""))
                                File.WriteAllText("update.sh", new_update);
                        });
                    }
                }
                catch { }
            }
            #endregion

            CacheCron.Run();
            KurwaCron.Run();
            PluginsCron.Run();
            SyncCron.Run();
            TrackersCron.Run();
            LampaCron.Run();

            _usersTimer = new Timer(UpdateUsersDb, null, TimeSpan.Zero, TimeSpan.FromSeconds(1));
            _kitTimer = new Timer(UpdateKitDb, null, TimeSpan.Zero, TimeSpan.FromSeconds(Math.Max(5, AppInit.conf.kit.cacheToSeconds)));

            while (_reload)
            {
                _host = CreateHostBuilder(args).Build();
                _reload = false;
                _host.Run();
            }
        }
        #endregion


        #region Reload
        public static void Reload()
        {
            _reload = true;
            _host.StopAsync();

            AppInit.LoadModules();
        }
        #endregion

        #region CreateHostBuilder
        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseKestrel(op =>
                    {
                        op.AddServerHeader = false;

                        if (AppInit.conf.listen.keepalive.HasValue && AppInit.conf.listen.keepalive.Value > 0)
                            op.Limits.KeepAliveTimeout = TimeSpan.FromSeconds(AppInit.conf.listen.keepalive.Value);

                        op.ConfigureEndpointDefaults(endpointOptions =>
                        {
                            if (AppInit.conf.listen.endpointDefaultsProtocols.HasValue)
                                endpointOptions.Protocols = AppInit.conf.listen.endpointDefaultsProtocols.Value;
                        });

                        if (string.IsNullOrEmpty(AppInit.conf.listen.sock) && string.IsNullOrEmpty(AppInit.conf.listen.ip))
                        {
                            op.Listen(IPAddress.Parse("127.0.0.1"), 9118);
                        }
                        else
                        {
                            if (!string.IsNullOrEmpty(AppInit.conf.listen.sock))
                            {
                                if (File.Exists($"/var/run/{AppInit.conf.listen.sock}.sock"))
                                    File.Delete($"/var/run/{AppInit.conf.listen.sock}.sock");

                                op.ListenUnixSocket($"/var/run/{AppInit.conf.listen.sock}.sock");
                            }

                            if (!string.IsNullOrEmpty(AppInit.conf.listen.ip))
                                op.Listen(AppInit.conf.listen.ip == "any" ? IPAddress.Any : AppInit.conf.listen.ip == "broadcast" ? IPAddress.Broadcast : IPAddress.Parse(AppInit.conf.listen.ip), AppInit.conf.listen.port);
                        }
                    })
                    .UseStartup<Startup>();
                });
        #endregion


        #region UpdateUsersDb
        static bool _updateUsersDb = false;
        static string _usersKeyUpdate = string.Empty;

        static void UpdateUsersDb(object state)
        {
            if (_updateUsersDb)
                return;

            try
            {
                _updateUsersDb = true;

                if (File.Exists("users.json"))
                {
                    var lastWriteTime = File.GetLastWriteTime("users.json");

                    string keyUpdate = $"{AppInit.conf?.guid}:{AppInit.conf?.accsdb?.users?.Count ?? 0}:{lastWriteTime}";
                    if (keyUpdate == _usersKeyUpdate)
                        return;

                    foreach (var user in JsonConvert.DeserializeObject<List<AccsUser>>(File.ReadAllText("users.json")))
                    {
                        try
                        {
                            var find = AppInit.conf.accsdb.findUser(user.id ?? user.ids?.First());
                            if (find != null)
                            {
                                find.id = user.id;
                                find.ids = user.ids;
                                find.group = user.group;
                                find.IsPasswd = user.IsPasswd;
                                find.expires = user.expires;
                                find.ban = user.ban;
                                find.ban_msg = user.ban_msg;
                                find.comment = user.comment;
                                find.@params = user.@params;
                            }
                            else
                            {
                                AppInit.conf.accsdb.users.Add(user);
                            }
                        }
                        catch { }
                    }

                    _usersKeyUpdate = keyUpdate;
                }
            }
            catch { }
            finally
            {
                _updateUsersDb = false;
            }
        }
        #endregion

        #region UpdateKitDb
        static bool _updateKitDb = false;

        async static void UpdateKitDb(object state)
        {
            if (_updateKitDb)
                return;

            try
            {
                _updateKitDb = true;

                if (AppInit.conf.kit.enable && AppInit.conf.kit.IsAllUsersPath && !string.IsNullOrEmpty(AppInit.conf.kit.path))
                {
                    var users = await Http.Get<Dictionary<string, JObject>>(AppInit.conf.kit.path);
                    if (users != null)
                        AppInit.conf.kit.allUsers = users;
                }
            }
            catch { }
            finally
            {
                _updateKitDb = false;
            }
        }
        #endregion
    }
}

```

## File: Lampac/Controllers/ApiController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.CodeAnalysis.Scripting;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Models.CSharpGlobals;
using Shared.Models.Events;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO.Compression;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Web;
using IO = System.IO;

namespace Lampac.Controllers
{
    public class ApiController : BaseController
    {
        #region Index
        [AllowAnonymous]
        [Route("/")]
        public ActionResult Index()
        {
            if (string.IsNullOrWhiteSpace(AppInit.conf.LampaWeb.index))
                return Content("api work", contentType: "text/plain; charset=utf-8");

            if (AppInit.conf.LampaWeb.basetag && Regex.IsMatch(AppInit.conf.LampaWeb.index, "/[^\\./]+\\.html$"))
            {
                if (!memoryCache.TryGetValue($"LampaWeb.index:{AppInit.conf.LampaWeb.index}", out string html))
                {
                    html = IO.File.ReadAllText($"wwwroot/{AppInit.conf.LampaWeb.index}");
                    html = html.Replace("<head>", $"<head><base href=\"/{Regex.Match(AppInit.conf.LampaWeb.index, "^([^/]+)/").Groups[1].Value}/\" />");

                    memoryCache.Set($"LampaWeb.index:{AppInit.conf.LampaWeb.index}", html, DateTime.Now.AddMinutes(1));
                }

                return Content(html, contentType: "text/html; charset=utf-8");
            }

            return LocalRedirect($"/{AppInit.conf.LampaWeb.index}");
        }
        #endregion

        #region Extensions
        [AllowAnonymous]
        [Route("/extensions")]
        public ActionResult Extensions()
        {
            return ContentTo(FileCache.ReadAllText("plugins/extensions.json").Replace("{localhost}", host).Replace("\n", "").Replace("\r", ""));
        }
        #endregion

        #region Version / Headers / geo / myip / reqinfo / personal.lampa
        [AllowAnonymous]
        [Route("/version")]
        public ActionResult Version() => Content($"{appversion}.{minorversion}");

        [AllowAnonymous]
        [Route("/ping")]
        public ActionResult PingPong() => Content("pong");

        [AllowAnonymous]
        [Route("/headers")]
        public ActionResult Headers() => Json(HttpContext.Request.Headers);

        [AllowAnonymous]
        [Route("/geo")]
        public ActionResult Geo(string select, string ip)
        {
            if (select == "ip")
                return Content(ip ?? requestInfo.IP);

            string country = requestInfo.Country;
            if (ip != null)
                country = GeoIP2.Country(ip);

            if (select == "country")
                return Content(country);

            return Json(new
            { 
                ip = ip ?? requestInfo.IP,
                country
            });
        }

        [AllowAnonymous]
        [Route("/myip")]
        public ActionResult MyIP() => Content(requestInfo.IP);

        [Route("/reqinfo")]
        public ActionResult Reqinfo() => ContentTo(JsonConvert.SerializeObject(requestInfo, new JsonSerializerSettings()
        {
            NullValueHandling = NullValueHandling.Ignore,
            DefaultValueHandling = DefaultValueHandling.Ignore
        }));

        [AllowAnonymous]
        [Route("/personal.lampa")]
        [Route("/lampa-main/personal.lampa")]
        [Route("/{myfolder}/personal.lampa")]
        public ActionResult PersonalLampa(string myfolder) => StatusCode(200);
        #endregion

        #region testaccsdb
        [Route("/testaccsdb")]
        public ActionResult TestAccsdb(string account_email, string uid) 
        {
            if (!string.IsNullOrEmpty(AppInit.conf.accsdb.shared_passwd) && uid == AppInit.conf.accsdb.shared_passwd)
                return ContentTo("{\"accsdb\": true, \"newuid\": true}");

            if (!string.IsNullOrEmpty(uid) && !string.IsNullOrEmpty(account_email) && account_email == AppInit.conf.accsdb.shared_passwd)
            {
                try
                {
                    string file = "users.json";

                    JArray arr = new JArray();

                    if (IO.File.Exists(file))
                    {
                        var txt = IO.File.ReadAllText(file);
                        if (!string.IsNullOrWhiteSpace(txt))
                            try { arr = JArray.Parse(txt); } catch { arr = new JArray(); }
                    }

                    bool exists = arr.Children<JObject>().Any(o =>
                        (o.Value<string>("id") != null && o.Value<string>("id").Equals(uid, StringComparison.OrdinalIgnoreCase)) ||
                        (o["ids"] != null && o["ids"].Any(t => t.ToString().Equals(uid, StringComparison.OrdinalIgnoreCase)))
                    );

                    if (exists)
                        return ContentTo("{\"accsdb\": false}");

                    var obj = new JObject();
                    obj["id"] = uid;
                    obj["expires"] = DateTime.Now.AddDays(Math.Max(1, AppInit.conf.accsdb.shared_daytime));

                    arr.Add(obj);

                    IO.File.WriteAllText(file, arr.ToString(Formatting.Indented));

                    return ContentTo("{\"accsdb\": false, \"success\": true, \"uid\": \"" + uid + "\"}");
                }
                catch { return ContentTo("{\"accsdb\": true}"); }
            }

            return ContentTo("{\"accsdb\": false, \"success\": true}");
        }
        #endregion

        #region Sync
        [Route("/api/sync")]
        public ActionResult Sync()
        {
            var sync = AppInit.conf.sync;
            if (!requestInfo.IsLocalRequest || !sync.enable || sync.type != "master")
                return Content("error");

            if (sync.initconf == "current")
                return Content(JsonConvert.SerializeObject(AppInit.conf), "application/json; charset=utf-8");

            var init = new AppInit();

            string confile = "sync.conf";
            if (sync.override_conf != null && sync.override_conf.TryGetValue(requestInfo.IP, out string _conf))
                confile = _conf;

            if (IO.File.Exists(confile))
                init = JsonConvert.DeserializeObject<AppInit>(IO.File.ReadAllText(confile));

            init.accsdb.users = AppInit.conf.accsdb.users;

            string json = JsonConvert.SerializeObject(init);
            json = json.Replace("{server_ip}", requestInfo.IP);

            return Content(json, "application/json; charset=utf-8");
        }
        #endregion


        #region app.min.js
        [AllowAnonymous]
        [Route("/app.min.js")]
        [Route("{type}/app.min.js")]
        public ContentResult LampaApp(string type)
        {
            if (string.IsNullOrEmpty(type))
            {
                if (AppInit.conf.LampaWeb.path != null)
                {
                    type = AppInit.conf.LampaWeb.path;
                }
                else
                {
                    if (AppInit.conf.LampaWeb.index == null || !AppInit.conf.LampaWeb.index.Contains("/"))
                        return Content(string.Empty, "application/javascript; charset=utf-8");

                    type = AppInit.conf.LampaWeb.index.Split("/")[0];
                }
            }

            bool usecubproxy = AppInit.conf.cub.enabled(requestInfo.Country);
            var apr = AppInit.conf.LampaWeb.appReplace ?? InvkEvent.conf?.Controller?.AppReplace?.appjs?.regex;

            string memKey = $"ApiController:{type}:{host}:{usecubproxy}:{apr?.Count ?? 0}:app.min.js";
            if (!memoryCache.TryGetValue(memKey, out string file))
            {
                file = IO.File.ReadAllText($"wwwroot/{type}/app.min.js");

                #region appReplace
                if (apr != null)
                {
                    foreach (var r in apr)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        val = val.Replace("{localhost}", host).Replace("{host}", Regex.Replace(host, "^https?://", ""));
                        file = Regex.Replace(file, r.Key, val, RegexOptions.IgnoreCase);
                    }
                }

                if (InvkEvent.conf?.Controller?.AppReplace?.appjs?.list != null)
                {
                    foreach (var r in InvkEvent.conf.Controller.AppReplace.appjs.list)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        val = val.Replace("{localhost}", host).Replace("{host}", Regex.Replace(host, "^https?://", ""));
                        file = file.Replace(r.Key, val);
                    }
                }
                #endregion

                string playerinner = FileCache.ReadAllText("plugins/player-inner.js", saveCache: false)
                       .Replace("{useplayer}", (!string.IsNullOrEmpty(AppInit.conf.playerInner)).ToString().ToLower())
                       .Replace("{notUseTranscoding}", (AppInit.conf.transcoding.enable == false).ToString().ToLower());

                var bulder = new StringBuilder(file);

                bulder = bulder.Replace("Player.play(element);", playerinner);

                if (usecubproxy)
                {
                    bulder = bulder.Replace("protocol + mirror + '/api/checker'", $"'{host}/cub/api/checker'");
                    bulder = bulder.Replace("Utils$1.protocol() + 'tmdb.' + object$2.cub_domain + '/' + u,", $"'{host}/cub/tmdb./' + u,");
                    bulder = bulder.Replace("Utils$2.protocol() + 'tmdb.' + object$2.cub_domain + '/' + u,", $"'{host}/cub/tmdb./' + u,");
                    bulder = bulder.Replace("Utils$1.protocol() + object$2.cub_domain", $"'{host}/cub/red'");
                    bulder = bulder.Replace("Utils$2.protocol() + object$2.cub_domain", $"'{host}/cub/red'");
                    bulder = bulder.Replace("object$2.cub_domain", $"'{AppInit.conf.cub.mirror}'");
                }

                bulder = bulder.Replace("http://lite.lampa.mx", $"{host}/{type}");
                bulder = bulder.Replace("https://yumata.github.io/lampa-lite", $"{host}/{type}");

                bulder = bulder.Replace("http://lampa.mx", $"{host}/{type}");
                bulder = bulder.Replace("https://yumata.github.io/lampa", $"{host}/{type}");

                bulder = bulder.Replace("window.lampa_settings.dcma = dcma;", "window.lampa_settings.fixdcma = true;");
                bulder = bulder.Replace("Storage.get('vpn_checked_ready', 'false')", "true");

                bulder = bulder.Replace("status$1 = false;", "status$1 = true;"); // local apk to personal.lampa
                bulder = bulder.Replace("return status$1;", "return true;"); // –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∫–ª–∞–º—ã
                bulder = bulder.Replace("if (!Storage.get('metric_uid', ''))", "return;"); // metric
                bulder = bulder.Replace("function log(data) {", "function log(data) { return;");
                bulder = bulder.Replace("function stat$1(method, name) {", "function stat$1(method, name) { return;");
                bulder = bulder.Replace("if (domain) {", "if (false) {");

                bulder = bulder.Replace("{localhost}", host);

                file = bulder.ToString();

                if (AppInit.conf.mikrotik == false)
                    memoryCache.Set(memKey, file, DateTime.Now.AddMinutes(1));
            }

            if (InvkEvent.conf?.Controller?.AppReplace?.appjs?.eval != null)
                file = InvkEvent.AppReplace("appjs", new EventAppReplace(file, null, type, host, requestInfo, HttpContext.Request, hybridCache));

            return Content(file, "application/javascript; charset=utf-8");
        }
        #endregion

        #region app.css
        [AllowAnonymous]
        [Route("/css/app.css")]
        [Route("{type}/css/app.css")]
        public ContentResult LampaAppCss(string type)
        {
            if (string.IsNullOrEmpty(type))
            {
                if (AppInit.conf.LampaWeb.path != null)
                {
                    type = AppInit.conf.LampaWeb.path;
                }
                else
                {
                    if (AppInit.conf.LampaWeb.index == null || !AppInit.conf.LampaWeb.index.Contains("/"))
                        return Content(string.Empty, "application/javascript; charset=utf-8");

                    type = AppInit.conf.LampaWeb.index.Split("/")[0];
                }
            }

            var apr = AppInit.conf.LampaWeb.cssReplace ?? InvkEvent.conf?.Controller?.AppReplace?.appcss?.regex;

            string memKey = $"ApiController:css/app.css:{type}:{host}:{apr?.Count ?? 0}";
            if (!memoryCache.TryGetValue(memKey, out string css))
            {
                css = IO.File.ReadAllText($"wwwroot/{type}/css/app.css");

                #region appReplace
                if (apr != null)
                {
                    foreach (var r in apr)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        val = val.Replace("{localhost}", host).Replace("{host}", Regex.Replace(host, "^https?://", ""));
                        css = Regex.Replace(css, r.Key, val, RegexOptions.IgnoreCase);
                    }
                }

                if (InvkEvent.conf?.Controller?.AppReplace?.appcss?.list != null)
                {
                    foreach (var r in InvkEvent.conf.Controller.AppReplace.appcss.list)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        val = val.Replace("{localhost}", host).Replace("{host}", Regex.Replace(host, "^https?://", ""));
                        css = css.Replace(r.Key, val);
                    }
                }
                #endregion

                memoryCache.Set(memKey, css, DateTime.Now.AddMinutes(AppInit.conf.multiaccess ? 5 : 1));
            }

            if (InvkEvent.conf?.Controller?.AppReplace?.appcss?.eval != null)
                css = InvkEvent.AppReplace("appcss", new EventAppReplace(css, null, type, host, requestInfo, HttpContext.Request, hybridCache));

            return Content(css, "text/css; charset=utf-8");
        }
        #endregion


        #region samsung.wgt
        [HttpGet]
        [AllowAnonymous]
        [Route("samsung.wgt")]
        public ActionResult SamsWgt(string overwritehost)
        {
            string folder = "data/widgets";

            if (!IO.File.Exists($"{folder}/samsung/loader.js"))
                return Content(string.Empty);

            string wgt = $"{folder}/{CrypTo.md5(overwritehost ?? host + "v3")}.wgt";
            if (IO.File.Exists(wgt))
                return File(IO.File.OpenRead(wgt), "application/octet-stream");

            string index = IO.File.ReadAllText($"{folder}/samsung/index.html");
            IO.File.WriteAllText($"{folder}/samsung/publish/index.html", index.Replace("{localhost}", overwritehost ?? host));

            string loader = IO.File.ReadAllText($"{folder}/samsung/loader.js");
            IO.File.WriteAllText($"{folder}/samsung/publish/loader.js", loader.Replace("{localhost}", overwritehost ?? host));

            string app = IO.File.ReadAllText($"{folder}/samsung/app.js");
            IO.File.WriteAllText($"{folder}/samsung/publish/app.js", app.Replace("{localhost}", overwritehost ?? host));

            IO.File.Copy($"{folder}/samsung/icon.png", $"{folder}/samsung/publish/icon.png", overwrite: true);
            IO.File.Copy($"{folder}/samsung/logo_appname_fg.png", $"{folder}/samsung/publish/logo_appname_fg.png", overwrite: true);
            IO.File.Copy($"{folder}/samsung/config.xml", $"{folder}/samsung/publish/config.xml", overwrite: true);

            string gethash(string file)
            {
                using (SHA512 sha = SHA512.Create())
                {
                    return Convert.ToBase64String(sha.ComputeHash(IO.File.ReadAllBytes(file)));
                    //digestValue = hash.Remove(76) + "\n" + hash.Remove(0, 76);
                }
            }

            string indexhashsha512 = gethash($"{folder}/samsung/publish/index.html");
            string loaderhashsha512 = gethash($"{folder}/samsung/publish/loader.js");
            string apphashsha512 = gethash($"{folder}/samsung/publish/app.js");
            string confighashsha512 = gethash($"{folder}/samsung/publish/config.xml");
            string iconhashsha512 = gethash($"{folder}/samsung/publish/icon.png");
            string logohashsha512 = gethash($"{folder}/samsung/publish/logo_appname_fg.png");

            string author_sigxml = IO.File.ReadAllText($"{folder}/samsung/author-signature.xml");
            author_sigxml = author_sigxml.Replace("loaderhashsha512", loaderhashsha512).Replace("apphashsha512", apphashsha512)
                                         .Replace("iconhashsha512", iconhashsha512).Replace("logohashsha512", logohashsha512)
                                         .Replace("confighashsha512", confighashsha512)
                                         .Replace("indexhashsha512", indexhashsha512);
            IO.File.WriteAllText($"{folder}/samsung/publish/author-signature.xml", author_sigxml);

            string authorsignaturehashsha512 = gethash($"{folder}/samsung/publish/author-signature.xml");
            string sigxml1 = IO.File.ReadAllText($"{folder}/samsung/signature1.xml");
            sigxml1 = sigxml1.Replace("loaderhashsha512", loaderhashsha512).Replace("apphashsha512", apphashsha512)
                             .Replace("confighashsha512", confighashsha512).Replace("authorsignaturehashsha512", authorsignaturehashsha512)
                             .Replace("iconhashsha512", iconhashsha512).Replace("logohashsha512", logohashsha512).Replace("indexhashsha512", indexhashsha512);
            IO.File.WriteAllText($"{folder}/samsung/publish/signature1.xml", sigxml1);

            ZipFile.CreateFromDirectory($"{folder}/samsung/publish/", wgt);

            return File(IO.File.OpenRead(wgt), "application/octet-stream");
        }
        #endregion

        #region MSX
        [HttpGet]
        [AllowAnonymous]
        [Route("msx/start.json")]
        public ActionResult MSX()
        {
            return Content(FileCache.ReadAllText("msx.json").Replace("{localhost}", host), "application/json; charset=utf-8");
        }
        #endregion

        #region startpage.js
        [HttpGet]
        [AllowAnonymous]
        [Route("startpage.js")]
        public ActionResult StartPage()
        {
            return Content(FileCache.ReadAllText("plugins/startpage.js").Replace("{localhost}", host), "application/javascript; charset=utf-8");
        }
        #endregion

        #region lampainit.js
        [HttpGet]
        [AllowAnonymous]
        [Route("lampainit.js")]
        public ActionResult LamInit(bool lite)
        {
            string initiale = string.Empty;
            var sb = new StringBuilder(FileCache.ReadAllText($"plugins/{(lite ? "liteinit" : "lampainit")}.js"));

            if (AppInit.modules != null)
            {
                if (lite)
                {
                    if (AppInit.conf.LampaWeb.initPlugins.online && AppInit.modules.FirstOrDefault(i => i.dll == "Online.dll" && i.enable) != null)
                        initiale += "\"{localhost}/lite.js\",";

                    if (AppInit.conf.LampaWeb.initPlugins.sisi && AppInit.modules.FirstOrDefault(i => i.dll == "SISI.dll" && i.enable) != null)
                        initiale += "\"{localhost}/sisi.js?lite=true\",";

                    if (AppInit.conf.LampaWeb.initPlugins.sync)
                        initiale += "\"{localhost}/sync.js?lite=true\",";
                }
                else
                {
                    if (AppInit.conf.LampaWeb.initPlugins.dlna && AppInit.modules.FirstOrDefault(i => i.dll == "DLNA.dll" && i.enable) != null)
                        initiale += "{\"url\": \"{localhost}/dlna.js\",\"status\": 1,\"name\": \"DLNA\",\"author\": \"lampac\"},";

                    if (AppInit.modules.FirstOrDefault(i => i.dll == "Tracks.dll" && i.enable) != null)
                    {
                        if (AppInit.conf.LampaWeb.initPlugins.tracks)
                            initiale += "{\"url\": \"{localhost}/tracks.js\",\"status\": 1,\"name\": \"Tracks.js\",\"author\": \"lampac\"},";

                        if (AppInit.conf.LampaWeb.initPlugins.transcoding && AppInit.conf.transcoding.enable)
                            initiale += "{\"url\": \"{localhost}/transcoding.js\",\"status\": 1,\"name\": \"Transcoding video\",\"author\": \"lampac\"},";
                    }

                    if (AppInit.conf.LampaWeb.initPlugins.tmdbProxy)
                        initiale += "{\"url\": \"{localhost}/tmdbproxy.js\",\"status\": 1,\"name\": \"TMDB Proxy\",\"author\": \"lampac\"},";

                    if (AppInit.conf.LampaWeb.initPlugins.online && AppInit.modules.FirstOrDefault(i => i.dll == "Online.dll" && i.enable) != null)
                        initiale += "{\"url\": \"{localhost}/online.js\",\"status\": 1,\"name\": \"–û–Ω–ª–∞–π–Ω\",\"author\": \"lampac\"},";

                    if (AppInit.conf.LampaWeb.initPlugins.catalog && AppInit.modules.FirstOrDefault(i => i.dll == "Catalog.dll" && i.enable) != null)
                        initiale += "{\"url\": \"{localhost}/catalog.js\",\"status\": 1,\"name\": \"–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –∫–∞—Ç–∞–ª–æ–≥–∞\",\"author\": \"lampac\"},";

                    if (AppInit.conf.LampaWeb.initPlugins.sisi && AppInit.modules.FirstOrDefault(i => i.dll == "SISI.dll" && i.enable) != null)
                    {
                        initiale += "{\"url\": \"{localhost}/sisi.js\",\"status\": 1,\"name\": \"–ö–ª—É–±–Ω–∏—á–∫–∞\",\"author\": \"lampac\"},";
                        initiale += "{\"url\": \"{localhost}/startpage.js\",\"status\": 1,\"name\": \"–°—Ç–∞—Ä—Ç–æ–≤–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞\",\"author\": \"lampac\"},";
                    }

                    if (AppInit.conf.LampaWeb.initPlugins.sync)
                        initiale += "{\"url\": \"{localhost}/sync.js\",\"status\": 1,\"name\": \"–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è\",\"author\": \"lampac\"},";

                    if (AppInit.conf.LampaWeb.initPlugins.timecode)
                        initiale += "{\"url\": \"{localhost}/timecode.js\",\"status\": 1,\"name\": \"–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Ç–∞–π–º-–∫–æ–¥–æ–≤\",\"author\": \"lampac\"},";

                    if (AppInit.conf.LampaWeb.initPlugins.bookmark)
                        initiale += "{\"url\": \"{localhost}/bookmark.js\",\"status\": 1,\"name\": \"–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–∫–ª–∞–¥–æ–∫\",\"author\": \"lampac\"},";

                    if (AppInit.conf.LampaWeb.initPlugins.torrserver && AppInit.modules.FirstOrDefault(i => i.dll == "TorrServer.dll" && i.enable) != null)
                        initiale += "{\"url\": \"{localhost}/ts.js\",\"status\": 1,\"name\": \"TorrServer\",\"author\": \"lampac\"},";

                    if (AppInit.conf.LampaWeb.initPlugins.backup)
                        initiale += "{\"url\": \"{localhost}/backup.js\",\"status\": 1,\"name\": \"Backup\",\"author\": \"lampac\"},";

                    if (AppInit.conf.pirate_store)
                        sb = sb.Replace("{pirate_store}", FileCache.ReadAllText("plugins/pirate_store.js"));

                    if (AppInit.conf.accsdb.enable)
                        sb = sb.Replace("{deny}", FileCache.ReadAllText("plugins/deny.js").Replace("{cubMesage}", AppInit.conf.accsdb.authMesage));
                }
            }

            sb = sb.Replace("{lampainit-invc}", FileCache.ReadAllText("plugins/lampainit-invc.js"));
            sb = sb.Replace("{initiale}", Regex.Replace(initiale, ",$", ""));

            sb = sb.Replace("{country}", requestInfo.Country);
            sb = sb.Replace("{localhost}", host);
            sb = sb.Replace("{deny}", string.Empty);
            sb = sb.Replace("{pirate_store}", string.Empty);

            sb = sb.Replace("{ major: 0, minor: 0 }", $"{{major: {appversion}, minor: {minorversion}}}");

            if (AppInit.modules != null && AppInit.modules.FirstOrDefault(i => i.dll == "JacRed.dll" && i.enable) != null)
                sb = sb.Replace("{jachost}", Regex.Replace(host, "^https?://", ""));
            else
                sb = sb.Replace("{jachost}", "redapi.apn.monster");

            #region full_btn_priority_hash
            string online_version = Regex.Match(FileCache.ReadAllText("plugins/online.js"), "version: '([^']+)'").Groups[1].Value;

            string LampaUtilshash(string input)
            {
                if (!AppInit.conf.online.version)
                    input = input.Replace($"v{online_version}", "");

                string str = (input ?? string.Empty);
                int hash = 0;

                if (str.Length == 0) return hash.ToString();

                for (int i = 0; i < str.Length; i++)
                {
                    int _char = str[i];

                    hash = (hash << 5) - hash + _char;
                    hash = hash & hash; // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ 32-–±–∏—Ç–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ
                }

                return Math.Abs(hash).ToString();
            }

            string full_btn_priority_hash = LampaUtilshash($"<div class=\"full-start__button selector view--online lampac--button\" data-subtitle=\"{AppInit.conf.online.name} v{online_version}\">\n        <svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 392.697 392.697\" xml:space=\"preserve\">\n            <path d=\"M21.837,83.419l36.496,16.678L227.72,19.886c1.229-0.592,2.002-1.846,1.98-3.209c-0.021-1.365-0.834-2.592-2.082-3.145\n                L197.766,0.3c-0.903-0.4-1.933-0.4-2.837,0L21.873,77.036c-1.259,0.559-2.073,1.803-2.081,3.18\n                C19.784,81.593,20.584,82.847,21.837,83.419z\" fill=\"currentColor\"></path>\n            <path d=\"M185.689,177.261l-64.988-30.01v91.617c0,0.856-0.44,1.655-1.167,2.114c-0.406,0.257-0.869,0.386-1.333,0.386\n                c-0.368,0-0.736-0.082-1.079-0.244l-68.874-32.625c-0.869-0.416-1.421-1.293-1.421-2.256v-92.229L6.804,95.5\n                c-1.083-0.496-2.344-0.406-3.347,0.238c-1.002,0.645-1.608,1.754-1.608,2.944v208.744c0,1.371,0.799,2.615,2.045,3.185\n                l178.886,81.768c0.464,0.211,0.96,0.315,1.455,0.315c0.661,0,1.318-0.188,1.892-0.555c1.002-0.645,1.608-1.754,1.608-2.945\n                V180.445C187.735,179.076,186.936,177.831,185.689,177.261z\" fill=\"currentColor\"></path>\n            <path d=\"M389.24,95.74c-1.002-0.644-2.264-0.732-3.347-0.238l-178.876,81.76c-1.246,0.57-2.045,1.814-2.045,3.185v208.751\n                c0,1.191,0.606,2.302,1.608,2.945c0.572,0.367,1.23,0.555,1.892,0.555c0.495,0,0.991-0.104,1.455-0.315l178.876-81.768\n                c1.246-0.568,2.045-1.813,2.045-3.185V98.685C390.849,97.494,390.242,96.384,389.24,95.74z\" fill=\"currentColor\"></path>\n            <path d=\"M372.915,80.216c-0.009-1.377-0.823-2.621-2.082-3.18l-60.182-26.681c-0.938-0.418-2.013-0.399-2.938,0.045\n                l-173.755,82.992l60.933,29.117c0.462,0.211,0.958,0.316,1.455,0.316s0.993-0.105,1.455-0.316l173.066-79.092\n                C372.122,82.847,372.923,81.593,372.915,80.216z\" fill=\"currentColor\"></path>\n        </svg>\n\n        <span>–û–Ω–ª–∞–π–Ω</span>\n    </div>");

            sb = sb.Replace("{full_btn_priority_hash}", full_btn_priority_hash)
                   .Replace("{btn_priority_forced}", AppInit.conf.online.btn_priority_forced.ToString().ToLower());
            #endregion

            #region domain token
            if (!string.IsNullOrEmpty(AppInit.conf.accsdb.domainId_pattern))
            {
                string token = Regex.Match(HttpContext.Request.Host.Host, AppInit.conf.accsdb.domainId_pattern).Groups[1].Value;
                sb = sb.Replace("{token}", token);
            }
            else { sb = sb.Replace("{token}", string.Empty); }
            #endregion

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        #region on.js
        [HttpGet]
        [AllowAnonymous]
        [Route("on.js")]
        [Route("on/js/{token}")]
        [Route("on/h/{token}")]
        [Route("on/{token}")]
        public ActionResult LamOnInit(string token, bool adult = true)
        {
            if (adult && HttpContext.Request.Path.Value.StartsWith("/on/h/"))
                adult = false;

            var plugins = new List<string>(10);
            var sb = new StringBuilder(FileCache.ReadAllText("plugins/on.js"));

            if (AppInit.modules != null)
            {
                void send(string name, bool worktoken)
                {
                    if (worktoken && !string.IsNullOrEmpty(token))
                    {
                        plugins.Add($"\"{{localhost}}/{name}/js/{HttpUtility.UrlEncode(token)}\"");
                    }
                    else
                    {
                        plugins.Add($"\"{{localhost}}/{name}.js\"");
                    }
                }

                if (AppInit.conf.LampaWeb.initPlugins.dlna && AppInit.modules.FirstOrDefault(i => i.dll == "DLNA.dll" && i.enable) != null)
                    send("dlna", true);

                if (AppInit.modules.FirstOrDefault(i => i.dll == "Tracks.dll" && i.enable) != null)
                {
                    if (AppInit.conf.LampaWeb.initPlugins.tracks)
                        send("tracks", true);

                    if (AppInit.conf.LampaWeb.initPlugins.transcoding && AppInit.conf.transcoding.enable)
                        send("transcoding", true);
                }

                if (AppInit.conf.LampaWeb.initPlugins.tmdbProxy)
                    send("tmdbproxy", true);

                if (AppInit.conf.LampaWeb.initPlugins.online && AppInit.modules.FirstOrDefault(i => i.dll == "Online.dll" && i.enable) != null)
                    send("online", true);

                if (adult)
                {
                    if (AppInit.conf.LampaWeb.initPlugins.sisi && AppInit.modules.FirstOrDefault(i => i.dll == "SISI.dll" && i.enable) != null)
                    {
                        send("sisi", true);
                        send("startpage", false);
                    }
                }

                if (AppInit.conf.LampaWeb.initPlugins.sync)
                    send("sync", true);

                if (AppInit.conf.LampaWeb.initPlugins.timecode)
                    send("timecode", true);

                if (AppInit.conf.LampaWeb.initPlugins.bookmark)
                    send("bookmark", true);

                if (AppInit.conf.LampaWeb.initPlugins.torrserver && AppInit.modules.FirstOrDefault(i => i.dll == "TorrServer.dll" && i.enable) != null)
                    send("ts", true);

                if (AppInit.conf.LampaWeb.initPlugins.backup)
                    send("backup", true);
            }

            if (plugins.Count == 0)
                sb = sb.Replace("{plugins}", string.Empty);
            else
            {
                sb = sb.Replace("{plugins}", string.Join(",", plugins));
            }

            sb = sb.Replace("{country}", requestInfo.Country)
                   .Replace("{localhost}", host);

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        #region privateinit.js
        [HttpGet]
        [Route("privateinit.js")]
        public ActionResult PrivateInit()
        {
            var user = requestInfo.user;
            if (user == null || user.ban || DateTime.UtcNow > user.expires)
                return Content(string.Empty, "application/javascript; charset=utf-8");

            var sb = new StringBuilder(FileCache.ReadAllText("plugins/privateinit.js"));

            sb = sb.Replace("{country}", requestInfo.Country)
                   .Replace("{localhost}", host);

            if (AppInit.modules != null && AppInit.modules.FirstOrDefault(i => i.dll == "JacRed.dll" && i.enable) != null)
                sb = sb.Replace("{jachost}", Regex.Replace(host, "^https?://", ""));
            else
                sb = sb.Replace("{jachost}", "redapi.apn.monster");

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion


        #region backup.js
        [HttpGet]
        [AllowAnonymous]
        [Route("backup.js")]
        [Route("backup/js/{token}")]
        public ActionResult Backup(string token)
        {
            if (!AppInit.conf.storage.enable)
                return Content(string.Empty, "application/javascript; charset=utf-8");

            var sb = new StringBuilder(FileCache.ReadAllText("plugins/backup.js"));

            sb.Replace("{localhost}", host)
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        #region sync.js
        [HttpGet]
        [AllowAnonymous]
        [Route("sync.js")]
        [Route("sync/js/{token}")]
        public ActionResult SyncJS(string token, bool lite)
        {
            if (!AppInit.conf.storage.enable)
                return Content(string.Empty, "application/javascript; charset=utf-8");

            StringBuilder sb;

            if (lite || AppInit.conf.sync_user.version == 1)
            {
                sb = new StringBuilder(FileCache.ReadAllText($"plugins/{(lite ? "sync_lite" : "sync")}.js"));
            }
            else
            {
                sb = new StringBuilder(FileCache.ReadAllText("plugins/sync_v2/sync.js"));
            }

            sb.Replace("{sync-invc}", FileCache.ReadAllText("plugins/sync-invc.js"))
              .Replace("{localhost}", host)
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        #region invc-ws.js
        [HttpGet]
        [AllowAnonymous]
        [Route("invc-ws.js")]
        [Route("invc-ws/js/{token}")]
        public ActionResult InvcSyncJS(string token)
        {
            StringBuilder sb;

            if (AppInit.conf.sync_user.version == 1)
            {
                sb = new StringBuilder(FileCache.ReadAllText("plugins/invc-ws.js"));
            }    
            else
            {
                sb = new StringBuilder(FileCache.ReadAllText("plugins/sync_v2/invc-ws.js"));
            }

            sb.Replace("{invc-rch}", FileCache.ReadAllText("plugins/invc-rch.js"))
              .Replace("{invc-rch_nws}", FileCache.ReadAllText("plugins/invc-rch_nws.js"))
              .Replace("{localhost}", host)
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        #region invc-rch.js
        [HttpGet]
        [AllowAnonymous]
        [Route("invc-rch.js")]
        public ActionResult InvcRchJS()
        {
            string source = FileCache.ReadAllText("plugins/invc-rch.js").Replace("{localhost}", host);

            source = $"(function(){{'use strict'; {source} }})();";

            return Content(source, "application/javascript; charset=utf-8");
        }
        #endregion


        #region PlayerInner
        [HttpGet]
        [Route("player-inner/{*uri}")]
        public void PlayerInner(string uri)
        {
            if (string.IsNullOrEmpty(AppInit.conf.playerInner))
                return;

            // —É–±–∏—Ä–∞–µ–º –º—É—Å–æ—Ä –≤ —Å—Å—ã–ª–∫–µ
            uri = Regex.Replace(uri, "[^a-z0-9_:\\-\\/\\.\\=\\?\\&\\%\\@]+", "", RegexOptions.IgnoreCase);
            uri = uri + HttpContext.Request.QueryString.Value;

            if (!Uri.TryCreate(uri, UriKind.Absolute, out var stream) || 
                (stream.Scheme != Uri.UriSchemeHttp && stream.Scheme != Uri.UriSchemeHttps))
                return;

            Process.Start(new ProcessStartInfo()
            {
                FileName = AppInit.conf.playerInner,
                Arguments = stream.AbsoluteUri
            });
        }
        #endregion

        #region CMD
        [HttpGet]
        [Route("cmd/{key}/{*comand}")]
        async public Task CMD(string key, string comand)
        {
            if (!AppInit.conf.cmd.TryGetValue(key, out var cmd))
                return;

            if (!string.IsNullOrEmpty(cmd.eval))
            {
                var options = ScriptOptions.Default
                    .AddReferences(typeof(HttpRequest).Assembly).AddImports("Microsoft.AspNetCore.Http")
                    .AddReferences(typeof(Task).Assembly).AddImports("System.Threading.Tasks")
                    .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                    .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Engine").AddImports("Shared.Models")
                    .AddReferences(typeof(IO.File).Assembly).AddImports("System.IO")
                    .AddReferences(typeof(Process).Assembly).AddImports("System.Diagnostics");

                var model = new CmdEvalModel(key, comand, requestInfo, HttpContext.Request, hybridCache, memoryCache);

                await CSharpEval.ExecuteAsync(cmd.eval, model, options);
            }
            else
            {
                Process.Start(new ProcessStartInfo()
                {
                    FileName = cmd.path,
                    Arguments = cmd.arguments.Replace("{value}", comand + HttpContext.Request.QueryString.Value)
                });
            }
        }
        #endregion
    }
}
```

## File: Lampac/Controllers/CorseuController.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Newtonsoft.Json;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Base;
using Shared.PlaywrightCore;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Controllers
{
    public class CorseuController : BaseController
    {
        #region Routes
        [HttpGet]
        [Route("/corseu/{token}/{*url}")]
        public Task<IActionResult> Get(string token, string url)
        {
            return ExecuteAsync(new CorseuRequest
            {
                url = url + HttpContext.Request.QueryString.Value,
                auth_token = token
            });
        }

        [HttpGet]
        [Route("/corseu")]
        public Task<IActionResult> Get(string auth_token, string method, string url, string data, string headers, string browser, int? httpversion, int? timeout, string encoding, bool? defaultHeaders, bool? autoredirect, string proxy, string proxy_name, bool? headersOnly)
        {
            return ExecuteAsync(new CorseuRequest
            {
                url = url,
                method = method,
                data = data,
                browser = browser,
                httpversion = httpversion,
                timeout = timeout,
                encoding = encoding,
                defaultHeaders = defaultHeaders,
                autoredirect = autoredirect,
                proxy = proxy,
                proxy_name = proxy_name,
                headersOnly = headersOnly,
                auth_token = auth_token,
                headers = ParseHeaders(headers)
            });
        }

        [HttpPost]
        [Route("/corseu")]
        async public Task<IActionResult> Post()
        {
            try
            {
                using (var reader = new StreamReader(HttpContext.Request.Body, Encoding.UTF8, leaveOpen: true))
                {
                    string body = await reader.ReadToEndAsync().ConfigureAwait(false);

                    if (string.IsNullOrWhiteSpace(body))
                        return BadRequest("Empty body");

                    var model = JsonConvert.DeserializeObject<CorseuRequest>(body);
                    if (model == null)
                        return BadRequest("Invalid body");

                    return await ExecuteAsync(model);
                }
            }
            catch (JsonException)
            {
                return BadRequest("Invalid JSON");
            }
        }
        #endregion

        #region Execute
        async Task<IActionResult> ExecuteAsync(CorseuRequest model)
        {
            var init = AppInit.conf.—Åorseu;

            if (init?.tokens == null || init.tokens.Length == 0)
                return StatusCode((int)HttpStatusCode.Forbidden);

            if (string.IsNullOrEmpty(model?.auth_token) || !init.tokens.Contains(model.auth_token))
                return StatusCode((int)HttpStatusCode.Forbidden);

            if (string.IsNullOrWhiteSpace(model?.url))
                return BadRequest("url is empty");

            string method = string.IsNullOrWhiteSpace(model.method) ? "GET" : model.method.ToUpperInvariant();
            string browser = string.IsNullOrWhiteSpace(model.browser) ? "http" : model.browser.ToLowerInvariant();

            var headers = model.headers != null
                ? new Dictionary<string, string>(model.headers, StringComparer.OrdinalIgnoreCase)
                : new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            bool useDefaultHeaders = model.defaultHeaders ?? true;
            bool autoRedirect = model.autoredirect ?? true;
            bool headersOnly = model.headersOnly ?? false;
            int timeout = model.timeout.HasValue && model.timeout.Value > 5 ? model.timeout.Value : 15;
            int httpVersion = model.httpversion ?? 1;

            string contentType = null;
            if (headers.TryGetValue("content-type", out string ct))
            {
                contentType = ct;
                headers.Remove("content-type");
            }

            if (headers.ContainsKey("content-length"))
                headers.Remove("content-length");

            if (browser is "chromium" or "playwright")
                return await SendWithChromiumAsync(method, model.url, model.data, headers, contentType, timeout, autoRedirect, headersOnly, model.proxy, model.proxy_name);

            return await SendWithHttpClientAsync(method, model.url, model.data, headers, contentType, timeout, httpVersion, useDefaultHeaders, autoRedirect, headersOnly, model.proxy, model.proxy_name, model.encoding);
        }
        #endregion

        #region HttpClient
        async Task<IActionResult> SendWithHttpClientAsync(
            string method, string url, string data, Dictionary<string, string> headers, 
            string contentType, int timeout, int httpVersion, bool useDefaultHeaders, bool autoRedirect, bool headersOnly, string encodingName, 
            string proxyValue, string proxyName)
        {
            var proxyManager = CreateProxy(url, proxyValue, proxyName);

            try
            {
                var handler = Http.Handler(url, proxyManager.Get());
                handler.AllowAutoRedirect = autoRedirect;

                var client = FrendlyHttp.HttpMessageClient(httpVersion == 2 ? "http2" : "base", handler);

                using (var request = new HttpRequestMessage(new HttpMethod(method), url))
                {
                    request.Version = httpVersion == 2 ? HttpVersion.Version20 : HttpVersion.Version11;

                    if (!string.IsNullOrEmpty(data))
                    {
                        var encoding = string.IsNullOrEmpty(encodingName) 
                            ? Encoding.UTF8 
                            : Encoding.GetEncoding(encodingName);

                        var content = new StringContent(data, encoding);

                        if (!string.IsNullOrEmpty(contentType))
                            content.Headers.ContentType = MediaTypeHeaderValue.Parse(contentType);

                        request.Content = content;
                    }

                    var headersModel = headers.Count > 0 ? HeadersModel.Init(headers) : null;
                    string log = string.Empty;
                    Http.DefaultRequestHeaders(url, request, null, null, headersModel, ref log, useDefaultHeaders);

                    using (var cts = CancellationTokenSource.CreateLinkedTokenSource(HttpContext.RequestAborted))
                    {
                        cts.CancelAfter(TimeSpan.FromSeconds(Math.Max(5, timeout)));

                        using (var response = await client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cts.Token).ConfigureAwait(false))
                        {
                            proxyManager.Success();

                            await CopyResponseAsync(response, headersOnly).ConfigureAwait(false);
                            return new EmptyResult();
                        }
                    }
                }
            }
            catch (OperationCanceledException)
            {
                proxyManager.Refresh();
                return StatusCode((int)HttpStatusCode.RequestTimeout);
            }
            catch (Exception ex)
            {
                proxyManager.Refresh();
                return StatusCode((int)HttpStatusCode.BadGateway, ex.Message);
            }
        }
        #endregion

        #region Chromium
        async Task<IActionResult> SendWithChromiumAsync(
            string method, string url, string data, Dictionary<string, string> headers, 
            string contentType, int timeout, bool autoRedirect, bool headersOnly, 
            string proxyValue, string proxyName)
        {
            var proxyManager = CreateProxy(url, proxyValue, proxyName);
            var proxy = proxyManager.BaseGet();

            try
            {
                if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                    return StatusCode((int)HttpStatusCode.BadGateway, "PlaywrightStatus disabled");

                var contextHeaders = new Dictionary<string, string>(headers, StringComparer.OrdinalIgnoreCase);
                var requestHeaders = new Dictionary<string, string>(headers, StringComparer.OrdinalIgnoreCase);

                if (!string.IsNullOrEmpty(contentType))
                {
                    if (!requestHeaders.ContainsKey("content-type"))
                    {
                        requestHeaders["content-type"] = contentType;
                        contextHeaders["content-type"] = contentType;
                    }
                }

                var contextOptions = new APIRequestNewContextOptions
                {
                    IgnoreHTTPSErrors = true,
                    ExtraHTTPHeaders = contextHeaders,
                    Timeout = timeout * 1000,
                    UserAgent = requestHeaders.TryGetValue("user-agent", out string _useragent) ? _useragent : Http.UserAgent
                };

                var requestOptions = new APIRequestContextOptions
                {
                    Method = method,
                    Headers = requestHeaders,
                    Timeout = timeout * 1000
                };

                if (!string.IsNullOrEmpty(data))
                    requestOptions.DataString = data;

                if (!autoRedirect)
                    requestOptions.MaxRedirects = 0;

                if (proxy.proxy != null)
                {
                    contextOptions.Proxy = new Proxy
                    {
                        Server = proxy.data.ip,
                        Username = proxy.data.username,
                        Password = proxy.data.password
                    };
                }

                await using (var requestContext = await Chromium.playwright.APIRequest.NewContextAsync(contextOptions).ConfigureAwait(false))
                {
                    var response = await requestContext.FetchAsync(url, requestOptions).ConfigureAwait(false);

                    try
                    {
                        HttpContext.Response.StatusCode = response.Status;

                        foreach (var header in response.HeadersArray)
                        {
                            var headerName = header.Name.ToLowerInvariant();

                            if (ShouldSkipHeader(headerName))
                                continue;

                            if (headerName == "content-type")
                                HttpContext.Response.ContentType = header.Value;

                            HttpContext.Response.Headers[header.Name] = header.Value;
                        }

                        if (headersOnly)
                        {
                            proxyManager.Success();
                            await HttpContext.Response.CompleteAsync().ConfigureAwait(false);
                            return new EmptyResult();
                        }

                        var body = await response.BodyAsync().ConfigureAwait(false);
                        if (body?.Length > 0)
                            await HttpContext.Response.Body.WriteAsync(body, 0, body.Length, HttpContext.RequestAborted).ConfigureAwait(false);

                        proxyManager.Success();
                        return new EmptyResult();
                    }
                    finally
                    {
                        await response.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
            catch (OperationCanceledException)
            {
                proxyManager.Refresh();
                return StatusCode((int)HttpStatusCode.RequestTimeout);
            }
            catch (Exception ex)
            {
                proxyManager.Refresh();
                return StatusCode((int)HttpStatusCode.BadGateway, ex.Message);
            }
        }
        #endregion

        #region Helpers
        Dictionary<string, string> ParseHeaders(string headers)
        {
            try
            {
                if (!string.IsNullOrEmpty(headers))
                    return JsonConvert.DeserializeObject<Dictionary<string, string>>(headers);
            }
            catch { }

            return new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        }

        ProxyManager CreateProxy(string url, string proxyValue, string proxyName)
        {
            var model = new BaseSettings()
            {
                plugin = $"corseu:{Regex.Match(url, "https?://([^/]+)")}"
            };

            if (!string.IsNullOrEmpty(proxyValue))
            {
                model.proxy = new ProxySettings();
                model.proxy.list = [proxyValue];
            }
            else if (!string.IsNullOrEmpty(proxyName))
            {
                if (AppInit.conf.globalproxy != null)
                {
                    var settings = AppInit.conf.globalproxy.FirstOrDefault(i => i.name == proxyName);
                    if (settings?.list != null && settings.list.Length > 0)
                        model.proxy = settings;
                }
            }

            if (model.proxy != null)
                model.useproxy = true;

            return new ProxyManager(model);
        }

        async Task CopyResponseAsync(HttpResponseMessage response, bool headersOnly)
        {
            var httpResponse = HttpContext.Response;
            httpResponse.StatusCode = (int)response.StatusCode;

            foreach (var header in response.Headers)
            {
                if (ShouldSkipHeader(header.Key))
                    continue;

                httpResponse.Headers[header.Key] = string.Join(", ", header.Value);
            }

            foreach (var header in response.Content.Headers)
            {
                if (string.Equals(header.Key, "Content-Type", StringComparison.OrdinalIgnoreCase))
                {
                    httpResponse.ContentType = response.Content.Headers.ContentType?.ToString();
                    continue;
                }

                if (ShouldSkipHeader(header.Key))
                    continue;

                httpResponse.Headers[header.Key] = string.Join(", ", header.Value);
            }

            if (headersOnly)
            {
                await httpResponse.CompleteAsync().ConfigureAwait(false);
                return;
            }

            using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                await responseStream.CopyToAsync(httpResponse.Body, HttpContext.RequestAborted).ConfigureAwait(false);
        }

        bool ShouldSkipHeader(string header)
        {
            string key = header.ToLowerInvariant();

            return key switch
            {
                "content-length" => true,
                "transfer-encoding" => true,
                "connection" => true,
                "keep-alive" => true,
                "content-disposition" => true,
                "content-encoding" => true,
                "content-security-policy" => true,
                "vary" => true,
                "alt-svc" => true,
                _ when key.StartsWith("access-control") => true,
                _ when key.StartsWith("x-") => true,
                _ => false
            };
        }
        #endregion
    }
}
```

## File: Lampac/Controllers/TimecodeController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.SQL;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Web;

namespace Lampac.Controllers
{
    public class TimecodeController : BaseController
    {
        #region timecode.js
        [HttpGet]
        [AllowAnonymous]
        [Route("timecode.js")]
        [Route("timecode/js/{token}")]
        public ActionResult timecode(string token)
        {
            string file = FileCache.ReadAllText("plugins/timecode.js").Replace("{localhost}", host);
            file = file.Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(file, contentType: "application/javascript; charset=utf-8");
        }
        #endregion

        [Route("/timecode/all")]
        public ActionResult Get(string card_id)
        {
            if (string.IsNullOrEmpty(card_id))
                return Json(new { });

            string userId = getUserid(requestInfo, HttpContext);

            Dictionary<string, string> timecodes = null;

            using (var sqlDb = new SyncUserContext())
            {
                timecodes = sqlDb.timecodes
                    .AsNoTracking()
                    .Where(i => i.user == userId && i.card == card_id)
                    .ToDictionary(i => i.item, i => i.data);
            }

            if (timecodes == null || timecodes.Count == 0)
                return Json(new { });

            return Json(timecodes);
        }

        [HttpPost]
        [Route("/timecode/add")]
        async public Task<ActionResult> Set([FromQuery] string card_id, [FromForm] string id, [FromForm] string data)
        {
            if (string.IsNullOrEmpty(id) || string.IsNullOrEmpty(data))
                return ContentTo("{\"success\": false}");

            if (string.IsNullOrEmpty(card_id))
                return ContentTo("{\"success\": false}");

            string userId = getUserid(requestInfo, HttpContext);

            bool success = false;

            try
            {
                await SyncUserContext.semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                using (var sqlDb = new SyncUserContext())
                {
                    sqlDb.timecodes
                        .Where(i => i.user == userId && i.card == card_id && i.item == id)
                        .ExecuteDelete();

                    sqlDb.timecodes.Add(new SyncUserTimecodeSqlModel
                    {
                        user = userId,
                        card = card_id,
                        item = id,
                        data = data,
                        updated = DateTime.UtcNow
                    });

                    success = sqlDb.SaveChanges() > 0;
                }
            }
            catch { }
            finally
            {
                SyncUserContext.semaphore.Release();
            }

            return ContentTo($"{{\"success\": {success.ToString().ToLower()}}}");
        }


        static string getUserid(RequestModel requestInfo, HttpContext httpContext)
        {
            string user_id = requestInfo.user_uid;

            if (httpContext.Request.Query.TryGetValue("profile_id", out var profile_id) && !string.IsNullOrEmpty(profile_id) && profile_id != "0")
                return $"{user_id}_{profile_id}";

            return user_id;
        }
    }
}
```

## File: Lampac/Controllers/ChromiumController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Shared;

namespace Lampac.Controllers
{
    public class ChromiumController : BaseController
    {
        [AllowAnonymous]
        [Route("/api/chromium/ping")]
        public string Ping() => "pong";


        [AllowAnonymous]
        [Route("/api/chromium/iframe")]
        public ActionResult RenderIframe(string src)
        {
            return ContentTo($@"<html lang=""ru"">
                <head>
                    <meta charset=""UTF-8"">
                    <meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
                    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"">
                    <title>chromium iframe</title>
                </head>
                <body>
                    <iframe width=""560"" height=""400"" src=""{src}"" frameborder=""0"" allow=""*"" allowfullscreen></iframe>
                </body>
            </html>");
        }
    }
}
```

## File: Lampac/Controllers/RchApi.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Shared;
using Shared.Engine;
using System.IO;
using System.IO.Compression;
using System.Text;
using System.Threading.Tasks;

namespace Lampac.Controllers
{
    public class RchApi : BaseController
    {
        [HttpGet]
        [AllowAnonymous]
        [Route("rch/check/connected")]
        public ActionResult –°heck–°onnected()
        {
            var rch = new RchClient(HttpContext, host, new Shared.Models.Base.BaseSettings() { rhub = true }, requestInfo);
            if (rch.IsNotConnected())
                return ContentTo(rch.connectionMsg);

            var info = rch.InfoConnected() ?? new RchClientInfo();
            return Json(new { info.version, info.apkVersion, info.rchtype });
        }

        [HttpPost]
        [AllowAnonymous]
        [Route("rch/result")]
        public ActionResult WriteResult([FromForm]string id, [FromForm]string value)
        {
            if (string.IsNullOrEmpty(id))
            {
                HttpContext.Response.StatusCode = 401;
                return Content(string.Empty);
            }

            if (!RchClient.rchIds.TryGetValue(id, out var tcs))
            {
                HttpContext.Response.StatusCode = 400;
                return Content(string.Empty);
            }

            tcs.SetResult(value ?? string.Empty);
            return Ok();
        }

        [HttpPost]
        [AllowAnonymous]
        [Route("rch/gzresult")]
        async public Task<ActionResult> WriteZipResult([FromQuery]string id)
        {
            if (string.IsNullOrEmpty(id))
            {
                HttpContext.Response.StatusCode = 401;
                return Content(string.Empty);
            }

            if (!RchClient.rchIds.TryGetValue(id, out var tcs))
            {
                HttpContext.Response.StatusCode = 400;
                return Content(string.Empty);
            }

            try
            {
                using (var gzip = new GZipStream(Request.Body, CompressionMode.Decompress, leaveOpen: true))
                {
                    using (var reader = new StreamReader(gzip, Encoding.UTF8))
                    {
                        var text = await reader.ReadToEndAsync();
                        tcs.SetResult(text ?? string.Empty);
                    }
                }
            }
            catch { }

            return Ok();
        }
    }
}

```

## File: Lampac/Controllers/StorageController.cs
```
Ôªøusing Lampac.Engine;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using IO = System.IO;

namespace Lampac.Controllers
{
    public class StorageController : BaseController
    {
        #region StorageController
        static StorageController()
        {
            Directory.CreateDirectory("database/storage");
            Directory.CreateDirectory("database/storage/temp");
        }
        #endregion

        #region Get
        [Route("/storage/get")]
        public ActionResult Get(string path, string pathfile, bool responseInfo)
        {
            string outFile = getFilePath(path, pathfile, false);
            if (outFile == null || !IO.File.Exists(outFile))
                return Content("{\"success\": false, \"msg\": \"outFile\"}", "application/json; charset=utf-8");

            var file = new FileInfo(outFile);
            var fileInfo = new { file.Name, path = outFile, file.Length, changeTime = new DateTimeOffset(file.LastWriteTimeUtc).ToUnixTimeMilliseconds() };

            if (responseInfo)
                return Json(new { success = true, uid = requestInfo.user_uid, fileInfo });

            string data = AppInit.conf.storage.brotli ? BrotliTo.Decompress(outFile) : IO.File.ReadAllText(outFile);

            return Json(new { success = true, uid = requestInfo.user_uid, fileInfo, data });
        }
        #endregion

        #region Set
        [HttpPost]
        [Route("/storage/set")]
        async public Task<ActionResult> Set([FromQuery]string path, [FromQuery]string pathfile, [FromQuery]string connectionId, [FromQuery]string events)
        {
            if (!AppInit.conf.storage.enable)
                return ContentTo("{\"success\": false, \"msg\": \"disabled\"}");

            if (HttpContext.Request.ContentLength > AppInit.conf.storage.max_size)
                return ContentTo("{\"success\": false, \"msg\": \"max_size\"}");

            string outFile = getFilePath(path, pathfile, true);
            if (outFile == null)
                return ContentTo("{\"success\": false, \"msg\": \"outFile\"}");

            byte[] array = null;
            using (var memoryStream = new MemoryStream()) 
            {
                try
                {
                    await HttpContext.Request.Body.CopyToAsync(memoryStream);
                    array = memoryStream.ToArray();
                }
                catch 
                {
                    HttpContext.Response.StatusCode = 500;
                    return ContentTo("{\"success\": false, \"msg\": \"Request.Body.CopyToAsync\"}");
                }
            }

            var semaphore = new SemaphorManager(outFile, TimeSpan.FromMinutes(1));

            try
            {
                await semaphore.WaitAsync();

                if (AppInit.conf.storage.brotli)
                    BrotliTo.Compress(outFile, array);
                else
                {
                    using (var fileStream = new FileStream(outFile, FileMode.Create, FileAccess.Write, FileShare.None))
                        fileStream.Write(array, 0, array.Length);
                }
            }
            catch
            {
                HttpContext.Response.StatusCode = 500;
                return ContentTo("{\"success\": false, \"msg\": \"fileLock\"}");
            }
            finally
            {
                semaphore.Release();
            }

            #region events
            if (!string.IsNullOrEmpty(events))
            {
                try
                {
                    var json = JsonConvert.DeserializeObject<JObject>(CrypTo.DecodeBase64(events));
                    _ = soks.SendEvents(json.Value<string>("connectionId"), requestInfo.user_uid, json.Value<string>("name"), json.Value<string>("data")).ConfigureAwait(false);
                    _ = nws.SendEvents(json.Value<string>("connectionId"), requestInfo.user_uid, json.Value<string>("name"), json.Value<string>("data")).ConfigureAwait(false);
                }
                catch { }
            }
            else
            {
                string edata = JsonConvert.SerializeObject(new { path, pathfile });
                _ = nws.SendEvents(connectionId, requestInfo.user_uid, "storage", edata).ConfigureAwait(false);
            }
            #endregion

            var inf = new FileInfo(outFile);

            return Json(new 
            { 
                success = true,
                uid = requestInfo.user_uid,
                fileInfo = new { inf.Name, path = outFile, inf.Length, changeTime = new DateTimeOffset(inf.LastWriteTimeUtc).ToUnixTimeMilliseconds() }
            });
        }
        #endregion

        #region TempGet
        [HttpGet]
        [Route("/storage/temp/{key}")]
        public ActionResult TempGet(string key, bool responseInfo)
        {
            string outFile = getFilePath("temp", null, false, user_uid: key);
            if (outFile == null || !IO.File.Exists(outFile))
                return Content("{\"success\": false, \"msg\": \"outFile\"}", "application/json; charset=utf-8");

            var file = new FileInfo(outFile);
            var fileInfo = new { file.Name, path = outFile, file.Length, changeTime = new DateTimeOffset(file.LastWriteTimeUtc).ToUnixTimeMilliseconds() };

            if (responseInfo)
                return Json(new { success = true, uid = requestInfo.user_uid, fileInfo });

            string data = AppInit.conf.storage.brotli ? BrotliTo.Decompress(outFile) : IO.File.ReadAllText(outFile);

            return Json(new { success = true, uid = requestInfo.user_uid, fileInfo, data });
        }
        #endregion

        #region TempSet
        [HttpPost]
        [Route("/storage/temp/{key}")]
        async public Task<ActionResult> TempSet(string key)
        {
            if (!AppInit.conf.storage.enable)
                return ContentTo("{\"success\": false, \"msg\": \"disabled\"}");

            if (HttpContext.Request.ContentLength > AppInit.conf.storage.max_size)
                return ContentTo("{\"success\": false, \"msg\": \"max_size\"}");

            string outFile = getFilePath("temp", null, true, user_uid: key);
            if (outFile == null)
                return ContentTo("{\"success\": false, \"msg\": \"outFile\"}");

            byte[] array = null;
            using (var memoryStream = new MemoryStream())
            {
                try
                {
                    await HttpContext.Request.Body.CopyToAsync(memoryStream);
                    array = memoryStream.ToArray();
                }
                catch 
                {
                    HttpContext.Response.StatusCode = 500;
                    return ContentTo("{\"success\": false, \"msg\": \"Request.Body.CopyToAsync\"}");
                }
            }

            var semaphore = new SemaphorManager(outFile, TimeSpan.FromMinutes(1));

            try
            {
                await semaphore.WaitAsync();

                if (AppInit.conf.storage.brotli)
                    BrotliTo.Compress(outFile, array);
                else
                {
                    using (var fileStream = new FileStream(outFile, FileMode.Create, FileAccess.Write, FileShare.None))
                        fileStream.Write(array, 0, array.Length);
                }
            }
            catch
            {
                HttpContext.Response.StatusCode = 500;
                return ContentTo("{\"success\": false, \"msg\": \"fileLock\"}");
            }
            finally
            {
                semaphore.Release();
            }

            var inf = new FileInfo(outFile);

            return Json(new
            {
                success = true,
                uid = requestInfo.user_uid,
                fileInfo = new { inf.Name, path = outFile, inf.Length, changeTime = new DateTimeOffset(inf.LastWriteTimeUtc).ToUnixTimeMilliseconds() }
            });
        }
        #endregion


        #region getFilePath
        string getFilePath(string path, string pathfile, bool createDirectory, string user_uid = null)
        {
            if (path == "temp" && string.IsNullOrEmpty(user_uid))
                return null;

            string id = user_uid ?? requestInfo.user_uid;
            if (string.IsNullOrEmpty(id))
                return null;

            id += pathfile;
            string md5key = AppInit.conf.storage.md5name ? CrypTo.md5(id) : Regex.Replace(id, "(\\@|_)", "");

            if (path == "temp")
            {
                return $"database/storage/{path}/{md5key}";
            }
            else
            {
                if (createDirectory)
                    Directory.CreateDirectory($"database/storage/{path}/{md5key.Substring(0, 2)}");

                return $"database/storage/{path}/{md5key.Substring(0, 2)}/{md5key.Substring(2)}";
            }
        }
        #endregion
    }
}
```

## File: Lampac/Controllers/BookmarkController.cs
```
using Lampac.Engine;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.SQL;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Web;

namespace Lampac.Controllers
{
    public class BookmarkController : BaseController
    {
        #region bookmark.js
        [HttpGet]
        [Route("bookmark.js")]
        [Route("bookmark/js/{token}")]
        public ActionResult BookmarkJS(string token)
        {
            if (!AppInit.conf.storage.enable)
                return Content(string.Empty, "application/javascript; charset=utf-8");

            var sb = new StringBuilder(FileCache.ReadAllText("plugins/bookmark.js"));

            sb.Replace("{localhost}", host)
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        static readonly string[] BookmarkCategories = {
            "history",
            "like",
            "watch",
            "wath",
            "book",
            "look",
            "viewed",
            "scheduled",
            "continued",
            "thrown"
        };


        #region List
        [HttpGet]
        [Route("/bookmark/list")]
        public async Task<ActionResult> List(string filed)
        {
            if (!AppInit.conf.sync_user.enable)
                return ContentTo("{}");

            string userUid = getUserid(requestInfo, HttpContext);

            #region migration storage to sql
            if (AppInit.conf.sync_user.version != 1 && !string.IsNullOrEmpty(requestInfo.user_uid))
            {
                string profile_id = getProfileid(requestInfo, HttpContext);
                string id = requestInfo.user_uid + profile_id;

                string md5key = AppInit.conf.storage.md5name ? CrypTo.md5(id) : Regex.Replace(id, "(\\@|_)", "");
                string storageFile = $"database/storage/sync_favorite/{md5key.Substring(0, 2)}/{md5key.Substring(2)}";

                if (System.IO.File.Exists(storageFile) && !System.IO.File.Exists($"{storageFile}.migration"))
                {
                    try
                    {
                        await SyncUserContext.semaphore.WaitAsync(TimeSpan.FromSeconds(40));

                        if (System.IO.File.Exists(storageFile) && !System.IO.File.Exists($"{storageFile}.migration"))
                        {
                            var content = System.IO.File.ReadAllText(storageFile);
                            if (!string.IsNullOrWhiteSpace(content))
                            {
                                var root = JsonConvert.DeserializeObject<JObject>(content);

                                var favorite = (JObject)root["favorite"];

                                using (var sqlDb = new SyncUserContext())
                                {
                                    var (entity, loaded) = LoadBookmarks(sqlDb, userUid, createIfMissing: true);
                                    bool changed = false;

                                    EnsureDefaultArrays(loaded);

                                    #region migrate card objects
                                    if (favorite["card"] is JArray srcCards)
                                    {
                                        foreach (var c in srcCards.Children<JObject>())
                                        {
                                            changed |= EnsureCard(loaded, c, c?["id"]?.ToString(), insert: false);
                                        }
                                    }
                                    #endregion

                                    #region migrate categories
                                    foreach (var prop in favorite.Properties())
                                    {
                                        var name = prop.Name.Trim().ToLowerInvariant();

                                        if (string.Equals(name, "card", StringComparison.OrdinalIgnoreCase))
                                            continue;

                                        var srcValue = prop.Value;

                                        if (BookmarkCategories.Contains(name))
                                        {
                                            if (srcValue is JArray srcArray)
                                            {
                                                var dest = GetCategoryArray(loaded, name);
                                                foreach (var t in srcArray)
                                                {
                                                    var idStr = t?.ToString();
                                                    if (string.IsNullOrWhiteSpace(idStr))
                                                        continue;

                                                    if (dest.Any(dt => dt.ToString() == idStr) == false)
                                                    {
                                                        if (long.TryParse(idStr, out long _id) && _id > 0)
                                                            dest.Add(_id);
                                                        else
                                                            dest.Add(idStr);

                                                        changed = true;
                                                    }
                                                }
                                            }
                                        }
                                        else
                                        {
                                            var existing = loaded[name];
                                            if (existing == null || !JToken.DeepEquals(existing, srcValue))
                                            {
                                                loaded[name] = srcValue;
                                                changed = true;
                                            }
                                        }
                                    }
                                    #endregion

                                    if (changed)
                                        Save(sqlDb, entity, loaded);
                                }

                                System.IO.File.Create($"{storageFile}.migration");
                            }
                        }
                    }
                    catch { }
                    finally
                    {
                        SyncUserContext.semaphore.Release();
                    }
                }
            }
            #endregion

            using (var sqlDb = new SyncUserContext())
            {
                bool IsDbInitialization = sqlDb.bookmarks.AsNoTracking().FirstOrDefault(i => i.user == userUid) != null;
                if (!IsDbInitialization)
                    return Json(new { dbInNotInitialization = true });

                var data = GetBookmarksForResponse(sqlDb);
                if (!string.IsNullOrEmpty(filed))
                    return ContentTo(data[filed].ToString(Formatting.None));

                return ContentTo(data.ToString(Formatting.None));
            }
        }
        #endregion

        #region Set
        [HttpPost]
        [Route("/bookmark/set")]
        public async Task<ActionResult> Set(string connectionId)
        {
            if (string.IsNullOrEmpty(requestInfo.user_uid) || !AppInit.conf.sync_user.enable)
                return JsonFailure();

            using (var reader = new StreamReader(Request.Body, Encoding.UTF8, detectEncodingFromByteOrderMarks: false, leaveOpen: true))
            {
                string body = await reader.ReadToEndAsync();
                if (string.IsNullOrWhiteSpace(body))
                    return JsonFailure();

                var token = JsonConvert.DeserializeObject<JToken>(body);
                if (token == null)
                    return JsonFailure();

                var jobs = new List<JObject>();
                if (token.Type == JTokenType.Array)
                {
                    foreach (var obj in token.Children<JObject>())
                        jobs.Add(obj);
                }
                else if (token is JObject singleJob)
                {
                    jobs.Add(singleJob);
                }

                bool IsDbInitialization = false;

                try
                {
                    await SyncUserContext.semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                    using (var sqlDb = new SyncUserContext())
                    {
                        string userUid = getUserid(requestInfo, HttpContext);

                        IsDbInitialization = sqlDb.bookmarks.AsNoTracking().FirstOrDefault(i => i.user == userUid) != null;

                        var (entity, data) = LoadBookmarks(sqlDb, userUid, createIfMissing: true);

                        foreach (var job in jobs)
                        {
                            string where = job.Value<string>("where")?.Trim()?.ToLowerInvariant();
                            if (string.IsNullOrWhiteSpace(where))
                                return JsonFailure();

                            if (IsDbInitialization && AppInit.conf.sync_user.fullset == false)
                            {
                                if (where == "card" || BookmarkCategories.Contains(where))
                                    return JsonFailure("enable sync_user.fullset in init.conf");
                            }

                            if (!job.TryGetValue("data", out var dataValue))
                                return JsonFailure();

                            data[where] = dataValue;
                        }

                        EnsureDefaultArrays(data);

                        Save(sqlDb, entity, data);
                    }
                }
                catch 
                {
                    return JsonFailure();
                }
                finally
                {
                    SyncUserContext.semaphore.Release();
                }

                if (IsDbInitialization)
                {
                    _ = nws.SendEvents(connectionId, requestInfo.user_uid, "bookmark", JsonConvert.SerializeObject(new
                    {
                        type = "set",
                        data = token,
                        profile_id = getProfileid(requestInfo, HttpContext)
                    })).ConfigureAwait(false);
                }

                return JsonSuccess();
            }
        }

        #endregion

        #region Add/Added
        [HttpPost]
        [Route("/bookmark/add")]
        [Route("/bookmark/added")]
        public async Task<ActionResult> Add(string connectionId)
        {
            if (string.IsNullOrEmpty(requestInfo.user_uid) || !AppInit.conf.sync_user.enable)
                return JsonFailure();

            var readBody = await ReadPayloadAsync();

            if (readBody.payloads.Count == 0)
                return JsonFailure();

            bool isAddedRequest = HttpContext?.Request?.Path.Value?.StartsWith("/bookmark/added", StringComparison.OrdinalIgnoreCase) == true;

            try
            {
                await SyncUserContext.semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                using (var sqlDb = new SyncUserContext())
                {
                    var (entity, data) = LoadBookmarks(sqlDb, getUserid(requestInfo, HttpContext), createIfMissing: true);
                    bool changed = false;

                    foreach (var payload in readBody.payloads)
                    {
                        var cardId = payload.ResolveCardId();
                        if (cardId == null)
                            continue;

                        changed |= EnsureCard(data, payload.Card, cardId);

                        if (payload.Where != null)
                            changed |= AddToCategory(data, payload.Where, cardId);

                        if (isAddedRequest)
                            changed |= MoveIdToFrontInAllCategories(data, cardId);
                    }

                    if (changed)
                    {
                        Save(sqlDb, entity, data);

                        if (readBody.token != null)
                        {
                            string edata = JsonConvert.SerializeObject(new
                            {
                                type = isAddedRequest ? "added" : "add",
                                profile_id = getProfileid(requestInfo, HttpContext),
                                data = readBody.token
                            });

                            _ = nws.SendEvents(connectionId, requestInfo.user_uid, "bookmark", edata).ConfigureAwait(false);
                        }
                    }
                }

                return JsonSuccess();
            }
            catch 
            {
                return JsonFailure();
            }
            finally
            {
                SyncUserContext.semaphore.Release();
            }
        }
        #endregion

        #region Remove
        [HttpPost]
        [Route("/bookmark/remove")]
        public async Task<ActionResult> Remove(string connectionId)
        {
            if (string.IsNullOrEmpty(requestInfo.user_uid) || !AppInit.conf.sync_user.enable)
                return JsonFailure();

            var readBody = await ReadPayloadAsync();

            if (readBody.payloads.Count == 0)
                return JsonFailure();

            try
            {
                await SyncUserContext.semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                using (var sqlDb = new SyncUserContext())
                {
                    var (entity, data) = LoadBookmarks(sqlDb, getUserid(requestInfo, HttpContext), createIfMissing: false);
                    if (entity == null)
                        return JsonSuccess();

                    bool changed = false;

                    foreach (var payload in readBody.payloads)
                    {
                        var cardId = payload.ResolveCardId();
                        if (cardId == null)
                            continue;

                        if (payload.Where != null)
                            changed |= RemoveFromCategory(data, payload.Where, cardId);

                        if (payload.Method == "card")
                        {
                            changed |= RemoveIdFromAllCategories(data, cardId);
                            changed |= RemoveCard(data, cardId);
                        }
                    }

                    if (changed)
                    {
                        Save(sqlDb, entity, data);

                        if (readBody.token != null)
                        {
                            string edata = JsonConvert.SerializeObject(new
                            {
                                type = "remove",
                                profile_id = getProfileid(requestInfo, HttpContext),
                                data = readBody.token
                            });

                            _ = nws.SendEvents(connectionId, requestInfo.user_uid, "bookmark", edata).ConfigureAwait(false);
                        }
                    }
                }

                return JsonSuccess();
            }
            catch 
            {
                return JsonFailure();
            }
            finally
            {
                SyncUserContext.semaphore.Release();
            }
        }
        #endregion


        #region static
        static string getUserid(RequestModel requestInfo, HttpContext httpContext)
        {
            string user_id = requestInfo.user_uid;
            string profile_id = getProfileid(requestInfo, httpContext);

            if (!string.IsNullOrEmpty(profile_id))
                return $"{user_id}_{profile_id}";

            return user_id;
        }

        static string getProfileid(RequestModel requestInfo, HttpContext httpContext)
        {
            if (httpContext.Request.Query.TryGetValue("profile_id", out var profile_id) && !string.IsNullOrEmpty(profile_id) && profile_id != "0")
                return profile_id;

            return string.Empty;
        }

        JObject GetBookmarksForResponse(SyncUserContext sqlDb)
        {
            if (string.IsNullOrEmpty(requestInfo.user_uid))
                return CreateDefaultBookmarks();

            string user_id = getUserid(requestInfo, HttpContext);
            var entity = sqlDb.bookmarks.AsNoTracking().FirstOrDefault(i => i.user == user_id);
            var data = entity != null ? DeserializeBookmarks(entity.data) : CreateDefaultBookmarks();
            EnsureDefaultArrays(data);
            return data;
        }

        static (SyncUserBookmarkSqlModel entity, JObject data) LoadBookmarks(SyncUserContext sqlDb, string userUid, bool createIfMissing)
        {
            JObject data = CreateDefaultBookmarks();
            SyncUserBookmarkSqlModel entity = null;

            if (!string.IsNullOrEmpty(userUid))
            {
                entity = sqlDb.bookmarks.FirstOrDefault(i => i.user == userUid);
                if (entity != null && !string.IsNullOrEmpty(entity.data))
                    data = DeserializeBookmarks(entity.data);
            }

            EnsureDefaultArrays(data);

            if (entity == null && createIfMissing && !string.IsNullOrEmpty(userUid))
                entity = new SyncUserBookmarkSqlModel { user = userUid };

            return (entity, data);
        }

        static JObject DeserializeBookmarks(string json)
        {
            if (string.IsNullOrWhiteSpace(json))
                return CreateDefaultBookmarks();

            try
            {
                var job = JsonConvert.DeserializeObject<JObject>(json) ?? new JObject();
                EnsureDefaultArrays(job);
                return job;
            }
            catch
            {
                return CreateDefaultBookmarks();
            }
        }

        static JObject CreateDefaultBookmarks()
        {
            var obj = new JObject
            {
                ["card"] = new JArray()
            };

            foreach (var category in BookmarkCategories)
                obj[category] = new JArray();

            return obj;
        }

        static void EnsureDefaultArrays(JObject root)
        {
            if (root == null)
                return;

            if (root["card"] is not JArray)
                root["card"] = new JArray();

            foreach (var category in BookmarkCategories)
            {
                if (root[category] is not JArray)
                    root[category] = new JArray();
            }
        }

        static bool EnsureCard(JObject data, JObject card, string idStr, bool insert = true)
        {
            if (data == null || card == null || string.IsNullOrWhiteSpace(idStr))
                return false;

            var cardArray = GetCardArray(data);
            var newCard = (JObject)card.DeepClone();

            foreach (var existing in cardArray.Children<JObject>().ToList())
            {
                var token = existing["id"];
                if (token != null && token.ToString() == idStr)
                {
                    if (!JToken.DeepEquals(existing, newCard))
                    {
                        existing.Replace(newCard);
                        return true;
                    }

                    return false;
                }
            }

            if (insert)
                cardArray.Insert(0, newCard);
            else
                cardArray.Add(newCard);

            return true;
        }

        static bool AddToCategory(JObject data, string category, string idStr)
        {
            var array = GetCategoryArray(data, category);

            foreach (var token in array)
            {
                if (token.ToString() == idStr)
                    return false;
            }

            if (long.TryParse(idStr, out long _id) && _id > 0)
                array.Insert(0, _id);
            else
                array.Insert(0, idStr);

            return true;
        }

        static bool MoveIdToFrontInAllCategories(JObject data, string idStr)
        {
            bool changed = false;

            foreach (var prop in data.Properties())
            {
                if (string.Equals(prop.Name, "card", StringComparison.OrdinalIgnoreCase))
                    continue;

                if (prop.Value is JArray array)
                    changed |= MoveIdToFront(array, idStr);
            }

            return changed;
        }

        static bool MoveIdToFront(JArray array, string idStr)
        {
            if (array == null)
                return false;

            for (int i = 0; i < array.Count; i++)
            {
                var token = array[i];
                if (token?.ToString() == idStr)
                {
                    if (i == 0)
                        return false;

                    token.Remove();
                    array.Insert(0, token);
                    return true;
                }
            }

            return false;
        }

        static bool RemoveFromCategory(JObject data, string category, string idStr)
        {
            if (data[category] is not JArray array)
                return false;

            return RemoveFromArray(array, idStr);
        }

        static bool RemoveIdFromAllCategories(JObject data, string idStr)
        {
            bool changed = false;

            foreach (var property in data.Properties().ToList())
            {
                if (property.Name == "card")
                    continue;

                if (property.Value is JArray array && RemoveFromArray(array, idStr))
                    changed = true;
            }

            return changed;
        }

        static bool RemoveCard(JObject data, string idStr)
        {
            if (data["card"] is JArray cardArray)
            {
                foreach (var card in cardArray.Children<JObject>().ToList())
                {
                    var token = card["id"];
                    if (token != null && token.ToString() == idStr)
                    {
                        card.Remove();
                        return true;
                    }
                }
            }

            return false;
        }

        static JArray GetCardArray(JObject data)
        {
            if (data["card"] is JArray array)
                return array;

            array = new JArray();
            data["card"] = array;
            return array;
        }

        static JArray GetCategoryArray(JObject data, string category)
        {
            if (data[category] is JArray array)
                return array;

            array = new JArray();
            data[category] = array;
            return array;
        }

        static bool RemoveFromArray(JArray array, string idStr)
        {
            foreach (var token in array.ToList())
            {
                if (token.ToString() == idStr)
                {
                    token.Remove();
                    return true;
                }
            }

            return false;
        }

        static void Save(SyncUserContext sqlDb, SyncUserBookmarkSqlModel entity, JObject data)
        {
            if (entity == null)
                return;

            entity.data = data.ToString(Formatting.None);
            entity.updated = DateTime.UtcNow;

            if (entity.Id == 0)
                sqlDb.bookmarks.Add(entity);
            else
                sqlDb.bookmarks.Update(entity);

            sqlDb.SaveChanges();
        }

        JsonResult JsonSuccess() => Json(new { success = true });

        ActionResult JsonFailure(string message = null) => ContentTo(JsonConvert.SerializeObject(new { success = false, message }));

        async Task<(IReadOnlyList<BookmarkEventPayload> payloads, JToken token)> ReadPayloadAsync()
        {
            JToken token = null;
            var payloads = new List<BookmarkEventPayload>();

            using (var reader = new StreamReader(Request.Body, Encoding.UTF8, detectEncodingFromByteOrderMarks: false, bufferSize: 1024, leaveOpen: true))
            {
                try
                {
                    string json = await reader.ReadToEndAsync();

                    if (string.IsNullOrWhiteSpace(json))
                        return (payloads, token);

                    token = JsonConvert.DeserializeObject<JToken>(json);
                    if (token == null)
                        return (payloads, token);

                    if (token.Type == JTokenType.Array)
                    {
                        foreach (var obj in token.Children<JObject>())
                            payloads.Add(ParsePayload(obj));
                    }
                    else if (token is JObject job)
                    {
                        payloads.Add(ParsePayload(job));
                    }
                }
                catch { }
            }

            return (payloads, token);
        }

        static BookmarkEventPayload ParsePayload(JObject job)
        {
            var payload = new BookmarkEventPayload
            {
                Method = job.Value<string>("method"),
                CardIdRaw = job.Value<string>("id") ?? job.Value<string>("card_id")
            };

            payload.Where = (job.Value<string>("where") ?? job.Value<string>("list"))?.Trim()?.ToLowerInvariant();
            if (string.IsNullOrEmpty(payload.Where) || payload.Where == "card")
                payload.Where = null;

            if (job.TryGetValue("card", out var cardToken) && cardToken is JObject cardObj)
                payload.Card = cardObj;

            return payload;
        }
        #endregion

        #region BookmarkEventPayload
        sealed class BookmarkEventPayload
        {
            public string Method { get; set; }

            public string Where { get; set; }

            public JObject Card { get; set; }

            public string CardIdRaw { get; set; }

            public string ResolveCardId()
            {
                if (!string.IsNullOrWhiteSpace(CardIdRaw))
                    return CardIdRaw.Trim().ToLowerInvariant();

                var token = Card?["id"];
                if (token != null)
                {
                    if (token.Type == JTokenType.Integer)
                        return token.Value<long>().ToString();

                    string _id = token.ToString();
                    if (string.IsNullOrWhiteSpace(_id))
                        return null;

                    return _id.Trim().ToLowerInvariant();
                }

                return null;
            }
        }
        #endregion
    }
}

```

## File: Lampac/Controllers/MediaController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Base;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;

namespace Lampac.Controllers
{
    public class MediaController : BaseController
    {
        #region Routes
        [HttpGet]
        [Route("/media/rsize/{token}/{width}/{height}/{*url}")]
        public ActionResult Get(string token, int width, int height, string url)
        {
            return GetLocation(url + HttpContext.Request.QueryString.Value, new MediaRequestBase
            {
                type = "img",
                auth_token = token,
                width = width,
                height = height
            }, null, null);
        }

        [HttpGet]
        [Route("/media/{type}/{token}/{*url}")]
        public ActionResult Get(string type, string token, string url)
        {
            return GetLocation(url + HttpContext.Request.QueryString.Value, new MediaRequestBase
            {
                auth_token = token,
                type = type
            }, null, null);
        }

        [HttpGet]
        [Route("/media")]
        public ActionResult Get(string url, string headers, [FromQuery] MediaRequestBase request)
        {
            var webProxy = CreateProxy(request?.proxy, request?.proxy_name);
            var headerList = HeadersModel.Init(ParseHeaders(headers));

            return GetLocation(url, request, headerList, webProxy);
        }

        [HttpPost]
        [Route("/media")]
        public ActionResult Post([FromBody] MediaRequest request)
        {
            if (!TryValidateBase(request, out ActionResult errorResult))
                return errorResult;

            if (request.urls == null || request.urls.Count == 0)
                return JsonError("invalid urls", 400);

            var webProxy = CreateProxy(request.proxy, request.proxy_name);
            var headerList = HeadersModel.Init(request.headers);
            var streamSettings = CreateStreamSettings(request);

            var result = new List<string>(request.urls.Count);

            foreach (string source in request.urls)
            {
                string proxied = request.type == "img"
                    ? CreateImageProxy(source, request.width, request.height, headerList, webProxy)
                    : HostStreamProxy(streamSettings, source, headerList, webProxy);

                result.Add(proxied);
            }

            return Json(new
            {
                success = true,
                urls = result
            });
        }
        #endregion

        #region Helpers
        ActionResult GetLocation(string url, MediaRequestBase request, List<HeadersModel> headers, WebProxy proxy)
        {
            if (string.IsNullOrEmpty(url))
                return JsonError("invalid url", 400);

            if (!TryValidateBase(request, out ActionResult errorResult))
                return errorResult;

            string location = request.type == "img"
                ? CreateImageProxy(url, request.width, request.height, headers, proxy)
                : HostStreamProxy(CreateStreamSettings(request), url, headers, proxy);

            return Redirect(location);
        }

        BaseSettings CreateStreamSettings(MediaRequestBase request)
        {
            return new BaseSettings
            {
                plugin = "media",
                streamproxy = true,
                apnstream = request.apnstream,
                useproxystream = request.useproxystream
            };
        }

        bool TryValidateBase(MediaRequestBase request, out ActionResult errorResult)
        {
            errorResult = null;
            var init = AppInit.conf.media;

            if (request == null)
            {
                errorResult = JsonError("invalid request", 400);
                return false;
            }

            if (string.IsNullOrEmpty(request.auth_token) || init?.tokens == null || !init.tokens.Any(t => t == request.auth_token))
            {
                errorResult = JsonError("unauthorized", 401);
                return false;
            }

            return true;
        }

        Dictionary<string, string> ParseHeaders(string headers)
        {
            try
            {
                if (!string.IsNullOrEmpty(headers))
                    return JsonConvert.DeserializeObject<Dictionary<string, string>>(headers);
            }
            catch { }

            return null;
        }

        WebProxy CreateProxy(string proxyValue, string proxyName)
        {
            ProxySettings proxySettings = null;

            if (!string.IsNullOrEmpty(proxyValue))
            {
                proxySettings = new ProxySettings
                {
                    list = [proxyValue]
                };
            }
            else if (!string.IsNullOrEmpty(proxyName) && AppInit.conf.globalproxy != null)
            {
                var settings = AppInit.conf.globalproxy.FirstOrDefault(i => i.name == proxyName);
                if (settings?.list != null && settings.list.Length > 0)
                    proxySettings = settings;
            }

            if (proxySettings == null)
                return null;

            return ProxyManager.ConfigureWebProxy(proxySettings, proxySettings.list.First()).proxy;
        }

        string CreateImageProxy(string url, int? width, int? height, List<HeadersModel> headers, WebProxy proxy)
        {
            if (!AppInit.conf.serverproxy.enable)
                return url;

            string encrypted = ProxyLink.Encrypt(url, requestInfo.IP, headers, proxy, "posterapi", verifyip: false);

            if (AppInit.conf.accsdb.enable && !AppInit.conf.serverproxy.encrypt)
                encrypted = AccsDbInvk.Args(encrypted, HttpContext);

            int normalizedWidth = Math.Max(0, width ?? 0);
            int normalizedHeight = Math.Max(0, height ?? 0);

            if (normalizedWidth > 0 || normalizedHeight > 0)
                return $"{host}/proxyimg:{normalizedWidth}:{normalizedHeight}/{encrypted}";

            return $"{host}/proxyimg/{encrypted}";
        }

        ActionResult JsonError(string message, int statusCode)
        {
            HttpContext.Response.StatusCode = statusCode;
            return ContentTo(JsonConvert.SerializeObject(new
            {
                success = false,
                error = message
            }));
        }
        #endregion
    }
}
```

## File: Lampac/Controllers/AdminController.cs
```
Ôªøusing Shared.Models.Module;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Linq;
using IO = System.IO;
using Shared;
using System.Threading.Tasks;
using Shared.Engine;

namespace Lampac.Controllers
{
    public class AdminController : BaseController
    {
        #region admin / auth
        [Route("admin")]
        [Route("admin/auth")]
        public ActionResult Authorization([FromForm]string parol)
        {
			if (AppInit.rootPasswd == "termux")
			{
                HttpContext.Response.Cookies.Append("passwd", "termux");
                return renderAdmin();
            }

            if (!string.IsNullOrEmpty(parol))
			{
                string ipKey = $"Accsdb:auth:IP:{requestInfo.IP}";
                if (!memoryCache.TryGetValue(ipKey, out HashSet<string> passwds))
                    passwds = new HashSet<string>();

                passwds.Add(parol);
                memoryCache.Set(ipKey, passwds, DateTime.Today.AddDays(1));

                if (passwds.Count > 5)
                    return Content("Too many attempts, try again tomorrow.");

                if (AppInit.rootPasswd == parol.Trim())
				{
					HttpContext.Response.Cookies.Append("passwd", parol.Trim());
					return Redirect("/admin");
				}
            }

			if (HttpContext.Request.Cookies.TryGetValue("passwd", out string passwd) && passwd == AppInit.rootPasswd)
				return renderAdmin();

            string html = @"
<!DOCTYPE html>
<html>
<head>
	<title>Authorization</title>
</head>
<body>

<style type=""text/css"">
	* {
	    box-sizing: border-box;
	    outline: none;
	}
	body{
		padding: 40px;
		font-family: sans-serif;
	}
	label{
		display: block;
		font-weight: 700;
		margin-bottom: 8px;
	}
	input,
	textarea,
	select{
		width: 340px;
		padding: 8px;
	}
	button{
		padding: 10px;
	}
	form > * + *{
		margin-top: 20px;
	}
</style>

<form method=""post"" action=""/admin/auth"" id=""form"">
	<div>
		<input type=""text"" name=""parol"" placeholder=""–ø–∞—Ä–æ–ª—å –∏–∑ —Ñ–∞–π–ª–∞ passwd""></input>
	</div>
	
	<button type=""submit"">–≤–æ–π—Ç–∏</button>
	
</form>

<div style=""margin-top: 4em;""><b style=""color: cadetblue;"">–í—ã–ø–æ–ª–Ω–∏—Ç–µ –æ–¥–Ω—É –∏–∑ –∫–æ–º–∞–Ω–¥ —á–µ—Ä–µ–∑ ssh</b><br><br>
	cat /home/lampac/passwd<br><br>
	docker exec -it lampac cat passwd
</div>

</body>
</html>
";

            return Content(html, contentType: "text/html; charset=utf-8");
        }

        ActionResult renderAdmin()
		{
            string adminHtml = IO.File.Exists("wwwroot/mycontrol/index.html") ? IO.File.ReadAllText("wwwroot/mycontrol/index.html") : IO.File.ReadAllText("wwwroot/control/index.html");
            return Content(adminHtml, contentType: "text/html; charset=utf-8");
		}
        #endregion


        #region init
        [Route("admin/init/save")]
        public ActionResult InitSave([FromForm]string json)
        {
			try
            {
                JsonConvert.DeserializeObject<AppInit>(json);
            }
			catch (Exception ex) { return Json(new { error = true, ex = ex.Message }); }

            var jo = JsonConvert.DeserializeObject<JObject>(json);

			JToken users = null;
            var accsdbNode = jo["accsdb"] as JObject;
            if (accsdbNode != null)
            {
                var usersNode = accsdbNode["users"];
                if (usersNode != null)
				{
					users = usersNode.DeepClone();
                    accsdbNode.Remove("users");

                    IO.File.WriteAllText("users.json", JsonConvert.SerializeObject(users, Formatting.Indented));
                }
            }

            IO.File.WriteAllText("init.conf", JsonConvert.SerializeObject(jo, Formatting.Indented));

            return Json(new { success = true });
        }

        [Route("admin/init/custom")]
        public ActionResult InitCustom()
        {
			string json = IO.File.Exists("init.conf") ? IO.File.ReadAllText("init.conf") : null;
			if (json != null && !json.Trim().StartsWith("{"))
				json = "{" + json + "}";

            var ob = json != null ? JsonConvert.DeserializeObject<JObject>(json) : new JObject { };
            return ContentTo(JsonConvert.SerializeObject(ob));
        }

        [Route("admin/init/current")]
        public ActionResult InitCurrent()
        {
            return Content(JsonConvert.SerializeObject(AppInit.conf), contentType: "application/json; charset=utf-8");
        }

        [Route("admin/init/default")]
        public ActionResult InitDefault()
        {
            return Content(JsonConvert.SerializeObject(new AppInit()), contentType: "application/json; charset=utf-8");
        }

        [Route("admin/init/example")]
        public ActionResult InitExample()
        {
            return Content(IO.File.Exists("example.conf") ? IO.File.ReadAllText("example.conf") : string.Empty);
        }
        #endregion

        #region sync/init
        [Route("admin/sync/init")]
        public ActionResult Synchtml()
        {
            string html = @"
<!DOCTYPE html>
<html>
<head>
	<title>–†–µ–¥–∞–∫—Ç–æ—Ä sync.conf</title>
</head>
<body>

<style type=""text/css"">
	* {
	    box-sizing: border-box;
	    outline: none;
	}
	body{
		padding: 40px;
		font-family: sans-serif;
	}
	label{
		display: block;
		font-weight: 700;
		margin-bottom: 8px;
	}
	input,
	textarea,
	select{
		width: 100%;
		padding: 10px;
	}
	button{
		padding: 10px;
	}
	form > * + *{
		margin-top: 30px;
	}
</style>

<form method=""post"" action="""" id=""form"">
	<div>
		<label>–í–∞—à sync.conf
		<textarea id=""value"" name=""value"" rows=""30"">{conf}</textarea>
	</div>
	
	<button type=""submit"">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
	
</form>

<script type=""text/javascript"">
	document.getElementById('form').addEventListener(""submit"", (e) => {
		let json = document.getElementById('value').value

		e.preventDefault()

		try{
			let formData = new FormData()
				formData.append('json', json)

			fetch('/admin/sync/init/save',{
			    method: ""POST"",
			    body: formData
			})
			.then((response)=>{
				if (!response.ok) {
					return response.json().then(err => {
						throw new Error(err.ex || '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏');
					});
				}
				return response.json();
			 })  
			.then((data)=>{
				if (data.success) {
					alert('–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ');
				} else if (data.error) {
					throw new Error(data.ex); 
				} else {
					throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏'); 
				}
			})
			.catch((e)=>{
				alert(e.message)
			})
		}
		catch(e){
			alert('–û—à–∏–±–∫–∞: ' + e.message)
		}
	})
</script>

</body>
</html>
";

            string conf = IO.File.Exists("sync.conf") ? IO.File.ReadAllText("sync.conf") : string.Empty;
            return Content(html.Replace("{conf}", conf), contentType: "text/html; charset=utf-8");
        }


        [Route("admin/sync/init/save")]
        public ActionResult SyncSave([FromForm] string json)
        {
            try
            {
                string testjson = json.Trim();
                if (!testjson.StartsWith("{"))
                    testjson = "{" + testjson + "}";

                JsonConvert.DeserializeObject<AppInit>(testjson);

            }
            catch (Exception ex) { return Json(new { error = true, ex = ex.Message }); }

            IO.File.WriteAllText("sync.conf", json);
            return Json(new { success = true });
        }
        #endregion

        #region manifest
        [Route("admin/manifest/install")]
        public Task ManifestInstallHtml(string online, string sisi, string jac, string dlna, string tracks, string ts, string catalog, string merch, string eng)
        {
            HttpContext.Response.ContentType = "text/html; charset=utf-8";

            if (AppInit.rootPasswd == "termux")
                return HttpContext.Response.WriteAsync("–í termux –æ–ø–µ—Ä–∞—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞");

            bool isEditManifest = false;

			if (IO.File.Exists("module/manifest.json"))
			{
                if (HttpContext.Request.Cookies.TryGetValue("passwd", out string passwd) && passwd == AppInit.rootPasswd)
                {
                    isEditManifest = true;
                }
                else
                {
                    HttpContext.Response.Redirect("/admin");
                    return Task.CompletedTask;
                }
            }

			if (HttpContext.Request.Method == "POST")
			{
				var modules = new List<string>(10);

				if (online == "on")
					modules.Add("{\"enable\":true,\"dll\":\"Online.dll\"}");

                if (sisi == "on")
                    modules.Add("{\"enable\":true,\"dll\":\"SISI.dll\"}");

                if (!string.IsNullOrEmpty(jac))
                {
                    modules.Add("{\"enable\":true,\"initspace\":\"Jackett.ModInit\",\"dll\":\"JacRed.dll\"}");

                    #region JacRed.conf
                    if (jac == "fdb")
                    {
                        var jacPath = "module/JacRed.conf";

                        JObject jj;
                        if (IO.File.Exists(jacPath))
                        {
                            string txt = IO.File.ReadAllText(jacPath).Trim();
                            if (string.IsNullOrEmpty(txt))
                                jj = new JObject();
                            else
                            {
                                if (!txt.StartsWith("{"))
                                    txt = "{" + txt + "}";

                                try
                                {
                                    jj = JsonConvert.DeserializeObject<JObject>(txt) ?? new JObject();
                                }
                                catch
                                {
                                    jj = new JObject();
                                }
                            }
                        }
                        else
                        {
                            jj = new JObject();
                        }

                        jj["typesearch"] = "red";
                        IO.File.WriteAllText(jacPath, JsonConvert.SerializeObject(jj, Formatting.Indented));
                    }
                    #endregion
                }

                if (dlna == "on")
                    modules.Add("{\"enable\":true,\"dll\":\"DLNA.dll\"}");

                if (tracks == "on")
                    modules.Add("{\"enable\":true,\"initspace\":\"Tracks.ModInit\",\"dll\":\"Tracks.dll\"}");

                if (ts == "on")
                    modules.Add("{\"enable\":true,\"initspace\":\"TorrServer.ModInit\",\"dll\":\"TorrServer.dll\"}");

                if (catalog == "on")
                    modules.Add("{\"enable\":true,\"initspace\":\"Catalog.ModInit\",\"dll\":\"Catalog.dll\"}");

                if (merch == "on")
                    modules.Add("{\"enable\":false,\"dll\":\"Merchant.dll\"}");

                IO.File.WriteAllText("module/manifest.json", $"[{string.Join(",", modules)}]");

                if (eng != "on")
                    UpdateInitConf(j => j["disableEng"] = true);

                if (isEditManifest)
                {
                    return HttpContext.Response.WriteAsync("–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ lampac –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫");
                }
                else
                {
                    #region frontend cloudflare
                    if (HttpContext.Request.Headers.TryGetValue("CF-Connecting-IP", out var xip) && !string.IsNullOrEmpty(xip))
                    {
                        UpdateInitConf(j =>
                        {
                            var listen = j["listen"] as JObject;
                            if (listen == null)
                            {
                                listen = new JObject();
                                j["listen"] = listen;
                            }

                            listen["frontend"] = "cloudflare";
                        });
                    }
                    #endregion

                    #region htmlSuccess
                    string passwdTxt = IO.File.Exists("passwd") ? IO.File.ReadAllText("passwd").Trim() : string.Empty;

                    #region shared_passwd
                    string sharedBlock = string.Empty;
                    if (IsLocalIp(requestInfo.IP) == false && IO.File.Exists("isdocker") == false)
                    {
                        string shared_passwd = CrypTo.unic(6).ToLower();

                        UpdateInitConf(j =>
                        {
                            var accsdb = j["accsdb"] as JObject;
                            if (accsdb == null)
                            {
                                accsdb = new JObject();
                                j["accsdb"] = accsdb;
                            }

                            accsdb["enable"] = true;
                            accsdb["shared_passwd"] = shared_passwd;
                        });

                        sharedBlock = $@"<div class=""block""><b>–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –≤ Lampa</b><br /><br />
                            –ü–∞—Ä–æ–ª—å: {shared_passwd}
                            <br><br>
                            –û—Ç–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –º–æ–∂–Ω–æ –≤ init.conf (accsdb) –∏–ª–∏ {host}/admin (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏) 
                        </div><hr />";
                    }
                    #endregion

                    string htmlSuccesds = $@"<!DOCTYPE html>
<html>
<head>
    <meta charset=""utf-8"" />
    <title>–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞</title>
</head>
<body>

<style type=""text/css"">
    * {{ box-sizing: border-box; outline: none; }}
    body {{ padding: 40px; font-family: sans-serif; }}
    h1 {{ color: #2b7a78; margin-bottom: 1em; text-align: center; }}
    hr {{ margin-top: 1em; margin-bottom: 2em; }}
    .block {{ margin-top: 20px; }}
    pre {{ background: #f5f5f5; padding: 12px; border-radius: 6px; white-space: pre-wrap; word-break: break-all; }}
</style>

<h1>–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞</h1>

{sharedBlock}

<div class=""block"">
    <b>–ê–¥–º–∏–Ω –ø–∞–Ω–µ–ª—å</b><br /><br />
    A–¥—Ä–µ—Å: {host}/admin<br />
    –ü–∞—Ä–æ–ª—å: {passwdTxt}
</div>

<hr />

<div class=""block"">
    <div style=""margin-top:10px""> 
        <b>Media Station X</b><br /><br />
        Settings -> Start Parameter -> Setup<br />
        Enter current ip address and port: {HttpContext.Request.Host.Value}<br /><br />
        –£–±—Ä–∞—Ç—å/–î–æ–±–∞–≤–∏—Ç—å –∞–¥—Ä–µ—Å–∞ –º–æ–∂–Ω–æ –≤ /home/lampac/msx.json
    </div>
</div>

<hr />

<div class=""block"">
    <b>–í–∏–¥–∂–µ—Ç –¥–ª—è Samsung</b><br /><br />
    {host}/samsung.wgt
</div>

<hr />

<div class=""block"">
    <b>–î–ª—è android apk</b><br /><br />
    –ó–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∞–∑–∞–¥ –∏ –≤–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –∞–¥—Ä–µ—Å: {host}
</div>

<hr />

<div class=""block"">
    <b>–ü–ª–∞–≥–∏–Ω—ã –¥–ª—è Lampa</b><br /><br />
    –ó–∞—Ö–æ–¥–∏–º –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ - —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è, –∂–º–µ–º –Ω–∞ –∫–Ω–æ–ø–∫—É ""–¥–æ–±–∞–≤–∏—Ç—å –ø–ª–∞–≥–∏–Ω"". –í –æ–∫–Ω–µ –≤–≤–æ–¥–∞ –≤–ø–∏—Å—ã–≤–∞–µ–º –∞–¥—Ä–µ—Å –ø–ª–∞–≥–∏–Ω–∞ {host}/on.js –∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –≤–∏–¥–∂–µ—Ç —É–¥–µ—Ä–∂–∏–≤–∞—è –∫–Ω–æ–ø–∫—É ""–Ω–∞–∑–∞–¥"" –ø–æ–∫–∞ –≤–∏–¥–∂–µ—Ç –Ω–µ –∑–∞–∫—Ä–æ–µ—Ç—Å—è.
</div>

<hr />

<div class=""block"">
    <b>TorrServer (–µ—Å–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω)</b><br /><br />
    {host}/ts
</div>

</body>
</html>";

                    return HttpContext.Response.WriteAsync(htmlSuccesds).ContinueWith(t => Program.Reload());
                    #endregion
                }
            }

            #region renderHtml
            string renderHtml()
			{
				var modules = IO.File.Exists("module/manifest.json") ? JsonConvert.DeserializeObject<List<RootModule>>(IO.File.ReadAllText("module/manifest.json")) : null;

				string IsChecked(string name, string def)
				{
					if (modules == null)
						return def;

                    bool res = modules.FirstOrDefault(m => m.dll == name)?.enable ?? false;
                    return res ? "checked" : string.Empty;
                }

                return $@"
<!DOCTYPE html>
<html>
<head>
    <meta charset=""utf-8"" />
	<title>–ú–æ–¥—É–ª–∏</title>
</head>
<body>

<style type='text/css'>
	* {{
	    box-sizing: border-box;
	    outline: none;
	}}
	body{{
		padding: 40px;
		font-family: sans-serif;
	}}
	label{{
		display: block;
		font-weight: 700;
		margin-bottom: 8px;
	}}
	input,
	select{{
		margin: 10px;
		margin-left: 0px;
	}}
	button{{
		padding: 10px;
	}}
	form > * + *{{
		margin-top: 30px;
	}}
	.flex{{
		display: flex;
		align-items: center;
	}}
</style>

<form method='post' action='/admin/manifest/install' id='form'>
	<div>
		<label>–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ–¥—É–ª–µ–π</label>
		<div class='flex'>
			<input name='online' type='checkbox' {IsChecked("Online.dll", "checked")} /> –û–Ω–ª–∞–π–Ω –±–∞–ª–∞–Ω—Å–µ—Ä—ã Rezka, Filmix, etc
		</div>
		<div class='flex'>
			&nbsp; &nbsp; &nbsp; <input name='eng' type='checkbox' checked /> ENG –±–∞–ª–∞–Ω—Å–µ—Ä—ã
		</div>
		<div class='flex'>
			<input name='sisi' type='checkbox' {IsChecked("SISI.dll", "checked")} /> –ö–ª—É–±–Ω–∏—á–∫–∞ 18+, PornHub, Xhamster, etc
		</div>
		<div class='flex'>
			<input name='catalog' type='checkbox' {IsChecked("Catalog.dll", "checked")} /> –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –∫–∞—Ç–∞–ª–æ–≥–∞ cub –∏ tmdb
		</div>
		<div class='flex'>
			<input name='dlna' type='checkbox' {IsChecked("DLNA.dll", "checked")} /> DLNA - –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤ –∏ –ø—Ä–æ—Å–º–æ—Ç—Ä –º–µ–¥–∏–∞ —Ñ–∞–π–ª–æ–≤ —Å –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ 
		</div>
		<div class='flex'>
			<input name='ts' type='checkbox' {IsChecked("TorrServer.dll", "checked")} /> TorrServer - –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å —Ç–æ—Ä—Ä–µ–Ω—Ç—ã –≤ –æ–Ω–ª–∞–π–Ω 
		</div>
		<div class='flex'>
			<input name='tracks' type='checkbox' {IsChecked("Tracks.dll", "checked")} /> Tracks - —Ç—Ä–∞–Ω—Å–∫–æ–¥–∏–Ω–≥ –≤–∏–¥–µ–æ –∏ –∑–∞–º–µ–Ω–∞ –Ω–∞–∑–≤–∞–Ω–∏–π –∞—É–¥–∏–æ–¥–æ—Ä–æ–∂–µ–∫ —Å rus1, rus2 –Ω–∞ —á–∏—Ç–∞–µ–º—ã–µ LostFilm, HDRezka, etc
		</div>
		<div class='flex'>
			<input name='merch' type='checkbox' {IsChecked("Merchant.dll", "")} /> –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –æ–ø–ª–∞—Ç—ã FreeKassa, Streampay, Litecoin, CryptoCloud
		</div>

		<br><br>
		<label>–ü–æ–∏—Å–∫ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤</label>
		<div class='flex'>
			<input name='jac' type='radio' value='webapi' checked /> –ë—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ –ø–æ –≤–Ω–µ—à–Ω–∏–º –±–∞–∑–∞–º JacRed, Rutor, Kinozal, NNM-Club, Rutracker, etc
		</div>
		<div class='flex'>
			<input name='jac' type='radio' value='fdb' /> –õ–æ–∫–∞–ª—å–Ω—ã–π jacred.xyz (–Ω–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —Å—Ç–∞–≤–∏—Ç—å –Ω–∞ –¥–æ–º–∞—à–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞) - 2GB HDD
		</div>
	</div>
	
	<button type='submit'>{(isEditManifest ? "–ò–∑–º–µ–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏" : "–ó–∞–≤–µ—Ä—à–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É")}</button></form></body></html>";
            }
            #endregion

            return HttpContext.Response.WriteAsync(renderHtml());
        }
        #endregion


        #region UpdateInitConf
        void UpdateInitConf(Action<JObject> modify)
        {
            JObject jo;

            if (IO.File.Exists("init.conf"))
            {
                string initconf = IO.File.ReadAllText("init.conf").Trim();
                if (string.IsNullOrEmpty(initconf))
                    jo = new JObject();

                else
                {
                    if (!initconf.StartsWith("{"))
                        initconf = "{" + initconf + "}";

                    try
                    {
                        jo = JsonConvert.DeserializeObject<JObject>(initconf) ?? new JObject();
                    }
                    catch
                    {
                        jo = new JObject();
                    }
                }
            }
            else
            {
                jo = new JObject();
            }

            modify?.Invoke(jo);

            IO.File.WriteAllText("init.conf", JsonConvert.SerializeObject(jo, Formatting.Indented));
        }
        #endregion

        #region IsLocalIp
        bool IsLocalIp(string ip)
        {
            if (string.IsNullOrWhiteSpace(ip))
                return false;

            // –ï—Å–ª–∏ ip –ø—Ä–∏—Ö–æ–¥–∏—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ IPv4-mapped IPv6 (::ffff:192.168.0.1)
            var lastColon = ip.LastIndexOf(':');
            if (lastColon != -1 && ip.Contains("."))
                ip = ip.Substring(lastColon + 1);

            if (!System.Net.IPAddress.TryParse(ip, out var addr))
                return false;

            // loopback (127.0.0.0/8 –∏ ::1)
            if (System.Net.IPAddress.IsLoopback(addr))
                return true;

            if (addr.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork) // IPv4
            {
                var b = addr.GetAddressBytes(); // [a,b,c,d]
                                                // 10.0.0.0/8
                if (b[0] == 10) return true;
                // 127.0.0.0/8
                if (b[0] == 127) return true;
                // 192.168.0.0/16
                if (b[0] == 192 && b[1] == 168) return true;
                // 172.16.0.0/12  => 172.16.0.0 - 172.31.255.255
                if (b[0] == 172 && b[1] >= 16 && b[1] <= 31) return true;

                return false;
            }

            if (addr.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6) // IPv6
            {
                var b = addr.GetAddressBytes();
                // unique local fc00::/7 (first byte 0xfc or 0xfd)
                if ((b[0] & 0xfe) == 0xfc) return true;
                // ::1 handled by IsLoopback above
                return false;
            }

            return false;
        }
        #endregion
    }
}
```

## File: Lampac/Controllers/WebLogController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Shared;

namespace Lampac.Controllers
{
    public class WebLogController : BaseController
    {
        [HttpGet]
        [AllowAnonymous]
        [Route("weblog")]
        public ActionResult WebLog(string token, string pattern, string receive = "http")
        {
            if (!AppInit.conf.weblog.enable)
                return Content("–í–∫–ª—é—á–∏—Ç–µ weblog –≤ init.conf\n\n\"weblog\": {\n   \"enable\": true\n}", contentType: "text/plain; charset=utf-8");

            if (!string.IsNullOrEmpty(AppInit.conf.weblog.token) && token != AppInit.conf.weblog.token)
                return Content("–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /weblog?token=my_key\n\n\"weblog\": {\n   \"enable\": true,\n   \"token\": \"my_key\"\n}", contentType: "text/plain; charset=utf-8");

            string html = $@"<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>weblog</title>
    <style>
        details summary {{
          font-weight: bold;
          font-size: 1.2em;
          color: #2772d2;
          cursor: pointer;
          list-style: none;
          user-select: none;
          position: relative;
        }}

        details summary:hover {{
          color: #1a4bb8;
        }}
    </style>
</head>
<body style='margin: 0px;'>
    <div id='controls' style='margin-bottom: 1em; background: #f0f0f0; padding: 10px; border-bottom: 1px solid #ccc;'>
        <label style='margin-right: 20px;'>–ó–∞–ø—Ä–æ—Å—ã:
            <select id='receiveSelect' style='padding: 0px 5px 0px 0px;'>
                <option value='http' {(receive == "http" ? "selected" : "")}>–ò—Å—Ö–æ–¥—è—â–∏–µ</option>
                <option value='request' {(receive == "request" ? "selected" : "")}>–í—Ö–æ–¥—è—â–∏–µ</option>
            </select>
        </label>
        <label for='patternInput'>–§–∏–ª—å—Ç—Ä: </label>
        <input type='text' id='patternInput' placeholder='rezka.ag' value='{pattern ?? ""}' style='margin-right: 20px;' />
    </div>
    <div id='log'></div>
    <script src='/js/nws-client-es5.js'></script>
    <script src='/signalr-6.0.25_es5.js'></script>
    <script>
        let pattern = document.getElementById('patternInput').value.trim();
        let receive = document.getElementById('receiveSelect').value;

        document.getElementById('patternInput').addEventListener('input', e => {{
            pattern = e.target.value.trim();
        }});
        document.getElementById('receiveSelect').addEventListener('change', e => {{
            receive = e.target.value;
        }});

        function send(message) {{
            if (pattern && message.indexOf(pattern) === -1) return;

            var messageHtml = message.replace(/</g, '&lt;').replace(/>/g, '&gt;');

            const markers = [
              {{ text: 'CurrentUrl: ', caseSensitive: true }},
              {{ text: 'StatusCode: ', caseSensitive: true }},
              {{ text: '&lt;!doctype html&gt;', caseSensitive: false }}
            ];

            for (const marker of markers) {{
              let searchText = marker.text;
              let messageText = messageHtml;
  
              if (!marker.caseSensitive)
                messageText = messageHtml.toLowerCase();
  
              const index = messageText.indexOf(searchText);
              if (index !== -1) {{
                messageHtml = messageHtml.slice(0, index) 
                  + '<details><summary>–ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ</summary>'
                  + messageHtml.slice(index) 
                  + '</details>';
                break;
              }}
            }}

            var par = document.getElementById('log');

            let messageElement = document.createElement('hr');
            messageElement.style.cssText = ' margin-bottom: 2.5em; margin-top: 2.5em;';
            par.insertBefore(messageElement, par.children[0]);

            messageElement = document.createElement('pre');
            messageElement.style.cssText = 'padding: 10px; background: cornsilk; white-space: pre-wrap; word-wrap: break-word;';
            if (messageHtml.indexOf('<details>') !== -1)
                messageElement.innerHTML = messageHtml;
            else 
                messageElement.innerText = message;
            par.insertBefore(messageElement, par.children[0]);
        }}


        let outageReported = false;
        function reportOutageOnce(message) {{
            if (!outageReported) {{
                send(message);
                outageReported = true;
            }}
        }}

        {(AppInit.conf.rch.websoket == "signalr" ? signalCode(token) : nwsCode(token))}
    </script>
</body>
</html>";

            return Content(html, "text/html; charset=utf-8");
        }


        static string nwsCode(string token) => $@"
const client = new NativeWsClient(""/nws"", {{
    autoReconnect: true,
    reconnectDelay: 2000,

    onOpen: function () {{
        send('WebSocket connected');
        outageReported = false;
        client.invoke('RegistryWebLog', '{token}');
    }},

    onClose: function () {{
        reportOutageOnce('Connection closed');
    }},

    onError: function (err) {{
        reportOutageOnce('Connection error: ' + (err && err.message ? err.message : String(err)));
    }}
}});

client.on('Receive', function (message, e) {{
    if (receive === e) send(message);
}});

client.connect();
";

        static string signalCode(string token) => $@"
const hubConnection = new signalR.HubConnectionBuilder()
    .withUrl('/ws')
    .build();

let reconnectAttempts = 0;
const maxReconnectAttempts = 150; // 5 minutes
const reconnectDelay = 2000;      // 2 seconds

function startConnection() {{
    hubConnection.start()
        .then(function () {{
            if (reconnectAttempts != 0)
                send('WebSocket connected');
            reconnectAttempts = 0; // Reset counter on successful connection
            hubConnection.invoke('RegistryWebLog', '{token}');
        }})
        .catch(function (err) {{
            console.log(`${{err.toString()}}\n\nAttempting to reconnect (${{reconnectAttempts}}/${{maxReconnectAttempts}})...`);
            attemptReconnect();
        }});
}}

function attemptReconnect() {{
    if (reconnectAttempts < maxReconnectAttempts) {{
        reconnectAttempts++;
        setTimeout(function() {{
            startConnection();
        }}, reconnectDelay);
    }} else {{
        send('Max reconnection attempts reached. Please refresh the page.');
    }}
}}

hubConnection.on('Receive', function(message, e) {{
    if(receive === e) send(message);
}});

hubConnection.onclose(function(err) {{
    if (err) {{
        send('Connection closed due to error: ' + err.toString());
    }} else {{
        send('Connection closed');
    }}
    attemptReconnect();
}});

startConnection();
";
    }
}
```

## File: Lampac/Controllers/OpenStatController.cs
```
Ôªøusing Lampac.Engine;
using Lampac.Engine.Middlewares;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Shared;
using Shared.Engine;
using Shared.Models.AppConf;
using Shared.PlaywrightCore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.NetworkInformation;

namespace Lampac.Controllers
{
    public class OpenStatController : BaseController
    {
        public OpenStatConf openstat => AppInit.conf.openstat;

        public bool IsDeny(out string ermsg) 
        {
            ermsg = "–í–∫–ª—é—á–∏—Ç–µ openstat –≤ init.conf\n\n\"openstat\": {\n   \"enable\": true\n}";

            if (!openstat.enable || (!string.IsNullOrEmpty(openstat.token) && openstat.token != HttpContext.Request.Query["token"].ToString()))
                return true;

            return false;
        }

        #region browser/context
        [AllowAnonymous]
        [Route("/stats/browser/context")]
        public ActionResult BrowserContext()
        {
            if (IsDeny(out string ermsg))
                return Content(ermsg, "text/plain; charset=utf-8");

            return Json(new
            {
                Chromium = new
                {
                    open = Chromium.ContextsCount,
                    req_keepopen = Chromium.stats_keepopen,
                    req_newcontext = Chromium.stats_newcontext,
                    ping = new 
                    {
                        Chromium.stats_ping.status,
                        Chromium.stats_ping.time,
                        Chromium.stats_ping.ex
                    }
                },
                Firefox = new
                {
                    open = Firefox.ContextsCount,
                    req_keepopen = Firefox.stats_keepopen,
                    req_newcontext = Firefox.stats_newcontext
                }
            });
        }
        #endregion

        #region request
        [AllowAnonymous]
        [Route("/stats/request")]
        public ActionResult Requests()
        {
            if (IsDeny(out string ermsg))
                return Content(ermsg, "text/plain; charset=utf-8");

            long req_min = memoryCache.Get<long>($"stats:request:{DateTime.Now.AddMinutes(-1).Minute}");

            long req_hour = req_min;
            for (int i = 1; i < 58; i++)
            {
                if (memoryCache.TryGetValue($"stats:request:{DateTime.Now.AddMinutes(-i).Minute}", out long _r))
                    req_hour += _r;
            }

            var responseStats = RequestStatisticsTracker.GetResponseTimeStatsLastMinute();

            var httpResponseMs = new Dictionary<string, object>
            {
                ["avg"] = Math.Round(responseStats.Average, 2)
            };

            foreach (var percentile in responseStats.PercentileAverages.OrderBy(x => x.Key))
                httpResponseMs.Add(percentile.Key.ToString(), Math.Round(percentile.Value, 2));

            return Json(new
            {
                req_min,
                req_hour,
                tcpConnections = IPGlobalProperties.GetIPGlobalProperties().GetActiveTcpConnections().Length,
                nws_online = nws.ConnectionCount,
                soks_online = soks.connections,
                http_active = RequestStatisticsTracker.ActiveHttpRequests,
                http_response_ms = httpResponseMs
            });
        }
        #endregion

        #region rch
        [AllowAnonymous]
        [Route("/stats/rch")]
        public ActionResult Rhc()
        {
            if (IsDeny(out string ermsg))
                return Content(ermsg, "text/plain; charset=utf-8");

            return Json(new { clients = RchClient.clients.Count, rchIds = RchClient.rchIds.Count });
        }
        #endregion
    }
}
```

## File: Lampac/Controllers/CubController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Shared;
using Shared.Engine;
using System.Web;

namespace Lampac.Controllers
{
    public class CubController : BaseController
    {
        [HttpGet]
        [AllowAnonymous]
        [Route("cubproxy.js")]
        [Route("cubproxy/js/{token}")]
        public ActionResult CubProxy(string token)
        {
            if (!AppInit.conf.cub.enabled(requestInfo.Country))
                return Content(string.Empty, contentType: "application/javascript; charset=utf-8");

            string file = FileCache.ReadAllText("plugins/cubproxy.js").Replace("{localhost}", host);
            file = file.Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(file, contentType: "application/javascript; charset=utf-8");
        }
    }
}
```

## File: Lampac/Controllers/TmdbController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Shared;
using Shared.Engine;
using System.Web;

namespace Lampac.Controllers
{
    public class TmdbController : BaseController
    {
        [HttpGet]
        [AllowAnonymous]
        [Route("tmdbproxy.js")]
        [Route("tmdbproxy/js/{token}")]
        public ActionResult TmdbProxy(string token)
        {
            string file = FileCache.ReadAllText("plugins/tmdbproxy.js").Replace("{localhost}", host);
            file = file.Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(file, contentType: "application/javascript; charset=utf-8");
        }
    }
}
```

## File: Lampac/Engine/soks.cs
```
Ôªøusing Microsoft.AspNetCore.SignalR;
using Shared;
using Shared.Engine;
using Shared.Models;
using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading.Tasks;

namespace Lampac.Engine
{
    public class soks : Hub, ISoks
    {
        #region soks
        public static int connections { get; private set; }

        public static IHubCallerClients hubClients = null;

        public IHubCallerClients AllClients => hubClients;
        #endregion

        #region Rch
        public void RchRegistry(string json)
        {
            if (!AppInit.conf.rch.enable)
                return;

            var httpContext = Context.GetHttpContext();
            var requestInfo = httpContext.Features.Get<RequestModel>();
            RchClient.Registry(requestInfo.IP, Context.ConnectionId, AppInit.Host(httpContext), json);
        }

        public void RchResult(string id, string value)
        {
            if (!AppInit.conf.rch.enable)
                return;

            if (RchClient.rchIds.TryGetValue(id, out var tcs))
                tcs.SetResult(value ?? string.Empty);
        }
        #endregion

        #region WebLog
        public static ConcurrentDictionary<string, byte> weblog_clients = new ConcurrentDictionary<string, byte>();

        public void RegistryWebLog(string token)
        {
            if (AppInit.conf.weblog.enable)
            {
                if (string.IsNullOrEmpty(AppInit.conf.weblog.token) || AppInit.conf.weblog.token == token)
                {
                    weblog_clients.AddOrUpdate(Context.ConnectionId, 0, (k, v) => 0);
                    return;
                }
            }
        }

        public void WebLog(string message, string plugin) => SendLog(message, plugin);

        public static void SendLog(string message, string plugin)
        {
            if (!AppInit.conf.weblog.enable || hubClients == null || string.IsNullOrEmpty(message) || string.IsNullOrEmpty(plugin) || message.Length > 4_000000)
                return;

            if (weblog_clients.Count > 0)
                hubClients.Clients(weblog_clients.Keys).SendAsync("Receive", message, plugin).ConfigureAwait(false);
        }
        #endregion

        #region Events
        static ConcurrentDictionary<string, string> event_clients = new ConcurrentDictionary<string, string>();

        public void RegistryEvent(string uid)
        {
            if (string.IsNullOrEmpty(uid))
                return;

            event_clients.AddOrUpdate(Context.ConnectionId, uid, (k,v) => uid);
        }

        /// <summary>
        /// –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π —á–µ—Ä–µ–∑ js
        /// </summary>
        /// <param name="uid"></param>
        /// <param name="name"></param>
        /// <param name="data"></param>
        public async Task events(string uid, string name, string data)
        {
            if (hubClients == null || string.IsNullOrEmpty(uid) || string.IsNullOrEmpty(name) || (data != null && data.Length > 10_000000))
                return;

            try
            {
                var clients = event_clients.Where(i => i.Value == uid && i.Key != Context.ConnectionId);
                if (clients.Any())
                    await hubClients.Clients(clients.Select(i => i.Key)).SendAsync("event", uid, name, data ?? string.Empty).ConfigureAwait(false);
            }
            catch { }
        }

        public async Task eventsId(string connectionId, string uid, string name, string data)
        {
            if (hubClients == null || string.IsNullOrEmpty(connectionId) || string.IsNullOrEmpty(name) || (data != null && data.Length > 10_000000))
                return;

            try
            {
                var clients = event_clients.Where(i => i.Key == connectionId);
                if (clients.Any())
                    await hubClients.Clients(clients.Select(i => i.Key)).SendAsync("event", uid ?? string.Empty, name, data ?? string.Empty).ConfigureAwait(false);
            }
            catch { }
        }

        public Task EventsAsync(string connectionId, string uid, string name, string data) => SendEvents(connectionId, uid, name, data);

        /// <summary>
        /// –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π —á–µ—Ä–µ–∑ —Å–µ—Ä–≤–µ—Ä
        /// </summary>
        /// <param name="connectionId"></param>
        /// <param name="uid"></param>
        /// <param name="name"></param>
        /// <param name="data"></param>
        async public static Task SendEvents(string connectionId, string uid, string name, string data)
        {
            if (hubClients == null || string.IsNullOrEmpty(uid) || string.IsNullOrEmpty(name) || (data != null && data.Length > 10_000000))
                return;

            try
            {
                var clients = event_clients.Where(i => i.Value == uid && i.Key != connectionId);
                if (clients.Any())
                    await hubClients.Clients(clients.Select(i => i.Key)).SendAsync("event", uid, name, data ?? string.Empty).ConfigureAwait(false);
            }
            catch { }
        }
        #endregion

        #region Connected / Disconnected
        public override Task OnConnectedAsync()
        {
            hubClients = Clients;
            connections++;

            return base.OnConnectedAsync();
        }

        public override Task OnDisconnectedAsync(Exception exception)
        {
            weblog_clients.TryRemove(Context.ConnectionId, out _);
            event_clients.TryRemove(Context.ConnectionId, out _);
            RchClient.OnDisconnected(Context.ConnectionId);

            hubClients = Clients;
            connections--;

            return base.OnDisconnectedAsync(exception);
        }
        #endregion


        public static void FullDispose()
        {
        }
    }
}

```

## File: Lampac/Engine/DynamicActionDescriptorChangeProvider.cs
```
using Microsoft.AspNetCore.Mvc.Infrastructure;
using Microsoft.Extensions.Primitives;
using System.Threading;

namespace Lampac.Engine
{
    public class DynamicActionDescriptorChangeProvider : IActionDescriptorChangeProvider
    {
        public static DynamicActionDescriptorChangeProvider Instance { get; } = new DynamicActionDescriptorChangeProvider();

        private CancellationTokenSource tokenSource = new CancellationTokenSource();
        public CancellationTokenSource TokenSource => tokenSource;

        public IChangeToken GetChangeToken() => new CancellationChangeToken(tokenSource.Token);

        public void NotifyChanges()
        {
            var previous = Interlocked.Exchange(ref tokenSource, new CancellationTokenSource());
            previous.Cancel();
        }
    }
}

```

## File: Lampac/Engine/nws.cs
```
using Microsoft.AspNetCore.Http;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Events;
using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine
{
    public class nws : INws
    {
        #region fields
        static readonly JsonSerializerOptions serializerOptions = new JsonSerializerOptions
        {
            WriteIndented = false
        };

        public static readonly ConcurrentDictionary<string, NwsConnection> _connections = new ConcurrentDictionary<string, NwsConnection>();

        static readonly Timer ConnectionMonitorTimer = new Timer(ConnectionMonitorCallback, null, TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1));

        public readonly static ConcurrentDictionary<string, byte> weblog_clients = new ConcurrentDictionary<string, byte>();

        public readonly static ConcurrentDictionary<string, string> event_clients = new ConcurrentDictionary<string, string>();

        public static int ConnectionCount => _connections.Count;
        #endregion

        #region interface
        public void WebLog(string message, string plugin) => SendLog(message, plugin);

        public Task EventsAsync(string connectionId, string uid, string name, string data) => SendEvents(connectionId, uid, name, data);

        public Task SendAsync(string connectionId, string method, params object[] args)
        {
            if (connectionId != null && _connections.TryGetValue(connectionId, out var client))
                return SendAsync(client, method, args);

            return Task.CompletedTask;
        }

        public ConcurrentDictionary<string, NwsConnection> AllConnections() => _connections;
        #endregion

        #region handle
        public static async Task HandleWebSocketAsync(HttpContext context)
        {
            if (!context.WebSockets.IsWebSocketRequest)
            {
                context.Response.StatusCode = StatusCodes.Status400BadRequest;
                return;
            }

            using (var socket = await context.WebSockets.AcceptWebSocketAsync().ConfigureAwait(false))
            {
                string connectionId = Guid.NewGuid().ToString("N");

                if (context.Request.Query.TryGetValue("id", out var _connectionId) && !string.IsNullOrEmpty(_connectionId.ToString()))
                {
                    connectionId = _connectionId.ToString();
                    Cleanup(connectionId);
                }

                try
                {
                    var requestInfo = context.Features.Get<RequestModel>();
                    string ip = requestInfo.IP ?? context.Connection.RemoteIpAddress?.ToString();

                    var connection = new NwsConnection(connectionId, socket, AppInit.Host(context), ip, requestInfo.UserAgent);

                    var cancellationSource = CancellationTokenSource.CreateLinkedTokenSource(context.RequestAborted);
                    connection.SetCancellationSource(cancellationSource);

                    _connections.AddOrUpdate(connectionId, connection, (k, v) => connection);

                    await SendAsync(connection, "Connected", connectionId).ConfigureAwait(false);

                    InvkEvent.NwsConnected(new EventNwsConnected(connectionId, ip, requestInfo, connection, cancellationSource.Token));

                    await ReceiveLoopAsync(connection, cancellationSource.Token).ConfigureAwait(false);
                }
                finally
                {
                    Cleanup(connectionId);
                    InvkEvent.NwsDisconnected(new EventNwsDisconnected(connectionId));
                }
            }
        }
        #endregion

        #region receive loop
        static async Task ReceiveLoopAsync(NwsConnection connection, CancellationToken token)
        {
            WebSocket socket = connection.Socket;
            var buffer = ArrayPool<byte>.Shared.Rent(4096);
            var builder = new StringBuilder();

            try
            {
                while (socket.State == WebSocketState.Open && !token.IsCancellationRequested)
                {
                    builder.Clear();

                    WebSocketReceiveResult result;

                    do
                    {
                        result = await socket.ReceiveAsync(new ArraySegment<byte>(buffer), token).ConfigureAwait(false);

                        if (result.MessageType == WebSocketMessageType.Close)
                        {
                            using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(20)))
                                await socket.CloseAsync(result.CloseStatus ?? WebSocketCloseStatus.NormalClosure, result.CloseStatusDescription, cts.Token).ConfigureAwait(false);
                            return;
                        }

                        if (result.Count > 0)
                        {
                            builder.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));
                            if (builder.Length > 10_000000)
                            {
                                using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(20)))
                                    await socket.CloseAsync(WebSocketCloseStatus.MessageTooBig, "payload too large", cts.Token).ConfigureAwait(false);
                                return;
                            }
                        }
                    }
                    while (!result.EndOfMessage);

                    connection.UpdateActivity();

                    if (result.MessageType == WebSocketMessageType.Text)
                    {
                        string message = builder.ToString();
                        builder.Clear();

                        if (!string.IsNullOrWhiteSpace(message) && message != "ping")
                            await HandleMessageAsync(connection, message).ConfigureAwait(false);
                    }
                }
            }
            catch (OperationCanceledException)
            {
            }
            catch (WebSocketException)
            {
            }
            catch (Exception)
            {
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
                builder.Clear();
            }
        }
        #endregion

        #region message handling
        static async Task HandleMessageAsync(NwsConnection connection, string payload)
        {
            try
            {
                using JsonDocument document = JsonDocument.Parse(payload);
                if (document.RootElement.ValueKind != JsonValueKind.Object)
                    return;

                if (!document.RootElement.TryGetProperty("method", out var methodProp))
                    return;

                string method = methodProp.GetString();
                JsonElement args = default;

                if (document.RootElement.TryGetProperty("args", out var argsProp) && argsProp.ValueKind == JsonValueKind.Array)
                    args = argsProp;

                InvkEvent.NwsMessage(new EventNwsMessage(connection.ConnectionId, payload, method, args));

                await InvokeAsync(connection, method, args).ConfigureAwait(false);
            }
            catch (JsonException)
            {
            }
        }

        static async Task InvokeAsync(NwsConnection connection, string method, JsonElement args)
        {
            if (string.IsNullOrEmpty(method))
                return;

            switch (method.ToLower())
            {
                case "rchregistry":
                    if (AppInit.conf.rch.enable)
                    {
                        string json = GetStringArg(args, 0);
                        RchClient.Registry(connection.Ip, connection.ConnectionId, connection.Host, json, connection);
                        await SendAsync(connection, "RchRegistry", connection.Ip).ConfigureAwait(false);
                    }
                    break;

                case "rchresult":
                    if (AppInit.conf.rch.enable)
                    {
                        string id = GetStringArg(args, 0);
                        string value = GetStringArg(args, 1) ?? string.Empty;

                        if (!string.IsNullOrEmpty(id) && RchClient.rchIds.TryGetValue(id, out var tcs))
                            tcs.TrySetResult(value);
                    }
                    break;

                case "registryweblog":
                    if (AppInit.conf.weblog.enable)
                    {
                        string token = GetStringArg(args, 0);
                        if (string.IsNullOrEmpty(AppInit.conf.weblog.token) || AppInit.conf.weblog.token == token)
                            weblog_clients.AddOrUpdate(connection.ConnectionId, 0, static (_, __) => 0);
                    }
                    break;

                case "weblog":
                    SendLog(GetStringArg(args, 0), GetStringArg(args, 1));
                    break;

                case "registryevent":
                {
                    string uid = GetStringArg(args, 0);
                    if (!string.IsNullOrEmpty(uid))
                        event_clients.AddOrUpdate(connection.ConnectionId, uid, (_, __) => uid);
                    break;
                }

                case "events":
                {
                    string uid = GetStringArg(args, 0);
                    string name = GetStringArg(args, 1);
                    string data = GetStringArg(args, 2);

                    if (name == "devices")
                    {
                        var evc = event_clients.Where(i => i.Value == uid).ToArray();

                        var devices = _connections
                            .Where(i => i.Value.ConnectionId != connection.ConnectionId)
                            .Where(i => i.Value.Ip == connection.Ip || event_clients.Values.Contains(uid))
                            .Select(i => new {
                                uid = event_clients.TryGetValue(i.Value.ConnectionId, out var _uid) ? _uid : null, 
                                i.Value.ConnectionId, 
                                i.Value.UserAgent
                            })
                            .ToArray();

                        await SendAsync(connection, "event", uid, name, devices).ConfigureAwait(false);
                        break;
                    }

                    await SendEvents(connection.ConnectionId, uid, name, data).ConfigureAwait(false);
                    break;
                }

                case "eventsid":
                {
                    string targetConnection = GetStringArg(args, 0);
                    string uid = GetStringArg(args, 1);
                    string name = GetStringArg(args, 2);
                    string data = GetStringArg(args, 3);
                    await SendEventToConnection(targetConnection, uid, name, data).ConfigureAwait(false);
                    break;
                }

                case "ping":
                    await SendAsync(connection, "pong").ConfigureAwait(false);
                    break;
            }
        }

        static string GetStringArg(JsonElement args, int index)
        {
            if (args.ValueKind != JsonValueKind.Array || args.GetArrayLength() <= index)
                return null;

            var element = args[index];
            if (element.ValueKind == JsonValueKind.String)
                return element.GetString();

            if (element.ValueKind == JsonValueKind.Null)
                return null;

            return element.ToString();
        }
        #endregion

        #region SendAsync
        static async Task SendAsync(NwsConnection connection, string method, params object[] args)
        {
            if (connection.Socket.State != WebSocketState.Open || string.IsNullOrEmpty(method))
                return;

            var payload = new { method, args = args ?? Array.Empty<object>() };
            byte[] bytes;

            try
            {
                bytes = Encoding.UTF8.GetBytes(JsonSerializer.Serialize(payload, serializerOptions));
            }
            catch
            {
                return;
            }

            try
            {
                await connection.SendLock.WaitAsync(TimeSpan.FromSeconds(20)).ConfigureAwait(false);

                if (connection.Socket.State == WebSocketState.Open)
                {
                    using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10)))
                        await connection.Socket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, cts.Token).ConfigureAwait(false);

                    connection.UpdateActivity();
                }
            }
            catch (WebSocketException)
            {
            }
            catch (OperationCanceledException)
            {
            }
            finally
            {
                connection.SendLock.Release();
            }
        }

        public static void SendLog(string message, string plugin)
        {
            if (!AppInit.conf.weblog.enable || string.IsNullOrEmpty(message) || string.IsNullOrEmpty(plugin) || message.Length > 4_000000)
                return;

            if (weblog_clients.IsEmpty)
                return;

            foreach (string connectionId in weblog_clients.Keys)
            {
                if (_connections.TryGetValue(connectionId, out var client))
                    _ = SendAsync(client, "Receive", message, plugin).ConfigureAwait(false);
            }
        }

        public static Task SendEvents(string connectionId, string uid, string name, string data)
        {
            if (string.IsNullOrEmpty(uid) || string.IsNullOrEmpty(name))
                return Task.CompletedTask;

            var targets = event_clients.Where(i => i.Value == uid && (connectionId == null || i.Key != connectionId)).Select(i => i.Key).ToArray();
            if (targets.Length == 0)
                return Task.CompletedTask;

            var tasks = new List<Task>(targets.Length);
            foreach (string targetId in targets)
            {
                if (_connections.TryGetValue(targetId, out var client))
                    tasks.Add(SendAsync(client, "event", uid, name, data ?? string.Empty));
            }

            if (tasks.Count == 0)
                return Task.CompletedTask;

            return Task.WhenAll(tasks);
        }

        static Task SendEventToConnection(string connectionId, string uid, string name, string data)
        {
            if (string.IsNullOrEmpty(connectionId) || string.IsNullOrEmpty(name))
                return Task.CompletedTask;

            if (_connections.TryGetValue(connectionId, out var client))
                return SendAsync(client, "event", uid ?? string.Empty, name, data ?? string.Empty);

            return Task.CompletedTask;
        }

        public static Task SendRchRequestAsync(string connectionId, string rchId, string url, string data, Dictionary<string, string> headers, bool returnHeaders)
        {
            if (string.IsNullOrEmpty(connectionId))
                return Task.CompletedTask;

            if (_connections.TryGetValue(connectionId, out var client))
                return SendAsync(client, "RchClient", rchId, url, data, headers, returnHeaders);

            return Task.CompletedTask;
        }
        #endregion

        #region cleanup
        public static void Cleanup(string connectionId)
        {
            if (string.IsNullOrEmpty(connectionId))
                return;

            if (_connections.TryRemove(connectionId, out var connection))
            {
                connection.Cancel();
                connection.Dispose();
            }

            weblog_clients.TryRemove(connectionId, out _);
            event_clients.TryRemove(connectionId, out _);
            RchClient.OnDisconnected(connectionId);
        }
        #endregion

        #region ConnectionMonitorCallback
        static void ConnectionMonitorCallback(object state)
        {
            try
            {
                if (_connections.IsEmpty)
                    return;

                foreach (string connectionId in _connections.Select(kv => kv.Key).ToArray())
                {
                    if (_connections.TryGetValue(connectionId, out var connection))
                    {
                        if (DateTime.UtcNow.AddMinutes(-2) >= connection.LastActivityUtc)
                            connection.Cancel();
                    }
                }
            }
            catch
            {
            }
        }
        #endregion


        #region FullDispose
        public static void FullDispose()
        {
            ConnectionMonitorTimer.Dispose();
            foreach (var connection in _connections)
                connection.Value.Cancel();
        }
        #endregion
    }
}

```

## File: Lampac/Engine/Middlewares/ProxyCub.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Models;
using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class ProxyCub
    {
        #region ProxyCub
        static FileSystemWatcher fileWatcher;

        static ConcurrentDictionary<string, byte> cacheFiles = new ConcurrentDictionary<string, byte>();

        static Timer cleanupTimer;

        static ProxyCub() 
        {
            Directory.CreateDirectory("cache/cub");

            foreach (var item in Directory.EnumerateFiles("cache/cub", "*"))
                cacheFiles.TryAdd(Path.GetFileName(item), 0);

            fileWatcher = new FileSystemWatcher
            {
                Path = "cache/cub",
                NotifyFilter = NotifyFilters.FileName,
                EnableRaisingEvents = true
            };

            fileWatcher.Created += (s, e) => { cacheFiles.TryAdd(e.Name, 0); };
            fileWatcher.Deleted += (s, e) => { cacheFiles.TryRemove(e.Name, out _); };

            cleanupTimer = new Timer(cleanup, null, TimeSpan.FromMinutes(30), TimeSpan.FromMinutes(30));
        }

        static void cleanup(object state)
        {
            try
            {
                var files = Directory.GetFiles("cache/cub", "*").Select(f => Path.GetFileName(f)).ToHashSet();

                foreach (string md5fileName in cacheFiles.Keys.ToArray())
                {
                    if (!files.Contains(md5fileName))
                        cacheFiles.TryRemove(md5fileName, out _);
                }
            }
            catch { }
        }

        public ProxyCub(RequestDelegate next) { }
        #endregion

        async public Task InvokeAsync(HttpContext httpContext, IMemoryCache memoryCache)
        {
            using (var ctsHttp = CancellationTokenSource.CreateLinkedTokenSource(httpContext.RequestAborted))
            {
                ctsHttp.CancelAfter(TimeSpan.FromSeconds(90));

                var hybridCache = new HybridCache();
                var requestInfo = httpContext.Features.Get<RequestModel>();

                var init = AppInit.conf.cub;
                string domain = init.domain;
                string path = httpContext.Request.Path.Value.Replace("/cub/", "");
                string query = httpContext.Request.QueryString.Value;
                string uri = Regex.Match(path, "^[^/]+/(.*)").Groups[1].Value + query;

                if (!init.enable || domain == "ws")
                {
                    httpContext.Response.Redirect($"https://{path}/{query}");
                    return;
                }

                if (path.Split(".")[0] is "geo" or "tmdb" or "tmapi" or "apitmdb" or "imagetmdb" or "cdn" or "ad" or "ws")
                    domain = $"{path.Split(".")[0]}.{domain}";

                if (domain.StartsWith("geo"))
                {
                    string country = requestInfo.Country;
                    if (string.IsNullOrEmpty(country))
                    {
                        var ipify = await Http.Get<JObject>("https://api.ipify.org/?format=json");
                        if (ipify != null || !string.IsNullOrEmpty(ipify.Value<string>("ip")))
                            country = GeoIP2.Country(ipify.Value<string>("ip"));
                    }

                    await httpContext.Response.WriteAsync(country ?? "", ctsHttp.Token);
                    return;
                }

                #region checker
                if (path.StartsWith("api/checker") || uri.StartsWith("api/checker"))
                {
                    if (HttpMethods.IsPost(httpContext.Request.Method))
                    {
                        if (httpContext.Request.ContentType != null &&
                            httpContext.Request.ContentType.StartsWith("application/x-www-form-urlencoded", StringComparison.OrdinalIgnoreCase))
                        {
                            using (var reader = new StreamReader(httpContext.Request.Body, leaveOpen: true))
                            {
                                string form = await reader.ReadToEndAsync();

                                var match = Regex.Match(form, @"(?:^|&)data=([^&]+)");
                                if (match.Success)
                                {
                                    string dataValue = Uri.UnescapeDataString(match.Groups[1].Value);
                                    await httpContext.Response.WriteAsync(dataValue, ctsHttp.Token);
                                    return;
                                }
                            }
                        }
                    }

                    await httpContext.Response.WriteAsync("ok", ctsHttp.Token);
                    return;
                }
                #endregion

                #region blacklist
                if (uri.StartsWith("api/plugins/blacklist"))
                {
                    httpContext.Response.ContentType = "application/json; charset=utf-8";
                    await httpContext.Response.WriteAsync("[]", ctsHttp.Token);
                    return;
                }
                #endregion

                #region ads/log/metric
                if (uri.StartsWith("api/metric/") || uri.StartsWith("api/ad/stat"))
                {
                    await httpContext.Response.WriteAsJsonAsync(new { secuses = true });
                    return;
                }

                if (uri.StartsWith("api/ad/vast"))
                {
                    await httpContext.Response.WriteAsJsonAsync(new 
                    { 
                        secuses = true,
                        ad = new string[] { },
                        day_of_month = DateTime.Now.Day,
                        days_in_month =  31,
                        month = DateTime.Now.Month
                    });
                    return;
                }
                #endregion

                var proxyManager = new ProxyManager("cub_api", init);
                var proxy = proxyManager.Get();

                bool isMedia = Regex.IsMatch(uri, "\\.(jpe?g|png|gif|webp|ico|svg|mp4|js|css)");

                if (0 >= init.cache_api || !HttpMethods.IsGet(httpContext.Request.Method) || isMedia ||
                    (path.Split(".")[0] is "imagetmdb" or "cdn" or "ad") ||
                    httpContext.Request.Headers.ContainsKey("token") || httpContext.Request.Headers.ContainsKey("profile"))
                {
                    #region bypass
                    string md5key = CrypTo.md5($"{domain}:{uri}");
                    string outFile = Path.Combine("cache", "cub", md5key);

                    if (cacheFiles.ContainsKey(md5key))
                    {
                        httpContext.Response.Headers["X-Cache-Status"] = "HIT";
                        httpContext.Response.ContentType = getContentType(uri);
                        await httpContext.Response.SendFileAsync(outFile);
                        return;
                    }

                    var handler = new HttpClientHandler()
                    {
                        AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate,
                        AllowAutoRedirect = false
                    };

                    handler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;

                    if (proxy != null)
                    {
                        handler.UseProxy = true;
                        handler.Proxy = proxy;
                    }
                    else { handler.UseProxy = false; }

                    var client = FrendlyHttp.HttpMessageClient("proxy", handler);
                    var request = CreateProxyHttpRequest(httpContext, new Uri($"{init.scheme}://{domain}/{uri}"), requestInfo, init.viewru && path.Split(".")[0] == "tmdb");

                    using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(15)))
                    {
                        using (var response = await client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cts.Token))
                        {
                            if (init.cache_img > 0 && isMedia && HttpMethods.IsGet(httpContext.Request.Method) && AppInit.conf.mikrotik == false && response.StatusCode == HttpStatusCode.OK)
                            {
                                #region cache
                                httpContext.Response.ContentType = getContentType(uri);
                                httpContext.Response.Headers["X-Cache-Status"] = "MISS";

                                int initialCapacity = response.Content.Headers.ContentLength.HasValue ?
                                    (int)response.Content.Headers.ContentLength.Value :
                                    20_000; // 20kB

                                using (var memoryStream = new MemoryStream(initialCapacity))
                                {
                                    try
                                    {
                                        bool saveCache = true;

                                        using (var responseStream = await response.Content.ReadAsStreamAsync())
                                        {
                                            byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);

                                            try
                                            {
                                                int bytesRead;

                                                while ((bytesRead = await responseStream.ReadAsync(buffer, ctsHttp.Token)) > 0)
                                                {
                                                    memoryStream.Write(buffer, 0, bytesRead);
                                                    await httpContext.Response.Body.WriteAsync(buffer, 0, bytesRead, ctsHttp.Token);
                                                }
                                            }
                                            catch
                                            {
                                                saveCache = false;
                                            }
                                            finally
                                            {
                                                ArrayPool<byte>.Shared.Return(buffer);
                                            }
                                        }

                                        if (saveCache && memoryStream.Length > 1000)
                                        {
                                            try
                                            {
                                                if (!cacheFiles.ContainsKey(md5key))
                                                {
                                                    File.WriteAllBytes(outFile, memoryStream.ToArray());
                                                    cacheFiles.TryAdd(md5key, 0);
                                                }
                                            }
                                            catch { File.Delete(outFile); }
                                        }
                                    }
                                    catch { }
                                }
                                #endregion
                            }
                            else
                            {
                                httpContext.Response.Headers["X-Cache-Status"] = "bypass";
                                await CopyProxyHttpResponse(httpContext, response);
                            }
                        }
                    }
                    #endregion
                }
                else
                {
                    #region cache
                    string memkey = $"cubproxy:{domain}:{uri}";
                    (string content, int statusCode, string contentType) cache = default;

                    var semaphore = new SemaphorManager(memkey, TimeSpan.FromSeconds(20));

                    try
                    {
                        await semaphore.WaitAsync();

                        if (!hybridCache.TryGetValue(memkey, out cache, inmemory: false))
                        {
                            var headers = HeadersModel.Init();

                            if (!string.IsNullOrEmpty(requestInfo.Country))
                                headers.Add(new HeadersModel("cf-connecting-ip", requestInfo.IP));

                            if (path.Split(".")[0] == "tmdb")
                            {
                                if (init.viewru)
                                    headers.Add(new HeadersModel("cookie", "viewru=1"));

                                headers.Add(new HeadersModel("user-agent", httpContext.Request.Headers.UserAgent.ToString()));
                            }
                            else
                            {
                                foreach (var header in httpContext.Request.Headers)
                                {
                                    if (header.Key.ToLower() is "cookie" or "user-agent")
                                        headers.Add(new HeadersModel(header.Key, header.Value.ToString()));
                                }
                            }

                            var result = await Http.BaseGetAsync($"{init.scheme}://{domain}/{uri}", timeoutSeconds: 10, proxy: proxy, headers: headers, statusCodeOK: false, useDefaultHeaders: false);
                            if (string.IsNullOrEmpty(result.content))
                            {
                                proxyManager.Refresh();
                                httpContext.Response.StatusCode = (int)result.response.StatusCode;
                                return;
                            }

                            cache.content = result.content;
                            cache.statusCode = (int)result.response.StatusCode;
                            cache.contentType = result.response.Content.Headers.ContentType.ToString();

                            if (domain.StartsWith("tmdb") || domain.StartsWith("tmapi") || domain.StartsWith("apitmdb"))
                            {
                                if (cache.content == "{\"blocked\":true}")
                                {
                                    var header = HeadersModel.Init(("localrequest", AppInit.rootPasswd));
                                    string json = await Http.Get($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/{uri}", timeoutSeconds: 5, headers: header);
                                    if (!string.IsNullOrEmpty(json))
                                    {
                                        cache.statusCode = 200;
                                        cache.contentType = "application/json; charset=utf-8";
                                        cache.content = json;
                                    }
                                }
                            }

                            httpContext.Response.Headers["X-Cache-Status"] = "MISS";

                            if (cache.statusCode == 200)
                            {
                                proxyManager.Success();
                                hybridCache.Set(memkey, cache, DateTime.Now.AddMinutes(init.cache_api), inmemory: false);
                            }
                        }
                        else
                        {
                            httpContext.Response.Headers["X-Cache-Status"] = "HIT";
                        }
                    }
                    finally
                    {
                        semaphore.Release();
                    }

                    httpContext.Response.StatusCode = cache.statusCode;
                    httpContext.Response.ContentType = cache.contentType;
                    await httpContext.Response.WriteAsync(cache.content, ctsHttp.Token);
                    #endregion
                }
            }
        }


        #region getContentType
        static string getContentType(string uri)
        {
            return Path.GetExtension(uri).ToLowerInvariant() switch
            {
                ".jpg" or ".jpeg" => "image/jpeg",
                ".png" => "image/png",
                ".gif" => "image/gif",
                ".webp" => "image/webp",
                ".ico" => "image/x-icon",
                ".svg" => "image/svg+xml",
                ".mp4" => "video/mp4",
                ".js" => "application/javascript",
                ".css" => "text/css",
                _ => "application/octet-stream"
            };
        }
        #endregion

        #region CreateProxyHttpRequest
        HttpRequestMessage CreateProxyHttpRequest(HttpContext context, Uri uri, RequestModel requestInfo, bool viewru)
        {
            var request = context.Request;

            var requestMessage = new HttpRequestMessage();

            var requestMethod = request.Method;
            if (HttpMethods.IsPost(requestMethod))
            {
                var streamContent = new StreamContent(request.Body);
                requestMessage.Content = streamContent;
            }

            if (viewru)
                request.Headers["cookie"] = "viewru=1";

            #region Headers
            foreach (var header in request.Headers)
            {
                if (header.Key.ToLower() is "host" or "origin" or "content-disposition" or "accept-encoding")
                    continue;

                if (viewru && header.Key.ToLower() == "cookie")
                    continue;

                if (header.Key.ToLower().StartsWith("x-"))
                    continue;

                if (!requestMessage.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray()) && requestMessage.Content != null)
                    requestMessage.Content?.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray());
            }
            #endregion

            if (!string.IsNullOrEmpty(requestInfo.Country))
                requestMessage.Headers.Add("cf-connecting-ip", requestInfo.IP);

            requestMessage.Headers.Host = uri.Authority;
            requestMessage.RequestUri = uri;
            requestMessage.Method = new HttpMethod(request.Method);
            //requestMessage.Version = new Version(2, 0);

            return requestMessage;
        }
        #endregion

        #region CopyProxyHttpResponse
        async Task CopyProxyHttpResponse(HttpContext context, HttpResponseMessage responseMessage)
        {
            var response = context.Response;
            response.StatusCode = (int)responseMessage.StatusCode;
            response.ContentLength = responseMessage.Content.Headers.ContentLength;

            #region UpdateHeaders
            void UpdateHeaders(HttpHeaders headers)
            {
                foreach (var header in headers)
                {
                    if (header.Key.ToLower() is "transfer-encoding" or "etag" or "connection" or "content-security-policy" or "content-disposition")
                        continue;

                    if (header.Key.ToLower().StartsWith("x-"))
                        continue;

                    if (header.Key.ToLower().Contains("access-control"))
                        continue;

                    string value = string.Empty;
                    foreach (var val in header.Value)
                        value += $"; {val}";

                    response.Headers[header.Key] = Regex.Replace(value, "^; ", "");
                }
            }
            #endregion

            UpdateHeaders(responseMessage.Headers);
            UpdateHeaders(responseMessage.Content.Headers);

            using (var responseStream = await responseMessage.Content.ReadAsStreamAsync())
            {
                if (response.Body == null)
                    throw new ArgumentNullException("destination");

                if (!responseStream.CanRead && !responseStream.CanWrite)
                    throw new ObjectDisposedException("ObjectDisposed_StreamClosed");

                if (!response.Body.CanRead && !response.Body.CanWrite)
                    throw new ObjectDisposedException("ObjectDisposed_StreamClosed");

                if (!responseStream.CanRead)
                    throw new NotSupportedException("NotSupported_UnreadableStream");

                if (!response.Body.CanWrite)
                    throw new NotSupportedException("NotSupported_UnwritableStream");

                using (var ctsHttp = CancellationTokenSource.CreateLinkedTokenSource(context.RequestAborted))
                {
                    ctsHttp.CancelAfter(TimeSpan.FromSeconds(90));
                    byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);

                    try
                    {
                        int bytesRead;

                        while ((bytesRead = await responseStream.ReadAsync(buffer, ctsHttp.Token)) != 0)
                            await response.Body.WriteAsync(buffer, 0, bytesRead, ctsHttp.Token);
                    }
                    finally
                    {
                        ArrayPool<byte>.Shared.Return(buffer);
                    }
                }
            }
        }
        #endregion
    }
}

```

## File: Lampac/Engine/Middlewares/OverrideResponse.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.CodeAnalysis.Scripting;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.CSharpGlobals;
using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class OverrideResponse
    {
        private readonly RequestDelegate _next;
        private readonly bool first;
        public OverrideResponse(RequestDelegate next, bool first)
        {
            _next = next;
            this.first = first;
        }

        public Task Invoke(HttpContext httpContext)
        {
            if (AppInit.conf.overrideResponse != null && AppInit.conf.overrideResponse.Count > 0)
            {
                var requestInfo = httpContext.Features.Get<RequestModel>();
                if (requestInfo.IsLocalRequest)
                    return _next(httpContext);

                string url = httpContext.Request.Path.Value + httpContext.Request.QueryString.Value;

                foreach (var over in AppInit.conf.overrideResponse.Where(i => i.firstEndpoint == first))
                {
                    if (Regex.IsMatch(url, over.pattern, RegexOptions.IgnoreCase))
                    {
                        switch (over.action)
                        {
                            case "html":
                                {
                                    httpContext.Response.ContentType = over.type;
                                    return httpContext.Response.WriteAsync(over.val.Replace("{localhost}", AppInit.Host(httpContext)), httpContext.RequestAborted);
                                }
                            case "file":
                                {
                                    httpContext.Response.ContentType = over.type;

                                    if (string.IsNullOrEmpty(over.val) || !File.Exists(over.val))
                                    {                                         
                                        httpContext.Response.StatusCode = 404;
                                        return Task.CompletedTask;
                                    }

                                    if (Regex.IsMatch(over.val, "\\.(html|txt|css|js|json|xml)$", RegexOptions.IgnoreCase))
                                    {
                                        string val = FileCache.ReadAllText(over.val);
                                        return httpContext.Response.WriteAsync(val.Replace("{localhost}", AppInit.Host(httpContext)), httpContext.RequestAborted);
                                    }
                                    else
                                    {
                                        return httpContext.Response.SendFileAsync(over.val);
                                    }
                                }
                            case "redirect":
                                {
                                    httpContext.Response.Redirect(over.val);
                                    return Task.CompletedTask;
                                }
                            case "eval":
                                {
                                    var options = ScriptOptions.Default
                                        .AddReferences(typeof(Console).Assembly).AddImports("System")
                                        .AddReferences(typeof(Regex).Assembly).AddImports("System.Text.RegularExpressions");

                                    bool _next = CSharpEval.BaseExecute<bool>(over.val, new OverrideResponseGlobals(url, httpContext.Request, requestInfo), options);
                                    if (!_next)
                                        return Task.CompletedTask;
                                    break;
                                }
                            default:
                                break;
                        }
                    }
                }
            }

            return _next(httpContext);
        }
    }
}

```

## File: Lampac/Engine/Middlewares/ModHeaders.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class ModHeaders
    {
        private readonly RequestDelegate _next;
        public ModHeaders(RequestDelegate next)
        {
            _next = next;
        }

        public Task Invoke(HttpContext httpContext)
        {
            if (httpContext.Request.Path.Value.StartsWith("/cors/check"))
                return Task.CompletedTask;

            httpContext.Response.Headers["Access-Control-Allow-Credentials"] = "true";
            httpContext.Response.Headers["Access-Control-Allow-Private-Network"] = "true";
            httpContext.Response.Headers["Access-Control-Allow-Methods"] = "POST, GET, OPTIONS";

            string allowHeaders = "Accept, Origin, Content-Type, Authorization, X-Requested-With, X-Signalr-User-Agent, Cache-Control, DNT, If-Modified-Since, Keep-Alive, User-Agent, Token, Profile";
            if (httpContext.Request.Headers.TryGetValue("Access-Control-Request-Headers", out var accessHeaders) && !string.IsNullOrEmpty(accessHeaders.ToString()))
                allowHeaders += ", " + accessHeaders.ToString();

            httpContext.Response.Headers["Access-Control-Allow-Headers"] = allowHeaders;

            if (httpContext.Request.Headers.TryGetValue("origin", out var origin))
                httpContext.Response.Headers["Access-Control-Allow-Origin"] = origin.ToString();
            else if (httpContext.Request.Headers.TryGetValue("referer", out var referer))
                httpContext.Response.Headers["Access-Control-Allow-Origin"] = referer.ToString();
            else
                httpContext.Response.Headers["Access-Control-Allow-Origin"] = "*";

            if (Regex.IsMatch(httpContext.Request.Path.Value, "^/(lampainit|sisi|lite|online|tmdbproxy|cubproxy|tracks|transcoding|dlna|timecode|bookmark|catalog|sync|backup|ts|invc-ws)\\.js") ||
                Regex.IsMatch(httpContext.Request.Path.Value, "^/(on/|(lite|online|sisi|timecode|bookmark|sync|tmdbproxy|dlna|ts|tracks|transcoding|backup|catalog|invc-ws)/js/)"))
            {
                httpContext.Response.Headers["Cache-Control"] = "no-cache, no-store, must-revalidate"; // HTTP 1.1.
                httpContext.Response.Headers["Pragma"] = "no-cache"; // HTTP 1.0.
                httpContext.Response.Headers["Expires"] = "0"; // Proxies.
            }

            if (HttpMethods.IsOptions(httpContext.Request.Method))
                return Task.CompletedTask;

            return _next(httpContext);
        }
    }
}

```

## File: Lampac/Engine/Middlewares/WAF.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Shared;
using Shared.Models;
using Shared.Models.AppConf;
using System;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class WAF
    {
        IMemoryCache memoryCache;
        private readonly RequestDelegate _next;
        public WAF(RequestDelegate next, IMemoryCache mem)
        {
            _next = next;
            memoryCache = mem;
        }

        public Task Invoke(HttpContext httpContext)
        {
            var waf = AppInit.conf.WAF;
            if (!waf.enable)
                return _next(httpContext);

            var requestInfo = httpContext.Features.Get<RequestModel>();
            if (requestInfo.IsLocalRequest || requestInfo.IsAnonymousRequest)
                return _next(httpContext);

            if (waf.whiteIps != null && waf.whiteIps.Contains(requestInfo.IP))
                return _next(httpContext);

            #region country
            if (waf.countryAllow != null)
            {
                // –µ—Å–ª–∏ –º—ã –Ω–µ –∑–Ω–∞–µ–º —Å—Ç—Ä–∞–Ω—É –∏–ª–∏ —Ç–æ—á–Ω–æ –∑–Ω–∞–µ–º, —á—Ç–æ –æ–Ω–∞ –Ω–µ –≤ —Å–ø–∏—Å–∫–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã—Ö
                if (string.IsNullOrEmpty(requestInfo.Country) || !waf.countryAllow.Contains(requestInfo.Country))
                {
                    httpContext.Response.StatusCode = 403;
                    return Task.CompletedTask;
                }
            }

            if (waf.countryDeny != null)
            {
                // —Ç–æ—á–Ω–æ –∑–Ω–∞–µ–º —Å—Ç—Ä–∞–Ω—É –∏ –æ–Ω–∞ –µ—Å—Ç—å –≤ —Å–ø–∏—Å–∫–µ –∑–∞–ø—Ä–µ—â–µ–Ω–Ω—ã—Ö
                if (!string.IsNullOrEmpty(requestInfo.Country) && waf.countryDeny.Contains(requestInfo.Country))
                {
                    httpContext.Response.StatusCode = 403;
                    return Task.CompletedTask;
                }
            }
            #endregion

            #region ips
            if (waf.ipsDeny != null)
            {
                if (waf.ipsDeny.Contains(requestInfo.IP))
                {
                    httpContext.Response.StatusCode = 403;
                    return Task.CompletedTask;
                }

                var clientIPAddress = IPAddress.Parse(requestInfo.IP);
                foreach (string ip in waf.ipsDeny)
                {
                    if (ip.Contains("/"))
                    {
                        string[] parts = ip.Split('/');
                        if (int.TryParse(parts[1], out int prefixLength))
                        {
                            if (new System.Net.IPNetwork(IPAddress.Parse(parts[0]), prefixLength).Contains(clientIPAddress))
                            {
                                httpContext.Response.StatusCode = 403;
                                return Task.CompletedTask;
                            }
                        }
                    }
                }
            }

            if (waf.ipsAllow != null)
            {
                if (!waf.ipsAllow.Contains(requestInfo.IP))
                {
                    bool deny = true;
                    var clientIPAddress = IPAddress.Parse(requestInfo.IP);
                    foreach (string ip in waf.ipsAllow)
                    {
                        if (ip.Contains("/"))
                        {
                            string[] parts = ip.Split('/');
                            if (int.TryParse(parts[1], out int prefixLength))
                            {
                                if (new System.Net.IPNetwork(IPAddress.Parse(parts[0]), prefixLength).Contains(clientIPAddress))
                                {
                                    deny = false;
                                    break;
                                }
                            }
                        }
                    }

                    if (deny)
                    {
                        httpContext.Response.StatusCode = 403;
                        return Task.CompletedTask;
                    }
                }
            }
            #endregion

            #region headers
            if (waf.headersDeny != null)
            {
                foreach (var header in waf.headersDeny)
                {
                    if (httpContext.Request.Headers.TryGetValue(header.Key, out var headerValue) && !string.IsNullOrEmpty(headerValue))
                    {
                        if (Regex.IsMatch(headerValue.ToString(), header.Value, RegexOptions.IgnoreCase))
                        {
                            httpContext.Response.StatusCode = 403;
                            return Task.CompletedTask;
                        }
                    }
                }
            }
            #endregion

            #region limit_req
            var (limit, pattern) = MapLimited(waf, httpContext.Request.Path.Value);
            if (limit > 0)
            {
                if (RateLimited(requestInfo.IP, limit, pattern))
                {
                    httpContext.Response.StatusCode = 429;
                    return Task.CompletedTask;
                }
            }
            #endregion

            return _next(httpContext);
        }


        #region MapLimited
        static (int limit, string pattern) MapLimited(WafConf waf, string path)
        {
            if (waf.limit_map != null)
            {
                foreach (var pathLimit in waf.limit_map)
                {
                    if (Regex.IsMatch(path, pathLimit.Key, RegexOptions.IgnoreCase))
                        return (pathLimit.Value, pathLimit.Key);
                }
            }

            return (waf.limit_req, "default");
        }
        #endregion

        #region RateLimited
        bool RateLimited(string userip, int limit_req, string pattern)
        {
            string memKeyLocIP = $"WAF:RateLimited:{userip}:{pattern}:{DateTime.Now.Minute}";

            if (memoryCache.TryGetValue(memKeyLocIP, out int req))
            {
                if (req >= limit_req)
                    return true;

                memoryCache.Set(memKeyLocIP, req+1, DateTime.Now.AddMinutes(1));
            }
            else
            {
                memoryCache.Set(memKeyLocIP, 1, DateTime.Now.AddMinutes(1));
            }

            return false;
        }
        #endregion
    }
}

```

## File: Lampac/Engine/Middlewares/Accsdb.cs
```
Ôªøusing Shared;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Shared.Models;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Shared.Engine;

namespace Lampac.Engine.Middlewares
{
    public class Accsdb
    {
        static Accsdb() 
        {
            Directory.CreateDirectory("cache/logs/accsdb");
        }

        private readonly RequestDelegate _next;
        IMemoryCache memoryCache;

        public Accsdb(RequestDelegate next, IMemoryCache mem)
        {
            _next = next;
            memoryCache = mem;
        }

        public Task Invoke(HttpContext httpContext)
        {
            var requestInfo = httpContext.Features.Get<RequestModel>();
            if (requestInfo.IsLocalRequest || requestInfo.IsAnonymousRequest)
                return _next(httpContext);

            #region manifest / admin
            if (httpContext.Request.Path.Value.StartsWith("/admin/") || httpContext.Request.Path.Value == "/admin")
            {
                if (httpContext.Request.Cookies.TryGetValue("passwd", out string passwd))
                {
                    if (passwd == AppInit.rootPasswd)
                    {
                        if (httpContext.Request.Path.Value.StartsWith("/admin/auth"))
                            return _next(httpContext);

                        return _next(httpContext);
                    }

                    string ipKey = $"Accsdb:auth:IP:{requestInfo.IP}";
                    if (!memoryCache.TryGetValue(ipKey, out HashSet<string> passwds))
                        passwds = new HashSet<string>();

                    passwds.Add(passwd);
                    memoryCache.Set(ipKey, passwds, DateTime.Today.AddDays(1));

                    if (passwds.Count > 5)
                        return httpContext.Response.WriteAsync("Too many attempts, try again tomorrow.", httpContext.RequestAborted);
                }

                if (httpContext.Request.Path.Value.StartsWith("/admin/auth"))
                    return _next(httpContext);

                httpContext.Response.Redirect("/admin/auth");
                return Task.CompletedTask;
            }
            #endregion

            #region ws / nws
            if (httpContext.Request.Path.Value.StartsWith("/ws") || httpContext.Request.Path.Value.StartsWith("/nws"))
            {
                if (AppInit.conf.weblog.enable || AppInit.conf.rch.enable || AppInit.conf.storage.enable || AppInit.conf.sync_user.enable)
                    return _next(httpContext);

                return httpContext.Response.WriteAsync("disabled", httpContext.RequestAborted);
            }
            #endregion

            #region jacred
            string jacpattern = "^/(api/v2.0/indexers|api/v1.0/|toloka|rutracker|rutor|torrentby|nnmclub|kinozal|bitru|selezen|megapeer|animelayer|anilibria|anifilm|toloka|lostfilm|bigfangroup|mazepa)";

            if (!string.IsNullOrEmpty(AppInit.conf.apikey))
            {
                if (Regex.IsMatch(httpContext.Request.Path.Value, jacpattern))
                {
                    if (AppInit.conf.apikey != httpContext.Request.Query["apikey"])
                        return Task.CompletedTask;
                }
            }
            #endregion

            if (AppInit.conf.accsdb.enable)
            {
                var accsdb = AppInit.conf.accsdb;

                if (httpContext.Request.Path.Value.StartsWith("/testaccsdb") && accsdb.shared_passwd != null && requestInfo.user_uid == accsdb.shared_passwd)
                {
                    requestInfo.IsLocalRequest = true;
                    httpContext.Features.Set(requestInfo);
                    return _next(httpContext);
                }

                if (!string.IsNullOrEmpty(accsdb.premium_pattern) && !Regex.IsMatch(httpContext.Request.Path.Value, accsdb.premium_pattern, RegexOptions.IgnoreCase))
                    return _next(httpContext);

                if (!string.IsNullOrEmpty(accsdb.whitepattern) && Regex.IsMatch(httpContext.Request.Path.Value, accsdb.whitepattern, RegexOptions.IgnoreCase))
                {
                    requestInfo.IsAnonymousRequest = true;
                    httpContext.Features.Set(requestInfo);
                    return _next(httpContext);
                }

                if (Regex.IsMatch(httpContext.Request.Path.Value, jacpattern))
                    return _next(httpContext);

                bool limitip = false;

                var user = requestInfo.user;

                if (requestInfo.user_uid != null && accsdb.white_uids != null && accsdb.white_uids.Contains(requestInfo.user_uid))
                    return _next(httpContext);

                string uri = httpContext.Request.Path.Value + httpContext.Request.QueryString.Value;

                if (user == null || user.ban || DateTime.UtcNow > user.expires || IsLockHostOrUser(requestInfo.user_uid, requestInfo.IP, uri, out limitip))
                {
                    if (httpContext.Request.Path.Value.StartsWith("/proxy/") || httpContext.Request.Path.Value.StartsWith("/proxyimg"))
                    {
                        string hash = Regex.Replace(httpContext.Request.Path.Value, "/(proxy|proxyimg([^/]+)?)/", "");
                        if (AppInit.conf.serverproxy.encrypt || ProxyLink.Decrypt(hash, requestInfo.IP)?.uri != null)
                            return _next(httpContext);
                    }

                    if (uri.StartsWith("/tmdb/api.themoviedb.org/") || uri.StartsWith("/tmdb/api/"))
                    {
                        httpContext.Response.Redirect("https://api.themoviedb.org/" + Regex.Replace(httpContext.Request.Path.Value, "^/tmdb/[^/]+/", ""));
                        return Task.CompletedTask;
                    }

                    if (Regex.IsMatch(httpContext.Request.Path.Value, "\\.(js|css|ico|png|svg|jpe?g|woff|webmanifest)"))
                    {
                        if (uri.StartsWith("/tmdb/image.tmdb.org/") || uri.StartsWith("/tmdb/img/"))
                        {
                            httpContext.Response.Redirect("https://image.tmdb.org/" + Regex.Replace(httpContext.Request.Path.Value, "^/tmdb/[^/]+/", ""));
                            return Task.CompletedTask;
                        }

                        httpContext.Response.StatusCode = 404;
                        httpContext.Response.ContentType = "application/octet-stream";
                        return Task.CompletedTask;
                    }

                    #region msg
                    string msg = limitip ? $"–ü—Ä–µ–≤—ã—à–µ–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ ip/–∑–∞–ø—Ä–æ—Å–æ–≤ –Ω–∞ –∞–∫–∫–∞—É–Ω—Ç."
                        : string.IsNullOrEmpty(requestInfo.user_uid) ? accsdb.authMesage
                        : accsdb.denyMesage.Replace("{account_email}", requestInfo.user_uid).Replace("{user_uid}", requestInfo.user_uid).Replace("{host}", httpContext.Request.Host.Value);

                    if (user != null)
                    {
                        if (user.ban)
                            msg = user.ban_msg ?? "–í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã";

                        else if (DateTime.UtcNow > user.expires)
                            msg = accsdb.expiresMesage.Replace("{account_email}", requestInfo.user_uid).Replace("{user_uid}", requestInfo.user_uid).Replace("{expires}", user.expires.ToString("dd.MM.yyyy"));
                    }
                    #endregion

                    #region denymsg
                    string denymsg = limitip ? $"–ü—Ä–µ–≤—ã—à–µ–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ ip/–∑–∞–ø—Ä–æ—Å–æ–≤ –Ω–∞ –∞–∫–∫–∞—É–Ω—Ç." : null;

                    if (user != null)
                    {
                        if (user.ban)
                            denymsg = user.ban_msg ?? "–í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã";

                        else if (DateTime.UtcNow > user.expires)
                            denymsg = accsdb.expiresMesage.Replace("{account_email}", requestInfo.user_uid).Replace("{user_uid}", requestInfo.user_uid).Replace("{expires}", user.expires.ToString("dd.MM.yyyy"));
                    }
                    #endregion

                    return httpContext.Response.WriteAsJsonAsync(new { accsdb = true, msg, denymsg, user }, httpContext.RequestAborted);
                }
            }

            return _next(httpContext);
        }


        #region IsLock
        static string logsLock = string.Empty;

        bool IsLockHostOrUser(string account_email, string userip, string uri, out bool islock)
        {
            if (string.IsNullOrEmpty(account_email))
            {
                islock = false;
                return islock;
            }

            if (Regex.IsMatch(uri, "^/(proxy/|proxyimg|lifeevents|externalids|sisi/(bookmarks|historys)|(ts|transcoding|dlna|storage|bookmark|tmdb|cub)/|timecode)"))
            {
                islock = false;
                return islock;
            }

            HashSet<string> ips = null;
            HashSet<string> urls = null;

            #region setLogs
            void setLogs(string name)
            {
                string logFile = $"cache/logs/accsdb/{DateTime.Now:dd-MM-yyyy}.lock.txt";
                if (logsLock != string.Empty && !File.Exists(logFile))
                    logsLock = string.Empty;

                string line = $"{name} / {account_email} / {CrypTo.md5(account_email)}.*.log";

                if (!logsLock.Contains(line))
                {
                    logsLock += $"{DateTime.Now}: {line}\n";
                    File.WriteAllText(logFile, logsLock);
                }
            }
            #endregion

            #region countlock_day
            int countlock_day(bool update)
            {
                string key = $"Accsdb:lock_day:{account_email}:{DateTime.Now.Day}";

                if (memoryCache.TryGetValue(key, out HashSet<int> lockhour))
                {
                    if (update)
                    {
                        lockhour.Add(DateTime.Now.Hour);
                        memoryCache.Set(key, lockhour, DateTime.Now.AddDays(1));
                    }

                    return lockhour.Count;
                }
                else if (update)
                {
                    lockhour = new HashSet<int>() { DateTime.Now.Hour };
                    memoryCache.Set(key, lockhour, DateTime.Now.AddDays(1));
                    return lockhour.Count;
                }

                return 0;
            }
            #endregion

            if (IsLockIpHour(account_email, userip, out islock, out ips) | IsLockReqHour(account_email, uri, out islock, out urls))
            {
                setLogs("lock_hour");
                countlock_day(update: true);

                File.WriteAllLines($"cache/logs/accsdb/{CrypTo.md5(account_email)}.ips.log", ips);
                File.WriteAllLines($"cache/logs/accsdb/{CrypTo.md5(account_email)}.urls.log", urls);

                return islock;
            }

            if (countlock_day(update: false) > AppInit.conf.accsdb.maxlock_day)
            {
                if (AppInit.conf.accsdb.blocked_hour != -1)
                    memoryCache.Set($"Accsdb:blocked_hour:{account_email}", 0, DateTime.Now.AddHours(AppInit.conf.accsdb.blocked_hour));

                setLogs("lock_day");
                islock = true;
                return islock;
            }

            if (memoryCache.TryGetValue($"Accsdb:blocked_hour:{account_email}", out _))
            {
                setLogs("blocked");
                islock = true;
                return islock;
            }

            islock = false;
            return islock;
        }


        bool IsLockIpHour(string account_email, string userip, out bool islock, out HashSet<string> ips)
        {
            string memKeyLocIP = $"Accsdb:IsLockIpHour:{account_email}:{DateTime.Now.Hour}";

            if (memoryCache.TryGetValue(memKeyLocIP, out ips))
            {
                ips.Add(userip);
                memoryCache.Set(memKeyLocIP, ips, DateTime.Now.AddHours(1));

                if (ips.Count > AppInit.conf.accsdb.maxip_hour)
                {
                    islock = true;
                    return islock;
                }
            }
            else
            {
                ips = new HashSet<string>() { userip };
                memoryCache.Set(memKeyLocIP, ips, DateTime.Now.AddHours(1));
            }

            islock = false;
            return islock;
        }

        bool IsLockReqHour(string account_email, string uri, out bool islock, out HashSet<string> urls)
        {
            string memKeyLocIP = $"Accsdb:IsLockReqHour:{account_email}:{DateTime.Now.Hour}";

            if (memoryCache.TryGetValue(memKeyLocIP, out urls))
            {
                urls.Add(uri);
                memoryCache.Set(memKeyLocIP, urls, DateTime.Now.AddHours(1));

                if (urls.Count > AppInit.conf.accsdb.maxrequest_hour)
                {
                    islock = true;
                    return islock;
                }
            }
            else
            {
                urls = new HashSet<string>() { uri };
                memoryCache.Set(memKeyLocIP, urls, DateTime.Now.AddHours(1));
            }

            islock = false;
            return islock;
        }
        #endregion
    }
}

```

## File: Lampac/Engine/Middlewares/Module.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Events;
using Shared.Models.Module.Entrys;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class Module
    {
        private readonly RequestDelegate _next;
        IMemoryCache memoryCache;
        private readonly bool first;

        public Module(RequestDelegate next, IMemoryCache mem, bool first)
        {
            _next = next;
            memoryCache = mem;
            this.first = first;
        }

        async public Task InvokeAsync(HttpContext httpContext)
        {
            #region modules
            MiddlewaresModuleEntry.EnsureCache();

            if (MiddlewaresModuleEntry.middlewareModulesCache != null && MiddlewaresModuleEntry.middlewareModulesCache.Count > 0)
            {
                foreach (var entry in MiddlewaresModuleEntry.middlewareModulesCache)
                {
                    var mod = entry.mod;

                    try
                    {
                        if (first && (mod.version == 0 || mod.version == 1))
                            continue;

                        if (mod.version >= 2)
                        {
                            if (entry.Invoke != null)
                            {
                                bool next = entry.Invoke(first, httpContext, memoryCache);
                                if (!next)
                                    return;
                            }

                            if (entry.InvokeAsync != null)
                            {
                                bool next = await entry.InvokeAsync(first, httpContext, memoryCache);
                                if (!next)
                                    return;
                            }
                        }
                        else
                        {
                            if (entry.InvokeV1 != null)
                            {
                                bool next = entry.InvokeV1(httpContext, memoryCache);
                                if (!next)
                                    return;
                            }

                            if (entry.InvokeAsyncV1 != null)
                            {
                                bool next = await entry.InvokeAsyncV1(httpContext, memoryCache);
                                if (!next)
                                    return;
                            }
                        }
                    }
                    catch { }
                }
            }
            #endregion 

            if ((first && InvkEvent.conf?.Middleware?.first != null) || (!first && InvkEvent.conf?.Middleware?.end != null))
            {
                var rqinfo = httpContext.Features.Get<RequestModel>();
                bool next = await InvkEvent.Middleware(first, new EventMiddleware(rqinfo, httpContext.Request, httpContext, new HybridCache(), memoryCache));
                if (!next)
                    return;
            }

            await _next(httpContext);
        }
    }
}

```

## File: Lampac/Engine/Middlewares/ProxyTmdb.cs
```
Ôªøusing DnsClient;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using NetVips;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Models;
using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class ProxyTmdb
    {
        #region ProxyTmdb
        static FileSystemWatcher fileWatcher;

        static ConcurrentDictionary<string, byte> cacheFiles = new ConcurrentDictionary<string, byte>();

        static Timer cleanupTimer;

        static ProxyTmdb()
        {
            if (AppInit.conf.multiaccess == false)
                return;

            Directory.CreateDirectory("cache/tmdb");

            foreach (var item in Directory.EnumerateFiles("cache/tmdb", "*"))
                cacheFiles.TryAdd(Path.GetFileName(item), 0);

            fileWatcher = new FileSystemWatcher
            {
                Path = "cache/tmdb",
                NotifyFilter = NotifyFilters.FileName,
                EnableRaisingEvents = true
            };

            fileWatcher.Created += (s, e) => { cacheFiles.TryAdd(e.Name, 0); };
            fileWatcher.Deleted += (s, e) => { cacheFiles.TryRemove(e.Name, out _); };

            cleanupTimer = new Timer(cleanup, null, TimeSpan.FromMinutes(60), TimeSpan.FromMinutes(60));
        }

        static void cleanup(object state)
        {
            try
            {
                var files = Directory.GetFiles("cache/tmdb", "*").Select(f => Path.GetFileName(f)).ToHashSet();

                foreach (string md5fileName in cacheFiles.Keys.ToArray())
                {
                    if (!files.Contains(md5fileName))
                        cacheFiles.TryRemove(md5fileName, out _);
                }
            }
            catch { }
        }

        public ProxyTmdb(RequestDelegate next) { }
        #endregion

        public Task Invoke(HttpContext httpContext)
        {
            var hybridCache = new HybridCache();
            var requestInfo = httpContext.Features.Get<RequestModel>();

            if (httpContext.Request.Path.Value.StartsWith("/tmdb/api/"))
                return API(httpContext, hybridCache, requestInfo);

            if (httpContext.Request.Path.Value.StartsWith("/tmdb/img/"))
                return IMG(httpContext, requestInfo);

            string path = Regex.Replace(httpContext.Request.Path.Value, "^/tmdb/https?://", "").Replace("/tmdb/", "");
            string uri = Regex.Match(path, "^[^/]+/(.*)").Groups[1].Value + httpContext.Request.QueryString.Value;

            if (path.Contains("api.themoviedb.org"))
            {
                httpContext.Request.Path = $"/tmdb/api/{uri}";
                return API(httpContext, hybridCache, requestInfo);
            }
            else if (path.Contains("image.tmdb.org"))
            {
                httpContext.Request.Path = $"/tmdb/img/{uri}";
                return IMG(httpContext, requestInfo);
            }

            httpContext.Response.StatusCode = 403;
            return Task.CompletedTask;
        }


        #region API
        async public Task API(HttpContext httpContex, HybridCache hybridCache, RequestModel requestInfo)
        {
            using (var ctsHttp = CancellationTokenSource.CreateLinkedTokenSource(httpContex.RequestAborted))
            {
                ctsHttp.CancelAfter(TimeSpan.FromSeconds(90));
                httpContex.Response.ContentType = "application/json; charset=utf-8";

                var init = AppInit.conf.tmdb;
                if (!init.enable && !requestInfo.IsLocalRequest)
                {
                    httpContex.Response.StatusCode = 401;
                    await httpContex.Response.WriteAsJsonAsync(new { error = true, msg = "disable" }, ctsHttp.Token);
                    return;
                }

                string path = httpContex.Request.Path.Value.Replace("/tmdb/api", "");
                path = Regex.Replace(path, "^/https?://api.themoviedb.org", "");
                path = Regex.Replace(path, "/$", "");

                string query = Regex.Replace(httpContex.Request.QueryString.Value, "(&|\\?)(account_email|email|uid|token)=[^&]+", "");
                string uri = "https://api.themoviedb.org" + path + query;

                string mkey = $"tmdb/api:{path}:{query}";

                if (hybridCache.TryGetValue(mkey, out (string json, int statusCode) cache, inmemory: false))
                {
                    httpContex.Response.Headers["X-Cache-Status"] = "HIT";
                    httpContex.Response.StatusCode = cache.statusCode;
                    httpContex.Response.ContentType = "application/json; charset=utf-8";
                    await httpContex.Response.WriteAsync(cache.json, ctsHttp.Token);
                    return;
                }

                httpContex.Response.Headers["X-Cache-Status"] = "MISS";

                string tmdb_ip = init.API_IP;

                #region DNS QueryType.A
                if (string.IsNullOrEmpty(tmdb_ip) && string.IsNullOrEmpty(init.API_Minor) && !string.IsNullOrEmpty(init.DNS))
                {
                    string dnskey = $"tmdb/api:dns:{init.DNS}";

                    var _spredns = new SemaphorManager(dnskey, TimeSpan.FromMinutes(1));

                    try
                    {
                        await _spredns.WaitAsync();

                        if (!Startup.memoryCache.TryGetValue(dnskey, out string dns_ip))
                        {
                            using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(50)))
                            {
                                var lookup = new LookupClient(IPAddress.Parse(init.DNS));
                                var queryType = await lookup.QueryAsync("api.themoviedb.org", QueryType.A, cancellationToken: cts.Token);
                                dns_ip = queryType?.Answers?.ARecords()?.FirstOrDefault()?.Address?.ToString();

                                if (!string.IsNullOrEmpty(dns_ip))
                                    Startup.memoryCache.Set(dnskey, dns_ip, DateTime.Now.AddMinutes(Math.Max(init.DNS_TTL, 5)));
                                else
                                    Startup.memoryCache.Set(dnskey, string.Empty, DateTime.Now.AddMinutes(5));
                            }
                        }

                        if (!string.IsNullOrEmpty(dns_ip))
                            tmdb_ip = dns_ip;
                    }
                    catch { }
                    finally
                    {
                        _spredns.Release();
                    }
                }
                #endregion

                var headers = new List<HeadersModel>();
                var proxyManager = new ProxyManager("tmdb_api", init);

                if (!string.IsNullOrEmpty(init.API_Minor))
                {
                    uri = uri.Replace("api.themoviedb.org", init.API_Minor);
                }
                else if (!string.IsNullOrEmpty(tmdb_ip))
                {
                    headers.Add(new HeadersModel("Host", "api.themoviedb.org"));
                    uri = uri.Replace("api.themoviedb.org", tmdb_ip);
                }

                var result = await Http.BaseGetAsync<JObject>(uri, timeoutSeconds: 20, proxy: proxyManager.Get(), httpversion: init.httpversion, headers: headers, statusCodeOK: false);
                if (result.content == null)
                {
                    proxyManager.Refresh();
                    httpContex.Response.StatusCode = 401;
                    await httpContex.Response.WriteAsJsonAsync(new { error = true, msg = "json null" }, ctsHttp.Token);
                    return;
                }

                cache.statusCode = (int)result.response.StatusCode;
                httpContex.Response.StatusCode = cache.statusCode;

                if (result.content.ContainsKey("status_message") || result.response.StatusCode != HttpStatusCode.OK)
                {
                    proxyManager.Refresh();
                    cache.json = JsonConvert.SerializeObject(result.content);

                    if (init.cache_api > 0 && !string.IsNullOrEmpty(cache.json))
                        hybridCache.Set(mkey, cache, DateTime.Now.AddMinutes(1), inmemory: true);

                    await httpContex.Response.WriteAsync(cache.json, ctsHttp.Token);
                    return;
                }

                cache.json = JsonConvert.SerializeObject(result.content);

                if (init.cache_api > 0 && !string.IsNullOrEmpty(cache.json))
                    hybridCache.Set(mkey, cache, DateTime.Now.AddMinutes(init.cache_api), inmemory: false);

                proxyManager.Success();
                httpContex.Response.ContentType = "application/json; charset=utf-8";
                await httpContex.Response.WriteAsync(cache.json, ctsHttp.Token);
            }
        }
        #endregion

        #region IMG
        async public Task IMG(HttpContext httpContex, RequestModel requestInfo)
        {
            using (var ctsHttp = CancellationTokenSource.CreateLinkedTokenSource(httpContex.RequestAborted))
            {
                ctsHttp.CancelAfter(TimeSpan.FromSeconds(90));

                var init = AppInit.conf.tmdb;
                if (!init.enable)
                {
                    httpContex.Response.StatusCode = 401;
                    await httpContex.Response.WriteAsJsonAsync(new { error = true, msg = "disable" }, ctsHttp.Token);
                    return;
                }

                string path = httpContex.Request.Path.Value.Replace("/tmdb/img", "");
                path = Regex.Replace(path, "^/https?://image.tmdb.org", "");

                string query = Regex.Replace(httpContex.Request.QueryString.Value, "(&|\\?)(account_email|email|uid|token)=[^&]+", "");
                string uri = "https://image.tmdb.org" + path + query;

                string md5key = CrypTo.md5($"{path}:{query}");
                string outFile = Path.Combine("cache", "tmdb", md5key);

                httpContex.Response.ContentType = path.Contains(".png") ? "image/png" : path.Contains(".svg") ? "image/svg+xml" : "image/jpeg";

                if (cacheFiles.ContainsKey(md5key) || (AppInit.conf.multiaccess == false && File.Exists(outFile)))
                {
                    httpContex.Response.Headers["X-Cache-Status"] = "HIT";
                    await httpContex.Response.SendFileAsync(outFile);
                    return;
                }

                string tmdb_ip = init.IMG_IP;

                #region DNS QueryType.A
                if (string.IsNullOrEmpty(tmdb_ip) && string.IsNullOrEmpty(init.IMG_Minor) && !string.IsNullOrEmpty(init.DNS))
                {
                    string dnskey = $"tmdb/img:dns:{init.DNS}";

                    var _spredns = new SemaphorManager(dnskey, TimeSpan.FromMinutes(1));

                    try
                    {
                        await _spredns.WaitAsync();

                        if (!Startup.memoryCache.TryGetValue(dnskey, out string dns_ip))
                        {
                            using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(50)))
                            {
                                var lookup = new LookupClient(IPAddress.Parse(init.DNS));
                                var result = await lookup.QueryAsync("image.tmdb.org", QueryType.A);
                                dns_ip = result?.Answers?.ARecords()?.FirstOrDefault()?.Address?.ToString();

                                if (!string.IsNullOrEmpty(dns_ip))
                                    Startup.memoryCache.Set(dnskey, dns_ip, DateTime.Now.AddMinutes(Math.Max(init.DNS_TTL, 5)));
                                else
                                    Startup.memoryCache.Set(dnskey, string.Empty, DateTime.Now.AddMinutes(5));
                            }
                        }

                        if (!string.IsNullOrEmpty(dns_ip))
                            tmdb_ip = dns_ip;
                    }
                    catch { }
                    finally
                    {
                        _spredns.Release();
                    }
                }
                #endregion

                #region headers
                var headers = new List<HeadersModel>()
                {
                    // –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ä—ã–π ua —á—Ç–æ-–±—ã –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å image/jpeg –≤–º–µ—Å—Ç–æ image/webp
                    new HeadersModel("Accept", "image/jpeg,image/png,image/*;q=0.8,*/*;q=0.5"),
                    new HeadersModel("User-Agent", "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2"),
                    new HeadersModel("Cache-Control", "max-age=0")
                };

                if (!string.IsNullOrEmpty(init.IMG_Minor))
                {
                    uri = uri.Replace("image.tmdb.org", init.IMG_Minor);
                }
                else if (!string.IsNullOrEmpty(tmdb_ip))
                {
                    headers.Add(new HeadersModel("Host", "image.tmdb.org"));
                    uri = uri.Replace("image.tmdb.org", tmdb_ip);
                }
                #endregion

                var proxyManager = new ProxyManager("tmdb_img", init);

                bool cacheimg = init.cache_img > 0 && AppInit.conf.mikrotik == false;
                var semaphore = cacheimg ? new SemaphorManager(uri, TimeSpan.FromMinutes(1)) : null;

                try
                {
                    if (semaphore != null)
                        await semaphore.WaitAsync();

                    if (cacheFiles.ContainsKey(md5key) || (AppInit.conf.multiaccess == false && File.Exists(outFile)))
                    {
                        httpContex.Response.Headers["X-Cache-Status"] = "HIT";
                        await httpContex.Response.SendFileAsync(outFile);
                        return;
                    }

                    var handler = Http.Handler(uri, proxyManager.Get());

                    var client = FrendlyHttp.HttpMessageClient(init.httpversion == 2 ? "http2proxyimg" : "proxyimg", handler);

                    var req = new HttpRequestMessage(HttpMethod.Get, uri)
                    {
                        Version = init.httpversion == 1 ? HttpVersion.Version11 : new Version(init.httpversion, 0)
                    };

                    Http.DefaultRequestHeaders(uri, req, null, null, headers);

                    using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(20)))
                    {
                        using (HttpResponseMessage response = await client.SendAsync(req, cts.Token))
                        {
                            if (response.StatusCode == HttpStatusCode.OK)
                                proxyManager.Success();
                            else
                                proxyManager.Refresh();

                            if (response.StatusCode == HttpStatusCode.OK && cacheimg)
                            {
                                #region cache
                                httpContex.Response.Headers["X-Cache-Status"] = "MISS";

                                int initialCapacity = response.Content.Headers.ContentLength.HasValue ?
                                    (int)response.Content.Headers.ContentLength.Value :
                                    50_000; // 50kB

                                using (var memoryStream = new MemoryStream(initialCapacity))
                                {
                                    try
                                    {
                                        bool saveCache = true;

                                        using (var responseStream = await response.Content.ReadAsStreamAsync())
                                        {
                                            byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);

                                            try
                                            {
                                                int bytesRead;

                                                while ((bytesRead = await responseStream.ReadAsync(buffer, ctsHttp.Token)) > 0)
                                                {
                                                    memoryStream.Write(buffer, 0, bytesRead);
                                                    await httpContex.Response.Body.WriteAsync(buffer, 0, bytesRead, ctsHttp.Token);
                                                }
                                            }
                                            catch
                                            {
                                                saveCache = false;
                                            }
                                            finally
                                            {
                                                ArrayPool<byte>.Shared.Return(buffer);
                                            }
                                        }

                                        if (saveCache && memoryStream.Length > 1000)
                                        {
                                            try
                                            {
                                                if (cacheFiles.ContainsKey(md5key) == false || (AppInit.conf.multiaccess == false && File.Exists(outFile) == false))
                                                {
                                                    #region check_img
                                                    if (init.check_img && !path.Contains(".svg"))
                                                    {
                                                        using (var image = Image.NewFromBuffer(memoryStream.ToArray()))
                                                        {
                                                            try
                                                            {
                                                                // —Ç–µ—Å—Ç–∏—Ä—É–µ–º jpg/png –Ω–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å
                                                                byte[] temp = image.JpegsaveBuffer();
                                                                if (temp == null || temp.Length == 0)
                                                                    return;
                                                            }
                                                            catch
                                                            {
                                                                return;
                                                            }
                                                        }
                                                    }
                                                    #endregion

                                                    File.WriteAllBytes(outFile, memoryStream.ToArray());

                                                    if (AppInit.conf.multiaccess)
                                                        cacheFiles.TryAdd(md5key, 0);
                                                }
                                            }
                                            catch { File.Delete(outFile); }
                                        }
                                    }
                                    catch { }
                                }
                                #endregion
                            }
                            else
                            {
                                httpContex.Response.StatusCode = (int)response.StatusCode;
                                httpContex.Response.Headers["X-Cache-Status"] = "bypass";
                                await response.Content.CopyToAsync(httpContex.Response.Body, ctsHttp.Token);
                            }
                        }
                    }
                }
                catch
                {
                    proxyManager.Refresh();

                    if (!string.IsNullOrEmpty(tmdb_ip))
                        httpContex.Response.Redirect(uri.Replace(tmdb_ip, "image.tmdb.org"));
                    else
                        httpContex.Response.Redirect(uri);
                }
                finally
                {
                    if (semaphore != null)
                        semaphore.Release();
                }
            }
        }
        #endregion
    }
}

```

## File: Lampac/Engine/Middlewares/RequestStatistics.cs
```
using Microsoft.AspNetCore.Http;
using Shared;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class RequestStatistics
    {
        private readonly RequestDelegate _next;

        public RequestStatistics(RequestDelegate next)
        {
            _next = next;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            bool trackStats = !(context.Request.Path.StartsWithSegments("/ws") || context.Request.Path.StartsWithSegments("/nws"));
            Stopwatch stopwatch = null;

            if (trackStats && AppInit.conf.openstat.enable)
                stopwatch = RequestStatisticsTracker.StartRequest();

            try
            {
                await _next(context);
            }
            finally
            {
                if (trackStats && AppInit.conf.openstat.enable)
                    RequestStatisticsTracker.CompleteRequest(stopwatch);
            }
        }
    }

    public static class RequestStatisticsTracker
    {
        static int activeHttpRequests;
        static readonly ConcurrentQueue<(DateTime timestamp, double durationMs)> ResponseTimes = new();

        public static int ActiveHttpRequests => Volatile.Read(ref activeHttpRequests);

        internal static Stopwatch StartRequest()
        {
            Interlocked.Increment(ref activeHttpRequests);
            return Stopwatch.StartNew();
        }

        internal static void CompleteRequest(Stopwatch stopwatch)
        {
            if (stopwatch == null)
                return;

            stopwatch.Stop();
            AddResponseTime(stopwatch.Elapsed.TotalMilliseconds);
            Interlocked.Decrement(ref activeHttpRequests);
        }

        static void AddResponseTime(double durationMs)
        {
            var now = DateTime.UtcNow;
            ResponseTimes.Enqueue((now, durationMs));
            CleanupResponseTimes(now);
        }

        static void CleanupResponseTimes(DateTime now)
        {
            while (ResponseTimes.TryPeek(out var oldest) && (now - oldest.timestamp).TotalSeconds > 60)
                ResponseTimes.TryDequeue(out _);
        }

        public static ResponseTimeStatistics GetResponseTimeStatsLastMinute()
        {
            var now = DateTime.UtcNow;
            CleanupResponseTimes(now);

            double sum = 0;
            int count = 0;
            var durations = new List<double>(ResponseTimes.Count);

            foreach (var item in ResponseTimes)
            {
                sum += item.durationMs;
                count++;
                durations.Add(item.durationMs);
            }

            if (count == 0)
            {
                return new ResponseTimeStatistics
                {
                    Average = 0,
                    PercentileAverages = InitializePercentileDictionary()
                };
            }

            durations.Sort();

            return new ResponseTimeStatistics
            {
                Average = sum / count,
                PercentileAverages = CalculatePercentileAverages(durations)
            };
        }

        static Dictionary<int, double> CalculatePercentileAverages(List<double> sortedDurations)
        {
            const int bucketCount = 10;
            var result = InitializePercentileDictionary();

            int total = sortedDurations.Count;
            int baseSize = total / bucketCount;
            int remainder = total % bucketCount;
            int currentIndex = 0;

            for (int i = 1; i <= bucketCount; i++)
            {
                int key = i * 10;
                int bucketSize = baseSize + (i <= remainder ? 1 : 0);

                if (bucketSize > 0)
                {
                    result[key] = AverageRange(sortedDurations, currentIndex, bucketSize);
                    currentIndex += bucketSize;
                }
            }

            return result;
        }

        static Dictionary<int, double> InitializePercentileDictionary()
        {
            var dict = new Dictionary<int, double>();
            for (int i = 1; i <= 10; i++)
                dict[i * 10] = 0;

            return dict;
        }

        static double AverageRange(List<double> sortedDurations, int startIndex, int length)
        {
            if (length <= 0)
                return 0;

            double total = 0;
            for (int i = 0; i < length; i++)
                total += sortedDurations[startIndex + i];

            return total / length;
        }

        public class ResponseTimeStatistics
        {
            public double Average { get; set; }

            public Dictionary<int, double> PercentileAverages { get; set; } = new();
        }
    }
}

```

## File: Lampac/Engine/Middlewares/AlwaysRjson.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Http.Extensions;
using Microsoft.AspNetCore.WebUtilities;
using Microsoft.Extensions.Primitives;
using Shared;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class AlwaysRjson
    {
        private readonly RequestDelegate _next;

        public AlwaysRjson(RequestDelegate next)
        {
            _next = next;
        }

        public Task Invoke(HttpContext context)
        {
            if (!AppInit.conf.always_rjson)
                return _next(context);

            var query = QueryHelpers.ParseQuery(context.Request.QueryString.HasValue ? context.Request.QueryString.Value : string.Empty);

            if (!RequiresRewrite(query))
                return _next(context);

            var builder = new QueryBuilder();

            foreach (var kv in query)
            {
                if (string.Equals(kv.Key, "rjson", StringComparison.OrdinalIgnoreCase))
                    continue;

                foreach (var value in kv.Value)
                    builder.Add(kv.Key, value);
            }

            builder.Add("rjson", "true");

            context.Request.QueryString = builder.ToQueryString();

            return _next(context);
        }

        static bool RequiresRewrite(IDictionary<string, StringValues> query)
        {
            if (!query.TryGetValue("rjson", out var value))
                return true;

            for (int i = 0; i < value.Count; i++)
            {
                if (string.Equals(value[i], "true", StringComparison.OrdinalIgnoreCase))
                    return false;
            }

            return true;
        }
    }
}

```

## File: Lampac/Engine/Middlewares/ProxyImg.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Shared;
using Shared.Engine;
using Shared.Models;
using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class ProxyImg
    {
        #region ProxyImg
        static FileSystemWatcher fileWatcher;

        static ConcurrentDictionary<string, long> cacheFiles = new ConcurrentDictionary<string, long>();

        static Timer cleanupTimer;

        static ProxyImg()
        {
            if (AppInit.conf.multiaccess == false)
                return;

            Directory.CreateDirectory("cache/img");

            foreach (var item in Directory.EnumerateFiles("cache/img", "*"))
                cacheFiles.TryAdd(Path.GetFileName(item), new FileInfo(item).Length);

            fileWatcher = new FileSystemWatcher
            {
                Path = "cache/img",
                NotifyFilter = NotifyFilters.FileName,
                EnableRaisingEvents = true
            };

            //fileWatcher.Created += (s, e) => 
            //{ 
            //    cacheFiles.TryAdd(e.Name, 0); 
            //};

            fileWatcher.Deleted += (s, e) => { cacheFiles.TryRemove(e.Name, out _); };

            cleanupTimer = new Timer(cleanup, null, TimeSpan.FromMinutes(60), TimeSpan.FromMinutes(60));
        }

        static void cleanup(object state)
        {
            try
            {
                var files = Directory.GetFiles("cache/img", "*").Select(f => Path.GetFileName(f)).ToHashSet();

                foreach (string md5fileName in cacheFiles.Keys.ToArray())
                {
                    if (!files.Contains(md5fileName))
                        cacheFiles.TryRemove(md5fileName, out _);
                }
            }
            catch { }
        }

        public ProxyImg(RequestDelegate next) { }
        #endregion

        async public Task InvokeAsync(HttpContext httpContext, IMemoryCache memoryCache)
        {
            using (var ctsHttp = CancellationTokenSource.CreateLinkedTokenSource(httpContext.RequestAborted))
            {
                ctsHttp.CancelAfter(TimeSpan.FromSeconds(90));

                var requestInfo = httpContext.Features.Get<RequestModel>();

                var init = AppInit.conf.serverproxy.image;
                bool cacheimg = init.cache && AppInit.conf.mikrotik == false;

                string servPath = Regex.Replace(httpContext.Request.Path.Value, "/proxyimg([^/]+)?/", "");
                string href = servPath + httpContext.Request.QueryString.Value;

                #region –ü—Ä–æ–≤–µ—Ä–∫–∏
                if (servPath.Contains("image.tmdb.org"))
                {
                    httpContext.Response.Redirect($"/tmdb/img/{Regex.Replace(href.Replace("://", ":/_/").Replace("//", "/").Replace(":/_/", "://"), "^https?://[^/]+/", "")}");
                    return;
                }

                var decryptLink = ProxyLink.Decrypt(servPath, requestInfo.IP);

                if (AppInit.conf.serverproxy.encrypt || decryptLink?.uri != null)
                {
                    href = decryptLink?.uri;
                }
                else
                {
                    if (!AppInit.conf.serverproxy.enable)
                    {
                        httpContext.Response.StatusCode = 403;
                        return;
                    }
                }

                if (string.IsNullOrWhiteSpace(href) || !href.StartsWith("http"))
                {
                    httpContext.Response.StatusCode = 404;
                    return;
                }
                #endregion

                if (AppInit.conf.serverproxy.showOrigUri)
                    httpContext.Response.Headers["PX-Orig"] = href;

                #region width / height
                int width = 0;
                int height = 0;

                if (httpContext.Request.Path.Value.StartsWith("/proxyimg:"))
                {
                    if (!cacheimg)
                        cacheimg = init.cache_rsize;

                    var gimg = Regex.Match(httpContext.Request.Path.Value, "/proxyimg:([0-9]+):([0-9]+)").Groups;
                    width = int.Parse(gimg[1].Value);
                    height = int.Parse(gimg[2].Value);
                }
                #endregion

                string md5key = CrypTo.md5($"{href}:{width}:{height}");
                string outFile = Path.Combine("cache", "img", md5key);

                string url_reserve = null;
                if (href.Contains(" or "))
                {
                    var urls = href.Split(" or ");
                    href = urls[0];
                    url_reserve = urls[1];
                }

                string contentType = href.Contains(".png") ? "image/png" : href.Contains(".webp") ? "image/webp" : "image/jpeg";
                if (width > 0 || height > 0)
                    contentType = href.Contains(".png") ? "image/png" : "image/jpeg";

                #region cacheFiles
                if (cacheFiles.ContainsKey(md5key) || (AppInit.conf.multiaccess == false && File.Exists(outFile)))
                {
                    httpContext.Response.Headers["X-Cache-Status"] = "HIT";
                    httpContext.Response.ContentType = contentType;

                    if (AppInit.conf.serverproxy.responseContentLength && cacheFiles.ContainsKey(md5key))
                        httpContext.Response.ContentLength = cacheFiles[md5key];

                    await httpContext.Response.SendFileAsync(outFile);
                    return;
                }
                #endregion

                var semaphore = cacheimg ?  new SemaphorManager(href, TimeSpan.FromMinutes(1)) : null;

                try
                {
                    string memKeyErrorDownload = $"ProxyImg:ErrorDownload:{href}";
                    if (memoryCache.TryGetValue(memKeyErrorDownload, out _))
                    {
                        httpContext.Response.Redirect(href);
                        return;
                    }

                    if (semaphore != null)
                        await semaphore.WaitAsync();

                    #region cacheFiles
                    if (cacheFiles.ContainsKey(md5key) || (AppInit.conf.multiaccess == false && File.Exists(outFile)))
                    {
                        httpContext.Response.Headers["X-Cache-Status"] = "HIT";
                        httpContext.Response.ContentType = contentType;

                        if (AppInit.conf.serverproxy.responseContentLength && cacheFiles.ContainsKey(md5key))
                            httpContext.Response.ContentLength = cacheFiles[md5key];

                        await httpContext.Response.SendFileAsync(outFile);
                        return;
                    }
                    #endregion

                    httpContext.Response.Headers["X-Cache-Status"] = cacheimg ? "MISS" : "bypass";

                    var proxyManager = decryptLink?.plugin == "posterapi" ? new ProxyManager("posterapi", AppInit.conf.posterApi) : new ProxyManager("proxyimg", init);
                    var proxy = proxyManager.Get();

                    if (width == 0 && height == 0)
                    {
                        #region bypass
                        bypass_reset:
                        var handler = Http.Handler(href, proxy);

                        var client = FrendlyHttp.HttpMessageClient("proxyimg", handler);

                        var req = new HttpRequestMessage(HttpMethod.Get, href)
                        {
                            Version = HttpVersion.Version11
                        };

                        Http.DefaultRequestHeaders(href, req, null, null, decryptLink?.headers);

                        using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(15)))
                        {
                            using (HttpResponseMessage response = await client.SendAsync(req, cts.Token))
                            {
                                if (response.StatusCode != HttpStatusCode.OK)
                                {
                                    if (url_reserve != null)
                                    {
                                        href = url_reserve;
                                        url_reserve = null;
                                        goto bypass_reset;
                                    }

                                    if (cacheimg)
                                        memoryCache.Set(memKeyErrorDownload, 0, DateTime.Now.AddSeconds(5));

                                    proxyManager.Refresh();
                                    httpContext.Response.Redirect(href);
                                    return;
                                }

                                httpContext.Response.StatusCode = (int)response.StatusCode;

                                if (response.Content.Headers.TryGetValues("Content-Type", out var contype))
                                    httpContext.Response.ContentType = contype?.FirstOrDefault() ?? contentType;
                                else
                                    httpContext.Response.ContentType = contentType;

                                if (AppInit.conf.serverproxy.responseContentLength && response.Content.Headers.ContentLength.HasValue)
                                    httpContext.Response.ContentLength = response.Content.Headers.ContentLength.Value;

                                if (cacheimg)
                                {
                                    int initialCapacity = response.Content.Headers.ContentLength.HasValue ?
                                        (int)response.Content.Headers.ContentLength.Value :
                                        50_000; // 50kB

                                    using (var memoryStream = new MemoryStream(initialCapacity))
                                    {
                                        try
                                        {
                                            bool saveCache = true;

                                            using (var responseStream = await response.Content.ReadAsStreamAsync())
                                            {
                                                byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);

                                                try
                                                {
                                                    int bytesRead;

                                                    while ((bytesRead = await responseStream.ReadAsync(buffer, ctsHttp.Token)) > 0)
                                                    {
                                                        memoryStream.Write(buffer, 0, bytesRead);
                                                        await httpContext.Response.Body.WriteAsync(buffer, 0, bytesRead, ctsHttp.Token);
                                                    }
                                                }
                                                catch
                                                {
                                                    saveCache = false;
                                                }
                                                finally
                                                {
                                                    ArrayPool<byte>.Shared.Return(buffer);
                                                }
                                            }

                                            if (saveCache && memoryStream.Length > 1000)
                                            {
                                                if (!response.Content.Headers.ContentLength.HasValue || response.Content.Headers.ContentLength.Value == memoryStream.Length)
                                                {
                                                    try
                                                    {
                                                        if (cacheFiles.ContainsKey(md5key) == false || (AppInit.conf.multiaccess == false && File.Exists(outFile) == false))
                                                        {
                                                            File.WriteAllBytes(outFile, memoryStream.ToArray());

                                                            if (AppInit.conf.multiaccess)
                                                                cacheFiles.TryAdd(md5key, memoryStream.Length);
                                                        }
                                                    }
                                                    catch { File.Delete(outFile); }
                                                }
                                            }
                                        }
                                        catch { }
                                    }
                                }
                                else
                                {
                                    await response.Content.CopyToAsync(httpContext.Response.Body, ctsHttp.Token);
                                }
                            }
                        }
                        #endregion
                    }
                    else
                    {
                        #region rsize
                        rsize_reset:
                        var array = await Download(href, proxy: proxy, headers: decryptLink?.headers);
                        if (array == null || 1000 > array.Length)
                        {
                            if (url_reserve != null)
                            {
                                href = url_reserve;
                                url_reserve = null;
                                goto rsize_reset;
                            }

                            if (cacheimg)
                                memoryCache.Set(memKeyErrorDownload, 0, DateTime.Now.AddSeconds(5));

                            proxyManager.Refresh();
                            httpContext.Response.Redirect(href);
                            return;
                        }

                        if (AppInit.conf.imagelibrary == "NetVips")
                        {
                            array = NetVipsImage(href, array, width, height);
                        }
                        else if (AppInit.conf.imagelibrary == "ImageMagick" && RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                        {
                            array = ImageMagick(array, width, height, cacheimg ? outFile : null);
                        }

                        if (cacheimg)
                        {
                            try
                            {
                                if (cacheFiles.ContainsKey(md5key) == false || (AppInit.conf.multiaccess == false && File.Exists(outFile) == false))
                                {
                                    File.WriteAllBytes(outFile, array);

                                    if (AppInit.conf.multiaccess)
                                        cacheFiles.TryAdd(md5key, array.Length);
                                }
                            }
                            catch { try { File.Delete(outFile); } catch { } }
                        }

                        proxyManager.Success();

                        httpContext.Response.ContentType = contentType;

                        if (AppInit.conf.serverproxy.responseContentLength)
                            httpContext.Response.ContentLength = array.Length;

                        await httpContext.Response.Body.WriteAsync(array, ctsHttp.Token);
                        #endregion
                    }
                }
                finally
                {
                    if (semaphore != null)
                        semaphore.Release();
                }
            }
        }


        #region Download
        async Task<byte[]> Download(string url, List<HeadersModel> headers = null, WebProxy proxy = null)
        {
            try
            {
                var handler = Http.Handler(url, proxy);

                var client = FrendlyHttp.HttpMessageClient("base", handler);

                var req = new HttpRequestMessage(HttpMethod.Get, url)
                {
                    Version = HttpVersion.Version11
                };

                if (headers != null)
                {
                    foreach (var h in headers)
                        req.Headers.TryAddWithoutValidation(h.name, h.val);
                }

                using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(15)))
                {
                    using (HttpResponseMessage response = await client.SendAsync(req, cts.Token))
                    {
                        if (response.StatusCode != HttpStatusCode.OK)
                            return null;

                        using (HttpContent content = response.Content)
                        {
                            byte[] res = await content.ReadAsByteArrayAsync();
                            if (res == null || res.Length == 0)
                                return null;

                            return res;
                        }
                    }
                }
            }
            catch
            {
                return null;
            }
        }
        #endregion

        #region NetVipsImage
        private byte[] NetVipsImage(string href, byte[] array, int width, int height)
        {
            try
            {
                using (var image = NetVips.Image.NewFromBuffer(array))
                {
                    if ((width != 0 && image.Width > width) || (height != 0 && image.Height > height))
                    {
                        using (var res = image.ThumbnailImage(width == 0 ? image.Width : width, height == 0 ? image.Height : height, crop: NetVips.Enums.Interesting.None))
                        {
                            var buffer = href.Contains(".png") ? res.PngsaveBuffer() : res.JpegsaveBuffer();
                            if (buffer != null && buffer.Length > 1000)
                            {
                                array = null;
                                return buffer;
                            }
                        }
                    }
                }
            }
            catch { }

            return array;
        }
        #endregion

        #region ImageMagick
        static string imaGikPath = null;

        /// <summary>
        /// apt install -y imagemagick libpng-dev libjpeg-dev libwebp-dev
        /// </summary>
        static byte[] ImageMagick(byte[] array, int width, int height, string myoutputFilePath)
        {
            string inputFilePath = null;
            string outputFilePath = null;

            if (Directory.Exists("/dev/shm"))
            {
                inputFilePath = $"/dev/shm/{CrypTo.md5(DateTime.Now.ToBinary().ToString())}.in";
                outputFilePath = myoutputFilePath ?? $"/dev/shm/{CrypTo.md5(DateTime.Now.ToBinary().ToString())}.out";
            }

            if (inputFilePath == null)
                inputFilePath = Path.GetTempFileName();

            if (outputFilePath == null) 
                outputFilePath = myoutputFilePath ?? Path.GetTempFileName();

            if (imaGikPath == null)
                imaGikPath = File.Exists("/usr/bin/magick") ? "magick" : "convert";

            try
            {
                File.WriteAllBytes(inputFilePath, array);

                string argsize = width > 0 && height > 0 ? $"{width}x{height}" : width > 0 ? $"{width}x" : $"x{height}";

                using (Process process = new Process())
                {
                    process.StartInfo.FileName = imaGikPath;
                    process.StartInfo.Arguments = $"\"{inputFilePath}\" -resize {argsize} \"{outputFilePath}\"";
                    process.StartInfo.RedirectStandardOutput = true;
                    process.StartInfo.RedirectStandardError = true;
                    process.StartInfo.UseShellExecute = false;
                    process.StartInfo.CreateNoWindow = true;

                    process.Start();
                    process.WaitForExit();

                    if (process.ExitCode != 0)
                        return array;
                }

                return File.ReadAllBytes(outputFilePath);
            }
            catch 
            { 
                return array; 
            }
            finally
            {
                try
                {
                    if (File.Exists(inputFilePath))
                        File.Delete(inputFilePath);

                    if (File.Exists(outputFilePath) && myoutputFilePath != outputFilePath)
                        File.Delete(outputFilePath);
                }
                catch { }
            }
        }
        #endregion
    }
}

```

## File: Lampac/Engine/Middlewares/ProxyAPI.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Proxy;
using Shared.Models.Events;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class ProxyAPI
    {
        #region ProxyAPI
        public ProxyAPI(RequestDelegate next) { }

        static ProxyAPI()
        {
            Directory.CreateDirectory("cache/hls");
        }
        #endregion

        async public Task InvokeAsync(HttpContext httpContext)
        {
            var init = AppInit.conf.serverproxy;
            var requestInfo = httpContext.Features.Get<RequestModel>();
            string reqip = requestInfo.IP;
            string servPath = httpContext.Request.Path.Value.Replace("/proxy/", "").Replace("/proxy-dash/", "");
            string servUri = servPath + httpContext.Request.QueryString.Value;

            #region tmdb proxy
            if (servUri.Contains(".themoviedb.org"))
            {
                httpContext.Response.Redirect($"/tmdb/api/{Regex.Match(servUri.Replace("://", ":/_/").Replace("//", "/").Replace(":/_/", "://"), "https?://[^/]+/(.*)").Groups[1].Value}");
                return;
            }
            else if (servUri.Contains(".tmdb.org"))
            {
                httpContext.Response.Redirect($"/tmdb/img/{Regex.Match(servUri.Replace("://", ":/_/").Replace("//", "/").Replace(":/_/", "://"), "https?://[^/]+/(.*)").Groups[1].Value}");
                return;
            }
            #endregion

            #region decryptLink
            var decryptLink = ProxyLink.Decrypt(httpContext.Request.Path.Value.StartsWith("/proxy-dash/") ? servPath.Split("/")[0] : servPath, reqip);

            if (init.encrypt || decryptLink?.uri != null || httpContext.Request.Path.Value.StartsWith("/proxy-dash/"))
            {
                servUri = decryptLink?.uri;
            }
            else
            {
                if (!init.enable)
                {
                    httpContext.Response.StatusCode = 403;
                    return;
                }
            }

            if (string.IsNullOrWhiteSpace(servUri) || !servUri.StartsWith("http"))
            {
                httpContext.Response.StatusCode = 404;
                return;
            }

            if (decryptLink == null)
                decryptLink = new ProxyLinkModel(reqip, null, null, servUri);
            #endregion

            if (init.showOrigUri)
            {
                //Console.WriteLine("PX-Orig: " + decryptLink.uri);
                httpContext.Response.Headers["PX-Orig"] = decryptLink.uri;
            }

            #region handler
            var handler = new HttpClientHandler()
            {
                AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate,
                AllowAutoRedirect = false
            };

            handler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;

            if (decryptLink.proxy != null)
            {
                handler.UseProxy = true;
                handler.Proxy = decryptLink.proxy;
            }
            else { handler.UseProxy = false; }
            #endregion

            if (httpContext.Request.Path.Value.StartsWith("/proxy-dash/"))
            {
                #region DASH
                servUri += Regex.Replace(httpContext.Request.Path.Value, "/[^/]+/[^/]+/", "") + httpContext.Request.QueryString.Value;

                var client = FrendlyHttp.HttpMessageClient("proxy", handler);

                using (var request = await CreateProxyHttpRequest(decryptLink.plugin, httpContext, decryptLink.headers, new Uri(servUri), true))
                {
                    using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(20)))
                    {
                        using (var response = await client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cts.Token).ConfigureAwait(false))
                        {
                            httpContext.Response.Headers["PX-Cache"] = "BYPASS";
                            await CopyProxyHttpResponse(httpContext, response).ConfigureAwait(false);
                        }
                    }
                }
                #endregion
            }
            else
            {
                #region Video OR
                if (servUri.Contains(" or "))
                {
                    var hdlr = new HttpClientHandler()
                    {
                        AllowAutoRedirect = true,
                        AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate
                    };

                    hdlr.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;

                    if (decryptLink.proxy != null)
                    {
                        hdlr.UseProxy = true;
                        hdlr.Proxy = decryptLink.proxy;
                    }
                    else { hdlr.UseProxy = false; }

                    string[] links = servUri.Split(" or ");
                    servUri = links[0].Trim();

                    try
                    {
                        // base => AllowAutoRedirect = true
                        var clientor = FrendlyHttp.HttpMessageClient("base", hdlr);

                        using (var requestor = await CreateProxyHttpRequest(decryptLink.plugin, httpContext, decryptLink.headers, new Uri(servUri), true))
                        {
                            using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(7)))
                            {
                                using (var response = await clientor.SendAsync(requestor, HttpCompletionOption.ResponseHeadersRead, cts.Token).ConfigureAwait(false))
                                {
                                    if ((int)response.StatusCode is 200 or 206) { }
                                    else
                                        servUri = links[1].Trim();
                                }
                            }
                        }
                    }
                    catch
                    {
                        servUri = links[1].Trim();
                    }

                    servUri = servUri.Split(" ")[0].Trim();
                    decryptLink.uri = servUri;

                    if (init.showOrigUri)
                        httpContext.Response.Headers["PX-Set-Orig"] = decryptLink.uri;
                }
                #endregion

                var client = FrendlyHttp.HttpMessageClient("proxy", handler);

                using (var request = await CreateProxyHttpRequest(decryptLink.plugin, httpContext, decryptLink.headers, new Uri(servUri), Regex.IsMatch(httpContext.Request.Path.Value, "\\.(m3u|ts|m4s|mp4|mkv|aacp|srt|vtt)", RegexOptions.IgnoreCase)))
                {
                    using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(20)))
                    {
                        using (var response = await client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cts.Token).ConfigureAwait(false))
                        {
                            if ((int)response.StatusCode is 301 or 302 or 303 or 0 || response.Headers.Location != null)
                            {
                                httpContext.Response.Redirect(validArgs($"{AppInit.Host(httpContext)}/proxy/{ProxyLink.Encrypt(response.Headers.Location.AbsoluteUri, decryptLink)}", httpContext));
                                return;
                            }

                            response.Content.Headers.TryGetValues("Content-Type", out var contentType);

                            bool ists = httpContext.Request.Path.Value.EndsWith(".ts") || httpContext.Request.Path.Value.EndsWith(".m4s");

                            if (!ists && (httpContext.Request.Path.Value.Contains(".m3u") || (contentType != null && contentType.First().ToLower() is "application/x-mpegurl" or "application/vnd.apple.mpegurl" or "text/plain")))
                            {
                                #region m3u8/txt
                                using (HttpContent content = response.Content)
                                {
                                    if (response.StatusCode == HttpStatusCode.OK || response.StatusCode == HttpStatusCode.PartialContent)
                                    {
                                        if (response.Content.Headers.ContentLength > init.maxlength_m3u)
                                        {
                                            httpContext.Response.StatusCode = 502;
                                            httpContext.Response.ContentType = "text/plain";
                                            await httpContext.Response.WriteAsync("bigfile", httpContext.RequestAborted).ConfigureAwait(false);
                                            return;
                                        }

                                        var array = await content.ReadAsByteArrayAsync(httpContext.RequestAborted).ConfigureAwait(false);
                                        if (array == null)
                                        {
                                            httpContext.Response.StatusCode = 502;
                                            await httpContext.Response.WriteAsync("error proxy m3u8", httpContext.RequestAborted).ConfigureAwait(false);
                                            return;
                                        }

                                        string hls = editm3u(Encoding.UTF8.GetString(array), httpContext, decryptLink);

                                        httpContext.Response.ContentType = contentType == null ? "application/vnd.apple.mpegurl" : contentType.First();
                                        httpContext.Response.StatusCode = (int)response.StatusCode;

                                        if (response.Headers.AcceptRanges != null)
                                            httpContext.Response.Headers["accept-ranges"] = "bytes";

                                        if (httpContext.Response.StatusCode == 206)
                                            httpContext.Response.Headers["content-range"] = $"bytes 0-{hls.Length - 1}/{hls.Length}";

                                        if (init.responseContentLength)
                                            httpContext.Response.ContentLength = hls.Length;

                                        await httpContext.Response.WriteAsync(hls, httpContext.RequestAborted).ConfigureAwait(false);
                                    }
                                    else
                                    {
                                        httpContext.Response.StatusCode = (int)response.StatusCode;
                                        await httpContext.Response.WriteAsync("error proxy m3u8", httpContext.RequestAborted).ConfigureAwait(false);
                                    }
                                }
                                #endregion
                            }
                            else if (httpContext.Request.Path.Value.Contains(".mpd") || (contentType != null && contentType.First().ToLower() is "application/dash+xml"))
                            {
                                #region dash
                                using (HttpContent content = response.Content)
                                {
                                    if (response.StatusCode == HttpStatusCode.OK)
                                    {
                                        if (response.Content.Headers.ContentLength > init.maxlength_m3u)
                                        {
                                            httpContext.Response.ContentType = "text/plain";
                                            await httpContext.Response.WriteAsync("bigfile", httpContext.RequestAborted).ConfigureAwait(false);
                                            return;
                                        }

                                        var array = await content.ReadAsByteArrayAsync(httpContext.RequestAborted).ConfigureAwait(false);
                                        if (array == null)
                                        {
                                            httpContext.Response.StatusCode = 502;
                                            await httpContext.Response.WriteAsync("error proxy mpd", httpContext.RequestAborted).ConfigureAwait(false);
                                            return;
                                        }

                                        string mpd = Encoding.UTF8.GetString(array);

                                        var m = Regex.Match(mpd, "<BaseURL>([^<]+)</BaseURL>");
                                        while (m.Success)
                                        {
                                            string baseURL = m.Groups[1].Value;
                                            mpd = Regex.Replace(mpd, baseURL, $"{AppInit.Host(httpContext)}/proxy-dash/{ProxyLink.Encrypt(baseURL, decryptLink, forceMd5: true)}/");
                                            m = m.NextMatch();
                                        }

                                        httpContext.Response.ContentType = contentType == null ? "application/dash+xml" : contentType.First();

                                        if (init.responseContentLength)
                                            httpContext.Response.ContentLength = mpd.Length;

                                        await httpContext.Response.WriteAsync(mpd, httpContext.RequestAborted).ConfigureAwait(false);
                                    }
                                    else
                                    {
                                        httpContext.Response.StatusCode = (int)response.StatusCode;
                                        await httpContext.Response.WriteAsync("error proxy", httpContext.RequestAborted).ConfigureAwait(false);
                                    }
                                }
                                #endregion
                            }
                            else
                            {
                                httpContext.Response.Headers["PX-Cache"] = "BYPASS";
                                await CopyProxyHttpResponse(httpContext, response).ConfigureAwait(false);
                            }
                        }
                    }
                }
            }
        }


        #region validArgs
        static string validArgs(string uri, HttpContext httpContext)
        {
            if (AppInit.conf.accsdb.enable && !AppInit.conf.serverproxy.encrypt)
                return AccsDbInvk.Args(uri, httpContext);

            return uri;
        }
        #endregion

        #region editm3u
        static string editm3u(string _m3u8, HttpContext httpContext, ProxyLinkModel decryptLink)
        {
            string proxyhost = $"{AppInit.Host(httpContext)}/proxy";
            string m3u8 = Regex.Replace(_m3u8, "(https?://[^\n\r\"\\# ]+)", m =>
            {
                return validArgs($"{proxyhost}/{ProxyLink.Encrypt(m.Groups[1].Value, decryptLink)}", httpContext);
            });

            string hlshost = Regex.Match(decryptLink.uri, "(https?://[^/]+)/").Groups[1].Value;
            string hlspatch = Regex.Match(decryptLink.uri, "(https?://[^\n\r]+/)([^/]+)$").Groups[1].Value;
            if (string.IsNullOrEmpty(hlspatch) && decryptLink.uri.EndsWith("/"))
                hlspatch = decryptLink.uri;

            m3u8 = Regex.Replace(m3u8, "([\n\r])([^\n\r]+)", m =>
            {
                string uri = m.Groups[2].Value;

                if (uri.Contains("#") || uri.Contains("\"") || uri.StartsWith("http"))
                    return m.Groups[0].Value;

                if (uri.StartsWith("//"))
                {
                    uri = "https:" + uri;
                }
                else if (uri.StartsWith("/"))
                {
                    uri = hlshost + uri;
                }
                else if (uri.StartsWith("./"))
                {
                    uri = hlspatch + uri.Substring(2);
                }
                else
                {
                    uri = hlspatch + uri;
                }

                return m.Groups[1].Value + validArgs($"{proxyhost}/{ProxyLink.Encrypt(uri, decryptLink)}", httpContext);
            });

            m3u8 = Regex.Replace(m3u8, "(URI=\")([^\"]+)", m =>
            {
                string uri = m.Groups[2].Value;

                if (uri.Contains("\"") || uri.StartsWith("http"))
                    return m.Groups[0].Value;

                if (uri.StartsWith("//"))
                {
                    uri = "https:" + uri;
                }
                else if (uri.StartsWith("/"))
                {
                    uri = hlshost + uri;
                }
                else if (uri.StartsWith("./"))
                {
                    uri = hlspatch + uri.Substring(2);
                }
                else
                {
                    uri = hlspatch + uri;
                }

                return m.Groups[1].Value + validArgs($"{proxyhost}/{ProxyLink.Encrypt(uri, decryptLink)}", httpContext);
            });

            return m3u8;
        }
        #endregion


        #region CreateProxyHttpRequest
        async static Task<HttpRequestMessage> CreateProxyHttpRequest(string plugin, HttpContext context, List<HeadersModel> headers, Uri uri, bool ismedia)
        {
            var request = context.Request;

            var requestMessage = new HttpRequestMessage();

            var requestMethod = request.Method;
            if (HttpMethods.IsPost(requestMethod))
            {
                var streamContent = new StreamContent(request.Body);
                requestMessage.Content = streamContent;
            }

            #region Headers
            if (headers != null && headers.Count > 0)
            {
                foreach (var item in headers)
                    requestMessage.Headers.TryAddWithoutValidation(item.name, item.val);
            }

            if (ismedia || headers != null)
            {
                foreach (var header in request.Headers)
                {
                    if (header.Key.ToLower() is "range")
                    {
                        if (!requestMessage.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray()) && requestMessage.Content != null)
                            requestMessage.Content?.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray());
                    }
                }
            }
            else
            {
                foreach (var header in request.Headers)
                {
                    if (header.Key.ToLower() is "host" or "origin" or "user-agent" or "referer" or "content-disposition" or "accept-encoding")
                        continue;

                    if (header.Key.ToLower().StartsWith("x-"))
                        continue;

                    if (!requestMessage.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray()) && requestMessage.Content != null)
                    {
                        //Console.WriteLine(header.Key + ": " + String.Join(" ", header.Value.ToArray()));
                        requestMessage.Content?.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray());
                    }
                }
            }

            if (!requestMessage.Headers.Contains("User-Agent"))
                requestMessage.Headers.TryAddWithoutValidation("User-Agent", Http.UserAgent);
            #endregion

            requestMessage.Headers.Host = uri.Authority;
            requestMessage.RequestUri = uri;
            requestMessage.Method = new HttpMethod(request.Method);

            //requestMessage.Version = new Version(2, 0);
            //Console.WriteLine(JsonConvert.SerializeObject(requestMessage.Headers, Formatting.Indented));

            await InvkEvent.ProxyApi(new EventProxyApiCreateHttpRequest(plugin, request, headers, uri, ismedia, requestMessage));

            return requestMessage;
        }
        #endregion

        #region CopyProxyHttpResponse
        async Task CopyProxyHttpResponse(HttpContext context, HttpResponseMessage responseMessage)
        {
            var response = context.Response;
            response.StatusCode = (int)responseMessage.StatusCode;
            response.ContentLength = responseMessage.Content.Headers.ContentLength;

            #region UpdateHeaders
            void UpdateHeaders(HttpHeaders headers)
            {
                foreach (var header in headers)
                {
                    if (header.Key.ToLower() is "transfer-encoding" or "etag" or "connection" or "content-security-policy" or "content-disposition")
                        continue;

                    if (!AppInit.conf.serverproxy.responseContentLength && header.Key.ToLower() == "content-length")
                        continue;

                    if (header.Key.ToLower().StartsWith("x-") || header.Key.ToLower().StartsWith("alt-"))
                        continue;

                    if (header.Key.ToLower().StartsWith("access-control"))
                        continue;

                    string value = string.Empty;
                    foreach (var val in header.Value)
                        value += $"; {val}";

                    response.Headers[header.Key] = Regex.Replace(value, "^; ", "");
                    //response.Headers[header.Key] = header.Value.ToArray();
                }
            }
            #endregion

            UpdateHeaders(responseMessage.Headers);
            UpdateHeaders(responseMessage.Content.Headers);

            using (var responseStream = await responseMessage.Content.ReadAsStreamAsync().ConfigureAwait(false))
            {
                if (response.Body == null)
                    throw new ArgumentNullException("destination");

                if (!responseStream.CanRead && !responseStream.CanWrite)
                    throw new ObjectDisposedException("ObjectDisposed_StreamClosed");

                if (!response.Body.CanRead && !response.Body.CanWrite)
                    throw new ObjectDisposedException("ObjectDisposed_StreamClosed");

                if (!responseStream.CanRead)
                    throw new NotSupportedException("NotSupported_UnreadableStream");

                if (!response.Body.CanWrite)
                    throw new NotSupportedException("NotSupported_UnwritableStream");

                var bunit = AppInit.conf.serverproxy?.buffering;

                if (bunit?.enable == true && 
                   ((!string.IsNullOrEmpty(bunit.pattern) && Regex.IsMatch(context.Request.Path.Value, bunit.pattern, RegexOptions.IgnoreCase)) || 
                   context.Request.Path.Value.EndsWith(".mp4") || context.Request.Path.Value.EndsWith(".mkv") || responseMessage.Content.Headers.ContentLength > 40_000000))
                {
                    #region buffering
                    var channel = Channel.CreateBounded<(byte[] Buffer, int Length)>(new BoundedChannelOptions(capacity: bunit.length)
                    {
                        FullMode = BoundedChannelFullMode.Wait,
                        SingleWriter = true,
                        SingleReader = true
                    });

                    var readTask = Task.Factory.StartNew(async () =>
                        {
                            try
                            {
                                while (!context.RequestAborted.IsCancellationRequested)
                                {
                                    byte[] chunkBuffer = ArrayPool<byte>.Shared.Rent(Math.Max(bunit.rent, 4096));

                                    try
                                    {
                                        int bytesRead = await responseStream.ReadAsync(chunkBuffer, 0, chunkBuffer.Length, context.RequestAborted);

                                        if (bytesRead == 0)
                                        {
                                            ArrayPool<byte>.Shared.Return(chunkBuffer);
                                            break;
                                        }

                                        await channel.Writer.WriteAsync((chunkBuffer, bytesRead), context.RequestAborted);
                                    }
                                    catch
                                    {
                                        ArrayPool<byte>.Shared.Return(chunkBuffer);
                                        break;
                                    }
                                }
                            }
                            finally
                            {
                                channel.Writer.Complete();
                            }
                        },
                        context.RequestAborted, TaskCreationOptions.LongRunning | TaskCreationOptions.DenyChildAttach, TaskScheduler.Default
                    ).Unwrap();

                    var writeTask = Task.Factory.StartNew(async () =>
                        {
                            bool reqAborted = false;

                            await foreach (var (chunkBuffer, length) in channel.Reader.ReadAllAsync(context.RequestAborted))
                            {
                                try
                                {
                                    if (reqAborted == false)
                                        await response.Body.WriteAsync(chunkBuffer, 0, length, context.RequestAborted);
                                }
                                catch 
                                {
                                    reqAborted = true;
                                }
                                finally
                                {
                                    ArrayPool<byte>.Shared.Return(chunkBuffer);
                                }
                            }
                        },
                        context.RequestAborted, TaskCreationOptions.LongRunning | TaskCreationOptions.DenyChildAttach, TaskScheduler.Default
                    ).Unwrap();

                    await Task.WhenAll(readTask, writeTask).ConfigureAwait(false);
                    #endregion
                }
                else
                {
                    #region bypass
                    byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);

                    try
                    {
                        int bytesRead;

                        while ((bytesRead = await responseStream.ReadAsync(buffer, context.RequestAborted).ConfigureAwait(false)) != 0)
                            await response.Body.WriteAsync(buffer, 0, bytesRead, context.RequestAborted).ConfigureAwait(false);
                    }
                    finally
                    {
                        ArrayPool<byte>.Shared.Return(buffer);
                    }
                    #endregion
                }
            }
        }
        #endregion
    }
}

```

## File: Lampac/Engine/Middlewares/RequestInfo.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Shared;
using Shared.Models;
using System;
using System.IO;
using System.Net;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class RequestInfo
    {
        #region RequestInfo
        private readonly RequestDelegate _next;
        IMemoryCache memoryCache;

        public RequestInfo(RequestDelegate next, IMemoryCache mem)
        {
            _next = next;
            memoryCache = mem;
        }
        #endregion

        public Task Invoke(HttpContext httpContext)
        {
            #region stats
            if (AppInit.conf.openstat.enable)
            {
                string skey = $"stats:request:{DateTime.Now.Minute}";
                if (!memoryCache.TryGetValue(skey, out long _req))
                    _req = 0;

                _req++;
                memoryCache.Set(skey, _req, DateTime.Now.AddMinutes(59));
            }
            #endregion

            bool IsLocalRequest = false;
            string cf_country = null;
            string clientIp = httpContext.Connection.RemoteIpAddress.ToString();

            if (httpContext.Request.Headers.TryGetValue("localrequest", out var _localpasswd))
            {
                if (_localpasswd.ToString() != AppInit.rootPasswd)
                    return httpContext.Response.WriteAsync("error passwd", httpContext.RequestAborted);

                IsLocalRequest = true;

                if (httpContext.Request.Headers.TryGetValue("x-client-ip", out var xip) && !string.IsNullOrEmpty(xip))
                    clientIp = xip;
            }
            else if (AppInit.conf.real_ip_cf || AppInit.conf.listen.frontend == "cloudflare")
            {
                #region cloudflare
                if (Program.cloudflare_ips != null && Program.cloudflare_ips.Count > 0)
                {
                    try
                    {
                        var clientIPAddress = IPAddress.Parse(clientIp);
                        foreach (var cf in Program.cloudflare_ips)
                        {
                            if (new System.Net.IPNetwork(cf.prefix, cf.prefixLength).Contains(clientIPAddress))
                            {
                                if (httpContext.Request.Headers.TryGetValue("CF-Connecting-IP", out var xip) && !string.IsNullOrEmpty(xip))
                                    clientIp = xip;

                                if (httpContext.Request.Headers.TryGetValue("X-Forwarded-Proto", out var xfp) && !string.IsNullOrEmpty(xfp))
                                {
                                    if (xfp == "http" || xfp == "https")
                                        httpContext.Request.Scheme = xfp;
                                }

                                if (httpContext.Request.Headers.TryGetValue("CF-IPCountry", out var xcountry) && !string.IsNullOrEmpty(xcountry))
                                    cf_country = xcountry;

                                break;
                            }
                        }
                    }
                    catch { }
                }
                #endregion
            }
            // –∑–∞–ø—Ä–æ—Å —Å cloudflare, –∑–∞–ø—Ä–æ—Å –Ω–µ –≤ –∞–¥–º–∏–Ω–∫—É
            else if (httpContext.Request.Headers.ContainsKey("CF-Connecting-IP") && !httpContext.Request.Path.Value.StartsWith("/admin"))
            {
                // –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω frontend –∏ —ç—Ç–æ –Ω–µ –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞, —Ç–æ–≥–¥–∞ –≤—ã–≤–æ–¥–∏–º –æ—à–∏–±–∫—É
                if (string.IsNullOrEmpty(AppInit.conf.listen.frontend) && File.Exists("module/manifest.json"))
                    return httpContext.Response.WriteAsync(unknownFrontend, httpContext.RequestAborted);
            }

            var req = new RequestModel()
            {
                IsLocalRequest = IsLocalRequest,
                IP = clientIp,
                Country = cf_country,
                Path = httpContext.Request.Path.Value,
                Query = httpContext.Request.QueryString.Value,
                UserAgent = httpContext.Request.Headers.UserAgent
            };

            #region Weblog Request
            if (!IsLocalRequest)
            {
                string builderLog()
                {
                    var logBuilder = new System.Text.StringBuilder();
                    logBuilder.AppendLine($"{DateTime.Now}");
                    logBuilder.AppendLine($"IP: {clientIp} {req.Country}");
                    logBuilder.AppendLine($"URL: {AppInit.Host(httpContext)}{httpContext.Request.Path}{httpContext.Request.QueryString}\n");

                    foreach (var header in httpContext.Request.Headers)
                        logBuilder.AppendLine($"{header.Key}: {header.Value}");

                    return logBuilder.ToString();
                }

                if (AppInit.conf.rch.websoket == "signalr")
                {
                    if (soks.weblog_clients.Count > 0)
                        soks.SendLog(builderLog(), "request");
                }
                else
                {
                    if (nws.weblog_clients.Count > 0)
                        nws.SendLog(builderLog(), "request");
                }
            }
            #endregion

            if (!string.IsNullOrEmpty(AppInit.conf.accsdb.domainId_pattern))
            {
                string uid = Regex.Match(httpContext.Request.Host.Host, AppInit.conf.accsdb.domainId_pattern).Groups[1].Value;
                req.user = AppInit.conf.accsdb.findUser(uid);
                req.user_uid = uid;

                if (req.user == null)
                    return httpContext.Response.WriteAsync("user not found", httpContext.RequestAborted);

                req.@params = AppInit.conf.accsdb.@params;

                httpContext.Features.Set(req);
                return _next(httpContext);
            }
            else
            {
                #region getuid
                string getuid()
                {
                    if (httpContext.Request.Query.ContainsKey("token"))
                    {
                        string val = httpContext.Request.Query["token"].ToString();
                        if (!string.IsNullOrEmpty(val))
                            return val;
                    }

                    if (httpContext.Request.Query.ContainsKey("account_email"))
                    {
                        string val = httpContext.Request.Query["account_email"].ToString();
                        if (!string.IsNullOrEmpty(val))
                            return val;
                    }

                    if (httpContext.Request.Query.ContainsKey("uid"))
                    {
                        string val = httpContext.Request.Query["uid"].ToString();
                        if (!string.IsNullOrEmpty(val))
                            return val;
                    }

                    if (httpContext.Request.Query.ContainsKey("box_mac"))
                    {
                        string val = httpContext.Request.Query["box_mac"].ToString();
                        if (!string.IsNullOrEmpty(val))
                            return val;
                    }

                    return null;
                }
                #endregion

                req.user = AppInit.conf.accsdb.findUser(httpContext, out string uid);
                req.user_uid = uid;

                if (string.IsNullOrEmpty(req.user_uid))
                    req.user_uid = getuid();

                if (req.user != null)
                    req.@params = AppInit.conf.accsdb.@params;

                httpContext.Features.Set(req);
                return _next(httpContext);
            }
        }


        static string unknownFrontend = @"<!DOCTYPE html>
<html lang='ru'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>CloudFlare</title>
    <link href='/control/npm/bootstrap.min.css' rel='stylesheet'>
</head>
<body>
    <div class='container mt-5'>
        <div class='card mt-4'>
            <div class='card-body'>
                <h5 class='card-title'>–£–∫–∞–∂–∏—Ç–µ frontend –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞</h5>
				<br>
                <p class='card-text'>–î–æ–±–∞–≤—å—Ç–µ –≤ init.conf —Å–ª–µ–¥—É—é—â–∏–π –∫–æ–¥:</p>
                <pre style='background: #e9ecef;'><code>""listen"": {
  ""frontend"": ""cloudflare""
}</code></pre>
				<br>
                <p class='card-text'>–õ–∏–±–æ –æ—Ç–∫–ª—é—á–∏—Ç–µ –ø—Ä–æ–≤–µ—Ä–∫—É CF-Connecting-IP:</p>
                <pre style='background: #e9ecef;'><code>""listen"": {
  ""frontend"": ""off""
}</code></pre>
				<br>
                <p class='card-text'>–¢–∞–∫ –∂–µ –ø–∞—Ä–∞–º–µ—Ç—Ä –º–æ–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å –≤ <a href='/admin' target='_blank'>–∞–¥–º–∏–Ω–∫–µ</a>: –û—Å—Ç–∞–ª—å–Ω–æ–µ, base, frontend</p>
            </div>
        </div>
    </div>
</body>
</html>";
    }
}

```

## File: Lampac/Engine/Middlewares/Extensions.cs
```
Ôªøusing Microsoft.AspNetCore.Builder;

namespace Lampac.Engine.Middlewares
{
    public static class Extensions
    {
        public static IApplicationBuilder UseWAF(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<WAF>();
        }

        public static IApplicationBuilder UseModHeaders(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<ModHeaders>();
        }

        public static IApplicationBuilder UseRequestStatistics(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<RequestStatistics>();
        }

        public static IApplicationBuilder UseOverrideResponse(this IApplicationBuilder builder, bool first)
        {
            return builder.UseMiddleware<OverrideResponse>(first);
        }

        public static IApplicationBuilder UseRequestInfo(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<RequestInfo>();
        }

        public static IApplicationBuilder UseAnonymousRequest(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<AnonymousRequest>();
        }

        public static IApplicationBuilder UseAlwaysRjson(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<AlwaysRjson>();
        }

        public static IApplicationBuilder UseAccsdb(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<Accsdb>();
        }

        public static IApplicationBuilder UseProxyAPI(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<ProxyAPI>();
        }

        public static IApplicationBuilder UseProxyIMG(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<ProxyImg>();
        }

        public static IApplicationBuilder UseProxyCub(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<ProxyCub>();
        }

        public static IApplicationBuilder UseProxyTmdb(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<ProxyTmdb>();
        }

        public static IApplicationBuilder UseModule(this IApplicationBuilder builder, bool first)
        {
            return builder.UseMiddleware<Module>(first);
        }
    }
}

```

## File: Lampac/Engine/Middlewares/AnonymousRequest.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Shared.Models;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class AnonymousRequest
    {
        static bool manifestInitial = false;

        private readonly RequestDelegate _next;
        public AnonymousRequest(RequestDelegate next)
        {
            _next = next;
        }

        public Task Invoke(HttpContext httpContext)
        {
            var requestInfo = httpContext.Features.Get<RequestModel>();

            if (!manifestInitial)
            {
                if (!File.Exists("module/manifest.json"))
                {
                    if (httpContext.Request.Path.Value.StartsWith("/admin/manifest/install"))
                    {
                        requestInfo.IsAnonymousRequest = true;
                        httpContext.Features.Set(requestInfo);
                        return _next(httpContext);
                    }

                    httpContext.Response.Redirect("/admin/manifest/install");
                    return Task.CompletedTask;
                }
                else { manifestInitial = true; }
            }

            var endpoint = httpContext.GetEndpoint();
            if (endpoint != null && endpoint.Metadata.GetMetadata<IAllowAnonymous>() != null)
                requestInfo.IsAnonymousRequest = true;

            if (httpContext.Request.Path.Value == "/" || httpContext.Request.Path.Value == "/favicon.ico")
                requestInfo.IsAnonymousRequest = true;

            if (httpContext.Request.Path.Value == "/.well-known/appspecific/com.chrome.devtools.json")
                requestInfo.IsAnonymousRequest = true;

            if (httpContext.Request.Path.Value.EndsWith("/personal.lampa"))
                requestInfo.IsAnonymousRequest = true;

            if (Regex.IsMatch(httpContext.Request.Path.Value, "^/(merchant/payconfirm|streampay|b2pay|cryptocloud|freekassa|litecoin)(/|$)", RegexOptions.IgnoreCase))
                requestInfo.IsAnonymousRequest = true;

            if (Regex.IsMatch(httpContext.Request.Path.Value, "^/(proxy-dash|cub|corseu|media|ts|kit|bind)(/|$)", RegexOptions.IgnoreCase))
                requestInfo.IsAnonymousRequest = true;

            if (Regex.IsMatch(httpContext.Request.Path.Value, "^/(api/chromium|headers|myip|geo|version|weblog|stats|rch|ping|extensions)(/|$)", RegexOptions.IgnoreCase))
                requestInfo.IsAnonymousRequest = true;

            if (Regex.IsMatch(httpContext.Request.Path.Value, "^/(on/|(lite|online|sisi|timecode|bookmark|sync|tmdbproxy|dlna|ts|tracks|transcoding|backup|catalog|invc-ws)/js/)", RegexOptions.IgnoreCase))
                requestInfo.IsAnonymousRequest = true;

            if (Regex.IsMatch(httpContext.Request.Path.Value, "^/lite/(withsearch|filmixpro|fxapi/lowlevel|kinopubpro|vokinotk|rhs/bind|iptvonline/bind|getstv/bind)(/|$)", RegexOptions.IgnoreCase))
                requestInfo.IsAnonymousRequest = true;

            if (Regex.IsMatch(httpContext.Request.Path.Value, "^/(([^/]+/)?app\\.min\\.js|([^/]+/)?css/app\\.css|[a-zA-Z\\-]+\\.js|msx/start\\.json|samsung\\.wgt)", RegexOptions.IgnoreCase))
                requestInfo.IsAnonymousRequest = true;

            httpContext.Features.Set(requestInfo);
            return _next(httpContext);
        }
    }
}

```

## File: Lampac/Engine/CRON/KurwaCron.cs
```
Ôªøusing Newtonsoft.Json;
using Shared.Engine;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;

namespace Lampac.Engine.CRON
{
    public static class KurwaCron
    {
        public static void Run()
        {
            _cronTimer = new Timer(cron, null, TimeSpan.FromHours(1), TimeSpan.FromHours(5));
        }

        static Timer _cronTimer;

        static bool _cronWork = false;

        async static void cron(object state)
        {
            if (_cronWork)
                return;

            _cronWork = true;

            try
            {
                var externalids = await Http.Get<Dictionary<string, string>>("http://194.246.82.144/externalids.json", weblog: false);
                if (externalids != null && externalids.Count > 0)
                    await File.WriteAllTextAsync("data/externalids.json", JsonConvert.SerializeObject(externalids));

                var cdnmovies = await Http.Download("http://194.246.82.144/cdnmovies.json");
                if (cdnmovies != null && cdnmovies.Length > 0)
                    await File.WriteAllBytesAsync("data/cdnmovies.json", cdnmovies);

                var veoveo = await Http.Download("http://194.246.82.144/veoveo.json");
                if (veoveo != null && veoveo.Length > 0)
                    await File.WriteAllBytesAsync("data/veoveo.json", veoveo);

                var kodik = await Http.Download("http://194.246.82.144/kodik.json");
                if (kodik != null && kodik.Length > 0)
                    await File.WriteAllBytesAsync("data/kodik.json", kodik);
            }
            catch { }
            finally
            {
                _cronWork = false;
            }
        }
    }
}

```

## File: Lampac/Engine/CRON/LampaCron.cs
```
Ôªøusing Shared;
using Shared.Engine;
using System;
using System.IO;
using System.IO.Compression;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine.CRON
{
    public static class LampaCron
    {
        static string currentapp;

        public static void Run()
        {
            var init = AppInit.conf.LampaWeb;
            _cronTimer = new Timer(cron, null, TimeSpan.FromSeconds(20), TimeSpan.FromMinutes(Math.Max(init.intervalupdate, 5)));
        }

        static Timer _cronTimer;

        static bool _cronWork = false;

        async static void cron(object state)
        {
            if (_cronWork)
                return;

            _cronWork = true;

            try
            {
                var init = AppInit.conf.LampaWeb;
                bool istree = !string.IsNullOrEmpty(init.tree);

                async ValueTask<bool> update()
                {
                    if (!init.autoupdate)
                        return false;

                    if (!File.Exists("wwwroot/lampa-main/app.min.js"))
                        return true;

                    if (istree && File.Exists("wwwroot/lampa-main/tree") && init.tree == File.ReadAllText("wwwroot/lampa-main/tree"))
                        return false;

                    string gitapp = await Http.Get($"https://raw.githubusercontent.com/{init.git}/{(istree ? init.tree : "main")}/app.min.js", weblog: false);
                    if (gitapp == null || !gitapp.Contains("author: 'Yumata'"))
                        return false;

                    if (currentapp == null)
                    {
                        currentapp = File.ReadAllText("wwwroot/lampa-main/app.min.js");
                        currentapp = CrypTo.md5(currentapp);
                    }

                    if (CrypTo.md5(gitapp) != currentapp)
                        return true;

                    if (istree)
                        File.WriteAllText("wwwroot/lampa-main/tree", init.tree);

                    return false;
                }

                if (await update())
                {
                    string uri = istree ?
                        $"https://github.com/{init.git}/archive/{init.tree}.zip" :
                        $"https://github.com/{init.git}/archive/refs/heads/main.zip";

                    byte[] array = await Http.Download(uri, MaxResponseContentBufferSize: 20_000_000, timeoutSeconds: 40);
                    if (array != null)
                    {
                        currentapp = null;

                        await File.WriteAllBytesAsync("wwwroot/lampa.zip", array);
                        ZipFile.ExtractToDirectory("wwwroot/lampa.zip", "wwwroot/", overwriteFiles: true);

                        if (istree)
                        {
                            foreach (string infilePath in Directory.GetFiles($"wwwroot/lampa-{init.tree}", "*", SearchOption.AllDirectories))
                            {
                                string outfile = infilePath.Replace($"lampa-{init.tree}", "lampa-main");
                                Directory.CreateDirectory(Path.GetDirectoryName(outfile));
                                File.Copy(infilePath, outfile, true);
                            }

                            File.WriteAllText("wwwroot/lampa-main/tree", init.tree);
                        }

                        string html = File.ReadAllText("wwwroot/lampa-main/index.html");
                        html = html.Replace("</body>", "<script src=\"/lampainit.js\"></script></body>");

                        File.WriteAllText("wwwroot/lampa-main/index.html", html);
                        File.CreateText("wwwroot/lampa-main/personal.lampa");

                        if (!File.Exists("wwwroot/lampa-main/plugins_black_list.json"))
                            File.WriteAllText("wwwroot/lampa-main/plugins_black_list.json", "[]");

                        if (!File.Exists("wwwroot/lampa-main/plugins/modification.js"))
                        {
                            Directory.CreateDirectory("wwwroot/lampa-main/plugins");
                            File.WriteAllText("wwwroot/lampa-main/plugins/modification.js", string.Empty);
                        }

                        File.Delete("wwwroot/lampa.zip");

                        if (istree)
                            Directory.Delete($"wwwroot/lampa-{init.tree}", true);
                    }
                }
            }
            catch { }
            finally
            {
                _cronWork = false;
            }
        }
    }
}

```

## File: Lampac/Engine/CRON/TrackersCron.cs
```
Ôªøusing Shared;
using Shared.Engine;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine.CRON
{
    public static class TrackersCron
    {
        public static void Run()
        {
            _cronTimer = new Timer(cron, null, TimeSpan.FromMinutes(2), TimeSpan.FromMinutes(AppInit.conf.dlna.intervalUpdateTrackers));
        }

        static Timer _cronTimer;

        static bool _cronWork = false;

        async static void cron(object state)
        {
            if (_cronWork)
                return;

            _cronWork = true;

            try
            {
                if (AppInit.modules == null || AppInit.modules.FirstOrDefault(i => i.dll == "DLNA.dll" && i.enable) == null)
                    return;

                if (AppInit.conf.dlna.enable && AppInit.conf.dlna.autoupdatetrackers)
                {
                    var trackers = new HashSet<string>();
                    var trackers_bad = new HashSet<string>();
                    var temp = new HashSet<string>();

                    foreach (string uri in new string[]
                    {
                        "http://redapi.cfhttp.top/trackers.txt",
                        "https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_all_ip.txt",
                        "https://raw.githubusercontent.com/XIU2/TrackersListCollection/master/all.txt",
                        "https://newtrackon.com/api/all"
                    })
                    {
                        string plain = await Http.Get(uri, weblog: false);
                        if (plain == null)
                            continue;

                        foreach (string line in plain.Replace("\r", "").Replace("\t", "").Split("\n"))
                            if (!string.IsNullOrEmpty(line))
                                temp.Add(line.Trim());
                    }

                    foreach (string url in temp)
                    {
                        if (await ckeck(url))
                            trackers.Add(url);
                        else
                            trackers_bad.Add(url);
                    }

                    File.WriteAllLines("cache/trackers_bad.txt", trackers_bad);
                    File.WriteAllLines("cache/trackers.txt", trackers.OrderByDescending(i => Regex.IsMatch(i, "[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+")).ThenByDescending(i => i.StartsWith("http")));
                }
            }
            catch { }
            finally
            {
                _cronWork = false;
            }
        }


        async static Task<bool> ckeck(string tracker)
        {
            if (string.IsNullOrWhiteSpace(tracker) || tracker.Contains("["))
                return false;

            if (tracker.StartsWith("http"))
            {
                try
                {
                    using (var handler = new System.Net.Http.HttpClientHandler())
                    {
                        handler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;

                        using (var client = new System.Net.Http.HttpClient(handler))
                        {
                            client.Timeout = TimeSpan.FromSeconds(7);
                            await client.GetAsync(tracker, System.Net.Http.HttpCompletionOption.ResponseHeadersRead);
                            return true;
                        }
                    }
                }
                catch { }
            }
            else if (tracker.StartsWith("udp:"))
            {
                try
                {
                    tracker = tracker.Replace("udp://", "");

                    string host = tracker.Split(':')[0].Split('/')[0];
                    int port = tracker.Contains(":") ? int.Parse(tracker.Split(':')[1].Split('/')[0]) : 6969;

                    using (UdpClient client = new UdpClient(host, port))
                    {
                        CancellationTokenSource cts = new CancellationTokenSource();
                        cts.CancelAfter(7000);

                        string uri = Regex.Match(tracker, "^[^/]/(.*)").Groups[1].Value;
                        await client.SendAsync(Encoding.UTF8.GetBytes($"GET /{uri} HTTP/1.1\r\nHost: {host}\r\n\r\n"), cts.Token);
                        return true;
                    }
                }
                catch { }
            }

            return false;
        }
    }
}

```

## File: Lampac/Engine/CRON/PluginsCron.cs
```
Ôªøusing Shared;
using Shared.Engine;
using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine.CRON
{
    public static class PluginsCron
    {
        public static void Run()
        {
            _cronTimer = new Timer(cron, null, TimeSpan.FromMinutes(2), TimeSpan.FromHours(1));
        }

        static Timer _cronTimer;

        static bool _cronWork = false;

        async static void cron(object state)
        {
            if (_cronWork)
                return;

            _cronWork = true;

            try
            {
                if (!AppInit.conf.pirate_store)
                    return;

                async ValueTask update(string url, string checkcode = "Lampa.", string path = null)
                {
                    try
                    {
                        string js = await Http.Get(url, Encoding.UTF8, weblog: false);
                        if (js != null && js.Contains(checkcode))
                        {
                            if (path == null)
                                path = Path.GetFileName(url);

                            if (js.Contains("METRIKA"))
                                js = js.Replace("$('body').append(METRIKA);", "");

                            File.WriteAllText($"wwwroot/plugins/{path}", js, Encoding.UTF8);
                        }
                    }
                    catch { }
                }

                await update("https://immisterio.github.io/bwa/fx.js");
                await update("https://adultjs.onrender.com", path: "adult.js");
                await update("https://nb557.github.io/plugins/online_mod.js");
                await update("http://github.freebie.tom.ru/want.js");
                await update("https://nb557.github.io/plugins/reset_subs.js");
                await update("http://193.233.134.21/plugins/mult.js");
                await update("https://nemiroff.github.io/lampa/select_weapon.js");
                await update("https://nb557.github.io/plugins/not_mobile.js");
                await update("http://cub.red/plugin/etor", path: "etor.js");
                await update("http://193.233.134.21/plugins/checker.js");
                await update("https://plugin.rootu.top/ts-preload.js");
                await update("https://lampame.github.io/main/pubtorr/pubtorr.js");
                await update("https://lampame.github.io/main/nc/nc.js");
                await update("https://nb557.github.io/plugins/rating.js");
                await update("https://github.freebie.tom.ru/torrents.js");
                await update("https://nnmdd.github.io/lampa_hotkeys/hotkeys.js");
                await update("https://bazzzilius.github.io/scripts/gold_theme.js");
                await update("https://bdvburik.github.io/rezkacomment.js");
                await update("https://lampame.github.io/main/Shikimori/Shikimori.js");
            }
            catch { }
            finally
            {
                _cronWork = false;
            }
        }
    }
}

```

## File: Lampac/Engine/CRON/CacheCron.cs
```
Ôªøusing Shared;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;

namespace Lampac.Engine.CRON
{
    public static class CacheCron
    {
        public static void Run()
        {
            _cronTimer = new Timer(cron, null, TimeSpan.FromMinutes(2), TimeSpan.FromMinutes(4));
        }

        static Timer _cronTimer;

        static bool _cronWork = false;

        static void cron(object state)
        {
            if (_cronWork)
                return;

            _cronWork = true;

            try
            {
                var files = new Dictionary<string, FileInfo>();
                long freeDiskSpace = getFreeDiskSpace();

                foreach (var conf in new List<(string path, int minute)> {
                    ("tmdb", AppInit.conf.tmdb.cache_img),
                    ("cub", AppInit.conf.cub.cache_img),
                    ("img", AppInit.conf.serverproxy.image.cache_time),
                    ("torrent", AppInit.conf.fileCacheInactive.torrent),
                    ("html", AppInit.conf.fileCacheInactive.html),
                    ("hls", AppInit.conf.fileCacheInactive.hls),
                    ("storage/temp", 10)
                })
                {
                    try
                    {
                        if (conf.minute == -1 || !Directory.Exists(Path.Combine("cache", conf.path)))
                            continue;

                        foreach (string infile in Directory.EnumerateFiles(Path.Combine("cache", conf.path), "*", SearchOption.AllDirectories))
                        {
                            try
                            {
                                if (conf.minute == 0)
                                    File.Delete(infile);
                                else
                                {
                                    var fileinfo = new FileInfo(infile);
                                    if (DateTime.Now > fileinfo.LastWriteTime.AddMinutes(conf.minute))
                                        fileinfo.Delete();
                                    else if (1073741824 > freeDiskSpace) // 1Gb
                                        files.TryAdd(infile, fileinfo);
                                }
                            }
                            catch { }
                        }
                    }
                    catch { }
                }

                if (files.Count > 0)
                {
                    long removeGb = 0;

                    foreach (var item in files.OrderBy(i => i.Value.LastWriteTime))
                    {
                        try
                        {
                            if (File.Exists(item.Key))
                            {
                                File.Delete(item.Key);
                                removeGb += item.Value.Length;

                                // 2Gb
                                if (removeGb > 2147483648)
                                    break;
                            }
                        }
                        catch { }
                    }
                }
            }
            catch { }
            finally 
            {
                _cronWork = false;
            }
        }


        static long getFreeDiskSpace()
        {
            try
            {
                var directory = new DirectoryInfo("cache");
                var drive = DriveInfo.GetDrives()
                    .FirstOrDefault(d => d.IsReady && directory.FullName.StartsWith(d.RootDirectory.FullName, StringComparison.OrdinalIgnoreCase));
                return drive?.AvailableFreeSpace ?? -1;
            }
            catch
            {
                return -1;
            }
        }
    }
}

```

## File: Lampac/Engine/CRON/SyncCron.cs
```
Ôªøusing Shared;
using Shared.Engine;
using Shared.Models;
using System;
using System.Threading;

namespace Lampac.Engine.CRON
{
    public static class SyncCron
    {
        public static void Run()
        {
            _cronTimer = new Timer(cron, null, TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(1));
        }

        static Timer _cronTimer;

        static bool _cronWork = false;

        async static void cron(object state)
        {
            if (_cronWork)
                return;

            _cronWork = true;

            try
            {
                var sync = AppInit.conf?.sync;

                if (sync == null || !sync.enable || sync.type != "slave" || string.IsNullOrEmpty(sync.api_host) || string.IsNullOrEmpty(sync.api_passwd))
                    return;

                var init = await Http.Get<AppInit>(sync.api_host + "/api/sync", timeoutSeconds: 5, headers: HeadersModel.Init("localrequest", sync.api_passwd), weblog: false);
                if (init != null)
                {
                    if (sync.sync_full)
                    {
                        init.sync = sync;
                        AppInit.conf = init;
                    }
                    else
                    {
                        AppInit.conf.accsdb.users = init.accsdb.users;
                    }
                }
            }
            catch { }
            finally
            {
                _cronWork = false;
            }
        }
    }
}

```

## File: Online/GlobalUsings.cs
```
Ôªøglobal using System;
global using System.Web;
global using System.Threading.Tasks;
global using System.Collections.Generic;
global using System.Text.RegularExpressions;
global using System.Collections.Concurrent;
global using System.IO;
global using System.Linq;
global using Shared;
global using Shared.Models;
global using Shared.Engine;
global using Shared.Engine.Online;
global using Shared.Models.Templates;
global using Shared.Models.Base;
```

## File: Online/OnlineApi.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Events;
using Shared.Models.Module;
using Shared.Models.Module.Entrys;
using Shared.Models.SQL;
using Shared.PlaywrightCore;
using System.Data;
using System.Text;
using IO = System.IO;

namespace Online.Controllers
{
    public class OnlineApiController : BaseController
    {
        #region online.js
        [HttpGet]
        [AllowAnonymous]
        [Route("online.js")]
        [Route("online/js/{token}")]
        public ContentResult Online(string token)
        {
            var init = AppInit.conf.online;
            var apr = init.appReplace ?? InvkEvent.conf?.Controller?.AppReplace?.online?.regex;

            string memKey = $"online.js:{apr?.Count ?? 0}:{InvkEvent.conf?.Controller?.AppReplace?.online?.list?.Count ?? 0}:{init.version}:{init.description}:{init.apn}:{host}:{init.spider}:{init.component}:{init.name}:{init.spiderName}";
            if (!memoryCache.TryGetValue(memKey, out (string file, string filecleaer) cache))
            {
                cache.file = FileCache.ReadAllText("plugins/online.js", saveCache: false)
                    .Replace("{rch_websoket}", FileCache.ReadAllText($"plugins/rch_{AppInit.conf.rch.websoket}.js", saveCache: false));

                string playerinner = FileCache.ReadAllText("plugins/player-inner.js", saveCache: false)
                       .Replace("{useplayer}", (!string.IsNullOrEmpty(AppInit.conf.playerInner)).ToString().ToLower())
                       .Replace("{notUseTranscoding}", (AppInit.conf.transcoding.enable == false).ToString().ToLower());

                #region appReplace
                if (apr != null)
                {
                    foreach (var r in apr)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        cache.file = Regex.Replace(cache.file, r.Key, val, RegexOptions.IgnoreCase);
                    }
                }

                if (InvkEvent.conf?.Controller?.AppReplace?.online?.list != null)
                {
                    foreach (var r in InvkEvent.conf.Controller.AppReplace.online.list)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        cache.file = cache.file.Replace(r.Key, val);
                    }
                }
                #endregion

                if (!init.version)
                {
                    cache.file = Regex.Replace(cache.file, "version: \\'[^\\']+\\'", "version: ''")
                                      .Replace("manifst.name, \" v\"", "manifst.name, \" \"");
                }

                if (init.description != "–ü–ª–∞–≥–∏–Ω –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –æ–Ω–ª–∞–π–Ω —Å–µ—Ä–∏–∞–ª–æ–≤ –∏ —Ñ–∏–ª—å–º–æ–≤")
                    cache.file = Regex.Replace(cache.file, "description: \\'([^\\']+)?\\'", $"description: '{init.description}'");

                if (init.apn != null)
                    cache.file = Regex.Replace(cache.file, "apn: \\'([^\\']+)?\\'", $"apn: '{init.apn}'");

                var bulder = new StringBuilder(cache.file);

                if (!init.spider)
                {
                    bulder = bulder.Replace("addSourceSearch('Spider', 'spider');", "")
                                   .Replace("addSourceSearch('Anime', 'spider/anime');", "");
                }

                if (init.component != "lampac")
                {
                    bulder = bulder.Replace("component: 'lampac'", $"component: '{init.component}'")
                                   .Replace("'lampac', component", $"'{init.component}', component")
                                   .Replace("window.lampac_plugin", $"window.{init.component}_plugin");
                }

                if (init.name != "Lampac")
                    bulder = bulder.Replace("name: 'Lampac'", $"name: '{init.name}'");

                if (init.spiderName != "Spider")
                {
                    bulder = bulder.Replace("addSourceSearch('Spider'", $"addSourceSearch('{init.spiderName}'")
                                   .Replace("addSourceSearch('Anime'", $"addSourceSearch('{init.spiderName} - Anime'");
                }

                bulder = bulder
                    .Replace("{invc-rch}", FileCache.ReadAllText("plugins/invc-rch.js", saveCache: false))
                    .Replace("{invc-rch_nws}", FileCache.ReadAllText("plugins/invc-rch_nws.js", saveCache: false))
                    .Replace("{player-inner}", playerinner)
                    .Replace("{localhost}", host);

                cache.file = bulder.ToString();
                cache.filecleaer = cache.file.Replace("{token}", string.Empty);

                if (AppInit.conf.mikrotik == false)
                    memoryCache.Set(memKey, cache, DateTime.Now.AddMinutes(1));
            }

            if (InvkEvent.conf?.Controller?.AppReplace?.online?.eval != null)
            {
                string source = InvkEvent.AppReplace("online", new EventAppReplace(cache.file, token, null, host, requestInfo, HttpContext.Request, hybridCache));
                return Content(source.Replace("{token}", HttpUtility.UrlEncode(token)), "application/javascript; charset=utf-8");
            }

            return Content(token != null ? cache.file.Replace("{token}", HttpUtility.UrlEncode(token)) : cache.filecleaer, "application/javascript; charset=utf-8");
        }
        #endregion

        #region lite.js
        [HttpGet]
        [AllowAnonymous]
        [Route("lite.js")]
        [Route("lite/js/{token}")]
        public ActionResult Lite(string token)
        {
            var sb = new StringBuilder(FileCache.ReadAllText("plugins/lite.js"));

            sb.Replace("{localhost}", $"{host}/lite")
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion


        #region externalids
        /// <summary>
        /// imdb_id, kinopoisk_id
        /// </summary>
        static ConcurrentDictionary<string, string> externalids = new ConcurrentDictionary<string, string>();

        static DateTime externalids_lastWriteTime = default, externalids_nextCheck = default;

        [Route("externalids")]
        async public ValueTask<ActionResult> Externalids(string id, string imdb_id, long kinopoisk_id, int serial)
        {
            #region load externalids
            if (IO.File.Exists("data/externalids.json"))
            {
                try
                {
                    if (externalids_nextCheck > DateTime.Now || externalids_nextCheck == default)
                    {
                        externalids_nextCheck = DateTime.Now.AddMinutes(5);
                        var lastWriteTime = IO.File.GetLastWriteTime("data/externalids.json");
                        if (lastWriteTime != externalids_lastWriteTime)
                        {
                            externalids_lastWriteTime = lastWriteTime;
                            foreach (var item in JsonConvert.DeserializeObject<Dictionary<string, string>>(IO.File.ReadAllText("data/externalids.json")))
                                externalids.AddOrUpdate(item.Key, item.Value, (k, v) => item.Value);
                        }
                    }
                }
                catch { }
            }
            #endregion

            #region KP_
            if (id != null && id.StartsWith("KP_"))
            {
                string _kp = id.Substring(0, 3);
                foreach (var eid in externalids)
                {
                    if (eid.Value == _kp && !string.IsNullOrEmpty(eid.Key))
                    {
                        imdb_id = eid.Key;
                        break;
                    }
                }

                if (!string.IsNullOrEmpty(imdb_id))
                {
                    return Json(new { imdb_id, kinopoisk_id = _kp });
                }
                else
                {
                    string mkey = $"externalids:KP_:{_kp}";
                    if (!hybridCache.TryGetValue(mkey, out string _imdbid, inmemory: false))
                    {
                        string json = await Http.Get($"https://api.alloha.tv/?token=04941a9a3ca3ac16e2b4327347bbc1&kp=" + _kp, timeoutSeconds: 5);
                        _imdbid = Regex.Match(json ?? "", "\"id_imdb\":\"(tt[^\"]+)\"").Groups[1].Value;
                        hybridCache.Set(mkey, _imdbid, DateTime.Now.AddHours(8), inmemory: false);
                    }

                    return Json(new { imdb_id = _imdbid, kinopoisk_id = _kp });
                }
            }
            #endregion

            #region getAlloha / getVSDN / getTabus
            async Task<string> getAlloha(string imdb)
            {
                var proxyManager = new ProxyManager("alloha", AppInit.conf.Alloha);
                string json = await Http.Get("https://api.alloha.tv/?token=04941a9a3ca3ac16e2b4327347bbc1&imdb=" + imdb, timeoutSeconds: 5, proxy: proxyManager.Get());
                if (json == null)
                    return null;

                string kpid = Regex.Match(json, "\"id_kp\":([0-9]+),").Groups[1].Value;
                if (!string.IsNullOrEmpty(kpid) && kpid != "0" && kpid != "null")
                    return kpid;

                return null;
            }

            async Task<string> getVSDN(string imdb)
            {
                if (AppInit.conf.Lumex.spider && AppInit.conf.mikrotik == false)
                {
                    long? res = Lumex.database.FirstOrDefault(i => i.imdb_id == imdb).kinopoisk_id;
                    if (res > 0)
                        return res.ToString();
                }

                if (string.IsNullOrEmpty(AppInit.conf.VideoCDN.token) || string.IsNullOrEmpty(AppInit.conf.VideoCDN.iframehost))
                    return null;

                var proxyManager = new ProxyManager("vcdn", AppInit.conf.VideoCDN);
                string json = await Http.Get($"{AppInit.conf.VideoCDN.iframehost}/api/short?api_token={AppInit.conf.VideoCDN.token}&imdb_id={imdb}", timeoutSeconds: 5, proxy: proxyManager.Get());
                if (json == null)
                    return null;

                string kpid = Regex.Match(json, "\"kp_id\":\"?([0-9]+)\"?").Groups[1].Value;
                if (!string.IsNullOrEmpty(kpid) && kpid != "0" && kpid != "null")
                    return kpid;

                return null;
            }

            async Task<string> getTabus(string imdb)
            {
                var proxyManager = new ProxyManager("collaps", AppInit.conf.Collaps);
                string json = await Http.Get("https://api.bhcesh.me/franchise/details?token=d39edcf2b6219b6421bffe15dde9f1b3&imdb_id=" + imdb.Remove(0, 2), timeoutSeconds: 5, proxy: proxyManager.Get());
                if (json == null)
                    return null;

                string kpid = Regex.Match(json, "\"kinopoisk_id\":\"?([0-9]+)\"?").Groups[1].Value;
                if (!string.IsNullOrEmpty(kpid) && kpid != "0" && kpid != "null")
                    return kpid;

                return null;
            }
            #endregion

            #region get imdb_id
            if (string.IsNullOrWhiteSpace(imdb_id))
            {
                if (kinopoisk_id > 0)
                {
                    string kinopoisk_id_str = kinopoisk_id.ToString();
                    foreach (var eid in externalids)
                    {
                        if (eid.Value == kinopoisk_id_str && !string.IsNullOrEmpty(eid.Key))
                        {
                            imdb_id = eid.Key;
                            break;
                        }
                    }
                }

                if (string.IsNullOrWhiteSpace(imdb_id) && long.TryParse(id, out long _testid) && _testid > 0)
                {
                    using (var sqlDb = new ExternalidsContext())
                        imdb_id = sqlDb.imdb.Find($"{id}_{serial}")?.value;

                    if (string.IsNullOrEmpty(imdb_id))
                    {
                        string mkey = $"externalids:locktmdb:{serial}:{id}";
                        if (!hybridCache.TryGetValue(mkey, out _))
                        {
                            hybridCache.Set(mkey, 0, DateTime.Now.AddHours(1));

                            string cat = serial == 1 ? "tv" : "movie";
                            var header = HeadersModel.Init(("localrequest", AppInit.rootPasswd));
                            string json = await Http.Get($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/3/{cat}/{id}?api_key={AppInit.conf.tmdb.api_key}&append_to_response=external_ids", timeoutSeconds: 5, headers: header);
                            if (!string.IsNullOrWhiteSpace(json))
                            {
                                imdb_id = Regex.Match(json, "\"imdb_id\":\"(tt[0-9]+)\"").Groups[1].Value;
                                if (!string.IsNullOrEmpty(imdb_id))
                                {
                                    using (var sqlDb = new ExternalidsContext())
                                    {
                                        sqlDb.Add(new ExternalidsSqlModel()
                                        {
                                            Id = $"{id}_{serial}",
                                            value = imdb_id
                                        });

                                        await sqlDb.SaveChangesLocks();
                                    }
                                }
                            }
                        }
                    }
                }
            }
            #endregion

            #region get kinopoisk_id
            string kpid = null;

            if (!string.IsNullOrWhiteSpace(imdb_id))
            {
                externalids.TryGetValue(imdb_id, out kpid);

                if (string.IsNullOrEmpty(kpid) || kpid == "0")
                {
                    using (var sqlDb = new ExternalidsContext())
                    {
                        kpid = sqlDb.kinopoisk.Find(imdb_id)?.value;

                        if (string.IsNullOrEmpty(kpid) && kinopoisk_id == 0)
                        {
                            string mkey = $"externalids:lockkpid:{imdb_id}";
                            if (!hybridCache.TryGetValue(mkey, out _))
                            {
                                hybridCache.Set(mkey, 0, DateTime.Now.AddDays(1));

                                switch (AppInit.conf.online.findkp ?? "all")
                                {
                                    case "alloha":
                                        kpid = await getAlloha(imdb_id);
                                        break;
                                    case "vsdn":
                                        kpid = await getVSDN(imdb_id);
                                        break;
                                    case "tabus":
                                        kpid = await getTabus(imdb_id);
                                        break;
                                    default:
                                        {
                                            var tasks = new List<Task<string>> { getVSDN(imdb_id), getAlloha(imdb_id), getTabus(imdb_id) };

                                            while (tasks.Count > 0)
                                            {
                                                var completedTask = await Task.WhenAny(tasks);
                                                tasks.Remove(completedTask);

                                                var result = completedTask.Result;
                                                if (result != null)
                                                {
                                                    kpid = result;
                                                    break;
                                                }
                                            }

                                            break;
                                        }
                                }

                                if (!string.IsNullOrEmpty(kpid) && kpid != "0")
                                {
                                    sqlDb.Add(new ExternalidsSqlModel()
                                    {
                                        Id = imdb_id,
                                        value = kpid
                                    });

                                    await sqlDb.SaveChangesLocks();
                                }
                            }
                        }
                    }
                }
            }
            #endregion

            kpid = kpid != null ? kpid : kinopoisk_id.ToString();
            InvkEvent.Externalids(id, ref imdb_id, ref kpid, serial);

            return Content($"{{\"imdb_id\":\"{imdb_id}\",\"kinopoisk_id\":\"{kpid}\"}}", "application/json; charset=utf-8");
        }
        #endregion

        #region WithSearch
        [AllowAnonymous]
        [Route("lite/withsearch")]
        public ActionResult WithSearch()
        {
            if (AppInit.conf.online.with_search == null)
                return ContentTo("[]");

            return Json(AppInit.conf.online.with_search);
        }
        #endregion

        #region spider
        [Route("lite/spider")]
        [Route("lite/spider/anime")]
        async public Task<ActionResult> Spider(string title)
        {
            if (!AppInit.conf.online.spider)
                return ContentTo("{}");

            var rch = new RchClient(HttpContext, host, new BaseSettings() { rhub = true }, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var user = requestInfo.user;
            var piders = new List<(string name, string uri, int index)>();

            bool isanime = HttpContext.Request.Path.Value?.EndsWith("/anime") == true;

            #region module
            OnlineModuleEntry.EnsureCache();
            var spiderArgs = new OnlineSpiderModel(title, isanime);

            if (OnlineModuleEntry.onlineModulesCache != null && OnlineModuleEntry.onlineModulesCache.Count > 0)
            {
                void addResult(List<(string name, string url, int index)> result)
                {
                    if (result == null || result.Count == 0)
                        return;

                    foreach (var item in result)
                    {
                        if (string.IsNullOrEmpty(item.name) || string.IsNullOrEmpty(item.url))
                            continue;

                        piders.Add((item.name, item.url, item.index));
                    }
                }

                foreach (var entry in OnlineModuleEntry.onlineModulesCache)
                {
                    try
                    {
                        if (entry.Spider != null)
                        {
                            try
                            {
                                var result = entry.Spider(HttpContext, memoryCache, requestInfo, host, spiderArgs);
                                addResult(result);
                            }
                            catch { }
                        }

                        if (entry.SpiderAsync != null)
                        {
                            try
                            {
                                var result = await entry.SpiderAsync(HttpContext, memoryCache, requestInfo, host, spiderArgs);
                                addResult(result);
                            }
                            catch { }
                        }

                    }
                    catch (Exception ex) { Console.WriteLine($"Modules {entry.mod?.NamespacePath(entry.mod.online)}: {ex.Message}\n\n"); }
                }
            }
            #endregion

            #region send
            void send(BaseSettings init, string plugin = null)
            {
                if (!init.spider || !init.enable || init.rip)
                    return;

                if (init.geo_hide != null)
                {
                    if (requestInfo.Country != null && init.geo_hide.Contains(requestInfo.Country))
                        return;
                }

                if (init.group_hide)
                {
                    if (init.group > 0)
                    {
                        if (user == null || init.group > user.group)
                            return;
                    }
                    else if (AppInit.conf.accsdb.enable)
                    {
                        if (user == null && string.IsNullOrEmpty(AppInit.conf.accsdb.premium_pattern))
                            return;
                    }
                }

                string url = null;
                string displayname = init.displayname ?? init.plugin;

                if (string.IsNullOrEmpty(init.overridepasswd))
                {
                    url = init.overridehost;
                    if (string.IsNullOrEmpty(url) && init.overridehosts != null && init.overridehosts.Length > 0)
                        url = init.overridehosts[Random.Shared.Next(0, init.overridehosts.Length)];
                }

                if (string.IsNullOrEmpty(url))
                    url = $"{host}/lite/" + (plugin ?? init.plugin).ToLower();

                piders.Add((init.displayname ?? init.plugin, $"{url}?title={HttpUtility.UrlEncode(title)}&clarification=1&rjson=true&similar=true", init.displayindex));
            }
            #endregion

            if (isanime)
            {
                send(AppInit.conf.Kodik);
                send(AppInit.conf.AnimeLib);
                send(AppInit.conf.AnilibriaOnline, "anilibria");
                send(AppInit.conf.Animevost);
                send(AppInit.conf.Animebesst);
                send(AppInit.conf.MoonAnime);
                send(AppInit.conf.AnimeGo);
            }

            send(AppInit.conf.Filmix);
            send(AppInit.conf.FilmixTV, "filmixtv");
            send(AppInit.conf.FilmixPartner, "fxapi");

            send(AppInit.conf.Rezka);
            send(AppInit.conf.RezkaPrem, "rhsprem");

            send(AppInit.conf.KinoPub);
            send(AppInit.conf.Kinogo);
            send(AppInit.conf.GetsTV, "getstv-search");
            send(AppInit.conf.Kinobase);
            send(AppInit.conf.Alloha, "alloha-search");
            send(AppInit.conf.Collaps, "collaps-search");
            send(AppInit.conf.VeoVeo, "veoveo-spider");

            if (!string.IsNullOrEmpty(AppInit.conf.VideoCDN.token))
                send(AppInit.conf.VideoCDN);

            if (AppInit.conf.Lumex.priorityBrowser == "http" || PlaywrightBrowser.Status != PlaywrightStatus.disabled)
                send(AppInit.conf.Lumex);

            send(AppInit.conf.VDBmovies);
            send(AppInit.conf.HDVB, "hdvb-search");

            return Json(piders.OrderByDescending(i => i.index).ToDictionary(k => k.name, v => v.uri));
        }
        #endregion


        #region events
        [HttpGet]
        [AllowAnonymous]
        [Route("lifeevents")]
        public ActionResult LifeEvents(string memkey, long id, string imdb_id, long kinopoisk_id, int serial)
        {
            string json = null;
            JsonResult error(string msg) => Json(new { accsdb = true, ready = true, online = new string[] { }, msg });

            List<(string code, int index, bool work)> _links = null;
            if (memoryCache.TryGetValue(memkey, out List<(string code, int index, bool work)> links))
                _links = links.ToList();

            if (_links != null && _links.Count(i => i.code != null) > 0)
            {
                bool ready = _links.Count == _links.Count(i => i.code != null);
                string online = string.Join(",", _links.Where(i => i.code != null).OrderByDescending(i => i.work).ThenBy(i => i.index).Select(i => i.code));

                if (ready && !online.Contains("\"show\":true"))
                {
                    if (string.IsNullOrEmpty(imdb_id) && 0 >= kinopoisk_id)
                        return error($"–î–æ–±–∞–≤—å—Ç–µ \"IMDB ID\" {(serial == 1 ? "—Å–µ—Ä–∏–∞–ª–∞" : "—Ñ–∏–ª—å–º–∞")} –Ω–∞ https://themoviedb.org/{(serial == 1 ? "tv" : "movie")}/{id}/edit?active_nav_item=external_ids");

                    return error($"–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –æ–Ω–ª–∞–π–Ω –¥–ª—è {(serial == 1 ? "—Å–µ—Ä–∏–∞–ª–∞" : "—Ñ–∏–ª—å–º–∞")}");
                }

                json = "{" + $"\"ready\":{ready.ToString().ToLower()},\"tasks\":{_links.Count},\"online\":[{online.Replace("{localhost}", host)}]" + "}";
            }

            return Content(json ?? "{\"ready\":false,\"tasks\":0,\"online\":[]}", contentType: "application/javascript; charset=utf-8");
        }


        [HttpGet]
        [Route("lite/events")]
        async public ValueTask<ActionResult> Events(string id, string imdb_id, long kinopoisk_id, long tmdb_id, string title, string original_title, string original_language, int year, string source, string rchtype, int serial = -1, bool life = false, bool islite = false, string account_email = null, string uid = null, string token = null, string nws_id = null)
        {
            var online = new List<(dynamic init, string name, string url, string plugin, int index)>(50);
            bool isanime = original_language is "ja" or "zh";

            #region fix title
            bool fix_title = false;

            if (title != null && original_language != null && original_language.Split("|")[0] is "ja" or "ko" or "zh" or "cn")
            {
                if (long.TryParse(id, out long tmdbid) && tmdbid > 0)
                {
                    Regex chineseRegex = new Regex("[\u4E00-\u9FFF]"); // –î–∏–∞–ø–∞–∑–æ–Ω –¥–ª—è –∫–∏—Ç–∞–π—Å–∫–∏—Ö –∏–µ—Ä–æ–≥–ª–∏—Ñ–æ–≤
                    Regex japaneseRegex = new Regex("[\u3040-\u30FF\uFF66-\uFF9F]"); // –•–∏—Ä–∞–≥–∞–Ω–∞, –∫–∞—Ç–∞–∫–∞–Ω–∞ –∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
                    Regex koreanRegex = new Regex("[\uAC00-\uD7AF]"); // –î–∏–∞–ø–∞–∑–æ–Ω –¥–ª—è –∫–æ—Ä–µ–π—Å–∫–∏—Ö —Ö–∞–Ω–≥—ã–ª—å—Å–∫–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤

                    if (chineseRegex.IsMatch(title) || japaneseRegex.IsMatch(title) || koreanRegex.IsMatch(title))
                    {
                        var header = HeadersModel.Init(("localrequest", AppInit.rootPasswd));
                        var result = await Http.Get<JObject>($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/3/{(serial == 1 ? "tv" : "movie")}/{tmdbid}?api_key={AppInit.conf.tmdb.api_key}&language=en", timeoutSeconds: 4, headers: header);
                        if (result != null)
                        {
                            string _title = serial == 1 ? result.Value<string>("name") : result.Value<string>("title");
                            if (!string.IsNullOrEmpty(_title))
                            {
                                title = _title;
                                fix_title = true;
                            }
                        }
                    }
                }
            }
            #endregion

            var conf = AppInit.conf;
            var user = requestInfo.user;
            JObject kitconf = await loadKitConf();

            #region modules
            OnlineModuleEntry.EnsureCache();

            if (OnlineModuleEntry.onlineModulesCache != null && OnlineModuleEntry.onlineModulesCache.Count > 0)
            {
                var args = new OnlineEventsModel(id, imdb_id, kinopoisk_id, title, original_title, original_language, year, source, rchtype, serial, life, islite, account_email, uid, token, nws_id);

                foreach (var entry in OnlineModuleEntry.onlineModulesCache)
                {
                    try
                    {
                        #region version >= 3 methods
                        if (entry.Invoke != null)
                        {
                            try
                            {
                                var result = entry.Invoke(HttpContext, memoryCache, requestInfo, host, args);
                                if (result != null && result.Count > 0)
                                {
                                    foreach (var r in result)
                                        online.Add((null, r.name, r.url, r.plugin, r.index));
                                }
                            }
                            catch { }
                        }

                        if (entry.InvokeAsync != null)
                        {
                            try
                            {
                                var result = await entry.InvokeAsync(HttpContext, memoryCache, requestInfo, host, args);
                                if (result != null && result.Count > 0)
                                {
                                    foreach (var r in result)
                                        online.Add((null, r.name, r.url, r.plugin, r.index));
                                }
                            }
                            catch { }
                        }
                        #endregion

                        #region version < 3 legacy methods
                        if (entry.Events != null)
                        {
                            try
                            {
                                long.TryParse(id, out long tmdbid);
                                var result = entry.Events(host, tmdbid, imdb_id, kinopoisk_id, title, original_title, original_language, year, source, serial, account_email);
                                if (result != null && result.Count > 0)
                                {
                                    foreach (var r in result)
                                        online.Add((null, r.name, r.url, r.plugin, r.index));
                                }
                            }
                            catch { }
                        }

                        if (entry.EventsAsync != null)
                        {
                            try
                            {
                                long.TryParse(id, out long tmdbid);
                                var result = await entry.EventsAsync(HttpContext, memoryCache, host, tmdbid, imdb_id, kinopoisk_id, title, original_title, original_language, year, source, serial, account_email);
                                if (result != null && result.Count > 0)
                                {
                                    foreach (var r in result)
                                        online.Add((null, r.name, r.url, r.plugin, r.index));
                                }
                            }
                            catch { }
                        }
                        #endregion
                    }
                    catch (Exception ex) { Console.WriteLine($"Modules {entry.mod?.NamespacePath(entry.mod.online)}: {ex.Message}\n\n"); }
                }
            }
            #endregion

            #region send
            void send(BaseSettings _init, string plugin = null, string name = null, string arg_title = null, string arg_url = null, string rch_access = null, BaseSettings myinit = null)
            {
                var init = myinit != null ? _init : loadKit(_init, kitconf);
                bool enable = init.enable && !init.rip;
                if (!enable)
                    return;

                if (init.rhub && !init.rhub_fallback)
                {
                    if (rch_access != null && rchtype != null) 
                    {
                        enable = rch_access.Contains(rchtype);
                        if (enable && init.rhub_geo_disable != null)
                        {
                            if (requestInfo.Country != null && init.rhub_geo_disable.Contains(requestInfo.Country))
                                enable = false;
                        }
                    }
                }

                if (enable && init.client_type != null && rchtype != null)
                    enable = init.client_type.Contains(rchtype);

                if (init.geo_hide != null)
                {
                    if (requestInfo.Country != null && init.geo_hide.Contains(requestInfo.Country))
                        enable = false;
                }

                if (enable)
                {
                    if (init.group_hide)
                    {
                        if (init.group > 0)
                        {
                            if (user == null || init.group > user.group)
                                return;
                        }
                        else if (AppInit.conf.accsdb.enable)
                        {
                            if (user == null && string.IsNullOrEmpty(AppInit.conf.accsdb.premium_pattern))
                                return;
                        }
                    }

                    string url = string.Empty;

                    if (string.IsNullOrEmpty(init.overridepasswd))
                    {
                        url = init.overridehost;
                        if (string.IsNullOrEmpty(url) && init.overridehosts != null && init.overridehosts.Length > 0)
                            url = init.overridehosts[Random.Shared.Next(0, init.overridehosts.Length)];
                    }

                    string displayname = init.displayname ?? name ?? init.plugin;

                    if (!string.IsNullOrEmpty(url))
                    {
                        if (plugin == "collaps-dash")
                        {
                            displayname = displayname.Replace("- 720p", "- 1080p");
                            url = url.Replace("/collaps", "/collaps-dash");
                        }
                    }
                    else {
                        url = "{localhost}/lite/" + (plugin ?? (init.plugin ?? name).ToLower()) + arg_url;
                    }

                    if (original_language != null && original_language.Split("|")[0] is "ru" or "ja" or "ko" or "zh" or "cn")
                    {
                        string _p = (plugin ?? (init.plugin ?? name).ToLower());
                        if (_p is "filmix" or "filmixtv" or "fxapi" or "kinoukr" or "rezka" or "rhsprem" or "redheadsound" or "kinopub" or "alloha" or "lumex" or "vcdn" or "videocdn" or "fancdn" or "redheadsound" or "kinotochka" or "remux") // || (_p == "kodik" && kinopoisk_id == 0 && string.IsNullOrEmpty(imdb_id))
                            url += (url.Contains("?") ? "&" : "?") + "clarification=1";
                    }

                    online.Add((myinit, $"{displayname}{arg_title}", url, (plugin ?? init.plugin ?? name).ToLower(), init.displayindex > 0 ? init.displayindex : online.Count));
                }
            }
            #endregion

            if (original_language != null && original_language.Split("|")[0] is "ja" or "ko" or "zh" or "cn" or "th" or "vi" or "tl")
                send(conf.Kodik);

            if (serial == -1 || isanime)
            {
                send(conf.AniLiberty);
                send(conf.AnilibriaOnline, "anilibria", "Anilibria");
                send(conf.AnimeLib);
                send(conf.Animevost, rch_access: "apk,cors");
                send(conf.Animebesst, rch_access: "apk");
                send(conf.AnimeGo);
                send(conf.AniMedia);
                send(conf.MoonAnime);
            }

            #region VoKino
            if (kinopoisk_id > 0 || source?.ToLower() == "vokino")
            {
                string vid = kinopoisk_id.ToString();
                if (source?.ToLower() == "vokino" && !string.IsNullOrEmpty(id))
                    vid = id;

                var myinit = loadKit(conf.VoKino, kitconf , (j, i, c) => 
                {
                    if (j.ContainsKey("online"))
                        i.online = c.online;

                    return i;
                });

                if (myinit.enable && !string.IsNullOrEmpty(myinit.token))
                {
                    async ValueTask vkino()
                    {
                        if (myinit.rhub || !conf.online.checkOnlineSearch)
                        {
                            VoKinoInvoke.SendOnline(myinit, online, null);
                        }
                        else
                        {
                            if (!hybridCache.TryGetValue($"vokino:view:{vid}", out JObject view))
                            {
                                view = await Http.Get<JObject>($"{myinit.corsHost()}/v2/view/{vid}?token={myinit.token}", timeoutSeconds: 4);
                                if (view != null)
                                    hybridCache.Set($"vokino:view:{vid}", view, cacheTime(20));
                            }

                            if (view != null && view.ContainsKey("online") && view["online"] is JObject onlineObj)
                                VoKinoInvoke.SendOnline(myinit, online, onlineObj);
                        }
                    };

                    if (AppInit.conf.accsdb.enable)
                    {
                        if (user != null)
                        {
                            if (myinit.group > user.group && myinit.group_hide) { }
                            else
                                await vkino();
                        }
                        else
                        {
                            if (!string.IsNullOrEmpty(AppInit.conf.accsdb.premium_pattern))
                                await vkino();
                        }
                    }
                    else
                    {
                        if (myinit.group > 0 && myinit.group_hide && (user == null || myinit.group > user.group)) { }
                        else
                            await vkino();
                    }
                }
            }
            #endregion

            #region Filmix
            {
                var myinit = loadKit(conf.Filmix, kitconf, (j, i, c) => 
                { 
                    if (j.ContainsKey("pro"))
                        i.pro = c.pro; 
                    return i; 
                });

                if (string.IsNullOrEmpty(myinit.token) && (myinit.tokens == null || myinit.tokens.Length == 0) && conf.Filmix.hidefreeStart > 0)
                {
                    if (TimeZoneTo.ByIds(["Europe/Kyiv", "Europe/Kiev", "FLE Standard Time"], out DateTime kievTime))
                    {
                        if (kievTime.Hour >= conf.Filmix.hidefreeStart && kievTime.Hour < conf.Filmix.hidefreeEnd)
                            myinit.enable = false;
                    }
                }

                send(myinit, myinit: myinit, rch_access: "apk");
            }

            send(conf.FilmixTV, "filmixtv");
            send(conf.FilmixPartner, "fxapi", "Filmix");
            #endregion

            send(conf.KinoPub);
            send(conf.IptvOnline, "iptvonline", "iptv.online");
            send(conf.GetsTV);

            #region Alloha
            {
                var myinit = loadKit(conf.Alloha, kitconf , (j, i, c) => 
                { 
                    if (j.ContainsKey("m4s"))
                        i.m4s = c.m4s;
                    return i; 
                });

                send(myinit, myinit: myinit);
            }
            #endregion

            #region Rezka
            {
                var rezka_premium = loadKit(conf.RezkaPrem, kitconf , (j, i, c) => 
                {
                    if (j.ContainsKey("premium"))
                        i.premium = c.premium; 
                    return i; 
                });

                send(rezka_premium, "rhsprem", "HDRezka", myinit: rezka_premium);

                if (rezka_premium.enable == false)
                {
                    var myinit = await loadKit(conf.Rezka, (j, i, c) =>
                    {
                        if (j.ContainsKey("premium"))
                            i.premium = c.premium;
                        return i;
                    });

                    send(myinit, myinit: myinit);
                }
            }
            #endregion

            if (PlaywrightBrowser.Status != PlaywrightStatus.disabled)
                send(conf.Mirage);

            if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Kinobase.overridehost) || conf.Kinobase.overridehosts?.Length > 0)
                send(conf.Kinobase);

            if (conf.VDBmovies.rhub || conf.VDBmovies.priorityBrowser == "http" || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.VDBmovies.overridehost) || conf.VDBmovies.overridehosts?.Length > 0)
                send(conf.VDBmovies, rch_access: "apk");

            if (kinopoisk_id > 0)
            {
                if (conf.VideoDB.rhub || conf.VideoDB.priorityBrowser == "http" || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.VideoDB.overridehost) || conf.VideoDB.overridehosts?.Length > 0)
                    send(conf.VideoDB, rch_access: "apk");

                if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Zetflix.overridehost) || conf.Zetflix.overridehosts?.Length > 0)
                    send(conf.Zetflix);
            }

            if (serial == -1 || serial == 0 || !string.IsNullOrEmpty(conf.FanCDN.token) || !string.IsNullOrEmpty(conf.FanCDN.overridehost) || conf.FanCDN.overridehosts?.Length > 0)
            {
                if (conf.FanCDN.rhub || conf.FanCDN.priorityBrowser == "http" || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.FanCDN.overridehost) || conf.FanCDN.overridehosts?.Length > 0)
                    send(conf.FanCDN, rch_access: "apk");
            }

            send(conf.VideoCDN);

            if (conf.Lumex.priorityBrowser == "http" || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Lumex.overridehost) || conf.Lumex.overridehosts?.Length > 0)
                send(conf.Lumex);

            if (conf.Kinogo.rhub || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Kinogo.overridehost) || conf.Kinogo.overridehosts?.Length > 0)
                send(conf.Kinogo, rch_access: "apk");

            if (kinopoisk_id > 0)
                send(conf.Ashdi, "ashdi", "Ashdi (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π)");

            if (!isanime)
                send(conf.Kinoukr, "kinoukr", "Kinoukr (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π)", rch_access: "apk,cors");

            send(conf.Eneyida, "eneyida", "Eneyida (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π)", rch_access: "apk,cors");

            #region Collaps
            {
                var myinit = loadKit(conf.Collaps, kitconf, (j, i, c) =>
                {
                    if (j.ContainsKey("dash"))
                        i.dash = c.dash;
                    if (j.ContainsKey("two"))
                        i.two = c.two;
                    return i;
                });

                send(myinit, "collaps", $"Collaps ({(myinit.dash ? "DASH" : "HLS")})", rch_access: "apk", myinit: myinit);

                if (myinit.two && !myinit.dash)
                    send(myinit, "collaps-dash", "Collaps (DASH)", rch_access: "apk");
            }
            #endregion

            if (serial == -1 || serial == 0)
            {
                send(conf.Plvideo, "plvideo", "Plvideo", rch_access: "apk,cors");
                send(conf.RutubeMovie, "rutubemovie", "Rutube", rch_access: "apk,cors");
                send(conf.VkMovie, "vkmovie", "VK –í–∏–¥–µ–æ", rch_access: "apk,cors");
            }

            if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Videoseed.overridehost) || conf.Videoseed.overridehosts?.Length > 0)
                send(conf.Videoseed);

            send(conf.Vibix, rch_access: "apk");
            send(conf.VeoVeo);

            if (serial == -1 || serial == 0)
                send(conf.iRemux, "remux");

            #region PidTor
            if (conf.PidTor.enable)
            {
                if ((conf.PidTor.torrs != null && conf.PidTor.torrs.Length > 0) || (conf.PidTor.auth_torrs != null && conf.PidTor.auth_torrs.Count > 0) || AppInit.modules.FirstOrDefault(i => i.dll == "TorrServer.dll" && i.enable) != null)
                {
                    void psend()
                    {
                        var _conf = InvkEvent.conf.PidTor != null ? conf.PidTor.Clone() : conf.PidTor;

                        InvkEvent.PidTor(new EventPidTor(_conf, requestInfo, hybridCache));

                        if (!_conf.enable)
                            return;

                        if (_conf.group > 0 && _conf.group_hide)
                        {
                            if (user == null || _conf.group > user.group)
                                return;
                        }

                        online.Add((null, $"{_conf.displayname ?? "Pid≈¶or"}", "{localhost}/lite/pidtor", "pidtor", _conf.displayindex > 0 ? _conf.displayindex : online.Count));
                    }

                    psend();
                }
            }
            #endregion

            if (serial == -1 || serial == 0)
                send(conf.Redheadsound, rch_access: "apk");

            send(conf.HDVB, rch_access: "apk");
            send(conf.Kinotochka, rch_access: "apk,cors");

            if ((serial == -1 || (serial == 1 && !isanime)) && kinopoisk_id > 0)
                send(conf.CDNmovies, rch_access: "apk,cors");

            if (serial == -1 || serial == 0)
                send(conf.IframeVideo);

            if (kinopoisk_id > 0 && !isanime)
                send(conf.CDNvideohub, "cdnvideohub", "VideoHUB", rch_access: "apk,cors");

            #region ENG
            if ((original_language == null || original_language == "en") && conf.disableEng == false)
            {
                if (tmdb_id > 0 || (source != null && (source is "tmdb" or "cub")))
                {
                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Hydraflix.overridehost) || conf.Hydraflix.overridehosts?.Length > 0)
                        send(conf.Hydraflix, "hydraflix", "HydraFlix (ENG)");

                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Vidsrc.overridehost) || conf.Vidsrc.overridehosts?.Length > 0)
                        send(conf.Vidsrc, "vidsrc", "VidSrc (ENG)");

                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.VidLink.overridehost) || conf.VidLink.overridehosts?.Length > 0)
                        send(conf.VidLink, "vidlink", "VidLink (ENG)");

                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Videasy.overridehost) || conf.Videasy.overridehosts?.Length > 0)
                        send(conf.Videasy, "videasy", "Videasy (ENG)");

                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.MovPI.overridehost) || conf.MovPI.overridehosts?.Length > 0)
                        send(conf.MovPI, "movpi", "MovPI (ENG)");

                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Smashystream.overridehost) || conf.Smashystream.overridehosts?.Length > 0)
                        send(conf.Smashystream, "smashystream", "SmashyStream (ENG)");

                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Autoembed.overridehost) || conf.Autoembed.overridehosts?.Length > 0)
                        send(conf.Autoembed, "autoembed", "AutoEmbed (ENG)");

                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Playembed.overridehost) || conf.Playembed.overridehosts?.Length > 0)
                        send(conf.Playembed, "playembed", "PlayEmbed (ENG)");

                    if (Firefox.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Twoembed.overridehost) || conf.Twoembed.overridehosts?.Length > 0)
                        send(conf.Twoembed, "twoembed", "2Embed (ENG)");

                    send(conf.Rgshows, "rgshows", "RgShows (ENG)");
                }
            }
            #endregion

            if (!life && conf.litejac)
                online.Add((null, "–¢–æ—Ä—Ä–µ–Ω—Ç—ã", "{localhost}/lite/jac", "jac", 200));

            #region checkOnlineSearch
            bool chos = conf.online.checkOnlineSearch && !string.IsNullOrEmpty(id);

            if (chos && IO.File.Exists("isdocker"))
            {
                string version = await Http.Get($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/version", timeoutSeconds: 4, headers: HeadersModel.Init("localrequest", AppInit.rootPasswd));
                if (version == null || !version.StartsWith(appversion))
                    chos = false;
            }

            if (chos)
            {
                string memkey = CrypTo.md5($"checkOnlineSearch:{id}:{serial}:{source?.Replace("tmdb", "")?.Replace("cub", "")}:{online.Count}:{(IsKitConf ? requestInfo.user_uid : null)}");

                if (!memoryCache.TryGetValue(memkey, out List<(string code, int index, bool work)> links) || !conf.multiaccess)
                {
                    var tasks = new List<Task>();
                    links = new List<(string code, int index, bool work)>(online.Count);
                    for (int i = 0; i < online.Count; i++)
                        links.Add(default);

                    memoryCache.Set(memkey, links, DateTime.Now.AddMinutes(5));

                    foreach (var o in online)
                    {
                        var tk = checkSearch(memkey, links, tasks.Count, o.init, o.index, o.name, o.url, o.plugin, id, imdb_id, kinopoisk_id, tmdb_id, title, original_title, original_language, source, year, serial, life, rchtype);
                        tasks.Add(tk);
                    }

                    if (life)
                        return Json(new { life = true, memkey, title = (fix_title ? title : null) });

                    await Task.WhenAll(tasks);
                }

                if (life)
                    return Json(new { life = true, memkey });

                return ContentTo($"[{string.Join(",", links.Where(i => i.code != null).OrderByDescending(i => i.work).ThenBy(i => i.index).Select(i => i.code)).Replace("{localhost}", host)}]");
            }
            #endregion

            string online_result = string.Join(",", online.OrderBy(i => i.index).Select(i => "{\"name\":\"" + i.name + "\",\"url\":\"" + i.url + "\",\"balanser\":\"" + i.plugin + "\"}"));
            return ContentTo($"[{online_result.Replace("{localhost}", host)}]");
        }
        #endregion

        #region checkSearch
        async Task checkSearch(string memkey, List<(string code, int index, bool work)> links, int indexList, dynamic init, int index, string name, string uri, string plugin,
                               string id, string imdb_id, long kinopoisk_id, long tmdb_id, string title, string original_title, string original_language, string source,  int year, int serial, bool life, string rchtype)
        {
            try
            {
                string srq = uri.Replace("{localhost}", $"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}");
                var header = uri.Contains("{localhost}") ? HeadersModel.Init(("xhost", host), ("xscheme", HttpContext.Request.Scheme), ("localrequest", AppInit.rootPasswd)) : null;

                string checkuri = $"{srq}{(srq.Contains("?") ? "&" : "?")}id={HttpUtility.UrlEncode(id)}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&tmdb_id={tmdb_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&original_language={original_language}&source={source}&year={year}&serial={serial}&rchtype={rchtype}&checksearch=true";
                string res = await Http.Get(AccsDbInvk.Args(checkuri, HttpContext), timeoutSeconds: 10, headers: header);

                if (string.IsNullOrEmpty(res))
                    res = string.Empty;

                bool rch = res.Contains("\"rch\":true");
                bool work = rch || res.Contains("data-json=") 
                    || res.Contains("\"type\":\"movie\"") 
                    || res.Contains("\"type\":\"episode\"")
                    || res.Contains("\"type\":\"season\"");

                string quality = string.Empty;
                string balanser = plugin.Contains("/") ? plugin.Split("/")[1] : plugin;

                #region –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞
                if (work && life)
                {
                    foreach (string q in new string[] { "2160", "1080", "720", "480", "360" })
                    {
                        if (res.Contains("<!--q:"))
                        {
                            quality = " - " + Regex.Match(res, "<!--q:([^>]+)-->").Groups[1].Value;
                            break;
                        }
                        else if (res.Contains($"\"{q}p\"") || res.Contains($">{q}p<") || res.Contains($"<!--{q}p-->"))
                        {
                            quality = $" - {q}p";
                            break;
                        }
                    }

                    if (quality == "2160")
                        quality = res.Contains("HDR") ? " - 4K HDR" : " - 4K";

                    if (init != null)
                    {
                        if (balanser == "filmix")
                        {
                            if (!init.pro)
                                quality = string.IsNullOrEmpty(init.token) ? " - 480p" : " - 720p";
                        }

                        if (balanser == "alloha")
                            quality = string.IsNullOrEmpty(quality) ? (init.m4s ? " ~ 2160p" : " ~ 1080p") : quality;

                        if (balanser == "rezka" || balanser == "rhs")
                        {
                            string rezkaq = init.premium ? " ~ 2160p" : " ~ 720p";
                            quality = string.IsNullOrEmpty(quality) ? rezkaq : quality;
                        }

                        if (balanser == "collaps")
                            quality = init.dash ? " ~ 1080p" : " ~ 720p";
                    }

                    if (quality == string.Empty)
                    {
                        switch (balanser)
                        {
                            case "fxapi":
                            case "filmix":
                            case "filmixtv":
                            case "kinopub":
                            case "vokino":
                            case "vokino-alloha":
                            case "vokino-filmix":
                            case "alloha":
                            case "remux":
                            case "pidtor":
                            case "rhsprem":
                            case "animelib":
                            case "mirage":
                            case "videodb":
                            case "iptvonline":
                            case "plvideo":
                            case "rutubemovie":
                            case "vkmovie":
                                quality = " ~ 2160p";
                                break;
                            case "kinobase":
                            case "kinogo":
                            case "getstv":
                            case "zetflix":
                            case "vcdn":
                            case "videocdn":
                            case "lumex":
                            case "vibix":
                            case "videoseed":
                            case "eneyida":
                            case "kinoukr":
                            case "ashdi":
                            case "hdvb":
                            case "anilibria":
                            case "aniliberty":
                            case "redheadsound":
                            case "iframevideo":
                            case "animego":
                            case "lostfilmhd":
                            case "vdbmovies":
                            case "collaps-dash":
                            case "fancdn":
                            case "cdnvideohub":
                            case "moonanime":
                            case "playembed":
                            case "rgshows":
                            case "twoembed":
                            case "vidsrc":
                            case "smashystream":
                            case "hydraflix":
                            case "movpi":
                            case "videasy":
                            case "vidlink":
                            case "autoembed":
                            case "veoveo":
                            case "vokino-vibix":
                            case "vokino-monframe":
                            case "vokino-remux":
                            case "vokino-ashdi":
                            case "vokino-hdvb":
                                quality = " ~ 1080p";
                                break;
                            case "voidboost":
                            case "animedia":
                            case "animevost":
                            case "animebesst":
                            case "kodik":
                            case "kinotochka":
                            case "rhs":
                                quality = " ~ 720p";
                                break;
                            case "kinokrad":
                            case "kinoprofi":
                            case "seasonvar":
                                quality = " - 480p";
                                break;
                            case "cdnmovies":
                                quality = " - 360p";
                                break;
                            default:
                                break;
                        }

                        if (balanser == "vokino")
                            quality = res.Contains("4K HDR") ? " - 4K HDR" : res.Contains("4K ") ? " - 4K" : quality;
                    }
                }
                #endregion

                if (!name.Contains(" - ") && AppInit.conf.online.showquality && !string.IsNullOrEmpty(quality))
                {
                    name = Regex.Replace(name, " ~ .*$", "");
                    name += quality;
                }

                links[indexList] = ("{" + $"\"name\":\"{name}\",\"url\":\"{uri}\",\"index\":{index},\"show\":{work.ToString().ToLower()},\"balanser\":\"{plugin}\",\"rch\":{rch.ToString().ToLower()}" + "}", index, work);
            }
            catch (Exception ex) { Console.WriteLine("checkSearch: " + ex.ToString()); }
        }
        #endregion
    }
}
```

## File: Online/Controllers/Collaps.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Collaps;

namespace Online.Controllers
{
    public class Collaps : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/collaps")]
        [Route("lite/collaps-dash")]
        async public ValueTask<ActionResult> Index(long orid, string imdb_id, long kinopoisk_id, string title, string original_title, int s = -1, bool origsource = false, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.Collaps, (j, i, c) =>
            {
                if (j.ContainsKey("two"))
                    i.two = c.two;
                if (j.ContainsKey("dash"))
                    i.dash = c.dash;
                return i;
            });

            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            if (similar || (orid == 0 && kinopoisk_id == 0 && string.IsNullOrWhiteSpace(imdb_id)))
                return await Search(title, origsource, rjson);

            string module = HttpContext.Request.Path.Value.StartsWith("/lite/collaps-dash") ? "dash" : "hls";
            if (module == "dash")
                init.dash = true;
            else if (init.two)
                init.dash = false;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var oninvk = new CollapsInvoke
            (
               host,
               init.corsHost(),
               init.dash,
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl), httpHeaders(init)) : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               onstreamtofile => rch.enable ? onstreamtofile : HostStreamProxy(init, onstreamtofile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            reset:
            var cache = await InvokeCache<EmbedModel>($"collaps:view:{imdb_id}:{kinopoisk_id}:{orid}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(imdb_id, kinopoisk_id, orid);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => 
            {
                string html = oninvk.Html(cache.Value, imdb_id, kinopoisk_id, orid, title, original_title, s, vast: init.vast, rjson: rjson, headers: httpHeaders(init.host, init.headers_stream));
                if (module == "dash")
                    html = html.Replace("lite/collaps", "lite/collaps-dash");

                return html;

            }, origsource: origsource, gbcache: !rch.enable);
        }


        [HttpGet]
        [Route("lite/collaps-search")]
        async public ValueTask<ActionResult> Search(string title, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.Collaps);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            reset: 
            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var cache = await InvokeCache<ResultSearch[]>($"collaps:search:{title}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string uri = $"{init.apihost}/list?token={init.token}&name={HttpUtility.UrlEncode(title)}";
                var root = rch.enable ? await rch.Get<JObject>(uri) : await Http.Get<JObject>(uri, timeoutSeconds: 8, proxy: proxy);
                if (root == null || !root.ContainsKey("results"))
                    return res.Fail("results");

                return root["results"].ToObject<ResultSearch[]>();
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () =>
            {
                var stpl = new SimilarTpl(cache.Value.Length);

                foreach (var j in cache.Value)
                {
                    string uri = $"{host}/lite/collaps?orid={j.id}";
                    stpl.Append(j.name ?? j.origin_name, j.year.ToString(), string.Empty, uri, PosterApi.Size(j.poster));
                }

                return rjson ? stpl.ToJson() : stpl.ToHtml();

            }, origsource: origsource, gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/iRemux.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace Online.Controllers
{
    public class iRemux : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.iRemux);

        #region iRemuxInvoke
        public iRemuxInvoke InitRemuxInvoke()
        {
            var proxy = proxyManager.Get();
            var init = AppInit.conf.iRemux;

            return new iRemuxInvoke
            (
               host,
               init.corsHost(),
               ongettourl => Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, cookie: init.cookie, headers: httpHeaders(init)),
               (url, data) => Http.Post(init.cors(url), data, timeoutSeconds: 8, proxy: proxy, cookie: init.cookie, headers: httpHeaders(init)),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
               requesterror: () => proxyManager.Refresh()
            );
        }
        #endregion

        [HttpGet]
        [Route("lite/remux")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int year, string href, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.iRemux);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title ?? original_title) || year == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var oninvk = InitRemuxInvoke();

            var content = await InvokeCache($"remux:{title}:{original_title}:{year}:{href}", cacheTime(40, init: init), () => oninvk.Embed(title, original_title, year, href), proxyManager);
            if (content == null)
                return OnError();

            return ContentTo(oninvk.Html(content, title, original_title, year, rjson: rjson));
        }


        [HttpGet]
        [Route("lite/remux/movie")]
        async public ValueTask<ActionResult> Movie(string linkid, string quality, string title, string original_title)
        {
            var init = await loadKit(AppInit.conf.iRemux);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var oninvk = InitRemuxInvoke();

            string weblink = await InvokeCache($"remux:view:{linkid}:{proxyManager.CurrentProxyIp}", cacheTime(20), () => oninvk.Weblink(linkid), proxyManager);
            if (weblink == null)
                return OnError();

            return ContentTo(oninvk.Movie(weblink, quality, title, original_title, vast: init.vast));
        }
    }
}

```

## File: Online/Controllers/HDVB.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.HDVB;

namespace Online.Controllers
{
    public class HDVB : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.HDVB);

        [HttpGet]
        [Route("lite/hdvb")]
        async public ValueTask<ActionResult> Index(long kinopoisk_id, string title, string original_title, int t = -1, int s = -1, bool origsource = false, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.HDVB);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            if (similar || kinopoisk_id == 0)
                return await SpiderSearch(title, origsource, rjson);

            #region search
            reset:
            JArray data = await search(rch, kinopoisk_id);
            if (data == null)
            {
                if(init.rhub && init.rhub_fallback)
                {
                    init.rhub = false;
                    goto reset;
                }

                return OnError();
            }
            #endregion

            if (data.First.Value<string>("type") == "movie")
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, data.Count);

                foreach (var m in data)
                {
                    string link = $"{host}/lite/hdvb/video?kinopoisk_id={kinopoisk_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&iframe={HttpUtility.UrlEncode(m.Value<string>("iframe_url"))}";
                    
                    mtpl.Append(m.Value<string>("translator"), link, "call", accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true"));
                }

                return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                if (s == -1)
                {
                    var tpl = new SeasonTpl();
                    var tmp_season = new HashSet<string>();

                    foreach (var voice in data)
                    {
                        foreach (var season in voice.Value<JArray>("serial_episodes"))
                        {
                            string season_name = $"{season.Value<int>("season_number")} —Å–µ–∑–æ–Ω";
                            if (tmp_season.Contains(season_name))
                                continue;

                            tmp_season.Add(season_name);

                            string link = $"{host}/lite/hdvb?rjson={rjson}&serial=1&kinopoisk_id={kinopoisk_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&s={season.Value<int>("season_number")}";
                            tpl.Append(season_name, link, season.Value<int>("season_number"));
                        }
                    }

                    return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                }
                else
                {
                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var vtpl = new VoiceTpl();

                    for (int i = 0; i < data.Count; i++)
                    {
                        if (data[i].Value<JArray>("serial_episodes").FirstOrDefault(i => i.Value<int>("season_number") == s) == null)
                            continue;

                        if (t == -1)
                            t = i;

                        string link = $"{host}/lite/hdvb?rjson={rjson}&serial=1&kinopoisk_id={kinopoisk_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&s={s}&t={i}";
                        vtpl.Append(data[i].Value<string>("translator"), t == i, link);
                    }
                    #endregion

                    var etpl = new EpisodeTpl();
                    string iframe = HttpUtility.UrlEncode(data[t].Value<string>("iframe_url"));
                    string translator = HttpUtility.UrlEncode(data[t].Value<string>("translator"));

                    string sArhc = s.ToString();

                    foreach (int episode in data[t].Value<JArray>("serial_episodes").FirstOrDefault(i => i.Value<int>("season_number") == s).Value<JArray>("episodes").ToObject<List<int>>())
                    {
                        string link = $"{host}/lite/hdvb/serial?title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&iframe={iframe}&t={translator}&s={s}&e={episode}";
                        string streamlink = accsArgs($"{link.Replace("/serial", "/serial.m3u8")}&play=true");

                        etpl.Append($"{episode} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.ToString(), link, "call", streamlink: streamlink);
                    }

                    if (rjson)
                        return ContentTo(etpl.ToJson(vtpl));

                    return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                }
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/hdvb/video")]
        [Route("lite/hdvb/video.m3u8")]
        async public ValueTask<ActionResult> Video(string iframe, string title, string original_title, bool play)
        {
            var init = await loadKit(AppInit.conf.HDVB);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            var proxy = proxyManager.Get();

            string memKey = $"video:view:video:{iframe}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out string urim3u8))
                {
                    var header = httpHeaders(init, HeadersModel.Init(
                        ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                        ("sec-fetch-dest", "document"),
                        ("sec-fetch-mode", "navigate"),
                        ("sec-fetch-site", "none")
                    ));

                    reset:
                    string html = rch.enable ? await rch.Get(iframe, header) :
                                               await Http.Get(iframe, timeoutSeconds: 8, proxy: proxy, headers: header);

                    if (html != null)
                    {
                        string vid = "vid11";
                        string href = Regex.Match(html, "\"href\":\"([^\"]+)\"").Groups[1].Value;
                        string csrftoken = Regex.Match(html, "\"key\":\"([^\"]+)\"").Groups[1].Value.Replace("\\", "");
                        string file = Regex.Match(html, "\"file\":\"([^\"]+)\"").Groups[1].Value.Replace("\\", "");
                        file = Regex.Replace(file, "^/playlist/", "/");
                        file = Regex.Replace(file, "\\.txt$", "");

                        if (!string.IsNullOrWhiteSpace(href) && !string.IsNullOrWhiteSpace(file) && !string.IsNullOrWhiteSpace(csrftoken))
                        {
                            string origin = Regex.Match(iframe, "(https?://[^/]+)").Groups[1].Value;

                            header = httpHeaders(init, HeadersModel.Init(
                                ("accept", "*/*"),
                                ("origin", origin),
                                ("referer", $"{origin}/"),
                                ("sec-fetch-dest", "empty"),
                                ("sec-fetch-mode", "cors"),
                                ("sec-fetch-site", "same-site"),
                                ("x-csrf-token", csrftoken)
                            ));

                            urim3u8 = rch.enable ? await rch.Post($"https://{vid}.{href}/playlist/{file}.txt", "", header) :
                                                   await Http.Post($"https://{vid}.{href}/playlist/{file}.txt", "", timeoutSeconds: 8, proxy: proxy, headers: header);

                            if (urim3u8 != null)
                            {
                                if (!urim3u8.Contains("/index.m3u8"))
                                {
                                    file = Regex.Match(urim3u8, "\"file\":\"([^\"]+)\"").Groups[1].Value.Replace("\\", "");
                                    file = Regex.Replace(file, "^/playlist/", "/");
                                    file = Regex.Replace(file, "\\.txt$", "");

                                    if (!string.IsNullOrEmpty(file))
                                    {
                                        urim3u8 = rch.enable ? await rch.Post($"https://{vid}.{href}/playlist/{file}.txt", "", header) :
                                                               await Http.Post($"https://{vid}.{href}/playlist/{file}.txt", "", timeoutSeconds: 8, proxy: proxy, headers: header);
                                    }
                                }
                            }
                        }
                    }

                    if (string.IsNullOrEmpty(urim3u8))
                    {
                        if (!rch.enable)
                            proxyManager.Refresh();

                        if (init.rhub && init.rhub_fallback)
                        {
                            init.rhub = false;
                            goto reset;
                        }

                        return OnError();
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, urim3u8, cacheTime(20, init: init));
                }

                string m3u8 = HostStreamProxy(init, urim3u8, proxy: proxy);

                if (play)
                    return RedirectToPlay(m3u8);

                return ContentTo(VideoTpl.ToJson("play", m3u8, (title ?? original_title), vast: init.vast));
            });
        }
        #endregion

        #region Serial
        [HttpGet]
        [Route("lite/hdvb/serial")]
        [Route("lite/hdvb/serial.m3u8")]
        async public ValueTask<ActionResult> Serial(string iframe, string t, string s, string e, string title, string original_title, bool play)
        {
            var init = await loadKit(AppInit.conf.HDVB);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            var proxy = proxyManager.Get();

            string memKey = $"video:view:serial:{iframe}:{t}:{s}:{e}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out string urim3u8))
                {
                    string vid = "vid11";

                    #region playlist
                    string mkey_playlist = $"video:view:playlist:{iframe}";
                    if (!hybridCache.TryGetValue(mkey_playlist, out (List<Folder> playlist, string href, List<HeadersModel> header) cache))
                    {
                        cache.header = httpHeaders(init, HeadersModel.Init(
                            ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                            ("sec-fetch-dest", "iframe"),
                            ("sec-fetch-mode", "navigate"),
                            ("sec-fetch-site", "cross-site"),
                            ("referer", $"{init.host}/")
                        ));

                        reset_playlist:
                        string html = rch.enable ? await rch.Get(iframe, cache.header) :
                                                   await Http.Get(iframe, timeoutSeconds: 8, proxy: proxy, headers: cache.header);

                        if (html != null)
                        {
                            string href = Regex.Match(html, "\"href\":\"([^\"]+)\"").Groups[1].Value;
                            string csrftoken = Regex.Match(html, "\"key\":\"([^\"]+)\"").Groups[1].Value.Replace("\\", "");
                            string file = Regex.Match(html, "\"file\":\"([^\"]+)\"").Groups[1].Value.Replace("\\", "");
                            file = Regex.Replace(file, "^/playlist/", "/");
                            file = Regex.Replace(file, "\\.txt$", "");

                            if (!string.IsNullOrWhiteSpace(href) && !string.IsNullOrWhiteSpace(file) && !string.IsNullOrWhiteSpace(csrftoken))
                            {
                                string origin = Regex.Match(iframe, "(https?://[^/]+)").Groups[1].Value;

                                cache.header = httpHeaders(init, HeadersModel.Init(
                                    ("accept", "*/*"),
                                    ("origin", origin),
                                    ("referer", $"{origin}/"),
                                    ("sec-fetch-dest", "empty"),
                                    ("sec-fetch-mode", "cors"),
                                    ("sec-fetch-site", "same-site"),
                                    ("x-csrf-token", csrftoken)
                                ));

                                cache.playlist = rch.enable ? await rch.Post<List<Folder>>($"https://{vid}.{href}/playlist/{file}.txt", "", cache.header) :
                                                              await Http.Post<List<Folder>>($"https://{vid}.{href}/playlist/{file}.txt", "", timeoutSeconds: 8, proxy: proxy, headers: cache.header, IgnoreDeserializeObject: true);

                                if (cache.playlist != null && cache.playlist.Count > 0)
                                {
                                    cache.href = href;
                                    hybridCache.Set(mkey_playlist, cache, cacheTime(40, init: init));
                                }
                                else
                                {
                                    if (!rch.enable)
                                        proxyManager.Refresh();

                                    if (init.rhub && init.rhub_fallback)
                                    {
                                        init.rhub = false;
                                        goto reset_playlist;
                                    }

                                    return OnError();
                                }
                            }
                        }
                    }
                    #endregion

                    #region episode
                    reset_episode:
                    string episode = cache.playlist.First(i => i.id == s).folder.First(i => i.episode == e).folder.First(i => i.title == t).file;
                    if (!string.IsNullOrEmpty(episode))
                    {
                        episode = Regex.Replace(episode, "^/playlist/", "/");
                        episode = Regex.Replace(episode, "\\.txt$", "");

                        urim3u8 = rch.enable ? await rch.Post($"https://{vid}.{cache.href}/playlist/{episode}.txt", "", cache.header) :
                                               await Http.Post($"https://{vid}.{cache.href}/playlist/{episode}.txt", "", timeoutSeconds: 8, proxy: proxy, headers: cache.header);
                    }

                    if (string.IsNullOrEmpty(urim3u8) || !urim3u8.Contains("/index.m3u8"))
                    {
                        if (!rch.enable)
                            proxyManager.Refresh();

                        if (init.rhub && init.rhub_fallback)
                        {
                            init.rhub = false;
                            goto reset_episode;
                        }

                        return OnError();
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, urim3u8, cacheTime(20, init: init));
                    #endregion
                }

                if (play)
                    return Redirect(HostStreamProxy(init, urim3u8, proxy: proxy));

                return Content("{\"method\":\"play\",\"url\":\"" + HostStreamProxy(init, urim3u8, proxy: proxy) + "\",\"title\":\"" + (title ?? original_title) + "\"}", "application/json; charset=utf-8");
            });
        }
        #endregion

        #region SpiderSearch
        [HttpGet]
        [Route("lite/hdvb-search")]
        async public ValueTask<ActionResult> SpiderSearch(string title, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.HDVB);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            reset:
            var cache = await InvokeCache<JArray>($"hdvb:search:{title}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string uri = $"{init.host}/api/videos.json?token={init.token}&title={HttpUtility.UrlEncode(title)}";
                var root = rch.enable ? await rch.Get<JArray>(uri) :
                                        await Http.Get<JArray>(uri, timeoutSeconds: 8, proxy: proxyManager.Get());

                if (root == null)
                    return res.Fail("results");

                return root;
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () =>
            {
                var hash = new HashSet<long>(cache.Value.Count);
                var stpl = new SimilarTpl(cache.Value.Count);

                foreach (var j in cache.Value)
                {
                    var kinopoisk_id = j.Value<long?>("kinopoisk_id");
                    if (kinopoisk_id > 0 && !hash.Contains((long)kinopoisk_id))
                    {
                        hash.Add((long)kinopoisk_id);
                        string uri = $"{host}/lite/hdvb?kinopoisk_id={kinopoisk_id}";
                        stpl.Append(j.Value<string>("title_ru") ?? j.Value<string>("title_en"), j.Value<int>("year").ToString(), string.Empty, uri, PosterApi.Size(j.Value<string>("poster")));
                    }
                }

                return rjson ? stpl.ToJson() : stpl.ToHtml();

            }, origsource: origsource);
        }
        #endregion


        #region search
        async ValueTask<JArray> search(RchClient rch, long kinopoisk_id)
        {
            string memKey = $"hdvb:view:{kinopoisk_id}";

            if (!hybridCache.TryGetValue(memKey, out JArray root, inmemory: false))
            {
                var init = await loadKit(AppInit.conf.HDVB);
                string uri = $"{init.host}/api/videos.json?token={init.token}&id_kp={kinopoisk_id}";

                root = rch.enable ? await rch.Get<JArray>(uri) :
                                    await Http.Get<JArray>(uri, timeoutSeconds: 8, proxy: proxyManager.Get());

                if (root == null)
                {
                    if (!rch.enable)
                        proxyManager.Refresh();
                    return null;
                }

                if (!rch.enable)
                    proxyManager.Success();

                hybridCache.Set(memKey, root, cacheTime(40, init: init), inmemory: false);
            }

            if (root.Count == 0)
                return null;

            return root;
        }
        #endregion
    }
}

```

## File: Online/Controllers/RezkaPremium.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Shared.Models.Online.Rezka;
using Shared.Models.Online.Settings;
using System.Management;
using System.Net;

namespace Online.Controllers
{
    public class RezkaPremium : BaseOnlineController
    {
        #region InitRezkaInvoke
        static string uid = null, typeuid = null;

        static void genUid()
        {
            if (uid == null)
            {
                try
                {
                    uid = System.IO.File.ReadAllText("/etc/machine-id");
                    typeuid = "machine-id";
                }
                catch
                {
                    if (AppInit.Win32NT)
                    {
                        try
                        {
                            using (var searcher = new ManagementObjectSearcher("select ProcessorId from Win32_Processor"))
                            {
                                foreach (var item in searcher.Get())
                                    uid = item["ProcessorId"].ToString();
                            }

                            typeuid = "ProcessorId";
                        }
                        catch { }
                    }
                }

                if (string.IsNullOrEmpty(uid))
                {
                    if (System.IO.File.Exists("cache/uid"))
                    {
                        uid = System.IO.File.ReadAllText("cache/uid");
                    }
                    else
                    {
                        uid = CrypTo.SHA256(DateTime.Now.ToBinary().ToString());
                        System.IO.File.WriteAllText("cache/uid", uid);
                    }

                    typeuid = "generate";
                }
            }
        }

        List<HeadersModel> apiHeaders(RezkaSettings init, string cookie)
        {
            genUid();
            return httpHeaders(init, HeadersModel.Init(
               ("X-Lampac-App", "1"),
               ("X-Lampac-Version", $"{appversion}.{minorversion}"),
               ("X-Lampac-Device-Id", $"{(AppInit.Win32NT ? "win32" : "linux")}:uid/{Regex.Replace(uid, "[^a-zA-Z0-9]+", "").Trim()}:type_uid/{typeuid}"),
               ("X-Lampac-Cookie", cookie),
               ("User-Agent", requestInfo.UserAgent)
            ));
        }

        async public ValueTask<(RezkaInvoke invk, string cookie, string log)> InitRezkaInvoke(RezkaSettings init)
        {
            init.host = new RezkaSettings(null, "kwwsv=22odps1df").host;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);
            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            genUid();

            var cook = await getCookie(init, proxy);
            if (string.IsNullOrEmpty(cook.cookie))
                return (null, null, cook.log);

            var headers = apiHeaders(init, cook.cookie);

            string country = requestInfo.Country;

            if (!rch.enable && country != null)
                headers.Add(new HeadersModel("X-Real-IP", requestInfo.IP));

            if (init.forceua)
                country = "UA";

            init.premium = true;

            return (new RezkaInvoke
            (
                host,
                init,
                (url, _) => rch.enable ? rch.Get(url, headers) : Http.Get(url, timeoutSeconds: 8, proxy: proxy, headers: headers, statusCodeOK: !url.Contains("do=search")),
                (url, data, _) => rch.enable ? rch.Post(url, data, headers) : Http.Post(url, data, timeoutSeconds: 8, proxy: proxy, headers: headers),
                streamfile => HostStreamProxy(init, RezkaInvoke.fixcdn(country, init.uacdn, streamfile), proxy: proxy),
                requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            ), cook.cookie, null);
        }
        #endregion

        #region RezkaBind
        [HttpGet]
        [AllowAnonymous]
        [Route("/lite/rhs/bind")]
        async public Task<ActionResult> RezkaBind(string login, string pass)
        {
            string html = string.Empty;

            if (string.IsNullOrWhiteSpace(login) || string.IsNullOrWhiteSpace(pass))
            {
                html = "–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç–∞ rezka.ag <br> <br><form method=\"get\" action=\"/lite/rhs/bind\"><input type=\"text\" name=\"login\" placeholder=\"email\"> &nbsp; &nbsp; <input type=\"text\" name=\"pass\" placeholder=\"–ø–∞—Ä–æ–ª—å\"><br><br><button>–ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è</button></form> ";
            }
            else
            {
                var result = await getCookie(new RezkaSettings(null, "kwwsv=22odps1df") 
                {
                    login = login,
                    passwd = pass
                }, timeoutError: 5);

                if (string.IsNullOrEmpty(result.cookie))
                {
                    html = "–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ ;(<br><br>" + result.log.Replace("\n", "<br>");
                }
                else
                {
                    html = "–î–æ–±–∞–≤—å—Ç–µ –≤ init.conf<br><br>\"RezkaPrem\": {<br>&nbsp;&nbsp;\"enable\": true,<br>&nbsp;&nbsp;\"cookie\": \"" + result.cookie + "\"<br>},<br>\"Rezka\": {<br>&nbsp;&nbsp;\"enable\": false<br>}";
                }
            }

            return Content(html, "text/html; charset=utf-8");
        }
        #endregion

        #region Initialization
        ValueTask<RezkaSettings> Initialization()
        {
            return loadKit(AppInit.conf.RezkaPrem, (j, i, c) =>
            {
                if (j.ContainsKey("uacdn"))
                    i.uacdn = c.uacdn;

                if (j.ContainsKey("forceua"))
                    i.forceua = c.forceua;

                if (j.ContainsKey("reserve"))
                    i.reserve = c.reserve;

                return i;
            });
        }
        #endregion

        [HttpGet]
        [Route("lite/rhsprem")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int clarification, int year, int s = -1, string href = null, bool rjson = false, int serial = -1, bool similar = false, string source = null, string id = null)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(href) && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() is "rezka" or "hdrezka")
                    href = id;
            }

            var proxyManager = new ProxyManager(init);

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: serial == 0 ? null : -1);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.enable)
            {
                if (!AppInit.conf.rch.enable)
                    return ShowError(RchClient.ErrorMsg);

                if (string.IsNullOrEmpty(init.cookie))
                    return ShowError($"rhub —Ä–∞–±–æ—Ç–∞–µ—Ç —á–µ—Ä–µ–∑ cookie - {host}/lite/rhs/bind");
            }

            if (string.IsNullOrWhiteSpace(href) && string.IsNullOrWhiteSpace(title))
                return OnError("href/title = null");

            var onrezka = await InitRezkaInvoke(init);
            if (onrezka.invk == null)
                return OnError("authorization error ;(", weblog: onrezka.log);

            var oninvk = onrezka.invk;

            #region search
            string search_uri = null;

            if (string.IsNullOrEmpty(href))
            {
                var search = await InvokeCache<SearchModel>($"rhsprem:search:{title}:{original_title}:{clarification}:{year}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    var content = await oninvk.Search(title, original_title, clarification, year);
                    if (content == null || (content.IsEmpty && content.content != null))
                        return res.Fail(content.content ?? "content");

                    return content;
                });

                if (search.ErrorMsg != null && search.ErrorMsg.Contains("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞"))
                    return ShowError(search.ErrorMsg);

                if (similar || string.IsNullOrEmpty(search.Value?.href))
                {
                    if (search.Value?.IsEmpty == true)
                        return ShowError(search.Value.content ?? "–ø–æ–∏—Å–∫ –Ω–µ –¥–∞–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤");

                    return OnResult(search, () =>
                    {
                        if (search.Value.similar == null)
                            return string.Empty;

                        var stpl = new SimilarTpl(search.Value.similar.Count);

                        foreach (var similar in search.Value.similar)
                        {
                            string link = $"{host}/lite/rhsprem?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&href={HttpUtility.UrlEncode(similar.href)}";

                            stpl.Append(similar.title, similar.year, string.Empty, link, PosterApi.Size(similar.img));
                        }

                        return rjson ? stpl.ToJson() : stpl.ToHtml();
                    });
                }

                href = search.Value.href;
                search_uri = search.Value.search_uri;
            }
            #endregion

            var cache = await InvokeCache<EmbedModel>($"rhsprem:{href}", cacheTime(10, init: init), rch.enable ? null : proxyManager, async res => 
            {
                return await oninvk.Embed(href, search_uri);
            });

            return OnResult(cache, () => oninvk.Html(cache.Value, accsArgs(string.Empty), title, original_title, s, href, true, rjson).Replace("/rezka", "/rhsprem"), gbcache: !rch.enable);
        }


        #region Serial
        [HttpGet]
        [Route("lite/rhsprem/serial")]
        async public ValueTask<ActionResult> Serial(string title, string original_title, string href, long id, int t, int s = -1, bool rjson = false, bool similar = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(href))
                return OnError("href = null");

            var onrezka = await InitRezkaInvoke(init);
            if (onrezka.invk == null)
                return OnError("authorization error ;(", weblog: onrezka.log);

            var oninvk = onrezka.invk;

            var proxyManager = new ProxyManager(init);

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var cache_root = await InvokeCache<Episodes>($"rhsprem:view:serial:{id}:{t}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.SerialEmbed(id, t);
            });

            var cache_content = await InvokeCache<EmbedModel>($"rhsprem:{href}", cacheTime(10, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(href, null);
            });

            return ContentTo(oninvk.Serial(cache_root.Value, cache_content.Value, accsArgs(string.Empty), title, original_title, href, id, t, s, true, rjson).Replace("/rezka", "/rhsprem"));
        }
        #endregion

        #region Movie
        [HttpGet]
        [Route("lite/rhsprem/movie")]
        [Route("lite/rhsprem/movie.m3u8")]
        async public ValueTask<ActionResult> Movie(string title, string original_title, long id, int t, int director = 0, int s = -1, int e = -1, string favs = null, bool play = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var onrezka = await InitRezkaInvoke(init);
            if (onrezka.invk == null)
                return OnError("authorization error ;(", weblog: onrezka.log);

            var oninvk = onrezka.invk;
            var proxyManager = new ProxyManager(init);

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: s == -1 ? null : -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var cache = await InvokeCache<MovieModel>($"rhsprem:view:get_cdn_series:{id}:{t}:{director}:{s}:{e}:{onrezka.cookie}", cacheTime(5, mikrotik: 1, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Movie(id, t, director, s, e, favs);
            });

            string result = oninvk.Movie(cache.Value, title, original_title, play, vast: init.vast);
            if (result == null)
                return OnError("result = null", weblog: oninvk.requestlog);

            if (play)
                return RedirectToPlay(result);

            return ContentTo(result.Replace("/rezka", "/rhsprem"));
        }
        #endregion


        #region getCookie
        static Dictionary<string, string> authCookie = new Dictionary<string, string>();

        async ValueTask<(string cookie, string log)> getCookie(RezkaSettings init, WebProxy proxy = null, int timeoutError = 15)
        {
            if (!string.IsNullOrEmpty(init.cookie))
                return ($"dle_user_taken=1; {Regex.Match(init.cookie, "(dle_user_id=[^;]+;)")} {Regex.Match(init.cookie, "(dle_password=[^;]+)")}".Trim(), null);

            if (string.IsNullOrEmpty(init.login) || string.IsNullOrEmpty(init.passwd))
                return default;

            if (authCookie.TryGetValue(init.login, out string _cook))
                return (_cook, null);

            if (memoryCache.TryGetValue($"rhsprem:login:{init.login}", out _))
                return default;

            string loglines = string.Empty;
            memoryCache.Set($"rhsprem:login:{init.login}", 0, TimeSpan.FromSeconds(timeoutError));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false,
                    AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate
                })
                {

                    if (proxy != null)
                    {
                        clientHandler.UseProxy = true;
                        clientHandler.Proxy = proxy;
                    }
                    else { clientHandler.UseProxy = false; }

                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(15);

                        foreach (var item in apiHeaders(init, string.Empty))
                            client.DefaultRequestHeaders.Add(item.name, item.val);

                        var postParams = new Dictionary<string, string>
                        {
                            { "login_name", init.login },
                            { "login_password", init.passwd },
                            { "login_not_save", "0" }
                        };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            loglines += $"POST: {init.host}/ajax/login/\n";
                            loglines += $"{postContent.ReadAsStringAsync().Result}\n";

                            using (var response = await client.PostAsync($"{init.host}/ajax/login/", postContent))
                            {
                                loglines += $"\n\nStatusCode: {(int)response.StatusCode}\n";

                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string cookie = string.Empty;

                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrEmpty(line))
                                            continue;

                                        if (line.Contains("=deleted;"))
                                            continue;

                                        loglines += $"Set-Cookie: {line}\n";

                                        if (line.Contains("dle_user_id") || line.Contains("dle_password"))
                                            cookie += $"{line.Split(";")[0]}; ";
                                    }

                                    if (cookie.Contains("dle_user_id") && cookie.Contains("dle_password"))
                                    {
                                        _cook = $"dle_user_taken=1; {Regex.Replace(cookie.Trim(), ";$", "")}";
                                        authCookie.TryAdd(init.login, _cook);
                                    }

                                    loglines += $"authCookie: {authCookie}\n\n";
                                    loglines += await response.Content.ReadAsStringAsync();
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception ex) { loglines += $"\n\nHDRezka Exception: {ex}"; }

            return (_cook, loglines);
        }
        #endregion
    }
}

```

## File: Online/Controllers/VideoDB.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Shared.Models.Online.Settings;
using Shared.Models.Online.VideoDB;
using Shared.PlaywrightCore;
using System.Net;

namespace Online.Controllers
{
    public class VideoDB : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/videodb")]
        async public ValueTask<ActionResult> Index(long kinopoisk_id, string title, string original_title, string t, int s = -1, int sid = -1, bool origsource = false, bool rjson = false, int serial = -1)
        {
            var init = await loadKit(AppInit.conf.VideoDB);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (kinopoisk_id == 0)
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: serial == 0 ? null : -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            var oninvk = new VideoDBInvoke
            (
               host,
               init.apihost,
               (url, head) => rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : black_magic(url, init, proxy),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy.proxy)
            );

            reset: 
            var cache = await InvokeCache<EmbedModel>(rch.ipkey($"videodb:view:{kinopoisk_id}", proxyManager), cacheTime(20, init: init), proxyManager, async res =>
            {
                return await oninvk.Embed(kinopoisk_id);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, accsArgs(string.Empty), kinopoisk_id, title, original_title, t, s, sid, rjson), origsource: origsource);
        }


        #region Manifest
        [HttpGet]
        [Route("lite/videodb/manifest")]
        [Route("lite/videodb/manifest.m3u8")]
        async public ValueTask<ActionResult> Manifest(string link, bool serial)
        {
            var init = await loadKit(AppInit.conf.VideoDB);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(link))
                return OnError();

            bool play = HttpContext.Request.Path.Value.Contains(".m3u8");

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: serial ? -1 : null);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            string memKey = rch.ipkey($"videodb:video:{link}", proxyManager);

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out string location))
                {
                    reset:

                    try
                    {
                        var headers = httpHeaders(init, HeadersModel.Init(
                            ("sec-fetch-dest", "empty"),
                            ("sec-fetch-mode", "cors"),
                            ("sec-fetch-site", "same-site"),
                            ("origin", "{host}"),
                            ("referer", "{host}/")
                        ));

                        if (rch.enable)
                        {
                            var res = await rch.Headers(link, null, headers);
                            location = res.currentUrl;
                        }
                        else if (init.priorityBrowser == "http")
                        {
                            location = await Http.GetLocation(link, httpversion: 2, timeoutSeconds: 8, proxy: proxy.proxy, headers: headers);
                        }
                        else
                        {
                            using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                            {
                                var page = await browser.NewPageAsync(init.plugin, proxy: proxy.data);
                                if (page == null)
                                    return null;

                                browser.SetFailedUrl(link);

                                await page.RouteAsync("**/*", async route =>
                                {
                                    try
                                    {
                                        if (route.Request.Url.Contains("api/chromium/iframe"))
                                        {
                                            await route.ContinueAsync();
                                            return;
                                        }

                                        if (route.Request.Url == link)
                                        {
                                            await route.ContinueAsync(new RouteContinueOptions { Headers = headers.ToDictionary() });

                                            var response = await page.WaitForResponseAsync(route.Request.Url);
                                            if (response != null)
                                                response.Headers.TryGetValue("location", out location);

                                            browser.SetPageResult(location);
                                            PlaywrightBase.WebLog(route.Request, response, location, proxy.data);
                                            return;
                                        }

                                        await route.AbortAsync();
                                    }
                                    catch { }
                                });

                                PlaywrightBase.GotoAsync(page, PlaywrightBase.IframeUrl(link));

                                location = await browser.WaitPageResult();
                            }
                        }
                    }
                    catch { }

                    if (string.IsNullOrEmpty(location) || link == location)
                    {
                        if (init.rhub && init.rhub_fallback)
                        {
                            init.rhub = false;
                            goto reset;
                        }
                        return OnError();
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, location, cacheTime(20, rhub: 2, init: init));
                }

                string hls = HostStreamProxy(init, location, proxy: proxy.proxy);

                if (play)
                    return RedirectToPlay(hls);

                return ContentTo(VideoTpl.ToJson("play", hls, "auto", vast: init.vast));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<string> black_magic(string uri, OnlinesSettings init, (WebProxy proxy, (string ip, string username, string password) data) baseproxy)
        {
            try
            {
                var headers = httpHeaders(init, HeadersModel.Init(
                    ("sec-fetch-dest", "iframe"),
                    ("sec-fetch-mode", "navigate"),
                    ("sec-fetch-site", "cross-site"),
                    ("referer", "{host}/")
                ));

                if (init.priorityBrowser == "http")
                    return await Http.Get(uri, httpversion: 2, timeoutSeconds: 8, proxy: baseproxy.proxy, headers: headers);

                using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                {
                    var page = await browser.NewPageAsync(init.plugin, init.headers, proxy: baseproxy.data, imitationHuman: init.imitationHuman).ConfigureAwait(false);
                    if (page == null)
                        return null;

                    browser.SetFailedUrl(uri);

                    await page.RouteAsync("**/*", async route =>
                    {
                        try
                        {
                            if (route.Request.Url.StartsWith(init.host))
                            {
                                await route.FulfillAsync(new RouteFulfillOptions
                                {
                                    Body = PlaywrightBase.IframeHtml(uri)
                                });
                            }
                            else if (route.Request.Url == uri)
                            {
                                string html = null;
                                await route.ContinueAsync();

                                var response = await page.WaitForResponseAsync(route.Request.Url);
                                if (response != null)
                                    html = await response.TextAsync();

                                browser.SetPageResult(html);
                                PlaywrightBase.WebLog(route.Request, response, html, baseproxy.data);
                                return;
                            }
                            else
                            {
                                if (!init.imitationHuman || route.Request.Url.EndsWith(".m3u8") || route.Request.Url.Contains("/cdn-cgi/challenge-platform/"))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                }
                                else
                                {
                                    if (await PlaywrightBase.AbortOrCache(page, route))
                                        return;

                                    await route.ContinueAsync();
                                }
                            }
                        }
                        catch { }
                    });

                    PlaywrightBase.GotoAsync(page, init.host);

                    return await browser.WaitPageResult().ConfigureAwait(false);
                }
            }
            catch { return null; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/FilmixTV.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.FilmixTV;
using Shared.Models.Online.Settings;
using System.Text;
using System.Threading;
using F = System.IO.File;

namespace Online.Controllers
{
    /// <summary>
    /// –ê–≤—Ç–æ—Ä https://github.com/fellicienne
    /// https://github.com/immisterio/Lampac/pull/41
    /// </summary>
    public class FilmixTV : BaseOnlineController
    {
        static readonly SemaphoreSlim _accessTokenLock = new SemaphoreSlim(1, 1);

        [HttpGet]
        [Route("lite/filmixtv")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int clarification, int year, int postid, int t = -1, int? s = null, bool origsource = false, bool rjson = false, bool similar = false, string source = null, string id = null)
        {
            if (postid == 0 && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() is "filmix" or "filmixapp")
                {
                    if (!int.TryParse(id, out postid))
                        int.TryParse(Regex.Match(id, "/([0-9]+)-").Groups[1].Value, out postid);
                }
            }

            var init = await loadKit(AppInit.conf.FilmixTV, (j, i, c) =>
            {
                if (j.ContainsKey("pro"))
                    i.pro = c.pro;

                i.user_apitv = c.user_apitv;
                i.passwd_apitv = c.passwd_apitv;
                return i;
            });

            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.user_apitv))
                return OnError("user_apitv", gbcache: false);

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            #region accessToken
            var tokenResult = await EnsureAccessToken(init, proxyManager);

            if (!tokenResult.IsSuccess)
                return ShowError(HttpUtility.HtmlEncode(tokenResult.ErrorMsg));

            init.token_apitv = tokenResult.Token;
            #endregion

            var headers = httpHeaders(init, HeadersModel.Init
            (
                ("Authorization", $"Bearer {init.token_apitv}"),
                ("hash", init.hash_apitv)
            ));

            var oninvk = new FilmixTVInvoke
            (
               host,
               init.corsHost(),
               ongettourl => Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: headers),
               (url, data) => Http.Post(init.cors(url), data, timeoutSeconds: 8, headers: headers),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
               requesterror: () => proxyManager.Refresh(),
               rjson: rjson
            );

            if (postid == 0)
            {
                var search = await InvokeCache<Shared.Models.Online.Filmix.SearchResult>($"filmixtv:search:{title}:{original_title}:{clarification}:{similar}", cacheTime(40, init: init), proxyManager, async res =>
                {
                    return await oninvk.Search(title, original_title, clarification, year, similar);
                });

                if (!search.IsSuccess)
                    return OnError(search.ErrorMsg);

                if (search.Value.id == 0)
                    return ContentTo(rjson ? search.Value.similars.Value.ToJson() : search.Value.similars.Value.ToHtml());

                postid = search.Value.id;
            }

            var cache = await InvokeCache<RootObject>($"filmixtv:post:{postid}:{init.token_apitv}", cacheTime(20, init: init), proxyManager, onget: async res =>
            {
                string json = await Http.Get($"{init.corsHost()}/api-fx/post/{postid}/video-links", timeoutSeconds: 8, headers: headers);

                return oninvk.Post(json);
            });

            return OnResult(cache, () => oninvk.Html(cache.Value, init.pro, postid, title, original_title, t, s, vast: init.vast), origsource: origsource);
        }


        #region [Copilot AI] EnsureAccessToken
        async ValueTask<(bool IsSuccess, string Token, string ErrorMsg)> EnsureAccessToken(FilmixSettings init, ProxyManager proxyManager)
        {
            try
            {
                await _accessTokenLock.WaitAsync(TimeSpan.FromMinutes(1));

                string hashFile = $"cache/filmixtv-{CrypTo.md5(init.user_apitv)}.hash";

                if (F.Exists(hashFile))
                {
                    init.hash_apitv = F.ReadAllText(hashFile);
                }
                else
                {
                    var rtk = await Http.Get<JObject>($"{init.corsHost()}/api-fx/request-token", timeoutSeconds: 30);
                    if (rtk == null || !rtk.ContainsKey("token"))
                        return (false, null, "rtk");

                    string hash = rtk.Value<string>("token");
                    if (string.IsNullOrEmpty(hash))
                        return (false, null, "hash");

                    init.hash_apitv = hash;
                }

                var auth = await InvokeCache<string>($"filmixtv:accessToken:{init.user_apitv}:{init.passwd_apitv}:{init.hash_apitv}", TimeSpan.FromHours(5), proxyManager, async res =>
                {
                    JObject root_auth = null;

                    string authFile = $"cache/filmixtv-{CrypTo.md5(init.hash_apitv)}.auth";

                    if (F.Exists(authFile))
                    {
                        string refreshToken = Regex.Match(F.ReadAllText(authFile), "\"refreshToken\": ?\"([^\"]+)\"").Groups[1].Value;
                        root_auth = await Http.Get<JObject>($"{init.corsHost()}/api-fx/refresh?refreshToken={HttpUtility.UrlEncode(refreshToken)}", headers: HeadersModel.Init("hash", init.hash_apitv), timeoutSeconds: 30);
                    }
                    else
                    {
                        var data = new System.Net.Http.StringContent($"{{\"user_name\":\"{init.user_apitv}\",\"user_passw\":\"{init.passwd_apitv}\",\"session\":true}}", Encoding.UTF8, "application/json");
                        root_auth = await Http.Post<JObject>($"{init.corsHost()}/api-fx/auth", data, headers: HeadersModel.Init("hash", init.hash_apitv), timeoutSeconds: 30);
                    }

                    string accessToken = root_auth?.GetValue("accessToken")?.ToString();
                    if (string.IsNullOrEmpty(accessToken))
                    {
                        if (root_auth != null)
                        {
                            if (root_auth.ContainsKey("msg"))
                                return res.Fail(root_auth.Value<string>("msg"));

                            return res.Fail(root_auth.ToString());
                        }

                        return res.Fail("accessToken");
                    }

                    F.WriteAllText(hashFile, init.hash_apitv);
                    F.WriteAllText(authFile, root_auth.ToString());
                    return accessToken;
                });

                if (!auth.IsSuccess)
                    return (false, null, auth.ErrorMsg);

                return (true, auth.Value, null);
            }
            catch (Exception ex) { return (false, null, ex.Message); }
            finally
            {
                _accessTokenLock.Release();
            }
        }
        #endregion
    }
}

```

## File: Online/Controllers/IptvOnline.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;
using System.Net;
using System.Text;

namespace Online.Controllers
{
    public class IptvOnline : BaseOnlineController
    {
        #region Bind
        [HttpGet]
        [AllowAnonymous]
        [Route("lite/iptvonline/bind")]
        public ActionResult Bind(string KEY, string ID)
        {
            string html = string.Empty;

            if (string.IsNullOrWhiteSpace(KEY) || string.IsNullOrWhiteSpace(ID))
            {
                html = "–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ <a href='https://iptv.online/ru/dealers/api' target=_blank>https://iptv.online/ru/dealers/api</a> <br> <br><form method=\"get\" action=\"/lite/iptvonline/bind\"><input type=\"text\" name=\"KEY\" placeholder=\"X-API-KEY\"> &nbsp; &nbsp; <input type=\"text\" name=\"ID\" placeholder=\"X-API-ID\"><br><br><button>–ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è</button></form> ";
            }
            else
            {
                html = "–î–æ–±–∞–≤—å—Ç–µ –≤ init.conf<br><br>\"IptvOnline\": {<br>&nbsp;&nbsp;\"enable\": true,<br>&nbsp;&nbsp;\"token\": \"" + $"{ID}:{KEY}" + "\"<br>}";
            }

            return Content(html, "text/html; charset=utf-8");
        }
        #endregion

        [HttpGet]
        [Route("lite/iptvonline")]
        async public ValueTask<ActionResult> Index(string imdb_id, long kinopoisk_id, string title, string original_title, int serial = -1, int s = -1, bool rjson = false, bool origsource = false)
        {
            var init = await loadKit(AppInit.conf.IptvOnline);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            #region AUTH
            if (!hybridCache.TryGetValue($"iptvonline:auth:{init.token}", out string codeauth))
            {
                var auth = await Http.Post<JObject>($"{init.host}/v1/api/auth", "", timeoutSeconds: 8, proxy: proxy, useDefaultHeaders: false, headers: HeadersModel.Init(
                    ("X-API-KEY", init.token.Split(":")[1]),
                    ("X-API-ID", init.token.Split(":")[0])
                ));

                if (auth == null)
                {
                    proxyManager.Refresh();
                    return null;
                }

                string code = auth.Value<string>("code");
                if (string.IsNullOrEmpty(code))
                    return null;

                codeauth = code;
                hybridCache.Set($"iptvonline:auth:{init.token}", codeauth, DateTime.Now.AddHours(2));
            }
            #endregion

            var data = await search(init, proxyManager, proxy, codeauth, serial, imdb_id, kinopoisk_id, title, original_title);
            if (data == null)
                return OnError();

            if (data.Value<string>("message") != null)
                return ShowError(data.Value<string>("message"));

            #region media
            string id = data.Value<string>("id");
            var cache = await InvokeCache<JToken>($"IptvOnline:{id}:{init.token}", cacheTime(20, init: init), proxyManager, async res =>
            {
                var header = httpHeaders(init, HeadersModel.Init(
                    ("X-API-AUTH", codeauth),
                    ("X-API-ID", init.token.Split(":")[0])
                ));

                string uri = $"{init.host}/v1/api/media/{(serial == 1 ? "serials" : "movies")}/{id}/";
                var root = await Http.Get<JObject>(init.cors(uri), timeoutSeconds: 8, proxy: proxy, headers: header, useDefaultHeaders: false);

                if (root == null || !root.ContainsKey("data"))
                    return res.Fail("data");

                return root["data"];
            });
            #endregion

            return OnResult(cache, () =>
            {
                if (cache.Value.Value<string>("category") == "movie")
                {
                    #region –§–∏–ª—å–º
                    var mtpl = new MovieTpl(title, original_title, 1);

                    string stream = HostStreamProxy(init, cache.Value["medias"].First.Value<string>("url") + "#.m3u8", proxy: proxy);
                    string quality = cache.Value.Value<int?>("quality")?.ToString();
                    if (quality != null)
                        quality += "p";

                    mtpl.Append(quality ?? title, stream, vast: init.vast);

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∞–ª
                    if (s == -1)
                    {
                        string enc_title = HttpUtility.UrlEncode(title);
                        string enc_original_title = HttpUtility.UrlEncode(original_title);

                        string quality = cache.Value.Value<string>("quality");
                        if (quality != null)
                            quality += "p";

                        var tpl = new SeasonTpl(quality);

                        foreach (var media in cache.Value["medias"])
                        {
                            int season = media.Value<int>("season");
                            string link = $"{host}/lite/iptvonline?rjson={rjson}&serial={serial}&kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&title={enc_title}&original_title={enc_original_title}&s={season}";
                            tpl.Append($"{season} —Å–µ–∑–æ–Ω", link, season);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        var etpl = new EpisodeTpl();
                        string sArhc = s.ToString();

                        foreach (var episode in cache.Value["medias"].First(i => i.Value<int>("season") == s).Value<JArray>("episodes"))
                        {
                            string name = episode.Value<string>("title");
                            string file = episode.Value<string>("url") + "#.m3u8";

                            if (string.IsNullOrEmpty(file))
                                continue;

                            string stream = HostStreamProxy(init, file, proxy: proxy);
                            etpl.Append(name ?? $"{episode.Value<int>("episode")} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.Value<int>("episode").ToString(), stream, vast: init.vast);
                        }

                        return rjson ? etpl.ToJson() : etpl.ToHtml();
                    }
                    #endregion
                }

            }, origsource: origsource);
        }


        #region search
        async ValueTask<JToken> search(OnlinesSettings init, ProxyManager proxyManager, WebProxy proxy, string codeauth, int serial, string imdb_id, long kinopoisk_id, string title, string original_title)
        {
            string memKey = $"iptvonline:view:{kinopoisk_id}:{imdb_id}:{title}:{original_title}";

            if (!hybridCache.TryGetValue(memKey, out JToken data))
            {
                string stitle = StringConvert.SearchName(title);
                string sorigtitle = StringConvert.SearchName(original_title);

                async Task<JToken> goSearch(string search)
                {
                    if (string.IsNullOrEmpty(search))
                        return null;

                    var header = httpHeaders(init, HeadersModel.Init(
                        ("X-API-AUTH", codeauth),
                        ("X-API-ID", init.token.Split(":")[0])
                    ));

                    string uri = $"{init.host}/v1/api/media/{(serial == 1 ? "serials" : "movies")}";
                    var data = new System.Net.Http.StringContent(JsonConvert.SerializeObject(new { search }), Encoding.UTF8, "application/json");

                    var video = await Http.Get<JObject>(uri, body: data, timeoutSeconds: 8, proxy: proxy, headers: header, useDefaultHeaders: false);

                    if (video == null)
                    {
                        proxyManager.Refresh();
                        return null;
                    }

                    if (video.ContainsKey("message") && video.Value<string>("message") == "No Subscribed By Media API")
                        return video;

                    if (!video.ContainsKey("data"))
                        return null;

                    foreach (var item in video["data"])
                    {
                        if (kinopoisk_id > 0)
                        {
                            if (item.Value<long?>("kinopoisk") == kinopoisk_id) 
                                return item;   
                        }

                        if (!string.IsNullOrEmpty(imdb_id))
                        {
                            if ($"tt{item.Value<long?>("imdb")}" == imdb_id)
                                return item;
                        }
                    }

                    foreach (var item in video["data"])
                    {
                        if (sorigtitle != null)
                        {
                            if (StringConvert.SearchName(item.Value<string>("orig_title")) == sorigtitle)
                                return item;
                        }

                        if (stitle != null)
                        {
                            if (StringConvert.SearchName(item.Value<string>("ru_title")) == stitle)
                                return item;
                        }
                    }

                    return null;
                }

                data = await goSearch(original_title) ?? await goSearch(title);
                if (data == null)
                    return null;

                proxyManager.Success();
                hybridCache.Set(memKey, data, cacheTime(30, init: init));
            }

            return data;
        }
        #endregion
    }
}

```

## File: Online/Controllers/IframeVideo.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;

namespace Online.Controllers
{
    public class IframeVideo : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.IframeVideo);

        [HttpGet]
        [Route("lite/iframevideo")]
        async public Task<ActionResult> Index(string imdb_id, long kinopoisk_id, string title, string original_title)
        {
            var init = await loadKit(AppInit.conf.IframeVideo);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var frame = await iframe(imdb_id, kinopoisk_id);
            if (frame.type == null || (frame.type != "movie" && frame.type != "anime"))
                return OnError();

            bool firstjson = true;
            string html = "<div class=\"videos__line\">";

            var match = new Regex("<a href='/[^/]+/([^/]+)/iframe[^']+' [^>]+><span title='[^']+'>([^<]+)</span>").Match(frame.content);
            while (match.Success)
            {
                if (!string.IsNullOrWhiteSpace(match.Groups[1].Value))
                {
                    string link = $"{host}/lite/iframevideo/video?title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&type={frame.type}&cid={frame.cid}&token={match.Groups[1].Value}";
                    string streamlink = $"{link.Replace("/video", "/video.m3u8")}&play=true";

                    html += "<div class=\"videos__item videos__movie selector " + (firstjson ? "focused" : "") + "\" media=\"\" data-json='{\"method\":\"call\",\"url\":\"" + link + "\",\"stream\":\"" + streamlink + "\"}'><div class=\"videos__item-imgbox videos__movie-imgbox\"></div><div class=\"videos__item-title\">" + match.Groups[2].Value + "</div></div>";
                    firstjson = false;
                }
                match = match.NextMatch();
            }

            if (firstjson)
            {
                string _v = Regex.Match(html, "<span class='muted'><span [^>]+>([^<]+)</span>").Groups[1].Value;
                if (string.IsNullOrWhiteSpace(_v))
                    _v = Regex.Match(html, "<span class='muted'>([^<\n\r]+)").Groups[1].Value;

                string token = Regex.Match(frame.path, "/[^/]+/([^/]+)/iframe").Groups[1].Value;
                if (string.IsNullOrWhiteSpace(token))
                    return Content(string.Empty);

                string voice = string.IsNullOrWhiteSpace(_v) ? "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é" : _v;
                string link = $"{host}/lite/iframevideo/video?title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&type={frame.type}&cid={frame.cid}&token={token}";
                string streamlink = $"{link.Replace("/video", "/video.m3u8")}&play=true";

                html += "<div class=\"videos__item videos__movie selector focused\" media=\"\" data-json='{\"method\":\"call\",\"url\":\"" + link + "\",\"stream\":\"" + streamlink + "\"}'><div class=\"videos__item-imgbox videos__movie-imgbox\"></div><div class=\"videos__item-title\">" + voice + "</div></div>";
            }

            return Content(html + "</div>", "text/html; charset=utf-8");
        }


        #region Video
        [HttpGet]
        [Route("lite/iframevideo/video")]
        [Route("lite/iframevideo/video.m3u8")]
        async public Task<ActionResult> Video(string type, int cid, string token, string title, string original_title, bool play)
        {
            var init = await loadKit(AppInit.conf.IframeVideo);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var proxy = proxyManager.Get();

            string memKey = $"iframevideo:view:video:{type}:{cid}:{token}";
            if (!hybridCache.TryGetValue(memKey, out string urim3u8))
            {
                string json = await Http.Post($"{init.cdnhost}/loadvideo", $"token={token}&type={type}&season=&episode=&mobile=false&id={cid}&qt=480", timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init, HeadersModel.Init(
                    ("DNT", "1"),
                    ("Origin", init.cdnhost),
                    ("P-REF", string.Empty),
                    ("Referer", $"{init.cdnhost}/"),
                    ("Sec-Fetch-Dest", "empty"),
                    ("Sec-Fetch-Mode", "cors"),
                    ("Sec-Fetch-Site", "same-origin"),
                    ("X-REF", $"{init.host}/"),
                    ("sec-ch-ua", "\"Google Chrome\";v=\"113\", \"Chromium\";v=\"113\", \"Not-A.Brand\";v=\"24\""),
                    ("sec-ch-ua-mobile", "?0"),
                    ("sec-ch-ua-platform", "\"Windows\"")
                )));

                urim3u8 = Regex.Match(json ?? "", "{\"src\":\"([^\"]+)\"").Groups[1].Value.Replace("\\", "");
                if (string.IsNullOrWhiteSpace(urim3u8))
                    return OnError(proxyManager);

                hybridCache.Set(memKey, urim3u8, cacheTime(20, init: init));
            }

            string url = HostStreamProxy(init, urim3u8, proxy: proxy);
            if (play)
                return RedirectToPlay(url);

            return Content("{\"method\":\"play\",\"url\":\"" + url + "\",\"title\":\"" + (title ?? original_title) + "\"}", "application/json; charset=utf-8");
        }
        #endregion

        #region iframe
        async ValueTask<(string content, string type, int cid, string path)> iframe(string imdb_id, long kinopoisk_id)
        {
            var init = AppInit.conf.IframeVideo;

            if (kinopoisk_id == 0 && string.IsNullOrWhiteSpace(imdb_id))
                return (null, null, 0, null);

            string memKey = $"iframevideo:view:{imdb_id}:{kinopoisk_id}";

            if (!hybridCache.TryGetValue(memKey, out (string content, string type, int cid, string path) res))
            {
                string uri = $"{init.apihost}/api/v2/search?imdb={imdb_id}&kp={kinopoisk_id}";
                if (!string.IsNullOrWhiteSpace(init.token))
                    uri = $"{init.apihost}/api/v2/movies?kp={kinopoisk_id}&imdb={imdb_id}&api_token={init.token}";

                var proxy = proxyManager.Get();
                var root = await Http.Get<JObject>(uri, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));
                if (root == null)
                    return (null, null, 0, null);

                var item = root.Value<JArray>("results")?[0];
                if (item == null)
                    return (null, null, 0, null);

                res.cid = item.Value<int>("cid");
                res.path = item.Value<string>("path");
                res.type = item.Value<string>("type");

                res.content = await Http.Get(res.path, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init, HeadersModel.Init(
                    ("DNT", "1"),
                    ("Referer", $"{init.host}/"),
                    ("Sec-Fetch-Dest", "iframe"),
                    ("Sec-Fetch-Mode", "navigate"),
                    ("Sec-Fetch-Site", "cross-site"),
                    ("Upgrade-Insecure-Requests", "1"),
                    ("sec-ch-ua", "\"Google Chrome\";v=\"113\", \"Chromium\";v=\"113\", \"Not-A.Brand\";v=\"24\""),
                    ("sec-ch-ua-mobile", "?0"),
                    ("sec-ch-ua-platform", "\"Windows\"")
                )));

                if (res.content == null)
                {
                    proxyManager.Refresh();
                    return (null, null, 0, null);
                }

                hybridCache.Set(memKey, res, cacheTime(20, init: init));
            }

            return res;
        }
        #endregion
    }
}

```

## File: Online/Controllers/Lumex.cs
```
Ôªøusing DnsClient;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Routing;
using Microsoft.Playwright;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Lumex;
using Shared.PlaywrightCore;
using System.Threading;

namespace Online.Controllers
{
    public class Lumex : BaseOnlineController
    {
        //static Lumex()
        //{
        //    FixHostEvent();
        //}

        //static Dictionary<string, string> ips = null;

        //public static void FixHostEvent()
        //{
        //    if (ips != null) 
        //        return;

        //    ips = new Dictionary<string, string>();

        //    EventListener.ProxyApiCreateHttpRequest += async httpRequestModel =>
        //    {
        //        if (!httpRequestModel.uri.Host.Contains("mediaaly.pro"))
        //            return;

        //        string targetHost = httpRequestModel.uri.Host.Replace("mediaaly.pro", "saicdn.com");

        //        if (!ips.TryGetValue(targetHost, out string dns_ip))
        //        {
        //            using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10)))
        //            {
        //                var lookup = new LookupClient();
        //                var queryType = await lookup.QueryAsync(targetHost, QueryType.A, cancellationToken: cts.Token);

        //                dns_ip = queryType?.Answers?.ARecords()?.FirstOrDefault()?.Address?.ToString();

        //                if (string.IsNullOrEmpty(dns_ip))
        //                    return;

        //                ips.TryAdd(targetHost, dns_ip);
        //            }
        //        }

        //        var newUri = new Uri(httpRequestModel.requestMessage.RequestUri.AbsoluteUri.Replace(httpRequestModel.uri.Host, dns_ip));
        //        httpRequestModel.requestMessage.RequestUri = newUri;
        //    };
        //}


        #region database
        static List<DatumDB> databaseCache;

        public static IEnumerable<DatumDB> database
        {
            get
            {
                if (AppInit.conf.multiaccess || databaseCache != null)
                    return databaseCache ??= JsonHelper.ListReader<DatumDB>("data/lumex.json", 105000);

                return JsonHelper.IEnumerableReader<DatumDB>("data/lumex.json");
            }
        }
        #endregion

        [HttpGet]
        [Route("lite/lumex")]
        async public ValueTask<ActionResult> Index(long content_id, string content_type, string imdb_id, long kinopoisk_id, string title, string original_title, string t, int clarification, int s = -1, int serial = -1, bool origsource = false, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.Lumex);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (init.priorityBrowser == "firefox")
            {
                if (Firefox.Status == PlaywrightStatus.disabled)
                    return OnError("Firefox disabled");
            }
            else if (init.priorityBrowser != "http")
            {
                if (Chromium.Status == PlaywrightStatus.disabled)
                    return OnError("Chromium disabled");
            }

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var oninvk = new LumexInvoke
            (
               init,
               (url, referer) => Http.Get(init.cors(url), referer: referer, timeoutSeconds: 8, proxy: proxy.proxy, headers: httpHeaders(init)),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy.proxy),
               host,
               requesterror: () => proxyManager.Refresh()
            );

            if (similar || (content_id == 0 && kinopoisk_id == 0 && string.IsNullOrEmpty(imdb_id)))
            {
                string memKey = $"lumex:search:{title}:{original_title}:{clarification}";

                return await InvkSemaphore(init, memKey, async () =>
                {
                    if (!hybridCache.TryGetValue(memKey, out SimilarTpl search))
                    {
                        search = await oninvk.Search(title, original_title, serial, clarification, database);
                        if (search.data?.Count == 0)
                            return OnError("search");

                        hybridCache.Set(memKey, search, cacheTime(40, init: init));
                    }

                    return ContentTo(rjson ? search.ToJson() : search.ToHtml());
                });
            }

            var cache = await InvokeCache<EmbedModel>($"videocdn:{content_id}:{content_type}:{kinopoisk_id}:{imdb_id}:{proxyManager.CurrentProxyIp}", cacheTime(10, init: init), proxyManager,  async res =>
            {
                string content_uri = null;
                var content_headers = new List<HeadersModel>();

                #region uri
                string targetUrl = $"https://p.{init.iframehost}/{init.clientId}";
                if (content_id > 0)
                {
                    targetUrl += $"/{content_type}/{content_id}";
                }
                else
                {
                    if (kinopoisk_id > 0)
                        targetUrl += $"?kp_id={kinopoisk_id}";
                    if (!string.IsNullOrEmpty(imdb_id))
                        targetUrl += (targetUrl.Contains("?") ? "&" : "?") + $"imdb_id={imdb_id}";
                }
                #endregion

                if (init.priorityBrowser == "http" && kinopoisk_id > 0)
                {
                    content_uri = $"https://api.{init.iframehost}/content?clientId={init.clientId}&contentType=short&kpId={kinopoisk_id}";
                    content_headers = HeadersModel.Init(Chromium.baseContextOptions.ExtraHTTPHeaders);
                    content_headers.Add(new HeadersModel("accept", "*/*"));
                    content_headers.Add(new HeadersModel("origin", $"https://p.{init.iframehost}"));
                    content_headers.Add(new HeadersModel("referer", $"https://p.{init.iframehost}/"));
                    content_headers.Add(new HeadersModel("sec-fetch-site", "same-site "));
                    content_headers.Add(new HeadersModel("sec-fetch-mode", "cors"));
                    content_headers.Add(new HeadersModel("sec-fetch-dest", "empty"));
                }
                else if (init.priorityBrowser == "scraping")
                {
                    #region Scraping
                    using (var browser = new Scraping(targetUrl, "/content\\?contentId=", null))
                    {
                        browser.OnRequest += e =>
                        {
                            if (Regex.IsMatch(e.HttpClient.Request.Url, "\\.(css|woff2|jpe?g|png|ico)") ||
                               !Regex.IsMatch(e.HttpClient.Request.Url, "(lumex|cloudflare|sentry|gstatic)\\."))
                            {
                                e.Ok(string.Empty);
                            }
                        };

                        var scrap = await browser.WaitPageResult(15);

                        if (scrap != null)
                        {
                            content_uri = scrap.Url;
                            foreach (var item in scrap.Headers)
                            {
                                if (item.Name.ToLower() is "host" or "accept-encoding" or "connection" or "range" or "cookie")
                                    continue;

                                content_headers.Add(new HeadersModel(item.Name, item.Value));
                            }
                        }
                    }
                    #endregion
                }
                else
                {
                    #region Playwright
                    try
                    {
                        using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                        {
                            var page = await browser.NewPageAsync(init.plugin, proxy: proxy.data).ConfigureAwait(false);
                            if (page == null)
                                return null;

                            await page.Context.ClearCookiesAsync(new BrowserContextClearCookiesOptions { Domain = $"api.{init.iframehost}", Name = "x-csrf-token" });

                            await page.RouteAsync("**/*", async route =>
                            {
                                try
                                {
                                    if (content_uri != null || browser.IsCompleted)
                                    {
                                        PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (route.Request.Url.Contains("/content?clientId="))
                                    {
                                        content_uri = route.Request.Url.Replace("%3D", "=").Replace("%3F", "&");
                                        foreach (var item in route.Request.Headers)
                                        {
                                            if (item.Key is "host" or "accept-encoding" or "connection" or "range" or "cookie")
                                                continue;

                                            content_headers.Add(new HeadersModel(item.Key, item.Value));
                                        }

                                        foreach (var h in new List<(string key, string val)>
                                        {
                                            ("sec-fetch-site", "same-site"),
                                            ("sec-fetch-mode", "cors"),
                                            ("sec-fetch-dest", "empty"),
                                        })
                                        {
                                            if (!route.Request.Headers.ContainsKey(h.key))
                                                content_headers.Add(new HeadersModel(h.key, h.val));
                                        }

                                        browser.SetPageResult(string.Empty);
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                        return;

                                    await route.ContinueAsync();
                                }
                                catch { }
                            });

                            PlaywrightBase.GotoAsync(page, targetUrl);
                            await browser.WaitPageResult().ConfigureAwait(false);
                        }
                    }
                    catch { }
                    #endregion
                }

                if (content_uri == null)
                    return res.Fail("content_uri");

                var result = await Http.BaseGetAsync(content_uri, proxy: proxy.proxy, headers: content_headers);

                if (string.IsNullOrEmpty(result.content))
                {
                    proxyManager.Refresh();
                    return res.Fail("content");
                }

                if (!result.response.Headers.TryGetValues("Set-Cookie", out var cook))
                {
                    proxyManager.Refresh();
                    return res.Fail("cook");
                }

                string csrf = Regex.Match(cook.FirstOrDefault() ?? "", "x-csrf-token=([^\n\r; ]+)").Groups[1].Value.Trim();
                if (string.IsNullOrEmpty(csrf))
                {
                    proxyManager.Refresh();
                    return res.Fail("csrf");
                }

                content_headers.Add(new HeadersModel("x-csrf-token", csrf.Split("%")[0]));
                content_headers.Add(new HeadersModel("cookie", $"x-csrf-token={csrf}"));

                var md = JsonConvert.DeserializeObject<JObject>(result.content)["player"].ToObject<EmbedModel>();
                md.csrf = CrypTo.md5(DateTime.Now.ToFileTime().ToString());

                hybridCache.Set(md.csrf, content_headers, DateTime.Now.AddDays(1));

                return md;
            });

            return OnResult(cache, () => oninvk.Html(cache.Value, accsArgs(string.Empty), content_id, content_type, imdb_id, kinopoisk_id, title, original_title, clarification, t, s, rjson: rjson), origsource: origsource);
        }


        #region Video
        [HttpGet]
        [Route("lite/lumex/video")]
        [Route("lite/lumex/video.m3u8")]
        async public ValueTask<ActionResult> Video(string playlist, string csrf, int max_quality)
        {
            var init = await loadKit(AppInit.conf.Lumex);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrEmpty(playlist) || string.IsNullOrEmpty(csrf))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            string memkey = $"lumex/video:{playlist}:{csrf}";

            return await InvkSemaphore(init, memkey, async () =>
            {
                if (!hybridCache.TryGetValue(memkey, out string hls))
                {
                    if (!hybridCache.TryGetValue(csrf, out List<HeadersModel> content_headers))
                        return OnError();

                    var result = await Http.Post<JObject>($"https://api.{init.iframehost}" + playlist, "", httpversion: 2, proxy: proxy, timeoutSeconds: 8, headers: content_headers);

                    if (result == null || !result.ContainsKey("url"))
                        return OnError();

                    string url = result.Value<string>("url");
                    if (string.IsNullOrEmpty(url))
                        return OnError();

                    if (url.StartsWith("/"))
                        hls = $"{init.scheme}:{url}";
                    else
                        hls = url;

                    hybridCache.Set(memkey, hls, cacheTime(20, init: init));
                }

                string sproxy(string uri) => HostStreamProxy(init, uri, proxy: proxy);

                if (max_quality > 0 && !init.hls)
                {
                    var streamquality = new StreamQualityTpl();

                    foreach (int q in new int[] { 1080, 720, 480, 360, 240 })
                    {
                        if (max_quality >= q)
                            streamquality.Append(sproxy(Regex.Replace(hls, "/hls\\.m3u8$", $"/{q}.mp4")), $"{q}p");
                    }

                    if (!streamquality.Any())
                        return OnError("streams");

                    var first = streamquality.Firts();
                    return ContentTo(VideoTpl.ToJson("play", first.link, first.quality, streamquality: streamquality, vast: init.vast));
                }

                return Redirect(sproxy(hls));
            });
        }
        #endregion
    }
}

```

## File: Online/Controllers/VkMovie.cs
```
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.VkMovie;

namespace Online.Controllers
{
    public class VkMovie : BaseOnlineController
    {
        static readonly int client_id = 52461373;
        static string access_token;
        static DateTime token_expires;

        [HttpGet]
        [Route("lite/vkmovie")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int year, int serial, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.VkMovie);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (serial == 1)
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            if (!await EnsureAnonymToken(init, proxy))
                return ShowError("token");

            string searchTitle = StringConvert.SearchName(title);

            reset:
            var cache = await InvokeCache<CatalogVideo[]>(rch.ipkey($"vkmovie:view:{searchTitle}:{year}", proxyManager), cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string url = $"{init.host}/method/catalog.getVideoSearchWeb2?v=5.264&client_id={client_id}";
                string data = $"screen_ref=search_video_service&input_method=keyboard_search_button&q={HttpUtility.UrlEncode($"{title} {year}")}&access_token={access_token}";

                var root = rch.enable
                    ? await rch.Post<JObject>(url, data, httpHeaders(init))
                    : await Http.Post<JObject>(url, data, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));

                if (root == null || !root.ContainsKey("response"))
                    return res.Fail("response");

                var videos = root["response"]?["catalog_videos"]?.ToObject<CatalogVideo[]>();
                if (videos == null)
                    return res.Fail("catalog_videos");

                return videos;
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () =>
            {
                var mtpl = new MovieTpl(title, original_title, cache.Value.Length);

                foreach (var item in cache.Value
                    .OrderByDescending(i => i.video?.files?.mp4_2160 != null)
                    .ThenByDescending(i => i.video?.files?.mp4_1440 != null)
                    .ThenByDescending(i => i.video?.files?.mp4_1080 != null))
                {
                    var video = item.video;
                    if (video == null || video.files == null)
                        continue;

                    string name = StringConvert.SearchName(video.title);
                    if (name == null || !name.Contains(searchTitle))
                        continue;

                    if (!(name.Contains(year.ToString()) || name.Contains((year + 1).ToString()) || name.Contains((year - 1).ToString())))
                        continue;

                    if (video.duration < 3000) // 50 min
                        continue;

                    if (name.Contains("—Ç—Ä–µ–π–ª–µ—Ä") || name.Contains("trailer") || 
                        name.Contains("–ø—Ä–µ–º—å–µ—Ä–∞") || name.Contains("–æ–±–∑–æ—Ä") ||
                        name.Contains("—Å–µ–∑–æ–Ω") || name.Contains("—Å–µ—Ä–∏–∞–ª") ||
                        name.Contains("—Å–µ—Ä–∏—è") || name.Contains("—Å–µ—Ä–∏–π"))
                        continue;

                    if (string.IsNullOrEmpty(video.files.mp4_2160) 
                        && string.IsNullOrEmpty(video.files.mp4_1440) 
                        && string.IsNullOrEmpty(video.files.mp4_1080) 
                        && string.IsNullOrEmpty(video.files.mp4_720))
                        continue;

                    var streams = new StreamQualityTpl();

                    void append(string url, string quality)
                    {
                        if (!string.IsNullOrEmpty(url))
                            streams.Append(HostStreamProxy(init, url, proxy: proxy), quality);
                    }

                    //append(video.files.hls, "auto");
                    append(video.files.mp4_2160, "2160p");
                    append(video.files.mp4_1440, "1440p");
                    append(video.files.mp4_1080, "1080p");
                    append(video.files.mp4_720, "720p");
                    append(video.files.mp4_480, "480p");
                    append(video.files.mp4_360, "360p");
                    append(video.files.mp4_240, "240p");
                    append(video.files.mp4_144, "144p");

                    if (!streams.Any())
                        continue;

                    SubtitleTpl? subtitles = null;

                    if (video.subtitles != null && video.subtitles.Length > 0)
                    {
                        var subtitleTpl = new SubtitleTpl(video.subtitles.Length);

                        foreach (var subtitle in video.subtitles)
                        {
                            if (string.IsNullOrEmpty(subtitle?.url))
                                continue;

                            string label = subtitle.manifest_name;
                            if (string.IsNullOrEmpty(label))
                                label = !string.IsNullOrEmpty(subtitle.title) ? subtitle.title : subtitle.lang;

                            subtitleTpl.Append(label, HostStreamProxy(init, subtitle.url, proxy: proxy));
                        }

                        if (!subtitleTpl.IsEmpty())
                            subtitles = subtitleTpl;
                    }

                    mtpl.Append(video.title, streams.Firts().link, streamquality: streams, subtitles: subtitles, headers: HeadersModel.Init(init.headers), vast: init.vast);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();

            }, gbcache: !rch.enable);
        }


        async ValueTask<bool> EnsureAnonymToken(BaseSettings init, System.Net.WebProxy proxy)
        {
            // If token exists and not expired - ok
            if (!string.IsNullOrEmpty(access_token) && token_expires > DateTime.UtcNow)
                return true;

            var sem = _semaphoreLocks.GetOrAdd("vkmovie:anonym_token", _ => new System.Threading.SemaphoreSlim(1, 1));

            try
            {
                await sem.WaitAsync(TimeSpan.FromSeconds(40));

                // double-check after acquiring semaphore
                if (!string.IsNullOrEmpty(access_token) && token_expires > DateTime.UtcNow)
                    return true;

                string url = "https://login.vk.com/?act=get_anonym_token";
                string postData = $"client_secret=o557NLIkAErNhakXrQ7A&client_id={client_id}&scopes=audio_anonymous%2Cvideo_anonymous%2Cphotos_anonymous%2Cprofile_anonymous&isApiOauthAnonymEnabled=false&version=1&app_id=6287487";

                JObject root = null;

                try
                {
                    root = await Http.Post<JObject>(url, postData, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));
                }
                catch
                {
                    // ignore
                }

                if (root == null || !root.ContainsKey("data"))
                    return false;

                var data = root["data"];

                string token = data?["access_token"]?.ToString();
                if (string.IsNullOrEmpty(token))
                    return false;

                access_token = token;

                long? expires = data?["expires"]?.ToObject<long?>()
                    ?? data?["expired_at"]?.ToObject<long?>()
                    ?? -1;

                // "expires":1760171110 (24—á) | 20—á
                token_expires = expires == -1 
                    ? DateTime.UtcNow.AddHours(10) 
                    : DateTimeOffset.FromUnixTimeSeconds(expires.Value).UtcDateTime.AddHours(-4);

                return true;
            }
            finally
            {
                sem.Release();
            }
        }
    }
}

```

## File: Online/Controllers/CDNmovies.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.CDNmovies;

namespace Online.Controllers
{
    public class CDNmovies : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/cdnmovies")]
        async public ValueTask<ActionResult> Index(long kinopoisk_id, string title, string original_title, int t, int s = -1, int sid = -1, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.CDNmovies);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (kinopoisk_id == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var oninvk = new CDNmoviesInvoke
            (
               host,
               init.corsHost(),
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl), httpHeaders(init)) : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               onstreamtofile => HostStreamProxy(init, onstreamtofile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            reset:
            var cache = await InvokeCache<Voice[]>($"cdnmovies:view:{kinopoisk_id}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(kinopoisk_id);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, kinopoisk_id, title, original_title, t, s, sid, vast: init.vast, rjson: rjson), origsource: origsource, gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/Filmix.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Filmix;

namespace Online.Controllers
{
    public class Filmix : BaseOnlineController
    {
        #region filmixpro
        [HttpGet]
        [AllowAnonymous]
        [Route("lite/filmixpro")]
        async public Task<ActionResult> Pro()
        {
            var token_request = await Http.Get<JObject>($"{AppInit.conf.Filmix.corsHost()}/api/v2/token_request?user_dev_apk=2.0.1&user_dev_id=&user_dev_name=Xiaomi&user_dev_os=11&user_dev_vendor=Xiaomi&user_dev_token=", useDefaultHeaders: false);

            if (token_request == null)
                return Content($"–Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ {AppInit.conf.Filmix.corsHost()}", "text/html; charset=utf-8");

            string html = "1. –û—Ç–∫—Ä–æ–π—Ç–µ <a href='https://filmix.my/consoles'>https://filmix.my/consoles</a> <br>";
            html += $"2. –í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ <b>{token_request.Value<string>("user_code")}</b><br>";
            html += $"<br><br><br>–î–æ–±–∞–≤—å—Ç–µ –≤ init.conf<br><br>";
            html += "\"Filmix\": {<br>&nbsp;&nbsp;\"token\": \"" + token_request.Value<string>("code") + "\",<br>&nbsp;&nbsp;\"pro\": true<br>}";

            return Content(html, "text/html; charset=utf-8");
        }
        #endregion

        [HttpGet]
        [Route("lite/filmix")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int clarification, int year, int postid, int t, int? s = null, bool origsource = false, bool rjson = false, bool similar = false, string source = null, string id = null)
        {
            if (postid == 0 && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() is "filmix" or "filmixapp")
                {
                    if (!int.TryParse(id, out postid))
                        int.TryParse(Regex.Match(id, "/([0-9]+)-").Groups[1].Value, out postid);
                }
            }

            var init = await loadKit(AppInit.conf.Filmix, (j, i, c) =>
            {
                if (j.ContainsKey("reserve"))
                    i.reserve = c.reserve;

                i.pro = c.pro;
                i.tokens = c.tokens;
                return i;
            });

            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("cors,web", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            string token = init.token;
            if (init.tokens != null && init.tokens.Length > 1)
                token = init.tokens[Random.Shared.Next(0, init.tokens.Length)];

            reset:

            var oninvk = new FilmixInvoke
            (
               init,
               host,
               token,
               ongettourl => rch.enable 
                    ? rch.Get(init.cors(ongettourl), httpHeaders(init), useDefaultHeaders: false) 
                    : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init), useDefaultHeaders: false),
               (url, data, head) => rch.enable 
                    ? rch.Post(init.cors(url), data, (head != null ? head : httpHeaders(init)), useDefaultHeaders: false) 
                    : Http.Post(init.cors(url), data, timeoutSeconds: 8, headers: head != null ? head : httpHeaders(init), useDefaultHeaders: false),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } },
               rjson: rjson
            );

            if (postid == 0)
            {
                var search = await InvokeCache<SearchResult>($"filmix:search:{title}:{original_title}:{year}:{clarification}:{similar}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    return await oninvk.Search(title, original_title, clarification, year, similar);
                });

                if (!search.IsSuccess)
                    return OnError(search.ErrorMsg);

                if (search.Value.id == 0)
                    return ContentTo(rjson ? search.Value.similars.Value.ToJson() : search.Value.similars.Value.ToHtml());

                postid = search.Value.id;
            }

            var cache = await InvokeCache<RootObject>($"filmix:post:{postid}:{token}", cacheTime(20, init: init), rch.enable ? null : proxyManager, onget: async res =>
            {
                return await oninvk.Post(postid);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, init.pro, postid, title, original_title, t, s, vast: init.vast), origsource: origsource, gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/VideoCDN.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Lumex;
using Shared.Models.Online.Settings;
using System.Net;
using System.Text;

namespace Online.Controllers
{
    public class VideoCDN : BaseOnlineController
    {
        static VideoCDN() 
        { 
            Directory.CreateDirectory("cache/logs/VideoCDN");

            //Lumex.FixHostEvent();
        }

        #region Initialization
        async ValueTask<LumexSettings> Initialization()
        {
            var init = await loadKit(AppInit.conf.VideoCDN, (j, i, c) =>
            {
                if (j.ContainsKey("log"))
                    i.log = c.log;

                i.clientId = c.clientId;
                i.username = c.username;
                i.password = c.password;
                i.domain = Regex.Replace(c.domain ?? "bwa", "^https?://", "").Split(".")[0];
                i.corseu = false;
                i.rhub = !i.disable_protection;

                return i;
            });

            init.rhub = !init.disable_protection;
            return init;
        }
        #endregion

        [HttpGet]
        [Route("lite/videocdn")]
        async public ValueTask<ActionResult> Index(long content_id, string content_type, string imdb_id, long kinopoisk_id, string title, string original_title, string t, int clarification, bool similar = false, int s = -1, int serial = -1, bool rjson = false, bool checksearch = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.username) || string.IsNullOrEmpty(init.password))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            if (content_id == 0)
            {
                var search = await InvokeCache($"videocdn:search:{imdb_id}:{kinopoisk_id}:{title ?? original_title}:{clarification}:{similar}", TimeSpan.FromHours(1),
                    () => Search(init, imdb_id, kinopoisk_id, title, original_title, serial, clarification, similar, proxy)
                );

                if (search.content_type == null && search.similar.data == null)
                    return OnError();

                if (search.similar.data != null)
                    return ContentTo(rjson ? search.similar.ToJson() : search.similar.ToHtml());

                content_id = search.content_id;
                content_type = search.content_type;
            }

            if (content_id == 0 || string.IsNullOrEmpty(content_type))
                return OnError();

            if (checksearch)
                return Content("data-json=");

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: serial == 0 ? null : -1);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string accessToken = await getToken(proxy);
            if (string.IsNullOrEmpty(accessToken))
                return OnError();

            var player = await getPlayer(content_id, content_type, accessToken, proxy);
            if (player == null)
                return OnError();

            if (player.content_type is "movie" or "anime")
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, player.media.Length);

                foreach (var media in player.media)
                {
                    string hash = CrypTo.md5($"{init.clientId}:{content_type}:{content_id}:{media.playlist}:{requestInfo.IP}");
                    string link = accsArgs($"{host}/lite/videocdn/video?rjson={rjson}&content_id={content_id}&content_type={content_type}&playlist={HttpUtility.UrlEncode(media.playlist)}&max_quality={media.max_quality}&translation_id={media.translation_id}&hash={hash}");
                    string streamlink = link.Replace("/videocdn/video", "/videocdn/video.m3u8") + "&play=true";

                    mtpl.Append(media.translation_name, link, "call", streamlink, quality: media.max_quality?.ToString());
                }

                return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                if (s == -1)
                {
                    var tpl = new SeasonTpl(player.media.First().max_quality?.ToString(), player.media.Length);

                    foreach (var media in player.media.OrderBy(s => s.season_id))
                    {
                        string link = $"{host}/lite/videocdn?rjson={rjson}&content_id={content_id}&content_type={content_type}&title={enc_title}&original_title={enc_original_title}&s={media.season_id}";
                        tpl.Append($"{media.season_id} —Å–µ–∑–æ–Ω", link, media.season_id);
                    }

                    return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                }
                else
                {
                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var vtpl = new VoiceTpl();
                    var tmpVoice = new HashSet<int>();

                    foreach (var media in player.media)
                    {
                        if (media.season_id != s)
                            continue;

                        foreach (var episode in media.episodes)
                        {
                            foreach (var voice in episode.media)
                            {
                                if (tmpVoice.Contains(voice.translation_id))
                                    continue;

                                tmpVoice.Add(voice.translation_id);

                                if (string.IsNullOrEmpty(t))
                                    t = voice.translation_id.ToString();

                                vtpl.Append(voice.translation_name, t == voice.translation_id.ToString(), $"{host}/lite/videocdn?rjson={rjson}&content_id={content_id}&content_type={content_type}&title={enc_title}&original_title={enc_original_title}&s={s}&t={voice.translation_id}");
                            }
                        }
                    }
                    #endregion

                    if (string.IsNullOrEmpty(t))
                        t = "0";

                    var etpl = new EpisodeTpl();
                    string sArhc = s.ToString();

                    foreach (var media in player.media)
                    {
                        if (media.season_id != s)
                            continue;

                        foreach (var episode in media.episodes)
                        {
                            foreach (var voice in episode.media)
                            {
                                if (voice.translation_id.ToString() != t)
                                    continue;

                                string hash = CrypTo.md5($"{init.clientId}:{content_type}:{content_id}:{voice.playlist}:{requestInfo.IP}");
                                string link = accsArgs($"{host}/lite/videocdn/video?content_id={content_id}&content_type={content_type}&playlist={HttpUtility.UrlEncode(voice.playlist)}&max_quality={voice.max_quality}&s={s}&e={episode.episode_id}&translation_id={voice.translation_id}&hash={hash}&serial=true");
                                string streamlink = link.Replace("/videocdn/video", "/videocdn/video.m3u8") + "&play=true";

                                etpl.Append($"{episode.episode_id} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.episode_id.ToString(), link, "call", streamlink: streamlink);
                            }
                        }
                    }

                    if (rjson)
                        return ContentTo(etpl.ToJson(vtpl));

                    return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                }
                #endregion
            }
        }


        #region Video
        static FileStream logFileStream = null;

        [HttpGet]
        [Route("lite/videocdn/video")]
        [Route("lite/videocdn/video.m3u8")]
        async public ValueTask<ActionResult> Video(string hash, long content_id, string content_type, string playlist, int max_quality, bool play, bool serial, int s, int e, int translation_id)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (hash != CrypTo.md5($"{init.clientId}:{content_type}:{content_id}:{playlist}:{requestInfo.IP}"))
                return OnError("hash", gbcache: false);

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: serial ? -1 : null);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            string accessToken = await getToken(proxy);
            if (string.IsNullOrEmpty(accessToken))
                return OnError("token", gbcache: false);

            try
            {
                if (init.log)
                {
                    string data = System.Text.Json.JsonSerializer.Serialize(new
                    {
                        time = DateTime.Now,
                        requestInfo.Country,
                        requestInfo.IP,
                        requestInfo.UserAgent,
                        video = new { content_id, content_type, playlist, accessToken }
                    });

                    string patchlog = $"cache/logs/VideoCDN/{DateTime.Today:dd-MM}.txt";

                    if (logFileStream == null || !System.IO.File.Exists(patchlog))
                        logFileStream = new FileStream(patchlog, FileMode.Append, FileAccess.Write);

                    var buffer = Encoding.UTF8.GetBytes($"{data}\n");
                    logFileStream.Write(buffer, 0, buffer.Length);
                    logFileStream.Flush();
                }
            }
            catch { }

            string clientIP = init.verifyip ? requestInfo.IP : "::1";
            string memkey = $"videocdn/video:{playlist}:{(init.streamproxy ? "" : clientIP)}";

            return await InvkSemaphore(init, memkey, async () =>
            {
                if (!hybridCache.TryGetValue(memkey, out string hls))
                {
                    var headers = HeadersModel.Init("Authorization", $"Bearer {accessToken}");

                    if (!init.streamproxy)
                        headers.Add(new("X-LAMPA-CLIENT-IP", clientIP));

                    var result = rch.enable ? await rch.Post<JObject>(init.apihost + playlist, "{}", headers: headers) :
                                              await Http.Post<JObject>(init.apihost + playlist, "{}", headers: headers, proxy: proxy);

                    if (result == null || !result.ContainsKey("url"))
                        return OnError(null, gbcache: false);

                    string url = result.Value<string>("url");
                    if (string.IsNullOrEmpty(url))
                        return OnError(null, gbcache: false);

                    if (url.StartsWith("/"))
                        hls = $"{init.scheme}:{url}";
                    else
                        hls = url;

                    hybridCache.Set(memkey, hls, DateTime.Now.AddMinutes(10));
                }

                if (play)
                    return Redirect(HostStreamProxy(init, hls));

                var player = await getPlayer(content_id, content_type, accessToken, proxy);
                VastConf vast = requestInfo.user != null ? null : new VastConf() { url = player?.tag_url, msg = init?.vast?.msg };
                if (init.disable_ads)
                    vast = null;

                #region subtitle
                var subtitles = new SubtitleTpl();

                try
                {
                    if (translation_id > 0)
                    {
                        if (serial)
                        {
                            if (e > 0 && s > 0)
                            {
                                foreach (var media in player.media.Where(i => i.season_id == s))
                                {
                                    foreach (var episode in media.episodes.Where(i => i.episode_id == e))
                                    {
                                        foreach (var voice in episode.media.Where(i => i.translation_id == translation_id))
                                        {
                                            if (voice.tracks != null)
                                            {
                                                foreach (var t in voice.tracks)
                                                    subtitles.Append(t.label ?? t.srlang, $"{init.scheme}:{t.src}");

                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            var tracks = player.media.FirstOrDefault(i => i.translation_id == translation_id).tracks;
                            if (tracks != null)
                            {
                                foreach (var t in tracks)
                                    subtitles.Append(t.label ?? t.srlang, $"{init.scheme}:{t.src}");
                            }
                        }
                    }
                }
                catch { }
                #endregion

                if (max_quality > 0 && !init.hls)
                {
                    var streamquality = new StreamQualityTpl();
                    foreach (int q in new int[] { 1080, 720, 480, 360, 240 })
                    {
                        if (max_quality >= q)
                            streamquality.Append(HostStreamProxy(init, Regex.Replace(hls, "/hls\\.m3u8$", $"/{q}.mp4")), $"{q}p");
                    }

                    if (!streamquality.Any())
                        return OnError("streams");

                    var first = streamquality.Firts();
                    return ContentTo(VideoTpl.ToJson("play", first.link, first.quality, streamquality: streamquality, subtitles: subtitles, vast: vast));
                }

                return ContentTo(VideoTpl.ToJson("play", HostStreamProxy(init, hls), "auto", subtitles: subtitles, vast: vast));
            });
        }
        #endregion


        #region getToken
        async ValueTask<string> getToken(WebProxy proxy)
        {
            var init = await Initialization();

            #region refreshToken
            string memKey = $"videocdn:refreshToken:{init.username}";
            if (!hybridCache.TryGetValue(memKey, out string refreshToken))
            {
                var data = new System.Net.Http.StringContent($"{{\"username\":\"{init.username}\",\"password\":\"{init.password}\"}}", Encoding.UTF8, "application/json");
                var job = await Http.Post<JObject>($"{init.apihost}/login", data, useDefaultHeaders: false, proxy: proxy);
                if (job == null || !job.ContainsKey("refreshToken"))
                    return null;

                refreshToken = job.Value<string>("refreshToken");
                if (string.IsNullOrEmpty(refreshToken))
                    return null;

                hybridCache.Set(memKey, refreshToken, DateTime.Now.AddDays(2));
            }
            #endregion

            string clientIP = init.verifyip ? requestInfo.IP : "::1";

            memKey = $"videocdn:accessToken:{(init.streamproxy ? "" : clientIP)}";
            if (!hybridCache.TryGetValue(memKey, out string accessToken))
            {
                var headers = init.streamproxy ? null : HeadersModel.Init(("X-LAMPA-CLIENT-IP", clientIP));

                var data = new System.Net.Http.StringContent($"{{\"token\":\"{refreshToken}\"}}", Encoding.UTF8, "application/json");
                var job = await Http.Post<JObject>($"{init.apihost}/refresh", data, timeoutSeconds: 5, useDefaultHeaders: false, headers: headers, proxy: proxy);
                if (job == null || !job.ContainsKey("accessToken"))
                    return null;

                accessToken = job.Value<string>("accessToken");
                if (string.IsNullOrEmpty(accessToken))
                    return null;

                hybridCache.Set(memKey, accessToken, DateTime.Now.AddMinutes(5));
            }

            return accessToken;
        }
        #endregion

        #region getPlayer
        async ValueTask<EmbedModel> getPlayer(long content_id, string content_type, string accessToken, WebProxy proxy)
        {
            if (content_id == 0 || string.IsNullOrEmpty(content_type))
                return null;

            var init = await Initialization();
            string clientIP = init.verifyip ? requestInfo.IP : "::1";

            return await InvokeCache($"videocdn:{content_id}:{content_type}:{accessToken}:{(init.streamproxy ? "" : clientIP)}", TimeSpan.FromMinutes(5), async () =>
            {
                var headers = HeadersModel.Init(
                    ("Authorization", $"Bearer {accessToken}"),
                    ("User-Agent", HttpContext.Request.Headers.UserAgent)
                );

                if (!init.streamproxy)
                    headers.Add(new("X-LAMPA-CLIENT-IP", clientIP));

                string json = await Http.Get($"{init.apihost}/stream?clientId={init.clientId}&contentType={content_type}&contentId={content_id}&domain={init.domain}", useDefaultHeaders: false, timeoutSeconds: 8, headers: headers, proxy: proxy);
                if (string.IsNullOrEmpty(json))
                    return null;

                var job = JsonConvert.DeserializeObject<JObject>(json);

                var model = job["player"].ToObject<EmbedModel>();
                model.tag_url = job["ads"]["rolls"].First.Value<string>("tag_url");

                return model;
            });
        }
        #endregion

        #region Search
        async ValueTask<(long content_id, string content_type, SimilarTpl similar)> Search(LumexSettings init, string imdb_id, long kinopoisk_id, string title, string original_title, int serial, int clarification, bool similar, WebProxy proxy)
        {
            async Task<JToken> searchId(string imdb_id, long kinopoisk_id)
            {
                if (string.IsNullOrEmpty(init.token))
                    return null;

                if (string.IsNullOrEmpty(imdb_id) && kinopoisk_id == 0)
                    return null;

                string arg = kinopoisk_id > 0 ? $"&kinopoisk_id={kinopoisk_id}" : $"&imdb_id={imdb_id}";
                var job = await Http.Get<JObject>($"{init.iframehost}/api/short?api_token={init.token}" + arg, timeoutSeconds: 8, proxy: proxy);
                if (job == null || !job.ContainsKey("data"))
                    return null;

                var result = job["data"]?.First;
                if (result == null)
                    return null;

                return result;
            }

            var movie = similar ? null : (await searchId(imdb_id, 0) ?? await searchId(null, kinopoisk_id));
            if (movie != null)
            {
                return (movie.Value<long>("id"), movie.Value<string>("content_type"), default);
            }
            else
            {
                if (string.IsNullOrEmpty(title ?? original_title) || string.IsNullOrEmpty(init.token))
                    return default;

                string uri = $"{init.iframehost}/api/short?api_token={init.token}&title={HttpUtility.UrlEncode(clarification == 1 ? title : (original_title ?? title))}";
                string json = await Http.Get(uri, timeoutSeconds: 8, proxy: proxy);
                if (json == null)
                    return default;

                SearchRoot root;

                try
                {
                    root = JsonConvert.DeserializeObject<SearchRoot>(json);
                    if (root?.data == null || root.data.Length == 0)
                        return default;
                }
                catch { return default; }

                var stpl = new SimilarTpl(root.data.Length);

                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                int count = 0;
                foreach (var item in root.data)
                {
                    if (serial != -1)
                    {
                        if ((serial == 0 && item.content_type != "movie") || (serial == 1 && item.content_type == "movie"))
                            continue;
                    }

                    if (clarification != 1)
                    {
                        bool isok = title != null && title.Length > 3 && item.title != null && item.title.ToLower().Contains(title.ToLower());
                        isok = isok ? true : original_title != null && original_title.Length > 3 && item.orig_title != null && item.orig_title.ToLower().Contains(original_title.ToLower());

                        if (!isok)
                            continue;
                    }

                    string year = item.add?.Split("-")?[0] ?? string.Empty;
                    string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.orig_title) ? $"{item.title} / {item.orig_title}" : (item.title ?? item.orig_title);

                    string details = $"imdb: {item.imdb_id} {stpl.OnlineSplit} kinopoisk: {item.kp_id}";

                    string img = PosterApi.Find(item.kp_id, item.imdb_id);
                    stpl.Append(name, year, details, $"{host}/lite/videocdn?title={enc_title}&original_title={enc_original_title}&content_id={item.id}&content_type={item.content_type}", img);

                    count += 1;
                }

                return (0, null, stpl);
            }
        }
        #endregion
    }
}

```

## File: Online/Controllers/FanCDN.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Shared.PlaywrightCore;
using System.Net;
using BrowserCookie = Microsoft.Playwright.Cookie;
using Microsoft.AspNetCore.Routing;
using Shared.Models.Online.Settings;
using Shared.Models.Online.FanCDN;

namespace Online.Controllers
{
    public class FanCDN : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/fancdn")]
        async public ValueTask<ActionResult> Index(string imdb_id, long kinopoisk_id, string title, string original_title, int year, int serial, int t = -1, int s = -1, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.FanCDN);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.token) && string.IsNullOrEmpty(init.cookie))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var oninvk = new FanCDNInvoke
            (
               host,
               init.host,
               async ongettourl => 
               {
                   if (ongettourl.Contains("fancdn."))
                       return await black_magic(init, rch, init.cors(ongettourl), proxy);

                   if (string.IsNullOrEmpty(init.cookie))
                       return null;

                   var headers = httpHeaders(init, HeadersModel.Init(
                       ("sec-fetch-dest", "document"),
                       ("sec-fetch-mode", "navigate"),
                       ("sec-fetch-site", "none"),
                       ("cookie", init.cookie)
                   ));

                   if (rch.enable)
                       return await rch.Get(init.cors(ongettourl), headers);

                   if (init.priorityBrowser == "http")
                       return await Http.Get(init.cors(ongettourl), httpversion: 2, timeoutSeconds: 8, proxy: proxy.proxy, headers: headers);

                   #region Browser Search
                   try
                   {
                       using (var browser = new PlaywrightBrowser())
                       {
                           var page = await browser.NewPageAsync(init.plugin, proxy: proxy.data);
                           if (page == null)
                               return null;

                           string fanhost = "." + Regex.Replace(init.host, "^https?://", "");
                           var excookie = DateTimeOffset.UtcNow.AddYears(1).ToUnixTimeSeconds();

                           var cookies = new List<BrowserCookie>();
                           foreach (string line in init.cookie.Split(";"))
                           {
                               if (string.IsNullOrEmpty(line) || !line.Contains("=") || line.Contains("cf_clearance") || line.Contains("PHPSESSID"))
                                   continue;

                               cookies.Add(new BrowserCookie()
                               {
                                   Domain = fanhost,
                                   Expires = excookie,
                                   Path = "/",
                                   HttpOnly = true,
                                   Secure = true,
                                   Name = line.Split("=")[0].Trim(),
                                   Value = line.Split("=")[1].Trim()
                               });
                           }

                           await page.Context.AddCookiesAsync(cookies);

                           var response = await page.GotoAsync(ongettourl, new PageGotoOptions()
                           {
                               Timeout = 10_000,
                               WaitUntil = WaitUntilState.DOMContentLoaded 
                           });

                           if (response == null)
                               return null;

                           string result = await response.TextAsync();
                           PlaywrightBase.WebLog("GET", ongettourl, result, proxy.data, response: response);
                           return result;
                       }
                   }
                   catch
                   {
                       return null;
                   }
                   #endregion
               },
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy.proxy)
            );

            reset:
            var cache = await InvokeCache<EmbedModel>(rch.ipkey($"fancdn:{title}", proxyManager), cacheTime(20, init: init), proxyManager, async res =>
            {
                var result = !string.IsNullOrEmpty(init.token) && kinopoisk_id > 0 ? await oninvk.EmbedToken(kinopoisk_id, init.token) : await oninvk.EmbedSearch(title, original_title, year, serial);
                if (result == null)
                    return res.Fail("result");

                return result;
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, imdb_id, kinopoisk_id, title, original_title, t, s, rjson: rjson, vast: init.vast, headers: httpHeaders(init)), origsource: origsource);
        }


        #region black_magic
        async Task<string> black_magic(OnlinesSettings init, RchClient rch, string uri, (WebProxy proxy, (string ip, string username, string password) data) baseproxy)
        {
            try
            {
                var headers = httpHeaders(init, HeadersModel.Init(
                    ("sec-fetch-dest", "iframe"),
                    ("sec-fetch-mode", "navigate"),
                    ("sec-fetch-site", "cross-site"),
                    ("referer", $"{init.host}/")
                ));

                if (rch.enable)
                    return await rch.Get(uri, headers);

                if (init.priorityBrowser == "http")
                    return await Http.Get(uri, httpversion: 2, timeoutSeconds: 8, proxy: baseproxy.proxy, headers: headers);

                using (var browser = new PlaywrightBrowser())
                {
                    var page = await browser.NewPageAsync(init.plugin, init.headers, proxy: baseproxy.data, imitationHuman: init.imitationHuman);
                    if (page == null)
                        return null;

                    browser.SetFailedUrl(uri);

                    await page.RouteAsync("**/*", async route =>
                    {
                        try
                        {
                            if (route.Request.Url.StartsWith(init.host))
                            {
                                await route.FulfillAsync(new RouteFulfillOptions
                                {
                                    Body = PlaywrightBase.IframeHtml(uri)
                                });
                            }
                            else if (route.Request.Url == uri)
                            {
                                string html = null;
                                await browser.ClearContinueAsync(route, page);

                                var response = await page.WaitForResponseAsync(route.Request.Url);
                                if (response != null)
                                    html = await response.TextAsync();

                                browser.SetPageResult(html);
                                PlaywrightBase.WebLog(route.Request, response, html, baseproxy.data);
                            }
                            else
                            {
                                if (!init.imitationHuman || route.Request.Url.EndsWith(".m3u8"))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                }
                                else
                                {
                                    if (await PlaywrightBase.AbortOrCache(page, route))
                                        return;

                                    await browser.ClearContinueAsync(route, page);
                                }
                            }
                        }
                        catch { }
                    });

                    PlaywrightBase.GotoAsync(page, init.host);
                    return await browser.WaitPageResult();
                }
            }
            catch
            {
                return null; 
            }
        }
        #endregion
    }
}

```

## File: Online/Controllers/VoKino.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.VoKino;

namespace Online.Controllers
{
    public class VoKino : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.VoKino);

        #region vokinotk
        [HttpGet]
        [AllowAnonymous]
        [Route("lite/vokinotk")]
        async public Task<ActionResult> Token(string login, string pass)
        {
            string html = string.Empty;

            if (string.IsNullOrWhiteSpace(login) || string.IsNullOrWhiteSpace(pass))
            {
                html = "–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç–∞ <a href='http://vokino.tv'>vokino.tv</a> <br> <br><form method=\"get\" action=\"/lite/vokinotk\"><input type=\"text\" name=\"login\" placeholder=\"email\"> &nbsp; &nbsp; <input type=\"text\" name=\"pass\" placeholder=\"–ø–∞—Ä–æ–ª—å\"><br><br><button>–î–æ–±–∞–≤–∏—Ç—å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ</button></form> ";
            }
            else
            {
                string deviceid = new string(DateTime.Now.ToBinary().ToString().Reverse().ToArray()).Substring(0, 8);
                var token_request = await Http.Get<JObject>($"{AppInit.conf.VoKino.corsHost()}/v2/auth?email={HttpUtility.UrlEncode(login)}&passwd={HttpUtility.UrlEncode(pass)}&deviceid={deviceid}", proxy: proxyManager.Get(), headers: HeadersModel.Init("user-agent", "lampac"));

                if (token_request == null)
                    return Content($"–Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ {AppInit.conf.VoKino.corsHost()}", "text/html; charset=utf-8");

                string authToken = token_request.Value<string>("authToken");
                if (string.IsNullOrEmpty(authToken))
                    return Content(token_request.Value<string>("error") ?? "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–æ–∫–µ–Ω", "text/html; charset=utf-8");

                html = "–î–æ–±–∞–≤—å—Ç–µ –≤ init.conf<br><br>\"VoKino\": {<br>&nbsp;&nbsp;\"enable\": true,<br>&nbsp;&nbsp;\"token\": \"" + authToken + "\"<br>}";
            }

            return Content(html, "text/html; charset=utf-8");
        }
        #endregion

        [HttpGet]
        [Route("lite/vokino")]
        async public ValueTask<ActionResult> Index(bool checksearch, string origid, long kinopoisk_id, string title, string original_title, string balancer, string t, int s = -1, bool rjson = false, string source = null, string id = null)
        {
            if (string.IsNullOrEmpty(origid) && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() == "vokino")
                    origid = id;
            }

            var init = await loadKit(AppInit.conf.VoKino, (j, i, c) => 
            {
                if (j.ContainsKey("online"))
                    i.online = c.online;
                return i; 
            });

            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            if (kinopoisk_id == 0 && string.IsNullOrEmpty(origid))
                return OnError();

            if (balancer is "filmix" or "ashdi" or "monframe")
                init.streamproxy = false;

            if (checksearch /*&& balancer != "vokino"*/)
                return Content("data-json="); // –∑–∞–≥–ª—É—à–∫–∞ –æ—Ç 429 –∏ +1 –∫ –ø—Ä–æ—Å–º–æ—Ç—Ä—É

            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var oninvk = new VoKinoInvoke
            (
               host,
               init.corsHost(),
               init.token,
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl), httpHeaders(init)) : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            reset:
            var cache = await InvokeCache<EmbedModel>(rch.ipkey($"vokino:{kinopoisk_id}:{origid}:{balancer}:{t}:{init.token}", proxyManager), cacheTime(20, rhub: 2, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(origid, kinopoisk_id, balancer, t);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, origid, kinopoisk_id, title, original_title, balancer, t, s, init.vast, rjson), gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/Vibix.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Vibix;
using Shared.Models.Online.Settings;

namespace Online.Controllers
{
    public class Vibix : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.Vibix);

        [HttpGet]
        [Route("lite/vibix")]
        async public ValueTask<ActionResult> Index(string imdb_id, long kinopoisk_id, string title, string original_title,  int s = -1, bool rjson = false, bool origsource = false)
        {
            var init = await loadKit(AppInit.conf.Vibix);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            var data = await search(init, imdb_id, kinopoisk_id);
            if (data == null)
                return OnError();

            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            reset:
            var cache = await InvokeCache<EmbedModel>(rch.ipkey($"vibix:iframe:{data.iframe_url}:{init.token}", proxyManager), cacheTime(20, rhub: 2, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string api_url = data.iframe_url
                    .Replace("/embed/", "/api/v1/embed/")
                    .Replace("/embed-serials/", "/api/v1/embed-serials/");

                api_url += $"?kp={CrypTo.unic(6).ToLower()}";

                var api_headers = httpHeaders(init, HeadersModel.Init(
                    ("accept", "*/*"),
                    ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                    ("sec-fetch-dest", "empty"),
                    ("sec-fetch-mode", "cors"),
                    ("sec-fetch-site", "same-origin"),
                    ("referer", data.iframe_url)
                ));

                var root = rch.enable 
                    ? await rch.Get<JObject>(init.cors(api_url), api_headers) 
                    : await Http.Get<JObject>(init.cors(api_url), timeoutSeconds: 8, proxy: proxy, headers: api_headers, httpversion: 2);

                if (root == null || !root.ContainsKey("data") || root["data"]?["playlist"] == null)
                    return res.Fail("root");

                return new EmbedModel() { playlist = root["data"]["playlist"].ToObject<Seasons[]>() };
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            if (data.type == "movie")
            {
                #region –§–∏–ª—å–º
                return OnResult(cache, () => 
                {
                    var mtpl = new MovieTpl(title, original_title, 1);

                    foreach (var movie in cache.Value.playlist)
                    {
                        var streams = new StreamQualityTpl();

                        foreach (string q in new string[] { "1080", "720", "480" })
                        {
                            var g = new Regex($"{q}p?\\](\\{{[^\\}}]+\\}})?(?<file>https?://[^,\t\\[\\;\\{{ ]+\\.mp4)").Match(movie.file).Groups;

                            if (!string.IsNullOrEmpty(g["file"].Value))
                                streams.Append(HostStreamProxy(init, g["file"].Value, proxy: proxy), $"{q}p");
                        }

                        mtpl.Append(movie.title, streams.Firts().link, streamquality: streams, vast: init.vast);
                    }

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();

                }, origsource: origsource, gbcache: !rch.enable);
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                return OnResult(cache, () =>
                {
                    string enc_title = HttpUtility.UrlEncode(title);
                    string enc_original_title = HttpUtility.UrlEncode(original_title);

                    if (s == -1)
                    {
                        var tpl = new SeasonTpl(cache.Value.playlist.Length);

                        foreach (var season in cache.Value.playlist)
                        {
                            string name = season.title;
                            if (int.TryParse(Regex.Match(name, "([0-9]+)$").Groups[1].Value, out int _s) && _s > 0)
                            {
                                string link = $"{host}/lite/vibix?rjson={rjson}&kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&title={enc_title}&original_title={enc_original_title}&s={_s}";
                                tpl.Append($"{_s} —Å–µ–∑–æ–Ω", link, _s);
                            }
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        var etpl = new EpisodeTpl();
                        string sArhc = s.ToString();

                        foreach (var season in cache.Value.playlist)
                        {
                            if (!season.title.EndsWith($" {s}"))
                                continue;

                            foreach (var episode in season.folder)
                            {
                                string name = episode.title;
                                string file = episode.folder?.First().file ?? episode.file;

                                if (string.IsNullOrEmpty(name) || string.IsNullOrEmpty(file))
                                    continue;

                                var streams = new StreamQualityTpl();

                                foreach (string q in new string[] { "1080", "720", "480" })
                                {
                                    var g = new Regex($"{q}p?\\](\\{{[^\\}}]+\\}})?(?<file>https?://[^,\t\\[\\;\\{{ ]+\\.mp4)").Match(file).Groups;
                                    if (!string.IsNullOrEmpty(g["file"].Value))
                                        streams.Append(HostStreamProxy(init, g["file"].Value, proxy: proxy), $"{q}p");
                                }

                                etpl.Append(name, title ?? original_title, sArhc, Regex.Match(name, "([0-9]+)").Groups[1].Value, streams.Firts().link, streamquality: streams, vast: init.vast);
                            }
                        }

                        return rjson ? etpl.ToJson() : etpl.ToHtml();
                    }

                }, origsource: origsource, gbcache: !rch.enable);
                #endregion
            }
        }


        #region search
        async ValueTask<Video> search(OnlinesSettings init, string imdb_id, long kinopoisk_id)
        {
            string memKey = $"vibix:view:{kinopoisk_id}:{imdb_id}";

            if (!hybridCache.TryGetValue(memKey, out Video root))
            {
                async Task<Video> goSearch(string imdb_id, long kinopoisk_id)
                {
                    if (string.IsNullOrEmpty(imdb_id) && kinopoisk_id == 0)
                        return null;

                    string uri = kinopoisk_id > 0 ? $"kp/{kinopoisk_id}" : $"imdb/{imdb_id}";
                    var header = httpHeaders(init, HeadersModel.Init(
                        ("Accept", "application/json"),
                        ("Authorization", $"Bearer {init.token}"),
                        ("X-CSRF-TOKEN", "")
                    ));

                    var video = await Http.Get<Video>($"{init.host}/api/v1/publisher/videos/{uri}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: header);

                    if (video == null)
                    {
                        proxyManager.Refresh();
                        return null;
                    }

                    if (string.IsNullOrEmpty(video.iframe_url) || string.IsNullOrEmpty(video.type))
                        return null;

                    return video;
                }

                root = await goSearch(null, kinopoisk_id) ?? await goSearch(imdb_id, 0);
                if (root == null)
                    return null;

                proxyManager.Success();
                hybridCache.Set(memKey, root, cacheTime(30, init: init));
            }

            return root;
        }
        #endregion
    }
}

```

## File: Online/Controllers/Zetflix.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class Zetflix : BaseOnlineController
    {
        static string PHPSESSID = null;

        [HttpGet]
        [Route("lite/zetflix")]
        async public ValueTask<ActionResult> Index(long id, int serial, long kinopoisk_id, string title, string original_title, string t, int s = -1, bool orightml = false, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.Zetflix);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (kinopoisk_id == 0)
                return OnError();

            if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string ztfhost = await goHost(init.host);
            string log = $"{HttpContext.Request.Path.Value}\n\nstart init\n";

            var oninvk = new ZetflixInvoke
            (
               host,
               ztfhost,
               init.hls,
               (url, head) => Http.Get(init.cors(url), headers: httpHeaders(init, head), timeoutSeconds: 8, proxy: proxy.proxy),
               onstreamtofile => HostStreamProxy(init, onstreamtofile, proxy: proxy.proxy)
               //AppInit.log
            );

            int rs = serial == 1 ? (s == -1 ? 1 : s) : s;

            string html = await InvokeCache($"zetfix:view:{kinopoisk_id}:{rs}:{proxyManager.CurrentProxyIp}", cacheTime(20, init: init), async () => 
            {
                string uri = $"{ztfhost}/iplayer/videodb.php?kp={kinopoisk_id}" + (rs > 0 ? $"&season={rs}" : "");

                var headers = HeadersModel.Init(Chromium.baseContextOptions.ExtraHTTPHeaders.ToDictionary(), ("Referer", "https://www.google.com/"));

                string result = string.IsNullOrEmpty(PHPSESSID) ? null : await Http.Get(uri, proxy: proxy.proxy, cookie: $"PHPSESSID={PHPSESSID}", headers: headers);
                if (result != null && !result.StartsWith("<script>(function"))
                {
                    if (!result.Contains("new Playerjs"))
                        return null;

                    proxyManager.Success();
                    return result;
                }

                try
                {
                    using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                    {
                        log += "browser init\n";

                        var page = await browser.NewPageAsync(init.plugin, new Dictionary<string, string>()
                        {
                            ["Referer"] = "https://www.google.com/"

                        }, proxy: proxy.data, keepopen: init.browser_keepopen).ConfigureAwait(false);

                        if (page == null)
                            return null;

                        if (init.browser_keepopen)
                        {
                            await page.Context.ClearCookiesAsync(new BrowserContextClearCookiesOptions
                            {
                                Domain = Regex.Replace(ztfhost, "^https?://", ""),
                                Name = "PHPSESSID"

                            }).ConfigureAwait(false);
                        }

                        log += "page init\n";

                        await page.RouteAsync("**/*", async route =>
                        {
                            try
                            {
                                if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                    return;

                                await route.ContinueAsync();
                            }
                            catch { }
                        });

                        await page.GotoAsync(uri, new PageGotoOptions() 
                        {
                            Timeout = 15_000,
                            WaitUntil = WaitUntilState.NetworkIdle 
                        }).ConfigureAwait(false);

                        result = await page.ContentAsync().ConfigureAwait(false);

                        log += $"{result}\n\n";

                        if (result == null || result.StartsWith("<script>(function"))
                        {
                            proxyManager.Refresh();
                            return null;
                        }

                        var cook = await page.Context.CookiesAsync().ConfigureAwait(false);
                        PHPSESSID = cook?.FirstOrDefault(i => i.Name == "PHPSESSID")?.Value;

                        if (!result.Contains("new Playerjs"))
                            return null;

                        return result;
                    }
                }
                catch (Exception ex) 
                {
                    log += $"\nex: {ex}\n";
                    return null; 
                }
            });

            if (html == null)
                return OnError();

            if (orightml)
                return Content(html, "text/plain; charset=utf-8");

            var content = oninvk.Embed(html);
            if (content.pl == null)
                return OnError();

            if (origsource)
                return Json(content);

            int number_of_seasons = 1;
            if (!content.movie && s == -1 && id > 0)
                number_of_seasons = await InvokeCache($"zetfix:number_of_seasons:{kinopoisk_id}", cacheTime(120, init: init), () => oninvk.number_of_seasons(id));

            OnLog(log + "\nStart OnResult");

            return ContentTo(oninvk.Html(content, number_of_seasons, kinopoisk_id, title, original_title, t, s, vast: init.vast, rjson: rjson));
        }


        async ValueTask<string> goHost(string host)
        {
            if (!Regex.IsMatch(host, "^https?://go\\."))
                return host;

            string backhost = CrypTo.DecodeBase64("aHR0cHM6Ly96ZXQtZmxpeC5vbmxpbmU=");

            string memkey = $"zeflix:gohost:{host}";
            if (hybridCache.TryGetValue(memkey, out string ztfhost))
            {
                if (string.IsNullOrEmpty(ztfhost))
                    return backhost;

                return ztfhost;
            }

            string html = await Http.Get(host, timeoutSeconds: 8);
            if (html != null)
            {
                ztfhost = Regex.Match(html, "\"([^\"]+)\"\\);</script>").Groups[1].Value;
                if (!string.IsNullOrEmpty(ztfhost))
                {
                    ztfhost = $"https://{ztfhost}";
                    hybridCache.Set(memkey, ztfhost, DateTime.Now.AddMinutes(20));
                    return ztfhost;
                }
            }
            else
            {
                hybridCache.Set(memkey, string.Empty, DateTime.Now.AddMinutes(1));
            }

            return backhost;
        }
    }
}

```

## File: Online/Controllers/KinoPub.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.KinoPub;
using System.Net;

namespace Online.Controllers
{
    public class KinoPub : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.KinoPub);

        static CookieContainer cookies = new CookieContainer();

        #region kinopubpro
        [HttpGet]
        [AllowAnonymous]
        [Route("lite/kinopubpro")]
        async public Task<ActionResult> Pro(string code, string name)
        {
            var proxy = proxyManager.Get();
            var init = AppInit.conf.KinoPub;
            var headers = httpHeaders(init);

            if (string.IsNullOrWhiteSpace(code))
            {
                var token_request = await Http.Post<JObject>($"{init.corsHost()}/oauth2/device?grant_type=device_code&client_id=xbmc&client_secret=cgg3gtifu46urtfp2zp1nqtba0k2ezxh", "", proxy: proxy, headers: httpHeaders(init), httpversion: 2);

                if (token_request == null)
                    return Content($"–Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ {init.corsHost()}", "text/html; charset=utf-8");

                string html = "1. –û—Ç–∫—Ä–æ–π—Ç–µ <a href='https://kino.pub/device'>https://kino.pub/device</a> <br>";
                html += $"2. –í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ <b>{token_request.Value<string>("user_code")}</b><br>";
                html += $"3. –ö–æ–≥–¥–∞ –Ω–∞ —Å–∞–π—Ç–µ kino.pub –ø–æ—è–≤–∏—Ç—Å—è \"–û–∂–∏–¥–∞–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞\", –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É \"–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∞–∫—Ç–∏–≤–∞—Ü–∏—é\" –∫–æ—Ç–æ—Ä–∞—è –Ω–∏–∂–µ</b>";

                html += $"<br><br><a href='/lite/kinopubpro?code={token_request.Value<string>("code")}&name={name}'><button>–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∞–∫—Ç–∏–≤–∞—Ü–∏—é</button></a>";

                return Content(html, "text/html; charset=utf-8");
            }
            else
            {
                var device_token = await Http.Post<JObject>($"{init.corsHost()}/oauth2/device?grant_type=device_token&client_id=xbmc&client_secret=cgg3gtifu46urtfp2zp1nqtba0k2ezxh&code={code}", "", proxy: proxy, headers: httpHeaders(init), httpversion: 2);
                if (device_token == null || string.IsNullOrWhiteSpace(device_token.Value<string>("access_token")))
                    return LocalRedirect("/lite/kinopubpro");

                if (!string.IsNullOrEmpty(name))
                    await Http.Post($"{init.corsHost()}/v1/device/notify?access_token={device_token.Value<string>("access_token")}", $"&title={name}", proxy: proxy, headers: httpHeaders(init), httpversion: 2);

                return Content("–î–æ–±–∞–≤—å—Ç–µ –≤ init.conf<br><br>\"KinoPub\": {<br>&nbsp;&nbsp;\"enable\": true,<br>&nbsp;&nbsp;\"token\": \"" + device_token.Value<string>("access_token") + "\"<br>}", "text/html; charset=utf-8");
            }
        }
        #endregion

        [HttpGet]
        [Route("lite/kinopub")]
        async public ValueTask<ActionResult> Index(string imdb_id, long kinopoisk_id, string title, string original_title, int year, int clarification, int postid, int s = -1, int t = -1, string codec = null, bool origsource = false, bool rjson = false, bool similar = false, string source = null, string id = null)
        {
            if (postid == 0 && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() == "kinopub")
                    int.TryParse(id, out postid);
            }

            var init = await loadKit(AppInit.conf.KinoPub, (j, i, c) =>
            {
                if (j.ContainsKey("filetype"))
                    i.filetype = c.filetype;
                i.tokens = c.tokens;
                return i;
            });

            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxy = proxyManager.Get();

            string token = init.token;
            if (init.tokens != null && init.tokens.Length > 1)
                token = init.tokens[Random.Shared.Next(0, init.tokens.Length)];

            var oninvk = new KinoPubInvoke
            (
               host,
               init.corsHost(),
               token,
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl), httpHeaders(init)) : 
                                          Http.Get(init.cors(ongettourl), httpversion: 2, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init), cookieContainer: cookies),
               (stream, filepath) => HostStreamProxy(init, stream, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            if (postid == 0)
            {
                var search = await InvokeCache<SearchResult>($"kinopub:search:{title}:{year}:{clarification}:{imdb_id}:{kinopoisk_id}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    return await oninvk.Search(title, original_title, year, clarification, imdb_id, kinopoisk_id);
                });

                if (!search.IsSuccess)
                    return OnError(search.ErrorMsg);

                if (similar || search.Value.id == 0)
                {
                    if (search.Value.similars == null)
                        return OnError();

                    return ContentTo(rjson ? search.Value.similars.Value.ToJson() : search.Value.similars.Value.ToHtml());
                }

                postid = search.Value.id;
            }

            var cache = await InvokeCache<RootObject>($"kinopub:post:{postid}:{token}", cacheTime(10, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Post(postid);
            });

            return OnResult(cache, () => oninvk.Html(cache.Value, init.filetype, title, original_title, postid, s, t, codec, vast: init.vast, rjson: rjson), origsource: origsource, gbcache: !rch.enable);
        }


        [HttpGet]
        [Route("lite/kinopub/subtitles.json")]
        async public ValueTask<ActionResult> Subtitles(int mid)
        {
            var init = await loadKit(AppInit.conf.KinoPub, (j, i, c) =>
            {
                i.tokens = c.tokens;
                return i;
            });

            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxy = proxyManager.Get();

            string token = init.token;
            if (init.tokens != null && init.tokens.Length > 1)
                token = init.tokens[Random.Shared.Next(0, init.tokens.Length)];

            string uri = $"{init.corsHost()}/v1/items/media-links?mid={mid}&access_token={token}";

            var root = await InvokeCache($"kinopub:media-links:{mid}:{token}", cacheTime(20, init: init), 
                () => Http.Get<JObject>(uri, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init))
            );

            if (root == null || !root.ContainsKey("subtitles"))
            {
                proxyManager.Refresh();
                return ContentTo("[]");
            }

            var subs = root["subtitles"] as JArray;

            if (subs == null || subs.Count == 0)
                return ContentTo("[]");

            var tpl = new SubtitleTpl(subs.Count);

            foreach (var s in subs.OfType<JObject>())
            {
                try
                {
                    string lang = s.Value<string>("lang");
                    string url = s.Value<string>("url");

                    if (!string.IsNullOrEmpty(url))
                        tpl.Append(lang, HostStreamProxy(init, url, proxy: proxy));
                }
                catch { }
            }

            return ContentTo(tpl.ToJson());
        }
    }
}

```

## File: Online/Controllers/Redheadsound.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Redheadsound;

namespace Online.Controllers
{
    public class Redheadsound : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/redheadsound")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int year, int clarification, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.Redheadsound);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title) || year == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var oninvk = new RedheadsoundInvoke
            (
               host,
               init.corsHost(),
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl), httpHeaders(init)) : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               (url, data) => rch.enable ? rch.Post(init.cors(url), data, httpHeaders(init)) : Http.Post(init.cors(url), data, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            reset:
            var cache = await InvokeCache<EmbedModel>($"redheadsound:view:{title}:{year}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(title, year);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, title, vast: init.vast, rjson: rjson), origsource: origsource, gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/Mirage.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class Mirage : BaseOnlineController
    {
        ValueTask<AllohaSettings> Initialization()
        {
            return loadKit(AppInit.conf.Mirage, (j, i, c) =>
            {
                if (j.ContainsKey("m4s"))
                    i.m4s = c.m4s;
                return i;
            });
        }

        [HttpGet]
        [Route("lite/mirage")]
        async public ValueTask<ActionResult> Index(string orid, string imdb_id, long kinopoisk_id, string title, string original_title, int serial, string original_language, int year, int t = -1, int s = -1, bool origsource = false, bool rjson = false, bool similar = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: serial == 0 ? null : -1);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (similar)
                return await SpiderSearch(title, origsource, rjson);

            var result = await search(orid, imdb_id, kinopoisk_id, title, serial, original_language, year);
            if (result.category_id == 0 || result.data == null)
                return OnError();

            JToken data = result.data;
            string tokenMovie = data["token_movie"] != null ? data.Value<string>("token_movie") : null;
            var frame = await iframe(tokenMovie, init);
            if (frame.all == null)
                return OnError();

            //return ContentTo(JsonConvert.SerializeObject(frame.all));

            if (result.category_id is 1 or 3)
            {
                #region –§–∏–ª—å–º
                var videos = frame.all["theatrical"].ToObject<Dictionary<string, Dictionary<string, JObject>>>();

                var mtpl = new MovieTpl(title, original_title, videos.Count);

                foreach (var i in videos)
                {
                    var file = i.Value.First().Value;

                    string translation = file.Value<string>("translation");
                    string quality = file.Value<string>("quality");
                    long id = file.Value<long>("id");
                    bool uhd = init.m4s ? file.Value<bool>("uhd") : false;

                    string link = $"{host}/lite/mirage/video?id_file={id}&token_movie={data.Value<string>("token_movie")}";
                    string streamlink = accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true");

                    mtpl.Append(translation, link, "call", streamlink, voice_name: uhd ? "2160p" : quality, quality: uhd ? "2160p" : "");
                }

                return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string defaultargs = $"&orid={orid}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&year={year}&original_language={original_language}";

                if (s == -1)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    string q = null;
                    try
                    {
                        if (init.m4s)
                            q = frame.active.Value<bool>("uhd") == true ? "2160p" : null;
                    }
                    catch { }

                    Dictionary<string, JToken> seasons;
                    if (frame.all["seasons"] != null)
                        seasons = frame.all["seasons"].ToObject<Dictionary<string, JToken>>();
                    else
                        seasons = frame.all.ToObject<Dictionary<string, JToken>>();

                    if (seasons.First().Key.StartsWith("t"))
                    {
                        var tpl = new SeasonTpl(q);

                        var seasonNumbers = new HashSet<int>();

                        foreach (var translation in seasons)
                        {
                            var file = translation.Value["file"];
                            if (file == null)
                                continue;

                            foreach (var season in file.ToObject<Dictionary<string, object>>())
                            {
                                if (int.TryParse(season.Key, out int seasonNumber))
                                    seasonNumbers.Add(seasonNumber);
                            }
                        }

                        if (!seasonNumbers.Any())
                            seasonNumbers.Add(frame.active.Value<int>("seasons"));

                        foreach (int i in seasonNumbers.OrderBy(i => i))
                            tpl.Append($"{i} —Å–µ–∑–æ–Ω", $"{host}/lite/mirage?rjson={rjson}&s={i}{defaultargs}", i.ToString());

                        return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                    }
                    else
                    {
                        var tpl = new SeasonTpl(q, seasons.Count);

                        foreach (var season in seasons)
                            tpl.Append($"{season.Key} —Å–µ–∑–æ–Ω", $"{host}/lite/mirage?rjson={rjson}&s={season.Key}{defaultargs}", season.Key);

                        return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                    }
                    #endregion
                }
                else
                {
                    var vtpl = new VoiceTpl();
                    var etpl = new EpisodeTpl();
                    var voices = new HashSet<int>();

                    string sArhc = s.ToString();

                    if (frame.all[sArhc] is JArray)
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        foreach (var episode in frame.all[sArhc])
                        {
                            foreach (var voice in episode.ToObject<Dictionary<string, JObject>>().Select(i => i.Value))
                            {
                                int id_translation = voice.Value<int>("id_translation");
                                if (voices.Contains(id_translation))
                                    continue;

                                voices.Add(id_translation);

                                if (t == -1)
                                    t = id_translation;

                                string link = $"{host}/lite/mirage?rjson={rjson}&s={s}&t={id_translation}{defaultargs}";
                                bool active = t == id_translation;

                                vtpl.Append(voice.Value<string>("translation"), active, link);
                            }
                        }
                        #endregion

                        foreach (var episode in frame.all[sArhc])
                        {
                            foreach (var voice in episode.ToObject<Dictionary<string, JObject>>().Select(i => i.Value))
                            {
                                if (voice.Value<int>("id_translation") != t)
                                    continue;

                                string translation = voice.Value<string>("translation");
                                int e = voice.Value<int>("episode");

                                string link = $"{host}/lite/mirage/video?id_file={voice.Value<long>("id")}&token_movie={data.Value<string>("token_movie")}";
                                string streamlink = accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true");

                                if (e > 0)
                                    etpl.Append($"{e} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, e.ToString(), link, "call", voice_name: translation, streamlink: streamlink);
                            }
                        }
                    }
                    else if (frame.all.ToObject<Dictionary<string, object>>().First().Key.StartsWith("t"))
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        foreach (var node in frame.all)
                        {
                            if (!node.First["file"].ToObject<Dictionary<string, object>>().ContainsKey(sArhc))
                                continue;

                            var voice = node.First["file"].First.First.First.First;
                            int id_translation = voice.Value<int>("id_translation");
                            if (voices.Contains(id_translation))
                                continue;

                            voices.Add(id_translation);

                            if (t == -1)
                                t = id_translation;

                            string link = $"{host}/lite/mirage?rjson={rjson}&s={s}&t={id_translation}{defaultargs}";
                            bool active = t == id_translation;

                            vtpl.Append(voice.Value<string>("translation"), active, link);
                        }
                        #endregion

                        foreach (var node in frame.all)
                        {
                            foreach (var season in node.First["file"].ToObject<Dictionary<string, object>>())
                            {
                                if (season.Key != sArhc)
                                    continue;

                                if (season.Value is JArray sjar)
                                {

                                }
                                else if (season.Value is JObject sjob)
                                {
                                    foreach (var episode in sjob.ToObject<Dictionary<string, JObject>>())
                                    {
                                        if (episode.Value.Value<int>("id_translation") != t)
                                            continue;

                                        string translation = episode.Value.Value<string>("translation");
                                        int e = episode.Value.Value<int>("episode");

                                        string link = $"{host}/lite/mirage/video?id_file={episode.Value.Value<long>("id")}&token_movie={data.Value<string>("token_movie")}";
                                        string streamlink = accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true");

                                        if (e > 0)
                                            etpl.Append($"{e} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, e.ToString(), link, "call", voice_name: translation, streamlink: streamlink);
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        foreach (var episode in frame.all[sArhc].ToObject<Dictionary<string, Dictionary<string, JObject>>>())
                        {
                            foreach (var voice in episode.Value.Select(i => i.Value))
                            {
                                int id_translation = voice.Value<int>("id_translation");
                                if (voices.Contains(id_translation))
                                    continue;

                                voices.Add(id_translation);

                                if (t == -1)
                                    t = id_translation;

                                string link = $"{host}/lite/mirage?rjson={rjson}&s={s}&t={id_translation}{defaultargs}";
                                bool active = t == id_translation;

                                vtpl.Append(voice.Value<string>("translation"), active, link);
                            }
                        }
                        #endregion

                        foreach (var episode in frame.all[sArhc].ToObject<Dictionary<string, Dictionary<string, JObject>>>())
                        {
                            foreach (var voice in episode.Value.Select(i => i.Value))
                            {
                                string translation = voice.Value<string>("translation");
                                if (voice.Value<int>("id_translation") != t)
                                    continue;

                                string link = $"{host}/lite/mirage/video?id_file={voice.Value<long>("id")}&token_movie={data.Value<string>("token_movie")}";
                                string streamlink = accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true");

                                etpl.Append($"{episode.Key} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.Key, link, "call", voice_name: translation, streamlink: streamlink);
                            }
                        }
                    }

                    if (rjson)
                        return ContentTo(etpl.ToJson(vtpl));

                    return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                }
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/mirage/video")]
        [Route("lite/mirage/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id_file, string token_movie, bool play)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string memKey = $"mirage:video:{id_file}:{init.m4s}";
            if (!hybridCache.TryGetValue(memKey, out (string hls, List<HeadersModel> headers) movie))
            {
                movie = await goMovie($"{init.linkhost}/?token_movie={token_movie}&token={init.token}", id_file, init);
                if (movie.hls == null)
                    return OnError();

                hybridCache.Set(memKey, movie, cacheTime(10));
            }

            var streamquality = new StreamQualityTpl();
            streamquality.Append(HostStreamProxy(init, movie.hls, headers: movie.headers), "auto");

            if (play)
                return Redirect(streamquality.Firts().link);

            return ContentTo(VideoTpl.ToJson("play", streamquality.Firts().link, "auto",
                streamquality: streamquality,
                vast: init.vast,
                headers: movie.headers,
                hls_manifest_timeout: (int)TimeSpan.FromSeconds(20).TotalMilliseconds
            ));
        }
        #endregion

        #region iframe
        async ValueTask<(JToken all, JToken active)> iframe(string token_movie, AllohaSettings init)
        {
            if (string.IsNullOrEmpty(token_movie))
                return default;

            string memKey = $"mirage:iframe:{token_movie}";
            if (!hybridCache.TryGetValue(memKey, out (JToken all, JToken active) cache))
            {
                string uri = $"{init.linkhost}/?token_movie={token_movie}&token={init.token}";
                string referer = $"https://lgfilm.fun/" + reffers[Random.Shared.Next(0, reffers.Length)];

                string html = await Http.Get(uri, httpversion: 2, timeoutSeconds: 8, headers: httpHeaders(init, HeadersModel.Init(
                    ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                    ("referer", referer),
                    ("sec-fetch-dest", "iframe"),
                    ("sec-fetch-mode", "navigate"),
                    ("sec-fetch-site", "cross-site"),
                    ("upgrade-insecure-requests", "1")
                )));

                string json = Regex.Match(html ?? "", "fileList = JSON.parse\\('([^\n\r]+)'\\);").Groups[1].Value;
                if (string.IsNullOrEmpty(json))
                    return default;

                try
                {
                    var root = JsonConvert.DeserializeObject<JObject>(json);
                    if (root == null || !root.ContainsKey("all"))
                        return default;

                    cache = (root["all"], root["active"]);

                    hybridCache.Set(memKey, cache, cacheTime(40));
                }
                catch { return default; }
            }

            return cache;
        }
        #endregion

        #region goMovie
        async Task<(string hls, List<HeadersModel> headers)> goMovie(string uri, long id_file, AllohaSettings init)
        {
            try
            {
                using (var browser = new PlaywrightBrowser())
                {
                    var page = await browser.NewPageAsync(init.plugin).ConfigureAwait(false);
                    if (page == null)
                        return default;

                    await page.RouteAsync("**/*", async route =>
                    {
                        try
                        {
                            if (route.Request.Url.Contains("lgfilm.fun"))
                            {
                                await route.FulfillAsync(new RouteFulfillOptions
                                {
                                    Body = PlaywrightBase.IframeHtml(uri)
                                });
                            }
                            else if (route.Request.Method == "POST" && route.Request.Url.Contains("/movies/"))
                            {
                                string newUrl = Regex.Replace(route.Request.Url, "/[0-9]+$", $"/{id_file}");

                                var fetchHeaders = route.Request.Headers;
                                fetchHeaders.TryAdd("accept-encoding", "gzip, deflate, br, zstd");
                                fetchHeaders.TryAdd("cache-control", "no-cache");
                                fetchHeaders.TryAdd("dnt", "1");
                                fetchHeaders.TryAdd("pragma", "no-cache");
                                fetchHeaders.TryAdd("priority", "u=1, i");
                                fetchHeaders.TryAdd("sec-fetch-dest", "empty");
                                fetchHeaders.TryAdd("sec-fetch-mode", "cors");
                                fetchHeaders.TryAdd("sec-fetch-site", "same-origin");
                                fetchHeaders.TryAdd("sec-fetch-storage-access", "active");

                                var fetchResponse = await route.FetchAsync(new RouteFetchOptions
                                {
                                    Url = newUrl,
                                    Method = "POST",
                                    Headers = fetchHeaders,
                                    PostData = route.Request.PostDataBuffer
                                }).ConfigureAwait(false);

                                string body = await fetchResponse.TextAsync().ConfigureAwait(false);

                                string targetStream = null;
                                if (init.m4s)
                                    targetStream = Regex.Match(body, "\"(2160|1440)\":\"([^\"]+)\"").Groups[2].Value;

                                if (string.IsNullOrWhiteSpace(targetStream))
                                    targetStream = Regex.Match(body, "\"(1080|720)\":\"([^\"]+)\"").Groups[2].Value;

                                if (!string.IsNullOrWhiteSpace(targetStream))
                                    body = Regex.Replace(body, "\"(2160|1440|1080|720|480|360)\":\"[^\"]+\"", $"\"$1\":\"{targetStream}\"");

                                await route.FulfillAsync(new RouteFulfillOptions
                                {
                                    Status = fetchResponse.Status,
                                    Body = body,
                                    Headers = fetchResponse.Headers
                                }).ConfigureAwait(false);
                            }
                            else
                            {
                                if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                    return;

                                await route.ContinueAsync();
                            }
                        }
                        catch { }
                    });

                    page.Response += Page_Response;

                    PlaywrightBase.GotoAsync(page, $"https://lgfilm.fun/" + reffers[Random.Shared.Next(0, reffers.Length)]);

                    try
                    {
                        return await tcsPageResponse.Task.WaitAsync(TimeSpan.FromSeconds(15));
                    }
                    catch { }
                    finally
                    {
                        page.Response -= Page_Response;
                    }
                }
            }
            catch { }

            return default;
        }

        TaskCompletionSource<(string hls, List<HeadersModel> headers)> tcsPageResponse = new TaskCompletionSource<(string hls, List<HeadersModel> headers)>();

        private void Page_Response(object sender, IResponse e)
        {
            if (e.Request.Method == "GET" && e.Url.Contains("/master.m3u8"))
            {
                var headers = HeadersModel.Init(Http.defaultFullHeaders,
                    ("sec-fetch-dest", "empty"),
                    ("sec-fetch-mode", "cors"),
                    ("sec-fetch-site", "cross-site")
                );

                foreach (var item in e.Request.Headers)
                {
                    if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                        continue;

                    if (!Http.defaultFullHeaders.ContainsKey(item.Key.ToLower()))
                        headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                }

                tcsPageResponse.SetResult((e.Url, headers));
            }
        }
        #endregion


        #region SpiderSearch
        [HttpGet]
        [Route("lite/mirage-search")]
        async public ValueTask<ActionResult> SpiderSearch(string title, bool origsource = false, bool rjson = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var cache = await InvokeCache<JArray>($"mirage:search:{title}", cacheTime(40, init: init), proxyManager, async res =>
            {
                var root = await Http.Get<JObject>($"{init.apihost}/?token={init.token}&name={HttpUtility.UrlEncode(title)}&list", timeoutSeconds: 8, proxy: proxyManager.Get());
                if (root == null || !root.ContainsKey("data"))
                    return res.Fail("data");

                return root["data"].ToObject<JArray>();
            });

            return OnResult(cache, () =>
            {
                var stpl = new SimilarTpl(cache.Value.Count);

                foreach (var j in cache.Value)
                {
                    string uri = $"{host}/lite/mirage?orid={j.Value<string>("token_movie")}";
                    stpl.Append(j.Value<string>("name") ?? j.Value<string>("original_name"), j.Value<int>("year").ToString(), string.Empty, uri, PosterApi.Size(j.Value<string>("poster")));
                }

                return rjson ? stpl.ToJson() : stpl.ToHtml();

            }, origsource: origsource);
        }
        #endregion

        #region search
        async ValueTask<(bool refresh_proxy, int category_id, JToken data)> search(string token_movie, string imdb_id, long kinopoisk_id, string title, int serial, string original_language, int year)
        {
            var init = await Initialization();
            string memKey = $"mirage:view:{kinopoisk_id}:{imdb_id}";
            if (0 >= kinopoisk_id && string.IsNullOrEmpty(imdb_id))
                memKey = $"mirage:viewsearch:{title}:{serial}:{original_language}:{year}";

            if (!string.IsNullOrEmpty(token_movie))
                memKey = $"mirage:view:{token_movie}";

            JObject root;

            if (!hybridCache.TryGetValue(memKey, out (int category_id, JToken data) res))
            {
                string stitle = title.ToLower();

                if (memKey.Contains(":viewsearch:"))
                {
                    if (string.IsNullOrWhiteSpace(title) || year == 0)
                        return default;

                    root = await Http.Get<JObject>($"{init.apihost}/?token={init.token}&name={HttpUtility.UrlEncode(title)}&list={(serial == 1 ? "serial" : "movie")}", timeoutSeconds: 8);
                    if (root == null)
                        return (true, 0, null);

                    if (root.ContainsKey("data"))
                    {
                        foreach (var item in root["data"])
                        {
                            if (item.Value<string>("name")?.ToLower()?.Trim() == stitle)
                            {
                                int y = item.Value<int>("year");
                                if (y > 0 && (y == year || y == (year - 1) || y == (year + 1)))
                                {
                                    if (original_language == "ru" && item.Value<string>("country")?.ToLower() != "—Ä–æ—Å—Å–∏—è")
                                        continue;

                                    res.data = item;
                                    res.category_id = item.Value<int>("category_id");
                                    break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    root = await Http.Get<JObject>($"{init.apihost}/?token={init.token}&kp={kinopoisk_id}&imdb={imdb_id}&token_movie={token_movie}", timeoutSeconds: 8);
                    if (root == null)
                        return (true, 0, null);

                    if (root.ContainsKey("data"))
                    {
                        res.data = root.GetValue("data");
                        res.category_id = res.data.Value<int>("category");
                    }
                }

                if (res.data != null || (root.ContainsKey("error_info") && root.Value<string>("error_info") == "not movie"))
                    hybridCache.Set(memKey, res, cacheTime(res.category_id is 1 or 3 ? 120 : 40, init: init));
                else
                    hybridCache.Set(memKey, res, cacheTime(2, init: init));
            }

            return (false, res.category_id, res.data);
        }
        #endregion


        static string[] reffers = new string[] { "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "944-pingvin-2024.html", "944-ping–≤–∏–Ω-2024.html" };
    }
}

```

## File: Online/Controllers/Jackett.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;

namespace Online.Controllers
{
    public class Jackett : BaseController
    {
        [HttpGet]
        [Route("lite/jac")]
        async public ValueTask<ActionResult> Index(string title, string original_title, string original_language, int year, int serial, int quality = -1)
        {
            if (!AppInit.conf.litejac)
                return Content(string.Empty);

            #region –ö–µ—à –∑–∞–ø—Ä–æ—Å–∞
            string localhost = $"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}";

            string memkey = $"lite/jac:{title}:{original_title}:{year}";
            if (!hybridCache.TryGetValue(memkey, out JArray results, inmemory: false) || quality == -1)
            {
                var root = await Http.Get<JObject>($"{localhost}/api/v2.0/indexers/all/results?apikey={AppInit.conf.apikey}&title={HttpUtility.UrlEncode(title)}&title_original={HttpUtility.UrlEncode(original_title)}&year={year}&is_serial={(original_language == "ja" ? 5 : (serial + 1))}", timeoutSeconds: 11, headers: HeadersModel.Init("localrequest", AppInit.rootPasswd));
                if (root == null)
                    return Content(string.Empty, "text/html; charset=utf-8");

                results = root.GetValue("Results")?.ToObject<JArray>();
                if (results == null || results.Count == 0)
                    return Content(string.Empty, "text/html; charset=utf-8");

                hybridCache.Set(memkey, results, DateTime.Now.AddMinutes(5), inmemory: false);
            }
            #endregion

            bool firstjson = true;
            string html = string.Empty;

            #region –ú–µ–Ω—é –∫–∞—á–µ—Å—Ç–≤–∞
            HashSet<int> qualitys = new HashSet<int>();

            foreach (var item in results)
            {
                var info = item.Value<JObject>("Info");
                if (info != null)
                    qualitys.Add(info.Value<int>("quality"));
            }

            html = "<div class=\"videos__line\">";

            foreach (int q in qualitys.OrderByDescending(i => i))
            {
                string link = $"{host}/lite/jac?year={year}&serial={serial}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&quality={q}";

                string active = q == quality ? "active" : "";

                html += "<div class=\"videos__button selector " + active + "\" data-json='{\"method\":\"link\",\"url\":\"" + link + "\"}'>" + $"{q}p" + "</div>";
                firstjson = false;
            }

            firstjson = true;
            html += "</div>";
            #endregion

            foreach (var item in results)
            {
                int sid = item.Value<int>("Seeders"), pir = item.Value<int>("Peers"), q = 0;
                string magnet = item.Value<string>("MagnetUri");
                string tracker = item.Value<string>("Tracker");
                string sizeName = null;

                if (string.IsNullOrWhiteSpace(magnet))
                    magnet = item.Value<string>("Link").Replace(localhost, host);

                var info = item.Value<JObject>("Info");
                if (info != null)
                {
                    q = info.Value<int>("quality");
                    sizeName = info.Value<string>("sizeName");

                    if (quality != -1 && quality != q)
                        continue;
                }

                html += "<div class=\"videos__item videos__torrent selector " + (firstjson ? "focused" : "") + "\" media=\"\" data-json='{\"method\":\"torrent\",\"Link\":\"" + magnet + "\",\"title\":\"" + (title ?? original_title) + "\"}'><div class=\"videos__torrent-title\">" + item.Value<string>("Title") + $"</div><div class=\"videos__item-title\">–†–∞–∑–º–µ—Ä {sizeName} / –†–∞–∑–¥–∞—é—Ç {sid} / –ö–∞—á–∞—é—Ç {pir} / {q}p / {tracker}</div></div>";
                firstjson = false;
            }

            return Content(html, "text/html; charset=utf-8");
        }
    }
}

```

## File: Online/Controllers/Kinobase.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Shared.Models.Online.Kinobase;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class Kinobase : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/kinobase")]
        async public ValueTask<ActionResult> Index(string title, int year, int s = -1, int serial = -1, string href = null, string t = null, bool rjson = false, bool similar = false, string source = null, string id = null)
        {
            var init = await loadKit(AppInit.conf.Kinobase);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (string.IsNullOrEmpty(href) && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() == "kinobase")
                    href = id;
            }

            var proxyManager = new ProxyManager(AppInit.conf.Kinobase);
            var proxy = proxyManager.BaseGet();

            var oninvk = new KinobaseInvoke
            (
               host,
               init,
               ongettourl => 
               {
                   if (ongettourl.Contains("/search?query="))
                       return Http.Get(ongettourl, timeoutSeconds: 8, proxy: proxy.proxy, referer: init.host, httpversion: 2, headers: httpHeaders(init));

                   return black_magic(ongettourl, init, proxy.data);
               },
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy.proxy),
               requesterror: () => proxyManager.Refresh()
            );

            #region search
            if (string.IsNullOrEmpty(href))
            {
                var search = await InvokeCache<SearchModel>($"kinobase:search:{title}:{year}", cacheTime(40, init: init), proxyManager, async res =>
                {
                    var content = await oninvk.Search(title, year);
                    if (content == null)
                        return res.Fail("search");

                    return content;
                });

                if (similar || string.IsNullOrEmpty(search.Value?.link))
                    return OnResult(search, () => rjson ? search.Value.similar.Value.ToJson() : search.Value.similar.Value.ToHtml());

                if (string.IsNullOrEmpty(search.Value?.link))
                    return OnError();

                href = search.Value?.link;
            }
            #endregion

            var cache = await InvokeCache<EmbedModel>($"kinobase:view:{href}:{proxyManager.CurrentProxyIp}", cacheTime(20, init: init), proxyManager, async res =>
            {
                var content = await oninvk.Embed(href, init.playerjs);
                if (content == null)
                    return res.Fail("embed");

                return content;
            });

            return OnResult(cache, () => 
            {
                if (cache.Value.IsEmpty)
                    return ShowErrorString(cache.Value.errormsg);

                return oninvk.Html(cache.Value, title, href, s, t, rjson);
            });
        }



        #region black_magic
        async ValueTask<string> black_magic(string uri, KinobaseSettings init, (string ip, string username, string password) proxy)
        {
            try
            {
                using (var browser = new PlaywrightBrowser())
                {
                    var page = await browser.NewPageAsync(init.plugin, proxy: proxy, headers: init.headers).ConfigureAwait(false);
                    if (page == null)
                        return null;

                    await page.Context.AddCookiesAsync(new List<Cookie>()
                    {
                        new Cookie()
                        {
                            Name = "player_settings",
                            Value = $"{(init.playerjs ? "new" : "old")}|{(init.hls ? "hls" : "mp4")}|{(init.hdr ? 1 : 0)}",
                            Domain = Regex.Match(init.host, "^https?://([^/]+)").Groups[1].Value,
                            Path = "/",
                            Expires = 2220002226
                        }
                    }).ConfigureAwait(false);

                    await page.RouteAsync("**/*", async route =>
                    {
                        try
                        {
                            if (route.Request.Url.Contains("/playerjs.js"))
                            {
                                await route.FulfillAsync(new RouteFulfillOptions
                                {
                                    Body = System.IO.File.ReadAllText("data/kinobase_playerjs.js")
                                });

                                return;
                            }
                            else if (route.Request.Url.Contains("/uppod.js"))
                            {
                                await route.FulfillAsync(new RouteFulfillOptions
                                {
                                    Body = System.IO.File.ReadAllText("data/kinobase_uppod.js")
                                });

                                return;
                            }

                            if (!route.Request.Url.Contains(init.host) || route.Request.Url.Contains("/comments"))
                            {
                                await route.AbortAsync();
                                return;
                            }

                            if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, patterCache: "/js/(jquery|boot)\\.js"))
                                return;

                            await route.ContinueAsync();
                        }
                        catch { }
                    });

                    PlaywrightBase.GotoAsync(page, uri);
                    await browser.WaitForAnySelectorAsync(page, "#playerjsfile", ".uppod-media", ".alert").ConfigureAwait(false);

                    string content = await page.ContentAsync().ConfigureAwait(false);

                    PlaywrightBase.WebLog("GET", uri, content, proxy);
                    return content;
                }
            }
            catch { return null; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/VeoVeo.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;
using Shared.Models.Online.VeoVeo;
using System.Net;

namespace Online.Controllers
{
    public class VeoVeo : BaseOnlineController
    {
        #region database
        static List<Movie> databaseCache;

        static IEnumerable<Movie> database
        {
            get
            {
                if (AppInit.conf.multiaccess || databaseCache != null)
                    return databaseCache ??= JsonHelper.ListReader<Movie>("data/veoveo.json", 45000);

                return JsonHelper.IEnumerableReader<Movie>("data/veoveo.json");
            }
        }
        #endregion

        [HttpGet]
        [Route("lite/veoveo")]
        async public ValueTask<ActionResult> Index(long movieid, string imdb_id, long kinopoisk_id, string title, string original_title, int clarification, int s = -1, bool rjson = false, bool origsource = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.VeoVeo);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            if (movieid == 0)
            {
                if (similar)
                    return Spider(title);

                var movie = search(init, proxyManager, proxy, imdb_id, kinopoisk_id, title, original_title);
                if (movie == null)
                    return Spider(clarification == 1 ? title : (original_title ?? title));

                movieid = movie.Value.id;
            }

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            #region media
            var cache = await InvokeCache<JArray>($"{init.plugin}:view:{movieid}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string uri = $"{init.host}/balancer-api/proxy/playlists/catalog-api/episodes?content-id={movieid}";
                
                var root = rch.enable 
                    ? await rch.Get<JArray>(init.cors(uri), httpHeaders(init))
                    : await Http.Get<JArray>(init.cors(uri), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));

                if (root == null || root.Count == 0)
                    return res.Fail("data");

                return root;
            });
            #endregion

            return OnResult(cache, () =>
            {
                if (cache.Value.First["season"].Value<int>("order") == 0)
                {
                    #region –§–∏–ª—å–º
                    var mtpl = new MovieTpl(title, original_title, 1);

                    string file = cache.Value.First["episodeVariants"]
                        .OrderByDescending(i => i.Value<string>("filepath").Contains(".m3u8"))
                        .First()
                        .Value<string>("filepath");

                    string stream = HostStreamProxy(init, file, proxy: proxy);

                    mtpl.Append("1080p", stream, vast: init.vast);

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∞–ª
                    if (s == -1)
                    {
                        var tpl = new SeasonTpl();
                        var hash = new HashSet<int>();

                        foreach (var item in cache.Value)
                        {
                            var season = item["season"].Value<int>("order");
                            if (hash.Contains(season))
                                continue;

                            hash.Add(season);
                            string link = $"{host}/lite/veoveo?rjson={rjson}&kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&s={season}";
                            tpl.Append($"{season} —Å–µ–∑–æ–Ω", link, season);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        var episodes = cache.Value.Where(i => i["season"].Value<int>("order") == s);

                        var etpl = new EpisodeTpl(episodes.Count());
                        string sArhc = s.ToString();

                        foreach (var episode in episodes.OrderBy(i => i.Value<int>("order")))
                        {
                            string name = episode.Value<string>("title");

                            string file = episode["episodeVariants"]
                                .OrderByDescending(i => i.Value<string>("filepath").Contains(".m3u8"))
                                .First()
                                .Value<string>("filepath");

                            if (string.IsNullOrEmpty(file))
                                continue;

                            string stream = HostStreamProxy(init, file, proxy: proxy);
                            etpl.Append(name ?? $"{episode.Value<int>("order")} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.Value<int>("order").ToString(), stream, vast: init.vast);
                        }

                        return rjson ? etpl.ToJson() : etpl.ToHtml();
                    }
                    #endregion
                }

            }, origsource: origsource);
        }

        #region Spider
        [HttpGet]
        [Route("lite/veoveo-spider")]
        public ActionResult Spider(string title)
        {
            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var stpl = new SimilarTpl(100);
            string _t = StringConvert.SearchName(title);
            if (string.IsNullOrEmpty(_t))
                return OnError();

            foreach (var m in database)
            {
                if (stpl.data.Count >= 100)
                    break;

                if (StringConvert.SearchName(m.title, string.Empty).Contains(_t) || StringConvert.SearchName(m.originalTitle, string.Empty).Contains(_t))
                {
                    string uri = $"{host}/lite/veoveo?movieid={m.id}";
                    stpl.Append(m.title ?? m.originalTitle, m.year.ToString(), string.Empty, uri, PosterApi.Find(m.kinopoiskId, m.imdbId));
                }
            }

            return ContentTo(stpl.ToJson());
        }
        #endregion

        #region search
        Movie? search(OnlinesSettings init, ProxyManager proxyManager, WebProxy proxy, string imdb_id, long kinopoisk_id, string title, string original_title)
        {
            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            Movie? goSearch(bool searchToId)
            {
                if (searchToId && kinopoisk_id == 0 && string.IsNullOrEmpty(imdb_id))
                    return null;

                foreach (var item in database)
                {
                    if (searchToId)
                    {
                        if (kinopoisk_id > 0)
                        {
                            if (item.kinopoiskId == kinopoisk_id)
                                return item;
                        }

                        if (!string.IsNullOrEmpty(imdb_id))
                        {
                            if (item.imdbId == imdb_id)
                                return item;
                        }
                    }
                    else
                    {
                        if (sorigtitle != null)
                        {
                            if (StringConvert.SearchName(item.originalTitle) == sorigtitle)
                                return item;
                        }

                        if (stitle != null)
                        {
                            if (StringConvert.SearchName(item.title) == stitle)
                                return item;
                        }
                    }
                }

                return null;
            }

            return goSearch(true) ?? goSearch(false);
        }
        #endregion
    }
}

```

## File: Online/Controllers/PiTor.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.PiTor;
using Shared.Models.Online.Settings;
using System.Data;

namespace Online.Controllers
{
    public class PiTor : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/pidtor")]
        async public ValueTask<ActionResult> Index(string account_email, string title, string original_title, int year, string original_language, int serial, int s = -1, bool rjson = false)
        {
            var init = AppInit.conf.PidTor;
            if (!init.enable)
                return OnError();

            if (NoAccessGroup(init, out string error_msg))
                return ShowError(error_msg);

            string memKey = $"pidtor:{title}:{original_title}:{year}";

            return await InvkSemaphore(null, memKey, async () =>
            {
                #region –ö–µ—à –∑–∞–ø—Ä–æ—Å–∞
                if (!hybridCache.TryGetValue(memKey, out List<(string name, string voice, string magnet, int sid, string tr, string quality, long size, string mediainfo, Result torrent)> torrents))
                {
                    var root = await Http.Get<RootObject>($"{init.redapi}/api/v2.0/indexers/all/results?title={HttpUtility.UrlEncode(title)}&title_original={HttpUtility.UrlEncode(original_title)}&year={year}&is_serial={(original_language == "ja" ? 5 : (serial + 1))}&apikey={init.apikey}", timeoutSeconds: 8);
                    if (root == null)
                        return Content(string.Empty, "text/html; charset=utf-8");

                    torrents = new List<(string name, string voice, string magnet, int sid, string tr, string quality, long size, string mediainfo, Result torrent)>();
                    var results = root?.Results;
                    if (results != null && results.Length > 0)
                    {
                        foreach (var torrent in results)
                        {
                            string magnet = torrent.MagnetUri;
                            string name = torrent.Title;

                            if (string.IsNullOrEmpty(magnet) || string.IsNullOrEmpty(name))
                                continue;

                            string tracker = torrent.Tracker;
                            if (tracker == "selezen")
                                continue;

                            if (init.max_serial_size > 0 && init.max_size > 0)
                            {
                                if (serial == 1)
                                {
                                    if (torrent.Size > init.max_serial_size)
                                        continue;
                                }
                                else
                                {
                                    if (torrent.Size > init.max_size)
                                        continue;
                                }
                            }
                            else
                            {
                                if (init.max_size > 0 && torrent.Size > init.max_size)
                                    continue;
                            }

                            if (init.forceAll || Regex.IsMatch(name.ToLower(), "(4k|uhd)( |\\]|,|$)") || name.Contains("2160p") || name.Contains("1080p") || name.Contains("720p"))
                            {
                                int sid = torrent.Seeders;
                                long? size = torrent.Size;

                                if (sid >= init.min_sid)
                                {
                                    string mediainfo = torrent.info.sizeName ?? string.Empty;
                                    if (!string.IsNullOrEmpty(mediainfo))
                                        mediainfo += " / ";

                                    #region –ü–µ—Ä–µ–≤–æ–¥
                                    string voicename = string.Empty;

                                    var voices = torrent.info.voices;
                                    if (voices != null && voices.Length > 0)
                                        voicename = string.Join(", ", voices);
                                    #endregion

                                    #region –ü–µ—Ä–µ–≤–æ–¥ 2
                                    if (string.IsNullOrWhiteSpace(voicename))
                                    {
                                        if (Regex.IsMatch(name.ToLower(), "( –¥–±| d|–¥—É–±–ª—è–∂)", RegexOptions.IgnoreCase))
                                            voicename += "–î—É–±–ª—è–∂, ";

                                        if (Regex.IsMatch(name.ToLower(), "( —Å—Ç| –ø–º)", RegexOptions.IgnoreCase))
                                            voicename += "–ú–Ω–æ–≥–æ–≥–æ–ª–æ—Å—ã–π, ";

                                        if (torrent.Tracker.ToLower() == "lostfilm")
                                        {
                                            voicename += "LostFilm, ";
                                        }
                                        else if (torrent.Tracker.ToLower() == "toloka")
                                        {
                                            voicename += "–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π, ";
                                        }
                                        else
                                        {
                                            var allVoices = new HashSet<string>
                                            {
                                                "Movie Dubbing", "Bravo Records", "Ozz", "Laci", "Kerob", "LE-Production",  "Parovoz Production", "Paradox", "Omskbird", "LostFilm", "–ü—Ä–∏—á—É–¥–∏–∫–∏", "BaibaKo", "NewStudio", "AlexFilm", "FocusStudio", "Gears Media", "Jaskier", "ViruseProject",
                                                "–ö—É–±–∏–∫ –≤ –ö—É–±–µ", "IdeaFilm", "Sunshine Studio", "Ozz.tv", "Hamster Studio", "–°–µ—Ä–±–∏–Ω", "To4ka", "–ö—Ä–∞–≤–µ—Ü", "Victory-Films", "SNK-TV", "GladiolusTV", "Jetvis Studio", "ApofysTeam", "ColdFilm",
                                                "Agatha Studdio", "KinoView", "Jimmy J.", "Shadow Dub Project", "Amedia", "Red Media", "Selena International", "–ì–æ–±–ª–∏–Ω", "Universal Russia", "Kiitos", "Paramount Comedy", "–ö—É—Ä–∞–∂-–ë–∞–º–±–µ–π",
                                                "–°—Ç—É–¥–∏—è –ü–∏—Ä–∞—Ç—Å–∫–æ–≥–æ –î—É–±–ª—è–∂–∞", "–ß–∞–¥–æ–≤", "–ö–∞—Ä–ø–æ–≤—Å–∫–∏–π", "RecentFilms", "–ü–µ—Ä–≤—ã–π –∫–∞–Ω–∞–ª", "Alternative Production", "NEON Studio", "–ö–æ–ª–æ–±–æ–∫", "–î–æ–ª—å—Å–∫–∏–π", "–°–∏–Ω–µ–º–∞ –£–°", "–ì–∞–≤—Ä–∏–ª–æ–≤", "–ñ–∏–≤–æ–≤", "SDI Media",
                                                "–ê–ª–µ–∫—Å–µ–µ–≤", "Green–†–∞–π Studio", "–ú–∏—Ö–∞–ª–µ–≤", "–ï—Å–∞—Ä–µ–≤", "–í–∏–∑–≥—É–Ω–æ–≤", "–õ–∏–±–µ—Ä–≥–∞–ª", "–ö—É–∑–Ω–µ—Ü–æ–≤", "–°–∞–Ω–∞–µ–≤", "–î–¢–í", "–î–æ—Ö–∞–ª–æ–≤", "Sunshine Studio", "–ì–æ—Ä—á–∞–∫–æ–≤", "LevshaFilm", "CasStudio", "–í–æ–ª–æ–¥–∞—Ä—Å–∫–∏–π",
                                                "ColdFilm", "–®–≤–∞—Ä–∫–æ", "–ö–∞—Ä—Ü–µ–≤", "ETV+", "–í–ì–¢–†–ö", "Gravi-TV", "1001cinema", "Zone Vision Studio", "–•–∏—Ö–∏–∫–∞—é—â–∏–π –¥–æ–∫—Ç–æ—Ä", "Murzilka", "turok1990", "FOX", "STEPonee", "Elrom", "–ö–æ–ª–æ–±–æ–∫", "HighHopes",
                                                "SoftBox", "Green–†–∞–π Studio", "NovaFilm", "–ß–µ—Ç—ã—Ä–µ –≤ –∫–≤–∞–¥—Ä–∞—Ç–µ", "Greb&Creative", "MUZOBOZ", "ZM-Show", "RecentFilms", "Kerems13", "Hamster Studio", "New Dream Media", "–ò–≥–º–∞—Ä", "–ö–æ—Ç–æ–≤", "DeadLine Studio",
                                                "Jetvis Studio", "–†–µ–Ω–¢–í", "–ê–Ω–¥—Ä–µ–π –ü–∏—Ç–µ—Ä—Å–∫–∏–π", "Fox Life", "–†—ã–±–∏–Ω", "Trdlo.studio", "Studio Victory –êsia", "Ozeon", "–ù–¢–í", "CP Digital", "AniLibria", "STEPonee", "Levelin", "FanStudio", "Cmert",
                                                "–ò–Ω—Ç–µ—Ä—Ñ–∏–ª—å–º", "SunshineStudio", "Kulzvuk Studio", "–ö–∞—à–∫–∏–Ω", "–í–∞—Ä—Ç–∞–Ω –î–æ—Ö–∞–ª–æ–≤", "–ù–µ–º–∞—Ö–æ–≤", "Sedorelli", "–°–¢–°", "–Ø—Ä–æ—Ü–∫–∏–π", "ICG", "–¢–í–¶", "–®—Ç–µ–π–Ω", "AzOnFilm", "SorzTeam", "–ì–∞–µ–≤—Å–∫–∏–π", "–ú—É–¥—Ä–æ–≤",
                                                "–í–æ—Ä–æ–±—å–µ–≤ –°–µ—Ä–≥–µ–π", "–°—Ç—É–¥–∏—è –†–∞–π–¥–æ", "DeeAFilm Studio", "zamez", "ViruseProject", "–ò–≤–∞–Ω–æ–≤", "STEPonee", "–†–µ–Ω–¢–í", "–°–í-–î—É–±–ª—å", "BadBajo", "–ö–æ–º–µ–¥–∏—è –¢–í", "–ú–∞—Å—Ç–µ—Ä –¢—ç–π–ø", "5-–π –∫–∞–Ω–∞–ª –°–ü–±", "SDI Media",
                                                "–ì–ª–∞–Ω—Ü", "–û—Ö! –°—Ç—É–¥–∏—è", "–°–í-–ö–∞–¥—Ä", "2x2", "–ö–æ—Ç–æ–≤–∞", "–ü–æ–∑–∏—Ç–∏–≤", "RusFilm", "–ù–∞–∑–∞—Ä–æ–≤", "XDUB Dorama", "–†–µ–∞–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥", "Kansai", "Sound-Group", "–ù–∏–∫–æ–ª–∞–π –î—Ä–æ–∑–¥–æ–≤", "ZEE TV", "Ozz.tv", "MTV",
                                                "–°—ã–µ–Ω–¥—É–∫", "GoldTeam", "–ë–µ–ª–æ–≤", "Dream Records", "–Ø–∫–æ–≤–ª–µ–≤", "Vano", "SilverSnow", "Lord32x", "Filiza Studio", "Sony Sci-Fi", "Flux-Team", "NewStation", "XDUB Dorama", "Hamster Studio", "Dream Records",
                                                "DexterTV", "ColdFilm", "Good People", "RusFilm", "Levelin", "AniDUB", "SHIZA Project", "AniLibria.TV", "StudioBand", "AniMedia", "Kansai", "Onibaku", "JWA Project", "MC Entertainment", "Oni", "Jade",
                                                "Ancord", "ANIvoice", "Nika Lenina", "Bars MacAdams", "JAM", "Anika", "Berial", "Kobayashi", "Cuba77", "RiZZ_fisher", "OSLIKt", "Lupin", "Ryc99", "Nazel & Freya", "Trina_D", "JeFerSon", "Vulpes Vulpes",
                                                "Hamster", "KinoGolos", "Fox Crime", "–î–µ–Ω–∏—Å –®–∞–¥–∏–Ω—Å–∫–∏–π", "AniFilm", "Rain Death", "LostFilm", "New Records", "Ancord", "–ü–µ—Ä–≤—ã–π –¢–í–ß", "RG.Paravozik", "Profix Media", "Tycoon", "RealFake",
                                                "HDrezka", "Jimmy J.", "AlexFilm", "Discovery", "Viasat History", "AniMedia", "JAM", "HiWayGrope", "Ancord", "–°–í-–î—É–±–ª—å", "Tycoon", "SHIZA Project", "GREEN TEA", "STEPonee", "AlphaProject",
                                                "AnimeReactor", "Animegroup", "Shachiburi", "Persona99", "3df voice", "CactusTeam", "AniMaunt", "AniMedia", "AnimeReactor", "ShinkaDan", "Jaskier", "ShowJet", "RAIM", "RusFilm", "Victory-Films",
                                                "–ê—Ä—Ö–∏–¢–µ–∞—Ç—Ä", "Project Web Mania", "ko136", "–ö—É—Ä–∞–°–≥—Ä–µ—á–µ–π", "AMS", "–°–í-–°—Ç—É–¥–∏—è", "–•—Ä–∞–º –î–æ—Ä–∞–º –¢–í", "TurkStar", "–ú–µ–¥–≤–µ–¥–µ–≤", "–†—è–±–æ–≤", "BukeDub", "FilmGate", "FilmsClub", "Sony Turbo", "–¢–í–¶", "AXN Sci-Fi",
                                                "NovaFilm", "DIVA Universal", "–ö—É—Ä–¥–æ–≤", "–ù–µ–æ–∫–ª–∞—Å—Å–∏–∫–∞", "fiendover", "SomeWax", "–õ–æ–≥–∏–Ω–æ—Ñ—Ñ", "Cartoon Network", "Sony Turbo", "Loginoff", "CrezaStudio", "–í–æ—Ä–æ—Ç–∏–ª–∏–Ω", "LakeFilms", "Andy", "CP Digital",
                                                "XDUB Dorama + –ö–æ–ª–æ–±–æ–∫", "SDI Media", "KosharaSerials", "–ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥ –ê—Ä—Ç", "Julia Prosenuk", "–ê–†–ö-–¢–í Studio", "–¢.–û –î—Ä—É–∑–µ–π", "Anifilm", "Animedub", "AlphaProject", "Paramount Channel", "–ö–∏—Ä–∏–ª–ª–∏—Ü–∞",
                                                "AniPLague", "–í–∏–¥–µ–æ—Å–µ—Ä–≤–∏—Å", "JoyStudio", "HighHopes", "TVShows", "AniFilm", "GostFilm", "West Video", "–§–æ—Ä–º–∞—Ç AB", "Film Prestige", "West Video", "–ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥ –ê—Ä—Ç", "SovetRomantica", "–†—É–§–∏–ª–º—Å",
                                                "AveBrasil", "Greb&Creative", "BTI Studios", "–ü–∏—Ñ–∞–≥–æ—Ä", "Eurochannel", "NewStudio", "–ö–∞—Ä–º–µ–Ω –í–∏–¥–µ–æ", "–ö–æ—à–∫–∏–Ω", "–ö—Ä–∞–≤–µ—Ü", "Rainbow World", "–í–æ—Ä–æ—Ç–∏–ª–∏–Ω", "–í–∞—Ä—É—Å-–í–∏–¥–µ–æ", "ClubFATE", "HiWay Grope",
                                                "Banyan Studio", "Mallorn Studio", "Asian Miracle Group", "–≠–π –ë–∏ –í–∏–¥–µ–æ", "AniStar", "Korean Craze", "LakeFilms", "–ù–µ–≤–∞—Ñ–∏–ª—å–º", "Hallmark", "Netflix", "Mallorn Studio", "Sony Channel", "East Dream",
                                                "Bonsai Studio", "Lucky Production", "Octopus", "TUMBLER Studio", "CrazyCatStudio", "Amber", "Train Studio", "–ê–Ω–∞—Å—Ç–∞—Å–∏—è –ì–∞–π–¥–∞—Ä–∂–∏", "–ú–∞–¥–ª–µ–Ω –î—é–≤–∞–ª—å", "Fox Life", "Sound Film", "Cowabunga Studio", "–§–∏–ª—å–º—ç–∫—Å–ø–æ—Ä—Ç",
                                                "VO-Production", "Sound Film", "Nickelodeon", "MixFilm", "Green–†–∞–π Studio", "Sound-Group", "Back Board Cinema", "–ö–∏—Ä–∏–ª–ª –°–∞–≥–∞—á", "Bonsai Studio", "Stevie", "OnisFilms", "MaxMeister", "Syfy Universal",
                                                "TUMBLER Studio", "NewStation", "Neo-Sound", "–ú—É—Ä–∞–≤—Å–∫–∏–π", "IdeaFilm", "–†—É—Ç–∏–ª–æ–≤", "–¢–∏–º–æ—Ñ–µ–µ–≤", "–õ–∞–≥—É—Ç–∞", "–î—å—è–∫–æ–Ω–æ–≤", "Zone Vision Studio", "Onibaku", "AniMaunt", "Voice Project", "AniStar", "–ü–∏—Ñ–∞–≥–æ—Ä",
                                                "VoicePower", "StudioFilms", "Elysium", "AniStar", "BeniAffet", "Selena International", "Paul Bunyan", "CoralMedia", "–ö–æ–Ω–¥–æ—Ä", "–ò–≥–º–∞—Ä", "ViP Premiere", "FireDub", "AveTurk", "Sony Sci-Fi", "–Ø–Ω–∫–µ–ª–µ–≤–∏—á",
                                                "–ö–∏—Ä–µ–µ–≤", "–ë–∞–≥–∏—á–µ–≤", "2x2", "–õ–µ–∫—Å–∏–∫–æ–Ω", "–ù–æ—Ç–∞", "Arisu", "Superbit", "AveDorama", "VideoBIZ", "–ö–∏–Ω–æ–º–∞–Ω–∏—è", "DDV", "Alternative Production", "WestFilm", "–ê–Ω–∞—Å—Ç–∞—Å–∏—è –ì–∞–π–¥–∞—Ä–∂–∏ + –ê–Ω–¥—Ä–µ–π –Æ—Ä—á–µ–Ω–∫–æ", "–ö–∏–Ω–æ–º–∞–Ω–∏—è",
                                                "Agatha Studdio", "Green–†–∞–π Studio", "VSI Moscow", "Horizon Studio", "Flarrow Films", "Amazing Dubbing", "Asian Miracle Group", "–í–∏–¥–µ–æ–ø—Ä–æ–¥–∞–∫—à–Ω", "VGM Studio", "FocusX", "CBS Drama", "NovaFilm", "Novamedia",
                                                "East Dream", "–î–∞—Å–µ–≤–∏—á", "–ê–Ω–∞—Ç–æ–ª–∏–π –ì—É—Å–µ–≤", "Twister", "–ú–æ—Ä–æ–∑–æ–≤", "NewComers", "kubik&ko", "DeMon", "–ê–Ω–∞—Ç–æ–ª–∏–π –ê—à–º–∞—Ä–∏–Ω", "Inter Video", "–ü—Ä–æ–Ω–∏–Ω", "AMC", "–í–µ–ª–µ—Å", "Volume-6 Studio", "–•–æ—Ä—Ä–æ—Ä –ú—ç–π–∫–µ—Ä",
                                                "Ghostface", "Sephiroth", "–ê–∫–∏—Ä–∞", "–î–µ–≤–∞–ª—å –í–∏–¥–µ–æ", "RussianGuy27", "neko64", "Shaman", "Franek Monk", "–í–æ—Ä–æ–Ω", "Andre1288", "Selena International", "GalVid", "–î—Ä—É–≥–æ–µ –∫–∏–Ω–æ", "–°—Ç—É–¥–∏—è NLS", "Sam2007",
                                                "HaseRiLLoPaW", "–°–µ–≤–∞—Å—Ç—å—è–Ω–æ–≤", "D.I.M.", "–ú–∞—Ä—á–µ–Ω–∫–æ", "–ñ—É—Ä–∞–≤–ª–µ–≤", "–ù-–ö–∏–Ω–æ", "Lazer Video", "SesDizi", "Red Media", "–†—É–¥–æ–π", "–¢–æ–≤–±–∏–Ω", "–°–µ—Ä–≥–µ–π –î–∏–¥–æ–∫", "–•—É–∞–Ω –†–æ—Ö–∞—Å", "binjak", "–ö–∞—Ä—É—Å–µ–ª—å", "Lizard Cinema",
                                                "–í–∞—Ä—É—Å-–í–∏–¥–µ–æ", "–ê–∫—Ü–µ–Ω—Ç", "RG.Paravozik", "Max Nabokov", "Barin101", "–í–∞—Å—å–∫–∞ –ö—É—Ä–æ–ª–µ—Å–æ–≤", "–§–æ—Ä—Ç—É–Ω–∞-–§–∏–ª—å–º", "Amalgama", "AnyFilm", "–°—Ç—É–¥–∏—è –†–∞–π–¥–æ", "–ö–æ–∑–ª–æ–≤", "Zoomvision Studio", "–ü–∏—Ñ–∞–≥–æ—Ä", "Urasiko",
                                                "VIP Serial HD", "–ù–°–¢", "–ö–∏–Ω–æ–ª—é–∫—Å", "Project Web Mania", "–ó–∞–≤–≥–æ—Ä–æ–¥–Ω–∏–π", "AB-Video", "Twister", "Universal Channel", "Wakanim", "SnowRecords", "–°.–†.–ò", "–°—Ç–∞—Ä—ã–π –ë–∏–ª—å–±–æ", "Ozz.tv", "Mystery Film", "–†–µ–Ω–¢–í",
                                                "–õ–∞—Ç—ã—à–µ–≤", "–í–∞—â–µ–Ω–∫–æ", "–õ–∞–π–∫–æ", "–°–æ–Ω–æ—Ç–µ–∫", "Psychotronic", "DIVA Universal", "Gremlin Creative Studio", "–ù–µ–≤–∞-1", "–ú–∞–∫—Å–∏–º –ñ–æ–ª–æ–±–æ–≤", "Good People", "–ú–æ–±–∏–ª—å–Ω–æ–µ —Ç–µ–ª–µ–≤–∏–¥–µ–Ω–∏–µ", "Lazer Video",
                                                "IVI", "DoubleRec", "Milvus", "RedDiamond Studio", "Astana TV", "–ù–∏–∫–∏—Ç–∏–Ω", "–ö–¢–ö", "D2Lab", "–ù–°–¢", "DoubleRec", "Black Street Records", "–û—Å—Ç–∞–Ω–∫–∏–Ω–æ", "TatamiFilm", "–í–∏–¥–µ–æ–±–∞–∑–∞", "Crunchyroll", "Novamedia",
                                                "RedRussian1337", "–ö–æ–Ω—Ç–µ–Ω—Ç–∏–∫OFF", "Creative Sound", "HelloMickey Production", "–ü–∏—Ä–∞–º–∏–¥–∞", "CLS Media", "–°–æ–Ω—å–∫–∏–Ω", "–ú–∞—Å—Ç–µ—Ä –¢—ç–π–ø", "Garsu Pasaulis", "DDV", "IdeaFilm", "Gold Cinema", "–ß–µ!", "–ù–∞—Ä—ã—à–∫–∏–Ω",
                                                "Intra Communications", "OnisFilms", "XDUB Dorama", "–ö–∏–ø–∞—Ä–∏—Å", "–ö–æ—Ä–æ–ª—ë–≤", "visanti-vasaer", "–ì–æ—Ç–ª–∏–±", "Paramount Channel", "–°–¢–°", "–¥–∏–∫—Ç–æ—Ä CDV", "Pazl Voice", "–ü—Ä—è–º–æ—Å—Ç–∞–Ω–æ–≤", "Zerzia", "–ù–¢–í", "MGM",
                                                "–î—å—è–∫–æ–≤", "–í–æ–ª—å–≥–∞", "–ê–†–ö-–¢–í Studio", "–î—É–±—Ä–æ–≤–∏–Ω", "–ú–ò–†", "Netflix", "Jetix", "–ö–∏–ø–∞—Ä–∏—Å", "RUSCICO", "Seoul Bay", "–§–∏–ª–æ–Ω–æ–≤", "–ú–∞—Ö–æ–Ω—å–∫–æ", "–°—Ç—Ä–æ–µ–≤", "–°–∞–Ω—è –ë–µ–ª—ã–π", "–ì–æ–≤–∏–Ω–¥–∞ –†–∞–≥–∞", "–û—à—É—Ä–∫–æ–≤", "Horror Maker",
                                                "–•–ª–æ–ø—É—à–∫–∞", "–•—Ä—É—Å—Ç–∞–ª–µ–≤", "–ê–Ω—Ç–æ–Ω–æ–≤ –ù–∏–∫–æ–ª–∞–π", "–ó–æ–ª–æ—Ç—É—Ö–∏–Ω", "–ê—Ä—Ö–∏–ê–∑–∏—è", "–ü–æ–ø–æ–≤", "Ultradox", "–ú–æ—Å—Ç-–í–∏–¥–µ–æ", "–ê–ª—å—Ç–µ—Ä–∞ –ü–∞—Ä—Å", "–û–≥–æ—Ä–æ–¥–Ω–∏–∫–æ–≤", "–¢–≤–∏–Ω", "–•–∞–±–∞—Ä", "AimaksaLTV", "–¢–ù–¢", "FDV", "3df voice",
                                                "The Kitchen Russia", "–£–ª—å–ø–∞–Ω–µ–π –≠–ª—å—Ä–æ–º", "–í–∏–¥–µ–æ–∏–º–ø—É–ª—å—Å", "GoodTime Media", "Alezan", "True Dubbing Studio", "FDV", "–ö–∞—Ä—É—Å–µ–ª—å", "–ò–Ω—Ç–µ—Ä", "Contentica", "–ú–µ–ª—å–Ω–∏—Ü–∞", "RealFake", "–ò–î–î–ö", "–ò–Ω—Ñ–æ-—Ñ–∏–ª—å–º",
                                                "–ú—å—é–∑–∏–∫-—Ç—Ä–µ–π–¥", "–ö–∏—Ä–¥–∏–Ω | Stalk", "–î–∏–æ–ù–∏–ö", "–°—Ç–∞—Å—é–∫", "TV1000", "Hallmark", "–¢–æ–Ω–∏–∫—Å –ú–µ–¥–∏–∞", "–ë–µ—Å—Å–æ–Ω–æ–≤", "Gears Media", "–ë–∞—Ö—É—Ä–∞–Ω–∏", "NewDub", "Cinema Prestige", "–ù–∞–±–∏–µ–≤", "New Dream Media", "–¢–í3",
                                                "–ú–∞–ª–∏–Ω–æ–≤—Å–∫–∏–π –°–µ—Ä–≥–µ–π", "Superbit", "–ö–µ–Ω—Å –ú–∞—Ç–≤–µ–π", "LE-Production", "Voiz", "–°–≤–µ—Ç–ª–∞", "Cinema Prestige", "JAM", "LDV", "Videogram", "–ò–Ω–¥–∏—è –¢–í", "RedDiamond Studio", "–ì–µ—Ä—É—Å–æ–≤", "–≠–ª–µ–≥–∏—è —Ñ–∏–ª—å–º", "Nastia",
                                                "–°–µ–º—ã–∫–∏–Ω–∞ –Æ–ª–∏—è", "–≠–ª–µ–∫—Ç—Ä–∏—á–∫–∞", "–®—Ç–∞–º–ø –î–º–∏—Ç—Ä–∏–π", "–ü—è—Ç–Ω–∏—Ü–∞", "Oneinchnales", "Gravi-TV", "D2Lab", "–ö–∏–Ω–æ–ø—Ä–µ–º—å–µ—Ä–∞", "–ë—É—Å–æ–≤ –ì–ª–µ–±", "LE-Production", "1001cinema", "Amazing Dubbing", "Emslie",
                                                "1+1", "100 –¢–í", "1001 cinema", "2+2", "2—Ö2", "3df voice", "4u2ges", "5 –∫–∞–Ω–∞–ª", "A. Lazarchuk", "AAA-Sound", "AB-Video", "AdiSound", "ALEKS KV", "AlexFilm", "AlphaProject", "Alternative Production",
                                                "Amalgam", "AMC", "Amedia", "AMS", "Andy", "AniLibria", "AniMedia", "Animegroup", "Animereactor", "AnimeSpace Team", "Anistar", "AniUA", "AniWayt", "Anything-group", "AOS",
                                                "Arasi project", "ARRU Workshop", "AuraFilm", "AvePremier", "AveTurk", "AXN Sci-Fi", "Azazel", "AzOnFilm", "BadBajo", "BadCatStudio", "BBC Saint-Petersburg", "BD CEE", "Black Street Records",
                                                "Bonsai Studio", "Bo–ª—å–≥a", "Brain Production", "BraveSound", "BTI Studios", "Bubble Dubbing Company", "Byako Records", "Cactus Team", "Cartoon Network", "CBS Drama", "CDV", "Cinema Prestige",
                                                "CinemaSET GROUP", "CinemaTone", "ColdFilm", "Contentica", "CP Digital", "CPIG", "Crunchyroll", "Cuba77", "D1", "D2lab", "datynet", "DDV", "DeadLine", "DeadSno", "DeMon", "den904", "Description",
                                                "DexterTV", "Dice", "Discovery", "DniproFilm", "DoubleRec", "DreamRecords", "DVD Classic", "East Dream", "Eladiel", "Elegia", "ELEKTRI4KA", "Elrom", "ELYSIUM", "Epic Team", "eraserhead", "erogg",
                                                "Eurochannel", "Extrabit", "F-TRAIN", "Family Fan Edition", "FDV", "FiliZa Studio", "Film Prestige", "FilmGate", "FilmsClub", "FireDub", "Flarrow Films", "Flux-Team", "FocusStudio", "FOX", "Fox Crime",
                                                "Fox Russia", "FoxLife", "Foxlight", "Franek Monk", "Gala Voices", "Garsu Pasaulis", "Gears Media", "Gemini", "General Film", "GetSmart", "Gezell Studio", "Gits", "GladiolusTV", "GoldTeam", "Good People",
                                                "Goodtime Media", "GoodVideo", "GostFilm", "Gramalant", "Gravi-TV", "GREEN TEA", "Green–†–∞–π Studio", "Gremlin Creative Studio", "Hallmark", "HamsterStudio", "HiWay Grope", "Horizon Studio", "hungry_inri",
                                                "ICG", "ICTV", "IdeaFilm", "IgVin &amp; Solncekleshka", "ImageArt", "INTERFILM", "Ivnet Cinema", "I–ù–¢–ï–†", "Jakob Bellmann", "JAM", "Janetta", "Jaskier", "JeFerSon", "jept", "JetiX", "Jetvis", "JimmyJ",
                                                "KANSAI", "KIHO", "kiitos", "KinoGolos", "Kinomania", "KosharaSerials", "K–æ–ª–æ–±–æ–∫", "L0cDoG", "LakeFilms", "LDV", "LE-Production", "LeDoyen", "LevshaFilm", "LeXiKC", "Liga HQ", "Line", "Lisitz",
                                                "Lizard Cinema Trade", "Lord32x", "lord666", "LostFilm", "Lucky Production", "Macross", "madrid", "Mallorn Studio", "Marclail", "Max Nabokov", "MC Entertainment", "MCA", "McElroy", "Mega-Anime",
                                                "Melodic Voice Studio", "metalrus", "MGM", "MifSnaiper", "Mikail", "Milirina", "MiraiDub", "MOYGOLOS", "MrRose", "MTV", "Murzilka", "MUZOBOZ", "National Geographic", "NemFilm", "Neoclassica", "NEON Studio",
                                                "New Dream Media", "NewComers", "NewStation", "NewStudio", "Nice-Media", "Nickelodeon", "No-Future", "NovaFilm", "Novamedia", "Octopus", "Oghra-Brown", "OMSKBIRD", "Onibaku", "OnisFilms", "OpenDub",
                                                "OSLIKt", "Ozz TV", "PaDet", "Paramount Comedy", "Paramount Pictures", "Parovoz Production", "PashaUp", "Paul Bunyan", "Pazl Voice", "PCB Translate", "Persona99", "PiratVoice", "Postmodern", "Profix Media",
                                                "Project Web Mania", "Prolix", "QTV", "R5", "Radamant", "RainDeath", "RATTLEBOX", "RealFake", "Reanimedia", "Rebel Voice", "RecentFilms", "Red Media", "RedDiamond Studio", "RedDog", "RedRussian1337",
                                                "Renegade Team", "RG Paravozik", "RinGo", "RoxMarty", "Rumble", "RUSCICO", "RusFilm", "RussianGuy27", "Saint Sound", "SakuraNight", "Satkur", "Sawyer888", "Sci-Fi Russia", "SDI Media", "Selena", "seqw0",
                                                "SesDizi", "SGEV", "Shachiburi", "SHIZA", "ShowJet", "Sky Voices", "SkyeFilmTV", "SmallFilm", "SmallFilm", "SNK-TV", "SnowRecords", "SOFTBOX", "SOLDLUCK2", "Solod", "SomeWax", "Sony Channel", "Sony Turbo",
                                                "Sound Film", "SpaceDust", "ssvss", "st.Elrom", "STEPonee", "SunshineStudio", "Superbit", "Suzaku", "sweet couple", "TatamiFilm", "TB5", "TF-AniGroup", "The Kitchen Russia", "The Mike Rec.", "Timecraft",
                                                "To4kaTV", "Tori", "Total DVD", "TrainStudio", "Troy", "True Dubbing Studio", "TUMBLER Studio", "turok1990", "TV 1000", "TVShows", "Twister", "Twix", "Tycoon", "Ultradox", "Universal Russia", "VashMax2",
                                                "VendettA", "VHS", "VicTeam", "VictoryFilms", "Video-BIZ", "Videogram", "ViruseProject", "visanti-vasaer", "VIZ Media", "VO-production", "Voice Project Studio", "VoicePower", "VSI Moscow", "VulpesVulpes",
                                                "Wakanim", "Wayland team", "WestFilm", "WiaDUB", "WVoice", "XL Media", "XvidClub Studio", "zamez", "ZEE TV", "Zendos", "ZM-SHOW", "Zone Studio", "Zone Vision", "–ê–≥–∞–ø–æ–≤", "–ê–∫–æ–ø—è–Ω", "–ê–ª–µ–∫—Å–µ–µ–≤", "–ê—Ä—Ç–µ–º—å–µ–≤",
                                                "–ë–∞–≥–∏—á–µ–≤", "–ë–µ—Å—Å–æ–Ω–æ–≤", "–í–∞—Å–∏–ª—å–µ–≤", "–í–∞—Å–∏–ª—å—Ü–µ–≤", "–ì–∞–≤—Ä–∏–ª–æ–≤", "–ì–µ—Ä—É—Å–æ–≤", "–ì–æ—Ç–ª–∏–±", "–ì—Ä–∏–≥–æ—Ä—å–µ–≤", "–î–∞—Å–µ–≤–∏—á", "–î–æ–ª—å—Å–∫–∏–π", "–ö–∞—Ä–ø–æ–≤—Å–∫–∏–π", "–ö–∞—à–∫–∏–Ω", "–ö–∏—Ä–µ–µ–≤", "–ö–ª—é–∫–≤–∏–Ω", "–ö–æ—Å—Ç—é–∫–µ–≤–∏—á", "–ú–∞—Ç–≤–µ–µ–≤", "–ú–∏—Ö–∞–ª–µ–≤", "–ú–∏—à–∏–Ω",
                                                "–ú—É–¥—Ä–æ–≤", "–ü—Ä–æ–Ω–∏–Ω", "–°–∞–≤—á–µ–Ω–∫–æ", "–°–º–∏—Ä–Ω–æ–≤", "–¢–∏–º–æ—Ñ–µ–µ–≤", "–¢–æ–ª—Å—Ç–æ–±—Ä–æ–≤", "–ß—É–µ–≤", "–®—É–≤–∞–µ–≤", "–Ø–∫–æ–≤–ª–µ–≤", "–ê–ê–ê-sound", "–ê–ë—ã–ì–î–µ", "–ê–∫–∞–ª–∏—Ç", "–ê–∫–∏—Ä–∞", "–ê–ª—å—è–Ω—Å", "–ê–º–∞–ª—å–≥–∞–º–∞", "–ê–ú–°", "–ê–Ω–í–∞–¥", "–ê–Ω—É–±–∏—Å", "Anubis", "–ê—Ä–∫-–¢–í",
                                                "–ê–†–ö-–¢–í Studio", "–ë. –§–µ–¥–æ—Ä–æ–≤", "–ë–∏–±–∏–∫–æ–≤", "–ë–∏–≥—ã—á", "–ë–æ–π–∫–æ–≤", "–ê–±–¥—É–ª–æ–≤", "–ë–µ–ª–æ–≤", "–í–∏—Ö—Ä–æ–≤", "–í–æ—Ä–æ–Ω—Ü–æ–≤", "–ì–æ—Ä—á–∞–∫–æ–≤", "–î–∞–Ω–∏–ª–æ–≤", "–î–æ—Ö–∞–ª–æ–≤", "–ö–æ—Ç–æ–≤", "–ö–æ—à–∫–∏–Ω", "–ù–∞–∑–∞—Ä–æ–≤", "–ü–æ–ø–æ–≤", "–†—É–∫–∏–Ω", "–†—É—Ç–∏–ª–æ–≤",
                                                "–í–∞—Ä—É—Å –í–∏–¥–µ–æ", "–í–∞—Å—å–∫–∞ –ö—É—Ä–æ–ª–µ—Å–æ–≤", "–í–∞—â–µ–Ω–∫–æ –°.", "–í–µ–∫—à–∏–Ω", "–í–µ–ª–µ—Å", "–í–µ—Å–µ–ª—å—á–∞–∫", "–í–∏–¥–µ–æ–∏–º–ø—É–ª—å—Å", "–í–∏—Ç—è ¬´–≥–æ–≤–æ—Ä—É–Ω¬ª", "–í–æ–π—Å–æ–≤–µ—Ä", "–í–æ–ª—å–≥–∞", "–í–æ—Ä–æ–Ω", "–í–æ—Ä–æ—Ç–∏–ª–∏–Ω", "–ì. –õ–∏–±–µ—Ä–≥–∞–ª", "–ì. –†—É–º—è–Ω—Ü–µ–≤", "–ì–µ–π –ö–∏–Ω–æ –ì–∏–¥",
                                                "–ì–ö–ì", "–ì–ª—É—Ö–æ–≤—Å–∫–∏–π", "–ì—Ä–∏–∑–ª–∏", "–ì—É–Ω–¥–æ—Å", "–î–µ–Ω—å—â–∏–∫–æ–≤", "–ï—Å–∞—Ä–µ–≤", "–ù—É—Ä–º—É—Ö–∞–º–µ—Ç–æ–≤", "–ü—É—á–∫–æ–≤", "–°—Ç–∞—Å—é–∫", "–®–∞–¥–∏–Ω—Å–∫–∏–π", "–®—Ç–∞–º–ø", "sf@irat", "–î–µ—Ä–∂–∏–º–æ—Ä–¥–∞", "–î–æ–º–∞—à–Ω–∏–π", "–î–¢–í", "–î—å—è–∫–æ–Ω–æ–≤", "–ï. –ì–∞–µ–≤—Å–∫–∏–π", "–ï. –ì—Ä–∞–Ω–∫–∏–Ω",
                                                "–ï. –õ—É—Ä—å–µ", "–ï. –†—É–¥–æ–π", "–ï. –•—Ä—É—Å—Ç–∞–ª—ë–≤", "–ï–ê –°–∏–Ω–µ–º–∞", "–ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥ –ê—Ä—Ç", "–ñ–∏–≤–∞–≥–æ", "–ñ—É—á–∫–æ–≤", "–ó –†–∞–Ω–∫—É –î–æ –ù–æ—á—ñ", "–ó–∞–≤–≥–æ—Ä–æ–¥–Ω–∏–π", "–ó–µ–±—É—Ä–æ", "–ó–µ—Ä–µ–Ω–∏—Ü—ã–Ω", "–ò. –ï—Ä–µ–º–µ–µ–≤", "–ò. –ö–ª—É—à–∏–Ω", "–ò. –°–∞—Ñ—Ä–æ–Ω–æ–≤", "–ò. –°—Ç–µ–ø–∞–Ω–æ–≤",
                                                "–ò–ì–ú", "–ò–≥–º–∞—Ä", "–ò–î–î–ö", "–ò–º–∏–¥–∂-–ê—Ä—Ç", "–ò–Ω–∏—Å", "–ò—Ä—ç–Ω", "–ò—Å—Ç-–í–µ—Å—Ç", "–ö. –ü–æ–∑–¥–Ω—è–∫–æ–≤", "–ö. –§–∏–ª–æ–Ω–æ–≤", "–ö9", "–ö–∞—Ä–∞–ø–µ—Ç—è–Ω", "–ö–∞—Ä–º–µ–Ω –í–∏–¥–µ–æ", "–ö–∞—Ä—É—Å–µ–ª—å", "–ö–≤–∞–¥—Ä–∞—Ç –ú–∞–ª–µ–≤–∏—á–∞", "–ö–∏–ª—å–∫–∞",  "–ö–∏–ø–∞—Ä–∏—Å", "–ö–æ—Ä–æ–ª–µ–≤", "–ö–æ—Ç–æ–≤–∞",
                                                "–ö—Ä–∞–≤–µ—Ü", "–ö—É–±–∏–∫ –≤ –ö—É–±–µ", "–ö—É—Ä–∞–∂-–ë–∞–º–±–µ–π", "–õ. –í–æ–ª–æ–¥–∞—Ä—Å–∫–∏–π", "–õ–∞–∑–µ—Ä –í–∏–¥–µ–æ", "–õ–∞–Ω—Å–µ–ª–∞–ü", "–õ–∞–ø—à–∏–Ω", "–õ–µ–∫—Å–∏–∫–æ–Ω", "–õ–µ–Ω—Ñ–∏–ª—å–º", "–õ–µ—à–∞ –ü—Ä–∞–ø–æ—Ä—â–∏–∫", "–õ–∏–∑–∞—Ä–¥", "–õ—é—Å—å–µ–Ω–∞", "–ó–∞—É–≥–∞—Ä–æ–≤", "–ò–≤–∞–Ω–æ–≤", "–ò–≤–∞–Ω–æ–≤–∞ –∏ –ü. –ü–∞—à—É—Ç",
                                                "–õ–∞—Ç—ã—à–µ–≤", "–û—à—É—Ä–∫–æ–≤", "–ß–∞–¥–æ–≤", "–Ø—Ä–æ—Ü–∫–∏–π", "–ú–∞–∫—Å–∏–º –õ–æ–≥–∏–Ω–æ—Ñ—Ñ", "–ú–∞–ª–∏–Ω–æ–≤—Å–∫–∏–π", "–ú–∞—Ä—á–µ–Ω–∫–æ", "–ú–∞—Å—Ç–µ—Ä –¢—ç–π–ø", "–ú–∞—Ö–æ–Ω—å–∫–æ", "–ú–∞—à–∏–Ω—Å–∫–∏–π", "–ú–µ–¥–∏–∞-–ö–æ–º–ø–ª–µ–∫—Å", "–ú–µ–ª—å–Ω–∏—Ü–∞", "–ú–∏–∫–∞ –ë–æ–Ω–¥–∞—Ä–∏–∫", "–ú–∏–Ω—è–µ–≤", "–ú–∏—Ç–µ–ª—å–º–∞–Ω",
                                                "–ú–æ—Å—Ç –í–∏–¥–µ–æ", "–ú–æ—Å—Ñ–∏–ª—å–º", "–ú—É—Ä–∞–≤—Å–∫–∏–π", "–ú—å—é–∑–∏–∫-—Ç—Ä–µ–π–¥", "–ù-–ö–∏–Ω–æ", "–ù. –ê–Ω—Ç–æ–Ω–æ–≤", "–ù. –î—Ä–æ–∑–¥–æ–≤", "–ù. –ó–æ–ª–æ—Ç—É—Ö–∏–Ω", "–ù.–°–µ–≤–∞—Å—Ç—å—è–Ω–æ–≤ seva1988", "–ù–∞–±–∏–µ–≤", "–ù–∞—Ç–∞–ª—å—è –ì—É—Ä–∑–æ", "–ù–ï–í–ê 1", "–ù–µ–≤–∞—Ñ–∏–ª—å–º", "–ù–µ–ó—É–ø–∏–Ω—è–π–ü—Ä–æ–¥–∞–∫—à–Ω",
                                                "–ù–µ–æ–∫–ª–∞—Å—Å–∏–∫–∞", "–ù–µ—Å–º–µ—Ä—Ç–µ–ª—å–Ω–æ–µ –æ—Ä—É–∂–∏–µ", "–ù–õ–û-TV", "–ù–æ–≤–∏–π", "–ù–æ–≤—ã–π –¥–∏—Å–∫", "–ù–æ–≤—ã–π –î—É–±–ª—è–∂", "–ù–æ–≤—ã–π –ö–∞–Ω–∞–ª", "–ù–æ—Ç–∞", "–ù–°–¢", "–ù–¢–í", "–ù–¢–ù", "–û–≤–µ—Ä–ª–æ—Ä–¥", "–û–≥–æ—Ä–æ–¥–Ω–∏–∫–æ–≤", "–û–º–∏–∫—Ä–æ–Ω", "–ì–ª–∞–Ω—Ü", "–ö–∞—Ä—Ü–µ–≤", "–ú–æ—Ä–æ–∑–æ–≤",
                                                "–ü—Ä—è–º–æ—Å—Ç–∞–Ω–æ–≤", "–°–∞–Ω–∞–µ–≤", "–ü–∞—Ä–∞–¥–∏–∑", "–ü–µ–ø–µ–ª–∞—Ü", "–ü–µ—Ä–≤—ã–π –∫–∞–Ω–∞–ª –û–†–¢", "–ü–µ—Ä–µ–≤–æ–¥–º–∞–Ω", "–ü–µ—Ä–µ—Ü", "–ü–µ—Ç–µ—Ä–±—É—Ä–≥—Å–∫–∏–π –¥—É–±–ª—è–∂", "–ü–µ—Ç–µ—Ä–±—É—Ä–∂–µ—Ü", "–ü–∏—Ä–∞–º–∏–¥–∞", "–ü–∏—Ñ–∞–≥–æ—Ä", "–ü–æ–∑–∏—Ç–∏–≤-–ú—É–ª—å—Ç–∏–º–µ–¥–∏–∞", "–ü—Ä–∞–π–¥ –ü—Ä–æ–¥–∞–∫—à–Ω", "–ü—Ä–µ–º—å–µ—Ä –í–∏–¥–µ–æ",
                                                "–ü—Ä–µ–º—å–µ—Ä –ú—É–ª—å—Ç–∏–º–µ–¥–∏–∞", "–ü—Ä–∏—á—É–¥–∏–∫–∏", "–†. –Ø–Ω–∫–µ–ª–µ–≤–∏—á", "–†–∞–π–¥–æ", "–†–∞–∫—É—Ä—Å", "–†–µ–Ω–¢–í", "–†–æ—Å—Å–∏—è", "–†–¢–†", "–†—É—Å—Å–∫–∏–π –¥—É–±–ª—è–∂", "–†—É—Å—Å–∫–∏–π –†–µ–ø–æ—Ä—Ç–∞–∂", "–†—É–§–∏–ª–º—Å", "–†—ã–∂–∏–π –ø–µ—Å", "–°. –í–∏–∑–≥—É–Ω–æ–≤", "–°. –î—å—è–∫–æ–≤", "–°. –ö–∞–∑–∞–∫–æ–≤",
                                                "–°. –ö—É–∑–Ω–µ—Ü–æ–≤", "–°. –ö—É–∑—å–º–∏—á—ë–≤", "–°. –õ–µ–±–µ–¥–µ–≤", "–°. –ú–∞–∫–∞—à–æ–≤", "–°. –†—è–±–æ–≤", "–°. –©–µ–≥–æ–ª—å–∫–æ–≤", "–°.–†.–ò.", "–°olumbia Service", "–°–∞–º–∞—Ä—Å–∫–∏–π", "–°–í –°—Ç—É–¥–∏—è", "–°–í-–î—É–±–ª—å", "–°–≤–µ—Ç–ª–∞", "–°–µ–ª–µ–Ω–∞ –ò–Ω—Ç–µ—Ä–Ω–µ—à–Ω–ª", "–°–∏–Ω–µ–º–∞ –¢—Ä–µ–π–¥",
                                                "–°–∏–Ω–µ–º–∞ –£–°", "–°–∏–Ω—Ç–∞ –†—É—Ä–æ–Ω–∏", "–°–∏–Ω—Ö—Ä–æ–Ω", "–°–æ–≤–µ—Ç—Å–∫–∏–π", "–°–æ–∫—É—Ä–æ–≤", "–°–æ–ª–æ–¥—É—Ö–∏–Ω", "–°–æ–Ω–æ—Ç–µ–∫", "–°–æ–Ω—å–∫–∏–Ω", "–°–æ—é–∑ –í–∏–¥–µ–æ", "–°–æ—é–∑–º—É–ª—å—Ç—Ñ–∏–ª—å–º", "–°–ü–î - –°–ª–∞–¥–∫–∞—è –ø–∞—Ä–æ—á–∫–∞", "–°—Ç—Ä–æ–µ–≤", "–°–¢–°", "–°—Ç—É–¥–∏–∏ –°—É–≤–µ—Ä–µ–Ω–Ω–æ–≥–æ –õ–µ–ø—Ä–æ–∑–æ—Ä–∏—è",
                                                "–°—Ç—É–¥–∏—è ¬´–°—Ç–∞—Ä—Ç—Ä–µ–∫¬ª", "KOleso", "–°—Ç—É–¥–∏—è –ì–æ—Ä—å–∫–æ–≥–æ", "–°—Ç—É–¥–∏—è –ö–æ–ª–æ–±–æ–∫", "–°—Ç—É–¥–∏—è –ü–∏—Ä–∞—Ç—Å–∫–æ–≥–æ –î—É–±–ª—è–∂–∞", "–°—Ç—É–¥–∏—è –†–∞–π–¥–æ", "–°—Ç—É–¥–∏—è –¢—Ä—ë—Ö", "–ì—É—Ä—Ç–æ–º", "–°—É–ø–µ—Ä–±–∏—Ç", "–°—ã–µ–Ω–¥—É–∫", "–¢–∞–∫ –¢—Ä–µ–±–∞ –ü—Ä–æ–¥–∞–∫—à–Ω", "–¢–í XXI –≤–µ–∫", "–¢–í –°–ü–±",
                                                "–¢–í-3", "–¢–í6", "–¢–í–ò–ù", "–¢–í–¶", "–¢–í–ß 1", "–¢–ù–¢", "–¢–û –î—Ä—É–∑–µ–π", "–¢–æ–ª–º–∞—á–µ–≤", "–¢–æ—á–∫–∞ Z—Ä–µ–Ω–∏—è", "–¢—Ä–∞–º–≤–∞–π-—Ñ–∏–ª—å–º", "–¢–†–ö", "–£–æ–ª—Ç –î–∏—Å–Ω–µ–π –ö–æ–º–ø–∞–Ω–∏", "–•–∏—Ö–∏–¥–æ–∫", "–•–ª–æ–ø—É—à–∫–∞", "–¶—ñ–∫–∞–≤–∞ –Ü–¥–µ—è", "–ß–µ—Ç—ã—Ä–µ –≤ –∫–≤–∞–¥—Ä–∞—Ç–µ", "–®–≤–µ—Ü–æ–≤",
                                                "–®—Ç–∞–º–ø", "–®—Ç–µ–π–Ω", "–Æ. –ñ–∏–≤–æ–≤", "–Æ. –ù–µ–º–∞—Ö–æ–≤", "–Æ. –°–µ—Ä–±–∏–Ω", "–Æ. –¢–æ–≤–±–∏–Ω", "–Ø. –ë–µ–ª–ª–º–∞–Ω–Ω", "–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π"
                                            };

                                            foreach (string v in allVoices)
                                            {
                                                if (v.Length > 4 && name.ToLower().Contains(v.ToLower()))
                                                    voicename += $"{v}, ";
                                            }
                                        }

                                        voicename = Regex.Replace(voicename, ", +$", "");
                                    }
                                    #endregion

                                    if (init.emptyVoice == false && string.IsNullOrEmpty(voicename))
                                        continue;

                                    voicename  = voicename ?? string.Empty;

                                    #region HDR / HEVC / Dolby Vision
                                    if (Regex.IsMatch(name, "HDR10", RegexOptions.IgnoreCase) || Regex.IsMatch(name, "10-?bit", RegexOptions.IgnoreCase))
                                        mediainfo += " HDR10 ";
                                    else if (Regex.IsMatch(name, "HDR", RegexOptions.IgnoreCase))
                                        mediainfo += " HDR ";
                                    else
                                    {
                                        mediainfo += " SDR ";
                                    }

                                    if (Regex.IsMatch(name, "HEVC", RegexOptions.IgnoreCase) || Regex.IsMatch(name, "H.265", RegexOptions.IgnoreCase))
                                        mediainfo += " / H.265 ";

                                    if (Regex.IsMatch(name, "Dolby Vision", RegexOptions.IgnoreCase))
                                        mediainfo += " / Dolby Vision ";
                                    #endregion

                                    #region tr arg
                                    string tr = string.Empty;
                                    var match = Regex.Match(magnet, "(&|\\?)tr=([^&\\?]+)");
                                    while (match.Success)
                                    {
                                        string t = match.Groups[2].Value.Trim().ToLower();
                                        if (!string.IsNullOrEmpty(t))
                                            tr += t.Contains("/") || t.Contains(":") ? $"&tr={HttpUtility.UrlEncode(t)}" : $"&tr={t}";

                                        match = match.NextMatch();
                                    }

                                    if (!string.IsNullOrEmpty(tr))
                                        tr = tr.Remove(0, 1);
                                    #endregion

                                    if (!string.IsNullOrEmpty(init.filter) && !Regex.IsMatch($"{name}:{voicename}", init.filter, RegexOptions.IgnoreCase))
                                        continue;

                                    if (!string.IsNullOrEmpty(init.filter_ignore) && Regex.IsMatch($"{name}:{voicename}", init.filter_ignore, RegexOptions.IgnoreCase))
                                        continue;

                                    torrents.Add((name, voicename, magnet, sid, tr, (name.Contains("2160p") ? "2160p" : name.Contains("1080p") ? "1080p" : "720–∑"), (torrent.Size ?? 0), mediainfo, torrent));
                                }
                            }
                        }
                    }

                    hybridCache.Set(memKey, torrents, DateTime.Now.AddMinutes(5));
                }

                if (torrents.Count == 0)
                    return Content(string.Empty);
                #endregion

                string en_title = HttpUtility.UrlEncode(title);
                string en_original_title = HttpUtility.UrlEncode(original_title);

                var movies = torrents
                    .OrderByDescending(i => i.voice.Contains("–î—É–±–ª—è–∂"))
                    .ThenByDescending(i => !string.IsNullOrEmpty(i.voice))
                    .ThenByDescending(i => i.magnet.Contains("&tr="));

                movies = init.sort == "size" 
                    ? movies.ThenByDescending(i => i.size) 
                    : init.sort == "sid" ? movies.ThenByDescending(i => i.sid) 
                    : movies.ThenByDescending(i => i.torrent.PublishDate);

                if (serial == 1)
                {
                    if (s == -1)
                    {
                        HashSet<int> seasons = new HashSet<int>();

                        var tpl = new SeasonTpl(quality: movies.FirstOrDefault
                        (
                            i => Regex.IsMatch(i.name, "(4k|uhd)( |\\]|,|$)", RegexOptions.IgnoreCase) || i.name.Contains("2160p")).name != null ? "2160p" :
                                 movies.FirstOrDefault(i => i.name.Contains("1080p")).name != null ? "1080p" : "720p"
                        );

                        foreach (var t in movies)
                        {
                            if (t.torrent.info.seasons == null || t.torrent.info.seasons.Length == 0)
                                continue;

                            foreach (var item in t.torrent.info.seasons)
                                seasons.Add(item);
                        }

                        foreach (int season in seasons.OrderBy(i => i))
                            tpl.Append($"{season} —Å–µ–∑–æ–Ω", $"{host}/lite/pidtor?rjson={rjson}&title={en_title}&original_title={en_original_title}&year={year}&original_language={original_language}&serial=1&s={season}", season);

                        return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                    }
                    else
                    {
                        var stpl = new SimilarTpl();

                        foreach (var torrent in movies)
                        {
                            if (torrent.torrent.info.seasons == null || torrent.torrent.info.seasons.Length == 0)
                                continue;

                            if (!torrent.torrent.info.seasons.Contains(s) || torrent.torrent.info.seasons.Length != 1) // –º–Ω–æ–≥–æ—Å–µ–∑–æ–Ω–Ω—ã–π 
                                continue;

                            string hashmagnet = Regex.Match(torrent.magnet, "magnet:\\?xt=urn:btih:([a-zA-Z0-9]+)").Groups[1].Value.ToLower();
                            if (string.IsNullOrWhiteSpace(hashmagnet))
                                continue;

                            stpl.Append(torrent.voice, null, $"{torrent.quality} / {torrent.mediainfo} / {torrent.sid}", accsArgs($"{host}/lite/pidtor/serial/{hashmagnet}?{torrent.tr}&rjson={rjson}&title={en_title}&original_title={en_original_title}&s={s}"));
                        }

                        return ContentTo(rjson ? stpl.ToJson() : stpl.ToHtml());
                    }
                }
                else
                {
                    var mtpl = new MovieTpl(title, original_title);

                    foreach (var torrent in movies)
                    {
                        string hashmagnet = Regex.Match(torrent.magnet, "magnet:\\?xt=urn:btih:([a-zA-Z0-9]+)").Groups[1].Value.ToLower();
                        if (string.IsNullOrWhiteSpace(hashmagnet))
                            continue;

                        mtpl.Append(torrent.voice, accsArgs($"{host}/lite/pidtor/s{hashmagnet}?{torrent.tr}"), voice_name: $"{torrent.quality} / {torrent.mediainfo} / {torrent.sid}", quality: torrent.quality.Replace("p", ""));
                    }

                    return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                }
            });
        }


        [HttpGet]
        [Route("lite/pidtor/serial/{id}")]
        async public ValueTask<ActionResult> Serial(string id, string account_email, string title, string original_title, int s, bool rjson = false)
        {
            var init = AppInit.conf.PidTor;
            if (!init.enable)
                return OnError();

            if (NoAccessGroup(init, out string error_msg))
                return ShowError(error_msg);

            string tr = Regex.Replace(HttpContext.Request.QueryString.Value.Remove(0, 1), "&(account_email|uid|token|title|original_title|rjson|s)=[^&]+", "");

            string memKey = $"pidtor:serial:{id}";

            return await InvkSemaphore(null, memKey, async () =>
            {
                #region –ö–µ—à –∑–∞–ø—Ä–æ—Å–∞
                if (!hybridCache.TryGetValue(memKey, out FileStat[] file_stats))
                {
                    #region gots
                    (List<HeadersModel> header, string host) gots()
                    {
                        if ((init.torrs == null || init.torrs.Length == 0) && (init.auth_torrs == null || init.auth_torrs.Count == 0))
                        {
                            if (System.IO.File.Exists("torrserver/accs.db"))
                            {
                                string accs = System.IO.File.ReadAllText("torrserver/accs.db");
                                string passwd = Regex.Match(accs, "\"ts\":\"([^\"]+)\"").Groups[1].Value;

                                return (HeadersModel.Init("Authorization", $"Basic {CrypTo.Base64($"ts:{passwd}")}"), $"http://{AppInit.conf.listen.localhost}:9080");
                            }

                            return (null, $"http://{AppInit.conf.listen.localhost}:9080");
                        }

                        if (init.auth_torrs != null && init.auth_torrs.Count > 0)
                        {
                            var ts = init.auth_torrs.First();
                            string login = ts.login.Replace("{account_email}", account_email);
                            var auth = HeadersModel.Init("Authorization", $"Basic {CrypTo.Base64($"{login}:{ts.passwd}")}");

                            return (httpHeaders(ts.host, HeadersModel.Join(auth, ts.headers)), ts.host);
                        }
                        else
                        {
                            if (init.base_auth != null && init.base_auth.enable)
                            {
                                var ts = init.auth_torrs.First();
                                string login = init.base_auth.login.Replace("{account_email}", account_email);
                                var auth = HeadersModel.Init("Authorization", $"Basic {CrypTo.Base64($"{login}:{init.base_auth.passwd}")}");

                                return (httpHeaders(ts.host, HeadersModel.Join(auth, init.base_auth.headers)), ts.host);
                            }

                            return (null, init.torrs.First());
                        }
                    }
                    #endregion

                    var ts = gots();

                    string magnet = $"magnet:?xt=urn:btih:{id}&" + tr;
                    string hash = await Http.Post($"{ts.host}/torrents", "{\"action\":\"add\",\"link\":\"" + magnet + "\",\"title\":\"\",\"poster\":\"\",\"save_to_db\":false}", timeoutSeconds: 8, headers: ts.header);
                    if (hash == null)
                        return OnError();

                    hash = Regex.Match(hash, "\"hash\":\"([^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(hash))
                        return OnError();

                    Stat stat = null;
                    var ex = DateTime.Now.AddSeconds(20);

                resetgotingo: stat = await Http.Post<Stat>($"{ts.host}/torrents", "{\"action\":\"get\",\"hash\":\"" + hash + "\"}", timeoutSeconds: 3, headers: ts.header);
                    if (stat?.file_stats == null || stat.file_stats.Length == 0)
                    {
                        if (DateTime.Now > ex)
                        {
                            _ = Http.Post($"{ts.host}/torrents", "{\"action\":\"rem\",\"hash\":\"" + hash + "\"}", headers: ts.header);
                            return OnError();
                        }

                        await Task.Delay(250);
                        goto resetgotingo;
                    }

                    _ = Http.Post($"{ts.host}/torrents", "{\"action\":\"rem\",\"hash\":\"" + hash + "\"}", headers: ts.header);

                    file_stats = stat.file_stats;
                    hybridCache.Set(memKey, file_stats, DateTime.Now.AddHours(36));
                }
                #endregion

                var mtpl = new EpisodeTpl();

                foreach (var torrent in file_stats)
                {
                    if (Path.GetExtension(torrent.Path) is ".srt" or ".txt" or ".jpg" or ".png")
                        continue;

                    mtpl.Append(Path.GetFileName(torrent.Path), title ?? original_title, s.ToString(), torrent.Id.ToString(), accsArgs($"{host}/lite/pidtor/s{id}?{tr}&tsid={torrent.Id}"));
                }

                return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
            });
        }


        [HttpGet]
        [Route("lite/pidtor/s{id}")]
        async public ValueTask<ActionResult> Stream(string id, int tsid = -1, string account_email = null)
        {
            var init = AppInit.conf.PidTor;
            if (!init.enable)
                return OnError();

            if (NoAccessGroup(init, out string error_msg))
                return ShowError(error_msg);

            string country = requestInfo.Country;

            int index = tsid != -1 ? tsid : 1;
            string magnet = $"magnet:?xt=urn:btih:{id}&" + Regex.Replace(HttpContext.Request.QueryString.Value.Remove(0, 1), "&(account_email|uid|token|tsid)=[^&]+", "");

            #region auth_stream
            async ValueTask<ActionResult> auth_stream(string host, string login, string passwd, string uhost = null, Dictionary<string, string> addheaders = null)
            {
                string memKey = $"pidtor:auth_stream:{id}:{uhost ?? host}";
                if (!hybridCache.TryGetValue(memKey, out string hash))
                {
                    login = login.Replace("{account_email}", account_email ?? string.Empty);

                    var headers = HeadersModel.Init("Authorization", $"Basic {CrypTo.Base64($"{login}:{passwd}")}");
                        headers = HeadersModel.Join(headers, addheaders);

                    hash = await Http.Post($"{host}/torrents", "{\"action\":\"add\",\"link\":\"" + magnet + "\",\"title\":\"\",\"poster\":\"\",\"save_to_db\":false}", timeoutSeconds: 5, headers: headers);
                    if (hash == null)
                        return OnError($"{host} unavailable");

                    hash = Regex.Match(hash, "\"hash\":\"([^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(hash))
                        return OnError("hash null");

                    hybridCache.Set(memKey, hash, DateTime.Now.AddMinutes(1));
                }

                return Redirect($"{uhost ?? host}/stream?link={hash}&index={index}&play");
            }
            #endregion

            if ((init.torrs == null || init.torrs.Length == 0) && (init.auth_torrs == null || init.auth_torrs.Count == 0))
            {
                if (System.IO.File.Exists("torrserver/accs.db"))
                {
                    string accs = System.IO.File.ReadAllText("torrserver/accs.db");
                    string passwd = Regex.Match(accs, "\"ts\":\"([^\"]+)\"").Groups[1].Value;

                    return await auth_stream($"http://{AppInit.conf.listen.localhost}:9080", "ts", passwd, uhost: $"{host}/ts");
                }

                return Redirect($"{host}/ts/stream?link={HttpUtility.UrlEncode(magnet)}&index={index}&play");
            }

            if (init.auth_torrs != null && init.auth_torrs.Count > 0)
            {
                string tskey = $"pidtor:ts2:{id}:{requestInfo.IP}";
                if (!hybridCache.TryGetValue(tskey, out PidTorAuthTS ts))
                {
                    var tors = init.auth_torrs.Where(i => i.enable).ToList();

                    if (country != null)
                        tors = tors.Where(i => i.country == null || i.country.Contains(country)).Where(i => i.no_country == null || !i.no_country.Contains(country)).ToList();

                    ts = tors[Random.Shared.Next(0, tors.Count)];
                    hybridCache.Set(tskey, ts, DateTime.Now.AddHours(4));
                }

                return await auth_stream(ts.host, ts.login, ts.passwd, addheaders: ts.headers);
            }
            else 
            {
                if (init.base_auth != null && init.base_auth.enable)
                {
                    string tskey = $"pidtor:ts3:{id}:{requestInfo.IP}";
                    if (!hybridCache.TryGetValue(tskey, out string ts))
                    {
                        ts = init.torrs[Random.Shared.Next(0, init.torrs.Length)];
                        hybridCache.Set(tskey, ts, DateTime.Now.AddHours(4));
                    }

                    return await auth_stream(ts, init.base_auth.login, init.base_auth.passwd, addheaders: init.base_auth.headers);
                }

                string key = $"pidtor:ts4:{id}:{requestInfo.IP}";
                if (!hybridCache.TryGetValue(key, out string tshost))
                {
                    tshost = init.torrs[Random.Shared.Next(0, init.torrs.Length)];
                    hybridCache.Set(key, tshost, DateTime.Now.AddHours(4));
                }

                return Redirect($"{tshost}/stream?link={HttpUtility.UrlEncode(magnet)}&index={index}&play");
            }
        }
    }
}

```

## File: Online/Controllers/FilmixPartner.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Filmix;
using System.Security.Cryptography;
using System.Text;

namespace Online.Controllers
{
    public class FilmixPartner : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/fxapi")]
        async public ValueTask<ActionResult> Index(long kinopoisk_id, bool checksearch, string title, string original_title, int year, int postid, int t = -1, int s = -1, bool rjson = false, bool similar = false, string source = null, string id = null)
        {
            if (postid == 0 && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() is "filmix" or "filmixapp")
                {
                    if (!int.TryParse(id, out postid))
                        int.TryParse(Regex.Match(id, "/([0-9]+)-").Groups[1].Value, out postid);
                }
            }

            var init = await loadKit(AppInit.conf.FilmixPartner);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (postid == 0)
            {
                var res = await InvokeCache($"fxapi:search:{title}:{original_title}:{similar}", cacheTime(40, init: init), () => Search(title, original_title, year, similar));
                if (similar)
                    return ContentTo(rjson ? res.similars.Value.ToJson() : res.similars.Value.ToHtml());

                if (res != null)
                    postid = res.id;

                // –ø–ª–∞—Ç–Ω—ã–π –ø–æ–∏—Å–∫
                if (!checksearch && postid == 0 && kinopoisk_id > 0)
                    postid = await searchKp(kinopoisk_id);

                if (postid == 0 && res?.similars != null)
                    return ContentTo(rjson ? res.similars.Value.ToJson() : res.similars.Value.ToHtml());
            }

            if (postid == 0)
                return OnError();

            if (checksearch)
                return Content("data-json=");

            string hashKey = $"fxapi:hashfimix:{requestInfo.IP}";
            hybridCache.TryGetValue(hashKey, out string hashfimix);

            string videoKey = $"fxapi:{postid}:{(string.IsNullOrEmpty(hashfimix) ? requestInfo.IP : "")}";

            return await InvkSemaphore(init, videoKey, async () =>
            {
                #region video_links
                if (!hybridCache.TryGetValue(videoKey, out JArray root))
                {
                    string XFXTOKEN = await getXFXTOKEN(requestInfo.user_uid);
                    if (string.IsNullOrWhiteSpace(XFXTOKEN))
                        return OnError();

                    root = await Http.Get<JArray>($"{init.corsHost()}/video_links/{postid}", headers: httpHeaders(init, HeadersModel.Init("X-FX-TOKEN", XFXTOKEN)));

                    if (root == null || root.Count == 0)
                        return OnError();

                    var first = root.First.ToObject<JObject>();
                    if (!first.ContainsKey("files") && !first.ContainsKey("seasons"))
                        return OnError();

                    if (string.IsNullOrEmpty(hashfimix))
                    {
                        hashfimix = Regex.Match(root.First.ToString().Replace("\\", ""), "/s/([^/]+)/").Groups[1].Value;

                        if (!string.IsNullOrEmpty(hashfimix))
                        {
                            videoKey = $"fxapi:{postid}";
                            hybridCache.Set(hashKey, hashfimix, DateTime.Now.AddHours(1));
                        }
                    }

                    hybridCache.Set(videoKey, root, DateTime.Now.AddHours(2));
                }
                #endregion

                if (root.First.ToObject<JObject>().ContainsKey("files"))
                {
                    #region –§–∏–ª—å–º
                    var mtpl = new MovieTpl(title, original_title, root.Count);

                    foreach (var movie in root)
                    {
                        var streamquality = new StreamQualityTpl();

                        foreach (var file in movie.Value<JArray>("files").OrderByDescending(i => i.Value<int>("quality")))
                        {
                            int q = file.Value<int>("quality");
                            string url = file.Value<string>("url");
                            if (!string.IsNullOrEmpty(hashfimix))
                                url = Regex.Replace(url, "/s/[^/]+/", $"/s/{hashfimix}/");

                            streamquality.Append(HostStreamProxy(init, url), $"{q}p");
                        }

                        mtpl.Append(movie.Value<string>("name"), streamquality.Firts().link, streamquality: streamquality, vast: init.vast);
                    }

                    return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∞–ª
                    if (s == -1)
                    {
                        #region –°–µ–∑–æ–Ω—ã
                        var tpl = new SeasonTpl(root.Count);
                        var temp_season = new HashSet<int>();

                        foreach (var translation in root)
                        {
                            foreach (var season in translation.Value<JArray>("seasons"))
                            {
                                int sid = season.Value<int>("season");
                                string sname = $"{sid} —Å–µ–∑–æ–Ω";

                                if (!temp_season.Contains(sid))
                                {
                                    temp_season.Add(sid);
                                    string link = $"{host}/lite/fxapi?rjson={rjson}&postid={postid}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&s={sid}";
                                    tpl.Append(sname, link, sid);
                                }
                            }
                        }

                        return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                        #endregion
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        int indexTranslate = 0;
                        var vtpl = new VoiceTpl();

                        foreach (var translation in root)
                        {
                            foreach (var season in translation.Value<JArray>("seasons"))
                            {
                                if (season.Value<int>("season") == s)
                                {
                                    string link = $"{host}/lite/fxapi?rjson={rjson}&postid={postid}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&s={s}&t={indexTranslate}";
                                    bool active = t == indexTranslate;

                                    if (t == -1)
                                        t = indexTranslate;

                                    vtpl.Append(translation.Value<string>("name"), active, link);
                                    break;
                                }
                            }

                            indexTranslate++;
                        }
                        #endregion

                        #region –°–µ—Ä–∏–∏
                        var etpl = new EpisodeTpl();
                        string sArhc = s.ToString();

                        foreach (var episode in root[t].Value<JArray>("seasons").FirstOrDefault(i => i.Value<int>("season") == s).Value<JObject>("episodes").ToObject<Dictionary<string, JObject>>().Values)
                        {
                            var streamquality = new StreamQualityTpl();

                            foreach (var file in episode.Value<JArray>("files").OrderByDescending(i => i.Value<int>("quality")))
                            {
                                int q = file.Value<int>("quality");
                                string url = file.Value<string>("url");
                                if (!string.IsNullOrEmpty(hashfimix))
                                    url = Regex.Replace(url, "/s/[^/]+/", $"/s/{hashfimix}/");

                                string l = HostStreamProxy(init, url);

                                streamquality.Append(l, $"{q}p");
                            }

                            int e = episode.Value<int>("episode");
                            etpl.Append($"{e} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, e.ToString(), streamquality.Firts().link, streamquality: streamquality, vast: init.vast);
                        }
                        #endregion

                        if (rjson)
                            return ContentTo(etpl.ToJson(vtpl));

                        return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                    }
                    #endregion
                }
            });
        }


        [HttpGet]
        [Route("lite/fxapi/lowlevel/{*uri}")]
        async public Task<ActionResult> LowlevelApi(string uri)
        {
            var init = AppInit.conf.FilmixPartner;

            if (!init.enable)
                return OnError("disable", gbcache: false);

            if (!HttpContext.Request.Headers.TryGetValue("low_passw", out var low_passw) || low_passw.ToString() != init.lowlevel_api_passw)
                return OnError("lowlevel_api", gbcache: false);

            string XFXTOKEN = await getXFXTOKEN();
            if (string.IsNullOrWhiteSpace(XFXTOKEN))
                return OnError("XFXTOKEN", gbcache: false);

            string json = await Http.Get($"{init.corsHost()}/{uri}", headers: httpHeaders(init, HeadersModel.Init("X-FX-TOKEN", XFXTOKEN)));

            return Content(json, "application/json; charset=utf-8");
        }


        #region search
        async ValueTask<int> searchKp(long kinopoisk_id)
        {
            if (kinopoisk_id == 0)
                return 0;

            string memKey = $"fxapi:search:{kinopoisk_id}";
            if (!hybridCache.TryGetValue(memKey, out int postid))
            {
                string XFXTOKEN = await getXFXTOKEN();
                if (string.IsNullOrWhiteSpace(XFXTOKEN))
                    return 0;

                var root = await Http.Get<JObject>($"{AppInit.conf.FilmixPartner.corsHost()}/film/by-kp/{kinopoisk_id}", headers: httpHeaders(AppInit.conf.FilmixPartner, HeadersModel.Init("X-FX-TOKEN", XFXTOKEN)));

                if (root == null || !root.ContainsKey("id"))
                    return 0;

                postid = root.Value<int>("id"); 

                if (postid > 0)
                    hybridCache.Set(memKey, postid, DateTime.Now.AddDays(20));
                else
                    hybridCache.Set(memKey, postid, DateTime.Now.AddDays(1));
            }

            return postid;
        }


        async ValueTask<SearchResult> Search(string title, string original_title, int year, bool similar)
        {
            if (string.IsNullOrWhiteSpace(title ?? original_title))
                return null;

            var proxyManager = new ProxyManager("filmix", AppInit.conf.Filmix);
            var proxy = proxyManager.Get();

            string uri = $"{AppInit.conf.Filmix.corsHost()}/api/v2/search?story={HttpUtility.UrlEncode(title)}&user_dev_apk=2.0.1&user_dev_id=&user_dev_name=Xiaomi&user_dev_os=11&user_dev_token={AppInit.conf.Filmix.token}&user_dev_vendor=Xiaomi";

            string json = await Http.Get(AppInit.conf.Filmix.cors(uri), timeoutSeconds: 7, proxy: proxy, useDefaultHeaders: false, headers: HeadersModel.Init(
                ("Accept-Encoding", "gzip")
            ));

            if (json == null)
            {
                proxyManager.Refresh();
                return await Search2(title, original_title, year);
            }

            List<SearchModel> root = null;

            try
            {
                root = JsonConvert.DeserializeObject<List<SearchModel>>(json);
            }
            catch { }

            if (root == null || root.Count == 0)
                return await Search2(title, original_title, year);

            var ids = new List<int>();
            var stpl = new SimilarTpl(root.Count);

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            foreach (var item in root)
            {
                if (item == null)
                    continue;

                string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.original_title) ? $"{item.title} / {item.original_title}" : (item.title ?? item.original_title);

                stpl.Append(name, item.year.ToString(), string.Empty, host + $"lite/fxapi?postid={item.id}&title={enc_title}&original_title={enc_original_title}", PosterApi.Size(item.poster));

                if ((!string.IsNullOrEmpty(stitle) && StringConvert.SearchName(item.title) == stitle) ||
                    (!string.IsNullOrEmpty(sorigtitle) && StringConvert.SearchName(item.original_title) == sorigtitle))
                {
                    if (item.year == year)
                        ids.Add(item.id);
                }
            }

            if (ids.Count == 1 &&!similar)
                return new SearchResult() { id = ids[0] };

            return new SearchResult() { similars = stpl };
        }


        async Task<SearchResult> Search2(string? title, string? original_title, int year)
        {
            async Task<List<SearchModel>> gosearch(string? story)
            {
                if (string.IsNullOrEmpty(story))
                    return null;

                string uri = $"https://api.filmix.tv/api-fx/list?search={HttpUtility.UrlEncode(story)}&limit=48";

                string json = await Http.Get(uri, timeoutSeconds: 5);
                if (string.IsNullOrEmpty(json) || !json.Contains("\"status\":\"ok\""))
                    return null;

                List<SearchModel> root = null;

                try
                {
                    root = JsonConvert.DeserializeObject<List<SearchModel>>(json);
                }
                catch { }

                if (root == null || root.Count == 0)
                    return null;

                return root;
            }

            var result = await gosearch(original_title);
            if (result == null)
                result = await gosearch(title);

            if (result == null)
                return default;

            var ids = new List<int>();
            var stpl = new SimilarTpl(result.Count);

            string? enc_title = HttpUtility.UrlEncode(title);
            string? enc_original_title = HttpUtility.UrlEncode(original_title);

            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            foreach (var item in result)
            {
                if (item == null)
                    continue;

                string? name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.original_title) ? $"{item.title} / {item.original_title}" : (item.title ?? item.original_title);

                stpl.Append(name, item.year.ToString(), string.Empty, host + $"lite/filmix?postid={item.id}&title={enc_title}&original_title={enc_original_title}", PosterApi.Size(item.poster));

                if ((!string.IsNullOrEmpty(stitle) && StringConvert.SearchName(item.title) == stitle) ||
                    (!string.IsNullOrEmpty(sorigtitle) && StringConvert.SearchName(item.original_title) == sorigtitle))
                {
                    if (item.year == year)
                        ids.Add(item.id);
                }
            }

            if (ids.Count == 1)
                return new SearchResult() { id = ids[0] };

            return new SearchResult() { similars = stpl };
        }
        #endregion

        #region getXFXTOKEN
        static long userid = 1;

        static string serverip = null;

        async ValueTask<string> getXFXTOKEN(string uid = null)
        {
            var init = AppInit.conf.FilmixPartner;

            if (serverip == null)
            {
                var myip = await Http.Get<JObject>($"{init.host}/my_ip", headers: httpHeaders(init));
                if (myip == null || string.IsNullOrWhiteSpace(myip.Value<string>("ip")))
                    return null;

                serverip = myip.Value<string>("ip");
            }

            if (userid > 20_000)
                userid = 1;
            userid++;

            if (uid != null)
            {
                using (SHA256 sha256Hash = SHA256.Create())
                {
                    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫—É –≤ –±–∞–π—Ç—ã –∏ –≤—ã—á–∏—Å–ª—è–µ–º —Ö—ç—à
                    byte[] bytes = sha256Hash.ComputeHash(Encoding.UTF8.GetBytes(uid));

                    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –ø–µ—Ä–≤—ã–µ 8 –±–∞–π—Ç —Ö—ç—à–∞ –≤ —á–∏—Å–ª–æ
                    long result = BitConverter.ToInt64(bytes, 0);
                    userid = Math.Abs(result); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                }
            }

            string XNICK = ReverseString(DateTime.Now.ToString("HHmm")) + DateTime.Now.ToString("yyyyMMdd");
            string XSAM = ReverseString(serverip.Replace(".", "")) + DateTime.Now.ToString("HHmm");

            var salt = await Http.Post<JObject>($"{init.host}/request-salt", $"key={init.APIKEY}", headers: httpHeaders(init, HeadersModel.Init(
                ("X-NICK", SHA1(XNICK)),
                ("X-SAM", SHA1(XSAM))
            )));

            if (salt == null || string.IsNullOrWhiteSpace(salt.Value<string>("salt")))
                return null;

            string token = SHA1(init.APISECRET + init.APIKEY + CrypTo.md5(array_sum(serverip) + salt.Value<string>("salt")));

            var xtk = await Http.Post<JObject>($"{init.host}/request-token", $"user_name={init.user_name}&user_passw={init.user_passw}&key={init.APIKEY}&token={token}", headers: httpHeaders(init, HeadersModel.Init("User-Id", userid.ToString())));

            if (xtk != null && !string.IsNullOrWhiteSpace(xtk.Value<string>("token")))
                return xtk.Value<string>("token");

            return null;
        }
        #endregion

        #region ReverseString / array_sum / SHA1
        static string ReverseString(string s)
        {
            char[] charArray = s.ToCharArray();
            Array.Reverse(charArray);
            return new string(charArray);
        }

        static int array_sum(string s)
        {
            List<int> mass = new List<int>();
            foreach (var num in s.Split("."))
                mass.Add(int.Parse(num));

            return mass.Sum();
        }

        static string SHA1(string IntText)
        {
            using (var sha1 = new System.Security.Cryptography.SHA1Managed())
            {
                var result = sha1.ComputeHash(Encoding.UTF8.GetBytes(IntText));
                return BitConverter.ToString(result).Replace("-", "").ToLower();
            }
        }
        #endregion
    }
}

```

## File: Online/Controllers/Videoseed.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Newtonsoft.Json.Linq;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class Videoseed : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/videoseed")]
        async public ValueTask<ActionResult> Index(string imdb_id, long kinopoisk_id, string title, string original_title, int year, int s = -1, bool rjson = false, int serial = -1)
        {
            var init = await loadKit(AppInit.conf.Videoseed);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string memKey = $"videoseed:view:{kinopoisk_id}:{imdb_id}:{original_title}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                #region search
                if (!hybridCache.TryGetValue(memKey, out (Dictionary<string, JObject> seasons, string iframe) cache))
                {
                    #region goSearch
                    async ValueTask<JToken> goSearch(bool isOk, string arg)
                    {
                        if (!isOk)
                            return null;

                        string uri = $"{init.host}/apiv2.php?item={(serial == 1 ? "serial" : "movie")}&token={init.token}" + arg;
                        var root = await Http.Get<JObject>(uri, timeoutSeconds: 8, headers: httpHeaders(init), proxy: proxy.proxy);

                        if (root == null || !root.ContainsKey("data") || root.Value<string>("status") == "error")
                        {
                            proxyManager.Refresh();
                            return null;
                        }

                        return root["data"]?.First;
                    }
                    #endregion

                    var data = await goSearch(kinopoisk_id > 0, $"&kp={kinopoisk_id}") ??
                               await goSearch(!string.IsNullOrEmpty(imdb_id), $"&tmdb={imdb_id}") ??
                               await goSearch(!string.IsNullOrEmpty(original_title), $"&q={HttpUtility.UrlEncode(original_title)}&release_year_from={year - 1}&release_year_to={year + 1}");

                    if (data == null)
                    {
                        proxyManager.Refresh();
                        return OnError();
                    }

                    if (serial == 1)
                        cache.seasons = data?["seasons"]?.ToObject<Dictionary<string, JObject>>();
                    else
                        cache.iframe = data?.Value<string>("iframe");

                    if (cache.seasons == null && string.IsNullOrEmpty(cache.iframe))
                    {
                        proxyManager.Refresh();
                        return OnError();
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(40, init: init));
                }
                #endregion

                if (cache.iframe != null)
                {
                    #region –§–∏–ª—å–º
                    var mtpl = new MovieTpl(title, original_title, 1);
                    mtpl.Append("–ü–æ-—É–º–æ–ª—á–∞–Ω–∏—é", accsArgs($"{host}/lite/videoseed/video/{AesTo.Encrypt(cache.iframe)}") + "#.m3u8", "call", vast: init.vast);

                    return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∞–ª
                    string enc_title = HttpUtility.UrlEncode(title);
                    string enc_original_title = HttpUtility.UrlEncode(original_title);

                    if (s == -1)
                    {
                        var tpl = new SeasonTpl(cache.seasons.Count);

                        foreach (var season in cache.seasons)
                        {
                            string link = $"{host}/lite/videoseed?rjson={rjson}&kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&title={enc_title}&original_title={enc_original_title}&s={season.Key}";
                            tpl.Append($"{season.Key} —Å–µ–∑–æ–Ω", link, season.Key);
                        }

                        return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                    }
                    else
                    {
                        string sArhc = s.ToString();
                        var videos = cache.seasons.First(i => i.Key == sArhc).Value["videos"].ToObject<Dictionary<string, JObject>>();

                        var etpl = new EpisodeTpl(videos.Count);

                        foreach (var video in videos)
                        {
                            string iframe = video.Value.Value<string>("iframe");
                            etpl.Append($"{video.Key} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, video.Key, accsArgs($"{host}/lite/videoseed/video/{AesTo.Encrypt(iframe)}"), "call", vast: init.vast);
                        }

                        return ContentTo(rjson ? etpl.ToJson() : etpl.ToHtml());
                    }
                    #endregion
                }
            });
        }


        #region Video
        [HttpGet]
        [Route("lite/videoseed/video/{*iframe}")]
        async public ValueTask<ActionResult> Video(string iframe)
        {
            var init = await loadKit(AppInit.conf.Videoseed);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            iframe = AesTo.Decrypt(iframe);
            if (string.IsNullOrEmpty(iframe))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string memKey = $"videoseed:video:{iframe}:{proxyManager.CurrentProxyIp}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out string location))
                {
                    var headers = httpHeaders(init);

                    try
                    {
                        using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                        {
                            var page = await browser.NewPageAsync(init.plugin, proxy: proxy.data, headers: headers?.ToDictionary()).ConfigureAwait(false);
                            if (page == null)
                                return null;

                            await page.AddInitScriptAsync("localStorage.setItem('pljsquality', '1080p');").ConfigureAwait(false);

                            await page.RouteAsync("**/*", async route =>
                            {
                                try
                                {
                                    if (!string.IsNullOrEmpty(location))
                                    {
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (route.Request.Url.Contains(".m3u8") || (route.Request.Url.Contains(".mp4") && !route.Request.Url.Contains(".ts")))
                                        location = route.Request.Url;

                                    if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                        return;

                                    await route.ContinueAsync();
                                }
                                catch { }
                            });

                            var options = new PageGotoOptions()
                            {
                                Timeout = 15_000,
                                WaitUntil = WaitUntilState.NetworkIdle
                            };

                            var result = await page.GotoAsync(iframe, options).ConfigureAwait(false);
                            if (result != null && string.IsNullOrEmpty(location))
                            {
                                string html = await page.ContentAsync().ConfigureAwait(false);
                                location = Regex.Match(html, "<video preload=\"none\" src=\"(https?://[^\"]+)\"").Groups[1].Value;
                                if (!location.Contains(".m3u") && !location.Contains(".mp4"))
                                    location = null;
                            }

                            PlaywrightBase.WebLog("SET", iframe, location, proxy.data);
                        }

                        if (string.IsNullOrEmpty(location))
                        {
                            proxyManager.Refresh();
                            return OnError();
                        }
                    }
                    catch
                    {
                        return OnError();
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, location, cacheTime(20));
                }

                string link = HostStreamProxy(init, location, proxy: proxy.proxy, headers: HeadersModel.Init("referer", iframe));
                return ContentTo(VideoTpl.ToJson("play", link, "auto", vast: init.vast));
            });
        }
        #endregion
    }
}

```

## File: Online/Controllers/Alloha.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Alloha;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class Alloha : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.Alloha);

        #region Initialization
        ValueTask<AllohaSettings> Initialization()
        {
            return loadKit(AppInit.conf.Alloha, (j, i, c) =>
            {
                if (j.ContainsKey("m4s"))
                    i.m4s = c.m4s;

                if (j.ContainsKey("linkhost"))
                    i.linkhost = c.linkhost;

                if (j.ContainsKey("reserve"))
                    i.reserve = c.reserve;

                i.secret_token = c.secret_token;
                i.token = c.token;
                return i;
            });
        }
        #endregion

        [HttpGet]
        [Route("lite/alloha")]
        async public ValueTask<ActionResult> Index(string orid, string imdb_id, long kinopoisk_id, string title, string original_title, int serial, string original_language, int year, string t, int s = -1, bool origsource = false, bool rjson = false, bool similar = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (similar)
                return await SpiderSearch(title, origsource, rjson);

            var result = await search(init, orid, imdb_id, kinopoisk_id, title, serial, original_language, year);
            if (result.category_id == 0)
                return OnError("data", proxyManager, result.refresh_proxy);

            if (result.data == null)
                return Ok();

            if (origsource)
                return ContentTo(JsonConvert.SerializeObject(result.data));

            JToken data = result.data;

            string defaultargs = $"&orid={orid}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&serial={serial}&year={year}&original_language={original_language}";

            if (result.category_id is 1 or 3)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title);
                bool directors_cut = data.Value<bool>("available_directors_cut");

                foreach (var translation in data.Value<JObject>("translation_iframe").ToObject<Dictionary<string, Dictionary<string, object>>>())
                {
                    string link = $"{host}/lite/alloha/video?t={translation.Key}&token_movie={result.data.Value<string>("token_movie")}" + defaultargs;
                    string streamlink = accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true");

                    bool uhd = false;
                    if (translation.Value.TryGetValue("uhd", out object _uhd))
                        uhd = _uhd.ToString().ToLower() == "true" && init.m4s;

                    if (directors_cut && translation.Key == "66")
                        mtpl.Append("–†–µ–∂–∏—Å—Å–µ—Ä—Å–∫–∞—è –≤–µ—Ä—Å–∏—è", $"{link}&directors_cut=true", "call", $"{streamlink}&directors_cut=true", voice_name: uhd ? "2160p" : translation.Value["quality"].ToString(), quality: uhd ? "2160p" : "");

                    mtpl.Append(translation.Value["name"].ToString(), link, "call", streamlink, voice_name: uhd ? "2160p" : translation.Value["quality"].ToString(), quality: uhd ? "2160p" : "");
                }

                return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                if (s == -1)
                {
                    var tpl = new SeasonTpl(result.data.Value<bool>("uhd") && init.m4s ? "2160p" : null);

                    foreach (var season in data.Value<JObject>("seasons").ToObject<Dictionary<string, object>>().Reverse())
                        tpl.Append($"{season.Key} —Å–µ–∑–æ–Ω", $"{host}/lite/alloha?rjson={rjson}&s={season.Key}{defaultargs}", season.Key);

                    return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                }
                else
                {
                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var vtpl = new VoiceTpl();
                    var temp_translation = new HashSet<string>();

                    string activTranslate = t;

                    foreach (var episodes in data.Value<JObject>("seasons").GetValue(s.ToString()).Value<JObject>("episodes").ToObject<Dictionary<string, Episode>>().Select(i => i.Value.translation))
                    {
                        foreach (var translation in episodes)
                        {
                            if (temp_translation.Contains(translation.Value.translation) || translation.Value.translation.ToLower().Contains("—Å—É–±—Ç–∏—Ç—Ä—ã"))
                                continue;

                            temp_translation.Add(translation.Value.translation);

                            if (string.IsNullOrWhiteSpace(activTranslate))
                                activTranslate = translation.Key;

                            vtpl.Append(translation.Value.translation, activTranslate == translation.Key, $"{host}/lite/alloha?rjson={rjson}&s={s}&t={translation.Key}{defaultargs}");
                        }
                    }
                    #endregion

                    var etpl = new EpisodeTpl();
                    string sArhc = s.ToString();

                    foreach (var episode in data.Value<JObject>("seasons").GetValue(sArhc).Value<JObject>("episodes").ToObject<Dictionary<string, Episode>>().Reverse())
                    {
                        if (!string.IsNullOrWhiteSpace(activTranslate) && !episode.Value.translation.ContainsKey(activTranslate))
                            continue;

                        string link = $"{host}/lite/alloha/video?t={activTranslate}&s={s}&e={episode.Key}&token_movie={result.data.Value<string>("token_movie")}" + defaultargs;
                        string streamlink = accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true");

                        etpl.Append($"{episode.Key} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.Key, link, "call", streamlink: streamlink);
                    }

                    if (rjson)
                        return ContentTo(etpl.ToJson(vtpl));

                    return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                }
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/alloha/video")]
        [Route("lite/alloha/video.m3u8")]
        async public ValueTask<ActionResult> Video(string token_movie, string title, string original_title, string t, int s, int e, bool play, bool directors_cut)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxy = proxyManager.BaseGet();

            return await InvkSemaphore(init, $"alloha:view:stream:{init.secret_token}:{token_movie}:{t}:{s}:{e}:{init.m4s}:{directors_cut}", async () =>
            {
                if (!string.IsNullOrEmpty(init.secret_token))
                {
                    #region –ü—Ä—è–º—ã–µ —Å—Å—ã–ª–∫–∏
                    string userIp = requestInfo.IP;
                    if (init.localip || init.streamproxy)
                    {
                        userIp = await mylocalip();
                        if (userIp == null)
                            return OnError("userIp");
                    }

                    string memKey = $"alloha:view:stream:{init.secret_token}:{token_movie}:{t}:{s}:{e}:{userIp}:{init.m4s}:{directors_cut}";
                    if (!hybridCache.TryGetValue(memKey, out JToken data))
                    {
                        #region url –∑–∞–ø—Ä–æ—Å–∞
                        string uri = $"{init.linkhost}/direct?secret_token={init.secret_token}&token_movie={token_movie}";

                        uri += $"&ip={userIp}&translation={t}";

                        if (s > 0)
                            uri += $"&season={s}";

                        if (e > 0)
                            uri += $"&episode={e}";

                        if (init.m4s)
                            uri += "&av1=true";

                        if (directors_cut)
                            uri += "&directors_cut";
                        #endregion

                        var root = await Http.Get<JObject>(uri, timeoutSeconds: 8, proxy: proxy.proxy, headers: httpHeaders(init));
                        if (root == null)
                            return OnError("json", proxyManager);

                        if (!root.ContainsKey("data"))
                            return OnError("data");

                        proxyManager.Success();

                        data = root["data"];
                        hybridCache.Set(memKey, data, cacheTime(10, init: init));
                    }

                    #region subtitle
                    var subtitles = new SubtitleTpl();

                    try
                    {
                        foreach (var sub in data["file"]["tracks"])
                            subtitles.Append(sub.Value<string>("label"), sub.Value<string>("src"));
                    }
                    catch { }
                    #endregion

                    List<(string link, string quality)> streams = null;

                    foreach (var hlsSource in data["file"]["hlsSource"])
                    {
                        // first or default
                        if (streams == null || hlsSource.Value<bool>("default"))
                        {
                            streams = new List<(string link, string quality)>(6);

                            foreach (var q in hlsSource["quality"].ToObject<Dictionary<string, string>>())
                            {
                                string file = q.Value;
                                if (init.reserve)
                                    file += " or " + hlsSource["reserve"][q.Key].ToString();

                                streams.Add((HostStreamProxy(init, file, proxy: proxy.proxy), $"{q.Key}p"));
                            }
                        }
                    }

                    if (streams == null || streams.Count == 0)
                        return OnError("streams");

                    var streamquality = new StreamQualityTpl(streams);

                    if (play)
                        return RedirectToPlay(streamquality.Firts().link);

                    #region segments
                    var segments = new SegmentTpl();

                    var dfile = data["file"];
                    string skipTime = dfile.Value<string>("skipTime");
                    string removeTime = dfile.Value<string>("removeTime");

                    if (skipTime != null && skipTime.Contains("-"))
                    {
                        foreach (string skp in skipTime.Split(","))
                        {
                            var t = skp.Trim().Split('-');
                            if (t.Length >= 2 && int.TryParse(t[0].Trim(), out int start) && int.TryParse(t[1].Trim(), out int end))
                                segments.skip(start, end);
                        }
                    }

                    if (removeTime != null && removeTime.Contains("-"))
                    {
                        foreach (string skp in removeTime.Split(","))
                        {
                            var t = skp.Trim().Split('-');
                            if (t.Length >= 2 && int.TryParse(t[0].Trim(), out int start) && int.TryParse(t[1].Trim(), out int end))
                                segments.ad(start, end);
                        }
                    }
                    #endregion

                    return ContentTo(VideoTpl.ToJson("play", streamquality.Firts().link, (title ?? original_title),
                        streamquality: streamquality,
                        vast: init.vast,
                        subtitles: subtitles,
                        segments: segments,
                        hls_manifest_timeout: (int)TimeSpan.FromSeconds(20).TotalMilliseconds
                    ));
                    #endregion
                }
                else
                {
                    #region Playwright
                    init.streamproxy = true; // force streamproxy

                    string memKey = $"alloha:black_magic:{proxy.data.ip}:{token_movie}:{t}:{s}:{e}";
                    if (!hybridCache.TryGetValue(memKey, out (string hls, List<HeadersModel> headers) cache))
                    {
                        if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                            return OnError();

                        using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                        {
                            string targetHost = "https://alloha.tv";

                            string targetUrl = $"{init.linkhost}/?token_movie={token_movie}&translation={t}&token={init.token}";
                            if (s > 0)
                                targetUrl += $"&season={s}&episode={e}";

                            var page = await browser.NewPageAsync(init.plugin, proxy: proxy.data, headers: Http.defaultFullHeaders).ConfigureAwait(false);
                            if (page == null)
                                return null;

                            string q = init.m4s ? "2160" : "1080";
                            await page.AddInitScriptAsync($"localStorage.setItem('allplay', '{{\"captionParam\":{{\"fontSize\":\"100%\",\"colorText\":\"–ë–µ–ª—ã–π\",\"colorBackground\":\"–ß–µ—Ä–Ω—ã–π\",\"opacityText\":\"100%\",\"opacityBackground\":\"75%\",\"styleText\":\"–ë–µ–∑ –∫–æ–Ω—Ç—É—Ä–∞\",\"weightText\":\"–û–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç\"}},\"quality\":{q},\"volume\":0.5,\"muted\":false}}');");

                            await page.RouteAsync("**/*", async route =>
                            {
                                try
                                {
                                    if (browser.IsCompleted || route.Request.Url.Contains("blank.mp4") || route.Request.Url.Contains("googleapis.com"))
                                    {
                                        PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (route.Request.Url.StartsWith(targetHost))
                                    {
                                        await route.FulfillAsync(new RouteFulfillOptions
                                        {
                                            Body = PlaywrightBase.IframeHtml(targetUrl)
                                        });
                                    }
                                    else
                                    {
                                        if (route.Request.Url.Contains("/m/"))
                                        {
                                            await route.ContinueAsync();

                                            var response = await page.WaitForResponseAsync(route.Request.Url);
                                            if (response != null && response.Headers.ContainsKey("location"))
                                            {
                                                response = await page.WaitForResponseAsync(response.Headers["location"]);
                                                if (response != null)
                                                {
                                                    cache.headers = HeadersModel.Init(Http.defaultFullHeaders,
                                                        ("sec-fetch-dest", "empty"),
                                                        ("sec-fetch-mode", "cors"),
                                                        ("sec-fetch-site", "cross-site")
                                                    );

                                                    foreach (var item in response.Request.Headers)
                                                    {
                                                        if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                                            continue;

                                                        if (!Http.defaultFullHeaders.ContainsKey(item.Key.ToLower()))
                                                            cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                                    }

                                                    PlaywrightBase.ConsoleLog($"Playwright: SET {response.Request.Url}", cache.headers);
                                                    browser.SetPageResult(response.Request.Url);
                                                }
                                            }
                                        }
                                        else
                                        {
                                            if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                                return;

                                            await route.ContinueAsync();
                                        }
                                    }
                                }
                                catch { }
                            });

                            PlaywrightBase.GotoAsync(page, targetHost);
                            cache.hls = await browser.WaitPageResult();
                        }

                        if (string.IsNullOrEmpty(cache.hls))
                            return OnError();

                        hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                    }

                    var streamquality = new StreamQualityTpl();
                    streamquality.Append(HostStreamProxy(init, cache.hls, headers: cache.headers), "auto");

                    if (play)
                        return RedirectToPlay(streamquality.Firts().link);

                    return ContentTo(VideoTpl.ToJson("play", streamquality.Firts().link, title ?? original_title,
                        streamquality: streamquality,
                        vast: init.vast,
                        headers: cache.headers
                    ));
                    #endregion
                }
            });
        }
        #endregion

        #region SpiderSearch
        [HttpGet]
        [Route("lite/alloha-search")]
        async public ValueTask<ActionResult> SpiderSearch(string title, bool origsource = false, bool rjson = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var cache = await InvokeCache<JArray>($"alloha:search:{title}", cacheTime(40, init: init), proxyManager, async res =>
            {
                var root = await Http.Get<JObject>($"{init.apihost}/?token={init.token}&name={HttpUtility.UrlEncode(title)}&list", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                if (root == null || !root.ContainsKey("data"))
                    return res.Fail("data");

                return root["data"].ToObject<JArray>();
            });

            return OnResult(cache, () =>
            {
                var stpl = new SimilarTpl(cache.Value.Count);

                foreach (var j in cache.Value)
                {
                    string uri = $"{host}/lite/alloha?orid={j.Value<string>("token_movie")}";
                    stpl.Append(j.Value<string>("name") ?? j.Value<string>("original_name"), j.Value<int>("year").ToString(), string.Empty, uri, PosterApi.Size(j.Value<string>("poster")));
                }

                return rjson ? stpl.ToJson() : stpl.ToHtml();

            }, origsource: origsource);
        }
        #endregion


        #region search
        async ValueTask<(bool refresh_proxy, int category_id, JToken data)> search(AllohaSettings init, string token_movie, string imdb_id, long kinopoisk_id, string title, int serial, string original_language, int year)
        {
            string memKey = $"alloha:view:{kinopoisk_id}:{imdb_id}";
            if (0 >= kinopoisk_id && string.IsNullOrEmpty(imdb_id))
                memKey = $"alloha:viewsearch:{title}:{serial}:{original_language}:{year}";

            if (!string.IsNullOrEmpty(token_movie))
                memKey = $"alloha:view:{token_movie}";

            JObject root = null;

            if (!hybridCache.TryGetValue(memKey, out (int category_id, JToken data) res))
            {
                if (memKey.Contains(":viewsearch:"))
                {
                    if (string.IsNullOrWhiteSpace(title) || year == 0)
                        return default;

                    root = await Http.Get<JObject>($"{init.apihost}/?token={init.token}&name={HttpUtility.UrlEncode(title)}&list={(serial == 1 ? "serial" : "movie")}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                    if (root == null)
                        return (true, 0, null);

                    if (root.ContainsKey("data"))
                    {
                        string stitle = title.ToLower();

                        foreach (var item in root["data"])
                        {
                            if (item.Value<string>("name")?.ToLower()?.Trim() == stitle)
                            {
                                int y = item.Value<int>("year");
                                if (y > 0 && (y == year || y == (year - 1) || y == (year + 1)))
                                {
                                    if (original_language == "ru" && item.Value<string>("country")?.ToLower() != "—Ä–æ—Å—Å–∏—è")
                                        continue;

                                    res.data = item;
                                    res.category_id = item.Value<int>("category_id");
                                    break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (!string.IsNullOrEmpty(imdb_id))
                        root = await Http.Get<JObject>($"{init.apihost}/?token={init.token}&imdb={imdb_id}&token_movie={token_movie}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                    
                    if ((root == null || !root.ContainsKey("data")) && kinopoisk_id > 0)
                        root = await Http.Get<JObject>($"{init.apihost}/?token={init.token}&kp={kinopoisk_id}&token_movie={token_movie}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));

                    if (root == null)
                        return (true, 0, null);

                    if (root.ContainsKey("data"))
                    {
                        res.data = root.GetValue("data");
                        res.category_id = res.data.Value<int>("category");
                    }
                }

                if (res.data != null)
                    proxyManager.Success();

                if (res.data != null || (root.ContainsKey("error_info") && root.Value<string>("error_info") == "not movie"))
                    hybridCache.Set(memKey, res, cacheTime(res.category_id is 1 or 3 ? 120 : 40, init: init));
                else
                    hybridCache.Set(memKey, res, cacheTime(2, init: init));
            }

            return (false, res.category_id, res.data);
        }
        #endregion
    }
}

```

## File: Online/Controllers/CDNvideohub.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;

namespace Online.Controllers
{
    public class CDNvideohub : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/cdnvideohub")]
        async public ValueTask<ActionResult> Index(string title, string original_title, long kinopoisk_id, string t, int s = -1, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.CDNvideohub);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            reset:
            var cache = await InvokeCache<JObject>($"cdnvideohub:view:{kinopoisk_id}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string uri = $"{init.corsHost()}/api/v1/player/sv/playlist?pub=12&aggr=kp&id={kinopoisk_id}";

                var root = rch.enable 
                    ? await rch.Get<JObject>(uri, httpHeaders(init)) 
                    : await Http.Get<JObject>(uri, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));

                if (root == null || !root.ContainsKey("items"))
                    return res.Fail("root");

                var videos = root["items"] as JArray;
                if (videos == null || videos.Count == 0)
                    return res.Fail("video");

                return root;
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => 
            {
                if (cache.Value.Value<bool>("isSerial"))
                {
                    #region –°–µ—Ä–∏–∞–ª
                    string defaultargs = $"&rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}";

                    if (s == -1)
                    {
                        #region –°–µ–∑–æ–Ω—ã
                        var tpl = new SeasonTpl();
                        var hash = new HashSet<int>();

                        foreach (var video in cache.Value["items"].OrderBy(i => i.Value<int>("season")))
                        {
                            int season = video.Value<int>("season");

                            if (hash.Contains(season))
                                continue;

                            hash.Add(season);
                            tpl.Append($"{season} —Å–µ–∑–æ–Ω", $"{host}/lite/cdnvideohub?s={season}{defaultargs}", season);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                        #endregion
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();
                        var tmpVoice = new HashSet<string>();

                        foreach (var video in cache.Value["items"])
                        {
                            if (video.Value<int>("season") != s)
                                continue;

                            string voice_studio = video.Value<string>("voiceStudio");
                            if (string.IsNullOrEmpty(voice_studio) || tmpVoice.Contains(voice_studio))
                                continue;

                            tmpVoice.Add(voice_studio);

                            if (string.IsNullOrEmpty(t))
                                t = voice_studio;

                            vtpl.Append(voice_studio, t == voice_studio, $"{host}/lite/cdnvideohub?s={s}&t={HttpUtility.UrlEncode(voice_studio)}{defaultargs}");
                        }
                        #endregion

                        var etpl = new EpisodeTpl();
                        string sArhc = s.ToString();
                        var tmpEpisode = new HashSet<int>();

                        foreach (var video in cache.Value["items"].OrderBy(i => i.Value<int>("episode")))
                        {
                            if (video.Value<int>("season") != s || video.Value<string>("voiceStudio") != t)
                                continue;

                            string vkId = video.Value<string>("vkId");
                            if (string.IsNullOrEmpty(vkId))
                                continue;

                            int episode = video.Value<int>("episode");

                            if (tmpEpisode.Contains(episode))
                                continue;

                            tmpEpisode.Add(episode);

                            string link = accsArgs($"{host}/lite/cdnvideohub/video.m3u8?vkId={vkId}&title={HttpUtility.UrlEncode(title)}");

                            etpl.Append($"{episode} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.ToString(), link, "call", streamlink: $"{link}&play=true", vast: init.vast);
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                    #endregion
                }
                else
                {
                    #region –§–∏–ª—å–º
                    var mtpl = new MovieTpl(title, original_title);

                    foreach (var video in cache.Value["items"])
                    {
                        string voice = video.Value<string>("voiceStudio") ?? video.Value<string>("voiceType");
                        string vkId = video.Value<string>("vkId");

                        string link = accsArgs($"{host}/lite/cdnvideohub/video.m3u8?vkId={vkId}&title={HttpUtility.UrlEncode(title)}");

                        mtpl.Append(voice, link, "call", vast: init.vast);
                    }

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                    #endregion
                }

            }, origsource: origsource, gbcache: !rch.enable);
        }


        #region Video
        [HttpGet]
        [Route("lite/cdnvideohub/video.m3u8")]
        async public ValueTask<ActionResult> Video(string vkId, string title, bool play)
        {
            var init = await loadKit(AppInit.conf.CDNvideohub);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            reset: 
            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("cors,web", out string rch_error))
                return ShowError(rch_error);

            var cache = await InvokeCache<string>(rch.ipkey($"cdnvideohub:video:{vkId}", proxyManager), cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                if (rch.IsNotConnected())
                    return res.Fail(rch.connectionMsg);

                string uri = $"{init.corsHost()}/api/v1/player/sv/video/{vkId}";

                string iframe;
                if (rch.enable)
                {
                    iframe = await rch.Get(init.cors(uri), headers: httpHeaders(init));
                }
                else
                {
                    iframe = await Http.Get(uri, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init), httpversion: 2);
                }

                if (iframe == null)
                    return res.Fail("iframe");

                string hls = Regex.Match(iframe, "\"hlsUrl\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(hls))
                    return res.Fail("hls");

                return hls.Replace("u0026", "&").Replace("\\", "");
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            if (!cache.IsSuccess)
                return OnError(cache.ErrorMsg, gbcache: !rch.enable);

            string link = HostStreamProxy(init, cache.Value, proxy: proxyManager.Get());

            if (play)
                return RedirectToPlay(link);

            return ContentTo(VideoTpl.ToJson("play", link, title, vast: init.vast));
        }
        #endregion
    }
}

```

## File: Online/Controllers/GetsTV.cs
```
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;
using System.Text;

namespace Online.Controllers
{
    public class GetsTV : BaseOnlineController
    {
        #region Bind
        [HttpGet]
        [AllowAnonymous]
        [Route("/lite/getstv/bind")]
        async public Task<ActionResult> Bind(string login, string pass)
        {
            string html = string.Empty;

            if (string.IsNullOrWhiteSpace(login) || string.IsNullOrWhiteSpace(pass))
            {
                return ContentTo("–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç–∞ getstv.com <br> <br><form method=\"get\" action=\"/lite/getstv/bind\"><input type=\"text\" name=\"login\" placeholder=\"email\"> &nbsp; &nbsp; <input type=\"text\" name=\"pass\" placeholder=\"–ø–∞—Ä–æ–ª—å\"><br><br><button>–ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è</button></form>");
            }
            else
            {
                string postdata = $"{{\"email\":\"{login}\",\"password\":\"{pass}\",\"fingerprint\":\"{CrypTo.md5(DateTime.Now.ToString())}\",\"device\":{{}}}}";
                var result =  await Http.Post<JObject>($"{AppInit.conf.GetsTV.corsHost()}/api/login", new System.Net.Http.StringContent(postdata, Encoding.UTF8, "application/json"), headers: httpHeaders(AppInit.conf.GetsTV));

                if (result == null)
                    return ContentTo("–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ ;(");

                string token = result.Value<string>("token");
                if (string.IsNullOrEmpty(token))
                    return ContentTo(JsonConvert.SerializeObject(result, Formatting.Indented));

                return ContentTo("–î–æ–±–∞–≤—å—Ç–µ –≤ init.conf<br><br>\"GetsTV\": {<br>&nbsp;&nbsp;\"enable\": true,<br>&nbsp;&nbsp;\"token\": \"" + token + "\"<br>}");
            }
        }
        #endregion

        ProxyManager proxyManager = new ProxyManager(AppInit.conf.GetsTV);

        [HttpGet]
        [Route("lite/getstv")]
        async public ValueTask<ActionResult> Index(string orid, string title, string original_title, int year, int t = -1, int s = -1, bool rjson = false, bool similar = false, string source = null, string id = null)
        {
            var init = await loadKit(AppInit.conf.GetsTV);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (string.IsNullOrEmpty(orid) && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() == "getstv")
                    orid = id;
            }

            if (string.IsNullOrEmpty(orid))
            {
                var result = await search(init, title, original_title, year);

                if (result.id != null && similar == false)
                    orid = result.id;
                else
                {
                    if (result.similar.data == null || result.similar.data.Count == 0)
                        return OnError("data");

                    return ContentTo(rjson ? result.similar.ToJson() : result.similar.ToHtml());
                }
            }

            var cache = await InvokeCache<JObject>($"getstv:movies:{orid}", cacheTime(20, init: init), proxyManager, async res =>
            {
                var headers = httpHeaders(init, HeadersModel.Init("authorization", $"Bearer {init.token}"));
                var root = await Http.Get<JObject>($"{init.corsHost()}/api/movies/{orid}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: headers);
                if (root == null)
                    return res.Fail("movies");

                return root;
            });

            return OnResult(cache, () => 
            {
                string defaultargs = $"&orid={orid}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&year={year}";

                if (cache.Value.Value<string>("type") == "movie")
                {
                    #region –§–∏–ª—å–º
                    var mtpl = new MovieTpl(title, original_title);

                    foreach (var media in cache.Value["media"])
                    {
                        string link = $"{host}/lite/getstv/video.m3u8?id={media.Value<string>("_id")}";
                        string streamlink = accsArgs($"{link}&play=true");

                        mtpl.Append(media.Value<string>("trName"), link, "call", streamlink, details: media.Value<string>("sourceType"));
                    }

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∞–ª
                    if (s == -1)
                    {
                        var tpl = new SeasonTpl();

                        foreach (var season in cache.Value["seasons"])
                        {
                            int seasonNum = season.Value<int>("seasonNum");
                            tpl.Append($"{seasonNum} —Å–µ–∑–æ–Ω", $"{host}/lite/getstv?rjson={rjson}&s={seasonNum}{defaultargs}", seasonNum);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        var episodes = cache.Value["seasons"].First(i => i.Value<int>("seasonNum") == s)["episodes"];

                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();
                        var temp_translation = new HashSet<int>();

                        foreach (var e in episodes)
                        {
                            foreach (var tr in e["trs"])
                            {
                                int trId = tr.Value<int>("trId");
                                if (temp_translation.Contains(trId))
                                    continue;

                                temp_translation.Add(trId);

                                if (t == -1)
                                    t = trId;

                                vtpl.Append(tr.Value<string>("trName"), t == trId, $"{host}/lite/getstv?rjson={rjson}&s={s}&t={trId}{defaultargs}");
                            }
                        }
                        #endregion

                        var etpl = new EpisodeTpl();
                        string sArhc = s.ToString();

                        foreach (var episode in episodes)
                        {
                            foreach (var tr in episode["trs"])
                            {
                                if (tr.Value<int>("trId") == t)
                                {
                                    int e = episode.Value<int>("episodeNum");
                                    string link = $"{host}/lite/getstv/video.m3u8?id={tr.Value<string>("_id")}";
                                    string streamlink = accsArgs($"{link}&play=true");

                                    etpl.Append($"{e} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, e.ToString(), link, "call", streamlink: streamlink);
                                    break;
                                }
                            }
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                    #endregion
                }
            });
        }


        #region Video
        [HttpGet]
        [Route("lite/getstv/video.m3u8")]
        async public ValueTask<ActionResult> Video(string id, bool play)
        {
            var init = await loadKit(AppInit.conf.GetsTV);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxy = proxyManager.Get();

            string memKey = $"getstv:view:stream:{id}:{init.token}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out JObject root))
                {
                    var headers = httpHeaders(init, HeadersModel.Init("authorization", $"Bearer {init.token}"));
                    root = await Http.Get<JObject>($"{init.corsHost()}/api/media/{id}?format=m3u8&protocol=https", timeoutSeconds: 8, proxy: proxy, headers: headers);
                    if (root == null)
                        return OnError("json", proxyManager);

                    if (!root.ContainsKey("resolutions"))
                        return OnError("resolutions");

                    proxyManager.Success();
                    hybridCache.Set(memKey, root, cacheTime(10, init: init));
                }

                #region subtitle
                var subtitles = new SubtitleTpl();

                try
                {
                    foreach (var sub in root["subtitles"])
                        subtitles.Append(sub.Value<string>("lang"), sub.Value<string>("url"));
                }
                catch { }
                #endregion

                var streamquality = new StreamQualityTpl();

                foreach (var r in root["resolutions"])
                    streamquality.Append(HostStreamProxy(init, r.Value<string>("url"), proxy: proxy), $"{r.Value<int>("type")}p");

                if (!streamquality.Any())
                    return OnError("stream");

                if (play)
                    return RedirectToPlay(streamquality.Firts().link);

                var titleObj = root["media"]["movie"]["title"] as JObject;
                string titleRu = titleObj?["ru"]?.ToString();
                string titleEn = titleObj?["en"]?.ToString();

                string name = titleRu ?? titleEn;
                if (titleRu != null && titleEn != null)
                    name = $"{titleRu} / {titleEn}";

                return ContentTo(VideoTpl.ToJson("play", streamquality.Firts().link, name,
                    streamquality: streamquality,
                    vast: init.vast,
                    subtitles: subtitles
                ));
            });
        }
        #endregion

        #region SpiderSearch
        [HttpGet]
        [Route("lite/getstv-search")]
        async public ValueTask<ActionResult> SpiderSearch(string title, bool rjson = false)
        {
            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var init = await loadKit(AppInit.conf.GetsTV);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var result = await search(init, title, null, 0);
            if (result.similar.data?.Count == 0)
                return OnError("data");

            return ContentTo(rjson ? result.similar.ToJson() : result.similar.ToHtml());
        }
        #endregion


        #region search
        async ValueTask<(string id, SimilarTpl similar)> search(OnlinesSettings init, string title, string original_title, int year)
        {
            if (string.IsNullOrWhiteSpace(title) || string.IsNullOrEmpty(init.token))
                return default;

            string memKey = $"getstv:search:{title ?? original_title}";
            if (!hybridCache.TryGetValue(memKey, out JArray root))
            {
                var headers = httpHeaders(init, HeadersModel.Init("authorization", $"Bearer {init.token}"));
                root = await Http.Get<JArray>($"{init.corsHost()}/api/movies?skip=0&sort=updated&searchText={HttpUtility.UrlEncode(title)}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: headers);
                if (root == null)
                {
                    proxyManager.Refresh();
                    return default;
                }

                proxyManager.Success();
                hybridCache.Set(memKey, root, cacheTime(20, init: init));
            }

            List<string> ids = new List<string>();
            var stpl = new SimilarTpl(root.Count);

            string stitle = StringConvert.SearchName(title);
            string soriginal_title = StringConvert.SearchName(original_title);

            foreach (var j in root)
            {
                string uri = $"{host}/lite/getstv?orid={j.Value<string>("_id")}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&year={year}";

                var titleObj = j["title"] as JObject;
                string titleRu = titleObj?["ru"]?.ToString();
                string titleEn = titleObj?["en"]?.ToString();

                string name = titleRu ?? titleEn;
                if (titleRu != null && titleEn != null)
                    name = $"{titleRu} / {titleEn}";

                int released = j.Value<DateTime>("released").Year;
                string img = $"https://img.getstv.com/poster/cover/345x518/{j.Value<string>("poster")}.jpg";
                stpl.Append(name, released.ToString(), j.Value<string>("contentType"), uri, img);

                if ((titleRu != null && (StringConvert.SearchName(titleRu) == stitle || StringConvert.SearchName(titleRu) == soriginal_title)) ||
                    (titleEn != null && (StringConvert.SearchName(titleEn) == stitle || StringConvert.SearchName(titleEn) == soriginal_title)))
                {
                    if (released == year)
                        ids.Add(j.Value<string>("_id"));
                }
            }

            if (ids.Count == 1)
                return (ids[0], stpl);

            return (null, stpl);
        }
        #endregion
    }
}

```

## File: Online/Controllers/Kinogo.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;
using System.Net;

namespace Online.Controllers
{
    public class Kinogo : BaseOnlineController
    {
        public class SearchModel
        {
            public string link { get; set; }

            public SimilarTpl? similar { get; set; }
        }

        [HttpGet]
        [Route("lite/kinogo")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int year, bool rjson, string href, bool similar, int s = -1, int t = -1)
        {
            var init = await loadKit(AppInit.conf.Kinogo);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            #region search
            if (string.IsNullOrEmpty(href))
            {
                if (string.IsNullOrEmpty(title))
                    return OnError("search params");

                reset_search:
                var search = await InvokeCache<SearchModel>($"kinogo:search:{title}:{year}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string data = $"do=search&subaction=search&search_start=0&full_search=0&result_from=1&story={HttpUtility.UrlEncode(title)}";

                    string searchHtml = rch.enable 
                        ? await rch.Post($"{init.corsHost()}/index.php?do=search", data, httpHeaders(init)) 
                        : await Http.Post($"{init.corsHost()}/index.php?do=search", data, timeoutSeconds: 8, proxy: proxy.proxy, headers: httpHeaders(init));

                    if (searchHtml == null)
                        return res.Fail("search");

                    var result = SearchResult(searchHtml, title, year);
                    if (result == null)
                        return res.Fail("search-result");

                    return result;
                });

                if (similar || string.IsNullOrEmpty(search.Value?.link))
                    return OnResult(search, () => rjson ? search.Value.similar.Value.ToJson() : search.Value.similar.Value.ToHtml());

                if (string.IsNullOrEmpty(search.Value?.link))
                {
                    if (IsRhubFallback(search, init))
                        goto reset_search;

                    return OnError();
                }

                href = search.Value?.link;
            }
            #endregion

            if (string.IsNullOrEmpty(href))
                return OnError();

            #region embed
            reset_embed:
            var cache = await InvokeCache<JArray>(rch.ipkey(href, proxyManager), cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string targetHref = $"{init.corsHost()}/{href}";

                string html = rch.enable 
                    ? await rch.Get(targetHref, httpHeaders(init)) 
                    : await Http.Get(init.cors(targetHref), timeoutSeconds: 8, proxy: proxy.proxy, headers: httpHeaders(init));

                if (html == null) 
                    return res.Fail("html");

                string iframe = Regex.Match(html, "<iframe [^>]+data-src=\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(iframe))
                    return res.Fail("iframe");

                string embedUrl = iframe.StartsWith("//") ? $"https:{iframe}" : iframe;
                var embedHeaders = httpHeaders(init, HeadersModel.Init("referer", targetHref));

                string embedHtml = rch.enable 
                    ? await rch.Get(init.cors(embedUrl), embedHeaders) 
                    : await PlaywrightBrowser.Get(init, init.cors(embedUrl), headers: embedHeaders, proxy.data);

                if (embedHtml == null)
                    return res.Fail("embed");

                string playlistPath = Regex.Match(embedHtml, "\"file\":\"(/playlist/[^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(playlistPath))
                    return res.Fail("playlist");

                string playlistUrl = Regex.Match(embedUrl, "^(https?://[^/]+)").Groups[1].Value + playlistPath;
                var playlistHeaders = httpHeaders(init, HeadersModel.Init("referer", embedUrl));

                string playlistJson = rch.enable 
                    ? await rch.Get(init.cors(playlistUrl), playlistHeaders) 
                    : await PlaywrightBrowser.Get(init, init.cors(playlistUrl), headers: playlistHeaders, proxy.data);

                if (playlistJson == null)
                    return res.Fail("playlist-json");

                try
                {
                    var playlist = JArray.Parse(playlistJson);
                    if (playlist == null || playlist.Count == 0)
                        return res.Fail("playlist");

                    return playlist;
                }
                catch
                {
                    return res.Fail("DeserializeObject");
                }
            });

            if (IsRhubFallback(cache, init))
                goto reset_embed;
            #endregion

            return OnResult(cache, () =>
            {
                return BuildResult(init, cache.Value, title, original_title, year, s, t, rjson, href, proxy.proxy);

            }, gbcache: !rch.enable);
        }


        #region BuildResult
        string BuildResult(OnlinesSettings init, JArray playlist, string title, string original_title, int year, int s, int t, bool rjson, string href, WebProxy proxy)
        {
            if (playlist.First.Value<string>("file") != null)
            {
                var mtpl = new MovieTpl(title, original_title);

                foreach (var source in playlist)
                {
                    string voice = source.Value<string>("title");
                    string file = source.Value<string>("file");

                    if (string.IsNullOrEmpty(voice) || string.IsNullOrEmpty(file))
                        continue;

                    if (file.StartsWith("//"))
                        file = "https:" + file;

                    #region subtitle
                    var subtitles = new SubtitleTpl();
                    string _subs = source.Value<string>("subtitle");
                    if (!string.IsNullOrEmpty(_subs))
                    {
                        var match = new Regex("\\[([^\\]]+)\\]([^\\[\\,]+)").Match(_subs);
                        while (match.Success)
                        {
                            string srt = match.Groups[2].Value;
                            if (srt.StartsWith("//"))
                                srt = "https:" + srt;

                            subtitles.Append(match.Groups[1].Value, HostStreamProxy(init, srt, proxy: proxy));
                            match = match.NextMatch();
                        }
                    }
                    #endregion

                    voice = Regex.Replace(voice, "<[^>]+>", "");
                    mtpl.Append(voice, HostStreamProxy(init, file, proxy: proxy), subtitles: subtitles, vast: init.vast);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
            }
            else
            {
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);
                string enc_href = HttpUtility.UrlEncode(href);

                if (s == -1)
                {
                    var tpl = new SeasonTpl(playlist.Count);
                    foreach (var season in playlist)
                    {
                        string _s = Regex.Match(season.Value<string>("title"), " ([0-9]+)$").Groups[1].Value;
                        if (!string.IsNullOrEmpty(_s))
                        {
                            string link = $"{host}/lite/kinogo?rjson={rjson}&title={enc_title}&original_title={enc_original_title}&year={year}&href={enc_href}&s={_s}";
                            tpl.Append($"{_s} —Å–µ–∑–æ–Ω", link, _s);
                        }
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                }
                else
                {
                    var episodes = playlist.First(i => i.Value<string>("title").EndsWith($" {s}"))["folder"];

                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var vtpl = new VoiceTpl();
                    var hashSet = new HashSet<int>();

                    foreach (var episode in episodes)
                    {
                        foreach (var voice in episode["folder"])
                        {
                            int voice_id = voice.Value<int>("voice_id");
                            if (!hashSet.Add(voice_id))
                                continue;

                            if (t == -1)
                                t = voice_id;

                            string link = $"{host}/lite/kinogo?rjson={rjson}&title={enc_title}&original_title={enc_original_title}&year={year}&href={enc_href}&s={s}&t={voice_id}";
                            bool active = t == voice_id;

                            vtpl.Append(voice.Value<string>("title"), active, link);
                        }
                    }
                    #endregion

                    var etpl = new EpisodeTpl(episodes.Count());
                    string sArhc = s.ToString();

                    foreach (var episode in episodes)
                    {
                        string name = episode.Value<string>("title");
                        string file = episode["folder"].FirstOrDefault(i => i.Value<int>("voice_id") == t)?.Value<string>("file");

                        if (string.IsNullOrEmpty(file))
                            continue;

                        if (file.StartsWith("//"))
                            file = "https:" + file;

                        #region subtitle
                        var subtitles = new SubtitleTpl();
                        string _subs = episode.Value<string>("subtitle");

                        if (!string.IsNullOrEmpty(_subs))
                        {
                            var match = new Regex("\\[([^\\]]+)\\]([^\\[\\,]+)").Match(_subs);
                            while (match.Success)
                            {
                                string srt = match.Groups[2].Value;
                                if (srt.StartsWith("//"))
                                    srt = "https:" + srt;

                                subtitles.Append(match.Groups[1].Value, HostStreamProxy(init, srt, proxy: proxy));
                                match = match.NextMatch();
                            }
                        }
                        #endregion

                        string stream = HostStreamProxy(init, file, proxy: proxy);
                        etpl.Append(name, title ?? original_title, sArhc, Regex.Match(name, " ([0-9]+)$").Groups[1].Value, stream, subtitles: subtitles, vast: init.vast);
                    }

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                }
            }
        }
        #endregion

        #region SearchResult
        SearchModel SearchResult(string html, string title, int year)
        {
            string stitle = StringConvert.SearchName(title);

            var matches = Regex.Matches(html, "<div id=\"[0-9]+\" class=\"shortstory\">(.*?)<div class=\"shortstory__meta\">", RegexOptions.Singleline);
            if (matches.Count == 0)
                return null;

            var similar = new SimilarTpl(matches.Count);

            string link = null;

            foreach (Match match in matches)
            {
                string block = match.Groups[1].Value;
                string href = Regex.Match(block, "<a href=\"https?://[^/]+/([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(href))
                    continue;

                string name = Regex.Match(block, "<h2>([^<]+)</h2>").Groups[1].Value;
                if (string.IsNullOrEmpty(name))
                    continue;
                
                string blockYear = Regex.Match(block, "–ì–æ–¥ –≤—ã–ø—É—Å–∫–∞:</b><a[^>]*>([0-9]{4})").Groups[1].Value;

                string img = Regex.Match(block, "<img\\s+data-src=\"([^\"]+)\"").Groups[1].Value;
                if (!string.IsNullOrEmpty(img))
                    img = AppInit.conf.Kinogo.corsHost() + img;

                string uri = $"{host}/lite/kinogo?href={HttpUtility.UrlEncode(href)}";
                similar.Append(name, blockYear, string.Empty, uri, PosterApi.Size(img));

                if (StringConvert.SearchName(name).Contains(stitle) && blockYear == year.ToString())
                    link = href;
            }

            if (string.IsNullOrEmpty(link) && similar.data.Count == 0)
                return null;

            return new SearchModel() 
            {
                link = link,
                similar = similar
            };
        }
        #endregion
    }
}
```

## File: Online/Controllers/RutubeMovie.cs
```
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.RutubeMovie;

namespace Online.Controllers
{
    public class RutubeMovie : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/rutubemovie")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int year, int serial, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.RutubeMovie);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            string searchTitle = StringConvert.SearchName(title);
            if (string.IsNullOrEmpty(searchTitle) || year == 0)
                return OnError();

            var proxyManager = new ProxyManager(init);

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            if (serial == 1)
            {
                return OnError();
            }
            else
            {
                reset:
                string memKey = $"rutubemovie:view:{searchTitle}:{year}:{(rch.enable ? requestInfo.Country : "")}";
                var cache = await InvokeCache<Result[]>(memKey, cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string uri = $"api/search/video/?content_type=video&duration=movie&query={HttpUtility.UrlEncode($"{title} {year}")}";
                    var root = rch.enable ? await rch.Get<JObject>($"{init.host}/{uri}", httpHeaders(init)) : 
                                            await Http.Get<JObject>($"{init.host}/{uri}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));

                    if (root == null || !root.ContainsKey("results"))
                        return res.Fail("content");

                    return root["results"].ToObject<Result[]>();
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                return OnResult(cache, () =>
                {
                    var mtpl = new MovieTpl(title, original_title, cache.Value.Length);

                    foreach (var movie in cache.Value)
                    {
                        string name = StringConvert.SearchName(movie.title);
                        if (name != null && name.Contains(searchTitle) && (name.Contains(year.ToString()) || name.Contains((year + 1).ToString()) || name.Contains((year - 1).ToString())))
                        {
                            long duration = movie.duration;
                            if (duration > 3000) // 50 minutes
                            {
                                if (name.Contains("—Ç—Ä–µ–π–ª–µ—Ä") || name.Contains("trailer") ||
                                    name.Contains("–ø—Ä–µ–º—å–µ—Ä–∞") || name.Contains("–æ–±–∑–æ—Ä") ||
                                    name.Contains("—Å–µ–∑–æ–Ω") || name.Contains("—Å–µ—Ä–∏–∞–ª") ||
                                    name.Contains("—Å–µ—Ä–∏—è") || name.Contains("—Å–µ—Ä–∏–π"))
                                    continue;

                                if (movie.category.id == 4)
                                {
                                    if (movie.is_hidden || movie.is_deleted || movie.is_adult || movie.is_locked || movie.is_audio || movie.is_paid || movie.is_livestream)
                                        continue;

                                    mtpl.Append(movie.title, $"{host}/lite/rutubemovie/play?linkid={movie.id}", "call", vast: init.vast);
                                }
                            }
                        }
                    }

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();

                }, gbcache: !rch.enable);
            }
        }


        [HttpGet]
        [Route("lite/rutubemovie/play")]
        async public ValueTask<ActionResult> Movie(string linkid)
        {
            var init = await loadKit(AppInit.conf.RutubeMovie);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(linkid))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            reset:
            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var cache = await InvokeCache<string>($"rutubemovie:play:{linkid}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string uri = $"api/play/options/{linkid}/?no_404=true&referer=&pver=v2&client=wdp";
                var root = rch.enable ? await rch.Get<JObject>($"{init.host}/{uri}", httpHeaders(init)) : 
                                        await Http.Get<JObject>($"{init.host}/{uri}", timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));

                if (root == null || !root.ContainsKey("video_balancer"))
                    return res.Fail("video_balancer");

                return root["video_balancer"].Value<string>("m3u8");
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return ContentTo(VideoTpl.ToJson("play", HostStreamProxy(init, cache.Value, proxy: proxy), "auto", vast: init.vast));
        }
    }
}

```

## File: Online/Controllers/Kinotochka.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Kinotochka;

namespace Online.Controllers
{
    public class Kinotochka : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/kinotochka")]
        async public ValueTask<ActionResult> Index(long kinopoisk_id, string title, string original_title, int serial, string newsuri, int s = -1, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.Kinotochka);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            // enable 720p
            string cookie = init.cookie;

            if (serial == 1)
            {
                if (s == -1)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    reset:
                    var cache = await InvokeCache<List<(string name, string uri, string season)>>($"kinotochka:seasons:{title}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
                    {
                        List<(string, string, string)> links = null;

                        if (kinopoisk_id > 0) // https://kinovibe.co/embed.html
                        {
                            string uri = $"{init.corsHost()}/api/find-by-kinopoisk.php?kinopoisk={kinopoisk_id}";
                            var root = rch.enable ? await rch.Get<JArray>(uri, httpHeaders(init)) : await Http.Get<JArray>(uri, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));
                            if (root == null || root.Count == 0)
                                return res.Fail("find-by-kinopoisk");

                            links = new List<(string, string, string)>(root.Count);
                            foreach (var item in root)
                            {
                                string url = item.Value<string>("url");
                                string sname = Regex.Match(url, "-([0-9]+)-sezon").Groups[1].Value;
                                if (!string.IsNullOrEmpty(sname))
                                    links.Add(($"{sname} —Å–µ–∑–æ–Ω", $"{host}/lite/kinotochka?title={HttpUtility.UrlEncode(title)}&serial={serial}&s={sname}&newsuri={HttpUtility.UrlEncode(url)}", sname));
                            }

                            if (links.Count == 0)
                                return res.Fail("links");
                        }
                        else
                        {
                            string data = $"do=search&subaction=search&search_start=0&full_search=0&result_from=1&story={HttpUtility.UrlEncode(title)}";
                            string search = rch.enable ? await rch.Post($"{init.corsHost()}/index.php?do=search", data, httpHeaders(init)) : await Http.Post($"{init.corsHost()}/index.php?do=search", data, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));
                            if (search == null)
                            {
                                if (!rch.enable)
                                    proxyManager.Refresh();

                                return res.Fail("search");
                            }

                            var rows = search.Split("sres-wrap clearfix");
                            links = new List<(string, string, string)>(rows.Length);

                            string stitle = StringConvert.SearchName(title);

                            foreach (string row in rows.Skip(1).Reverse())
                            {
                                var gname = Regex.Match(row, "<h2>([^<]+) (([0-9]+) –°–µ–∑–æ–Ω) \\([0-9]{4}\\)</h2>", RegexOptions.IgnoreCase).Groups;

                                if (StringConvert.SearchName(gname[1].Value) == stitle)
                                {
                                    string uri = Regex.Match(row, "href=\"(https?://[^\"]+\\.html)\"").Groups[1].Value;
                                    if (string.IsNullOrWhiteSpace(uri))
                                        continue;

                                    links.Add((gname[2].Value.ToLower(), $"{host}/lite/kinotochka?title={HttpUtility.UrlEncode(title)}&serial={serial}&s={gname[3].Value}&newsuri={HttpUtility.UrlEncode(uri)}", gname[3].Value));
                                }
                            }

                            if (links.Count == 0 && !search.Contains(">–ü–æ–∏—Å–∫ –ø–æ —Å–∞–π—Ç—É<"))
                                return res.Fail("links");
                        }

                        return links;
                    });

                    if (IsRhubFallback(cache, init))
                        goto reset;

                    return OnResult(cache, () =>
                    {
                        var tpl = new SeasonTpl(cache.Value.Count);

                        foreach (var l in cache.Value)
                            tpl.Append(l.name, l.uri, l.season);

                        return rjson ? tpl.ToJson() : tpl.ToHtml();

                    }, gbcache: !rch.enable);
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∏
                    reset: 
                    var cache = await InvokeCache<List<(string name, string uri)>>($"kinotochka:playlist:{newsuri}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
                    {
                        string news = rch.enable ? await rch.Get(newsuri, httpHeaders(init)) : await Http.Get(newsuri, timeoutSeconds: 8, proxy: proxy, cookie: cookie, headers: httpHeaders(init));
                        if (news == null)
                        {
                            if (!rch.enable)
                                proxyManager.Refresh();

                            return res.Fail("news");
                        }

                        string filetxt = Regex.Match(news, "file:\"(https?://[^\"]+\\.txt)\"").Groups[1].Value;
                        if (string.IsNullOrEmpty(filetxt))
                            return res.Fail("filetxt");

                        var root = rch.enable ? await rch.Get<JObject>(filetxt, httpHeaders(init)) : await Http.Get<JObject>(filetxt, timeoutSeconds: 8, proxy: proxy, cookie: cookie, headers: httpHeaders(init));
                        if (root == null)
                        {
                            if (!rch.enable)
                                proxyManager.Refresh();

                            return res.Fail("root");
                        }

                        var playlist = root.Value<JArray>("playlist");
                        if (playlist == null)
                            return res.Fail("playlist");

                        var links = new List<(string name, string uri)>(playlist.Count);

                        foreach (var pl in playlist)
                        {
                            string name = pl.Value<string>("comment");
                            string file = pl.Value<string>("file");
                            if (!string.IsNullOrWhiteSpace(name) && !string.IsNullOrWhiteSpace(file))
                            {
                                if (file.Contains("].mp4"))
                                    file = Regex.Replace(file, "\\[[^\\]]+,([0-9]+)\\]\\.mp4$", "$1.mp4");

                                links.Add((name.Split("<")[0].Trim(), file));
                            }
                        }

                        if (links.Count == 0)
                            return res.Fail("links");

                        return links;
                    });

                    if (IsRhubFallback(cache, init))
                        goto reset;

                    return OnResult(cache, () =>
                    {
                        var etpl = new EpisodeTpl(cache.Value.Count);

                        foreach (var l in cache.Value)
                            etpl.Append(l.name, title, s.ToString(), Regex.Match(l.name, "^([0-9]+)").Groups[1].Value, HostStreamProxy(init, l.uri, proxy: proxy), vast: init.vast);

                        return rjson ? etpl.ToJson() : etpl.ToHtml();

                    }, gbcache: !rch.enable);
                    #endregion
                }
            }
            else
            {
                #region –§–∏–ª—å–º
                if (kinopoisk_id == 0)
                    return OnError();

                reset:
                var cache = await InvokeCache<EmbedModel>($"kinotochka:view:{kinopoisk_id}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string uri = $"{init.corsHost()}/embed/kinopoisk/{kinopoisk_id}";
                    string embed = rch.enable ? await rch.Get(uri, httpHeaders(init)) : await Http.Get(uri, timeoutSeconds: 8, proxy: proxy, cookie: cookie, headers: httpHeaders(init));
                    if (embed == null)
                    {
                        if (!rch.enable)
                            proxyManager.Refresh();

                        return res.Fail("embed");
                    }

                    string file = Regex.Match(embed, "id:\"playerjshd\", file:\"(https?://[^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(file))
                        return res.Fail("file");

                    foreach (string f in file.Split(",").Reverse())
                    {
                        if (string.IsNullOrWhiteSpace(f))
                            continue;

                        file = f;
                        break;
                    }

                    return new EmbedModel() { content = file };
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                return OnResult(cache, () => 
                {
                    var mtpl = new MovieTpl(title, original_title, 1);
                    mtpl.Append("–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é", HostStreamProxy(init, cache.Value.content, proxy: proxy), vast: init.vast);

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();

                }, gbcache: !rch.enable);
                #endregion
            }
        }
    }
}

```

## File: Online/Controllers/Plvideo.cs
```
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Plvideo;

namespace Online.Controllers
{
    public class Plvideo : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/plvideo")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int year, int serial, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.Plvideo);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            string searchTitle = StringConvert.SearchName(title);
            if (string.IsNullOrEmpty(searchTitle) || year == 0)
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            if (serial == 1)
            {
                return OnError();
            }
            else
            {
                reset:
                var cache = await InvokeCache<Item[]>($"plvideo:view:{searchTitle}:{year}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string uri = $"v1/videos?Type=video&Query={HttpUtility.UrlEncode($"{title} {year}")}&From=0&Size=20&Aud=16&Qf=false";
                    var root = rch.enable ? await rch.Get<JObject>($"{init.host}/{uri}", httpHeaders(init)) : 
                                            await Http.Get<JObject>($"{init.host}/{uri}", timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));

                    if (root == null || !root.ContainsKey("items"))
                        return res.Fail("content");

                    return root["items"].ToObject<Item[]>();
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                return OnResult(cache, () =>
                {
                    var mtpl = new MovieTpl(title, original_title, cache.Value.Length);

                    foreach (var movie in cache.Value)
                    {
                        string name = StringConvert.SearchName(movie.title);
                        if (name != null && name.StartsWith(searchTitle) && (name.Contains(year.ToString()) || name.Contains((year + 1).ToString()) || name.Contains((year - 1).ToString())))
                        {
                            long duration = movie.uploadFile.videoDuration;
                            if (duration > 1900000) // 30 minutes
                            {
                                if (name.Contains("—Ç—Ä–µ–π–ª–µ—Ä") || name.Contains("–ø—Ä–µ–º—å–µ—Ä–∞") || name.Contains("—Å–µ–∑–æ–Ω") || name.Contains("—Å–µ—Ä–∏–∞–ª") || name.Contains("—Å–µ—Ä–∏—è") || name.Contains("—Å–µ—Ä–∏–π"))
                                    continue;

                                if (movie.visible != "public")
                                    continue;

                                mtpl.Append(movie.title, $"{host}/lite/plvideo/movie?linkid={movie.id}", "call");
                            }
                        }
                    }

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();

                }, gbcache: !rch.enable);
            }
        }



        [HttpGet]
        [Route("lite/plvideo/movie")]
        async public ValueTask<ActionResult> Movie(string linkid)
        {
            var init = await loadKit(AppInit.conf.Plvideo);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(linkid))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            reset: var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var cache = await InvokeCache<Dictionary<string, Profile>>($"plvideo:play:{linkid}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string uri = $"v1/videos/{linkid}?Aud=16";
                var root = rch.enable ? await rch.Get<JObject>($"{init.host}/{uri}", httpHeaders(init)) : 
                                        await Http.Get<JObject>($"{init.host}/{uri}", timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));

                if (root == null || !root.ContainsKey("item"))
                    return res.Fail("item");

                return root["item"]["profiles"].ToObject<Dictionary<string, Profile>>();
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            var streams = new StreamQualityTpl();
            foreach (string q in new string[] { "2160p", "1440p", "1080p", "720p", "468p", "360p", "240p" })
            {
                if (cache.Value.TryGetValue(q, out Profile p))
                {
                    if (!string.IsNullOrEmpty(p.hls))
                        streams.Append(HostStreamProxy(init, p.hls + "#.m3u8", proxy: proxy), q);
                }
            }

            return ContentTo(VideoTpl.ToJson("play", streams.Firts().link, streams.Firts().quality, streamquality: streams, vast: init.vast));
        }
    }
}

```

## File: Online/Controllers/VDBmovies.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Shared.Models.Online.Settings;
using Shared.Models.Online.VDBmovies;
using Shared.PlaywrightCore;
using System.Net;

namespace Online.Controllers
{
    public class VDBmovies : BaseOnlineController
    {
        #region database
        static List<MovieDB> databaseCache;

        static IEnumerable<MovieDB> database
        {
            get
            {
                if (AppInit.conf.multiaccess || databaseCache != null)
                    return databaseCache ??= JsonHelper.ListReader<MovieDB>("data/cdnmovies.json", 105000);

                return JsonHelper.IEnumerableReader<MovieDB>("data/cdnmovies.json");
            }
        }
        #endregion

        static string referer = CrypTo.DecodeBase64("aHR0cHM6Ly9tb3ZpZWJvb20uc3RvcmUv");

        [HttpGet]
        [Route("lite/vdbmovies")]
        async public ValueTask<ActionResult> Index(string orid, string imdb_id, long kinopoisk_id, string title, string original_title, bool similar, string t, int sid, int s = -1, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.VDBmovies);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var oninvk = new VDBmoviesInvoke
            (
               host,
               init.hls,
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy.proxy)
            );

            #region –ø–æ–∏—Å–∫
            if (similar || (string.IsNullOrEmpty(orid) && kinopoisk_id == 0))
            {
                if (!init.spider)
                    return OnError("spider");

                var stpl = new SimilarTpl();

                string stitle = StringConvert.SearchName(title);
                string sorigtitle = StringConvert.SearchName(original_title);

                foreach (var j in database)
                {
                    if (stpl.data.Count > 100)
                        break;

                    bool IsOkTitle = false, IsOkID = false;

                    if (kinopoisk_id > 0 && kinopoisk_id == j.kinopoisk_id)
                        IsOkID = true;

                    if (!string.IsNullOrEmpty(imdb_id) && j.imdb_id == imdb_id)
                        IsOkID = true;

                    if (!IsOkID)
                    {
                        if (sorigtitle != null && StringConvert.SearchName(j.orig_title) == sorigtitle)
                            IsOkTitle = true;

                        if (!IsOkTitle && stitle != null)
                        {
                            if (StringConvert.SearchName(j.ru_title) != null)
                            {
                                if (StringConvert.SearchName(j.ru_title).Contains(stitle))
                                    IsOkTitle = true;
                            }

                            if (!IsOkTitle && StringConvert.SearchName(j.orig_title) != null)
                            {
                                if (StringConvert.SearchName(j.orig_title).Contains(stitle))
                                    IsOkTitle = true;
                            }
                        }
                    }

                    if (IsOkTitle || IsOkID)
                    {
                        if (!similar && IsOkID)
                        {
                            orid = j.id;
                            break;
                        }
                        else
                        {
                            string uri = $"{host}/lite/vdbmovies?orid={j.id}";
                            stpl.Append(j.ru_title ?? j.orig_title, j.year.ToString(), string.Empty, uri, PosterApi.Find(j.kinopoisk_id, j.imdb_id));
                        }
                    }
                }

                if (similar || string.IsNullOrEmpty(orid))
                    return ContentTo(rjson ? stpl.ToJson() : stpl.ToHtml());
            }
            #endregion

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            reset: 
            var cache = await InvokeCache<EmbedModel>(rch.ipkey($"vdbmovies:{orid}:{kinopoisk_id}", proxyManager), cacheTime(20, rhub: 2, init: init), proxyManager, async res =>
            {
                string uri = $"{init.corsHost()}/kinopoisk/{kinopoisk_id}/iframe";
                if (!string.IsNullOrEmpty(orid))
                    uri = $"{init.corsHost()}/content/{orid}/iframe";

                string html = rch.enable ? await rch.Get(uri, httpHeaders(init, HeadersModel.Init(("referer", referer)))) : 
                                           await black_magic(uri, referer, init, proxy);

                if (html == null)
                    return res.Fail("html");

                string file = Regex.Match(html, "file:([\t ]+)?'(#[^']+)").Groups[2].Value;
                if (string.IsNullOrEmpty(file))
                    return res.Fail("file");

                return oninvk.Embed(oninvk.DecodeEval(file));
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, orid, imdb_id, kinopoisk_id, title, original_title, t, s, sid, vast: init.vast, rjson: rjson), origsource: origsource, gbcache: !rch.enable);
        }


        #region black_magic
        async Task<string> black_magic(string uri, string referer, OnlinesSettings init, (WebProxy proxy, (string ip, string username, string password) data) baseproxy)
        {
            try
            {
                var headers = httpHeaders(init, HeadersModel.Init(
                    ("sec-fetch-dest", "iframe"),
                    ("sec-fetch-mode", "navigate"),
                    ("sec-fetch-site", "cross-site"),
                    ("referer", referer)
                ));

                if (init.priorityBrowser == "http")
                    return await Http.Get(uri, httpversion: 2, timeoutSeconds: 8, proxy: baseproxy.proxy, headers: headers);

                using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                {
                    var page = await browser.NewPageAsync(init.plugin, init.headers, proxy: baseproxy.data, imitationHuman: init.imitationHuman).ConfigureAwait(false);
                    if (page == null)
                        return null;

                    browser.SetFailedUrl(uri);

                    await page.RouteAsync("**/*", async route =>
                    {
                        try
                        {
                            if (route.Request.Url.StartsWith(referer))
                            {
                                await route.FulfillAsync(new RouteFulfillOptions
                                {
                                    Body = PlaywrightBase.IframeHtml(uri)
                                });
                            }
                            else if (route.Request.Url == uri)
                            {
                                string html = null;
                                await route.ContinueAsync();

                                var response = await page.WaitForResponseAsync(route.Request.Url);
                                if (response != null)
                                    html = await response.TextAsync();

                                browser.SetPageResult(html);
                                PlaywrightBase.WebLog(route.Request, response, html, baseproxy.data);
                                return;
                            }
                            else
                            {
                                if (!init.imitationHuman || route.Request.Url.EndsWith(".m3u8") || route.Request.Url.Contains("/cdn-cgi/challenge-platform/"))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                }
                                else
                                {
                                    if (await PlaywrightBase.AbortOrCache(page, route))
                                        return;

                                    await route.ContinueAsync();
                                }
                            }
                        }
                        catch { }
                    });

                    PlaywrightBase.GotoAsync(page, referer);
                    return await browser.WaitPageResult().ConfigureAwait(false);
                }
            }
            catch { return null; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/Rezka.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Shared.Models.Online.Rezka;
using Shared.Models.Online.Settings;
using System.Net;

namespace Online.Controllers
{
    public class Rezka : BaseOnlineController
    {
        #region InitRezkaInvoke
        async public ValueTask<RezkaInvoke> InitRezkaInvoke(RezkaSettings init)
        {
            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            string country = init.forceua ? "UA" : requestInfo.Country;
            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            var headers = httpHeaders(init);
            var cookie = await getCookie(init);

            if (rch.enable && cookie != null)
                headers.Add(new HeadersModel("Cookie", rhubCookie));

            if (init.xapp)
                headers.Add(new HeadersModel("X-App-Hdrezka-App", "1"));

            if (init.xrealip)
                headers.Add(new HeadersModel("realip", requestInfo.IP));

            return new RezkaInvoke
            (
                host,
                init,
                (url, hed) =>
                    rch.enable ? rch.Get(url, HeadersModel.Join(hed, headers)) :
                    Http.Get(init.cors(url), timeoutSeconds: 8, proxy: proxy, headers: HeadersModel.Join(hed, headers), cookieContainer: cookieContainer, statusCodeOK: false),
                (url, data, hed) =>
                    rch.enable ? rch.Post(url, data, HeadersModel.Join(hed, headers)) :
                    Http.Post(init.cors(url), data, timeoutSeconds: 8, proxy: proxy, headers: HeadersModel.Join(hed, headers), cookieContainer: cookieContainer),
                streamfile => HostStreamProxy(init, RezkaInvoke.fixcdn(country, init.uacdn, streamfile), proxy: proxy, headers: RezkaInvoke.StreamProxyHeaders(init)),
                requesterror: () => proxyManager.Refresh()
            );
        }
        #endregion

        #region Initialization
        ValueTask<RezkaSettings> Initialization()
        {
            return loadKit(AppInit.conf.Rezka, (j, i, c) =>
            {
                if (j.ContainsKey("premium"))
                    i.premium = c.premium;

                if (j.ContainsKey("uacdn"))
                    i.uacdn = c.uacdn;

                if (j.ContainsKey("forceua"))
                    i.forceua = c.forceua;

                if (j.ContainsKey("reserve"))
                    i.reserve = c.reserve;

                if (j.ContainsKey("ajax"))
                    i.ajax = c.ajax;

                return i;
            });
        }
        #endregion

        [HttpGet]
        [Route("lite/rezka")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int clarification, int year, int s = -1, string href = null, bool rjson = false, int serial = -1, bool similar = false, string source = null, string id = null)
        {
            #region Initialization
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (init.premium || AppInit.conf.RezkaPrem.enable) 
                return ShowError("–ó–∞–º–µ–Ω–∏—Ç–µ Rezka –Ω–∞ RezkaPrem –≤ init.conf");

            if (string.IsNullOrWhiteSpace(href) && string.IsNullOrWhiteSpace(title))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: serial == 0 ? null : -1);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.enable)
            {
                if (rch.IsNotSupport("web", out string rch_error))
                    return ShowError($"–ù—É–∂–µ–Ω HDRezka Premium<br>{init.host}/payments/");

                if (requestInfo.Country == "RU")
                {
                    if (rch.InfoConnected()?.rchtype != "apk")
                        return ShowError($"–ù—É–∂–µ–Ω HDRezka Premium<br>{init.host}/payments/");

                    if (await getCookie(init) == null)
                        return ShowError("–£–∫–∞–∂–∏—Ç–µ –ª–æ–≥–∏–Ω/–ø–∞—Ä–æ–ª—å –∏–ª–∏ cookie");
                }
            }
            #endregion

            if (string.IsNullOrEmpty(href) && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() is "rezka" or "hdrezka")
                    href = id;
            }

            var oninvk = await InitRezkaInvoke(init);
            var proxyManager = new ProxyManager(init);

            #region search
            string search_uri = null;

            if (string.IsNullOrEmpty(href))
            {
                var search = await InvokeCache<SearchModel>($"rezka:search:{title}:{original_title}:{clarification}:{year}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    var content = await oninvk.Search(title, original_title, clarification, year);
                    if (content == null || (content.IsEmpty && content.content != null))
                        return res.Fail(content.content ?? "content");

                    return content;
                });

                if (search.ErrorMsg != null && search.ErrorMsg.Contains("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞"))
                    return ShowError(search.ErrorMsg);

                if (similar || string.IsNullOrEmpty(search.Value?.href))
                {
                    if (search.Value?.IsEmpty == true)
                        return ShowError(search.Value.content ?? "–ø–æ–∏—Å–∫ –Ω–µ –¥–∞–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤");

                    return OnResult(search, () =>
                    {
                        if (search.Value.similar == null)
                            return string.Empty;

                        var stpl = new SimilarTpl(search.Value.similar.Count);

                        foreach (var similar in search.Value.similar)
                        {
                            string link = $"{host}/lite/rezka?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&href={HttpUtility.UrlEncode(similar.href)}";

                            stpl.Append(similar.title, similar.year, string.Empty, link, PosterApi.Size(similar.img));
                        }

                        return rjson ? stpl.ToJson() : stpl.ToHtml();
                    });
                }

                href = search.Value.href;
                search_uri = search.Value.search_uri;
            }
            #endregion

            var cache = await InvokeCache<EmbedModel>($"rezka:{href}", cacheTime(10, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(href, search_uri);
            });

            return OnResult(cache, () => oninvk.Html(cache.Value, accsArgs(string.Empty), title, original_title, s, href, true, rjson), gbcache: !rch.enable);
        }


        #region Serial
        [HttpGet]
        [Route("lite/rezka/serial")]
        async public ValueTask<ActionResult> Serial(string title, string original_title, string href, long id, int t, int s = -1, bool rjson = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(href))
                return OnError();

            var oninvk = await InitRezkaInvoke(init);
            var proxyManager = new ProxyManager(init);

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            Episodes root = await InvokeCache($"rezka:view:serial:{id}:{t}", cacheTime(20, init: init), () => oninvk.SerialEmbed(id, t));
            if (root == null)
                return OnError(null, gbcache: !rch.enable);

            var content = await InvokeCache($"rezka:{href}", cacheTime(20, init: init), () => oninvk.Embed(href, null));
            if (content == null)
                return OnError(null, gbcache: !rch.enable);

            return ContentTo(oninvk.Serial(root, content, accsArgs(string.Empty), title, original_title, href, id, t, s, true, rjson));
        }
        #endregion

        #region Movie
        [HttpGet]
        [Route("lite/rezka/movie")]
        [Route("lite/rezka/movie.m3u8")]
        async public ValueTask<ActionResult> Movie(string title, string original_title, string voice, long id, int t, int director = 0, int s = -1, int e = -1, string favs = null, bool play = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var oninvk = await InitRezkaInvoke(init);
            var proxyManager = new ProxyManager(init);

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: s == -1 ? null : -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string realip = (init.xrealip && init.corseu) ? requestInfo.IP : "";

            MovieModel md = null;

            /// ajax = true (get_cdn_series)
            /// ajax = false (movie | get_cdn_series)
            /// ajax = null (movie)

            if (init.ajax != null && init.ajax.Value == false && !string.IsNullOrEmpty(voice))
            {
                md = await InvokeCache(rch.ipkey($"rezka:movie:{voice}:{realip}:{init.cookie}", proxyManager), cacheTime(20, mikrotik: 1, init: init), () => oninvk.Movie(voice), proxyManager);
            }

            if (md == null && init.ajax != null)
                md = await InvokeCache(rch.ipkey($"rezka:view:get_cdn_series:{id}:{t}:{director}:{s}:{e}:{realip}:{init.cookie}", proxyManager), cacheTime(20, mikrotik: 1, init: init), () => oninvk.Movie(id, t, director, s, e, favs), proxyManager);

            if (md == null)
                return OnError(null, gbcache: !rch.enable);

            string result = oninvk.Movie(md, title, original_title, play, vast: init.vast);
            if (result == null)
                return OnError(null, gbcache: !rch.enable);

            if (play)
                return RedirectToPlay(result);

            return ContentTo(result);
        }
        #endregion


        #region getCookie
        static string rhubCookie = string.Empty;
        static CookieContainer cookieContainer = null;

        async ValueTask<CookieContainer> getCookie(RezkaSettings init)
        {
            if (cookieContainer != null)
                return cookieContainer;

            string domain = Regex.Match(init.host, "https?://([^/]+)").Groups[1].Value;

            #region setCookieContainer
            void setCookieContainer(string coks)
            {
                cookieContainer = new CookieContainer();

                if (coks != string.Empty && !coks.Contains("hdmbbs"))
                    coks = $"hdmbbs=1; {coks}";

                if (!coks.Contains("dle_user_taken"))
                    coks = $"dle_user_taken=1; {coks}";

                foreach (string line in coks.Split(";"))
                {
                    if (string.IsNullOrEmpty(line) || !line.Contains("="))
                        continue;

                    var g = Regex.Match(line.Trim(), "^([^=]+)=([^\n\r]+)").Groups;
                    string name = g[1].Value.Trim();
                    string value = g[2].Value.Trim();

                    if (name is "CLID" or "MUID" or "_clck" or "_clsk")
                        continue;

                    if (name.StartsWith("_ym_"))
                        continue;

                    if (name != "PHPSESSID")
                        rhubCookie += $"{name}={value}; ";

                    if (name == "hdmbbs")
                    {
                        cookieContainer.Add(new Cookie()
                        {
                            Path = "/",
                            Expires = DateTime.Today.AddYears(1),
                            Domain = domain,
                            Name = name,
                            Value = value
                        });
                    }
                    else
                    {
                        cookieContainer.Add(new Cookie()
                        {
                            Path = "/",
                            Expires = name == "PHPSESSID" ? default : DateTime.Today.AddYears(1),
                            Domain = $".{domain}",
                            Name = name,
                            Value = value,
                            HttpOnly = true
                        });
                    }
                }

                rhubCookie = Regex.Replace(rhubCookie.Trim(), ";$", "");
            }
            #endregion

            if (!string.IsNullOrEmpty(init.cookie))
            {
                setCookieContainer(init.cookie.Trim());
                return cookieContainer;
            }

            if (string.IsNullOrEmpty(init.login) || string.IsNullOrEmpty(init.passwd))
            {
                setCookieContainer(string.Empty);
                return cookieContainer;
            }

            if (memoryCache.TryGetValue("rezka:login", out _))
                return null;

            memoryCache.Set("rezka:login", 0, TimeSpan.FromMinutes(2));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(20);
                        client.DefaultRequestHeaders.Add("user-agent", Http.UserAgent);

                        var postParams = new Dictionary<string, string>
                        {
                            { "login_name", init.login },
                            { "login_password", init.passwd },
                            { "login_not_save", "0" }
                        };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync($"{init.host}/ajax/login/", postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string cookie = string.Empty;

                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrEmpty(line))
                                            continue;

                                        if (line.Contains("=deleted;") || !line.Contains(domain))
                                            continue;

                                        string c = line.Split(";")[0];
                                        if (c.Contains("="))
                                        {
                                            string name = c.Split("=")[0];
                                            if (cookie.Contains(name))
                                            {
                                                cookie = Regex.Replace(cookie, $"{name}=[^;]+", $"{name}={c.Split("=")[1]}");
                                            }
                                            else
                                            {
                                                cookie += $"{c}; ";
                                            }
                                        }
                                    }

                                    if (cookie.Contains("dle_user_id") && cookie.Contains("dle_password"))
                                    {
                                        setCookieContainer(cookie.Trim());
                                        return cookieContainer;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch { }

            return null;
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/Vidsrc.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class VidSrc : BaseENGController
    {
        [HttpGet]
        [Route("lite/vidsrc")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.Vidsrc, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, method: "call");
        }


        #region Video
        static List<HeadersModel> lastHeaders = null;


        [HttpGet]
        [Route("lite/vidsrc/video")]
        [Route("lite/vidsrc/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id, string imdb_id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.Vidsrc);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (id == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/v2/embed/movie/{id}?autoPlay=true&poster=false";
            if (s > 0)
                embed = $"{init.host}/v2/embed/tv/{id}/{s}/{e}?autoPlay=true&poster=false";

            return await InvkSemaphore(init, embed, async () =>
            {
                #region api servers
                if (memoryCache.TryGetValue($"vidsrc:lastvrf:{id}", out string _vrf) && s > 0)
                {
                    string uri = $"{init.host}/api/{id}/servers?id={id}&type=tv&season={s}&episode={e}&vrf={_vrf}&imdbId={imdb_id}";
                    if (!hybridCache.TryGetValue(uri, out JToken data))
                    {
                        try
                        {
                            var root = await Http.Get<JObject>(uri, timeoutSeconds: 8);
                            if (root != null && root.ContainsKey("data"))
                            {
                                string hash = root["data"].First.Value<string>("hash");
                                var source = await Http.Get<JObject>($"{init.host}/api/source/{hash}", timeoutSeconds: 8);
                                if (source != null && source.ContainsKey("data"))
                                {
                                    data = source["data"];
                                    hybridCache.Set(uri, data, cacheTime(20));
                                }
                            }
                        }
                        catch { }
                    }

                    if (data != null)
                    {
                        var subtitles = new SubtitleTpl();
                        try
                        {
                            foreach (var sub in data["subtitles"])
                                subtitles.Append(sub.Value<string>("label"), HostStreamProxy(init, sub.Value<string>("file"), proxy: proxy.proxy));
                        }
                        catch { }

                        var lastHeaders_headers = httpHeaders(init.host, init.headers_stream);
                        if (lastHeaders_headers.Count == 0)
                            lastHeaders_headers = lastHeaders;

                        string file = HostStreamProxy(init, data.Value<string>("source"), proxy: proxy.proxy, headers: lastHeaders_headers);
                        if (play)
                            return RedirectToPlay(file);

                        return ContentTo(VideoTpl.ToJson("play", file, "English", subtitles: subtitles, vast: init.vast, headers: init.streamproxy ? null : lastHeaders_headers));
                    }
                }
                #endregion

                var cache = await black_magic(id, embed, init, proxyManager, proxy.data);
                if (cache.m3u8 == null)
                    return StatusCode(502);

                var headers_stream = httpHeaders(init.host, init.headers_stream);
                if (headers_stream.Count == 0)
                    headers_stream = cache.headers;

                string hls = HostStreamProxy(init, cache.m3u8, proxy: proxy.proxy, headers: headers_stream);

                if (play)
                    return RedirectToPlay(hls);

                return ContentTo(VideoTpl.ToJson("play", hls, "English", vast: init.vast, headers: init.streamproxy ? null : headers_stream));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string m3u8, List<HeadersModel> headers)> black_magic(long id, string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"vidsrc:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out (string m3u8, List<HeadersModel> headers) cache))
                {
                    if (init.priorityBrowser == "scraping")
                    {
                        #region Scraping
                        using (var browser = new Scraping(uri, "\\.m3u8", null))
                        {
                            browser.OnRequest += e =>
                            {
                                if (Regex.IsMatch(e.HttpClient.Request.Url, "/api/[0-9]+/servers"))
                                {
                                    string vrf = Regex.Match(e.HttpClient.Request.Url, "&vrf=([^&]+)").Groups[1].Value;
                                    if (!string.IsNullOrEmpty(vrf) && e.HttpClient.Request.Url.Contains("&type=tv"))
                                        memoryCache.Set($"vidsrc:lastvrf:{id}", vrf, DateTime.Now.AddDays(1));
                                }
                                else if (Regex.IsMatch(e.HttpClient.Request.Url.Split("?")[0], "\\.(woff2?|vtt|srt|css|ico)$"))
                                    e.Ok(string.Empty);
                            };

                            var scrap = await browser.WaitPageResult(20);

                            if (scrap != null)
                            {
                                cache.m3u8 = scrap.Url;
                                cache.headers = new List<HeadersModel>();

                                foreach (var item in scrap.Headers)
                                {
                                    if (item.Name.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                        continue;

                                    cache.headers.Add(new HeadersModel(item.Name, item.Value));
                                }
                            }
                        }
                        #endregion
                    }
                    else
                    {
                        #region Playwright
                        using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                        {
                            var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy);
                            if (page == null)
                                return default;

                            await page.RouteAsync("**/*", async route =>
                            {
                                try
                                {
                                    if (browser.IsCompleted || Regex.IsMatch(route.Request.Url.Split("?")[0], "\\.(woff2?|vtt|srt|css|ico)$"))
                                    {
                                        PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (await PlaywrightBase.AbortOrCache(page, route, fullCacheJS: true))
                                        return;

                                    if (Regex.IsMatch(route.Request.Url, "/api/[0-9]+/servers"))
                                    {
                                        string vrf = Regex.Match(route.Request.Url, "&vrf=([^&]+)").Groups[1].Value;
                                        if (!string.IsNullOrEmpty(vrf) && route.Request.Url.Contains("&type=tv"))
                                            memoryCache.Set($"vidsrc:lastvrf:{id}", vrf, DateTime.Now.AddDays(1));
                                    }

                                    if (route.Request.Url.Contains(".m3u8"))
                                    {
                                        cache.headers = new List<HeadersModel>();
                                        foreach (var item in route.Request.Headers)
                                        {
                                            if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                                continue;

                                            cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                        }

                                        lastHeaders = cache.headers;

                                        PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                        browser.SetPageResult(route.Request.Url);
                                        await route.AbortAsync();
                                        return;
                                    }

                                    await route.ContinueAsync();
                                }
                                catch { }
                            });

                            PlaywrightBase.GotoAsync(page, uri);
                            cache.m3u8 = await browser.WaitPageResult(20);
                        }
                        #endregion
                    }

                    if (cache.m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/PlayEmbed.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class PlayEmbed : BaseENGController
    {
        [HttpGet]
        [Route("lite/playembed")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.Playembed, checksearch, id, tmdb_id,imdb_id, title, original_title, serial, s, rjson, method: "call");
        }


        #region Video
        [HttpGet]
        [Route("lite/playembed/video")]
        [Route("lite/playembed/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.Playembed);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/movie/{id}?colour=e1216d&autoplay=true&autonextepisode=false&pausescreen=true";
            if (s > 0)
                embed = $"{init.host}/tv/{id}/{s}/{e}?colour=e1216d&autoplay=true&autonextepisode=false&pausescreen=true";

            return await InvkSemaphore(init, embed, async () =>
            {
                var cache = await black_magic(embed, init, proxyManager, proxy.data);
                if (cache.m3u8 == null)
                    return StatusCode(502);

                var headers_stream = httpHeaders(init.host, init.headers_stream);
                if (headers_stream.Count == 0)
                    headers_stream = cache.headers;

                string hls = HostStreamProxy(init, cache.m3u8, proxy: proxy.proxy, headers: headers_stream);

                if (play)
                    return RedirectToPlay(hls);

                return ContentTo(VideoTpl.ToJson("play", hls, "English", vast: init.vast, headers: init.streamproxy ? null : headers_stream));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string m3u8, List<HeadersModel> headers)> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"playembed:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out (string m3u8, List<HeadersModel> headers) cache))
                {
                    using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                    {
                        var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy);
                        if (page == null)
                            return default;

                        await page.RouteAsync("**/*", async route =>
                        {
                            try
                            {
                                if (browser.IsCompleted || Regex.IsMatch(route.Request.Url, "(/ads/)"))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }

                                if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                    return;

                                if (route.Request.Url.Contains(".m3u8") || route.Request.Url.Contains("/playlist/"))
                                {
                                    cache.headers = HeadersModel.Init(
                                        ("sec-fetch-dest", "empty"),
                                        ("sec-fetch-mode", "cors"),
                                        ("sec-fetch-site", "cross-site")
                                    );

                                    foreach (var item in route.Request.Headers)
                                    {
                                        if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                            continue;

                                        if (cache.headers.FirstOrDefault(k => k.name == item.Key) == null)
                                            cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                    }

                                    PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                    browser.SetPageResult(route.Request.Url);
                                    await route.AbortAsync();
                                    return;
                                }

                                await route.ContinueAsync();
                            }
                            catch { }
                        });

                        PlaywrightBase.GotoAsync(page, uri);
                        cache.m3u8 = await browser.WaitPageResult(20);
                    }

                    if (cache.m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/Videasy.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.PlaywrightCore;
using Shared.Models.Online.Settings;

namespace Online.Controllers
{
    public class Videasy : BaseENGController
    {
        [HttpGet]
        [Route("lite/videasy")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.Videasy, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, method: "call");
        }


        #region Video
        [HttpGet]
        [Route("lite/videasy/video")]
        [Route("lite/videasy/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.Videasy);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (id == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/movie/{id}";
            if (s > 0)
                embed = $"{init.host}/tv/{id}/{s}/{e}";

            return await InvkSemaphore(init, embed, async () =>
            {
                var cache = await black_magic(embed, init, proxyManager, proxy.data);
                if (cache.m3u8 == null)
                    return StatusCode(502);

                var headers_stream = httpHeaders(init.host, init.headers_stream);
                if (headers_stream.Count == 0)
                    headers_stream = cache.headers;

                string hls = HostStreamProxy(init, cache.m3u8, proxy: proxy.proxy, headers: headers_stream);

                if (play)
                    return RedirectToPlay(hls);

                return ContentTo(VideoTpl.ToJson("play", hls, "English", vast: init.vast, headers: init.streamproxy ? null : headers_stream));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string m3u8, List<HeadersModel> headers)> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"videasy:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out (string m3u8, List<HeadersModel> headers) cache))
                {
                    using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                    {
                        var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy, deferredDispose: true);
                        if (page == null)
                            return default;

                        await page.RouteAsync("**/*", async route =>
                        {
                            try
                            {
                                if (browser.IsCompleted)
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }

                                if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true))
                                    return;

                                if (route.Request.Url.Contains(".m3u8") || route.Request.Url.Contains(".mp4") || route.Request.Url.Contains("/mp4/") || route.Request.Url.Contains("mp4."))
                                {
                                    cache.headers = new List<HeadersModel>();
                                    foreach (var item in route.Request.Headers)
                                    {
                                        if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                            continue;

                                        cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                    }

                                    PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                    browser.completionSource.SetResult(route.Request.Url);
                                    await route.AbortAsync();
                                    return;
                                }

                                await route.ContinueAsync();
                            }
                            catch { }
                        });

                        PlaywrightBase.GotoAsync(page, uri);

                        for (int i = 0; i < 10*5; i++) // 5 second
                        {
                            if (browser.IsCompleted)
                                break;

                            foreach (string playBtnSelector in new string[] { "div.flex.flex-col.items-center.gap-y-3.title-year > button" })
                            {
                                try
                                {
                                    var playBtn = await page.QuerySelectorAsync(playBtnSelector);
                                    if (playBtn != null)
                                        await playBtn.ClickAsync();
                                }
                                catch { }
                            }

                            await Task.Delay(100);
                        }

                        // await browser.WaitPageResult()
                        cache.m3u8 = await browser.completionSource.Task;
                    }

                    if (cache.m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/BaseENGController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;

namespace Online.Controllers
{
    public class BaseENGController : BaseOnlineController
    {
        async public ValueTask<ActionResult> ViewTmdb(OnlinesSettings _init, bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false, bool mp4 = false, string method = "play", int? hls_manifest_timeout = null, string extension = "m3u8")
        {
            if (checksearch)
                return Content("data-json=");

            var init = await loadKit(_init);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (tmdb_id > 0)
                id = tmdb_id;

            if (hls_manifest_timeout == null)
                hls_manifest_timeout = (int)TimeSpan.FromSeconds(20).TotalMilliseconds;

            if (serial == 1)
            {
                #region –°–µ—Ä–∏–∞–ª
                var tmdb = await InvokeCache<JToken>($"tmdb:seasons:{id}", cacheTime(40, init: init), async res =>
                {
                    var root = await Http.Get<JObject>($"{AppInit.conf.cub.scheme}://tmdb.{AppInit.conf.cub.mirror}/3/tv/{id}?api_key={AppInit.conf.tmdb.api_key}");

                    if (root == null || !root.ContainsKey("seasons"))
                        return res.Fail("seasons");

                    return root["seasons"];
                });

                if (!tmdb.IsSuccess)
                    return OnError(tmdb.ErrorMsg);

                if (s == -1)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    var tpl = new SeasonTpl();

                    foreach (var season in tmdb.Value)
                    {
                        int number = season.Value<int>("season_number");
                        if (1 > number)
                            continue;

                        string link = $"{host}/lite/{init.plugin.ToLower()}?id={id}&imdb_id={imdb_id}&serial=1&rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&s={number}";
                        tpl.Append($"{number} —Å–µ–∑–æ–Ω", link, number);
                    }

                    return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∏
                    var etpl = new EpisodeTpl();

                    foreach (var season in tmdb.Value)
                    {
                        if (season.Value<int>("season_number") != s)
                            continue;

                        for (int i = 1; i <= season.Value<int>("episode_count"); i++)
                        {
                            string path = (mp4 || method == "call") ? "video" : $"video.{extension}";
                            string uri = $"{host}/lite/{init.plugin.ToLower()}/{path}?id={id}&imdb_id={imdb_id}&s={s}&e={i}";
                            string stream = method == "call" ? accsArgs($"{host}/lite/{init.plugin.ToLower()}/{(mp4 ? "video" : $"video.{extension}")}?id={id}&imdb_id={imdb_id}&s={s}&e={i}&play=true") : null;

                            if (method == "play")
                                uri = accsArgs(uri);

                            etpl.Append($"{i} —Å–µ—Ä–∏—è", title ?? original_title, s.ToString(), i.ToString(), uri, method, streamlink: stream, vast: init.vast, hls_manifest_timeout: hls_manifest_timeout);
                        }
                    }

                    return ContentTo(rjson ? etpl.ToJson() : etpl.ToHtml());
                    #endregion
                }
                #endregion
            }
            else
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title);

                string path = (mp4 || method == "call") ? "video" : $"video.{extension}";
                string uri = $"{host}/lite/{init.plugin.ToLower()}/{path}?id={id}&imdb_id={imdb_id}";
                string stream = method == "call" ? accsArgs($"{host}/lite/{init.plugin.ToLower()}/{(mp4 ? "video" : $"video.{extension}")}?id={id}&imdb_id={imdb_id}&play=true") : null;

                if (method == "play")
                    uri = accsArgs(uri);

                mtpl.Append("English", uri, method, stream: stream, vast: init.vast, hls_manifest_timeout: hls_manifest_timeout);

                return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                #endregion
            }
        }
    }
}

```

## File: Online/Controllers/ENG/AutoEmbed.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class AutoEmbed : BaseENGController
    {
        [HttpGet]
        [Route("lite/autoembed")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            var init = AppInit.conf.Autoembed;
            return ViewTmdb(init, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, mp4: true, method: "call");
        }


        #region Video
        [HttpGet]
        [Route("lite/autoembed/video")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.Autoembed);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/embed/movie/{id}";
            if (s > 0)
                embed = $"{init.host}/embed/tv/{id}/{s}/{e}";

            return await InvkSemaphore(init, embed, async () =>
            {
                var cache = await black_magic(embed, init, proxyManager, proxy.data);
                if (cache.file == null)
                    return StatusCode(502);

                var headers_stream = httpHeaders(init.host, init.headers_stream);
                if (headers_stream.Count == 0)
                    headers_stream = cache.headers;

                string file = HostStreamProxy(init, cache.file, proxy: proxy.proxy, headers: headers_stream);

                if (play)
                    return RedirectToPlay(file);

                return ContentTo(VideoTpl.ToJson("play", file, "English", vast: init.vast, headers: init.streamproxy ? null : headers_stream));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string file, List<HeadersModel> headers)> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"autoembed:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out (string file, List<HeadersModel> headers) cache))
                {
                    using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                    {
                        var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy);
                        if (page == null)
                            return default;

                        await page.RouteAsync("**/*", async route =>
                        {
                            try
                            {
                                if (cache.file != null || await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                    return;

                                if ((Regex.IsMatch(route.Request.Url, "(hakunaymatata|kphimplayer)") && route.Request.Url.Contains(".mp4")) 
                                    || route.Request.Url.Contains("/embed-proxy?url=")
                                    || route.Request.Url.Contains(".m3u8"))
                                {
                                    cache.headers = HeadersModel.Init(
                                        ("sec-fetch-dest", "empty"),
                                        ("sec-fetch-mode", "cors"),
                                        ("sec-fetch-site", "cross-site"), 
                                        ("referer", $"{init.host}/"),
                                        ("origin", init.host)
                                    );

                                    foreach (var item in route.Request.Headers)
                                    {
                                        if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                            continue;

                                        if (cache.headers.FirstOrDefault(k => k.name == item.Key) == null)
                                            cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                    }

                                    PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                    browser.SetPageResult(route.Request.Url);
                                    await route.AbortAsync();
                                    return;
                                }

                                if (browser.IsCompleted || Regex.IsMatch(route.Request.Url, "(/ads/|vast.xml|ping.gif|silent.mp4)"))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }

                                await route.ContinueAsync();
                            }
                            catch { }
                        });

                        PlaywrightBase.GotoAsync(page, uri);
                        cache.file = await browser.WaitPageResult(20);
                    }

                    if (cache.file == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/MovPI.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Shared.PlaywrightCore;
using Shared.Models.Online.Settings;

namespace Online.Controllers
{
    public class MovPI : BaseENGController
    {
        [HttpGet]
        [Route("lite/movpi")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.MovPI, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, method: "call");
        }


        #region Video
        [HttpGet]
        [Route("lite/movpi/video")]
        [Route("lite/movpi/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.MovPI);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (id == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/movie/{id}?autoPlay=true&poster=false";
            if (s > 0)
                embed = $"{init.host}/tv/{id}-{s}-{e}?autoPlay=true&poster=false";

            return await InvkSemaphore(init, embed, async () =>
            {
                var cache = await black_magic(embed, init, proxyManager, proxy.data);
                if (cache.m3u8 == null)
                    return StatusCode(502);

                var headers_stream = httpHeaders(init.host, init.headers_stream);
                if (headers_stream.Count == 0)
                    headers_stream = cache.headers;

                string hls = HostStreamProxy(init, cache.m3u8, proxy: proxy.proxy, headers: headers_stream);

                if (play)
                    return RedirectToPlay(hls);

                return ContentTo(VideoTpl.ToJson("play", hls, "English", vast: init.vast, headers: init.streamproxy ? null : headers_stream));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string m3u8, List<HeadersModel> headers)> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"movpi:black_magic:{uri}:{proxy.ip}";
                if (!hybridCache.TryGetValue(memKey, out (string m3u8, List<HeadersModel> headers) cache))
                {
                    if (init.priorityBrowser == "scraping")
                    {
                        #region Scraping
                        using (var browser = new Scraping(uri, "\\.m3u8", null))
                        {
                            browser.OnRequest += e =>
                            {
                                if (uri == e.HttpClient.Request.Url)
                                    e.HttpClient.Request.Headers.AddHeader("Referer", CrypTo.DecodeBase64("aHR0cHM6Ly93d3cuaHlkcmFmbGl4LnZpcC8="));
                            };

                            var scrap = await browser.WaitPageResult(20);

                            if (scrap != null)
                            {
                                cache.m3u8 = scrap.Url;
                                cache.headers = new List<HeadersModel>();

                                foreach (var item in scrap.Headers)
                                {
                                    if (item.Name.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                        continue;

                                    cache.headers.Add(new HeadersModel(item.Name, item.Value));
                                }
                            }
                        }
                        #endregion
                    }
                    else
                    {
                        #region Playwright
                        using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                        {
                            var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy);
                            if (page == null)
                                return default;

                            await page.RouteAsync("**/*", async route =>
                            {
                                try
                                {
                                    if (route.Request.Url.Contains("api/chromium/iframe"))
                                    {
                                        await route.ContinueAsync();
                                        return;
                                    }

                                    if (browser.IsCompleted)
                                    {
                                        PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                        return;

                                    if (route.Request.Url == uri)
                                    {
                                        await route.ContinueAsync(new RouteContinueOptions
                                        {
                                            Headers = httpHeaders(init, HeadersModel.Init(("referer", CrypTo.DecodeBase64("aHR0cHM6Ly93d3cuaHlkcmFmbGl4LnZpcC8=")))).ToDictionary()
                                        });
                                        return;
                                    }

                                    if (route.Request.Url.Contains(".m3u8"))
                                    {
                                        cache.headers = new List<HeadersModel>();
                                        foreach (var item in route.Request.Headers)
                                        {
                                            if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                                continue;

                                            cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                        }

                                        PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                        browser.SetPageResult(route.Request.Url);
                                        await route.AbortAsync();
                                        return;
                                    }

                                    await route.ContinueAsync();
                                }
                                catch { }
                            });

                            PlaywrightBase.GotoAsync(page, PlaywrightBase.IframeUrl(uri));

                            cache.m3u8 = await browser.WaitPageResult(20);
                        }
                        #endregion
                    }

                    if (cache.m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/VidLink.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class VidLink : BaseENGController
    {
        [HttpGet]
        [Route("lite/vidlink")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.VidLink, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, mp4: true, method: "call");
        }


        #region Video
        [HttpGet]
        [Route("lite/vidlink/video")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.VidLink);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (id == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/movie/{id}";
            if (s > 0)
                embed = $"{init.host}/tv/{id}/{s}/{e}";

            return await InvkSemaphore(init, embed, async () =>
            {
                var cache = await black_magic(embed, init, proxyManager, proxy.data);
                if (cache.m3u8 == null)
                    return StatusCode(502);

                var headers_stream = httpHeaders(init.host, init.headers_stream);
                if (headers_stream.Count == 0)
                    headers_stream = cache.headers;

                string file = HostStreamProxy(init, cache.m3u8, proxy: proxy.proxy, headers: headers_stream);

                if (play)
                    return RedirectToPlay(file);

                return ContentTo(VideoTpl.ToJson("play", file, "English", vast: init.vast, headers: init.streamproxy ? null : headers_stream));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string m3u8, List<HeadersModel> headers)> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"vidlink:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out (string m3u8, List<HeadersModel> headers) cache))
                {
                    if (init.priorityBrowser == "scraping")
                    {
                        #region Scraping
                        using (var browser = new Scraping(uri, "\\.(m3u|mp4)", null))
                        {
                            browser.OnRequest += e =>
                            {
                                if (Regex.IsMatch(e.HttpClient.Request.Url, "(adsco|pubtrky|clarity)\\."))
                                    e.Ok(string.Empty);
                            };

                            var scrap = await browser.WaitPageResult(20);

                            if (scrap != null)
                            {
                                cache.m3u8 = scrap.Url;
                                cache.headers = new List<HeadersModel>();

                                foreach (var item in scrap.Headers)
                                {
                                    if (item.Name.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                        continue;

                                    cache.headers.Add(new HeadersModel(item.Name, item.Value));
                                }
                            }
                        }
                        #endregion
                    }
                    else
                    {
                        #region Playwright
                        using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                        {
                            var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy);
                            if (page == null)
                                return default;

                            await page.RouteAsync("**/*", async route =>
                            {
                                try
                                {
                                    if (browser.IsCompleted)
                                    {
                                        PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true, patterCache: "/api/(mercury|venus)$"))
                                        return;

                                    if (route.Request.Url.Contains("adsco.") || route.Request.Url.Contains("pubtrky.") || route.Request.Url.Contains("clarity."))
                                    {
                                        PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (route.Request.Url.Contains(".m3u") || route.Request.Url.Contains(".mp4"))
                                    {
                                        cache.headers = new List<HeadersModel>();
                                        foreach (var item in route.Request.Headers)
                                        {
                                            if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                                continue;

                                            cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                        }

                                        PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                        browser.SetPageResult(route.Request.Url);
                                        await route.AbortAsync();
                                        return;
                                    }

                                    await route.ContinueAsync();
                                }
                                catch { }
                            });

                            PlaywrightBase.GotoAsync(page, uri);
                            cache.m3u8 = await browser.WaitPageResult(20);
                        }
                        #endregion
                    }

                    if (cache.m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/HydraFlix.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class HydraFlix : BaseENGController
    {
        [HttpGet]
        [Route("lite/hydraflix")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.Hydraflix, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, method: "call", extension: "m3u8");
        }


        #region Video
        [HttpGet]
        [Route("lite/hydraflix/video")]
        [Route("lite/hydraflix/video.mpd")]
        [Route("lite/hydraflix/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.Hydraflix);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (id == 0)
                return OnError();

            if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/movie/{id}?autoPlay=true&theme=e1216d";
            if (s > 0)
                embed = $"{init.host}/tv/{id}/{s}/{e}?autoPlay=true&theme=e1216d";

            return await InvkSemaphore(init, embed, async () =>
            {
                var cache = await black_magic(embed, init, proxyManager, proxy.data);
                if (cache.m3u8 == null)
                    return StatusCode(502);

                var headers_stream = httpHeaders(init.host, init.headers_stream);
                if (headers_stream.Count == 0)
                    headers_stream = cache.headers;

                string file = HostStreamProxy(init, cache.m3u8, proxy: proxy.proxy, headers: headers_stream);

                if (play)
                    return RedirectToPlay(file);

                return ContentTo(VideoTpl.ToJson("play", file, "English", vast: init.vast, headers: init.streamproxy ? null : headers_stream));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string m3u8, List<HeadersModel> headers)> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"Hydraflix:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out (string m3u8, List<HeadersModel> headers) cache))
                {
                    if (init.priorityBrowser == "scraping")
                    {
                        #region Scraping
                        using (var browser = new Scraping(uri, "\\.(mpd|m3u|mp4)", null))
                        {
                            //browser.OnRequest += e =>
                            //{
                            //    if (Regex.IsMatch(e.HttpClient.Request.Url, "\\.(css|woff2|jpe?g|png|ico)"))
                            //        e.Ok(string.Empty);
                            //};

                            var scrap = await browser.WaitPageResult(20);

                            if (scrap != null)
                            {
                                cache.m3u8 = scrap.Url;
                                cache.headers = new List<HeadersModel>();

                                foreach (var item in scrap.Headers)
                                {
                                    if (item.Name.ToLower() is "host" or "accept-encoding" or "connection" or "range" or "cookie")
                                        continue;

                                    cache.headers.Add(new HeadersModel(item.Name, item.Value));
                                }
                            }
                        }
                        #endregion
                    }
                    else
                    {
                        #region Playwright
                        using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                        {
                            var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy);
                            if (page == null)
                                return default;

                            await page.RouteAsync("**/*", async route =>
                            {
                                try
                                {
                                    if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                        return;

                                    if (browser.IsCompleted || route.Request.Url.Contains("adsco."))
                                    {
                                        PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (Regex.IsMatch(route.Request.Url, "\\.(mpd|m3u|mp4)"))
                                    {
                                        cache.headers = new List<HeadersModel>();
                                        foreach (var item in route.Request.Headers)
                                        {
                                            if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                                continue;

                                            cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                        }

                                        PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                        browser.SetPageResult(route.Request.Url);
                                        await route.AbortAsync();
                                        return;
                                    }

                                    await route.ContinueAsync();
                                }
                                catch { }
                            });

                            PlaywrightBase.GotoAsync(page, uri);
                            cache.m3u8 = await browser.WaitPageResult(20);
                        }
                        #endregion
                    }

                    if (cache.m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch 
            { 
                return default; 
            }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/SmashyStream.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class SmashyStream : BaseENGController
    {
        [HttpGet]
        [Route("lite/smashystream")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.Smashystream, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, hls_manifest_timeout: (int)TimeSpan.FromSeconds(35).TotalMilliseconds);
        }


        #region Video
        [HttpGet]
        [Route("lite/smashystream/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1)
        {
            var init = await loadKit(AppInit.conf.Smashystream);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (id == 0)
                return OnError();

            if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/movie/{id}";
            if (s > 0)
                embed = $"{init.host}/tv/{id}?s={s}&e={e}";

            return await InvkSemaphore(init, embed, async () =>
            {
                var cache = await black_magic(embed, init, proxyManager, proxy.data);
                if (cache.m3u8 == null)
                    return StatusCode(502);

                return Redirect(HostStreamProxy(init, cache.m3u8, proxy: proxy.proxy, headers: cache.headers));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string m3u8, List<HeadersModel> headers)> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"smashystream:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out (string m3u8, List<HeadersModel> headers) cache))
                {
                    DateTime routeActiveTime = default;

                    using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                    {
                        var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy, deferredDispose: true).ConfigureAwait(false);
                        if (page == null)
                            return default;

                        await page.RouteAsync("**/*", async route =>
                        {
                            try
                            {
                                routeActiveTime = DateTime.Now;

                                if (browser.IsCompleted || route.Request.Url.Contains(".m3u") || Regex.IsMatch(route.Request.Url, "(\\.vtt|histats.com|solid.gif|poster.png|doubleclick\\.|inkblotconusor\\.|jrbbavbvqmrjw\\.)"))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }

                                if (await PlaywrightBase.AbortOrCache(page, route, fullCacheJS: true))
                                    return;

                                if (route.Request.Url.Contains("master.txt"))
                                {
                                    cache.headers = new List<HeadersModel>();
                                    foreach (var item in route.Request.Headers)
                                    {
                                        if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                            continue;

                                        cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                    }

                                    PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                    browser.SetPageResult(route.Request.Url);
                                    cache.m3u8 = route.Request.Url;
                                    await route.AbortAsync();
                                    return;
                                }

                                await route.ContinueAsync();
                            }
                            catch { }
                        });

                        await page.GotoAsync(uri, new PageGotoOptions() 
                        {
                            Timeout = 15_000,
                            WaitUntil = WaitUntilState.DOMContentLoaded 
                        }).ConfigureAwait(false);

                        var frameElement = await page.WaitForSelectorAsync("iframe[src*='smashyplayer.top']", new PageWaitForSelectorOptions 
                        { 
                            Timeout = 15_000, 
                            State = WaitForSelectorState.Visible 
                        }).ConfigureAwait(false);

                        var frame = await frameElement.ContentFrameAsync().ConfigureAwait(false);

                        // –Ω–µ–≤—å–µ–±–µ–Ω–Ω–∞—è –º–∞–≥–∏—è –æ–±—Ö–æ–¥–∞ –∑–∞—â–∏—Ç—ã =)
                        await Task.Delay(1000).ConfigureAwait(false);
                        while (routeActiveTime.AddSeconds(1) > DateTime.Now)
                            await Task.Delay(100).ConfigureAwait(false);

                        await frame.WaitForSelectorAsync("#player-button", new FrameWaitForSelectorOptions() { Timeout = 10_000 }).ConfigureAwait(false);

                        var endTime = DateTime.Now.AddSeconds(5);
                        while (endTime > DateTime.Now && cache.m3u8 == null)
                        {
                            try
                            {
                                await frame.ClickAsync("#player-button", new FrameClickOptions
                                {
                                    Timeout = 400,
                                    Force = true
                                }).ConfigureAwait(false);

                                await Task.Delay(200).ConfigureAwait(false);
                            }
                            catch { }
                        }
                    }

                    if (cache.m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/RgShows.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;
using System.Net;

namespace Online.Controllers
{
    public class RgShows : BaseENGController
    {
        [HttpGet]
        [Route("lite/rgshows")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.Rgshows, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, mp4: true, method: "call", hls_manifest_timeout: (int)TimeSpan.FromSeconds(30).TotalMilliseconds);
        }


        #region Video
        [HttpGet]
        [Route("lite/rgshows/video")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.Rgshows);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/main/movie/{id}";
            if (s > 0)
                embed = $"{init.host}/main/tv/{id}/{s}/{e}";

            return await InvkSemaphore(init, embed, async () =>
            {
                string file = await magic(embed, init, proxyManager, proxy.proxy);
                if (file == null)
                    return StatusCode(502);

                file = HostStreamProxy(init, file, proxy: proxy.proxy);

                if (play)
                    return RedirectToPlay(file);

                return ContentTo(VideoTpl.ToJson("play", file, "English", vast: init.vast, headers: init.streamproxy ? null : httpHeaders(init.host, init.headers_stream), hls_manifest_timeout: (int)TimeSpan.FromSeconds(30).TotalMilliseconds));
            });
        }
        #endregion

        #region magic
        async ValueTask<string> magic(string uri, OnlinesSettings init, ProxyManager proxyManager, WebProxy proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return uri;

            try
            {
                string memKey = $"rgshows:{uri}";
                if (!hybridCache.TryGetValue(memKey, out string file))
                {
                    var root = await Http.Get<JObject>(uri, timeoutSeconds: 40, httpversion: 2, headers: httpHeaders(init));
                    if (root == null || !root.ContainsKey("stream"))
                    {
                        proxyManager.Refresh();
                        return null;
                    }

                    file = root["stream"].Value<string>("url");
                    if (string.IsNullOrEmpty(file))
                        return null;

                    proxyManager.Success();
                    hybridCache.Set(memKey, file, cacheTime(20, init: init));
                }

                return file;
            }
            catch { return null; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/TwoEmbed.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class TwoEmbed : BaseENGController
    {
        [HttpGet]
        [Route("lite/twoembed")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.Twoembed, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, method: "call");
        }


        #region Video
        [HttpGet]
        [Route("lite/twoembed/video")]
        [Route("lite/twoembed/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.Twoembed);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (Firefox.Status == PlaywrightStatus.disabled)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/embed/movie/{id}";
            if (s > 0)
                embed = $"{init.host}/embed/tv/{id}/{s}/{e}";

            return await InvkSemaphore(init, embed, async () =>
            {
                var hls = await black_magic(embed, init, proxyManager, proxy.data);
                if (hls == null)
                    return StatusCode(502);

                hls = HostStreamProxy(init, hls, proxy: proxy.proxy);

                if (play)
                    return RedirectToPlay(hls);

                return ContentTo(VideoTpl.ToJson("play", hls, "English", vast: init.vast, headers: init.streamproxy ? null : httpHeaders(init.host, init.headers_stream)));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<string> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"twoembed:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out string m3u8))
                {
                    using (var browser = new Firefox())
                    {
                        var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy);
                        if (page == null)
                            return default;

                        await page.RouteAsync("**/*", async route =>
                        {
                            try
                            {
                                if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                    return;

                                if (browser.IsCompleted || Regex.IsMatch(route.Request.Url, "(fonts.googleapis|pixel.embed|rtmark)\\."))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }

                                if (route.Request.Url.Contains(".m3u8"))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}");
                                    browser.IsCompleted = true;
                                    browser.completionSource.SetResult(route.Request.Url);
                                    await route.AbortAsync();
                                    return;
                                }

                                await route.ContinueAsync();
                            }
                            catch { }
                        });

                        PlaywrightBase.GotoAsync(page, uri);
                        m3u8 = await browser.WaitPageResult(20);
                    }

                    if (m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, m3u8, cacheTime(20, init: init));
                }

                return m3u8;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/UKR/Kinoukr.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Eneyida;

namespace Online.Controllers
{
    public class Kinoukr : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/kinoukr")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int clarification, int year, string t, int s = -1, string href = null, bool origsource = false, bool rjson = false, string source = null, string id = null)
        {
            var init = await loadKit(AppInit.conf.Kinoukr);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var oninvk = new KinoukrInvoke
            (
               host,
               init.corsHost(),
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl), httpHeaders(init)) : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               (url, data) => rch.enable ? rch.Post(init.cors(url), data, httpHeaders(init)) : Http.Post(init.cors(url), data, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               onstreamtofile => HostStreamProxy(init, onstreamtofile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
               //onlog: (l) => { Console.WriteLine(l); return string.Empty; }
            );

            if (string.IsNullOrEmpty(href) && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() == "kinoukr")
                    href = await InvokeCache($"kinoukr:source:{id}", cacheTime(180, init: init), () => oninvk.getIframeSource($"{init.host}/{id}"));
            }

            reset:
            var cache = await InvokeCache<EmbedModel>($"kinoukr:view:{title}:{original_title}:{year}:{href}:{clarification}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.EmbedKurwa(clarification, title, original_title, year, href);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, clarification, title, original_title, year, t, s, href, vast: init.vast, rjson: rjson), origsource: origsource, gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/UKR/Ashdi.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Ashdi;

namespace Online.Controllers
{
    public class Ashdi : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/ashdi")]
        async public ValueTask<ActionResult> Index(long kinopoisk_id, string title, string original_title, int t = -1, int s = -1, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.Ashdi);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (kinopoisk_id == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var oninvk = new AshdiInvoke
            (
               host,
               init.corsHost(),
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl), httpHeaders(init)) : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init), statusCodeOK: false),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            reset:
            var cache = await InvokeCache<EmbedModel>($"ashdi:view:{kinopoisk_id}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(kinopoisk_id);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, kinopoisk_id, title, original_title, t, s, vast: init.vast, rjson: rjson), origsource: origsource, gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/UKR/Eneyida.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Eneyida;

namespace Online.Controllers
{
    public class Eneyida : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/eneyida")]
        async public Task<ActionResult> Index(string title, string original_title, int clarification, int year, int t = -1, int s = -1, string href = null, bool rjson = false, bool similar = false, string source = null, string id = null)
        {
            var init = await loadKit(AppInit.conf.Eneyida);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(href) && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() == "eneyida")
                    href = $"{init.host}/{id}";
            }

            if (string.IsNullOrWhiteSpace(href) && (string.IsNullOrWhiteSpace(original_title) || year == 0))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            var oninvk = new EneyidaInvoke
            (
               host,
               init.corsHost(),
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl)) : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               (url, data) => rch.enable ? rch.Post(init.cors(url), data) : Http.Post(init.cors(url), data, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               onstreamtofile => HostStreamProxy(init, onstreamtofile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            reset:
            var cache = await InvokeCache<EmbedModel>($"eneyida:view:{title}:{year}:{href}:{clarification}:{similar}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed((similar || clarification == 1) ? title : original_title, year, href, similar);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, clarification, title, original_title, year, t, s, href, vast: init.vast, rjson: rjson), gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/Anime/AniMedia.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace Online.Controllers
{
    public class AniMedia : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.AniMedia);

        [HttpGet]
        [Route("lite/animedia")]
        async public ValueTask<ActionResult> Index(string title, string news, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.AniMedia);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (string.IsNullOrEmpty(news))
            {
                if (string.IsNullOrEmpty(title))
                    return OnError();

                #region –ü–æ–∏—Å–∫
                string memkey = $"animedia:search:{title}:{similar}";

                return await InvkSemaphore(init, memkey, async () =>
                {
                    if (!hybridCache.TryGetValue(memkey, out List<(string title, string url, string img)> catalog, inmemory: false))
                    {
                        string search = await Http.Post($"{init.corsHost()}/index.php?do=search", $"do=search&subaction=search&from_page=0&story={HttpUtility.UrlEncode(title)}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                        if (search == null)
                            return OnError(proxyManager);

                        var rows = search.Split("</article>")[1].Split("grid-item d-flex fd-column");

                        catalog = new List<(string title, string url, string img)>(rows.Length);

                        foreach (string row in rows.Skip(1))
                        {
                            var g = Regex.Match(row, "<a href=\"https?://[^/]+/([^\"]+)\" class=\"poster__link\"><h3 class=\"poster__title line-clamp\">([^<]+)</h3></a>").Groups;

                            if (!string.IsNullOrEmpty(g[1].Value) && !string.IsNullOrEmpty(g[2].Value))
                            {
                                string img = Regex.Match(row, "<img src=\"([^\"]+)\"").Groups[1].Value;
                                if (!string.IsNullOrEmpty(img))
                                    img = init.host + img;

                                if (similar || StringConvert.SearchName(g[2].Value).Contains(StringConvert.SearchName(title)))
                                    catalog.Add((g[2].Value, g[1].Value, img));
                            }
                        }

                        if (catalog.Count == 0 && !search.Contains("id=\"dosearch\""))
                            return OnError();

                        proxyManager.Success();
                        hybridCache.Set(memkey, catalog, cacheTime(40, init: init), inmemory: false);
                    }

                    if (catalog.Count == 0)
                        return OnError();

                    if (!similar && catalog.Count == 1)
                        return LocalRedirect(accsArgs($"/lite/animedia?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&news={HttpUtility.UrlEncode(catalog[0].url)}"));

                    var stpl = new SimilarTpl(catalog.Count);

                    foreach (var res in catalog)
                    {
                        string uri = $"{host}/lite/animedia?title={HttpUtility.UrlEncode(title)}&news={HttpUtility.UrlEncode(res.url)}";
                        stpl.Append(res.title, string.Empty, string.Empty, uri, PosterApi.Size(res.img));
                    }

                    return ContentTo(rjson ? stpl.ToJson() : stpl.ToHtml());
                });
                #endregion
            }
            else 
            {
                #region –°–µ—Ä–∏–∏
                string memKey = $"animedia:{news}";

                return await InvkSemaphore(init, memKey, async () =>
                {
                    if (!hybridCache.TryGetValue(memKey, out List<(int episode, string s, string vod)> links, inmemory: false))
                    {
                        string html = await Http.Get($"{init.corsHost()}/{news}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                        if (html == null)
                            return OnError(proxyManager);

                        var match = Regex.Match(html, "data-vid=\"([0-9]+)\"[\t ]+data-vlnk=\"([^\"]+)\"");
                        links = new List<(int episode, string s, string vod)>(match.Length);

                        string pmovie = Regex.Match(html, "class=\"pmovie__main-info ws-nowrap\">([^<]+)<").Groups[1].Value;
                        string s = Regex.Match(pmovie, "Season[\t ]+([0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value;
                        if (string.IsNullOrEmpty(s))
                            s = "1";

                        while (match.Success)
                        {
                            string vod = match.Groups[2].Value;
                            if (!string.IsNullOrEmpty(match.Groups[1].Value) && !string.IsNullOrEmpty(vod) && vod.Contains("/vod/"))
                            {
                                if (int.TryParse(match.Groups[1].Value, out int episode) && episode > 0)
                                {
                                    if (links.FirstOrDefault(i => i.episode == episode).vod == null)
                                        links.Add((episode, s, vod));
                                }
                            }

                            match = match.NextMatch();
                        }

                        if (links.Count == 0)
                            return OnError();

                        proxyManager.Success();
                        hybridCache.Set(memKey, links, cacheTime(30, init: init), inmemory: false);
                    }

                    var etpl = new EpisodeTpl(links.Count);

                    foreach (var l in links.OrderBy(i => i.episode))
                        etpl.Append($"{l.episode} —Å–µ—Ä–∏—è", title, l.s, l.episode.ToString(), accsArgs($"{host}/lite/animedia/video.m3u8?vod={HttpUtility.UrlEncode(l.vod)}"), vast: init.vast);

                    return ContentTo(rjson ? etpl.ToJson() : etpl.ToHtml());
                });
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/animedia/video.m3u8")]
        async public ValueTask<ActionResult> Video(string vod)
        {
            var init = await loadKit(AppInit.conf.AniMedia);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            string memKey = $"animedia:{vod}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out string hls))
                {
                    string embed = await Http.Get(vod, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));

                    if (string.IsNullOrEmpty(embed))
                        return OnError(proxyManager);

                    hls = Regex.Match(embed, "file:\"([^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(hls))
                        return OnError(proxyManager);

                    proxyManager.Success();
                    hybridCache.Set(memKey, hls, cacheTime(180, init: init));
                }

                return Redirect(HostStreamProxy(init, hls, proxy: proxyManager.Get()));
            });
        }
        #endregion
    }
}

```

## File: Online/Controllers/Anime/MoonAnime.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;

namespace Online.Controllers
{
    public class MoonAnime : BaseOnlineController
    {
        static MoonAnime() {
            Directory.CreateDirectory("cache/logs/MoonAnime");
        }

        ProxyManager proxyManager = new ProxyManager(AppInit.conf.MoonAnime);

        [HttpGet]
        [Route("lite/moonanime")]
        async public ValueTask<ActionResult> Index(string imdb_id, string title, string original_title, long animeid, string t, int s = -1, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.MoonAnime);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (animeid == 0)
            {
                #region –ü–æ–∏—Å–∫
                string memkey = $"moonanime:search:{imdb_id}:{title}:{original_title}";

                return await InvkSemaphore(init, memkey, async () =>
                {
                    if (!hybridCache.TryGetValue(memkey, out List<(string title, string year, long id, string poster)> catalog, inmemory: false))
                    {
                        async Task<JObject> goSearch(string arg)
                        {
                            if (string.IsNullOrEmpty(arg.Split("=")?[1]))
                                return null;

                            var search = await Http.Get<JObject>($"{init.corsHost()}/api/2.0/titles?api_key={init.token}&limit=20" + arg, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                            if (search == null || !search.ContainsKey("anime_list"))
                                return null;

                            if (search["anime_list"].Count() == 0)
                                return null;

                            return search;
                        }

                        JObject search = await goSearch($"&imdbid={imdb_id}") ?? await goSearch($"&japanese_title={HttpUtility.UrlEncode(original_title)}") ?? await goSearch($"&title={HttpUtility.UrlEncode(title)}");
                        if (search == null)
                            return OnError(proxyManager);

                        catalog = new List<(string title, string year, long id, string poster)>();

                        foreach (var anime in search["anime_list"])
                        {
                            string _titl = anime.Value<string>("title");
                            int year = anime.Value<int>("year");

                            if (string.IsNullOrEmpty(_titl))
                                continue;

                            catalog.Add((_titl, year.ToString(), anime.Value<long>("id"), anime.Value<string>("poster")));
                        }

                        if (catalog.Count == 0)
                            return OnError();

                        proxyManager.Success();
                        hybridCache.Set(memkey, catalog, cacheTime(40, init: init), inmemory: false);
                    }

                    if (!similar && catalog.Count == 1)
                        return LocalRedirect(accsArgs($"/lite/moonanime?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&animeid={catalog[0].id}"));

                    var stpl = new SimilarTpl(catalog.Count);

                    foreach (var res in catalog)
                    {
                        string uri = $"{host}/lite/moonanime?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&animeid={res.id}";
                        stpl.Append(res.title, res.year, string.Empty, uri, PosterApi.Size(res.poster));
                    }

                    return ContentTo(rjson ? stpl.ToJson() : stpl.ToHtml());
                });
                #endregion
            }
            else 
            {
                #region –°–µ—Ä–∏–∏
                string memKey = $"moonanime:playlist:{animeid}";

                return await InvkSemaphore(init, memKey, async () =>
                {
                    if (!hybridCache.TryGetValue(memKey, out JArray root))
                    {
                        root = await Http.Get<JArray>($"{init.corsHost()}/api/2.0/title/{animeid}/videos?api_key={init.token}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                        if (root == null)
                            return OnError(proxyManager);

                        proxyManager.Success();
                        hybridCache.Set(memKey, root, cacheTime(30, init: init));
                    }

                    if (s == -1)
                    {
                        var tpl = new SeasonTpl();
                        var temp = new HashSet<string>();

                        foreach (var voices in root)
                        {
                            foreach (var voice in voices.ToObject<Dictionary<string, Dictionary<string, JArray>>>())
                            {
                                foreach (var season in voice.Value)
                                {
                                    if (temp.Contains(season.Key))
                                        continue;

                                    temp.Add(season.Key);

                                    tpl.Append($"{season.Key} —Å–µ–∑–æ–Ω", $"{host}/lite/moonanime?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&animeid={animeid}&s={season.Key}", season.Key);
                                }
                            }
                        }

                        return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();
                        string activTranslate = t;

                        foreach (var voices in root)
                        {
                            foreach (var voice in voices.ToObject<Dictionary<string, Dictionary<string, JArray>>>())
                            {
                                foreach (var season in voice.Value)
                                {
                                    if (season.Key != s.ToString())
                                        continue;

                                    if (string.IsNullOrEmpty(activTranslate))
                                        activTranslate = voice.Key;

                                    vtpl.Append(voice.Key, activTranslate == voice.Key, $"{host}/lite/moonanime?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&animeid={animeid}&s={s}&t={HttpUtility.UrlEncode(voice.Key)}");
                                }
                            }
                        }
                        #endregion

                        var etpl = new EpisodeTpl();
                        string sArhc = s.ToString();

                        foreach (var voices in root)
                        {
                            foreach (var voice in voices.ToObject<Dictionary<string, Dictionary<string, JArray>>>())
                            {
                                if (voice.Key != activTranslate)
                                    continue;

                                foreach (var season in voice.Value)
                                {
                                    if (season.Key != sArhc)
                                        continue;

                                    foreach (var folder in season.Value)
                                    {
                                        int episode = folder.Value<int>("episode");
                                        string vod = folder.Value<string>("vod");

                                        string link = $"{host}/lite/moonanime/video?vod={HttpUtility.UrlEncode(vod)}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}";
                                        string streamlink = accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true");

                                        etpl.Append($"{episode} —Å–µ—Ä–∏—è", title, sArhc, episode.ToString(), link, "call", streamlink: streamlink);
                                    }
                                }
                            }
                        }

                        if (rjson)
                            return ContentTo(etpl.ToJson(vtpl));

                        return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                    }
                });
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/moonanime/video")]
        [Route("lite/moonanime/video.m3u8")]
        async public ValueTask<ActionResult> Video(string vod, bool play, string title, string original_title)
        {
            var init = await loadKit(AppInit.conf.MoonAnime);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string memKey = $"moonanime:vod:{vod}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out (string file, string subtitle) cache))
                {
                    string iframe = await Http.Get(vod + "?partner=lampa", timeoutSeconds: 10, httpversion: 2, proxy: proxyManager.Get(), headers: httpHeaders(init, HeadersModel.Init(
                        ("cache-control", "no-cache"),
                        ("dnt", "1"),
                        ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                        ("pragma", "no-cache"),
                        ("priority", "u=0, i"),
                        ("sec-ch-ua", "\"Chromium\";v=\"130\", \"Microsoft Edge\";v=\"130\", \"Not?A_Brand\";v=\"99\""),
                        ("sec-ch-ua-mobile", "?0"),
                        ("sec-ch-ua-platform", "\"Windows\""),
                        ("sec-fetch-dest", "document"),
                        ("sec-fetch-mode", "navigate"),
                        ("sec-fetch-site", "none"),
                        ("sec-fetch-user", "?1"),
                        ("upgrade-insecure-requests", "1"),
                        ("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0")
                    )));

                    if (iframe == null)
                        return OnError(proxyManager);

                    cache.file = Regex.Match(iframe, "file: ?\"([^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(cache.file))
                        return OnError();

                    #region stats
                    _ = await Http.Post("https://moonanime.art/api/stats/", $"{{\"domain\":\"{CrypTo.DecodeBase64("bGFtcGEubXg=")}\",\"player\":\"{vod}?partner=lampa\",\"play\":1}}", timeoutSeconds: 4, httpversion: 2, removeContentType: true, proxy: proxyManager.Get(), headers: HeadersModel.Init(
                        ("accept", "*/*"),
                        ("cache-control", "no-cache"),
                        ("dnt", "1"),
                        ("origin", CrypTo.DecodeBase64("aHR0cDovL2xhbXBhLm14")),
                        ("pragma", "no-cache"),
                        ("priority", "u=1, i"),
                        ("referer", vod),
                        ("sec-ch-ua", "\"Google Chrome\";v=\"131\", \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\""),
                        ("sec-ch-ua-mobile", "?0"),
                        ("sec-ch-ua-platform", "\"Windows\""),
                        ("sec-fetch-dest", "empty"),
                        ("sec-fetch-mode", "cors"),
                        ("sec-fetch-site", "same-origin"),
                        ("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36")
                    ));

                    try
                    {
                        System.IO.File.AppendAllText($"cache/logs/MoonAnime/{DateTime.Today.ToString("MM-yyyy")}.txt", $"{DateTime.Now.ToString("dd / HH:mm")} - {requestInfo.IP} / {vod}\n");
                    }
                    catch { }
                    #endregion

                    cache.subtitle = Regex.Match(iframe, "subtitle: ?\"([^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(cache.subtitle) || cache.subtitle == "null")
                        cache.subtitle = Regex.Match(iframe, "thumbnails: ?\"([^\"]+)\"").Groups[1].Value;

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(30, init: init));
                }

                var subtitles = new SubtitleTpl();
                if (!string.IsNullOrEmpty(cache.subtitle))
                    subtitles.Append("–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é", cache.subtitle);

                string file = HostStreamProxy(init, cache.file, proxy: proxyManager.Get(), headers: HeadersModel.Init(
                    ("accept", "*/*"),
                    ("accept-language", "ru,en;q=0.9,en-GB;q=0.8,en-US;q=0.7"),
                    ("dnt", "1"),
                    ("origin", CrypTo.DecodeBase64("aHR0cDovL2xhbXBhLm14")),
                    ("priority", "u=1, i"),
                    ("sec-ch-ua", "\"Chromium\";v=\"130\", \"Microsoft Edge\";v=\"130\", \"Not?A_Brand\";v=\"99\""),
                    ("sec-ch-ua-mobile", "?0"),
                    ("sec-ch-ua-platform", "\"Windows\""),
                    ("sec-fetch-dest", "empty"),
                    ("sec-fetch-mode", "cors"),
                    ("sec-fetch-site", "cross-site"),
                    ("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0")
                ));


                if (play)
                    return RedirectToPlay(file);

                return ContentTo(VideoTpl.ToJson("play", file, (title ?? original_title), subtitles: subtitles, vast: init.vast));
            });
        }
        #endregion
    }
}

```

## File: Online/Controllers/Anime/AnimeLib.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.AnimeLib;
using Shared.Models.Online.Settings;
using System.Net.Http;
using System.Text;
using System.Threading;

namespace Online.Controllers
{
    public class AnimeLib : BaseOnlineController
    {
        static readonly SemaphoreSlim TokenSemaphore = new SemaphoreSlim(1, 1);

        ProxyManager proxyManager = new ProxyManager(AppInit.conf.AnimeLib);

        [HttpGet]
        [Route("lite/animelib")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int year, string uri, string t, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.AnimeLib);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            await EnsureAnimeLibToken(init);

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var headers = httpHeaders(init, HeadersModel.Init("authorization", $"Bearer {init.token}"));

            if (string.IsNullOrWhiteSpace(uri))
            {
                #region –ü–æ–∏—Å–∫
                if (string.IsNullOrWhiteSpace(title))
                    return OnError();

                string memkey = $"animelib:search:{title}:{original_title}";

                return await InvkSemaphore(init, memkey, async () =>
                {
                    if (!hybridCache.TryGetValue(memkey, out List<(string title, string year, string uri, bool coincidence, string cover)> catalog, inmemory: false))
                    {
                        async Task<DataSearch[]> goSearch(string q)
                        {
                            if (string.IsNullOrEmpty(q))
                                return null;

                            string req_uri = $"{init.corsHost()}/api/anime?fields[]=rate_avg&fields[]=rate&fields[]=releaseDate&q={HttpUtility.UrlEncode(q)}";
                            var result = rch.enable ? await rch.Get<JObject>(req_uri, headers) :
                                                      await Http.Get<JObject>(req_uri, httpversion: 2, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: headers);

                            if (result == null || !result.ContainsKey("data"))
                                return null;

                            return result["data"].ToObject<DataSearch[]>();
                        }

                        var search = await goSearch(original_title);

                        if (search == null || search.Length == 0)
                            search = await goSearch(title);

                        if (search == null || search.Length == 0)
                            return OnError(proxyManager, refresh_proxy: !rch.enable);

                        string stitle = StringConvert.SearchName(title);
                        catalog = new List<(string title, string year, string uri, bool coincidence, string cover)>(search.Length);

                        foreach (var anime in search)
                        {
                            if (string.IsNullOrEmpty(anime.slug_url))
                                continue;

                            var model = ($"{anime.rus_name} / {anime.eng_name}", (anime.releaseDate != null ? anime.releaseDate.Split("-")[0] : "0"), anime.slug_url, false, anime.cover.@default);

                            if (stitle == StringConvert.SearchName(anime.rus_name) || stitle == StringConvert.SearchName(anime.eng_name))
                            {
                                if (!string.IsNullOrEmpty(anime.releaseDate) && anime.releaseDate.StartsWith(year.ToString()))
                                    model.Item4 = true;
                            }

                            catalog.Add(model);
                        }

                        if (catalog.Count == 0)
                            return OnError();

                        if (!rch.enable)
                            proxyManager.Success();

                        hybridCache.Set(memkey, catalog, cacheTime(40, init: init), inmemory: false);
                    }

                    if (!similar && catalog.Where(i => i.coincidence).Count() == 1)
                        return LocalRedirect(accsArgs($"/lite/animelib?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&uri={HttpUtility.UrlEncode(catalog.First(i => i.coincidence).uri)}"));

                    var stpl = new SimilarTpl(catalog.Count);

                    foreach (var res in catalog)
                        stpl.Append(res.title, res.year, string.Empty, $"{host}/lite/animelib?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&uri={HttpUtility.UrlEncode(res.uri)}", PosterApi.Size(res.cover));

                    return ContentTo(rjson ? stpl.ToJson() : stpl.ToHtml());
                });
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∏
                string memKey = $"animelib:playlist:{uri}";

                return await InvkSemaphore(init, memKey, async () =>
                {
                    if (!hybridCache.TryGetValue(memKey, out Episode[] episodes))
                    {
                        string req_uri = $"{init.corsHost()}/api/episodes?anime_id={uri}";

                        var root = rch.enable ? await rch.Get<JObject>(req_uri, headers) :
                                                await Http.Get<JObject>(req_uri, timeoutSeconds: 8, httpversion: 2, proxy: proxyManager.Get(), headers: headers);

                        if (root == null || !root.ContainsKey("data"))
                            return OnError(proxyManager, refresh_proxy: !rch.enable);

                        episodes = root["data"].ToObject<Episode[]>();

                        if (episodes.Length == 0)
                            return OnError();

                        if (!rch.enable)
                            proxyManager.Success();

                        hybridCache.Set(memKey, episodes, cacheTime(30, init: init));
                    }

                    #region –ü–µ—Ä–µ–≤–æ–¥
                    memKey = $"animelib:video:{episodes.First().id}";
                    if (!hybridCache.TryGetValue(memKey, out Player[] players))
                    {
                        if (rch.IsNotConnected())
                            return ContentTo(rch.connectionMsg);

                        string req_uri = $"{init.corsHost()}/api/episodes/{episodes.First().id}";

                        var root = rch.enable ? await rch.Get<JObject>(req_uri, headers) :
                                                await Http.Get<JObject>(req_uri, httpversion: 2, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: headers);

                        if (root == null || !root.ContainsKey("data"))
                            return OnError(proxyManager, refresh_proxy: !rch.enable);

                        players = root["data"]["players"].ToObject<Player[]>();
                        hybridCache.Set(memKey, players, cacheTime(30, init: init));
                    }

                    var vtpl = new VoiceTpl(players.Length);
                    string activTranslate = t;

                    foreach (var player in players)
                    {
                        if (player.player != "Animelib")
                            continue;

                        if (string.IsNullOrEmpty(activTranslate))
                            activTranslate = player.team.name;

                        vtpl.Append(player.team.name, activTranslate == player.team.name, $"{host}/lite/animelib?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&uri={HttpUtility.UrlEncode(uri)}&t={HttpUtility.UrlEncode(player.team.name)}");
                    }
                    #endregion

                    var etpl = new EpisodeTpl(episodes.Length);

                    foreach (var episode in episodes)
                    {
                        string name = string.IsNullOrEmpty(episode.name) ? title : $"{title} / {episode.name}";

                        string link = $"{host}/lite/animelib/video?id={episode.id}&voice={HttpUtility.UrlEncode(activTranslate)}&title={HttpUtility.UrlEncode(title)}";

                        etpl.Append($"{episode.number} —Å–µ—Ä–∏—è", name, episode.season, episode.number, link, "call", streamlink: accsArgs($"{link}&play=true"));
                    }

                    if (rjson)
                        return ContentTo(etpl.ToJson(vtpl));

                    return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                });
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/animelib/video")]
        async public ValueTask<ActionResult> Video(string title, long id, string voice, bool play)
        {
            var init = await loadKit(AppInit.conf.AnimeLib);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            await EnsureAnimeLibToken(init);

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            reset: 
            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var cache = await InvokeCache<Player[]>($"animelib:video:{id}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
            {
                if (rch.IsNotConnected())
                    return res.Fail(rch.connectionMsg);

                string req_uri = $"{init.corsHost()}/api/episodes/{id}";
                var headers = httpHeaders(init, HeadersModel.Init("authorization", $"Bearer {init.token}"));

                var root = rch.enable ? await rch.Get<JObject>(req_uri, headers) :
                                        await Http.Get<JObject>(req_uri, httpversion: 2, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: headers);

                if (root == null || !root.ContainsKey("data"))
                    return res.Fail("data");

                return root["data"]["players"].ToObject<Player[]>();
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            if (!cache.IsSuccess)
                return OnError(cache.ErrorMsg);

            var headers_stream = httpHeaders(init.host, init.headers_stream);

            #region goStreams
            List<(string link, string quality)> goStreams(string _voice)
            {
                var _streams = new List<(string link, string quality)>(5);

                foreach (var player in cache.Value)
                {
                    if (player.player != "Animelib")
                        continue;

                    if (!string.IsNullOrEmpty(_voice) && _voice != player.team.name)
                        continue;

                    foreach (var video in player.video.quality)
                    {
                        if (string.IsNullOrEmpty(video.href))
                            continue;

                        string file = HostStreamProxy(init, "https://video1.cdnlibs.org/.%D0%B0s/" + video.href, proxy: proxyManager.Get(), headers: headers_stream);

                        _streams.Add((file, $"{video.quality}p"));
                    }

                    if (_streams.Count > 0)
                        break;
                }

                return _streams;
            }
            #endregion

            List<(string link, string quality)> streams;

            if (string.IsNullOrEmpty(voice))
            {
                streams = goStreams(null);
            }
            else
            {
                streams = goStreams(voice);
                if (streams.Count == 0)
                    streams = goStreams(null);
            }

            if (streams == null || streams.Count == 0)
                return OnError("streams");

            var streamquality = new StreamQualityTpl(streams);

            if (play)
                return RedirectToPlay(streamquality.Firts().link);

            return ContentTo(VideoTpl.ToJson("play", streamquality.Firts().link, title, streamquality: streamquality, vast: init.vast, headers: init.streamproxy ? null : headers_stream));
        }
        #endregion


        #region [Codex AI] EnsureAnimeLibToken / RequestAnimeLibToken
        async ValueTask EnsureAnimeLibToken(OnlinesSettings init)
        {
            if (!string.IsNullOrEmpty(init.token))
                return;

            try
            {
                await TokenSemaphore.WaitAsync(TimeSpan.FromMinutes(1));

                AnimeLibTokenState cache = null;
                string TokenCachePath = Path.Combine("cache", "animelib.json");

                try
                {
                    string json = System.IO.File.ReadAllText(TokenCachePath);
                    cache = JsonConvert.DeserializeObject<AnimeLibTokenState>(json);
                }
                catch { }

                if (cache == null)
                    return;

                if (!string.IsNullOrEmpty(cache.token) && cache.refresh_time > DateTimeOffset.UtcNow.ToUnixTimeSeconds())
                {
                    init.token = cache.token;
                    return;
                }

                var tokens = await RequestAnimeLibToken(cache.refresh_token);
                if (tokens == null)
                    return;

                cache = new AnimeLibTokenState
                {
                    token = tokens.Value.accessToken,
                    refresh_token = tokens.Value.refreshToken,
                    // 2592000 —Å–µ–∫—É–Ω–¥ / 60 = 43200 –º–∏–Ω—É—Ç
                    // 43200 –º–∏–Ω—É—Ç / 60 = 720 —á–∞—Å–æ–≤
                    // 720 —á–∞—Å–æ–≤ / 24 = 30 –¥–Ω–µ–π
                    refresh_time = DateTimeOffset.UtcNow.AddDays(20).ToUnixTimeSeconds()
                };

                try
                {
                    System.IO.File.WriteAllText(TokenCachePath, JsonConvert.SerializeObject(cache));
                }
                catch { }

                init.token = cache.token;
            }
            catch { }
            finally
            {
                TokenSemaphore.Release();
            }
        }

        async ValueTask<(string accessToken, string refreshToken)?> RequestAnimeLibToken(string refreshToken)
        {
            var payload = JsonConvert.SerializeObject(new
            {
                grant_type = "refresh_token",
                client_id = "1",
                refresh_token = refreshToken,
                scope = string.Empty
            });

            using (var content = new StringContent(payload, Encoding.UTF8, "application/json"))
            {
                var headers = HeadersModel.Init(Http.defaultFullHeaders,
                    ("accept", "*/*"),
                    ("origin", "https://anilib.me"),
                    ("referer", "https://anilib.me/"),
                    ("accept-language", "en-US,en;q=0.9,ru;q=0.8"),
                    ("client-time-zone", "Europe/Kiev"),
                    ("sec-fetch-dest", "empty"),
                    ("sec-fetch-mode", "cors"),
                    ("sec-fetch-site", "cross-site"),
                    ("site-id", "5")
                );

                var result = await Http.Post<JObject>("https://api.cdnlibs.org/api/auth/oauth/token", content, httpversion: 2, timeoutSeconds: 8, headers: headers, useDefaultHeaders: false);
                if (result == null)
                    return null;

                //{"token_type":"Bearer","expires_in":2592000,"access_token":"*","refresh_token":"*"}

                string accessToken = result.Value<string>("access_token");
                string newRefreshToken = result.Value<string>("refresh_token");

                if (string.IsNullOrEmpty(accessToken) || string.IsNullOrEmpty(newRefreshToken))
                    return null;

                return (accessToken, newRefreshToken);
            }
        }
        #endregion
    }
}

```

## File: Online/Controllers/Anime/AniLiberty.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;

namespace Online.Controllers
{
    public class AniLiberty : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/aniliberty")]
        async public ValueTask<ActionResult> Index(string title, int year, int releases, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.AniLiberty);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(AppInit.conf.AniLiberty);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (releases == 0)
            {
                #region –ü–æ–∏—Å–∫
                string stitle = StringConvert.SearchName(title);
                if (string.IsNullOrEmpty(stitle))
                    return OnError();

                reset:
                var cache = await InvokeCache<List<(string title, string year, int releases, string cover)>>($"aniliberty:search:{title}:{similar}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string req_uri = $"{init.corsHost()}/api/v1/app/search/releases?query={HttpUtility.UrlEncode(title)}";
                    var search = rch.enable ? await rch.Get<JArray>(req_uri, httpHeaders(init)) :
                                              await Http.Get<JArray>(req_uri, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));

                    if (search == null || search.Count == 0)
                        return res.Fail("search");

                    bool checkName = true;
                    var catalog = new List<(string title, string year, int releases, string cover)>(search.Count);

                    retry: foreach (var anime in search)
                    {
                        var name = anime["name"];
                        string name_main = StringConvert.SearchName(name.Value<string>("main"));
                        string name_english = StringConvert.SearchName(name.Value<string>("english"));

                        if (!checkName || similar || (name_main != null && name_main.StartsWith(stitle)) || (name_english != null && name_english.StartsWith(stitle)))
                        {
                            int id = anime.Value<int>("id");
                            int releaseDate = anime.Value<int>("year");

                            string img = null;
                            var cover = anime["poster"];
                            if (cover != null)
                                img = init.host + cover.Value<string>("src");

                            catalog.Add(($"{name.Value<string>("main")} / {name.Value<string>("english")}", releaseDate.ToString(), id, img));
                        }
                    }

                    if (catalog.Count == 0)
                    {
                        if (checkName && similar == false)
                        {
                            checkName = false;
                            goto retry;
                        }

                        return res.Fail("catalog");
                    }

                    return catalog;
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                if (!similar && cache.Value != null && cache.Value.Count == 1)
                    return LocalRedirect(accsArgs($"/lite/aniliberty?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&releases={cache.Value.First().releases}"));

                return OnResult(cache, () =>
                {
                    var stpl = new SimilarTpl(cache.Value.Count);

                    foreach (var res in cache.Value)
                        stpl.Append(res.title, res.year, string.Empty, $"{host}/lite/aniliberty?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&releases={res.releases}", PosterApi.Size(res.cover));

                    return rjson ? stpl.ToJson() : stpl.ToHtml();

                }, gbcache: !rch.enable);
                #endregion
            }
            else 
            {
                #region –°–µ—Ä–∏–∏
                reset: 
                var cache = await InvokeCache<JObject>($"aniliberty:releases:{releases}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string req_uri = $"{init.corsHost()}/api/v1/anime/releases/{releases}";

                    var root = rch.enable ? await rch.Get<JObject>(req_uri, httpHeaders(init)) :
                                            await Http.Get<JObject>(req_uri, timeoutSeconds: 8, httpversion: 2, proxy: proxy, headers: httpHeaders(init));

                    if (root == null || !root.ContainsKey("episodes"))
                        return res.Fail("episodes");

                    return root;
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                return OnResult(cache, () =>
                {
                    var episodes = cache.Value["episodes"] as JArray;
                    var etpl = new EpisodeTpl(episodes.Count);

                    foreach (var episode in episodes)
                    {
                        string alias = cache.Value.Value<string>("alias") ?? "";
                        string season = Regex.Match(alias, "-([0-9]+)(nd|th)").Groups[1].Value;
                        if (string.IsNullOrEmpty(season))
                        {
                            season = Regex.Match(alias, "season-([0-9]+)").Groups[1].Value;
                            if (string.IsNullOrEmpty(season))
                                season = "1";
                        }

                        string number = episode.Value<string>("ordinal");

                        string name = episode.Value<string>("name");
                        name = string.IsNullOrEmpty(name) ? $"{number} —Å–µ—Ä–∏—è" : name;

                        var streams = new StreamQualityTpl();
                        foreach (var f in new List<(string quality, string url)>
                        {
                            ("1080p", episode.Value<string>("hls_1080")),
                            ("720p", episode.Value<string>("hls_720")),
                            ("480p", episode.Value<string>("hls_480"))
                        })
                        {
                            if (string.IsNullOrEmpty(f.url))
                                continue;

                            streams.Append(HostStreamProxy(init, f.url, proxy: proxy), f.quality);
                        }

                        etpl.Append(name, title, season, number, streams.Firts().link, streamquality: streams);
                    }

                    return rjson ? etpl.ToJson() : etpl.ToHtml();

                }, gbcache: !rch.enable);
                #endregion
            }
        }
    }
}

```

## File: Online/Controllers/Anime/Kodik.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Kodik;
using Shared.Models.Online.Settings;
using System.Security.Cryptography;
using System.Text;

namespace Online.Controllers
{
    public class Kodik : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.Kodik);

        #region database
        static List<Result> databaseCache;

        static IEnumerable<Result> database
        {
            get
            {
                if (AppInit.conf.multiaccess || databaseCache != null)
                    return databaseCache ??= JsonHelper.ListReader<Result>("data/kodik.json", 70_000);

                return JsonHelper.IEnumerableReader<Result>("data/kodik.json");
            }
        }
        #endregion

        #region InitKodikInvoke
        public KodikInvoke InitKodikInvoke(KodikSettings init)
        {
            var proxy = proxyManager.Get();

            return new KodikInvoke
            (
                host,
                init.apihost,
                init.token,
                init.hls,
                init.cdn_is_working,
                "video",
                database,
                (uri, head) => Http.Get(init.cors(uri), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
                (uri, data) => Http.Post(init.cors(uri), data, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
                streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
                requesterror: () => proxyManager.Refresh()
            );
        }
        #endregion

        #region Initialization
        ValueTask<KodikSettings> Initialization()
        {
            return loadKit(AppInit.conf.Kodik, (j, i, c) =>
            {
                if (j.ContainsKey("linkhost"))
                    i.linkhost = c.linkhost;

                if (j.ContainsKey("secret_token"))
                    i.secret_token = c.secret_token;

                if (j.ContainsKey("auto_proxy"))
                    i.auto_proxy = c.auto_proxy;

                if (j.ContainsKey("cdn_is_working"))
                    i.cdn_is_working = c.cdn_is_working;

                return i;
            });
        }
        #endregion

        [HttpGet]
        [Route("lite/kodik")]
        async public ValueTask<ActionResult> Index(string imdb_id, long kinopoisk_id, string title, string original_title, int clarification, string pick, string kid, int s = -1, bool rjson = false, bool similar = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            List<Result> content = null;
            var oninvk = InitKodikInvoke(init);

            if (similar || clarification == 1 || (kinopoisk_id == 0 && string.IsNullOrEmpty(imdb_id)))
            {
                EmbedModel res = null;

                if (clarification == 1)
                {
                    if (string.IsNullOrEmpty(title))
                        return OnError();

                    res = await InvokeCache($"kodik:search:{title}", cacheTime(40, init: init), () => oninvk.Embed(title, null, clarification), proxyManager);
                    if (res?.result == null || res.result.Count == 0)
                        return OnError();
                }
                else
                {
                    if (string.IsNullOrEmpty(pick) && string.IsNullOrEmpty(title ?? original_title))
                        return OnError();

                    res = await InvokeCache($"kodik:search2:{original_title}:{title}:{clarification}", cacheTime(40, init: AppInit.conf.Kodik), async () => 
                    {
                        var i = await oninvk.Embed(null, original_title, clarification);
                        if (i?.result == null || i.result.Count == 0)
                            return await oninvk.Embed(title, null, clarification);

                        return i;

                    }, proxyManager);
                }

                if (string.IsNullOrEmpty(pick))
                    return ContentTo(res?.stpl == null ? string.Empty : (rjson ? res.stpl.Value.ToJson() : res.stpl.Value.ToHtml()));

                content = oninvk.Embed(res.result, pick);
            }
            else
            {
                content = await InvokeCache($"kodik:search:{kinopoisk_id}:{imdb_id}", cacheTime(40, init: AppInit.conf.Kodik), () => oninvk.Embed(imdb_id, kinopoisk_id, s), proxyManager);
                if (content == null || content.Count == 0)
                    return LocalRedirect(accsArgs($"/lite/kodik?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}"));
            }

            return ContentTo(await oninvk.Html(content, accsArgs(string.Empty), imdb_id, kinopoisk_id, title, original_title, clarification, pick, kid, s, true, rjson));
        }

        #region Video
        [HttpGet]
        [Route("lite/kodik/video")]
        [Route("lite/kodik/video.m3u8")]
        async public ValueTask<ActionResult> VideoAPI(string title, string original_title, string link, int episode, bool play)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (string.IsNullOrWhiteSpace(init.secret_token))
            {
                var oninvk = InitKodikInvoke(init);

                var streams = await InvokeCache($"kodik:video:{link}:{play}", cacheTime(40, init: init), () => oninvk.VideoParse(init.linkhost, link), proxyManager);
                if (streams == null)
                    return OnError();

                string result = oninvk.VideoParse(streams, title, original_title, episode, play, vast: init.vast);
                if (string.IsNullOrEmpty(result))
                    return OnError();

                if (play)
                    return RedirectToPlay(result);

                return ContentTo(result);
            }
            else
            {
                string userIp = requestInfo.IP;
                if (init.localip)
                {
                    userIp = await mylocalip();
                    if (userIp == null)
                        return OnError();
                }

                var proxy = proxyManager.Get();

                string memKey = $"kodik:view:stream:{link}:{init.secret_token}:{requestInfo.IP}";

                return await InvkSemaphore(init, memKey, async () =>
                {
                    if (!hybridCache.TryGetValue(memKey, out (List<(string q, string url)> streams, SegmentTpl segments) cache))
                    {
                        string deadline = DateTime.Now.AddHours(4).ToString("yyyy MM dd HH").Replace(" ", "");
                        string hmac = HMAC(init.secret_token, $"{link}:{userIp}:{deadline}");

                        var root = await Http.Get<JObject>($"http://kodik.biz/api/video-links?link={link}&p={init.token}&ip={userIp}&d={deadline}&s={hmac}&auto_proxy={init.auto_proxy.ToString().ToLower()}&skip_segments=true", timeoutSeconds: 8, proxy: proxy);

                        if (root == null || !root.ContainsKey("links"))
                            return OnError("links");

                        cache.streams = new List<(string q, string url)>(3);

                        foreach (var link in root["links"].ToObject<Dictionary<string, JObject>>())
                        {
                            string src = link.Value.Value<string>("Src");
                            if (src.StartsWith("http"))
                                src = src.Substring(src.IndexOf("://") + 3);

                            cache.streams.Add(($"{link.Key}p", $"https://{src}"));
                        }

                        if (cache.streams.Count == 0)
                        {
                            proxyManager.Refresh();
                            return OnError("streams");
                        }

                        cache.streams.Reverse();

                        if (root.ContainsKey("segments"))
                        {
                            var segs = root["segments"] as JObject;
                            if (segs != null)
                            {
                                cache.segments = new SegmentTpl();

                                foreach (string key in new string[] { "ad", "skip" })
                                {
                                    if (segs.ContainsKey(key))
                                    {
                                        var arr = segs[key] as JArray;
                                        if (arr != null)
                                        {
                                            foreach (var it in arr)
                                            {
                                                int? s = it.Value<int?>("start");
                                                int? e = it.Value<int?>("end");
                                                if (s.HasValue && e.HasValue)
                                                    cache.segments.ad(s.Value, e.Value);
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        proxyManager.Success();
                        hybridCache.Set(memKey, cache, cacheTime(120, init: init));
                    }

                    var streamquality = new StreamQualityTpl();
                    foreach (var l in cache.streams)
                        streamquality.Append(HostStreamProxy(init, l.url, proxy: proxy), l.q);

                    if (play)
                        return RedirectToPlay(streamquality.Firts().link);

                    string name = title ?? original_title;
                    if (episode > 0)
                        name += $" ({episode} —Å–µ—Ä–∏—è)";

                    return ContentTo(VideoTpl.ToJson("play", streamquality.Firts().link, name, streamquality: streamquality, vast: init.vast, segments: cache.segments));
                });
            }
        }
        #endregion


        #region HMAC
        static string HMAC(string key, string message)
        {
            using (var hash = new HMACSHA256(Encoding.UTF8.GetBytes(key)))
            {
                return BitConverter.ToString(hash.ComputeHash(Encoding.UTF8.GetBytes(message))).Replace("-", "").ToLower();
            }
        }
        #endregion
    }
}

```

## File: Online/Controllers/Anime/AnimeGo.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;

namespace Online.Controllers
{
    public class AnimeGo : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.AnimeGo);

        [HttpGet]
        [Route("lite/animego")]
        async public ValueTask<ActionResult> Index(string title, int year, int pid, int s, string t, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.AnimeGo);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var headers_stream = httpHeaders(init.host, init.headers_stream);

            if (pid == 0)
            {
                #region –ü–æ–∏—Å–∫
                string memkey = $"animego:search:{title}";

                return await InvkSemaphore(init, memkey, async () =>
                {
                    if (!hybridCache.TryGetValue(memkey, out List<(string title, string year, string pid, string s, string img)> catalog, inmemory: false))
                    {
                        string search = await Http.Get($"{init.corsHost()}/search/anime?q={HttpUtility.UrlEncode(title)}", timeoutSeconds: 10, proxy: proxyManager.Get(), headers: httpHeaders(init), httpversion: 2);
                        if (search == null)
                            return OnError(proxyManager);

                        var rows = search.Split("class=\"p-poster__stack\"");

                        catalog = new List<(string title, string year, string pid, string s, string img)>(rows.Length);

                        foreach (string row in rows.Skip(1))
                        {
                            string player_id = Regex.Match(row, "data-ajax-url=\"/[^\"]+-([0-9]+)\"").Groups[1].Value;
                            string name = Regex.Match(row, "card-title text-truncate\"><a [^>]+>([^<]+)<").Groups[1].Value;
                            string animeyear = Regex.Match(row, "class=\"anime-year\"><a [^>]+>([0-9]{4})<").Groups[1].Value;
                            string img = Regex.Match(row, "data-original=\"([^\"]+)\"").Groups[1].Value;
                            if (string.IsNullOrEmpty(img))
                                img = null;

                            if (!string.IsNullOrWhiteSpace(player_id) && !string.IsNullOrWhiteSpace(name) && StringConvert.SearchName(name).Contains(StringConvert.SearchName(title)))
                            {
                                string season = "0";
                                if (animeyear == year.ToString() && StringConvert.SearchName(name) == StringConvert.SearchName(title))
                                    season = "1";

                                catalog.Add((name, Regex.Match(row, ">([0-9]{4})</a>").Groups[1].Value, player_id, season, img));
                            }
                        }

                        if (catalog.Count == 0)
                            return OnError();

                        proxyManager.Success();
                        hybridCache.Set(memkey, catalog, cacheTime(40, init: init), inmemory: false);
                    }

                    if (!similar && catalog.Count == 1)
                        return LocalRedirect(accsArgs($"/lite/animego?title={HttpUtility.UrlEncode(title)}&pid={catalog[0].pid}&s={catalog[0].s}"));

                    var stpl = new SimilarTpl(catalog.Count);

                    foreach (var res in catalog)
                    {
                        string uri = $"{host}/lite/animego?title={HttpUtility.UrlEncode(title)}&pid={res.pid}&s={res.s}";
                        stpl.Append(res.title, res.year, string.Empty, uri, PosterApi.Size(res.img));
                    }

                    return ContentTo(rjson ? stpl.ToJson() : stpl.ToHtml());
                });
                #endregion
            }
            else 
            {
                #region –°–µ—Ä–∏–∏
                string memKey = $"animego:playlist:{pid}";

                return await InvkSemaphore(init, memKey, async () =>
                {
                    if (!hybridCache.TryGetValue(memKey, out (string translation, List<(string episode, string uri)> links, List<(string name, string id)> translations) cache))
                    {
                        #region content
                        var player = await Http.Get<JObject>($"{init.corsHost()}/anime/{pid}/player?_allow=true", timeoutSeconds: 10, proxy: proxyManager.Get(), httpversion: 2, headers: httpHeaders(init, HeadersModel.Init(
                            ("cache-control", "no-cache"),
                            ("dnt", "1"),
                            ("pragma", "no-cache"),
                            ("referer", $"{init.host}/"),
                            ("sec-fetch-dest", "empty"),
                            ("sec-fetch-mode", "cors"),
                            ("sec-fetch-site", "same-origin"),
                            ("x-requested-with", "XMLHttpRequest")
                        )));

                        string content = player?.Value<string>("content");
                        if (string.IsNullOrWhiteSpace(content))
                            return OnError(proxyManager);
                        #endregion

                        var g = Regex.Match(content, "data-player=\"(https?:)?//(aniboom\\.[^/]+)/embed/([^\"\\?&]+)\\?episode=1\\&amp;translation=([0-9]+)\"").Groups;
                        if (string.IsNullOrWhiteSpace(g[2].Value) || string.IsNullOrWhiteSpace(g[3].Value) || string.IsNullOrWhiteSpace(g[4].Value))
                            return OnError();

                        #region links
                        var match = Regex.Match(content, "data-episode=\"([0-9]+)\"");
                        cache.links = new List<(string episode, string uri)>(match.Length);

                        while (match.Success)
                        {
                            if (!string.IsNullOrWhiteSpace(match.Groups[1].Value))
                                cache.links.Add((match.Groups[1].Value, $"video.m3u8?host={g[2].Value}&token={g[3].Value}&e={match.Groups[1].Value}"));

                            match = match.NextMatch();
                        }

                        if (cache.links.Count == 0)
                            return OnError();
                        #endregion

                        #region translation / translations
                        match = Regex.Match(content, "data-player=\"(https?:)?//aniboom\\.[^/]+/embed/[^\"\\?&]+\\?episode=[0-9]+\\&amp;translation=([0-9]+)\"[\n\r\t ]+data-provider=\"[0-9]+\"[\n\r\t ]+data-provide-dubbing=\"([0-9]+)\"");

                        cache.translation = g[4].Value;
                        cache.translations = new List<(string name, string id)>(match.Length);

                        while (match.Success)
                        {
                            if (!string.IsNullOrWhiteSpace(match.Groups[2].Value) && !string.IsNullOrWhiteSpace(match.Groups[3].Value))
                            {
                                string name = Regex.Match(content, $"data-dubbing=\"{match.Groups[3].Value}\"><span [^>]+>[\n\r\t ]+([^\n\r<]+)").Groups[1].Value.Trim();
                                if (!string.IsNullOrWhiteSpace(name))
                                    cache.translations.Add((name, match.Groups[2].Value));
                            }

                            match = match.NextMatch();
                        }
                        #endregion

                        proxyManager.Success();
                        hybridCache.Set(memKey, cache, cacheTime(30, init: init));
                    }

                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var vtpl = new VoiceTpl(cache.translations.Count);
                    if (string.IsNullOrWhiteSpace(t))
                        t = cache.translation;

                    foreach (var translation in cache.translations)
                    {
                        string link = $"{host}/lite/animego?pid={pid}&title={HttpUtility.UrlEncode(title)}&s={s}&t={translation.id}";
                        vtpl.Append(translation.name, t == translation.id, link);
                    }
                    #endregion

                    var etpl = new EpisodeTpl(cache.links.Count);
                    string sArhc = s.ToString();

                    foreach (var l in cache.links)
                    {
                        string hls = accsArgs($"{host}/lite/animego/{l.uri}&t={t ?? cache.translation}");

                        etpl.Append($"{l.episode} —Å–µ—Ä–∏—è", title, sArhc, l.episode, hls, "play", headers: headers_stream);
                    }

                    if (rjson)
                        return ContentTo(etpl.ToJson(vtpl));

                    return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                });
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/animego/video.m3u8")]
        async public ValueTask<ActionResult> Video(string host, string token, string t, int e)
        {
            var init = await loadKit(AppInit.conf.AnimeGo);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            string memKey = $"animego:video:{token}:{t}:{e}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out string hls))
                {
                    string embed = await Http.Get($"https://{host}/embed/{token}?episode={e}&translation={t}", timeoutSeconds: 10, proxy: proxyManager.Get(), httpversion: 2, headers: httpHeaders(init, HeadersModel.Init(
                        ("cache-control", "no-cache"),
                        ("dnt", "1"),
                        ("pragma", "no-cache"),
                        ("referer", $"{init.host}/"),
                        ("sec-fetch-dest", "empty"),
                        ("sec-fetch-mode", "cors"),
                        ("sec-fetch-site", "same-origin"),
                        ("x-requested-with", "XMLHttpRequest")
                    )));

                    if (string.IsNullOrWhiteSpace(embed))
                        return OnError(proxyManager);

                    embed = embed.Replace("&quot;", "\"").Replace("\\", "");

                    hls = Regex.Match(embed, "\"hls\":\"\\{\"src\":\"(https?:)?(//[^\"]+\\.m3u8)\"").Groups[2].Value;
                    if (string.IsNullOrWhiteSpace(hls))
                        return OnError(proxyManager);

                    hls = "https:" + hls;

                    proxyManager.Success();
                    hybridCache.Set(memKey, hls, cacheTime(30, init: init));
                }

                return Redirect(HostStreamProxy(init, hls, proxy: proxyManager.Get()));
            });
        }
        #endregion
    }
}

```

## File: Online/Controllers/Anime/AniLibria.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.AniLibria;

namespace Online.Controllers
{
    public class AniLibriaOnline : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/anilibria")]
        async public ValueTask<ActionResult> Index(string title, string code, int year, bool origsource = false, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.AnilibriaOnline);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(title))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var oninvk = new AniLibriaInvoke
            (
               host,
               init.corsHost(),
               ongettourl => rch.enable ? rch.Get<List<RootObject>>(init.cors(ongettourl)) : Http.Get<List<RootObject>>(init.cors(ongettourl), timeoutSeconds: 40, proxy: proxy, IgnoreDeserializeObject: true, headers: httpHeaders(init)),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            reset:
            var cache = await InvokeCache<List<RootObject>>($"anilibriaonline:{title}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(title);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, title, code, year, vast: init.vast, rjson: rjson, similar: similar), origsource: origsource, gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/Anime/Animebesst.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace Online.Controllers
{
    public class Animebesst : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.Animebesst);

        [HttpGet]
        [Route("lite/animebesst")]
        async public ValueTask<ActionResult> Index(string title, string uri, int s, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.Animebesst);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("cors,web", out string rch_error))
                return ShowError(rch_error);

            reset:
            if (string.IsNullOrEmpty(uri))
            {
                if (string.IsNullOrWhiteSpace(title))
                    return OnError();

                #region –ü–æ–∏—Å–∫
                var cache = await InvokeCache<List<(string title, string year, string uri, string s, string img)>>($"animebesst:search:{title}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string data = $"do=search&subaction=search&search_start=0&full_search=0&result_from=1&story={HttpUtility.UrlEncode(title)}";
                    string search = rch.enable ? await rch.Post($"{init.corsHost()}/index.php?do=search", data) : await Http.Post($"{init.corsHost()}/index.php?do=search", data, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                    if (search == null)
                        return res.Fail("search");

                    var rows = search.Split("id=\"sidebar\"")[0].Split("class=\"shortstory-listab\"");

                    var catalog = new List<(string title, string year, string uri, string s, string img)>(rows.Length);

                    foreach (string row in rows.Skip(1))
                    {
                        if (row.Contains("–ù–æ–≤–æ—Å—Ç–∏"))
                            continue;

                        var g = Regex.Match(row, "class=\"shortstory-listab-title\"><a href=\"(https?://[^\"]+\\.html)\">([^<]+)</a>").Groups;

                        if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                        {
                            string season = "0";
                            if (g[2].Value.Contains("—Å–µ–∑–æ–Ω"))
                            {
                                season = Regex.Match(g[2].Value, "([0-9]+) —Å–µ–∑–æ–Ω").Groups[1].Value;
                                if (string.IsNullOrEmpty(season))
                                    season = "1";
                            }

                            string img = Regex.Match(row, "<img class=\"img-fit lozad\" data-src=\"([^\"]+)\"").Groups[1].Value;
                            if (string.IsNullOrEmpty(img))
                                img = null;

                            catalog.Add((g[2].Value, Regex.Match(row, "\">([0-9]{4})</a>").Groups[1].Value, g[1].Value, season, img));
                        }
                    }

                    if (catalog.Count == 0 && !search.Contains(">–ü–æ–∏—Å–∫ –ø–æ —Å–∞–π—Ç—É<"))
                        return res.Fail("catalog");

                    return catalog;
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                if (cache.Value != null && cache.Value.Count == 0)
                    return OnError();

                if (!similar && cache.Value != null && cache.Value.Count == 1)
                    return LocalRedirect(accsArgs($"/lite/animebesst?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&uri={HttpUtility.UrlEncode(cache.Value[0].uri)}&s={cache.Value[0].s}"));

                return OnResult(cache, () =>
                {
                    var stpl = new SimilarTpl(cache.Value.Count);

                    foreach (var res in cache.Value)
                    {
                        string _u = $"{host}/lite/animebesst?title={HttpUtility.UrlEncode(title)}&uri={HttpUtility.UrlEncode(res.uri)}&s={res.s}";
                        stpl.Append(res.title, res.year, string.Empty, _u, PosterApi.Size(res.img));
                    }

                    return rjson ? stpl.ToJson() : stpl.ToHtml();

                }, gbcache: !rch.enable);
                #endregion
            }
            else 
            {
                #region –°–µ—Ä–∏–∏
                var cache = await InvokeCache<List<(string episode, string name, string uri)>>($"animebesst:playlist:{uri}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string news = rch.enable ? await rch.Get(uri) : await Http.Get(uri, timeoutSeconds: 10, proxy: proxyManager.Get(), headers: httpHeaders(init));
                    if (news == null)
                        return res.Fail("news");

                    string videoList = Regex.Match(news, "var videoList ?=([^\n\r]+)").Groups[1].Value.Trim();
                    if (string.IsNullOrEmpty(videoList))
                        return res.Fail("videoList");

                    var links = new List<(string episode, string name, string uri)>(5);
                    var match = Regex.Match(videoList, "\"id\":\"([0-9]+)( [^\"]+)?\",\"link\":\"(https?:)?\\\\/\\\\/([^\"]+)\"");
                    while (match.Success)
                    {
                        if (!string.IsNullOrWhiteSpace(match.Groups[1].Value) && !string.IsNullOrWhiteSpace(match.Groups[4].Value))
                            links.Add((match.Groups[1].Value, match.Groups[2].Value.Trim(), match.Groups[4].Value.Replace("\\", "")));

                        match = match.NextMatch();
                    }

                    if (links.Count == 0)
                        return res.Fail("links");

                    return links;
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                return OnResult(cache, () =>
                {
                    var etpl = new EpisodeTpl(cache.Value.Count);
                    string sArhc = s.ToString();

                    foreach (var l in cache.Value)
                    {
                        string name = string.IsNullOrEmpty(l.name) ? $"{l.episode} —Å–µ—Ä–∏—è" : $"{l.episode} {l.name}";
                        string voice_name = !string.IsNullOrEmpty(l.name) ? Regex.Replace(l.name, "(^\\(|\\)$)", "") : "";

                        string link = accsArgs($"{host}/lite/animebesst/video.m3u8?uri={HttpUtility.UrlEncode(l.uri)}&title={HttpUtility.UrlEncode(title)}");

                        etpl.Append(name, $"{title} / {name}", sArhc, l.episode, link, "call", streamlink: $"{link}&play=true", voice_name: Regex.Unescape(voice_name));
                    }

                    return rjson ? etpl.ToJson() : etpl.ToHtml();

                }, gbcache: !rch.enable);
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/animebesst/video.m3u8")]
        async public ValueTask<ActionResult> Video(string uri, string title, bool play)
        {
            var init = await loadKit(AppInit.conf.Animebesst);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            reset: 
            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("cors,web", out string rch_error))
                return ShowError(rch_error);

            var cache = await InvokeCache<string>($"animebesst:video:{uri}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
            {
                if (rch.IsNotConnected())
                    return res.Fail(rch.connectionMsg);

                string iframe;
                if (rch.enable)
                {
                    iframe = await rch.Get(init.cors($"https://{uri}"), headers: httpHeaders(init));
                }
                else
                {
                    iframe = await Http.Get(init.cors($"https://{uri}"), referer: init.host, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init), httpversion: 2);
                }

                if (iframe == null)
                    return res.Fail("iframe");

                string hls = Regex.Match(iframe, "file:\"(https?://[^\"]+\\.m3u8)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(hls))
                    return res.Fail("hls");

                return hls;
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            if (!cache.IsSuccess)
                return OnError(cache.ErrorMsg, gbcache: !rch.enable);

            string link = HostStreamProxy(init, cache.Value, proxy: proxyManager.Get());

            if (play)
                return RedirectToPlay(link);

            return ContentTo(VideoTpl.ToJson("play", link, title, vast: init.vast));
        }
        #endregion
    }
}

```

## File: Online/Controllers/Anime/Animevost.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace Online.Controllers
{
    public class Animevost : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.Animevost);

        [HttpGet]
        [Route("lite/animevost")]
        async public ValueTask<ActionResult> Index(string title, int year, string uri, int s, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.Animevost);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            reset:
            if (string.IsNullOrWhiteSpace(uri))
            {
                #region –ü–æ–∏—Å–∫
                var cache = await InvokeCache<List<(string title, string year, string uri, string s, string img)>>($"animevost:search:{title}:{similar}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string data = $"do=search&subaction=search&search_start=0&full_search=0&result_from=1&story={HttpUtility.UrlEncode(title)}";
                    string search = rch.enable ? await rch.Post($"{init.corsHost()}/index.php?do=search", data) : await Http.Post($"{init.corsHost()}/index.php?do=search", data, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                    if (search == null)
                        return res.Fail("search");

                    var rows = search.Split("class=\"shortstory\"");

                    var smlr = new List<(string title, string year, string uri, string s, string img)>(rows.Length);
                    var catalog = new List<(string title, string year, string uri, string s, string img)>(rows.Length);

                    foreach (string row in rows.Skip(1))
                    {
                        var g = Regex.Match(row, "<a href=\"(https?://[^\"]+\\.html)\">([^<]+)</a>").Groups;
                        string animeyear = Regex.Match(row, "<strong>–ì–æ–¥ –≤—ã—Ö–æ–¥–∞: ?</strong>([0-9]{4})</p>").Groups[1].Value;
                        string img = Regex.Match(row, " src=\"(/uploads/[^\"]+)\"").Groups[1].Value;
                        if (!string.IsNullOrEmpty(img))
                            img = init.host + img;

                        if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                        {
                            string season = Regex.Match(g[2].Value, "([0-9 ]+) ?nd ", RegexOptions.IgnoreCase).Groups[1].Value.Trim();
                            if (string.IsNullOrEmpty(season))
                            {
                                season = Regex.Match(g[2].Value, "Season ([0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value.Trim();
                                if (string.IsNullOrEmpty(season))
                                    season = "1";
                            }

                            smlr.Add((g[2].Value, animeyear, g[1].Value, season, string.IsNullOrEmpty(img) ? null : img));

                            if (animeyear == year.ToString() && StringConvert.SearchName(g[2].Value).Contains(StringConvert.SearchName(title)))
                                catalog.Add((g[2].Value, animeyear, g[1].Value, season, null));
                        }
                    }

                    if (catalog.Count == 0 && smlr.Count == 0)
                        return res.Fail("catalog");

                    if (!similar && catalog.Count > 0)
                        return catalog;

                    return smlr;
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                if (!similar && cache.Value != null && cache.Value.Count == 1)
                    return LocalRedirect(accsArgs($"/lite/animevost?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&uri={HttpUtility.UrlEncode(cache.Value[0].uri)}&s={cache.Value[0].s}"));

                return OnResult(cache, () =>
                {
                    if (cache.Value.Count == 0)
                        return string.Empty;

                    var stpl = new SimilarTpl(cache.Value.Count);

                    foreach (var res in cache.Value)
                    {
                        string uri = $"{host}/lite/animevost?title={HttpUtility.UrlEncode(title)}&uri={HttpUtility.UrlEncode(res.uri)}&s={res.s}";
                        stpl.Append(res.title, res.year, string.Empty, uri, PosterApi.Size(res.img));
                    }

                    return rjson ? stpl.ToJson() : stpl.ToHtml();

                }, gbcache: !rch.enable);
                #endregion
            }
            else 
            {
                #region –°–µ—Ä–∏–∏
                var cache = await InvokeCache<List<(string episode, string id)>>($"animevost:playlist:{uri}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string news = rch.enable ? await rch.Get(uri) : await Http.Get(uri, timeoutSeconds: 10, proxy: proxyManager.Get(), headers: httpHeaders(init));
                    if (news == null)
                    {
                        if (!rch.enable)
                            proxyManager.Refresh();

                        return res.Fail("news");
                    }

                    string data = Regex.Match(news, "var data = ([^\n\r]+)").Groups[1].Value;
                    if (string.IsNullOrEmpty(data))
                    {
                        if (!rch.enable)
                            proxyManager.Refresh();

                        return res.Fail("data");
                    }

                    var match = Regex.Match(data, "\"([^\"]+)\":\"([0-9]+)\",");
                    var links = new List<(string episode, string id)>(match.Length);

                    while (match.Success)
                    {
                        if (!string.IsNullOrWhiteSpace(match.Groups[1].Value) && !string.IsNullOrWhiteSpace(match.Groups[2].Value))
                            links.Add((match.Groups[1].Value, match.Groups[2].Value));

                        match = match.NextMatch();
                    }

                    if (links.Count == 0)
                        return res.Fail("links");

                    return links;
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                return OnResult(cache, () =>
                {
                    var etpl = new EpisodeTpl(cache.Value.Count);
                    string sArhc = s.ToString();

                    foreach (var l in cache.Value)
                    {
                        string link = $"{host}/lite/animevost/video?id={l.id}&title={HttpUtility.UrlEncode(title)}";

                        etpl.Append(l.episode, title, sArhc, Regex.Match(l.episode, "^([0-9]+)").Groups[1].Value, link, "call", streamlink: accsArgs($"{link}&play=true"));
                    }

                    return rjson ? etpl.ToJson() : etpl.ToHtml();

                }, gbcache: !rch.enable);
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/animevost/video")]
        async public ValueTask<ActionResult> Video(int id, string title, bool play)
        {
            var init = await loadKit(AppInit.conf.Animevost);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            reset: 
            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            var cache = await InvokeCache<List<(string l, string q)>>($"animevost:video:{id}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                if (rch.IsNotConnected())
                    return res.Fail(rch.connectionMsg);

                string uri = $"{init.corsHost()}/frame5.php?play={id}&old=1";
                string iframe = rch.enable ? await rch.Get(uri) : await Http.Get(uri, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));

                var links = new List<(string l, string q)>(2);

                string mp4 = Regex.Match(iframe ?? "", "download=\"invoice\"[^>]+href=\"(https?://[^\"]+)\">720p").Groups[1].Value;
                if (!string.IsNullOrEmpty(mp4))
                    links.Add((mp4, "720p"));

                mp4 = Regex.Match(iframe ?? "", "download=\"invoice\"[^>]+href=\"(https?://[^\"]+)\">480p").Groups[1].Value;
                if (!string.IsNullOrEmpty(mp4))
                    links.Add((mp4, "480p"));

                if (links.Count == 0)
                {
                    if (!rch.enable)
                        proxyManager.Refresh();

                    return res.Fail("mp4");
                }

                if (!rch.enable)
                    proxyManager.Success();

                return links;
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            if (cache.IsSuccess && play)
                return Redirect(HostStreamProxy(init, cache.Value[0].l, proxy: proxyManager.Get()));

            return OnResult(cache, () =>
            {
                string link = HostStreamProxy(init, cache.Value[0].l, proxy: proxyManager.Get());
                return VideoTpl.ToJson("play", link, title, vast: init.vast);

            }, gbcache: !rch.enable);
        }
        #endregion
    }
}

```

## File: TorrServer/ApiController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Models.Base;
using System;
using System.Buffers;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Web;

namespace TorrServer.Controllers
{
    public class TorrServerController : BaseController
    {
        #region ts.js
        [HttpGet]
        [AllowAnonymous]
        [Route("ts.js")]
        [Route("ts/js/{token}")]
        public ActionResult Plugin(string token)
        {
            string file = FileCache.ReadAllText("plugins/ts.js").Replace("{localhost}", Regex.Replace(host, "^https?://", ""));

            if (!string.IsNullOrEmpty(token))
                file = Regex.Replace(file, "Lampa.Storage.set\\('torrserver_login'[^\n\r]+", $"Lampa.Storage.set('torrserver_login','{HttpUtility.UrlEncode(token)}');");

            return Content(file, "application/javascript; charset=utf-8");
        }
        #endregion

        #region HttpClient
        private static readonly HttpClient httpClient = new HttpClient(new SocketsHttpHandler
        {
            AllowAutoRedirect = true,
            AutomaticDecompression = DecompressionMethods.None,
            SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
            MaxConnectionsPerServer = 100
        })
        {
            BaseAddress = new Uri($"http://{AppInit.conf.listen.localhost}:{ModInit.tsport}"),
            DefaultRequestHeaders =
            {
                Authorization = new AuthenticationHeaderValue("Basic", CrypTo.Base64($"ts:{ModInit.tspass}")),
            },
            Timeout = TimeSpan.FromSeconds(30)
        };
        #endregion


        #region Main
        [Route("ts")]
        [Route("ts/static/js/{suffix}")]
        async public Task<ActionResult> Main()
        {
            string html = null;
            string pathRequest = Regex.Replace(HttpContext.Request.Path.Value, "^/ts", "");

            try
            {
                var responseMessage = await httpClient.GetAsync(pathRequest + HttpContext.Request.QueryString.Value).ConfigureAwait(false);
                html = await responseMessage.Content.ReadAsStringAsync().ConfigureAwait(false);
            }
            catch { }

            if (html == null)
                return StatusCode(500);

            if (pathRequest.Contains(".js"))
            {
                string key = Regex.Match(html, "\\.concat\\(([^,]+),\"/echo\"").Groups[1].Value;
                html = html.Replace($".concat({key},\"/", $".concat({key},\"/ts/");
                return Content(html, "application/javascript; charset=utf-8");
            }
            else
            {
                html = html.Replace("href=\"/", "href=\"/ts/").Replace("src=\"/", "src=\"/ts/");
                html = html.Replace("src=\"./", "src=\"/ts/");
                return Content(html, "text/html; charset=utf-8");
            }
        }
        #endregion

        #region TorAPI
        [Route("ts/{*suffix}")]
        async public Task Index()
        {
            if (HttpContext.Request.Path.Value.StartsWith("/shutdown"))
            {
                HttpContext.Response.StatusCode = 404;
                return;
            }

            if (AppInit.conf.accsdb.enable)
            {
                #region –û–±—Ä–∞–±–æ—Ç–∫–∞ stream –ø–æ—Ç–æ–∫–∞
                if (HttpContext.Request.Method == "GET" && Regex.IsMatch(HttpContext.Request.Path.Value, "^/ts/(stream|play)"))
                {
                    await TorAPI().ConfigureAwait(false);
                    return;

                    //if (ModInit.clientIps.Contains(HttpContext.Connection.RemoteIpAddress.ToString()))
                    //{
                    //    await TorAPI();
                    //    return;
                    //}
                    //else
                    //{
                    //    HttpContext.Response.StatusCode = 404;
                    //    return;
                    //}
                }
                #endregion

                #region Access-Control-Request-Headers
                if (HttpContext.Request.Method == "OPTIONS" && HttpContext.Request.Headers.TryGetValue("Access-Control-Request-Headers", out var AccessControl) && AccessControl == "authorization")
                {
                    HttpContext.Response.StatusCode = 204;
                    return;
                }
                #endregion

                if (HttpContext.Request.Headers.TryGetValue("Authorization", out var Authorization))
                {
                    byte[] data = Convert.FromBase64String(Authorization.ToString().Replace("Basic ", ""));
                    string[] decodedString = Encoding.UTF8.GetString(data).Split(":");

                    string login = decodedString[0].ToLower().Trim();
                    string passwd = decodedString[1];

                    if (AppInit.conf.accsdb.findUser(login) is AccsUser user && !user.ban && user.expires > DateTime.UtcNow && passwd == ModInit.conf.defaultPasswd)
                    {
                        if (ModInit.conf.group > user.group)
                        {
                            await HttpContext.Response.WriteAsync("NoAccessGroup", HttpContext.RequestAborted).ConfigureAwait(false);
                            return;
                        }

                        await TorAPI(user).ConfigureAwait(false);
                        return;
                    }
                }

                if (HttpContext.Request.Path.Value.StartsWith("/ts/echo"))
                {
                    await HttpContext.Response.WriteAsync("MatriX.API", HttpContext.RequestAborted).ConfigureAwait(false);
                    return;
                }

                HttpContext.Response.StatusCode = 401;
                HttpContext.Response.Headers["Www-Authenticate"] = "Basic realm=Authorization Required";
                return;
            }
            else
            {
                await TorAPI().ConfigureAwait(false);
                return;
            }
        }

        async public Task TorAPI(AccsUser user = null)
        {
            string pathRequest = Regex.Replace(HttpContext.Request.Path.Value, "^/ts", "");
            string servUri = $"http://{AppInit.conf.listen.localhost}:{ModInit.tsport}{pathRequest + HttpContext.Request.QueryString.Value}";

            #region settings
            if (pathRequest.StartsWith("/settings"))
            {
                if (HttpContext.Request.Method != "POST")
                {
                    HttpContext.Response.StatusCode = 404;
                    await HttpContext.Response.WriteAsync("404 page not found", HttpContext.RequestAborted).ConfigureAwait(false);
                    return;
                }

                using (var reader = new StreamReader(HttpContext.Request.Body, Encoding.UTF8, leaveOpen: true))
                {
                    string requestJson = await reader.ReadToEndAsync().ConfigureAwait(false);

                    if (requestJson.Contains("\"get\""))
                    {
                        var rs = await httpClient.PostAsync("/settings", new StringContent("{\"action\":\"get\"}", Encoding.UTF8, "application/json")).ConfigureAwait(false);
                        await rs.Content.CopyToAsync(HttpContext.Response.Body, HttpContext.RequestAborted).ConfigureAwait(false);
                        return;
                    }
                    else if (!ModInit.conf.rdb || requestInfo.IP == "127.0.0.1" || requestInfo.IP.StartsWith("192.168."))
                    {
                        await httpClient.PostAsync("/settings", new StringContent(requestJson, Encoding.UTF8, "application/json")).ConfigureAwait(false);
                    }

                    await HttpContext.Response.WriteAsync(string.Empty, HttpContext.RequestAborted).ConfigureAwait(false);
                    return;
                }
            }
            #endregion

            #region playlist
            if (pathRequest.StartsWith("/stream/") && HttpContext.Request.QueryString.Value.Contains("&m3u"))
            {
                string m3u = await httpClient.GetStringAsync(servUri).ConfigureAwait(false);
                HttpContext.Response.ContentType = "audio/x-mpegurl; charset=utf-8";
                await HttpContext.Response.WriteAsync((m3u ?? string.Empty).Replace("/stream/", "/ts/stream/"), HttpContext.RequestAborted).ConfigureAwait(false);
                return;
            }
            #endregion

            #region multiaccess
            if (ModInit.conf.multiaccess == "full" || (ModInit.conf.multiaccess == "auth" && user != null))
            {
                if (HttpContext.Request.Method == "POST" && pathRequest == "/torrents" && user?.group != 666)
                {
                    HttpContext.Request.EnableBuffering();
                    using (var readerBody = new StreamReader(HttpContext.Request.Body, Encoding.UTF8, leaveOpen: true)) // –û—Å—Ç–∞–≤–ª—è–µ–º –ø–æ—Ç–æ–∫ –æ—Ç–∫—Ä—ã—Ç—ã–º
                    {
                        string requestJson = await readerBody.ReadToEndAsync().ConfigureAwait(false);

                        if (requestJson.Contains("\"action\":\"add\"") || requestJson.Contains("\"action\":\"list\""))
                        {
                            try
                            {
                                var rs = await httpClient.PostAsync(pathRequest, new StringContent(requestJson, Encoding.UTF8, "application/json")).ConfigureAwait(false);
                                string json = await rs.Content.ReadAsStringAsync().ConfigureAwait(false);

                                string uid = user?.id ?? user?.ids?.FirstOrDefault();
                                HttpContext.Response.ContentType = "application/json; charset=utf-8";

                                if (requestJson.Contains("\"action\":\"add\""))
                                {
                                    #region add
                                    string hash = Regex.Match(json, "\"hash\":\"([^\"]+)\"").Groups[1].Value;
                                    if (!string.IsNullOrEmpty(hash))
                                    {
                                        var doc = ModInit.whosehash.FindById(hash);

                                        if (doc != null)
                                        {
                                            doc.ip = requestInfo.IP;
                                            doc.uid = uid;
                                            ModInit.whosehash.Update(doc);
                                        }
                                        else
                                        {
                                            ModInit.whosehash.Insert(new WhoseHashModel
                                            {
                                                id = hash,
                                                ip = requestInfo.IP,
                                                uid = uid
                                            });
                                        }
                                    }

                                    await HttpContext.Response.WriteAsync(json, HttpContext.RequestAborted).ConfigureAwait(false);
                                    return;
                                    #endregion
                                }
                                else
                                {
                                    #region list
                                    var torrents = JArray.Parse(json);

                                    for (int i = torrents.Count - 1; i >= 0; i--)
                                    {
                                        var hash = torrents[i]["hash"]?.ToString();

                                        if (!string.IsNullOrEmpty(hash))
                                        {
                                            var doc = ModInit.whosehash.FindById(hash);

                                            if (doc != null)
                                            {
                                                if (doc.ip == requestInfo.IP || (doc.uid != null && doc.uid == uid)) { }
                                                else
                                                    torrents.RemoveAt(i);
                                            }
                                        }
                                    }

                                    await HttpContext.Response.WriteAsync(torrents.ToString(), HttpContext.RequestAborted).ConfigureAwait(false);
                                    return;
                                    #endregion
                                }
                            }
                            catch { }

                            HttpContext.Response.StatusCode = 500;
                            await HttpContext.Response.WriteAsync(string.Empty, HttpContext.RequestAborted).ConfigureAwait(false);
                            return;
                        }
                    }

                    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é
                    HttpContext.Request.Body.Position = 0;
                }
            }
            #endregion

            var request = CreateProxyHttpRequest(HttpContext, new Uri(servUri));

            var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead).ConfigureAwait(false);
            await CopyProxyHttpResponse(HttpContext, response).ConfigureAwait(false);
        }
        #endregion


        #region CreateProxyHttpRequest
        HttpRequestMessage CreateProxyHttpRequest(HttpContext context, Uri uri)
        {
            var request = context.Request;

            var requestMessage = new HttpRequestMessage();
            var requestMethod = request.Method;
            if (HttpMethods.IsPost(requestMethod))
            {
                var streamContent = new StreamContent(request.Body);
                requestMessage.Content = streamContent;
            }

            foreach (var header in request.Headers)
            {
                if (header.Key.ToLower() is "authorization")
                    continue;

                if (!requestMessage.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray()) && requestMessage.Content != null)
                    requestMessage.Content?.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray());
            }

            requestMessage.Headers.Host = string.IsNullOrEmpty(AppInit.conf.listen.host) ? context.Request.Host.Value : AppInit.conf.listen.host;
            requestMessage.RequestUri = uri;
            requestMessage.Method = new HttpMethod(request.Method);

            return requestMessage;
        }
        #endregion

        #region CopyProxyHttpResponse
        async Task CopyProxyHttpResponse(HttpContext context, HttpResponseMessage responseMessage)
        {
            var response = context.Response;
            response.StatusCode = (int)responseMessage.StatusCode;

            #region UpdateHeaders
            void UpdateHeaders(HttpHeaders headers)
            {
                foreach (var header in headers)
                {
                    if (header.Key.ToLower() is "transfer-encoding" or "etag" or "connection" or "content-security-policy" or "content-disposition")
                        continue;

                    string value = string.Empty;
                    foreach (var val in header.Value)
                        value += $"; {val}";

                    response.Headers[header.Key] = Regex.Replace(value, "^; ", "");
                    //response.Headers[header.Key] = header.Value.ToArray();
                }
            }
            #endregion

            UpdateHeaders(responseMessage.Headers);
            UpdateHeaders(responseMessage.Content.Headers);

            var responseStream = await responseMessage.Content.ReadAsStreamAsync().ConfigureAwait(false);

            if (response.Body == null)
                throw new ArgumentNullException("destination");

            if (!responseStream.CanRead && !responseStream.CanWrite)
                throw new ObjectDisposedException("ObjectDisposed_StreamClosed");

            if (!response.Body.CanRead && !response.Body.CanWrite)
                throw new ObjectDisposedException("ObjectDisposed_StreamClosed");

            if (!responseStream.CanRead || !response.Body.CanWrite)
                throw new NotSupportedException("NotSupported_UnreadableStream");

            byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);

            try
            {
                int bytesRead;

                while ((bytesRead = await responseStream.ReadAsync(buffer, context.RequestAborted).ConfigureAwait(false)) != 0)
                    await response.Body.WriteAsync(buffer, 0, bytesRead, context.RequestAborted).ConfigureAwait(false);
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
        #endregion
    }
}

```

## File: TorrServer/ModInit.cs
```
Ôªøusing LiteDB;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Engine;
using Shared.Models.Module;
using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace TorrServer
{
    public class ModInit
    {
        #region static
        static bool IsShutdown;

        public static int tsport = 9080;

        public static string tspass = CrypTo.md5(DateTime.Now.ToBinary().ToString());

        public static string homedir;

        public static string tspath;

        public static Process tsprocess;
        #endregion

        #region dataDb
        static LiteDatabase dataDb;

        public static ILiteCollection<WhoseHashModel> whosehash { get; set; }
        #endregion

        #region ModInit
        public string releases { get; set; } = "MatriX.135";

        public bool rdb { get; set; }

        public string defaultPasswd { get; set; } = "ts";

        public int group { get; set; }

        /// <summary>
        /// auth
        /// full
        /// null - desable
        /// </summary>
        public string multiaccess { get; set; } = "auth";

        public bool checkfile { get; set; } = true;


        static (ModInit, DateTime) cacheconf = default;

        public static ModInit conf => cacheconf.Item1;
        #endregion

        #region cron_UpdateSettings
        static Timer _cronTimer;

        static bool _cronWork = false;

        static void cron_UpdateSettings(object state)
        {
            if (_cronWork)
                return;

            _cronWork = true;

            try
            {
                string path = "module/TorrServer.conf";

                if (!File.Exists(path))
                {
                    if (cacheconf.Item1 == null)
                        cacheconf.Item1 = new ModInit();

                    return;
                }

                var lastWriteTime = File.GetLastWriteTime(path);

                if (cacheconf.Item2 != lastWriteTime)
                {
                    cacheconf.Item1 = JsonConvert.DeserializeObject<ModInit>(File.ReadAllText(path));
                    cacheconf.Item2 = lastWriteTime;
                }
            }
            catch { }
            finally
            {
                _cronWork = false;
            }
        }
        #endregion

        #region loaded
        public static void loaded(InitspaceModel initspace)
        {
            RegisterShutdown(initspace);

            _cronTimer = new Timer(cron_UpdateSettings, null, TimeSpan.Zero, TimeSpan.FromSeconds(1));

            dataDb = new LiteDatabase("cache/ts.db");
            whosehash = dataDb.GetCollection<WhoseHashModel>("whosehash");

            #region homedir
            homedir = Directory.GetCurrentDirectory();
            if (string.IsNullOrWhiteSpace(homedir) || homedir == "/")
                homedir = string.Empty;

            homedir = Path.Combine(homedir, "torrserver");
            Directory.CreateDirectory(homedir);
            #endregion

            #region tspath
            tspath = Path.Combine(homedir, "TorrServer-linux");

            if (Environment.OSVersion.Platform == PlatformID.Win32NT)
                tspath = Path.Combine(homedir, "TorrServer-windows-amd64.exe");
            #endregion

            File.WriteAllText(Path.Combine(homedir, "accs.db"), $"{{\"ts\":\"{tspass}\"}}");

            ThreadPool.QueueUserWorkItem(async _ =>
            {
                #region downloadUrl
                string downloadUrl;
                if (Environment.OSVersion.Platform == PlatformID.Win32NT)
                {
                    downloadUrl = "https://github.com/YouROK/TorrServer/releases/latest/download/TorrServer-windows-amd64.exe";
                    if (conf.releases != "latest")
                        downloadUrl = $"https://github.com/YouROK/TorrServer/releases/download/{conf.releases}/TorrServer-windows-amd64.exe";
                }
                else
                {
                    string uname = (await Bash.Run("uname -m")) ?? string.Empty;
                    string arch = uname.Contains("x86_64") ? "amd64" : (uname.Contains("i386") || uname.Contains("i686")) ? "386" : uname.Contains("aarch64") ? "arm64" : uname.Contains("armv7") ? "arm7" : uname.Contains("armv6") ? "arm5" : "amd64";

                    downloadUrl = "https://github.com/YouROK/TorrServer/releases/latest/download/TorrServer-linux-" + arch;
                    if (conf.releases != "latest")
                        downloadUrl = $"https://github.com/YouROK/TorrServer/releases/download/{conf.releases}/TorrServer-linux-" + arch;
                }
                #endregion

                #region updatet/install
                async Task install()
                {
                    try
                    {
                        if (conf.releases == "latest")
                        {
                            var root = await Http.Get<JObject>("https://api.github.com/repos/YouROK/TorrServer/releases/latest");
                            if (root != null && root.ContainsKey("tag_name"))
                            {
                                string tagname = root.Value<string>("tag_name");
                                if (!string.IsNullOrEmpty(tagname))
                                {
                                    if (!File.Exists($"{homedir}/tagname") || tagname != File.ReadAllText($"{homedir}/tagname"))
                                    {
                                        if (File.Exists(tspath))
                                            File.Delete(tspath);

                                        File.WriteAllText($"{homedir}/tagname", tagname);
                                    }
                                }
                            }
                        }

                        if (!File.Exists(tspath))
                        {
                            if (Environment.OSVersion.Platform == PlatformID.Win32NT)
                            {
                                tsprocess?.Dispose();
                                bool success = await Http.DownloadFile(downloadUrl, tspath, timeoutSeconds: 200);
                                if (!success)
                                    File.Delete(tspath);
                            }
                            else
                            {
                                tsprocess?.Dispose();
                                bool success = await Http.DownloadFile(downloadUrl, tspath, timeoutSeconds: 200);
                                if (success)
                                    Bash.Invoke($"chmod +x {tspath}");
                                else
                                    Bash.Invoke($"rm -f {tspath}");
                            }
                        }
                    }
                    catch { }
                }

                await install();

                if (!File.Exists(tspath))
                {
                    await Task.Delay(10_000);
                    await install();
                }

                if (!File.Exists("isdocker") && conf.checkfile)
                {
                    var response = await Http.ResponseHeaders(downloadUrl, timeoutSeconds: 10, allowAutoRedirect: true);
                    if (response != null && response.Content.Headers.ContentLength.HasValue && new FileInfo(tspath).Length != response.Content.Headers.ContentLength.Value)
                    {
                        File.Delete(tspath);
                        await Task.Delay(10_000);
                        await install();
                    }
                }
                #endregion

                while (!IsShutdown && File.Exists(tspath))
                {
                    try
                    {
                        tsprocess = new Process();
                        tsprocess.StartInfo.UseShellExecute = false;
                        tsprocess.StartInfo.RedirectStandardOutput = true;
                        tsprocess.StartInfo.RedirectStandardError = true;
                        tsprocess.StartInfo.FileName = tspath;
                        tsprocess.StartInfo.Arguments = $"--httpauth -p {tsport} -d \"{homedir}\"";

                        tsprocess.Start();

                        tsprocess.OutputDataReceived += (sender, args) => { };
                        tsprocess.ErrorDataReceived += (sender, args) => { };
                        tsprocess.BeginOutputReadLine();
                        tsprocess.BeginErrorReadLine();

                        await tsprocess.WaitForExitAsync();
                    }
                    catch { }

                    await Task.Delay(10_000);
                }
            });
        }
        #endregion


        #region Shutdown
        static void RegisterShutdown(InitspaceModel initspace)
        {
            if (initspace?.app?.ApplicationServices != null)
            {
                var lifetime = initspace.app.ApplicationServices.GetService<IHostApplicationLifetime>();
                lifetime?.ApplicationStopping.Register(StopTranscoding);
            }

            AppDomain.CurrentDomain.ProcessExit += (_, _) => StopTranscoding();
        }

        static void StopTranscoding()
        {
            try
            {
                IsShutdown = true;
                tsprocess?.Kill(true);
                _cronTimer.Dispose();
            }
            catch { }
        }
        #endregion
    }
}

```

## File: TorrServer/WhoseHashModel.cs
```
Ôªøusing LiteDB;

namespace TorrServer
{
    public class WhoseHashModel
    {
        [BsonId]
        public string id { get; set; }

        public string ip { get; set; }

        public string uid { get; set; }

        public string hash { get; set; }
    }
}

```

## File: Merchant/Litecoin.cs
```
Ôªøusing System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Microsoft.Extensions.Caching.Memory;
using System;
using System.Text.RegularExpressions;
using Shared;
using System.Threading;
using IO = System.IO.File;
using System.IO;
using Shared.Engine;
using Shared.Models.Merchant.LtcWallet;
using Shared.Models;

namespace Merchant.Controllers
{
    public class Litecoin : MerchantController
    {
        #region Litecoin
        static Litecoin()
        {
            Directory.CreateDirectory("merchant/invoice/litecoin");
            ThreadPool.QueueUserWorkItem(async _ => await ChekTransactions());
        }
        #endregion

        #region LtcKurs
        async static ValueTask<double> LtcKurs()
        {
            if (!Startup.memoryCache.TryGetValue("Litecoin:kurs:ltc", out double kurs))
            {
                var exmo = await Http.Get<JObject>("https://api.exmo.com/v1.1/ticker");
                var LTC_USD = exmo.GetValue("LTC_USD");

                double avg = LTC_USD.Value<double>("avg");
                double buy_price = LTC_USD.Value<double>("buy_price");

                kurs = avg > buy_price ? buy_price : avg;
                Startup.memoryCache.Set("Litecoin:kurs:ltc", kurs, DateTime.Now.AddMinutes(15));
            }

            return kurs;
        }
        #endregion

        [HttpGet]
        [Route("litecoin/getnewaddress")]
        async public Task<ActionResult> Index(string email)
        {
            if (!AppInit.conf.Merchant.LtcWallet.enable || string.IsNullOrWhiteSpace(email))
                return Content(string.Empty);

            email = decodeEmail(email);
            string pathEmail = $"merchant/invoice/litecoin/{CrypTo.md5(email)}.email";
            double buyprice = await LtcKurs();

            if (IO.Exists(pathEmail))
            {
                return Json(new
                {
                    payinaddress = IO.ReadAllText(pathEmail),
                    buyprice,
                    amount = AppInit.conf.Merchant.accessCost / buyprice
                });
            }
            else
            {
                string json = await Http.Post(AppInit.conf.Merchant.LtcWallet.rpc, "{\"method\": \"getnewaddress\"}", headers: HeadersModel.Init("Authorization", $"Basic {CrypTo.Base64($"{AppInit.conf.Merchant.LtcWallet.rpcuser}:{AppInit.conf.Merchant.LtcWallet.rpcpassword}")}"));

                string payinAddress = Regex.Match(json ?? string.Empty, "\"result\":\"([^\"]+)\"").Groups[1].Value.Trim();

                if (string.IsNullOrWhiteSpace(payinAddress) || !Regex.IsMatch(payinAddress, "^[0-9a-zA-Z]+$") || 20 > payinAddress.Length)
                {
                    return Json(new { });
                }
                else
                {
                    IO.WriteAllText(pathEmail, payinAddress);
                    IO.WriteAllText($"merchant/invoice/litecoin/{payinAddress}.ltc", email);
                }

                return Json(new
                {
                    payinaddress = payinAddress,
                    buyprice,
                    amount = AppInit.conf.Merchant.accessCost / buyprice
                });
            }
        }


        #region ChekTransactions
        async static Task ChekTransactions()
        {
            while (true)
            {
                await Task.Delay(TimeSpan.FromMinutes(1));
                if (!AppInit.conf.Merchant.LtcWallet.enable)
                    continue;

                try
                {
                    double kurs = await LtcKurs();
                    if (kurs == -1)
                        continue;

                    var root = await Http.Post<RootTransactions>(AppInit.conf.Merchant.LtcWallet.rpc, "{\"method\": \"listtransactions\", \"params\": [\"*\", 20]}", headers: HeadersModel.Init("Authorization", $"Basic {CrypTo.Base64($"{AppInit.conf.Merchant.LtcWallet.rpcuser}:{AppInit.conf.Merchant.LtcWallet.rpcpassword}")}"));

                    var transactions = root?.result;
                    if (transactions == null || transactions.Count == 0)
                        continue;

                    foreach (var trans in transactions)
                    {
                        if (trans.category != "receive" || string.IsNullOrWhiteSpace(trans.txid))
                            continue;

                        try
                        {
                            if (IO.Exists($"merchant/invoice/litecoin/{trans.txid}.txid"))
                                continue;

                            string email = IO.ReadAllText($"merchant/invoice/litecoin/{trans.address}.ltc");
                            IO.WriteAllText($"merchant/invoice/litecoin/{trans.txid}.txid", $"{email}\n{trans.address}");

                            double cost = (double)AppInit.conf.Merchant.accessCost / (double)(AppInit.conf.Merchant.accessForMonths * 30);
                            PayConfirm(email, "litecoin", $"{trans.address} - {trans.txid}", days: (int)((trans.amount * kurs) / cost));
                        }
                        catch { }
                    }
                }
                catch { }
            }
        }
        #endregion
    }
}

```

## File: Merchant/CryptoCloud.cs
```
Ôªøusing System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;
using IO = System.IO.File;
using System.IO;
using Microsoft.Extensions.Caching.Memory;
using System;
using Shared;
using Shared.Engine;
using Shared.Models;

namespace Merchant.Controllers
{
    /// <summary>
    /// https://app.cryptocloud.plus/integration/api
    /// </summary>
    public class CryptoCloud : MerchantController
    {
        static CryptoCloud() { Directory.CreateDirectory("merchant/invoice/cryptocloud"); }


        [HttpGet]
        [Route("cryptocloud/invoice/create")]
        async public Task<ActionResult> Index(string email)
        {
            if (!AppInit.conf.Merchant.CryptoCloud.enable || string.IsNullOrWhiteSpace(email))
                return Content(string.Empty);

            email = decodeEmail(email);

            Dictionary<string, string> postParams = new Dictionary<string, string>()
            {
                ["amount"] = AppInit.conf.Merchant.accessCost.ToString(),
                ["shop_id"] = AppInit.conf.Merchant.CryptoCloud.SHOPID,
                //["currency"] = "USD",
                //["order_id"] = CrypTo.md5(DateTime.Now.ToBinary().ToString()),
                ["email"] = email
            };

            if (memoryCache.TryGetValue($"cryptocloud:{email}", out string pay_url))
                return Redirect(pay_url);

            var root = await Http.Post<JObject>("https://api.cryptocloud.plus/v1/invoice/create", new System.Net.Http.FormUrlEncodedContent(postParams), headers: HeadersModel.Init("Authorization", $"Token {AppInit.conf.Merchant.CryptoCloud.APIKEY}"));
            if (root == null || !root.ContainsKey("pay_url"))
                return Content("root == null");

            pay_url = root.Value<string>("pay_url");
            if (string.IsNullOrWhiteSpace(pay_url))
                return Content("pay_url == null");

            memoryCache.Set($"cryptocloud:{email}", pay_url, DateTime.Now.AddHours(2));

            IO.WriteAllText($"merchant/invoice/cryptocloud/{root.Value<string>("invoice_id")}", JsonConvert.SerializeObject(postParams));

            return Redirect(pay_url);
        }


        [HttpPost]
        [Route("cryptocloud/callback")]
        async public Task<ActionResult> Callback(string invoice_id)
        {
            if (!AppInit.conf.Merchant.CryptoCloud.enable || !IO.Exists($"merchant/invoice/cryptocloud/{invoice_id}"))
                return StatusCode(403);

            WriteLog("cryptocloud", JsonConvert.SerializeObject(HttpContext.Request.Form));

            var root = await Http.Get<JObject>("https://api.cryptocloud.plus/v1/invoice/info?uuid=INV-" + invoice_id, headers: HeadersModel.Init("Authorization", $"Token {AppInit.conf.Merchant.CryptoCloud.APIKEY}"));
            if (root == null || root.Value<string>("status") != "success")
                return StatusCode(403);

            if (root.Value<string>("status_invoice") is "paid" or "overpaid")
            {
                var invoice = JsonConvert.DeserializeObject<Dictionary<string, string>>(IO.ReadAllText($"merchant/invoice/cryptocloud/{invoice_id}"));
                PayConfirm(invoice["email"], "cryptocloud", invoice_id);

                return StatusCode(200);
            }

            return StatusCode(403);
        }
    }
}

```

## File: Merchant/MerchantController.cs
```
Ôªøusing Shared;
using Shared.Models.Base;
using System;
using System.Web;

namespace Merchant
{
    public class MerchantController : BaseController
    {
        static DateTime LastWriteTimeUsers = default;

        static string _users = null;

        public static void PayConfirm(string email, string merch, string order, int days = 0)
        {
            var lastWriteTimeUsers = System.IO.File.GetLastWriteTime("merchant/users.txt");

            if (_users == null || LastWriteTimeUsers != lastWriteTimeUsers)
            {
                LastWriteTimeUsers = lastWriteTimeUsers;
                _users = System.IO.File.ReadAllText("merchant/users.txt");
            }

            string users = _users;

            if (!users.Contains($",{merch},{order}"))
            {
                DateTime ex = default;

                if (days > 0)
                {
                    if (AppInit.conf.accsdb.findUser(email) is AccsUser user)
                    {
                        ex = user.expires;
                        ex = ex > DateTime.UtcNow ? ex.AddDays(days) : DateTime.UtcNow.AddDays(days);
                        user.expires = ex;
                        user.group = AppInit.conf.Merchant.defaultGroup;
                    }
                    else
                    {
                        ex = DateTime.UtcNow.AddDays(days);
                        AppInit.conf.accsdb.users.Add(new AccsUser() 
                        {
                            id = email.ToLower().Trim(),
                            expires = ex,
                            group = AppInit.conf.Merchant.defaultGroup
                        });
                    }
                }
                else
                {
                    if (AppInit.conf.accsdb.findUser(email) is AccsUser user)
                    {
                        ex = user.expires;
                        ex = ex > DateTime.UtcNow ? ex.AddMonths(AppInit.conf.Merchant.accessForMonths) : DateTime.UtcNow.AddMonths(AppInit.conf.Merchant.accessForMonths);
                        user.expires = ex;
                        user.group = AppInit.conf.Merchant.defaultGroup;
                    }
                    else
                    {
                        ex = DateTime.UtcNow.AddMonths(AppInit.conf.Merchant.accessForMonths);
                        AppInit.conf.accsdb.users.Add(new AccsUser()
                        {
                            id = email.ToLower().Trim(),
                            expires = ex,
                            group = AppInit.conf.Merchant.defaultGroup
                        });
                    }
                }

                System.IO.File.AppendAllText("merchant/users.txt", $"{email.ToLower().Trim()},{ex.ToFileTimeUtc()},{merch},{order}\n");

                _users += $"{email.ToLower().Trim()},{ex.ToFileTimeUtc()},{merch},{order}\n";
                LastWriteTimeUsers = System.IO.File.GetLastWriteTime("merchant/users.txt");
            }
        }


        public static void WriteLog(string merch, string content)
        {
            try
            {
                System.IO.File.AppendAllText($"merchant/log/{merch}.txt", content + "\n\n\n");
            }
            catch { }
        }


        public static string decodeEmail(string email)
        {
            if (string.IsNullOrEmpty(email))
                return null;    

            return HttpUtility.UrlDecode(email.ToLower().Trim());
        }
    }
}

```

## File: Merchant/MerchApi.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared;

namespace Merchant.Controllers
{
    public class MerchApi : MerchantController
    {
        [HttpGet]
        [Route("merchant/user")]
        public ActionResult Index(string account_email)
        {
            string email = decodeEmail(account_email);
            if (email == null)
                return Json(new { error = true, msg = "email null" });

            var user = AppInit.conf.accsdb.findUser(email);
            if (user == null)
                return Json(new { error = true, msg = "user not found" });

            return Json(new
            {
                user.id,
                user.ids,
                user.ban,
                user.ban_msg,
                user.expires,
                user.group
            });
        }


        [Route("merchant/payconfirm")]
        public ActionResult ConfirmPay(string passwd, string account_email, string merch, string order, int days = 0)
        {
            if (passwd != AppInit.rootPasswd)
                return Content("incorrect passwd");

            string email = decodeEmail(account_email);
            if (email == null)
                return Json(new { error = true, msg = "email null" });

            PayConfirm(email, merch, order, days);

            var user = AppInit.conf.accsdb.findUser(email);
            if (user == null)
                return Json(new { error = true, msg = "user not found" });

            return Json(user);
        }
    }
}

```

## File: Merchant/Streampay.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using System;
using IO = System.IO.File;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Chaos.NaCl;
using System.Text.RegularExpressions;
using System.Linq;
using Microsoft.Extensions.Caching.Memory;
using Shared;

namespace Merchant.Controllers
{
    public class Streampay : MerchantController
    {
        static Streampay() { Directory.CreateDirectory("merchant/invoice/streampay"); }


        [HttpGet]
        [Route("streampay/new")]
        async public Task<ActionResult> Index(string email)
        {
            var init = AppInit.conf.Merchant.Streampay;
            if (!init.enable || string.IsNullOrWhiteSpace(email))
                return Content(string.Empty);

            email = decodeEmail(email);
            string transid = DateTime.Now.ToBinary().ToString().Replace("-", "");

            if (memoryCache.TryGetValue($"streampay:{transid}", out string pay_link))
                return Redirect(pay_link);

            IO.WriteAllText($"merchant/invoice/streampay/{transid}", email);

            var body = new
            {
                init.store_id,
                customer = email,
                external_id = transid,
                description = $"–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ {AppInit.conf.Merchant.accessForMonths} {EndOfText("–º–µ—Å—è—Ü", "–º–µ—Å—è—Ü–∞", "–º–µ—Å—è—Ü–µ–≤", AppInit.conf.Merchant.accessForMonths)}",
                system_currency = "USDT",
                payment_type = 2,
                amount = AppInit.conf.Merchant.accessCost
            };

            var jsonBody = JsonSerializer.Serialize(body);
            string signature = Sign(Encoding.UTF8.GetBytes(jsonBody + DateTime.UtcNow.ToString("yyyyMMdd:HHmm")), init.private_key);

            using (var httpClient = new HttpClient())
            {
                var request = new HttpRequestMessage(HttpMethod.Post, "https://api.streampay.org/api/payment/create")
                {
                    Content = new StringContent(jsonBody, Encoding.UTF8, "application/json")
                };

                request.Headers.Add("signature", signature);

                var response = await httpClient.SendAsync(request);
                if (response.IsSuccessStatusCode)
                {
                    string respData = await response.Content.ReadAsStringAsync();
                    string pay_url = Regex.Match(respData, "\"pay_url\":\"([^\"]+)\"").Groups[1].Value;

                    if (!string.IsNullOrEmpty(pay_url))
                    {
                        memoryCache.Set($"streampay:{transid}", pay_url, DateTime.Now.AddHours(2));
                        return Redirect(pay_url);
                    }

                    return Content(respData);
                }
                else if (response.StatusCode == System.Net.HttpStatusCode.Forbidden)
                {
                    return Content("Invalid signature");
                }
                else if (response.StatusCode == System.Net.HttpStatusCode.NotAcceptable)
                {
                    return Content("Invalid request data");
                }
                else if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
                {
                    return Content("Internal server error");
                }
            }

            return Content("error");
        }


        [HttpGet]
        [Route("streampay/callback")]
        public ActionResult Callback()
        {
            string transid = Request.Query["external_id"].ToString();

            if (Request.Query["status"] != "awaiting_payment")
                memoryCache.Remove($"streampay:{transid}");

            var merchant = AppInit.conf.Merchant;
            if (!merchant.Streampay.enable || !IO.Exists($"merchant/invoice/streampay/{transid}") || Request.Query["status"] != "success")
                return Ok();

            var now = DateTime.UtcNow;
            var queryParams = Request.Query.OrderBy(x => x.Key).Select(x => $"{x.Key}={x.Value}").ToList();
            string paramsStr = string.Join('&', queryParams);
            byte[] paramsBuf = Encoding.UTF8.GetBytes(paramsStr);

            string log = $"{paramsStr}\n{JsonSerializer.Serialize(Request.Headers)}";

            for (int i = 0; i < 2; i++)
            {
                string tm = now.ToString("yyyyMMdd:HHmm");
                var bufToSign = paramsBuf.Concat(Encoding.UTF8.GetBytes(tm)).ToArray();

                bool verify = Verify(Request.Headers["Signature"], bufToSign, merchant.Streampay.public_key);
                log += $"\nverify: {verify} | {tm} | signature: {Request.Headers["Signature"]}";

                if (verify)
                {
                    PayConfirm(IO.ReadAllText($"merchant/invoice/streampay/{transid}"), "streampay", transid);

                    WriteLog("streampay", log + "\nOK");
                    return Ok();
                }

                now = now.AddMinutes(-1);
            }

            WriteLog("streampay", log + "\nForbid");
            return Forbid();
        }



        static string Sign(byte[] message, string privateKey)
        {
            var bytes = Ed25519.Sign(message, HexToBytes(privateKey));

            StringBuilder hex = new StringBuilder(bytes.Length * 2);

            foreach (byte b in bytes)
                hex.AppendFormat("{0:x2}", b);

            return hex.ToString();
        }

        static bool Verify(string signature, byte[] message, string publicKey)
        {
            try
            {
                return Ed25519.Verify(HexToBytes(signature), message, HexToBytes(publicKey));
            }
            catch { return false; }
        }

        static byte[] HexToBytes(string key)
        {
            if (key.Length % 2 != 0)
                return null;

            int byteCount = key.Length / 2;
            byte[] hexKey = new byte[byteCount];

            for (int i = 0; i < byteCount; i++)
            {
                string byteString = key.Substring(i * 2, 2);
                byte keyValue = Convert.ToByte(byteString, 16);
                hexKey[i] = keyValue;
            }

            return hexKey;
        }

        static string EndOfText(string s1, string s2, string s3, int x)
        {
            int n = x % 100;
            if ((n > 10) && (n < 20))
                return s3;

            switch (x % 10)
            {
                case 4: return s2;
                case 0:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9: return s3;
                default: return s1;
            }
        }
    }
}

```

## File: Merchant/FreeKassa.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using System;
using Newtonsoft.Json;
using IO = System.IO.File;
using System.IO;
using Shared.Engine;
using Shared;

namespace Merchant.Controllers
{
    /// <summary>
    /// https://docs.freekassa.ru/
    /// </summary>
    public class FreeKassa : MerchantController
    {
        static FreeKassa() { Directory.CreateDirectory("merchant/invoice/freekassa"); }


        [HttpGet]
        [Route("freekassa/new")]
        public ActionResult Index(string email)
        {
            if (!AppInit.conf.Merchant.FreeKassa.enable || string.IsNullOrWhiteSpace(email))
                return Content(string.Empty);

            string transid = DateTime.Now.ToBinary().ToString().Replace("-", "");

            IO.WriteAllText($"merchant/invoice/freekassa/{transid}", decodeEmail(email));

            string hash = CrypTo.md5($"{AppInit.conf.Merchant.FreeKassa.shop_id}:{AppInit.conf.Merchant.accessCost}:{AppInit.conf.Merchant.FreeKassa.secret}:USD:{transid}");
            return Redirect("https://pay.freekassa.ru/" + $"?m={AppInit.conf.Merchant.FreeKassa.shop_id}&oa={AppInit.conf.Merchant.accessCost}&o={transid}&s={hash}&currency=USD");
        }


        [HttpPost]
        [Route("freekassa/callback")]
        public ActionResult Callback(string AMOUNT, long MERCHANT_ORDER_ID, string SIGN)
        {
            if (!AppInit.conf.Merchant.FreeKassa.enable || !IO.Exists($"merchant/invoice/freekassa/{MERCHANT_ORDER_ID}"))
                return StatusCode(403);

            WriteLog("freekassa", JsonConvert.SerializeObject(HttpContext.Request.Form));

            if (CrypTo.md5($"{AppInit.conf.Merchant.FreeKassa.shop_id}:{AMOUNT}:{AppInit.conf.Merchant.FreeKassa.secret}:{MERCHANT_ORDER_ID}") == SIGN)
            {
                string email = IO.ReadAllText($"merchant/invoice/freekassa/{MERCHANT_ORDER_ID}");
                PayConfirm(email, "freekassa", MERCHANT_ORDER_ID.ToString());

                return Content("YES");
            }

            return Content("SIGN != hash");
        }
    }
}

```

## File: Merchant/B2PAY.cs
```
Ôªøusing System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Microsoft.AspNetCore.Http;
using System.Text;
using IO = System.IO.File;
using System.IO;
using Shared;
using Shared.Engine;

namespace Merchant.Controllers
{
    /// <summary>
    /// https://pay.b2pay.io/merchant/api.php
    /// </summary>
    public class B2PAY : MerchantController
    {
        static B2PAY() { Directory.CreateDirectory("merchant/invoice/b2pay"); }


        [HttpGet]
        [Route("b2pay/new")]
        async public Task<ActionResult> Index(string email)
        {
            if (!AppInit.conf.Merchant.B2PAY.enable || string.IsNullOrWhiteSpace(email))
                return Content(string.Empty);

            Dictionary<string, dynamic> payment = new Dictionary<string, dynamic>() 
            {
                ["amount"] = AppInit.conf.Merchant.accessCost,
                ["currency"] = "USD",
                ["description"] = "Buy Premium",
                ["order_number"] = CrypTo.md5(DateTime.Now.ToBinary().ToString()),
                ["type_payment"] = "merchant",
                ["usr"] = "new",
                ["custom_field"] = decodeEmail(email),
                ["callback_url"] = CrypTo.Base64($"{AppInit.Host(HttpContext)}/b2pay/callback"),
                ["success_url"] = CrypTo.Base64($"{AppInit.Host(HttpContext)}/buy/success.html"),
                ["error_url"] = CrypTo.Base64($"{AppInit.Host(HttpContext)}/buy/error.html")
            };

            payment.Add("signature", CrypTo.Base64(CrypTo.md5binary($"{AppInit.conf.Merchant.accessCost}:{payment["callback_url"]}:{payment["currency"]}:{payment["custom_field"]}:{payment["description"]}:{payment["error_url"]}:{payment["order_number"]}:{payment["success_url"]}:merchant:new:{AppInit.conf.Merchant.B2PAY.encryption_password}")));

            string data = $"payment={CrypTo.Base64(CrypTo.AES256(JsonConvert.SerializeObject(payment), AppInit.conf.Merchant.B2PAY.encryption_password, AppInit.conf.Merchant.B2PAY.encryption_iv))}&id={AppInit.conf.Merchant.B2PAY.username_id}";

            var root = await Http.Post<JObject>(AppInit.conf.Merchant.B2PAY.sandbox ? "https://pay.b2pay.io/api_sandbox/merchantpayments.php" : "https://pay.b2pay.io/api/merchantpayments.php", data);
            if (root == null || !root.ContainsKey("data"))
                return Content("data == null");

            string invoiceurl = root.Value<JObject>("data")?.Value<string>("url");
            if (string.IsNullOrWhiteSpace(invoiceurl))
                return Content("invoiceurl == null");

            IO.WriteAllText($"merchant/invoice/b2pay/{payment["order_number"]}", JsonConvert.SerializeObject(payment));

            return Redirect(invoiceurl);
        }


        [HttpPost]
        [Route("b2pay/callback")]
        async public Task<ActionResult> Callback()
        {
            if (!AppInit.conf.Merchant.B2PAY.enable || HttpContext.Request.Method != HttpMethods.Post || HttpContext.Request.ContentLength == 0)
                return StatusCode(404);

            var buffer = new byte[Convert.ToInt32(HttpContext.Request.ContentLength)];
            await HttpContext.Request.Body.ReadAsync(buffer, 0, buffer.Length);

            var requestContent = Encoding.UTF8.GetString(buffer);
            WriteLog("b2pay", requestContent);

            JObject result = JsonConvert.DeserializeObject<JObject>(requestContent);
            string signature = CrypTo.Base64(CrypTo.md5binary($"{result.Value<string>("amount")}:{result.Value<string>("currency")}:{result.Value<string>("gatewayAmount")}:{result.Value<string>("gatewayCurrency")}:{result.Value<string>("gatewayRate")}:{result.Value<string>("orderNumber")}:{result.Value<string>("pay_id")}:{result.Value<string>("sanitizedMask")}:{result.Value<string>("status")}:{result.Value<string>("token")}:pay:{AppInit.conf.Merchant.B2PAY.encryption_password}"));

            if (result.Value<string>("sign") != signature)
                return StatusCode(401);

            string orderNumber = result.Value<string>("orderNumber");
            if (result.Value<string>("status") != "approved" || string.IsNullOrWhiteSpace(orderNumber) || !IO.Exists($"merchant/invoice/b2pay/{orderNumber}"))
                return StatusCode(403);

            var invoice = JsonConvert.DeserializeObject<Dictionary<string, string>>(IO.ReadAllText($"merchant/invoice/b2pay/{orderNumber}"));
            PayConfirm(invoice["custom_field"], "b2pay", orderNumber);

            return Content("ok");
        }
    }
}

```


```

---

### docs/MATRIX_FULL_PROJECT_CODE.md

```md
# Full Project Code

## ./app/proguard-rules.pro
```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
```

## ./app/build.gradle
```gradle
plugins {
    id("com.android.application")
    id("com.google.devtools.ksp")
    id("com.google.firebase.crashlytics")
    id("com.google.gms.google-services")
    id("org.jetbrains.kotlin.android")
}

android {
    compileSdk 35
    defaultConfig {
        applicationId "ru.yourok.torrserve"
        minSdkVersion 16
        //noinspection ExpiredTargetSdkVersion
        targetSdkVersion 28
        multiDexEnabled true
        versionCode 136
        versionName "MatriX.136.Client"
        setProperty("archivesBaseName", "TorrServe_" + versionName)
        // Use SupportLibrary for vectors
        vectorDrawables.useSupportLibrary = true
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_21
        targetCompatibility JavaVersion.VERSION_21
    }
    packagingOptions {
        resources.excludes += "DebugProbesKt.bin"
    }
    namespace 'ru.yourok.torrserve'
    buildFeatures {
        buildConfig true
    }
}

dependencies {
    def appCompatVersion = '1.6.1' // 1.6.1 last api16 compatible
    //noinspection GradleDependency
    implementation "androidx.appcompat:appcompat:${appCompatVersion}"
    def constraintVersion = '2.1.4' // 2.1.4 last api16 compatible
    //noinspection GradleDependency
    implementation "androidx.constraintlayout:constraintlayout:${constraintVersion}"
    def coreKtxVersion = '1.12.0' // 1.12.0 last api16 compatible
    //noinspection GradleDependency
    implementation "androidx.core:core-ktx:${coreKtxVersion}"
    def lifecycleVersion = '2.6.2' // 2.6.2 last api16 compatible
    //noinspection GradleDependency
    implementation "androidx.lifecycle:lifecycle-livedata-ktx:${lifecycleVersion}"
    //noinspection GradleDependency
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:${lifecycleVersion}"
    //noinspection GradleDependency
    implementation "androidx.lifecycle:lifecycle-runtime-ktx:${lifecycleVersion}"
    //noinspection GradleDependency
    implementation "androidx.lifecycle:lifecycle-process:${lifecycleVersion}"
    // multidex
    implementation 'androidx.multidex:multidex:2.0.1'
    implementation 'androidx.palette:palette-ktx:1.0.0'
    implementation 'androidx.preference:preference-ktx:1.2.1'
    //noinspection GradleDependency
    implementation 'androidx.tvprovider:tvprovider:1.0.0'
    // speed test
    implementation 'com.github.anastr:speedviewlib:1.6.1'
    // glide
    def glideVersion = '4.16.0'
    implementation "com.github.bumptech.glide:glide:${glideVersion}"
    ksp "com.github.bumptech.glide:ksp:${glideVersion}"
    implementation "com.github.bumptech.glide:annotations:${glideVersion}"
    // root shell
    def libsuVersion = '3.2.1' // 3.2.1 last api16 compatible
    //noinspection GradleDependency
    implementation "com.github.topjohnwu.libsu:core:${libsuVersion}"
    def muiVersion = '1.11.0' // 1.11.0 last api16 compatible
    //noinspection GradleDependency
    implementation "com.google.android.material:material:${muiVersion}"
    implementation 'com.google.android.flexbox:flexbox:3.0.0'
    // json serializer
    def jsonVersion = '2.9.1' // 2.10.1 thorow java.lang.VerifyError on api17
    //noinspection GradleDependency
    implementation "com.google.code.gson:gson:${jsonVersion}"
    // firebase
    //noinspection GradleDependency firebase-core:19.0.2 is last api16 compatible
    implementation 'com.google.firebase:firebase-core:19.0.2'
    //noinspection GradleDependency firebase-analytics:19.0.2 is last api16 compatible
    implementation 'com.google.firebase:firebase-analytics:19.0.2'
    //noinspection GradleDependency firebase-crashlytics:18.2.5 is last api16 compatible
    implementation 'com.google.firebase:firebase-crashlytics:18.2.5'
    // SSL
    implementation 'info.guardianproject.netcipher:netcipher:2.1.0'
    implementation 'org.conscrypt:conscrypt-android:2.5.3'
    //noinspection GradleDependency
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.9.0'
    // http client/parser
    def jsoupVersion = '1.16.1' // 1.16.2, 1.17.1, 1.17.2 thorow java.lang.VerifyError on api19
    //noinspection GradleDependency
    implementation "org.jsoup:jsoup:${jsoupVersion}"
}

repositories {
    mavenCentral()
    maven { url 'https://jitpack.io' }
}
```

## ./app/src/main/res/values-v17/themes.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <style name="HeadPreferenceCategoryText" parent="TextAppearance.MaterialComponents.Subtitle1">
        <item name="android:textColor">?attr/colorPrimary</item>
        <item name="android:textAllCaps">true</item>
        <item name="android:textSize">16sp</item>
        <item name="android:paddingTop">32.0dip</item>
        <item name="android:paddingStart">16.0dip</item>
        <item name="android:paddingBottom">16.0dip</item>
    </style>

    <style name="AlertButtonStyle" parent="@style/Widget.MaterialComponents.Button.OutlinedButton">
        <item name="android:layout_marginStart">6dp</item>
        <item name="android:layout_marginEnd">6dp</item>
        <item name="android:layout_marginTop">6dp</item>
        <item name="android:layout_marginBottom">0dp</item>
    </style>

    <style name="MaterialSnackbarButtonTheme" parent="@style/Widget.MaterialComponents.Button.OutlinedButton">
        <item name="android:layout_marginEnd">12dp</item>
        <item name="materialThemeOverlay">@style/WhiteButtonThemeOverlay</item>
        <item name="strokeColor">@color/tv_white</item>
        <item name="strokeWidth">1dp</item>
    </style>
</resources>
```

## ./app/src/main/res/values-ru/strings.xml
```xml
<resources>
    <string name="add">–î–æ–±–∞–≤–∏—Ç—å</string>
    <string name="delete">–£–¥–∞–ª–∏—Ç—å</string>
    <string name="remove_all">–£–¥–∞–ª–∏—Ç—å –≤—Å–µ</string>
    <string name="playlist">–ü–ª–µ–π–ª–∏—Å—Ç</string>
    <string name="donate">–ü–æ–∂–µ—Ä—Ç–≤–æ–≤–∞–Ω–∏–µ</string>
    <string name="update">–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ</string>
    <string name="settings">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</string>
    <string name="exit">–í—ã—Ö–æ–¥</string>
    <string name="exit_title">–•–æ—Ç–∏—Ç–µ –∑–∞–≤–µ—Ä—à–∏—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ?</string>
    <string name="exit_text">–õ–æ–∫–∞–ª—å–Ω—ã–π TorrServer –±—É–¥–µ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ—Å–ª–µ –≤—ã—Ö–æ–¥–∞, –µ—Å–ª–∏ –Ω–µ –≤–∫–ª—é—á–µ–Ω —Å–µ—Ä–≤–∏—Å —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π.</string>
    <string name="remove_all_warn">–í—ã —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å –≤—Å–µ —Ç–æ—Ä—Ä–µ–Ω—Ç—ã?</string>
    <string name="share">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</string>
    <string name="open_torrserve">–ó–∞–ø—É—Å—Ç–∏—Ç—å TorrServe</string>
    <string name="open_with">–û—Ç–∫—Ä—ã—Ç—å —Å –ø–æ–º–æ—â—å—é</string>
    <string name="show_menu">–ü–æ–∫–∞–∑–∞—Ç—å –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</string>
    <string name="torrents">–¢–æ—Ä—Ä–µ–Ω—Ç—ã</string>
    <string name="apply">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</string>
    <string name="skip">–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å</string>
    <string name="yes">–î–∞</string>
    <string name="cancel">–û—Ç–º–µ–Ω–∞</string>
    <string name="default_sets">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é</string>
    <string name="default_sets_applied">–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é</string>
    <string name="cache_size">–†–∞–∑–º–µ—Ä –∫—ç—à–∞ (–ú–µ–≥–∞–±–∞–π—Ç—ã)</string>
    <string name="preload_before_start">–ù–∞–ø–æ–ª–Ω—è—Ç—å –∫–µ—à –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è</string>
    <string name="preload_before_start_desc">–ï—Å–ª–∏ –æ—Ç–∫–ª—é—á–µ–Ω–æ, –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è 32 –ú–ë –±—É—Ñ–µ—Ä –≤ –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–µ</string>
    <string name="torrent_preload" formatted="false">–û–ø–µ—Ä–µ–∂–∞—é—â–∏–π –∫–µ—à (5‚Äì100%, —Ä–µ–∫. 95%)</string>
    <string name="torrent_preload_cache" formatted="false">–ë—É—Ñ–µ—Ä –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∏ (0‚Äì100%)</string>
    <string name="torrent_disconnect_timeout">–¢–∞–π–º-–∞—É—Ç –æ—Ç–∫–ª—é—á–µ–Ω–∏—è —Ç–æ—Ä—Ä–µ–Ω—Ç–∞ (—Å–µ–∫—É–Ω–¥—ã)</string>
    <string name="save_content_path">–ü—É—Ç—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–µ—à–∞</string>
    <string name="save_on_disk">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–µ—à –Ω–∞ –¥–∏—Å–∫–µ</string>
    <string name="save_on_disk_desc">–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤–Ω–µ—à–Ω–∏–µ –Ω–æ—Å–∏—Ç–µ–ª–∏ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö —Å flash-–ø–∞–º—è—Ç—å—é</string>
    <string name="remove_cache_on_drop">–û—á–∏—â–∞—Ç—å –∫–µ—à –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞</string>
    <string name="remove_cache_on_drop_desc">–ï—Å–ª–∏ –æ—Ç–∫–ª—é—á–µ–Ω–æ, —Ñ–∞–π–ª—ã –∫–µ—à–∞ –æ—á–∏—â–∞—é—Ç—Å—è –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞</string>
    <string name="force_encrypt">–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤</string>
    <string name="force_encrypt_desc">–ú–æ–∂–µ—Ç –ø–æ–º–æ—á—å —Å –±–ª–æ–∫–∏—Ä—É—é—â–∏–º–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞–º–∏</string>
    <string name="enable_ipv6">IPv6</string>
    <string name="enable_ipv6_desc">–í–∫–ª—é—á–∏—Ç–µ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è</string>
    <string name="enable_debug">–ü–æ–¥—Ä–æ–±–Ω—ã–π –ª–æ–≥ —Å–µ—Ä–≤–µ—Ä–∞</string>
    <string name="enable_responsive_mode">–í–∫–ª—é—á–∏—Ç—å –±—ã—Å—Ç—Ä—ã–π —Ä–µ–∂–∏–º —á—Ç–µ–Ω–∏—è</string>
    <string name="enable_dlna">DLNA-–º–µ–¥–∏–∞—Å–µ—Ä–≤–µ—Ä</string>
    <string name="dlna_friendly_name">–ò–º—è —Å–µ—Ä–≤–µ—Ä–∞ DLNA</string>
    <string name="dlna_name_hint">–û—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.</string>
    <string name="disable_tcp">TCP - Transmission Control Protocol</string>
    <string name="disable_tcp_desc">–ù–µ –æ—Ç–∫–ª—é—á–∞–π—Ç–µ –±–µ–∑ –≤–∫–ª—é—á–µ–Ω–Ω–æ–≥–æ ŒºTP</string>
    <string name="disable_utp">ŒºTP - Micro Transport Protocol</string>
    <string name="disable_utp_desc">–ù–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –≤–∫–ª—é—á–∞—Ç—å –Ω–∞ —Å–ª–∞–±—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö</string>
    <string name="disable_upnp">UPnP - Universal Plug and Play</string>
    <string name="disable_upnp_desc">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–æ—Ä—Ç–∞ –Ω–∞ —Ä–æ—É—Ç–µ—Ä–µ</string>
    <string name="enable_rutor_search">–í–∫–ª—é—á–∏—Ç—å –ø–æ–∏—Å–∫ –ø–æ RuTor</string>
    <string name="enable_rutor_search_desc">–í–ù–ò–ú–ê–ù–ò–ï: –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –±—É–¥–µ—Ç –∑–∞–Ω–∏–º–∞—Ç—å –æ–∫–æ–ª–æ 500 –ú–ë –≤ –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ–π –ø–∞–º—è—Ç–∏</string>
    <string name="disable_dht">DHT - Distributed Hash Table</string>
    <string name="disable_dht_desc">–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–∞—è —Ö—ç—à-—Ç–∞–±–ª–∏—Ü–∞ - –æ—Ç–∫–ª—é—á–∏—Ç–µ –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ —Å–µ—Ç–∏ –ø–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞</string>
    <string name="disable_pex">PEX - Peer Exchange</string>
    <string name="disable_pex_desc">–û–±–º–µ–Ω —Å–ø–∏—Å–∫–∞–º–∏ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ - –Ω–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –æ—Ç–∫–ª—é—á–∞—Ç—å</string>
    <string name="disable_upload">–û—Ç–¥–∞—á–∞</string>
    <string name="disable_upload_desc">–ù–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –æ—Ç–∫–ª—é—á–∞—Ç—å</string>
    <string name="connections_limit">–¢–æ—Ä—Ä–µ–Ω—Ç-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è 20‚Äì25)</string>
    <string name="connections_dht_limit">–õ–∏–º–∏—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π DHT (0 - –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π)</string>
    <string name="download_rate_limit">–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ –∑–∞–≥—Ä—É–∑–∫–∏ (–ö–∏–ª–æ–±–∞–π—Ç—ã, 0 - –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π)</string>
    <string name="upload_rate_limit">–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ –æ—Ç–¥–∞—á–∏ (–ö–∏–ª–æ–±–∞–π—Ç—ã, 0 - –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π)</string>
    <string name="retrackers">–†–µ—Ç—Ä–µ–∫–µ—Ä—ã</string>
    <string name="peers_listen_port">–ü–æ—Ä—Ç –¥–ª—è –≤—Ö–æ–¥—è—â–∏—Ö –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π (0 - –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)</string>
    <string-array name="retracker_mode">
        <item>–ù–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞—Ç—å</item>
        <item>–î–æ–±–∞–≤–ª—è—Ç—å</item>
        <item>–£–¥–∞–ª—è—Ç—å</item>
        <item>–ó–∞–º–µ–Ω—è—Ç—å</item>
    </string-array>
    <string name="select_player">–í—ã–±–æ—Ä –ø–ª–µ–µ—Ä–∞</string>
    <string name="use_as_default">–ó–∞–ø–æ–º–Ω–∏—Ç—å –≤—ã–±–æ—Ä</string>
    <string name="default_player">–ü–ª–µ–µ—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏–∑ –û–°</string>
    <string name="choose_player">–í—Å–µ–≥–¥–∞ —Å–ø—Ä–∞—à–∏–≤–∞—Ç—å</string>
    <string name="app_theme_title">–¢–µ–º–∞ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è</string>
    <string-array name="app_theme_entries">
        <item>–ö–∞–∫ –≤ —Å–∏—Å—Ç–µ–º–µ</item>
        <item>–°–≤–µ—Ç–ª–∞—è</item>
        <item>–¢—ë–º–Ω–∞—è</item>
        <item>AMOLED</item>
    </string-array>
    <string name="add_play">–î–æ–±. –∏ –∏–≥—Ä–∞—Ç—å</string>
    <string name="play">–ò–≥—Ä–∞—Ç—å</string>
    <string name="play_from_start">–ò–≥—Ä–∞—Ç—å —Å –Ω–∞—á–∞–ª–∞</string>
    <string name="make_as_def">–ó–∞–ø–æ–º–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ</string>
    <string name="reset_def">–î–µ–π—Å—Ç–≤–∏–µ —Å–±—Ä–æ—à–µ–Ω–æ</string>
    <string name="playlist_all">–ò–≥—Ä–∞—Ç—å –≤—Å–µ</string>
    <string name="playlist_continue">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</string>
    <string name="torrent_link">–¢–æ—Ä—Ä–µ–Ω—Ç</string>
    <string name="torrent_link_help">–£–∫–∞–∂–∏—Ç–µ URL —Ç–æ—Ä—Ä–µ–Ω—Ç–∞, magnet-—Å—Å—ã–ª–∫—É –∏–ª–∏ —Ö–µ—à</string>
    <string name="title">–ù–∞–∑–≤–∞–Ω–∏–µ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞</string>
    <string name="poster">–ü–æ—Å—Ç–µ—Ä</string>
    <string name="poster_link">URL –ø–æ—Å—Ç–µ—Ä–∞</string>
    <string name="poster_link_help">–£–∫–∞–∂–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –ø–æ—Å—Ç–µ—Ä (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</string>
    <string name="torrent_category">–ö–∞—Ç–µ–≥–æ—Ä–∏—è</string>
    <string name="torrent_category_help">–£–∫–∞–∂–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–ª—è —Ç–æ—Ä—Ä–µ–Ω—Ç–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</string>
    <string name="local_ip">–õ–æ–∫–∞–ª—å–Ω—ã–π IP</string>
    <string name="connected_host">–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è</string>
    <string name="find_hosts">–ü–æ–∏—Å–∫ —Å–µ—Ä–≤–µ—Ä–æ–≤</string>
    <string name="local_server">–õ–æ–∫–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä</string>
    <string name="saved_server">–°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π —Å–µ—Ä–≤–µ—Ä</string>
    <string name="new_server">–ù–æ–≤—ã–π —Å–µ—Ä–≤–µ—Ä</string>
    <string name="online">–û–Ω–ª–∞–π–Ω</string>
    <string name="buffer">–ë—É—Ñ–µ—Ä</string>
    <string name="peers">–ü–∏—Ä—ã</string>
    <string name="seeds">–°–∏–¥—ã</string>
    <string name="size">–†–∞–∑–º–µ—Ä</string>
    <string name="download_speed">–°–∫–æ—Ä–æ—Å—Ç—å –∑–∞–≥—Ä—É–∑–∫–∏</string>
    <string name="bit_rate">–ë–∏—Ç—Ä–µ–π—Ç</string>
    <string name="found_new_app_update">–ù–∞–π–¥–µ–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è</string>
    <string name="not_found_new_app_update">–ù–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è</string>
    <string name="current_version">–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω</string>
    <string name="new_version">–ù–æ–≤–∞—è –≤–µ—Ä—Å–∏—è</string>
    <string name="server_update">–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–µ—Ä–≤–µ—Ä–∞</string>
    <string name="install_server">–£—Å—Ç–∞–Ω–æ–≤–∫–∞ TorrServer</string>
    <string name="install_server_latest">–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å / –æ–±–Ω–æ–≤–∏—Ç—å —Å–µ—Ä–≤–µ—Ä</string>
    <string name="install_server_local">–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–µ—Ä–≤–µ—Ä –∏–∑ –ø–∞–ø–∫–∏ Download</string>
    <string name="delete_local_server">–£–¥–∞–ª–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä</string>
    <string name="install_ffprobe">–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å FFProbe</string>
    <string name="delete_ffprobe">–£–¥–∞–ª–∏—Ç—å FFProbe</string>
    <string name="ffprobe_summary">–ó–∞–≥—Ä—É–∑–∏—Ç–µ FFProbe –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ –≤–∏–¥–µ–æ, —Ç–∞–∫–∏—Ö –∫–∞–∫ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, –±–∏—Ç—Ä–µ–π—Ç –∏ —Ç.–¥.</string>
    <string name="arch">–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –û–°</string>
    <string name="update_server">–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–µ—Ä–≤–µ—Ä–∞</string>
    <string name="warn_error_check_ver">–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤–µ—Ä—Å–∏–∏ —Å–µ—Ä–≤–µ—Ä–∞</string>
    <string name="warn_error_download_server">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–µ—Ä–≤–µ—Ä–∞</string>
    <string name="warn_no_local_updates">–ù–µ—Ç –ª–æ–∫–∞–ª—å–Ω—ã—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π</string>
    <string name="need_install_server">–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–µ—Ä–≤–µ—Ä</string>
    <string name="need_update_server">–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –æ–±–Ω–æ–≤–∏—Ç—å —Å–µ—Ä–≤–µ—Ä</string>
    <string name="not_support_old_server">–í–µ—Ä—Å–∏—è —Å–µ—Ä–≤–µ—Ä–∞ 1.1.x –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è. –û–±–Ω–æ–≤–∏—Ç–µ —Å–µ—Ä–≤–µ—Ä –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–ª–∏–µ–Ω—Ç 1.1.x —Å –Ω–µ–π.</string>
    <string name="not_support_local_ip">–ù–µ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–π—Ç–µ –ª–æ–∫–∞–ª—å–Ω—ã–π IP-–∞–¥—Ä–µ—Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –≤ –∫–∞—á–µ—Å—Ç–≤–µ URL-–∞–¥—Ä–µ—Å–∞ TorrServer! –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ localhost | 127.0.0.1.</string>
    <string name="not_loaded_exit_hint">–õ–æ–∫–∞–ª—å–Ω—ã–π TorrServer –Ω–µ –∑–∞–ø—É—â–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞–∂–∞—Ç—å ¬´–í—ã—Ö–æ–¥¬ª –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é –∏ —Å–Ω–æ–≤–∞ –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∏–ª–∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ. –ï—Å–ª–∏ –ø–æ—Å–ª–µ —ç—Ç–æ–≥–æ –Ω–∏—á–µ–≥–æ –Ω–µ –∏–∑–º–µ–Ω–∏—Ç—Å—è, –æ–±–Ω–æ–≤–∏—Ç–µ TorrServer –≤ —Ä–∞–∑–¥–µ–ª–µ ¬´–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ¬ª.</string>
    <string name="not_loaded_select_hint">–í—ã–±–µ—Ä–∏—Ç–µ –¥–æ—Å—Ç—É–ø–Ω—ã–π TorrServer –∏–∑ —Å–ø–∏—Å–∫–∞, –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ –∞–¥—Ä–µ—Å –Ω–æ–≤–æ–≥–æ.</string>
    <string name="copy_to_clipboard">–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞</string>
    <string name="stat_running">–õ–æ–∫–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω</string>
    <string name="server_not_responding">TorrServer –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç</string>
    <string name="done_sending_settings">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã</string>
    <string name="loading_torrent">–ó–∞–≥—Ä—É–∑–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–æ—Ä—Ä–µ–Ω—Ç–µ‚Ä¶</string>
    <string name="error_add_torrent">–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å —Ç–æ—Ä—Ä–µ–Ω—Ç</string>
    <string name="error_app_not_found">–ü–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ</string>
    <string name="error_download_ffprobe">–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å FFProbe</string>
    <string name="error_empty_link">–°—Å—ã–ª–∫–∞ –Ω–∞ —Ç–æ—Ä—Ä–µ–Ω—Ç –ø—É—Å—Ç–∞</string>
    <string name="error_intent_null">–ü—É—Å—Ç–æ–π –∏–Ω—Ç–µ–Ω—Ç</string>
    <string name="error_process_intent">–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –ø–ª–µ–µ—Ä–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.</string>
    <string name="error_retrieve_data">–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö</string>
    <string name="error_retrieve_torrent_file">–í —Ç–æ—Ä—Ä–µ–Ω—Ç–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ —Ñ–∞–π–ª–æ–≤ –º—É–ª—å—Ç–∏–º–µ–¥–∏–∞</string>
    <string name="error_retrieve_torrent_info">–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞</string>
    <string name="error_retrieving_settings">–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</string>
    <string name="error_sending_settings">–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</string>
    <string name="error_user_cancel">–û—Ç–º–µ–Ω–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º</string>
    <string name="error_unknown_command">–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞</string>
    <string name="permission_storage_msg">–î–æ—Å—Ç—É–ø –∫ –ø–∞–º—è—Ç–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º –¥–ª—è –∑–∞–ø–∏—Å–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –≤ —Ñ–∞–π–ª</string>
    <string name="permission_btn">–†–ê–ó–†–ï–®–ò–¢–¨</string>
    <string name="permission_deny">–í –¥–æ—Å—Ç—É–ø–µ –æ—Ç–∫–∞–∑–∞–Ω–æ</string>
    <string name="link">–û—Ç–∫—Ä—ã—Ç—å</string>
    <string name="donate_message">TorrServe –±–µ—Å–ø–ª–∞—Ç–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ä–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–æ–∂–µ—Ä—Ç–≤–æ–≤–∞–Ω–∏—è –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –±—É–¥—É—â–µ–≥–æ —Ä–∞–∑–≤–∏—Ç–∏—è TorrServe.</string>
    <string name="boosty_msg">Boosty —Å–∞–π—Ç</string>
    <string name="telegram_msg">–ö–∞–Ω–∞–ª –≤ Telegram</string>
    <string name="app_settings">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è</string>
    <string name="app_version">–í–µ—Ä—Å–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è</string>
    <string name="host_title">–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å URL-–∞–¥—Ä–µ—Å TorrServer</string>
    <string name="host_title_hint">http://localhost:8090¬†‚Äì –¥–ª—è —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ</string>
    <string name="speedtest_title">–¢–µ—Å—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏ –¥–æ TorrServer</string>
    <string name="speedtest_title_desc">–ü—Ä–æ–≤–µ—Ä–∫–∞ c–∫–æ—Ä–æ—Å—Ç–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å TorrServer</string>
    <string name="host_authorization">–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ</string>
    <string name="host_authorization_desc">–í–≤–µ–¥–∏—Ç–µ –∏–º—è –∏ –ø–∞—Ä–æ–ª—å —á–µ—Ä–µ–∑ ¬´:¬ª (user:pass)</string>
    <string name="local_auth_title">–õ–æ–∫–∞–ª—å–Ω—ã–π TorrServer —Å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–µ–π</string>
    <string name="local_auth_sum_on">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –Ω–∞ –ª–æ–∫–∞–ª—å–Ω–æ–º —Å–µ—Ä–≤–µ—Ä–µ</string>
    <string name="local_auth_sum_off">–ù–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –Ω–∞ –ª–æ–∫–∞–ª—å–Ω–æ–º —Å–µ—Ä–≤–µ—Ä–µ</string>
    <string name="torserver_title">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ TorrServer</string>
    <string name="torserver_summary">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ TorrServer</string>
    <string name="remove_action_title">–£–¥–∞–ª–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é</string>
    <string name="remove_action_summary">–°–±—Ä–æ—Å –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å —Ç–æ—Ä—Ä–µ–Ω—Ç–∞–º–∏ –∏ magnet-—Å—Å—ã–ª–∫–∞–º–∏</string>
    <string name="boot_start_title">–ó–∞–ø—É—Å–∫–∞—Ç—å —Å–µ—Ä–≤–µ—Ä –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ</string>
    <string name="boot_start_sum_on">–ó–∞–ø—É—Å–∫–∞—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞</string>
    <string name="boot_start_sum_off">–ù–µ –∑–∞–ø—É—Å–∫–∞—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞</string>
    <string name="root_start_title">–ó–∞–ø—É—Å–∫–∞—Ç—å —Å–µ—Ä–≤–µ—Ä –æ—Ç root</string>
    <string name="root_start_sum_on">–ó–∞–ø—É—Å–∫–∞—Ç—å —Å–µ—Ä–≤–µ—Ä –æ—Ç root, —á—Ç–æ–±—ã —Å–∏—Å—Ç–µ–º–∞ –Ω–µ –º–æ–≥–ª–∞ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –µ–≥–æ</string>
    <string name="root_start_sum_off">–ù–µ –∑–∞–ø—É—Å–∫–∞—Ç—å —Å–µ—Ä–≤–µ—Ä –æ—Ç root</string>
    <string name="choose_player_title">–í—ã–±–æ—Ä –ø–ª–µ–µ—Ä–∞</string>
    <string name="show_banner_title">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –±–∞–Ω–Ω–µ—Ä</string>
    <string name="show_banner_sum_on">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –±–∞–Ω–Ω–µ—Ä –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞</string>
    <string name="show_banner_sum_off">–ù–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –±–∞–Ω–Ω–µ—Ä –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞</string>
    <string name="show_cover_title">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –æ–±–ª–æ–∂–∫–∏</string>
    <string name="show_cover_sum_on">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –æ–±–ª–æ–∂–∫–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤</string>
    <string name="show_cover_sum_off">–ù–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –æ–±–ª–æ–∂–∫–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤</string>
    <string name="sort_torrents_list_title">–°–ø–∏—Å–æ–∫ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤ –ø–æ –∞–ª—Ñ–∞–≤–∏—Ç—É</string>
    <string name="sort_torrents_list_sum_on">–°–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–æ—Ä—Ä–µ–Ω—Ç—ã –ø–æ –∞–ª—Ñ–∞–≤–∏—Ç—É</string>
    <string name="sort_torrents_list_sum_off">–°–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–æ—Ä—Ä–µ–Ω—Ç—ã –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è</string>
    <string name="show_battery_save_tv">–û—Ç–∫–ª—é—á–∏—Ç–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—é –≤ ¬´–ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è¬ª / ¬´–°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –¥–æ—Å—Ç—É–ø¬ª / ¬´–≠–∫–æ–Ω–æ–º–∏—è —ç–Ω–µ—Ä–≥–∏–∏¬ª</string>
    <string name="show_battery_save_title">–ü–æ–∫–∞–∑–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —ç–Ω–µ—Ä–≥–æ—Å–±–µ—Ä–µ–∂–µ–Ω–∏—è</string>
    <string name="show_battery_save_summary">–û—Ç–∫—Ä—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —ç–∫–æ–Ω–æ–º–∏–∏ –∑–∞—Ä—è–¥–∞ –±–∞—Ç–∞—Ä–µ–∏</string>
    <string name="show_fab_title">–ö–Ω–æ–ø–∫–∞ –≤—ã–∑–æ–≤–∞ –º–µ–Ω—é –Ω–∞ —ç–∫—Ä–∞–Ω–µ</string>
    <string name="show_fab_sum_on">–ü–æ–∫–∞–∑–∞—Ç—å –∫–Ω–æ–ø–∫—É –≤—ã–∑–æ–≤–∞ –º–µ–Ω—é</string>
    <string name="show_fab_sum_off">–ù–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫–Ω–æ–ø–∫—É –≤—ã–∑–æ–≤–∞ –º–µ–Ω—é</string>
    <string name="show_sort_fab_title">–ö–Ω–æ–ø–∫–∞ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –Ω–∞ —ç–∫—Ä–∞–Ω–µ</string>
    <string name="show_sort_fab_sum_on">–ü–æ–∫–∞–∑–∞—Ç—å –∫–Ω–æ–ø–∫—É —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ —Å–ø–∏—Å–∫–∞</string>
    <string name="show_sort_fab_sum_off">–ù–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫–Ω–æ–ø–∫—É —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏</string>
    <string name="show_cat_fab_title">–ö–Ω–æ–ø–∫–∞ —Ñ–∏–ª—å—Ç—Ä–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏</string>
    <string name="show_cat_fab_sum_on">–ü–æ–∫–∞–∑–∞—Ç—å –∫–Ω–æ–ø–∫—É —Ñ–∏–ª—å—Ç—Ä–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π</string>
    <string name="show_cat_fab_sum_off">–ù–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫–Ω–æ–ø–∫—É —Ñ–∏–ª—å—Ç—Ä–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π</string>
    <string name="accessibility_manual_on">–í–∫–ª—é—á–∏—Ç–µ —Å–µ—Ä–≤–∏—Å ¬´%1$s¬ª –≤ —Ä–∞–∑–¥–µ–ª–µ ¬´–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞¬ª / ¬´–°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏¬ª</string>
    <string name="accessibility_manual_off">–û—Ç–∫–ª—é—á–∏—Ç–µ —Å–µ—Ä–≤–∏—Å ¬´%1$s¬ª –≤ —Ä–∞–∑–¥–µ–ª–µ ¬´–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞¬ª / ¬´–°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏¬ª</string>
    <string name="accessibility_service_description">–í–∫–ª—é—á–µ–Ω–∏–µ —ç—Ç–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞ –º–æ–∂–µ—Ç –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏—Ç—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ TorrServer —Å–∏—Å—Ç–µ–º–æ–π</string>
    <string name="switch_accessibility_title">C–µ—Ä–≤–∏—Å —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π</string>
    <string name="switch_accessibility_summary_on">–ù–∞–∂–º–∏—Ç–µ –¥–ª—è –æ—Ç–∫–ª—é—á–µ–Ω–∏—è —Å–µ—Ä–≤–∏—Å–∞ TorrServe</string>
    <string name="stat_string_added">–¢–æ—Ä—Ä–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω</string>
    <string name="stat_string_info">–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏</string>
    <string name="stat_string_preload">–ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞</string>
    <string name="stat_string_working">–¢–æ—Ä—Ä–µ–Ω—Ç –∞–∫—Ç–∏–≤–µ–Ω</string>
    <string name="stat_string_closed">–¢–æ—Ä—Ä–µ–Ω—Ç –∑–∞–∫—Ä—ã—Ç</string>
    <string name="stat_string_in_db">–¢–æ—Ä—Ä–µ–Ω—Ç –≤ –ë–î</string>
    <string name="fmt_h">—á.</string>
    <string name="fmt_m">–º.</string>
    <string name="fmt_s">—Å.</string>
    <string name="fmt_p">–ö–ú–ì–¢–ü–≠</string>
    <string name="fmt_b">–ë</string>
    <string name="fmt_bps">–±–∏—Ç/c</string>
    <string name="runtime">–í—Ä–µ–º—è</string>
    <string name="avg">—Å—Ä–µ–¥–Ω.</string>
    <string name="max">–º–∞–∫—Å.</string>
    <string name="sort_by_name">–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é</string>
    <string name="sort_by_size">–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —Ä–∞–∑–º–µ—Ä—É</string>
    <string name="sort_by_seed">–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —Ä–∞–∑–¥–∞—é—â–∏–º</string>
    <string name="sort_by_date">–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –¥–∞—Ç–µ</string>
    <string name="no_data">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</string>
    <string name="no_torrents">–ù–µ—Ç —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤</string>
    <string name="no_updates">–ù–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π</string>
    <string name="not_used">–ù–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è</string>
    <string name="not_installed">–ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω</string>
    <string name="cat_movie">–§–∏–ª—å–º—ã</string>
    <string name="cat_tv">–°–µ—Ä–∏–∞–ª—ã</string>
    <string name="cat_music">–ú—É–∑—ã–∫–∞</string>
    <string name="cat_other">–î—Ä—É–≥–æ–µ</string>
    <string name="cat_none">–í—Å–µ —Ç–æ—Ä—Ä–µ–Ω—Ç—ã</string>
    <string name="accessibility_note">–û—Ç–∫–ª—é—á–∏—Ç–µ —Å–µ—Ä–≤–∏—Å —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π, —á—Ç–æ–±—ã –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å TorrServer.</string>
    <string name="torrserver_log">–ñ—É—Ä–Ω–∞–ª TorrServer</string>
    <string name="torrserver_log_summary">–ü—Ä–æ—Å–º–æ—Ç—Ä –∂—É—Ä–Ω–∞–ª–∞ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ TorrServer</string>
    <string name="torrserver_log_cleared">–ñ—É—Ä–Ω–∞–ª TorrServer –æ—á–∏—â–µ–Ω</string>
    <string name="torrserver_log_trimmed">–õ–æ–≥ –æ–±—Ä–µ–∑–∞–Ω (–ø–æ–∫–∞–∑–∞–Ω—ã –ø–æ—Å–ª–µ–¥–Ω–∏–µ %s)</string>
</resources>
```

## ./app/src/main/res/layout-land/main_activity.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="horizontal">

        <include layout="@layout/navigation_menu" />

        <FrameLayout
            android:id="@+id/container"
            android:layout_width="match_parent"
            android:layout_height="match_parent" />

    </LinearLayout>

    <com.google.android.material.progressindicator.LinearProgressIndicator
        android:id="@+id/progressBar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="top"
        android:indeterminate="true"
        android:visibility="gone"
        app:trackCornerRadius="2dp"
        app:trackThickness="4dp" />

</FrameLayout>
```

## ./app/src/main/res/values-zh-rCN/strings.xml
```xml
<resources>
    <string name="app_name" translatable="false">TorrServe MatriX</string>

    <string name="add">Ê∑ªÂä†</string>
    <string name="rutor" translatable="false">RuTor</string>
    <string name="delete">Âà†Èô§</string>
    <string name="remove_all">ÂÖ®ÈÉ®Âà†Èô§</string>
    <string name="playlist">Êí≠ÊîæÂàóË°®</string>
    <string name="donate">ÊçêËµ†</string>
    <string name="update">Êõ¥Êñ∞</string>
    <string name="settings">ËÆæÁΩÆ</string>
    <string name="exit">ÈÄÄÂá∫</string>

    <string name="exit_title">ÊÇ®Á°ÆÂÆöË¶ÅÈÄÄÂá∫Âêó?</string>
    <string name="exit_text">Â¶ÇÊûúÊú™ÂêØÁî®Êó†ÈöúÁ¢çÊúçÂä°,Êú¨Âú∞ TorrServer Â∞ÜÂú®ÈÄÄÂá∫Êó∂ÂÅúÊ≠¢„ÄÇ</string>

    <string name="remove_all_warn">ÊÇ®Á°ÆÂÆöË¶ÅÂà†Èô§ÊâÄÊúâÁßçÂ≠êÂêó?</string>
    <string name="share">ÂàÜ‰∫´</string>

    <string name="open_torrserve">ÊâìÂºÄ TorrServe</string>
    <string name="open_with">ÊâìÂºÄÊñπÂºè</string>
    <string name="show_menu">ÊòæÁ§∫‰∏ªËèúÂçï</string>
    <string name="torrents">ÁßçÂ≠ê</string>

    <string name="apply">Â∫îÁî®</string>
    <string name="skip">Ë∑≥Ëøá</string>
    <string name="yes">ÊòØ</string>
    <string name="cancel">ÂèñÊ∂à</string>

    <string name="default_sets">ÈªòËÆ§ËÆæÁΩÆ</string>
    <string name="default_sets_applied">Â∑≤Â∫îÁî®ÈªòËÆ§ËÆæÁΩÆ</string>

    <string name="cache_size">ÁºìÂ≠òÂ§ßÂ∞è(ÂÖÜÂ≠óËäÇ)</string>
    <string name="preload_before_start">ÂºÄÂßãÂâçÈ¢ÑÂä†ËΩΩÁºìÂ≠ò</string>
    <string name="preload_before_start_desc">Â¶ÇÊûúÁ¶ÅÁî®,Â∞Ü‰ΩøÁî® 32 MB ÁºìÂÜ≤Âå∫ËøõË°åÈ¢ÑÂä†ËΩΩ</string>
    <string name="torrent_preload" formatted="false">È¢ÑËØªÁºìÂ≠ò(5-100%, Êé®Ëçê 95%)</string>
    <string name="torrent_preload_cache" formatted="false">Êí≠ÊîæÂâçÈ¢ÑÂä†ËΩΩÁºìÂ≠ò(0-100%)</string>
    <string name="torrent_disconnect_timeout">ÁßçÂ≠êÊñ≠ÂºÄËøûÊé•Ë∂ÖÊó∂(Áßí)</string>
    <string name="save_content_path">ÁºìÂ≠òÂ≠òÂÇ®Ë∑ØÂæÑ</string>
    <string name="save_on_disk">‰ΩøÁî®Á£ÅÁõòÁºìÂ≠ò</string>
    <string name="save_on_disk_desc">Âú®Âü∫‰∫éÈó™Â≠òÁöÑËÆæÂ§á‰∏äÊúÄÂ•Ω‰ΩøÁî® RAM ÊàñÂ§ñÈÉ®Â™í‰Ωì</string>
    <string name="remove_cache_on_drop">Âà†Èô§ÁßçÂ≠êÊó∂ÁßªÈô§ÁºìÂ≠ò</string>
    <string name="remove_cache_on_drop_desc">Â¶ÇÊûúÁ¶ÅÁî®,ÁºìÂ≠òÂ∞ÜÂú®‰ªéÊï∞ÊçÆÂ∫ìÂà†Èô§ÁßçÂ≠êÊó∂ÁßªÈô§</string>
    <string name="force_encrypt">Âº∫Âà∂Âä†ÂØÜÊ†áÂ§¥</string>
    <string name="force_encrypt_desc">ÂèØ‰ª•Â∏ÆÂä©Ëß£ÂÜ≥ÊúçÂä°Êèê‰æõÂïÜÂ∞ÅÈîÅÁßçÂ≠êÁöÑÈóÆÈ¢ò</string>
    <string name="enable_ipv6">IPv6</string>
    <string name="enable_ipv6_desc">‰ªÖÂú® ISP ÊîØÊåÅÊó∂ÂêØÁî®</string>
    <string name="enable_debug">ÂêØÁî® TorrServer Ë∞ÉËØïÊó•Âøó</string>
    <string name="enable_responsive_mode">ÂêØÁî®ÂìçÂ∫îÂºèÈòÖËØªÂô®Ê®°Âºè</string>
    <string name="enable_dlna">DLNA Â™í‰ΩìÊúçÂä°Âô®</string>
    <string name="dlna_friendly_name">DLNA ÊúçÂä°Âô®ÂêçÁß∞</string>
    <string name="dlna_name_hint">ÁïôÁ©∫‰ª•‰ΩøÁî®ÈªòËÆ§ÂêçÁß∞</string>
    <string name="disable_tcp">TCP - ‰º†ËæìÊéßÂà∂ÂçèËÆÆ</string>
    <string name="disable_tcp_desc">Ê≤°ÊúâÂêØÁî® ŒºTP Êó∂‰∏çË¶ÅÁ¶ÅÁî®</string>
    <string name="disable_utp">ŒºTP - ÂæÆ‰º†ËæìÂçèËÆÆ</string>
    <string name="disable_utp_desc">‰∏çÂª∫ËÆÆÂú®ÊÄßËÉΩËæÉÂº±ÁöÑËÆæÂ§á‰∏äÂêØÁî®</string>
    <string name="disable_upnp">UPnP - ÈÄöÁî®Âç≥ÊèíÂç≥Áî®</string>
    <string name="disable_upnp_desc">Âú®Ë∑ØÁî±Âô®‰∏äËá™Âä®ÊâìÂºÄÁ´ØÂè£</string>
    <string name="enable_rutor_search">ÂêØÁî® Rutor ÁßçÂ≠êÊêúÁ¥¢</string>
    <string name="enable_rutor_search_desc">Ê≥®ÊÑè:ÁßçÂ≠êÊï∞ÊçÆÂ∫ìÂ∞ÜÂç†Áî®Á∫¶ 500 MB ÁöÑ RAM</string>
    <string name="disable_dht">DHT - ÂàÜÂ∏ÉÂºèÂìàÂ∏åË°®</string>
    <string name="disable_dht_desc">Â¶ÇÊûúÂêØÂä®ÊúçÂä°Âô®ÂêéÊ≤°ÊúâÁΩëÁªúËøûÊé•,ËØ∑Á¶ÅÁî®</string>
    <string name="disable_pex">PEX - ÂØπÁ≠â‰∫§Êç¢</string>
    <string name="disable_pex_desc">ÊúÄÂ•Ω‰øùÊåÅÂêØÁî®</string>
    <string name="disable_upload">‰∏ä‰º†</string>
    <string name="disable_upload_desc">‰∏çÂª∫ËÆÆÁ¶ÅÁî®</string>
    <string name="connections_limit">ÁßçÂ≠êËøûÊé•Êï∞(Âª∫ËÆÆ 20-25)</string>
    <string name="connections_dht_limit">DHT ËøûÊé•Êï∞ÈôêÂà∂(0 - Êó†ÈôêÂà∂)</string>
    <string name="download_rate_limit">‰∏ãËΩΩÈÄüÂ∫¶ÈôêÂà∂(ÂçÉÂ≠óËäÇ,0 - Êó†ÈôêÂà∂)</string>
    <string name="upload_rate_limit">‰∏ä‰º†ÈÄüÂ∫¶ÈôêÂà∂(ÂçÉÂ≠óËäÇ,0 - Êó†ÈôêÂà∂)</string>
    <string name="retrackers">ÈáçÊñ∞Ë∑üË∏™Âô®</string>
    <string name="peers_listen_port">ÂØπÁ≠âÁõëÂê¨Á´ØÂè£(0 - ÈªòËÆ§)</string>
    <string-array name="retracker_mode">
        <item>ÈªòËÆ§</item>
        <item>Ê∑ªÂä†ÈáçÊñ∞Ë∑üË∏™Âô®</item>
        <item>ÁßªÈô§ÈáçÊñ∞Ë∑üË∏™Âô®</item>
        <item>ÊõøÊç¢ÈáçÊñ∞Ë∑üË∏™Âô®</item>
    </string-array>

    <string name="select_player">ÈÄâÊã©Êí≠ÊîæÂô®</string>
    <string name="use_as_default">‰øùÂ≠ò‰∏∫ÈªòËÆ§</string>
    <string name="default_player">Á≥ªÁªüÈªòËÆ§Êí≠ÊîæÂô®</string>
    <string name="choose_player">ÊÄªÊòØËØ¢ÈóÆ</string>
    <string name="player_pref_key" translatable="false">player</string>

    <string name="app_theme_title">Â∫îÁî®‰∏ªÈ¢ò</string>
    <string-array name="app_theme_entries">
        <item>Ëá™Âä®</item>
        <item>‰∫ÆËâ≤</item>
        <item>ÊöóËâ≤</item>
        <item>AMOLED</item>
    </string-array>
    <string-array name="app_theme_entries_values" translatable="false">
        <item>auto</item>
        <item>light</item>
        <item>dark</item>
        <item>black</item>
    </string-array>

    <string name="add_play">Ê∑ªÂä†Âπ∂Êí≠Êîæ</string>
    <string name="play">Êí≠Êîæ</string>
    <string name="play_from_start">‰ªéÂ§¥ÂºÄÂßãÊí≠Êîæ</string>

    <string name="make_as_def">ËÆæ‰∏∫ÈªòËÆ§</string>
    <string name="reset_def">ÈªòËÆ§ÂÄºÂ∑≤Ê∏ÖÈô§</string>

    <string name="playlist_all">ÂÖ®ÈÉ®Êí≠Êîæ</string>
    <string name="playlist_continue">ÁªßÁª≠Êí≠Êîæ</string>

    <string name="torrent_link">ÁßçÂ≠êÈìæÊé•</string>
    <string name="torrent_link_help">ËæìÂÖ•ÁßçÂ≠ê URL / Á£ÅÂäõÈìæÊé• / ÂìàÂ∏å</string>
    <string name="title">Ê†áÈ¢ò</string>
    <string name="poster">Êµ∑Êä•</string>
    <string name="poster_link">Êµ∑Êä•ÈìæÊé•</string>
    <string name="poster_link_help">ËæìÂÖ•Êµ∑Êä• URL(ÂèØÈÄâ)</string>
    <string name="torrent_category">ÂàÜÁ±ª</string>
    <string name="torrent_category_help">ËÆæÁΩÆÁßçÂ≠êÂàÜÁ±ª(ÂèØÈÄâ)</string>

    <string name="local_ip">Êú¨Âú∞ IP</string>
    <string name="connected_host">Â∑≤ËøûÊé•</string>
    <string name="find_hosts">Êü•Êâæ‰∏ªÊú∫</string>
    <string name="local_server">Êú¨Âú∞ÊúçÂä°Âô®</string>
    <string name="saved_server">Â∑≤‰øùÂ≠òÁöÑÊúçÂä°Âô®</string>
    <string name="new_server">Êñ∞ÊúçÂä°Âô®</string>
    <string name="online">Âú®Á∫ø</string>

    <string name="buffer">ÁºìÂÜ≤</string>
    <string name="peers">ËøûÊé•Êï∞</string>
    <string name="seeds">ÁßçÂ≠êÊï∞</string>
    <string name="size">Â§ßÂ∞è</string>
    <string name="download_speed">‰∏ãËΩΩÈÄüÂ∫¶</string>
    <string name="bit_rate">ÊØîÁâπÁéá</string>

    <string name="found_new_app_update">ÂèëÁé∞Â∫îÁî®Êõ¥Êñ∞</string>
    <string name="not_found_new_app_update">Êú™ÊâæÂà∞Â∫îÁî®Êõ¥Êñ∞</string>
    <string name="current_version">ÂΩìÂâçÁâàÊú¨</string>
    <string name="new_version">Êñ∞ÁâàÊú¨</string>

    <string name="server_update">TorrServer Êõ¥Êñ∞</string>
    <string name="install_server">ÂÆâË£Ö TorrServer</string>
    <string name="install_server_latest">ÂÆâË£Ö/Êõ¥Êñ∞ÊúçÂä°Âô®</string>
    <string name="install_server_local">‰ªé‰∏ãËΩΩÊñá‰ª∂Â§πÂÆâË£ÖÊúçÂä°Âô®</string>
    <string name="delete_local_server">Âà†Èô§Êú¨Âú∞ÊúçÂä°Âô®</string>
    <string name="install_ffprobe">ÂÆâË£Ö FFProbe</string>
    <string name="delete_ffprobe">Âà†Èô§ FFProbe</string>
    <string name="ffprobe_summary">‰∏ãËΩΩ FFProbe ‰ª•Ëé∑ÂèñÈ¢ùÂ§ñÁöÑËßÜÈ¢ëÊï∞ÊçÆ,Â¶ÇÊó∂Èïø„ÄÅÊØîÁâπÁéáÁ≠â</string>
    <string name="arch">Êû∂ÊûÑ</string>
    <string name="update_server">Êõ¥Êñ∞ÁâàÊú¨</string>
    <string name="warn_error_check_ver">ÁâàÊú¨Ê£ÄÊü•ÈîôËØØ</string>
    <string name="warn_error_download_server">ÊúçÂä°Âô®‰∏ãËΩΩÈîôËØØ</string>
    <string name="warn_no_local_updates">Êú™ÊâæÂà∞Êú¨Âú∞Êõ¥Êñ∞</string>
    <string name="need_install_server">ÈúÄË¶ÅÂÆâË£ÖÊúçÂä°Âô®</string>
    <string name="need_update_server">ÈúÄË¶ÅÊõ¥Êñ∞ÊúçÂä°Âô®</string>
    <string name="not_support_old_server">‰∏çÊîØÊåÅ 1.1.x ÁâàÊú¨ÁöÑÊúçÂä°Âô®„ÄÇËØ∑Êõ¥Êñ∞ÊúçÂä°Âô®Êàñ‰ΩøÁî® 1.1.x ÁâàÊú¨ÁöÑÂÆ¢Êà∑Á´Ø„ÄÇ</string>
    <string name="not_support_local_ip">ËØ∑‰∏çË¶ÅÂ∞ÜÊú¨Âú∞ËÆæÂ§á IP ËÆæÁΩÆ‰∏∫ torrserver URL! ËØ∑‰ΩøÁî® localhost | 127.0.0.1 ‰ª£Êõø„ÄÇ</string>
    <string name="not_loaded_exit_hint">Êú¨Âú∞ TorrServer Êú™ËøêË°å„ÄÇÂ∞ùËØïÂú®‰∏ªËèúÂçï‰∏≠ÁÇπÂáª‚ÄúÈÄÄÂá∫‚ÄùÂπ∂ÂÜçÊ¨°ÂêØÂä®Â∫îÁî®Á®ãÂ∫è,ÊàñÈáçÂêØËÆæÂ§á„ÄÇÂ¶ÇÊûúËøôÊ†∑ÂÅöÂêéÊÉÖÂÜµÊ≤°ÊúâÊîπÂèò,ËØ∑Âú®‚ÄúÊõ¥Êñ∞‚ÄùÈÉ®ÂàÜ‰∏≠Êõ¥Êñ∞ TorrServer„ÄÇ</string>
    <string name="not_loaded_select_hint">‰ªéÂàóË°®‰∏≠ÈÄâÊã©‰∏Ä‰∏™ÂèØÁî®ÁöÑ TorrServer,ÊàñÊåáÂÆö‰∏Ä‰∏™Êñ∞ÁöÑÂú∞ÂùÄ„ÄÇ</string>
    <string name="copy_to_clipboard">Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø</string>
    <string name="stat_running">ÊúçÂä°Ê≠£Âú®ËøêË°å</string>
    <string name="server_not_responding">TorrServer Êú™ÂìçÂ∫î</string>
    <string name="done_sending_settings">ËÆæÁΩÆÂ∑≤‰øùÂ≠ò</string>

    <string name="loading_torrent">Ëé∑ÂèñÁßçÂ≠ê‰ø°ÊÅØ...</string>

    <string name="error_add_torrent">Ê∑ªÂä†ÁßçÂ≠êÊó∂Âá∫Èîô</string>
    <string name="error_app_not_found">Êú™ÊâæÂà∞ÂêàÈÄÇÁöÑÂ∫îÁî®Á®ãÂ∫è</string>
    <string name="error_download_ffprobe">FFProbe ‰∏ãËΩΩÈîôËØØ</string>
    <string name="error_empty_link">ÁßçÂ≠êÈìæÊé•‰∏∫Á©∫</string>
    <string name="error_intent_null">Intent ‰∏∫Á©∫</string>
    <string name="error_process_intent">ÊâìÂºÄÊí≠ÊîæÂô®Êó∂Âá∫Èîô„ÄÇËØ∑Ê£ÄÊü•ËÆæÁΩÆ„ÄÇ</string>
    <string name="error_retrieve_data">Ëé∑ÂèñÊï∞ÊçÆÊó∂Âá∫Èîô</string>
    <string name="error_retrieve_torrent_file">Êú™ÊâæÂà∞ÂèØÊí≠ÊîæÁöÑÊñá‰ª∂</string>
    <string name="error_retrieve_torrent_info">Ëé∑ÂèñÁßçÂ≠ê‰ø°ÊÅØÊó∂Âá∫Èîô</string>
    <string name="error_retrieving_settings">Ëé∑ÂèñËÆæÁΩÆÊó∂Âá∫Èîô</string>
    <string name="error_sending_settings">ÂèëÈÄÅËÆæÁΩÆÊó∂Âá∫Èîô</string>
    <string name="error_user_cancel">Áî®Êà∑ÂÅúÊ≠¢</string>
    <string name="error_unknown_command">Êú™Áü•ÂëΩ‰ª§</string>

    <string name="permission_storage_msg">ÈúÄË¶ÅËÆøÈóÆÂ≠òÂÇ®ÊùÉÈôê‰ª•Â∞ÜËÆæÁΩÆÂÜôÂÖ•Êñá‰ª∂</string>
    <string name="permission_btn">ÊéàÊùÉ</string>
    <string name="permission_deny">ÊùÉÈôêË¢´ÊãíÁªù</string>

    <string name="link">ÈìæÊé•</string>
    <string name="donate_message">TorrServe ÊòØÂÖçË¥πÁöÑ„ÄÇËØ∑ËÄÉËôëÊçêËµ†‰ª•ÊîØÊåÅ TorrServe ÁöÑÊú™Êù•ÂºÄÂèë„ÄÇ</string>
    <string name="boosty_msg">Boosty ÁΩëÁ´ô</string>
    <string name="yandex_money_card" translatable="false">5599 0050 6424 4747</string>
    <string name="telegram_msg">Telegram È¢ëÈÅì</string>

    <!--    ËÆæÁΩÆ    -->
    <string name="app_settings">Â∫îÁî®ËÆæÁΩÆ</string>
    <string name="app_version">Â∫îÁî®ÁâàÊú¨</string>

    <string name="host_title">ËÆæÁΩÆ TorrServer URL</string>
    <string name="host_title_hint">http://localhost:8090 - Áî®‰∫éËÆæÂ§á‰∏äÁöÑÊúçÂä°Âô®</string>

    <string name="speedtest_title">TorrServer ÈÄüÂ∫¶ÊµãËØï</string>
    <string name="speedtest_title_desc">ÊµãËØïÂà∞ TorrServer ÁöÑÈÄüÂ∫¶</string>

    <string name="host_authorization">ÊúçÂä°Âô®ÊéàÊùÉ</string>
    <string name="host_authorization_desc">ËæìÂÖ•Áî®ÂÜíÂè∑ÂàÜÈöîÁöÑÁî®Êà∑ÂêçÂíåÂØÜÁ†Å(user:password),ÁïôÁ©∫Ë°®Á§∫Êó†ÈúÄÊéàÊùÉ„ÄÇ</string>
    <string name="local_auth_title">Êú¨Âú∞ TorrServer ÈúÄË¶ÅÊéàÊùÉ</string>
    <string name="local_auth_sum_on">Âú®Êú¨Âú∞ÊúçÂä°Âô®‰∏ä‰ΩøÁî®ÊéàÊùÉ</string>
    <string name="local_auth_sum_off">‰∏çÂú®Êú¨Âú∞ÊúçÂä°Âô®‰∏ä‰ΩøÁî®ÊéàÊùÉ</string>

    <string name="torserver_title">TorrServer ËÆæÁΩÆ</string>
    <string name="torserver_summary">ÈÖçÁΩÆ TorrServer ËÆæÁΩÆ</string>

    <string name="remove_action_title">Ê∏ÖÈô§Êìç‰ΩúÈªòËÆ§ÂÄº</string>
    <string name="remove_action_summary">ÈáçÁΩÆÁßçÂ≠êÁöÑÈªòËÆ§Á≥ªÁªüÂ∫îÁî®Á®ãÂ∫è</string>

    <string name="boot_start_title">ÂºÄÊú∫ÂêØÂä®ÊúçÂä°Âô®</string>
    <string name="boot_start_sum_on">Â∑≤ÂêØÁî®ÂºÄÊú∫ÂêØÂä®ÊúçÂä°Âô®</string>
    <string name="boot_start_sum_off">Â∑≤Á¶ÅÁî®ÂºÄÊú∫ÂêØÂä®ÊúçÂä°Âô®</string>

    <string name="root_start_title">‰ª• root ÊùÉÈôêÂêØÂä®ÊúçÂä°Âô®</string>
    <string name="root_start_sum_on">Â∑≤ÂêØÁî®‰ª• root ÊùÉÈôêÂêØÂä®ÊúçÂä°Âô®</string>
    <string name="root_start_sum_off">Â∑≤Á¶ÅÁî®‰ª• root ÊùÉÈôêÂêØÂä®ÊúçÂä°Âô®</string>

    <string name="choose_player_title">ÈÄâÊã©Êí≠ÊîæÂô®</string>

    <string name="show_banner_title">ÊòæÁ§∫Ê®™ÂπÖ</string>

    <string name="show_banner_sum_on">Âä†ËΩΩÁßçÂ≠êÊó∂ÊòæÁ§∫Ê®™ÂπÖ</string>
    <string name="show_banner_sum_off">Âä†ËΩΩÁßçÂ≠êÊó∂‰∏çÊòæÁ§∫Ê®™ÂπÖ</string>

    <string name="show_cover_title">ÊòæÁ§∫Êµ∑Êä•</string>
    <string name="show_cover_sum_on">ÊòæÁ§∫ÁßçÂ≠êÊµ∑Êä•</string>
    <string name="show_cover_sum_off">‰∏çÊòæÁ§∫ÁßçÂ≠êÊµ∑Êä•</string>

    <string name="sort_torrents_list_title">ÊåâÂ≠óÊØçÈ°∫Â∫èÊéíÂ∫èÁßçÂ≠êÂàóË°®</string>
    <string name="sort_torrents_list_sum_on">ÊåâÂ≠óÊØçÈ°∫Â∫èÊéíÂ∫èÁßçÂ≠ê</string>
    <string name="sort_torrents_list_sum_off">ÊåâÊ∑ªÂä†Êó∂Èó¥ÊéíÂ∫èÁßçÂ≠ê</string>

    <string name="show_battery_save_tv">Âú®Â∫îÁî®Á®ãÂ∫è/ÁâπÊÆäÂ∫îÁî®ËÆøÈóÆ/ËäÇËÉΩ‰ºòÂåñ‰∏≠Á¶ÅÁî®ÁîµÊ±†ËäÇÁúÅ</string>
    <string name="show_battery_save_title">ÊòæÁ§∫ÁîµÊ±†ËäÇÁúÅËÆæÁΩÆ</string>
    <string name="show_battery_save_summary">ÊâìÂºÄÂ∏¶ÊúâÁîµÊ±†ËäÇÁúÅÈÖçÁΩÆÁöÑËÆæÁΩÆ</string>

    <string name="show_fab_title">Á´ñÂ±èÊó∂ÊòæÁ§∫ÊµÆÂä®ËèúÂçïÊåâÈíÆ</string>
    <string name="show_fab_sum_on">ÊòæÁ§∫ÊµÆÂä®Êìç‰ΩúÊåâÈíÆ</string>
    <string name="show_fab_sum_off">‰∏çÊòæÁ§∫ÊµÆÂä®Êìç‰ΩúÊåâÈíÆ</string>

    <string name="show_sort_fab_title">Á´ñÂ±èÊó∂ÊòæÁ§∫ÊµÆÂä®ÊéíÂ∫èÊåâÈíÆ</string>
    <string name="show_sort_fab_sum_on">ÊòæÁ§∫ÊµÆÂä®ÊéíÂ∫èÊåâÈíÆ</string>
    <string name="show_sort_fab_sum_off">‰∏çÊòæÁ§∫ÊµÆÂä®ÊéíÂ∫èÊåâÈíÆ</string>

    <string name="show_cat_fab_title">Á´ñÂ±èÊó∂ÊòæÁ§∫ÊµÆÂä®ÂàÜÁ±ªÊåâÈíÆ</string>
    <string name="show_cat_fab_sum_on">ÊòæÁ§∫ÊµÆÂä®ÂàÜÁ±ªÊåâÈíÆ</string>
    <string name="show_cat_fab_sum_off">‰∏çÊòæÁ§∫ÊµÆÂä®ÂàÜÁ±ªÊåâÈíÆ</string>

    <string name="accessibility_manual_on">Âú®ËÆæÂ§áÈ¶ñÈÄâÈ°π/Êó†ÈöúÁ¢çÈÉ®ÂàÜÂêØÁî®ÊúçÂä° %1$s</string>
    <string name="accessibility_manual_off">Âú®ËÆæÂ§áÈ¶ñÈÄâÈ°π/Êó†ÈöúÁ¢çÈÉ®ÂàÜÁ¶ÅÁî®ÊúçÂä° %1$s</string>
    <string name="accessibility_service_description">ÂêØÁî®Ê≠§ÊúçÂä°ÂèØ‰ª•Èò≤Ê≠¢Êìç‰ΩúÁ≥ªÁªüÂÖ≥Èó≠Êú¨Âú∞ TorrServer</string>
    <string name="switch_accessibility_title">Êó†ÈöúÁ¢çÊúçÂä°</string>
    <string name="switch_accessibility_summary_on">Êåâ‰∏ã‰ª•Á¶ÅÁî® TorrServe ÊúçÂä°</string>

    <string name="stat_string_added">Â∑≤Ê∑ªÂä†ÁßçÂ≠ê</string>
    <string name="stat_string_info">Ê≠£Âú®Ëé∑ÂèñÁßçÂ≠ê‰ø°ÊÅØ</string>
    <string name="stat_string_preload">È¢ÑÂä†ËΩΩÁßçÂ≠ê</string>
    <string name="stat_string_working">ÁßçÂ≠êÊ≠£Âú®Â∑•‰Ωú</string>
    <string name="stat_string_closed">ÁßçÂ≠êÂ∑≤ÂÖ≥Èó≠</string>
    <string name="stat_string_in_db">ÁßçÂ≠êÂú®Êï∞ÊçÆÂ∫ì‰∏≠</string>

    <string name="fmt_h">Â∞èÊó∂</string>
    <string name="fmt_m">ÂàÜÈíü</string>
    <string name="fmt_s">Áßí</string>
    <string name="fmt_p">KMGTPE</string>
    <string name="fmt_b">B</string>
    <string name="fmt_bps">bps</string>
    <string name="runtime">ËøêË°åÊó∂Èó¥</string>
    <string name="avg">Âπ≥Âùá</string>
    <string name="max">ÊúÄÂ§ß</string>

    <string name="sort_by_name">ÊåâÊ†áÈ¢òÊéíÂ∫èÂàóË°®</string>
    <string name="sort_by_size">ÊåâÂ§ßÂ∞èÊéíÂ∫èÂàóË°®</string>
    <string name="sort_by_seed">ÊåâÂÅöÁßçËÄÖÊï∞ÈáèÊéíÂ∫èÂàóË°®</string>
    <string name="sort_by_date">ÊåâÊó•ÊúüÊéíÂ∫èÂàóË°®</string>

    <string name="no_data">Êó†Êï∞ÊçÆ</string>
    <string name="no_torrents">Êó†ÁßçÂ≠ê</string>
    <string name="no_updates">Êú™ÊâæÂà∞Êõ¥Êñ∞</string>
    <string name="not_used">Êú™‰ΩøÁî®</string>
    <string name="not_installed">Êú™ÂÆâË£Ö</string>

    <string name="cat_movie">ÁîµÂΩ±</string>
    <string name="cat_tv">ÁîµËßÜÂâß</string>
    <string name="cat_music">Èü≥‰πê</string>
    <string name="cat_other">ÂÖ∂‰ªñ</string>
    <string name="cat_none">ÊâÄÊúâÁßçÂ≠ê</string>

    <string name="accessibility_note">Á¶ÅÁî®Êó†ÈöúÁ¢çÊúçÂä°‰ª•ÂÅúÊ≠¢ TorrServer</string>
    <string name="torrserver_log">TorrServer Êó•Âøó</string>
    <string name="torrserver_log_summary">Êü•ÁúãÊú¨Âú∞ TorrServer Êó•Âøó</string>
    <string name="torrserver_log_cleared">TorrServer Êó•ÂøóÂ∑≤Ê∏ÖÈô§</string>
    <string name="torrserver_log_trimmed">Êó•ÂøóÂÜÖÂÆπÂ∑≤Êà™Êñ≠ÔºàÊòæÁ§∫ÊúÄÂêé%sÔºâ</string>
</resources>

```

## ./app/src/main/res/drawable/outline_info_24.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorPrimary"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M11,7h2v2h-2zM11,11h2v6h-2zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8z" />
</vector>

```

## ./app/src/main/res/drawable/ic_outline_remove.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorPrimary">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M7,11v2h10v-2L7,11zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8z"/>
</vector>

```

## ./app/src/main/res/drawable/ic_outline_content_copy.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorPrimary">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M16,1L4,1c-1.1,0 -2,0.9 -2,2v14h2L4,3h12L16,1zM19,5L8,5c-1.1,0 -2,0.9 -2,2v14c0,1.1 0.9,2 2,2h11c1.1,0 2,-0.9 2,-2L21,7c0,-1.1 -0.9,-2 -2,-2zM19,21L8,21L8,7h11v14z"/>
</vector>

```

## ./app/src/main/res/drawable/ic_outline_playlist_play.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorPrimary"
    android:autoMirrored="true">
  <group
      android:scaleX="1.1"
      android:scaleY="1.1"
      android:pivotX="4"
      android:pivotY="0">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M3,10h11v2h-11z"/>
  <path
      android:fillColor="@android:color/white"
      android:pathData="M3,6h11v2h-11z"/>
  <path
      android:fillColor="@android:color/white"
      android:pathData="M3,14h7v2h-7z"/>
  <path
      android:fillColor="@android:color/white"
      android:pathData="M16,13l0,8l6,-4z"/>
  </group>
</vector>

```

## ./app/src/main/res/drawable/telegram.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
  <path
      android:pathData="m9.417,15.181 l-0.397,5.584c0.568,0 0.814,-0.244 1.109,-0.537l2.663,-2.545 5.518,4.041c1.012,0.564 1.725,0.267 1.998,-0.931l3.622,-16.972 0.001,-0.001c0.321,-1.496 -0.541,-2.081 -1.527,-1.714l-21.29,8.151c-1.453,0.564 -1.431,1.374 -0.247,1.741l5.443,1.693 12.643,-7.911c0.595,-0.394 1.136,-0.176 0.691,0.218z"
      android:fillColor="#039be5"/>
</vector>

```

## ./app/src/main/res/drawable/outline_format_24.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorPrimary"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M4,6.47L5.76,10H20v8H4V6.47M22,4h-4l2,4h-3l-2,-4h-2l2,4h-3l-2,-4H8l2,4H7L5,4H4c-1.1,0 -1.99,0.9 -1.99,2L2,18c0,1.1 0.9,2 2,2h16c1.1,0 2,-0.9 2,-2V4z" />
</vector>

```

## ./app/src/main/res/drawable/round_sort_24.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:autoMirrored="true"
    android:tint="?attr/colorBright"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M4,18h4c0.55,0 1,-0.45 1,-1s-0.45,-1 -1,-1L4,16c-0.55,0 -1,0.45 -1,1s0.45,1 1,1zM3,7c0,0.55 0.45,1 1,1h16c0.55,0 1,-0.45 1,-1s-0.45,-1 -1,-1L4,6c-0.55,0 -1,0.45 -1,1zM4,13h10c0.55,0 1,-0.45 1,-1s-0.45,-1 -1,-1L4,11c-0.55,0 -1,0.45 -1,1s0.45,1 1,1z" />
</vector>

```

## ./app/src/main/res/drawable/twotone_lock_16.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="16dp"
    android:height="16dp"
    android:tint="?attr/colorHost"
    android:viewportWidth="24"
    android:viewportHeight="24">

    <path
        android:fillAlpha="0.3"
        android:fillColor="@android:color/white"
        android:pathData="M6,20h12L18,10L6,10v10zM12,13c1.1,0 2,0.9 2,2s-0.9,2 -2,2 -2,-0.9 -2,-2 0.9,-2 2,-2z"
        android:strokeAlpha="0.3" />

    <path
        android:fillColor="@android:color/white"
        android:pathData="M18,8h-1L17,6c0,-2.76 -2.24,-5 -5,-5S7,3.24 7,6v2L6,8c-1.1,0 -2,0.9 -2,2v10c0,1.1 0.9,2 2,2h12c1.1,0 2,-0.9 2,-2L20,10c0,-1.1 -0.9,-2 -2,-2zM9,6c0,-1.66 1.34,-3 3,-3s3,1.34 3,3v2L9,8L9,6zM18,20L6,20L6,10h12v10zM12,17c1.1,0 2,-0.9 2,-2s-0.9,-2 -2,-2 -2,0.9 -2,2 0.9,2 2,2z" />

</vector>

```

## ./app/src/main/res/drawable/tbank.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="153.09dp"
    android:height="153.09dp"
    android:viewportWidth="153.09"
    android:viewportHeight="153.09">
  <path
      android:pathData="M0,0h153.09v76.99c0,19.74 -10.53,37.98 -27.62,47.85l-48.92,28.25l-48.92,-28.25C10.53,114.97 0,96.73 0,76.99V0z"
      android:fillColor="#FFDD2D"/>
  <path
      android:pathData="M42.01,40.52v23.95c3.27,-3.7 9.23,-6.2 16.04,-6.2h7.4v27.84c0,7.41 -2.01,13.89 -5,17.45h32.18c-2.98,-3.57 -4.99,-10.04 -4.99,-17.44V58.27h7.4c6.81,0 12.76,2.5 16.04,6.2V40.52H42.01z"
      android:fillColor="#333333"
      android:fillType="evenOdd"/>
</vector>

```

## ./app/src/main/res/drawable/action_activate.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
  <item>
    <shape android:shape="rectangle">
      <solid android:color="@android:color/transparent"/>
    </shape>
  </item>
  <item android:top="5dp" android:bottom="5dp" android:left="5dp" android:right="5dp">
    <shape android:shape="rectangle">
      <!-- ?attr/colorAccent is too bright without opacity -->
      <solid android:color="@color/scrim_30" />
      <corners android:radius="3.0dip" />
      <stroke
          android:width="1dp"
          android:color="@color/white_10" />
    </shape>
  </item>
</layer-list>

```

## ./app/src/main/res/drawable/outline_audio_24.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorPrimary"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M20,4H4C2.9,4 2,4.9 2,6v12c0,1.1 0.9,2 2,2h16c1.1,0 2,-0.9 2,-2V6C22,4.9 21.1,4 20,4zM20,18H4V6h16V18z" />
    <path
        android:fillColor="@android:color/white"
        android:pathData="M8.29,15.71C7.27,14.69 6.75,13.35 6.75,12c0,-1.35 0.52,-2.69 1.53,-3.72L7.05,7.05C5.68,8.41 5,10.21 5,12s0.68,3.59 2.06,4.94L8.29,15.71z" />
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,15.5c1.93,0 3.5,-1.57 3.5,-3.5c0,-1.93 -1.57,-3.5 -3.5,-3.5c-1.93,0 -3.5,1.57 -3.5,3.5C8.5,13.93 10.07,15.5 12,15.5zM12,10.5c0.83,0 1.5,0.67 1.5,1.5s-0.67,1.5 -1.5,1.5s-1.5,-0.67 -1.5,-1.5S11.17,10.5 12,10.5z" />
    <path
        android:fillColor="@android:color/white"
        android:pathData="M15.72,15.72l1.23,1.23C18.32,15.59 19,13.79 19,12s-0.68,-3.59 -2.06,-4.94l-1.23,1.23c1.02,1.02 1.54,2.36 1.54,3.71C17.25,13.35 16.73,14.69 15.72,15.72z" />
</vector>

```

## ./app/src/main/res/drawable/ic_refresh.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorPrimary">
  <path
      android:pathData="M22,12l-3,3l-3,-3"
      android:strokeLineJoin="round"
      android:strokeWidth="2"
      android:fillColor="@android:color/transparent"
      android:strokeColor="@android:color/white"
      android:strokeLineCap="round"/>
  <path
      android:pathData="M11,20C6.5817,20 3,16.4183 3,12C3,7.5817 6.5817,4 11,4C15.4183,4 19,7.5817 19,12L19,14"
      android:strokeLineJoin="round"
      android:strokeWidth="2"
      android:fillColor="@android:color/transparent"
      android:strokeColor="@android:color/white"
      android:strokeLineCap="round"/>
</vector>

```

## ./app/src/main/res/drawable/ic_outline_exit_to_app.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorPrimary"
    android:autoMirrored="true">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M10.09,15.59L11.5,17l5,-5 -5,-5 -1.41,1.41L12.67,11H3v2h9.67l-2.58,2.59zM19,3H5c-1.11,0 -2,0.9 -2,2v4h2V5h14v14H5v-4H3v4c0,1.1 0.89,2 2,2h14c1.1,0 2,-0.9 2,-2V5c0,-1.1 -0.9,-2 -2,-2z"/>
</vector>

```

## ./app/src/main/res/drawable/rc_background_dark.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<inset xmlns:android="http://schemas.android.com/apk/res/android"
    android:insetTop="10dp"
    android:insetBottom="10dp">
    <shape>
        <solid android:color="@color/dark_gray" />
        <corners android:radius="6dp" />
        <stroke
            android:width="1dp"
            android:color="@color/white_10" />
    </shape>
</inset>

```

## ./app/src/main/res/drawable/flexdivider.xml
```xml
<shape xmlns:android="http://schemas.android.com/apk/res/android">
  <size
      android:width="8dp"
      android:height="8dp" />
  <solid android:color="@android:color/transparent" />
</shape>
```

## ./app/src/main/res/drawable/boosty.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="190dp"
    android:height="190dp"
    android:viewportWidth="190"
    android:viewportHeight="190">
  <path
      android:pathData="M19.7,113.4L52.3,0.5h50.1l-10.1,35c-0.1,0.2 -0.2,0.4 -0.3,0.6l-26.6,92.4h24.8c-10.4,25.9 -18.5,46.2 -24.3,60.9c-45.8,-0.5 -58.6,-33.3 -47.4,-72.1M66.1,189.5l60.4,-86.9h-25.6l22.3,-55.7c38.2,4 56.2,34.1 45.6,70.5c-11.3,39.1 -57.1,72.1 -101.7,72.1C66.7,189.5 66.4,189.5 66.1,189.5z">
    <aapt:attr name="android:fillColor">
      <gradient 
          android:startX="120.48"
          android:startY="25.05"
          android:endX="55.98"
          android:endY="244.98"
          android:type="linear">
        <item android:offset="0" android:color="#FFEF7829"/>
        <item android:offset="0.05" android:color="#FFF07529"/>
        <item android:offset="0.36" android:color="#FFF0672B"/>
        <item android:offset="0.67" android:color="#FFF15E2C"/>
        <item android:offset="1" android:color="#FFF15A2C"/>
      </gradient>
    </aapt:attr>
  </path>
</vector>

```

## ./app/src/main/res/drawable/ts_icon.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="600"
    android:viewportHeight="600">
  <path
      android:pathData="M300,30C150.88,30 30,150.88 30,300s120.88,270 270,270s270,-120.88 270,-270S449.12,30 300,30zM300,520c-121.5,0 -220,-98.5 -220,-220S178.5,80 300,80s220,98.5 220,220S421.5,520 300,520z"
      android:fillColor="#2A2122"/>
  <path
      android:pathData="M395.11,356.81c-0.35,-1.46 -0.7,-2.57 -0.89,-3.71c-2.44,-15.02 -9,-22.58 -23.98,-24.56c-7.7,-1.02 -15.92,0.1 -23.63,1.61c-3.83,0.75 -7.85,3.92 -10.43,7.1c-7.3,9 -4.39,21.07 6.48,25.55c7.93,3.27 16.54,4.9 24.86,7.19c9.3,2.56 18.83,4.47 27.89,7.68c16.3,5.77 27.37,16.4 28.46,34.8c1.09,18.47 -7.63,33.57 -25,41.21c-22.65,9.96 -45.77,10.13 -68.22,-0.6c-17.48,-8.35 -26.14,-23 -26.93,-42.38c-0.17,-4.12 1.54,-5.84 5.51,-5.79c4.34,0.06 8.71,-0.3 12.99,0.18c1.68,0.19 4.18,1.89 4.56,3.36c5.83,22.47 14.96,30.3 37.94,30.65c6.85,0.11 13.98,-1.15 20.56,-3.17c9.44,-2.9 13.77,-9.5 13.95,-18.54c0.19,-9.17 -3.24,-14.9 -13.15,-18.3c-10.03,-3.45 -20.55,-5.47 -30.81,-8.27c-7.7,-2.1 -15.49,-4.01 -22.95,-6.8c-13.6,-5.09 -22.95,-14.19 -24.22,-29.48c-1.35,-16.29 4.44,-29.5 18.27,-38.57c12.78,-8.39 27.23,-10.95 42.11,-9.43c8.31,0.85 16.91,2.72 24.49,6.11c16.32,7.31 23.49,21.36 24.91,38.7c0.26,3.12 -0.88,5.35 -4.28,5.42C407.46,356.9 401.31,356.81 395.11,356.81z"
      android:fillColor="#242424"/>
  <path
      android:pathData="M223.2,185.61c-14.24,0 -27.57,0.01 -40.89,-0.01c-5.81,-0.01 -6.76,-0.9 -6.75,-6.62c0.03,-16.52 -1.68,-14.79 14.58,-14.8c32.67,-0.02 65.34,-0.01 98.01,0c6.41,0 7.2,0.78 7.21,7.18c0.01,15.84 1.4,14.24 -14.14,14.25c-10.96,0.01 -21.92,0 -33.51,0c0,2.44 0,4.38 0,6.32c0,37.68 0,75.36 0,113.04c0,7.03 -0.73,7.76 -7.69,7.77c-3,0.01 -6,0.01 -9,0c-7.07,-0.01 -7.81,-0.73 -7.81,-7.65c0,-37.68 0,-75.36 0,-113.04C223.2,190.09 223.2,188.14 223.2,185.61z"
      android:fillColor="#242424"/>
  <path
      android:pathData="M437.72,39.43c0.17,0.34 0.12,0.76 -0.15,1.04c-0.94,0.99 0.68,-1.15 0,0C402,100.78 363.82,164.18 328.3,224.52c-0.38,0.64 -0.66,1.33 -1.07,2.33c-0.29,0.71 0.36,1.44 1.1,1.24c25.64,-6.99 50.54,-13.79 76.43,-20.85c0.86,-0.23 1.52,0.76 0.97,1.46c-33.68,43.03 -66.74,85.26 -99.78,127.47c0.69,1.27 0.76,1.4 1.44,2.67c19.85,-1.67 39.72,-3.34 60.26,-5.07c0.8,-0.07 1.3,0.86 0.8,1.49c-0.61,0.76 -1.13,1.42 -1.71,2.02C296.38,409.7 225.99,482.1 155.63,554.52c-0.65,0.67 -1.2,1.44 -1.74,2.22c-0.4,0.57 -1.26,0.51 -1.58,-0.12l-0.01,-0.02c-0.18,-0.37 -0.1,-0.82 0.2,-1.09c0.64,-0.58 1.32,-1.15 1.77,-1.85c34.29,-54.11 68.55,-108.23 102.81,-162.37c0.35,-0.55 0.63,-1.14 1.06,-2.03c0.32,-0.66 -0.22,-1.41 -0.95,-1.32c-20.5,2.6 -40.29,5.1 -60.85,7.7c-0.78,0.1 -1.33,-0.77 -0.88,-1.43c27.77,-41.29 55.13,-81.95 83.24,-123.74c0.45,-0.66 -0.11,-1.55 -0.91,-1.43c-21.2,3.21 -41.2,6.25 -62.07,9.41c-0.86,0.13 -1.4,-0.89 -0.82,-1.53c3.15,-3.48 5.9,-6.55 8.71,-9.56c53.23,-56.98 106.47,-113.93 159.69,-170.92c17.05,-18.26 34.03,-36.61 51.01,-54.94c0.66,-0.71 1.22,-1.5 1.79,-2.29c0.4,-0.57 1.26,-0.5 1.57,0.12L437.72,39.43z"
      android:fillColor="#FE7E00"/>
</vector>

```

## ./app/src/main/res/drawable/ic_add.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorPrimary">
  <path
      android:pathData="M17,12L7,12M12,17L12,7"
      android:strokeLineJoin="round"
      android:strokeWidth="1"
      android:fillColor="@android:color/transparent"
      android:strokeColor="@android:color/white"
      android:strokeLineCap="round"/>
  <path
      android:pathData="M12,12m-10,0a10,10 0,1 1,20 0a10,10 0,1 1,-20 0"
      android:strokeLineJoin="round"
      android:strokeWidth="1"
      android:fillColor="@android:color/transparent"
      android:strokeColor="@android:color/white"
      android:strokeLineCap="round"/>
</vector>

```

## ./app/src/main/res/drawable/round_check_24.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorBright"
    android:viewportWidth="24"
    android:viewportHeight="24">

    <path
        android:fillColor="@android:color/white"
        android:pathData="M9,16.17L5.53,12.7c-0.39,-0.39 -1.02,-0.39 -1.41,0 -0.39,0.39 -0.39,1.02 0,1.41l4.18,4.18c0.39,0.39 1.02,0.39 1.41,0L20.29,7.71c0.39,-0.39 0.39,-1.02 0,-1.41 -0.39,-0.39 -1.02,-0.39 -1.41,0L9,16.17z" />

</vector>

```

## ./app/src/main/res/drawable/io.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="169dp"
    android:height="120dp"
    android:viewportWidth="169"
    android:viewportHeight="120">
  <path
      android:pathData="M108.99,0C75.573,0 48.99,26.962 48.99,60C48.99,93.418 75.952,120 108.99,120C142.028,120 168.99,93.038 168.99,60C168.99,26.962 142.028,0 108.99,0ZM108.99,82.405C96.838,82.405 86.585,72.152 86.585,60C86.585,47.848 96.838,37.595 108.99,37.595C121.142,37.595 131.395,47.848 131.395,60C131.016,72.152 121.142,82.405 108.99,82.405Z"
      android:fillColor="#8B3FFD"/>
  <path
      android:pathData="M48.608,17.468V104.81H27.342L0,17.468H48.608V17.468Z"
      android:fillColor="#8B3FFD"/>
</vector>

```

## ./app/src/main/res/drawable/ic_thumb_up.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorPrimary">
  <path
      android:pathData="M8,8.7398C8,8.2624 8.1708,7.8008 8.4815,7.4383L13.2724,1.8489C13.7,1.35 14.4123,1.2061 15,1.5C15.5738,1.7869 15.8493,2.4521 15.6464,3.0607L14,8L18.6036,8C18.7236,8 18.8433,8.0108 18.9613,8.0323C20.0481,8.2299 20.7689,9.271 20.5713,10.3578L19.2986,17.3578C19.1257,18.3088 18.2974,19 17.3308,19L10,19C8.8954,19 8,18.1046 8,17L8,8.7398Z"
      android:strokeLineJoin="round"
      android:strokeWidth="2"
      android:fillColor="@android:color/transparent"
      android:strokeColor="@android:color/white"
      android:strokeLineCap="round"/>
  <path
      android:pathData="M4,18L4,9"
      android:strokeLineJoin="round"
      android:strokeWidth="2"
      android:fillColor="@android:color/transparent"
      android:strokeColor="@android:color/white"
      android:strokeLineCap="round"/>
</vector>

```

## ./app/src/main/res/drawable/rc_background_light.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<inset xmlns:android="http://schemas.android.com/apk/res/android"
    android:insetTop="10dp"
    android:insetBottom="10dp">
    <shape>
        <solid android:color="@color/tv_white" />
        <corners android:radius="6dp" />
        <stroke
            android:width="1dp"
            android:color="@color/white_10" />
    </shape>
</inset>

```

## ./app/src/main/res/drawable/ic_plus.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorPrimary">
  <path
      android:pathData="M20,12L4,12M12,4L12,20"
      android:strokeLineJoin="round"
      android:strokeWidth="2"
      android:fillColor="@android:color/transparent"
      android:strokeColor="@android:color/white"
      android:strokeLineCap="round"/>
</vector>

```

## ./app/src/main/res/drawable/action_focused.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
  <item>
    <shape android:shape="rectangle">
      <solid android:color="@android:color/transparent"/>
    </shape>
  </item>
  <item android:top="5dp" android:bottom="5dp" android:left="5dp" android:right="5dp">
    <shape android:shape="rectangle">
      <solid android:color="@color/scrim_30" />
      <corners android:radius="3.0dip" />
      <stroke
          android:width="1dp"
          android:color="@color/white_10" />
    </shape>
  </item>
</layer-list>

```

## ./app/src/main/res/drawable/ic_outline_share.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorPrimary">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M18,16.08c-0.76,0 -1.44,0.3 -1.96,0.77L8.91,12.7c0.05,-0.23 0.09,-0.46 0.09,-0.7s-0.04,-0.47 -0.09,-0.7l7.05,-4.11c0.54,0.5 1.25,0.81 2.04,0.81 1.66,0 3,-1.34 3,-3s-1.34,-3 -3,-3 -3,1.34 -3,3c0,0.24 0.04,0.47 0.09,0.7L8.04,9.81C7.5,9.31 6.79,9 6,9c-1.66,0 -3,1.34 -3,3s1.34,3 3,3c0.79,0 1.5,-0.31 2.04,-0.81l7.12,4.16c-0.05,0.21 -0.08,0.43 -0.08,0.65 0,1.61 1.31,2.92 2.92,2.92s2.92,-1.31 2.92,-2.92c0,-1.61 -1.31,-2.92 -2.92,-2.92zM18,4c0.55,0 1,0.45 1,1s-0.45,1 -1,1 -1,-0.45 -1,-1 0.45,-1 1,-1zM6,13c-0.55,0 -1,-0.45 -1,-1s0.45,-1 1,-1 1,0.45 1,1 -0.45,1 -1,1zM18,20.02c-0.55,0 -1,-0.45 -1,-1s0.45,-1 1,-1 1,0.45 1,1 -0.45,1 -1,1z"/>
</vector>

```

## ./app/src/main/res/drawable/flexdivider_small.xml
```xml
<shape xmlns:android="http://schemas.android.com/apk/res/android">
  <size
      android:width="3dp"
      android:height="3dp" />
  <solid android:color="@android:color/transparent" />
</shape>
```

## ./app/src/main/res/drawable/eye_show.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorBright"
    android:viewportWidth="24"
    android:viewportHeight="24">
  <path
      android:pathData="M12,9.005C14.209,9.005 16,10.795 16,13.005C16,15.214 14.209,17.005 12,17.005C9.791,17.005 8,15.214 8,13.005C8,10.795 9.791,9.005 12,9.005ZM12,5.5C16.614,5.5 20.596,8.65 21.701,13.064C21.802,13.466 21.558,13.873 21.156,13.974C20.754,14.075 20.347,13.83 20.246,13.429C19.307,9.678 15.921,7 12,7C8.077,7 4.69,9.68 3.753,13.433C3.652,13.835 3.245,14.079 2.843,13.979C2.442,13.879 2.197,13.472 2.298,13.07C3.401,8.653 7.384,5.5 12,5.5Z"
      android:strokeWidth="1"
      android:fillColor="#212121"
      android:fillType="nonZero"
      android:strokeColor="#00000000"/>
</vector>

```

## ./app/src/main/res/drawable/round_sort_by_alpha_24.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorBright"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <group
        android:scaleX="0.9"
        android:scaleY="0.9"
        android:pivotX="12"
        android:pivotY="12">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12.93,2.65c-0.2,-0.2 -0.51,-0.2 -0.71,0l-2.01,2.01h4.72l-2,-2.01zM12.23,21.35c0.2,0.2 0.51,0.2 0.71,0l1.98,-1.98h-4.66l1.97,1.98zM10.98,17.73c0.6,0 1.01,-0.6 0.79,-1.16L8.04,7.03c-0.18,-0.46 -0.63,-0.76 -1.12,-0.76 -0.49,0 -0.94,0.3 -1.12,0.76l-3.74,9.53c-0.22,0.56 0.19,1.16 0.79,1.16 0.35,0 0.67,-0.22 0.8,-0.55l0.71,-1.9h5.11l0.71,1.9c0.13,0.34 0.45,0.56 0.8,0.56zM4.97,13.64l1.94,-5.18 1.94,5.18L4.97,13.64zM21.05,16.14h-5.33l5.72,-8.29c0.46,-0.66 -0.02,-1.57 -0.82,-1.57h-6.48c-0.44,0 -0.79,0.36 -0.79,0.8v0.01c0,0.44 0.36,0.8 0.79,0.8h5.09l-5.73,8.28c-0.46,0.66 0.02,1.57 0.82,1.57h6.72c0.44,0 0.79,-0.36 0.79,-0.79 0.02,-0.45 -0.34,-0.81 -0.78,-0.81z" />
    </group>
</vector>

```

## ./app/src/main/res/drawable/ic_outline_add.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorPrimary">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M12,7c-0.55,0 -1,0.45 -1,1v3L8,11c-0.55,0 -1,0.45 -1,1s0.45,1 1,1h3v3c0,0.55 0.45,1 1,1s1,-0.45 1,-1v-3h3c0.55,0 1,-0.45 1,-1s-0.45,-1 -1,-1h-3L13,8c0,-0.55 -0.45,-1 -1,-1zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8z"/>
</vector>

```

## ./app/src/main/res/drawable/ic_video.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorPrimary">
  <path
      android:pathData="M18,12l-9,4.9l0,-9.9z"
      android:strokeLineJoin="round"
      android:strokeWidth="1"
      android:fillColor="@android:color/transparent"
      android:strokeColor="@android:color/white"
      android:strokeLineCap="round"/>
  <path
      android:pathData="M12,12m-10,0a10,10 0,1 1,20 0a10,10 0,1 1,-20 0"
      android:strokeLineJoin="round"
      android:strokeWidth="1"
      android:fillColor="@android:color/transparent"
      android:strokeColor="@android:color/white"
      android:strokeLineCap="round"/>
</vector>

```

## ./app/src/main/res/drawable/activated_background.xml
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_activated="true" android:drawable="@drawable/action_activate" />
    <item android:drawable="@android:color/transparent" />
</selector>
```

## ./app/src/main/res/drawable/ic_circle_viewed.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="oval">

    <solid android:color="@color/orange" />

    <size
        android:width="12dp"
        android:height="12dp" />
</shape>
```

## ./app/src/main/res/drawable/gradient_divider_white.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <size
        android:width="1dip"
        android:height="1dip" />
    <gradient
        android:endColor="#00ffffff"
        android:centerColor="#40ffffff"
        android:startColor="#00ffffff"
        android:type="linear"
        android:angle="0" />
</shape>
```

## ./app/src/main/res/drawable/round_music_note_24.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorBright"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <group
        android:scaleX="0.9"
        android:scaleY="0.9"
        android:pivotX="12"
        android:pivotY="17">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M12,3v10.55c-0.59,-0.34 -1.27,-0.55 -2,-0.55 -2.21,0 -4,1.79 -4,4s1.79,4 4,4 4,-1.79 4,-4V7h4V3h-6z" />
    </group>
</vector>

```

## ./app/src/main/res/drawable/ssl.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="18dp"
    android:height="18dp"
    android:tint="?attr/colorHost"
    android:viewportWidth="32"
    android:viewportHeight="32">
    <group android:translateY="2.5">
        <path
            android:fillColor="#00000000"
            android:pathData="M22,12l0,8l4,0"
            android:strokeWidth="2"
            android:strokeColor="#000000"
            android:strokeLineCap="round"
            android:strokeLineJoin="round" />
        <path
            android:fillColor="#00000000"
            android:pathData="M29,24H3c-1.1,0 -2,-0.9 -2,-2V10c0,-1.1 0.9,-2 2,-2h26c1.1,0 2,0.9 2,2v12C31,23.1 30.1,24 29,24z"
            android:strokeWidth="2"
            android:strokeColor="#000000"
            android:strokeLineCap="round"
            android:strokeLineJoin="round" />
        <path
            android:fillColor="#00000000"
            android:pathData="M10,14L10,14c0,-1.1 -0.9,-2 -2,-2h0c-1.1,0 -2,0.9 -2,2v0c0,1.1 0.9,2 2,2h0c1.1,0 2,0.9 2,2v0c0,1.1 -0.9,2 -2,2h0c-1.1,0 -2,-0.9 -2,-2v0"
            android:strokeWidth="2"
            android:strokeColor="#000000"
            android:strokeLineCap="round"
            android:strokeLineJoin="round" />
        <path
            android:fillColor="#00000000"
            android:pathData="M18,14L18,14c0,-1.1 -0.9,-2 -2,-2h0c-1.1,0 -2,0.9 -2,2v0c0,1.1 0.9,2 2,2h0c1.1,0 2,0.9 2,2v0c0,1.1 -0.9,2 -2,2h0c-1.1,0 -2,-0.9 -2,-2v0"
            android:strokeWidth="2"
            android:strokeColor="#000000"
            android:strokeLineCap="round"
            android:strokeLineJoin="round" />
    </group>
</vector>

```

## ./app/src/main/res/drawable/outline_subtitles_24.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorPrimary"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M20,4L4,4c-1.1,0 -2,0.9 -2,2v12c0,1.1 0.9,2 2,2h16c1.1,0 2,-0.9 2,-2L22,6c0,-1.1 -0.9,-2 -2,-2zM20,18L4,18L4,6h16v12zM6,10h2v2L6,12zM6,14h8v2L6,16zM16,14h2v2h-2zM10,10h8v2h-8z" />
</vector>

```

## ./app/src/main/res/drawable/action_selector.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<selector
  xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_pressed="true" android:drawable="@drawable/action_pressed" />
    <item android:state_focused="true" android:drawable="@drawable/action_focused" />
    <item android:drawable="@android:color/transparent" />
</selector>

```

## ./app/src/main/res/drawable/ic_create_new_folder.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorPrimary">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M20,6h-8l-2,-2L4,4c-1.11,0 -1.99,0.89 -1.99,2L2,18c0,1.11 0.89,2 2,2h16c1.11,0 2,-0.89 2,-2L22,8c0,-1.11 -0.89,-2 -2,-2zM19,14h-3v3h-2v-3h-3v-2h3L14,9h2v3h3v2z"/>
</vector>

```

## ./app/src/main/res/drawable/ic_settings.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="48dp"
    android:height="48dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorPrimary">
  <path
      android:pathData="M5.0351,12.705C5.0119,12.4732 5,12.238 5,12C5,11.762 5.0119,11.5268 5.0351,11.295L3.2058,9.2321L5.2058,5.7679L7.907,6.3207C8.2873,6.0461 8.6963,5.8088 9.1286,5.6141L10,3L14,3L14.8714,5.6141C15.3037,5.8088 15.7127,6.0461 16.093,6.3207L18.7942,5.7679L20.7942,9.2321L18.9649,11.295C18.9881,11.5268 19,11.762 19,12C19,12.238 18.9881,12.4732 18.9649,12.705L20.7942,14.7679L18.7942,18.232L16.093,17.6793C15.7127,17.9539 15.3037,18.1912 14.8714,18.3859L14,21L10,21L9.1286,18.3859C8.6963,18.1912 8.2873,17.9539 7.907,17.6793L5.2058,18.232L3.2058,14.7679L5.0351,12.705Z"
      android:strokeLineJoin="round"
      android:strokeWidth="2"
      android:fillColor="@android:color/transparent"
      android:strokeColor="@android:color/white"
      android:strokeLineCap="round"/>
  <path
      android:pathData="M12,12m-1,0a1,1 0,1 1,2 0a1,1 0,1 1,-2 0"
      android:strokeLineJoin="round"
      android:strokeWidth="2"
      android:fillColor="@android:color/transparent"
      android:strokeColor="@android:color/white"
      android:strokeLineCap="round"/>
</vector>

```

## ./app/src/main/res/drawable/ic_outline_visibility_off.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorPrimary">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M12,6c3.79,0 7.17,2.13 8.82,5.5 -0.59,1.22 -1.42,2.27 -2.41,3.12l1.41,1.41c1.39,-1.23 2.49,-2.77 3.18,-4.53C21.27,7.11 17,4 12,4c-1.27,0 -2.49,0.2 -3.64,0.57l1.65,1.65C10.66,6.09 11.32,6 12,6zM10.93,7.14L13,9.21c0.57,0.25 1.03,0.71 1.28,1.28l2.07,2.07c0.08,-0.34 0.14,-0.7 0.14,-1.07C16.5,9.01 14.48,7 12,7c-0.37,0 -0.72,0.05 -1.07,0.14zM2.01,3.87l2.68,2.68C3.06,7.83 1.77,9.53 1,11.5 2.73,15.89 7,19 12,19c1.52,0 2.98,-0.29 4.32,-0.82l3.42,3.42 1.41,-1.41L3.42,2.45 2.01,3.87zM9.51,11.37l2.61,2.61c-0.04,0.01 -0.08,0.02 -0.12,0.02 -1.38,0 -2.5,-1.12 -2.5,-2.5 0,-0.05 0.01,-0.08 0.01,-0.13zM6.11,7.97l1.75,1.75c-0.23,0.55 -0.36,1.15 -0.36,1.78 0,2.48 2.02,4.5 4.5,4.5 0.63,0 1.23,-0.13 1.77,-0.36l0.98,0.98c-0.88,0.24 -1.8,0.38 -2.75,0.38 -3.79,0 -7.17,-2.13 -8.82,-5.5 0.7,-1.43 1.72,-2.61 2.93,-3.53z"/>
</vector>

```

## ./app/src/main/res/drawable/round_filter_list_24.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorBright"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <group
        android:translateY="1">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M11,18h2c0.55,0 1,-0.45 1,-1s-0.45,-1 -1,-1h-2c-0.55,0 -1,0.45 -1,1s0.45,1 1,1zM3,7c0,0.55 0.45,1 1,1h16c0.55,0 1,-0.45 1,-1s-0.45,-1 -1,-1L4,6c-0.55,0 -1,0.45 -1,1zM7,13h10c0.55,0 1,-0.45 1,-1s-0.45,-1 -1,-1L7,11c-0.55,0 -1,0.45 -1,1s0.45,1 1,1z" />
    </group>
</vector>

```

## ./app/src/main/res/drawable/rc_background_black.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<inset xmlns:android="http://schemas.android.com/apk/res/android"
    android:insetTop="10dp"
    android:insetBottom="10dp">
    <shape>
        <solid android:color="@color/black_opaque" />
        <corners android:radius="6dp" />
        <stroke
            android:width="1dp"
            android:color="@color/white_10" />
    </shape>
</inset>

```

## ./app/src/main/res/drawable/ic_arrow_upward.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorPrimary">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M4,12l1.41,1.41L11,7.83V20h2V7.83l5.58,5.59L20,12l-8,-8 -8,8z"/>
</vector>

```

## ./app/src/main/res/drawable/ic_done.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="?attr/colorControlNormal">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M9,16.2L4.8,12l-1.4,1.4L9,19 21,7l-1.4,-1.4L9,16.2z"/>
</vector>

```

## ./app/src/main/res/drawable/snackbar.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
  <shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@color/snackbar" />
    <corners android:radius="6dp" />
    <stroke
        android:width="1dp"
        android:color="@color/white_10" />
  </shape>
```

## ./app/src/main/res/drawable/twotone_folder_16.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="16dp"
    android:height="16dp"
    android:tint="#bbb"
    android:viewportWidth="24"
    android:viewportHeight="24">

    <path
        android:fillAlpha="0.3"
        android:fillColor="@android:color/white"
        android:pathData="M11.17,8l-0.58,-0.59L9.17,6H4v12h16V8h-8z"
        android:strokeAlpha="0.3" />

    <path
        android:fillColor="@android:color/white"
        android:pathData="M20,6h-8l-2,-2L4,4c-1.1,0 -1.99,0.9 -1.99,2L2,18c0,1.1 0.9,2 2,2h16c1.1,0 2,-0.9 2,-2L22,8c0,-1.1 -0.9,-2 -2,-2zM20,18L4,18L4,6h5.17l1.41,1.41 0.59,0.59L20,8v10z" />

</vector>

```

## ./app/src/main/res/drawable/round_view_list_24.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:autoMirrored="true"
    android:tint="?attr/colorBright"
    android:viewportWidth="24"
    android:viewportHeight="24">

    <path
        android:fillColor="@android:color/white"
        android:pathData="M4,14h2c0.55,0 1,-0.45 1,-1v-2c0,-0.55 -0.45,-1 -1,-1H4c-0.55,0 -1,0.45 -1,1v2C3,13.55 3.45,14 4,14zM4,19h2c0.55,0 1,-0.45 1,-1v-2c0,-0.55 -0.45,-1 -1,-1H4c-0.55,0 -1,0.45 -1,1v2C3,18.55 3.45,19 4,19zM4,9h2c0.55,0 1,-0.45 1,-1V6c0,-0.55 -0.45,-1 -1,-1H4C3.45,5 3,5.45 3,6v2C3,8.55 3.45,9 4,9zM9,14h11c0.55,0 1,-0.45 1,-1v-2c0,-0.55 -0.45,-1 -1,-1H9c-0.55,0 -1,0.45 -1,1v2C8,13.55 8.45,14 9,14zM9,19h11c0.55,0 1,-0.45 1,-1v-2c0,-0.55 -0.45,-1 -1,-1H9c-0.55,0 -1,0.45 -1,1v2C8,18.55 8.45,19 9,19zM8,6v2c0,0.55 0.45,1 1,1h11c0.55,0 1,-0.45 1,-1V6c0,-0.55 -0.45,-1 -1,-1H9C8.45,5 8,5.45 8,6z" />

</vector>

```

## ./app/src/main/res/drawable/round_more_horiz_24.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorBright"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <group
        android:scaleX="0.9"
        android:scaleY="0.9"
        android:pivotX="12"
        android:pivotY="24">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M6,10c-1.1,0 -2,0.9 -2,2s0.9,2 2,2 2,-0.9 2,-2 -0.9,-2 -2,-2zM18,10c-1.1,0 -2,0.9 -2,2s0.9,2 2,2 2,-0.9 2,-2 -0.9,-2 -2,-2zM12,10c-1.1,0 -2,0.9 -2,2s0.9,2 2,2 2,-0.9 2,-2 -0.9,-2 -2,-2z" />
    </group>
</vector>

```

## ./app/src/main/res/drawable/action_pressed.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
  <item>
    <shape android:shape="rectangle">
      <solid android:color="@android:color/transparent"/>
    </shape>
  </item>
  <item android:top="5dp" android:bottom="5dp" android:left="5dp" android:right="5dp">
    <shape android:shape="rectangle">
      <solid android:color="@color/scrim_20" />
      <corners android:radius="3.0dip" />
    </shape>
  </item>
</layer-list>

```

## ./app/src/main/res/drawable/round_movie_24.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorBright"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <group
        android:scaleX="0.82"
        android:scaleY="0.82"
        android:pivotX="12"
        android:pivotY="18">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M18,4l1.82,3.64c0.08,0.16 -0.04,0.36 -0.22,0.36h-1.98c-0.38,0 -0.73,-0.21 -0.89,-0.55L15,4h-2l1.82,3.64c0.08,0.16 -0.04,0.36 -0.22,0.36h-1.98c-0.38,0 -0.73,-0.21 -0.89,-0.55L10,4H8l1.82,3.64c0.08,0.16 -0.04,0.36 -0.22,0.36H7.62c-0.38,0 -0.73,-0.21 -0.9,-0.55L5,4H4c-1.1,0 -2,0.9 -2,2v12c0,1.1 0.9,2 2,2h16c1.1,0 2,-0.9 2,-2V5c0,-0.55 -0.45,-1 -1,-1h-3z" />
    </group>
</vector>

```

## ./app/src/main/res/drawable/paypal.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="25.576353dp"
    android:height="30.177dp"
    android:viewportWidth="25.576353"
    android:viewportHeight="30.177">
  <path
      android:pathData="m7.266,29.154 l0.523,-3.322 -1.165,-0.027 -5.563,0 3.866,-24.513c0.012,-0.074 0.051,-0.143 0.108,-0.192 0.057,-0.049 0.13,-0.076 0.206,-0.076l9.38,0c3.114,0 5.263,0.648 6.385,1.927 0.526,0.6 0.861,1.227 1.023,1.917 0.17,0.724 0.173,1.589 0.007,2.644l-0.012,0.077 0,0.676 0.526,0.298c0.443,0.235 0.795,0.504 1.065,0.812 0.45,0.513 0.741,1.165 0.864,1.938 0.127,0.795 0.085,1.741 -0.123,2.812 -0.24,1.232 -0.628,2.305 -1.152,3.183 -0.482,0.809 -1.096,1.48 -1.825,2 -0.696,0.494 -1.523,0.869 -2.458,1.109 -0.906,0.236 -1.939,0.355 -3.072,0.355l-0.73,0c-0.522,0 -1.029,0.188 -1.427,0.525 -0.399,0.344 -0.663,0.814 -0.744,1.328l-0.055,0.299 -0.924,5.855 -0.042,0.215c-0.011,0.068 -0.03,0.102 -0.058,0.125 -0.025,0.021 -0.061,0.035 -0.096,0.035l-4.507,0z"
      android:fillColor="#253b80"/>
  <path
      android:pathData="m23.048,7.667 l0,0 0,0c-0.028,0.179 -0.06,0.362 -0.096,0.55 -1.237,6.351 -5.469,8.545 -10.874,8.545l-2.752,0c-0.661,0 -1.218,0.48 -1.321,1.132l0,0 0,0 -1.409,8.936 -0.399,2.533c-0.067,0.428 0.263,0.814 0.695,0.814l4.881,0c0.578,0 1.069,-0.42 1.16,-0.99l0.048,-0.248 0.919,-5.832 0.059,-0.32c0.09,-0.572 0.582,-0.992 1.16,-0.992l0.73,0c4.729,0 8.431,-1.92 9.513,-7.476 0.452,-2.321 0.218,-4.259 -0.978,-5.622 -0.362,-0.411 -0.811,-0.752 -1.336,-1.03z"
      android:fillColor="#179bd7"/>
  <path
      android:pathData="m21.754,7.151c-0.189,-0.055 -0.384,-0.105 -0.584,-0.15 -0.201,-0.044 -0.407,-0.083 -0.619,-0.117 -0.742,-0.12 -1.555,-0.177 -2.426,-0.177l-7.352,0c-0.181,0 -0.353,0.041 -0.507,0.115C9.927,6.985 9.675,7.306 9.614,7.699l-1.564,9.906 -0.045,0.289c0.103,-0.652 0.66,-1.132 1.321,-1.132l2.752,0c5.405,0 9.637,-2.195 10.874,-8.545 0.037,-0.188 0.068,-0.371 0.096,-0.55 -0.313,-0.166 -0.652,-0.308 -1.017,-0.429 -0.09,-0.03 -0.183,-0.059 -0.277,-0.087z"
      android:fillColor="#222d65"/>
  <path
      android:pathData="m9.614,7.699c0.061,-0.393 0.313,-0.714 0.652,-0.876 0.155,-0.074 0.326,-0.115 0.507,-0.115l7.352,0c0.871,0 1.684,0.057 2.426,0.177 0.212,0.034 0.418,0.073 0.619,0.117 0.2,0.045 0.395,0.095 0.584,0.15 0.094,0.028 0.187,0.057 0.278,0.086 0.365,0.121 0.704,0.264 1.017,0.429 0.368,-2.347 -0.003,-3.945 -1.272,-5.392C20.378,0.682 17.853,0 14.622,0L5.242,0c-0.66,0 -1.223,0.48 -1.325,1.133L0.01,25.898c-0.077,0.49 0.301,0.932 0.795,0.932l5.791,0 1.454,-9.225 1.564,-9.906z"
      android:fillColor="#253b80"/>
</vector>

```

## ./app/src/main/res/drawable/snackbar_dark.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@color/snackbar" />
    <corners android:radius="6dp" />
    <stroke
        android:width="0.5dip"
        android:color="@color/dark_brown" />
</shape>
```

## ./app/src/main/res/drawable/outline_video_24.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorPrimary"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M9.5,7.5l0,9l7,-4.5z" />
    <path
        android:fillColor="@android:color/white"
        android:pathData="M20,4H4C2.9,4 2,4.9 2,6v12c0,1.1 0.9,2 2,2h16c1.1,0 2,-0.9 2,-2V6C22,4.9 21.1,4 20,4zM20,18.01H4V5.99h16V18.01z" />
</vector>

```

## ./app/src/main/res/drawable/round_live_tv_24.xml
```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:tint="?attr/colorBright"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <group
        android:scaleX="0.8"
        android:scaleY="0.8"
        android:pivotX="12"
        android:pivotY="11">
        <path
            android:fillColor="@android:color/white"
            android:pathData="M10.5,17.15l3.98,-2.28c0.67,-0.38 0.67,-1.35 0,-1.74l-3.98,-2.28c-0.67,-0.38 -1.5,0.11 -1.5,0.87v4.55c0,0.77 0.83,1.26 1.5,0.88zM21,6h-7.59l2.94,-2.94c0.2,-0.2 0.2,-0.51 0,-0.71s-0.51,-0.2 -0.71,0L12,5.99 8.36,2.35c-0.2,-0.2 -0.51,-0.2 -0.71,0s-0.2,0.51 0,0.71L10.59,6L3,6c-1.1,0 -2,0.89 -2,2v12c0,1.1 0.9,2 2,2h18c1.1,0 2,-0.9 2,-2L23,8c0,-1.11 -0.9,-2 -2,-2zM20,20L4,20c-0.55,0 -1,-0.45 -1,-1L3,9c0,-0.55 0.45,-1 1,-1h16c0.55,0 1,0.45 1,1v10c0,0.55 -0.45,1 -1,1z" />
    </group>
</vector>

```

## ./app/src/main/res/drawable/gradient_divider_green.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <size
        android:width="1dip"
        android:height="1dip" />
    <gradient
        android:startColor="#003fb57a"
        android:centerColor="#803fb57a"
        android:endColor="#003fb57a"
        android:type="linear"
        android:angle="0" />
</shape>

```

## ./app/src/main/res/layout/log_fragment.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <androidx.core.widget.NestedScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:fadingEdge="vertical"
        android:fadingEdgeLength="32dp"
        android:overScrollMode="always"
        android:requiresFadingEdge="vertical">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:gravity="center_horizontal"
            android:orientation="vertical"
            android:paddingTop="16dp"
            android:paddingBottom="16dp">

            <TextView
                android:id="@+id/tvTitle"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginStart="16dp"
                android:layout_marginEnd="16dp"
                android:paddingTop="12dp"
                android:paddingBottom="16dp"
                android:text=""
                android:textAppearance="@style/TextAppearance.MaterialComponents.Subtitle1"
                android:textColor="?attr/colorAccent"
                android:textSize="20sp"
                tools:text="TorrServer log"
                tools:visibility="visible" />

            <Button
                android:id="@+id/btnClear"
                style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                android:layout_width="match_parent"
                android:layout_height="0dp"
                android:layout_marginStart="16dp"
                android:layout_marginLeft="16dp"
                android:layout_marginEnd="16dp"
                android:layout_marginRight="16dp"
                android:layout_marginBottom="10dp"
                android:layout_weight="1"
                android:text="@string/delete">

                <requestFocus />
            </Button>

            <TextView
                android:id="@+id/tvLog"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginStart="16dp"
                android:layout_marginEnd="16dp"
                android:textAppearance="@style/TextAppearance.MaterialComponents.Body1"
                android:textColor="?attr/colorBright"
                android:textSize="12sp"
                tools:text="TorrServer log contents" />
        </LinearLayout>
    </androidx.core.widget.NestedScrollView>
</LinearLayout>
```

## ./app/src/main/res/layout/settings_activity.xml
```xml
<?xml version="1.0" encoding="utf-8"?>

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".ui.activities.main.SettingsActivity">

    <FrameLayout
        android:id="@+id/container"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <com.google.android.material.progressindicator.LinearProgressIndicator
            android:id="@+id/progressBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="top"
            android:indeterminate="true"
            android:visibility="gone"
            app:trackCornerRadius="2dp"
            app:trackThickness="4dp" />
    </FrameLayout>

</LinearLayout>
```

## ./app/src/main/res/layout/item_toast.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <ImageView
        android:id="@+id/ivLogo"
        android:layout_width="25dp"
        android:layout_height="25dp"
        android:contentDescription="@string/app_name"
        android:src="@mipmap/ic_launcher"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintVertical_bias="0" />

    <TextView
        android:id="@+id/tvMessage"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:textSize="18sp"
        android:includeFontPadding="true"
        android:scrollbars="none"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toEndOf="@+id/ivLogo"
        app:layout_constraintVertical_bias="0"
        tools:text="App Message!\n\nVivamus a vehicula nunc. Phasellus nec metus cursus, molestie neque in, ullamcorper felis. Pellentesque pharetra ullamcorper mauris faucibus dapibus. Vestibulum eget gravida lacus. Pellentesque magna velit, dictum sed sagittis nec, commodo in nisi. Nam bibendum erat lorem, in semper tortor dignissim eu. Duis iaculis augue sit amet dolor mollis, interdum varius augue placerat. Praesent ut condimentum dui. Sed varius ultrices ligula quis cursus. Donec vulputate leo sit amet massa accumsan, id posuere orci convallis. Nam iaculis tempor ipsum placerat sodales. Morbi eleifend pretium malesuada." />

</androidx.constraintlayout.widget.ConstraintLayout>
```

## ./app/src/main/res/layout/head_preference_category.xml
```xml
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@android:id/title"
    style="@style/HeadPreferenceCategoryText"
    android:layout_width="match_parent"
    android:layout_height="wrap_content" />
```

## ./app/src/main/res/layout/host_item.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@drawable/action_selector"
    android:clickable="true"
    android:clipToPadding="false"
    android:focusable="true"
    android:padding="5dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <TextView
            android:id="@+id/tvHost"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_margin="3dp"
            android:paddingStart="12dp"
            android:paddingLeft="12dp"
            android:paddingTop="1dp"
            android:paddingEnd="12dp"
            android:paddingRight="12dp"
            android:paddingBottom="3dp"
            android:textAppearance="@style/TextAppearance.AppCompat.Medium"
            tools:text="http://localhost:8090" />

        <com.google.android.flexbox.FlexboxLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="3dp"
            app:alignContent="flex_start"
            app:alignItems="flex_start"
            app:dividerDrawable="@drawable/flexdivider_small"
            app:flexWrap="wrap"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:showDivider="middle">

            <TextView
                android:id="@+id/tvVersion"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginStart="3dp"
                android:layout_marginLeft="3dp"
                android:paddingStart="5dp"
                android:paddingLeft="5dp"
                android:paddingEnd="5dp"
                android:paddingRight="5dp"
                android:textAppearance="@style/TextAppearance.AppCompat.Small"
                tools:text="1.XX.XX" />

            <TextView
                android:id="@+id/tvStatus"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:paddingStart="3dp"
                android:paddingLeft="3dp"
                android:paddingEnd="3dp"
                android:paddingRight="3dp"
                android:textAppearance="@style/TextAppearance.AppCompat.Small"
                tools:text="@string/online" />

        </com.google.android.flexbox.FlexboxLayout>

    </LinearLayout>

    <TextView
        android:id="@+id/tvOnline"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentEnd="true"
        android:layout_alignParentRight="true"
        android:layout_centerVertical="true"
        android:layout_gravity="center|end"
        android:layout_marginEnd="5dp"
        android:layout_marginRight="5dp"
        android:contentDescription="@string/online"
        android:includeFontPadding="false"
        android:paddingStart="4dp"
        android:paddingLeft="4dp"
        android:paddingEnd="4dp"
        android:paddingRight="4dp"
        android:singleLine="true"
        android:visibility="invisible"
        tools:text="@string/online"
        tools:visibility="visible" />

</RelativeLayout>

```

## ./app/src/main/res/layout/torrent_files_item.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:clipToPadding="false"
    android:padding="5dp">

    <TextView
        android:id="@+id/tvFileName"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="start|center"
        android:layout_toStartOf="@+id/tvFileSize"
        android:layout_toLeftOf="@+id/tvFileSize"
        android:gravity="center_vertical"
        android:minHeight="64dp"
        android:paddingStart="5dp"
        android:paddingLeft="5dp"
        tools:text="Name" />

    <ImageView
        android:id="@+id/ivViewed"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentTop="true"
        android:layout_alignParentEnd="true"
        android:layout_alignParentRight="true"
        android:layout_gravity="end|center"
        android:layout_marginTop="-3dp"
        android:layout_marginEnd="1dp"
        android:layout_marginRight="1dp"
        app:srcCompat="@drawable/eye_show" />

    <TextView
        android:id="@+id/tvFileSize"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_above="@+id/tvExt"
        android:layout_alignParentEnd="true"
        android:layout_alignParentRight="true"
        android:layout_gravity="end|center"
        android:layout_margin="3dp"
        android:paddingStart="5dp"
        android:paddingLeft="5dp"
        android:paddingEnd="5dp"
        android:paddingRight="5dp"
        android:paddingBottom="1dp"
        android:textSize="12sp"
        android:textStyle="bold"
        tools:text="5 MB" />

    <TextView
        android:id="@+id/tvExt"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignBottom="@+id/tvFileName"
        android:layout_alignParentEnd="true"
        android:layout_alignParentRight="true"
        android:layout_gravity="end|bottom"
        android:layout_margin="3dp"
        android:paddingStart="5dp"
        android:paddingLeft="5dp"
        android:paddingEnd="5dp"
        android:paddingRight="5dp"
        android:paddingBottom="1dp"
        android:textSize="13sp"
        android:textStyle="bold"
        android:visibility="gone"
        tools:text=".mkv"
        tools:visibility="visible" />

</RelativeLayout>
```

## ./app/src/main/res/layout/add_fragment.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_margin="16dp">

        <com.google.android.material.textfield.TextInputLayout
            android:id="@+id/tvRutor"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="@string/rutor"
            android:visibility="gone"
            app:helperText="Venom 2018"
            app:helperTextEnabled="true"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            tools:visibility="visible">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/etSearch"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:inputType="text"
                android:textAppearance="@style/TextAppearance.AppCompat.Medium" />
        </com.google.android.material.textfield.TextInputLayout>

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/rvRTorrents"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_marginStart="-10dp"
            android:layout_marginLeft="-10dp"
            android:layout_marginEnd="-10dp"
            android:layout_marginRight="-10dp"
            android:fadingEdgeLength="20dp"
            android:paddingStart="5dp"
            android:paddingEnd="5dp"
            android:requiresFadingEdge="vertical"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/tvRutor"
            tools:visibility="gone" />

        <androidx.constraintlayout.widget.Group
            android:id="@+id/adder"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:constraint_referenced_ids="tvMagnet,tvTitle,tvPoster,tvCategory" />

        <com.google.android.material.textfield.TextInputLayout
            android:id="@+id/tvMagnet"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            android:hint="@string/torrent_link"
            app:helperText="@string/torrent_link_help"
            app:helperTextEnabled="true"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/tvRutor">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/etMagnet"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:inputType="text"
                android:textAppearance="@style/TextAppearance.AppCompat.Medium">

                <requestFocus />
            </com.google.android.material.textfield.TextInputEditText>
        </com.google.android.material.textfield.TextInputLayout>

        <com.google.android.material.textfield.TextInputLayout
            android:id="@+id/tvTitle"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            android:hint="@string/title"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/tvMagnet">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/etTitle"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:inputType="text"
                android:textAppearance="@style/TextAppearance.AppCompat.Medium" />
        </com.google.android.material.textfield.TextInputLayout>

        <com.google.android.material.textfield.TextInputLayout
            android:id="@+id/tvPoster"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            android:hint="@string/poster_link"
            app:helperText="@string/poster_link_help"
            app:helperTextEnabled="true"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/tvTitle">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/etPoster"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:inputType="text"
                android:textAppearance="@style/TextAppearance.AppCompat.Medium" />
        </com.google.android.material.textfield.TextInputLayout>

        <com.google.android.material.textfield.TextInputLayout
            android:id="@+id/tvCategory"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            android:hint="@string/torrent_category"
            android:visibility="gone"
            app:helperText="@string/torrent_category_help"
            app:helperTextEnabled="true"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/tvPoster"
            tools:visibility="visible">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/etCategory"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:inputType="text"
                android:textAppearance="@style/TextAppearance.AppCompat.Medium" />
        </com.google.android.material.textfield.TextInputLayout>


    </androidx.constraintlayout.widget.ConstraintLayout>

    <com.google.android.material.floatingactionbutton.FloatingActionButton
        android:id="@+id/sortFab"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="end|top"
        android:layout_marginTop="22dp"
        android:layout_marginEnd="18dp"
        android:layout_marginRight="18dp"
        android:contentDescription="@string/show_menu"
        android:scaleType="center"
        android:visibility="gone"
        app:fabCustomSize="32dp"
        app:fabSize="mini"
        app:maxImageSize="24dp"
        app:srcCompat="@drawable/round_sort_24"
        app:tint="@null"
        tools:visibility="visible" />

    <LinearLayout
        android:id="@+id/footer"
        style="@android:style/DeviceDefault.ButtonBar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom"
        android:layout_margin="10dp"
        android:divider="?android:attr/dividerVertical"
        android:orientation="horizontal"
        android:showDividers="none">

        <Button
            android:id="@+id/btnOK"
            style="@style/Widget.MaterialComponents.Button.OutlinedButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginStart="5dp"
            android:layout_marginLeft="5dp"
            android:layout_marginEnd="8dp"
            android:layout_marginRight="8dp"
            android:layout_weight="1"
            android:nextFocusUp="@id/etPoster"
            android:text="@android:string/ok"
            tools:ignore="ButtonOrder" />

        <Button
            android:id="@+id/btnCancel"
            style="@style/Widget.MaterialComponents.Button.OutlinedButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:layout_marginLeft="8dp"
            android:layout_marginEnd="5dp"
            android:layout_marginRight="5dp"
            android:layout_weight="1"
            android:nextFocusUp="@id/etPoster"
            android:text="@android:string/cancel" />
    </LinearLayout>
</FrameLayout>
```

## ./app/src/main/res/layout/torrent_file_fragment.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <!--ImageView
        android:layout_width="fill_parent"
        android:layout_height="1dp"
        android:layout_alignParentTop="true"
        android:background="@drawable/gradient_divider_hw" /-->

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <com.google.android.material.button.MaterialButton
            android:id="@+id/btnPlaylist"
            style="@style/Widget.MaterialComponents.Button.OutlinedButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginStart="6dp"
            android:layout_marginLeft="6dp"
            android:layout_marginEnd="3dp"
            android:layout_marginRight="3dp"
            android:layout_weight="1"
            android:singleLine="true"
            android:maxLines="1"
            android:text="@string/playlist_all"
            app:icon="@drawable/ic_outline_playlist_play"
            app:iconGravity="textStart"
            app:iconPadding="3dp"
            app:iconSize="22dp"
            app:iconTint="?attr/colorAccent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent" />

        <com.google.android.material.button.MaterialButton
            android:id="@+id/btnPlaylistContinue"
            style="@style/Widget.MaterialComponents.Button.OutlinedButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginStart="3dp"
            android:layout_marginLeft="3dp"
            android:layout_marginEnd="6dp"
            android:layout_marginRight="6dp"
            android:layout_weight="1"
            android:singleLine="true"
            android:maxLines="1"
            android:text="@string/playlist_continue"
            app:icon="@drawable/ic_outline_playlist_play"
            app:iconGravity="textStart"
            app:iconPadding="3dp"
            app:iconSize="22dp"
            app:iconTint="?attr/colorAccent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent" />

    </LinearLayout>

    <ListView
        android:id="@+id/lvTorrentFiles"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:fadingEdge="vertical"
        android:fadingEdgeLength="50dp"
        android:listSelector="@drawable/action_selector"
        android:requiresFadingEdge="vertical" />

</LinearLayout>
```

## ./app/src/main/res/layout/app_list_title.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:paddingTop="10dp">

    <TextView
        android:id="@+id/appListTitleText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_marginBottom="6dp"
        android:fitsSystemWindows="true"
        android:includeFontPadding="false"
        android:text="@string/select_player"
        android:textAppearance="@style/TextAppearance.AppCompat.Large"
        android:textSize="24sp"
        android:textStyle="bold" />

    <androidx.appcompat.widget.SwitchCompat
        android:id="@+id/useDefault"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:layout_gravity="center"
        android:layout_marginStart="5dp"
        android:layout_marginLeft="5dp"
        android:focusable="true"
        android:gravity="right|center_vertical|end"
        android:minWidth="200dp"
        android:switchPadding="5dp"
        android:text="@string/use_as_default"
        android:textAllCaps="true"
        android:textColor="?attr/colorBright"
        android:textSize="14sp"
        android:textStyle="bold"
        app:switchPadding="10dp" />
</LinearLayout>
```

## ./app/src/main/res/layout/torrent_details_item.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@drawable/action_selector"
    android:clickable="true"
    android:clipToPadding="false"
    android:focusable="true"
    android:padding="5dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <TextView
            android:id="@+id/tvName"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:fontFamily="sans-serif-condensed"
            android:paddingStart="5dp"
            android:paddingLeft="5dp"
            android:paddingTop="1dp"
            android:paddingEnd="5dp"
            android:paddingRight="5dp"
            android:textAppearance="@style/TextAppearance.AppCompat.Medium"
            android:textColor="?attr/colorBright"
            tools:text="Torrent Name" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <TextView
                android:id="@+id/tvInfo1"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:maxLines="1"
                android:paddingStart="5dp"
                android:paddingLeft="5dp"
                android:paddingEnd="5dp"
                android:paddingRight="5dp"
                android:paddingBottom="4dp"
                android:textAppearance="@style/TextAppearance.AppCompat.Small"
                tools:text="120.55 GB ‚ñ≤128 ‚ñº223" />

            <TextView
                android:id="@+id/tvInfo2"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:ellipsize="end"
                android:gravity="end"
                android:maxLines="1"
                android:paddingStart="5dp"
                android:paddingLeft="5dp"
                android:paddingEnd="5dp"
                android:paddingRight="5dp"
                android:paddingBottom="4dp"
                android:textAppearance="@style/TextAppearance.AppCompat.Small"
                tools:text="22.01.2022" />
        </LinearLayout>
    </LinearLayout>

</RelativeLayout>

```

## ./app/src/main/res/layout/directory_item.xml
```xml
<?xml version="1.0" encoding="utf-8"?>

<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/tvDirectoryName"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:minHeight="25dp"
    android:layout_gravity="start|center"
    android:padding="10dp"
    android:gravity="center_vertical"
    android:background="@drawable/action_selector"
    android:focusable="true"
    android:clickable="true" />
```

## ./app/src/main/res/layout/list_item.xml
```xml
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:ellipsize="end"
    android:maxLines="1"
    android:padding="16dp"
    android:textAppearance="?attr/textAppearanceSubtitle1" />
```

## ./app/src/main/res/layout/dialog_info.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:paddingLeft="24dp"
    android:paddingTop="10dp"
    android:paddingRight="24dp"
    android:paddingBottom="24dp">

    <ScrollView
        android:id="@+id/scroller"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:fadingEdgeLength="40dp"
        android:fillViewport="true"
        android:requiresFadingEdge="vertical"
        android:scrollbars="vertical">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical">

            <com.google.android.flexbox.FlexboxLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                app:alignContent="flex_start"
                app:alignItems="flex_start"
                app:dividerDrawable="@drawable/flexdivider"
                app:flexWrap="wrap"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toTopOf="parent"
                app:showDivider="middle">

                <TextView
                    android:id="@+id/tvSize"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginBottom="8dp"
                    android:maxLines="1"
                    android:paddingStart="12dp"
                    android:paddingEnd="12dp"
                    android:textAppearance="@style/TextAppearance.AppCompat.Medium"
                    android:textSize="16sp"
                    android:textStyle="bold"
                    tools:text="120.1 GB" />

                <TextView
                    android:id="@+id/tvRuntime"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginBottom="8dp"
                    android:maxLines="1"
                    android:paddingStart="12dp"
                    android:paddingEnd="12dp"
                    android:textAppearance="@style/TextAppearance.AppCompat.Medium"
                    android:textSize="16sp"
                    android:textStyle="bold"
                    tools:text="02:58:08" />

                <TextView
                    android:id="@+id/tvBitrate"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginBottom="8dp"
                    android:maxLines="1"
                    android:paddingStart="12dp"
                    android:paddingEnd="12dp"
                    android:textAppearance="@style/TextAppearance.AppCompat.Medium"
                    android:textSize="16sp"
                    android:textStyle="bold"
                    tools:text="20,2 Mbps" />

            </com.google.android.flexbox.FlexboxLayout>

            <TextView
                android:id="@+id/format"
                android:layout_width="fill_parent"
                android:layout_height="wrap_content"
                android:lineSpacingExtra="3sp"
                android:textAppearance="@style/TextAppearance.AppCompat.Medium"
                android:textSize="17sp"
                android:textColor="?attr/colorBright"
                tools:text="Format:" />

            <TextView
                android:id="@+id/video"
                android:layout_width="fill_parent"
                android:layout_height="wrap_content"
                android:lineSpacingExtra="3sp"
                android:textAppearance="@style/TextAppearance.AppCompat.Medium"
                android:textSize="17sp"
                android:textColor="?attr/colorBright"
                tools:text="Video:" />

            <TextView
                android:id="@+id/audio"
                android:layout_width="fill_parent"
                android:layout_height="wrap_content"
                android:lineSpacingExtra="3sp"
                android:textAppearance="@style/TextAppearance.AppCompat.Medium"
                android:textSize="17sp"
                android:textColor="?attr/colorBright"
                tools:text="Audio:" />

            <TextView
                android:id="@+id/subtitles"
                android:layout_width="fill_parent"
                android:layout_height="wrap_content"
                android:lineSpacingExtra="3sp"
                android:textAppearance="@style/TextAppearance.AppCompat.Medium"
                android:textSize="17sp"
                android:textColor="?attr/colorBright"
                tools:text="Subtitles:" />

            <TextView
                android:id="@+id/infoline"
                android:layout_width="fill_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:lineSpacingExtra="3sp"
                android:textAppearance="@style/TextAppearance.AppCompat.Medium"
                android:textSize="17sp"
                android:textColor="?attr/colorBright"
                android:visibility="gone"
                tools:visibility="gone"
                tools:text="Infoline" />

        </LinearLayout>

    </ScrollView>

</LinearLayout>
```

## ./app/src/main/res/layout/torrent_item.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/torrent"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="?android:attr/activatedBackgroundIndicator"
    android:baselineAligned="false"
    android:minHeight="84dp"
    android:orientation="horizontal">

    <ImageView
        android:id="@+id/ivPoster"
        android:layout_width="60dp"
        android:layout_height="90dp"
        android:layout_marginStart="8dp"
        android:layout_marginLeft="8dp"
        android:layout_marginTop="8dp"
        android:layout_marginBottom="8dp"
        android:scaleType="centerCrop" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginStart="8dp"
        android:layout_marginLeft="8dp"
        android:layout_marginEnd="8dp"
        android:layout_marginRight="8dp"
        android:orientation="vertical">

        <TextView
            android:id="@+id/tvTorrName"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="5dp"
            android:ellipsize="end"
            android:fontFamily="sans-serif-condensed"
            android:maxLines="3"
            android:singleLine="false"
            android:textAppearance="@style/TextAppearance.AppCompat.Medium"
            android:textColor="?attr/colorBright"
            android:textSize="18sp"
            tools:text="Name" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <TextView
                android:id="@+id/tvTorrHash"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="6dp"
                android:layout_weight="2"
                android:ellipsize="middle"
                android:fontFamily="sans-serif-condensed"
                android:singleLine="false"
                tools:text="hash" />

            <LinearLayout
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="4dp"
                android:layout_weight="0"
                android:orientation="vertical">

                <TextView
                    android:id="@+id/tvTorrSize"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="end"
                    android:fontFamily="sans-serif-condensed"
                    android:paddingStart="3dp"
                    android:paddingLeft="3dp"
                    android:singleLine="true"
                    android:textColor="?attr/colorHost"
                    android:textSize="22sp"
                    tools:text="5GB" />

                <TextView
                    android:id="@+id/tvTorrDate"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="end"
                    android:paddingStart="3dp"
                    android:paddingLeft="3dp"
                    android:singleLine="true"
                    tools:text="10.10.2001" />

            </LinearLayout>
        </LinearLayout>
    </LinearLayout>
</LinearLayout>

```

## ./app/src/main/res/layout/info_fragment.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/info"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_marginStart="12dp"
    android:layout_marginLeft="12dp"
    android:layout_marginTop="6dp"
    android:layout_marginEnd="12dp"
    android:layout_marginRight="12dp"
    android:layout_marginBottom="6dp"
    android:orientation="vertical">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/clHead"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <ImageView
            android:id="@+id/ivCat"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:adjustViewBounds="false"
            android:contentDescription="@string/torrent_category"
            android:paddingEnd="12dp"
            android:paddingRight="12dp"
            android:visibility="gone"
            app:layout_constraintBaseline_toBaselineOf="@id/tvTitle"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            tools:visibility="visible" />

        <TextView
            android:id="@+id/tvTitle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="start"
            android:layout_marginBottom="6dp"
            android:ellipsize="end"
            android:fontFamily="sans-serif-condensed"
            android:maxLines="4"
            android:textAppearance="@style/TextAppearance.AppCompat.Medium"
            android:textColor="?attr/colorOnBackground"
            android:textSize="18sp"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHorizontal_bias="0.0"
            app:layout_constraintLeft_toRightOf="@id/ivCat"
            app:layout_constraintStart_toEndOf="@id/ivCat"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintVertical_bias="0.5"
            tools:text="Torrent Title" />
    </androidx.constraintlayout.widget.ConstraintLayout>

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/clInfo"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <ImageView
            android:id="@+id/ivPoster"
            android:layout_width="78dp"
            android:layout_height="117dp"
            android:layout_marginTop="5dp"
            android:layout_marginBottom="3dp"
            android:adjustViewBounds="false"
            android:contentDescription="@string/poster"
            android:cropToPadding="true"
            android:scaleType="centerCrop"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toStartOf="@id/tvInfo"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintVertical_bias="0"
            tools:background="@drawable/emptyposter" />


        <TextView
            android:id="@+id/tvInfo"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="11dp"
            android:layout_marginLeft="11dp"
            android:layout_marginBottom="6dp"
            android:textAllCaps="true"
            android:textStyle="bold"
            app:layout_constraintBottom_toTopOf="@id/tvFileName"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toEndOf="@id/ivPoster"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_goneMarginLeft="0dp"
            app:layout_goneMarginStart="0dp"
            tools:text="Info" />

        <TextView
            android:id="@+id/tvFileName"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="11dp"
            android:layout_marginLeft="11dp"
            android:layout_marginBottom="6dp"
            android:ellipsize="end"
            android:fontFamily="sans-serif-condensed-medium"
            android:maxLines="1"
            android:singleLine="true"
            android:textSize="16sp"
            app:layout_constraintBottom_toTopOf="@+id/flexboxLayout"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toEndOf="@id/ivPoster"
            app:layout_constraintTop_toBottomOf="@id/tvInfo"
            app:layout_goneMarginLeft="0dp"
            app:layout_goneMarginStart="0dp"
            tools:text="Filename" />

        <com.google.android.flexbox.FlexboxLayout
            android:id="@+id/flexboxLayout"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="11dp"
            android:layout_marginLeft="11dp"
            app:alignContent="flex_start"
            app:alignItems="flex_start"
            app:dividerDrawable="@drawable/flexdivider"
            app:flexWrap="wrap"
            app:layout_constraintBottom_toTopOf="@id/tvBuffer"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toEndOf="@id/ivPoster"
            app:layout_constraintTop_toBottomOf="@id/tvFileName"
            app:layout_goneMarginLeft="0dp"
            app:layout_goneMarginStart="0dp"
            app:showDivider="none">

            <TextView
                android:id="@+id/tvPeers"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginEnd="6dp"
                android:layout_marginRight="6dp"
                tools:text="Peers" />

            <TextView
                android:id="@+id/tvSeeds"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginEnd="6dp"
                android:layout_marginRight="6dp"
                tools:text="Seeds" />

            <TextView
                android:id="@+id/tvSpeed"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginEnd="6dp"
                android:layout_marginRight="6dp"
                tools:text="Speed" />

            <TextView
                android:id="@+id/tvFileSize"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginEnd="6dp"
                android:layout_marginRight="6dp"
                tools:text="Size" />

            <TextView
                android:id="@+id/tvDuration"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginEnd="6dp"
                android:layout_marginRight="6dp"
                tools:text="Duration" />

            <TextView
                android:id="@+id/tvBitrate"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginEnd="6dp"
                android:layout_marginRight="6dp"
                tools:text="Bitrate" />

        </com.google.android.flexbox.FlexboxLayout>

        <TextView
            android:id="@+id/tvBuffer"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginStart="11dp"
            android:layout_marginLeft="11dp"
            android:layout_marginTop="6dp"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toEndOf="@id/ivPoster"
            app:layout_constraintTop_toBottomOf="@id/flexboxLayout"
            app:layout_constraintVertical_bias="1.0"
            app:layout_goneMarginLeft="0dp"
            app:layout_goneMarginStart="0dp"
            tools:text="Buffer" />

    </androidx.constraintlayout.widget.ConstraintLayout>
</LinearLayout>
```

## ./app/src/main/res/layout/main_activity.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.drawerlayout.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/drawerLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:clipChildren="false"
    android:clipToPadding="false">

    <FrameLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <com.google.android.material.progressindicator.LinearProgressIndicator
            android:id="@+id/progressBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="top"
            android:indeterminate="true"
            android:visibility="gone"
            app:trackCornerRadius="2dp"
            app:trackThickness="4dp" />

        <com.google.android.material.floatingactionbutton.FloatingActionButton
            android:id="@+id/fab"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="start|bottom"
            android:layout_margin="16dp"
            android:contentDescription="@string/show_menu"
            android:scaleType="center"
            android:visibility="gone"
            app:fabCustomSize="32dp"
            app:fabSize="mini"
            app:maxImageSize="30dp"
            app:srcCompat="@drawable/ts_round"
            app:tint="@null"
            tools:visibility="visible" />

        <FrameLayout
            android:id="@+id/container"
            android:layout_width="match_parent"
            android:layout_height="match_parent" />

        <com.google.android.material.floatingactionbutton.FloatingActionButton
            android:id="@+id/sort_fab"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="end|top"
            android:layout_margin="16dp"
            android:contentDescription="@string/show_menu"
            android:scaleType="center"
            android:visibility="gone"
            app:fabCustomSize="32dp"
            app:fabSize="mini"
            app:maxImageSize="24dp"
            app:srcCompat="@drawable/round_filter_list_24"
            app:tint="@null"
            tools:visibility="visible" />

        <androidx.constraintlayout.widget.ConstraintLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent">

            <com.google.android.material.floatingactionbutton.FloatingActionButton
                android:id="@+id/cat_fab"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="start|top"
                android:layout_margin="16dp"
                android:contentDescription="@string/torrent_category"
                android:scaleType="center"
                android:visibility="gone"
                app:fabCustomSize="32dp"
                app:fabSize="mini"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintEnd_toEndOf="parent"
                app:maxImageSize="24dp"
                app:srcCompat="@drawable/round_view_list_24"
                app:tint="@color/tv_white"
                tools:visibility="visible" />

            <com.google.android.material.floatingactionbutton.FloatingActionButton
                android:id="@+id/all_fab"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:backgroundTint="@null"
                android:contentDescription="@string/app_name"
                android:visibility="gone"
                app:fabCustomSize="32dp"
                app:fabSize="mini"
                app:layout_constraintBottom_toTopOf="@id/cat_fab"
                app:layout_constraintEnd_toEndOf="@id/cat_fab"
                app:srcCompat="@drawable/round_check_24"
                app:tint="@color/tv_white"
                tools:visibility="visible" />

            <TextView
                android:id="@+id/all_fab_text"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginRight="8dp"
                android:layout_marginEnd="8dp"
                android:text="@string/cat_none"
                android:textStyle="bold"
                android:visibility="gone"
                app:layout_constraintBottom_toBottomOf="@id/all_fab"
                app:layout_constraintEnd_toStartOf="@id/all_fab"
                app:layout_constraintTop_toTopOf="@id/all_fab"
                tools:visibility="visible" />

            <com.google.android.material.floatingactionbutton.FloatingActionButton
                android:id="@+id/oth_fab"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:backgroundTint="@null"
                android:contentDescription="@string/app_name"
                android:visibility="gone"
                app:fabCustomSize="32dp"
                app:fabSize="mini"
                app:layout_constraintBottom_toTopOf="@id/all_fab"
                app:layout_constraintEnd_toEndOf="@id/all_fab"
                app:layout_constraintStart_toStartOf="@id/all_fab"
                app:srcCompat="@drawable/round_more_horiz_24"
                app:tint="@color/tv_white"
                tools:visibility="visible" />

            <TextView
                android:id="@+id/oth_fab_text"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginRight="8dp"
                android:layout_marginEnd="8dp"
                android:text="@string/cat_other"
                android:textStyle="bold"
                android:visibility="gone"
                app:layout_constraintBottom_toBottomOf="@id/oth_fab"
                app:layout_constraintEnd_toStartOf="@id/oth_fab"
                app:layout_constraintTop_toTopOf="@id/oth_fab"
                tools:visibility="visible" />

            <com.google.android.material.floatingactionbutton.FloatingActionButton
                android:id="@+id/mus_fab"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:backgroundTint="@null"
                android:contentDescription="@string/app_name"
                android:visibility="gone"
                app:fabCustomSize="32dp"
                app:fabSize="mini"
                app:layout_constraintBottom_toTopOf="@id/oth_fab"
                app:layout_constraintEnd_toEndOf="@id/oth_fab"
                app:layout_constraintStart_toStartOf="@id/oth_fab"
                app:srcCompat="@drawable/round_music_note_24"
                app:tint="@color/tv_white"
                tools:visibility="visible" />

            <TextView
                android:id="@+id/mus_fab_text"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginRight="8dp"
                android:layout_marginEnd="8dp"
                android:text="@string/cat_music"
                android:textStyle="bold"
                android:visibility="gone"
                app:layout_constraintBottom_toBottomOf="@id/mus_fab"
                app:layout_constraintEnd_toStartOf="@id/mus_fab"
                app:layout_constraintTop_toTopOf="@id/mus_fab"
                tools:visibility="visible" />

            <com.google.android.material.floatingactionbutton.FloatingActionButton
                android:id="@+id/tv_fab"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:backgroundTint="@null"
                android:contentDescription="@string/app_name"
                android:visibility="gone"
                app:fabCustomSize="32dp"
                app:fabSize="mini"
                app:layout_constraintBottom_toTopOf="@id/mus_fab"
                app:layout_constraintEnd_toEndOf="@id/mus_fab"
                app:layout_constraintStart_toStartOf="@id/mus_fab"
                app:srcCompat="@drawable/round_live_tv_24"
                app:tint="@color/tv_white"
                tools:visibility="visible" />

            <TextView
                android:id="@+id/tv_fab_text"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginRight="8dp"
                android:layout_marginEnd="8dp"
                android:text="@string/cat_tv"
                android:textStyle="bold"
                android:visibility="gone"
                app:layout_constraintBottom_toBottomOf="@id/tv_fab"
                app:layout_constraintEnd_toStartOf="@id/tv_fab"
                app:layout_constraintTop_toTopOf="@id/tv_fab"
                tools:visibility="visible" />

            <com.google.android.material.floatingactionbutton.FloatingActionButton
                android:id="@+id/mov_fab"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:backgroundTint="@null"
                android:contentDescription="@string/app_name"
                android:visibility="gone"
                app:fabCustomSize="32dp"
                app:fabSize="mini"
                app:layout_constraintBottom_toTopOf="@id/tv_fab"
                app:layout_constraintEnd_toEndOf="@id/tv_fab"
                app:layout_constraintStart_toStartOf="@id/tv_fab"
                app:srcCompat="@drawable/round_movie_24"
                app:tint="@color/tv_white"
                tools:visibility="visible" />

            <TextView
                android:id="@+id/mov_fab_text"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginRight="8dp"
                android:layout_marginEnd="8dp"
                android:text="@string/cat_movie"
                android:textStyle="bold"
                android:visibility="gone"
                app:layout_constraintBottom_toBottomOf="@id/mov_fab"
                app:layout_constraintEnd_toStartOf="@id/mov_fab"
                app:layout_constraintTop_toTopOf="@id/mov_fab"
                tools:visibility="visible" />

        </androidx.constraintlayout.widget.ConstraintLayout>

    </FrameLayout>

    <!--menu-->
    <include layout="@layout/navigation_menu" />

</androidx.drawerlayout.widget.DrawerLayout>

```

## ./app/src/main/res/layout/apk_update_fragment.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="top|center"
        android:layout_margin="16dp"
        android:gravity="center"
        android:text="@string/found_new_app_update"
        android:textAppearance="@style/TextAppearance.AppCompat.Large" />

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="start|top"
        android:layout_marginStart="16dp"
        android:layout_marginLeft="16dp"
        android:layout_marginTop="80dp"
        android:layout_marginEnd="16dp"
        android:layout_marginRight="16dp"
        android:minWidth="320dp"
        android:orientation="vertical"
        android:paddingTop="10dp"
        android:paddingBottom="10dp">

        <TextView
            android:id="@+id/tvCurrentVersion"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/current_version"
            android:textAppearance="@style/TextAppearance.AppCompat.Medium" />


        <TextView
            android:id="@+id/tvNewVersion"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/new_version"
            android:textAppearance="@style/TextAppearance.AppCompat.Medium" />

    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_marginTop="180dp"
        android:layout_marginBottom="70dp"
        android:orientation="vertical">

        <ScrollView
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:fadingEdge="vertical"
            android:fadingEdgeLength="30dp"
            android:requiresFadingEdge="vertical">

            <TextView
                android:id="@+id/tvOverview"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:paddingStart="16dp"
                android:paddingEnd="16dp"
                android:textAppearance="@style/TextAppearance.AppCompat.Medium"
                tools:text="Some overview long text example. Some overview long text example. Some overview long text example." />
        </ScrollView>
    </LinearLayout>

    <LinearLayout
        style="@android:style/DeviceDefault.ButtonBar"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom"
        android:layout_margin="10dp"
        android:minWidth="400dp"
        android:orientation="horizontal">

        <Button
            android:id="@+id/btnUpdate"
            style="@style/Widget.MaterialComponents.Button.OutlinedButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginStart="5dp"
            android:layout_marginLeft="5dp"
            android:layout_marginEnd="8dp"
            android:layout_marginRight="8dp"
            android:layout_weight="1"
            android:minWidth="140dp"
            android:text="@string/update">

            <requestFocus />
        </Button>

        <Button
            android:id="@+id/btnCancel"
            style="@style/Widget.MaterialComponents.Button.OutlinedButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:layout_marginLeft="8dp"
            android:layout_marginEnd="5dp"
            android:layout_marginRight="5dp"
            android:layout_weight="1"
            android:minWidth="140dp"
            android:text="@string/skip" />
    </LinearLayout>
</FrameLayout>
```

## ./app/src/main/res/layout/app_list_item.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:padding="5dp">

    <ImageView
        android:id="@+id/imageViewIcon"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:layout_marginStart="10dp"
        android:layout_marginLeft="10dp"
        android:layout_marginTop="5dp"
        android:layout_marginBottom="5dp" />

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="5dp"
        android:layout_marginEnd="10dp"
        android:layout_marginRight="10dp"
        android:orientation="vertical"
        android:paddingStart="15dp"
        android:paddingLeft="15dp"
        tools:ignore="RtlSymmetry">

        <TextView
            android:id="@+id/textViewMain"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="20sp"
            android:textStyle="bold" />

        <TextView
            android:id="@+id/textViewSecond"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="14sp"
            android:textStyle="italic" />
    </LinearLayout>

</LinearLayout>
```

## ./app/src/main/res/layout/torrent_files_button.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:clipToPadding="false"
    android:padding="5dp">

    <TextView
        android:id="@+id/tvPlayFromStart"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:gravity="center"
        android:minHeight="36dp"
        android:paddingStart="5dp"
        android:paddingLeft="5dp"
        android:paddingEnd="5dp"
        android:paddingRight="5dp"
        android:text="@string/play_from_start"
        android:textAllCaps="true"
        android:textColor="?attr/colorPrimary"
        android:textFontWeight="700"
        android:textSize="14sp"
        android:textStyle="bold" />
</RelativeLayout>
```

## ./app/src/main/res/layout/server_update_fragment.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="top|center"
        android:layout_margin="16dp"
        android:gravity="center"
        android:text="@string/server_update"
        android:textAppearance="@style/TextAppearance.AppCompat.Large" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="start|top"
        android:layout_margin="16dp"
        android:minWidth="320dp"
        android:orientation="vertical"
        android:paddingTop="10dp"
        android:paddingBottom="10dp">

        <com.google.android.flexbox.FlexboxLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:alignContent="flex_start"
            app:alignItems="flex_start"
            app:dividerDrawable="@drawable/flexdivider"
            app:flexWrap="nowrap"
            app:justifyContent="space_evenly"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:showDivider="middle">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:minWidth="160dp"
                android:text="@string/arch"
                android:textSize="16sp" />

            <TextView
                android:id="@+id/tvArch"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:minWidth="160dp"
                android:textColor="?android:attr/textColorPrimary"
                android:textSize="16sp"
                tools:text="arm7" />
        </com.google.android.flexbox.FlexboxLayout>

        <com.google.android.flexbox.FlexboxLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            app:alignContent="flex_start"
            app:alignItems="flex_start"
            app:dividerDrawable="@drawable/flexdivider"
            app:flexDirection="row"
            app:flexWrap="nowrap"
            app:justifyContent="space_evenly"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:showDivider="middle">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:minWidth="160dp"
                android:text="@string/local_server"
                android:textSize="16sp" />

            <TextView
                android:id="@+id/tvLocalVersion"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:minWidth="160dp"
                android:textColor="?android:attr/textColorPrimary"
                android:textSize="16sp"
                tools:text="MatriX.120" />
        </com.google.android.flexbox.FlexboxLayout>

        <com.google.android.flexbox.FlexboxLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="16dp"
            app:alignContent="flex_start"
            app:alignItems="flex_start"
            app:dividerDrawable="@drawable/flexdivider"
            app:flexWrap="nowrap"
            app:justifyContent="space_evenly"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:showDivider="middle">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:minWidth="160dp"
                android:text="@string/update_server"
                android:textSize="16sp" />

            <TextView
                android:id="@+id/tvRemoteVersion"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:minWidth="160dp"
                android:textColor="?android:attr/textColorPrimary"
                android:textSize="16sp"
                tools:text="MatriX.121" />
        </com.google.android.flexbox.FlexboxLayout>
    </LinearLayout>

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginLeft="16dp"
            android:layout_marginTop="10dp"
            android:layout_marginRight="16dp"
            android:layout_marginBottom="70dp"
            android:orientation="vertical">

            <TextView
                android:id="@+id/tvInfo"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="6dp"
                android:text="@string/ffprobe_summary"
                android:visibility="gone"
                tools:text="@string/ffprobe_summary"
                tools:visibility="visible" />


            <Button
                android:id="@+id/btnUpdate"
                style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/install_server_latest">

                <requestFocus />
            </Button>

            <Button
                android:id="@+id/btnUpdateDownload"
                style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                android:layout_width="match_parent"
                android:layout_height="0dp"
                android:layout_weight="1"
                android:text="@string/install_server_local"
                android:visibility="gone" />

            <Button
                android:id="@+id/btnDeleteServer"
                style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/delete_local_server" />

            <Button
                android:id="@+id/btnDownloadFFProbe"
                style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/install_ffprobe"
                android:visibility="gone"
                tools:visibility="visible" />

        </LinearLayout>
    </ScrollView>
</LinearLayout>

```

## ./app/src/main/res/layout/chooser_fragment.xml
```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="5dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:orientation="horizontal">

        <androidx.cardview.widget.CardView
            android:id="@+id/cvPlay"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_margin="3dp"
            android:layout_weight="1"
            android:clickable="true"
            android:focusable="true"
            android:foreground="@drawable/action_selector"
            android:foregroundTint="?attr/colorAccent"
            android:foregroundTintMode="multiply"
            app:cardBackgroundColor="@android:color/transparent"
            app:cardCornerRadius="5dp"
            app:cardElevation="0dp"
            app:cardUseCompatPadding="true">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="center"
                android:minWidth="90dp"
                android:orientation="vertical"
                android:paddingTop="5dp">

                <ImageView
                    android:layout_width="48dp"
                    android:layout_height="48dp"
                    android:layout_gravity="center|top"
                    app:srcCompat="@drawable/ic_video" />

                <TextView
                    android:id="@+id/tvNamePlay"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="center_vertical|center_horizontal|bottom"
                    android:padding="5dp"
                    android:text="@string/play"
                    android:textColor="?attr/colorPrimary" />
            </LinearLayout>
        </androidx.cardview.widget.CardView>

        <androidx.cardview.widget.CardView
            android:id="@+id/cvAddPlay"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_margin="3dp"
            android:layout_weight="1"
            android:clickable="true"
            android:focusable="true"
            android:foreground="@drawable/action_selector"
            android:foregroundTint="?attr/colorAccent"
            android:foregroundTintMode="multiply"
            app:cardBackgroundColor="@android:color/transparent"
            app:cardCornerRadius="5dp"
            app:cardElevation="0dp"
            app:cardUseCompatPadding="true">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="center"
                android:minWidth="90dp"
                android:orientation="vertical"
                android:paddingTop="5dp">

                <FrameLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content">

                    <ImageView
                        android:layout_width="48dp"
                        android:layout_height="48dp"
                        android:layout_gravity="center|top"
                        app:srcCompat="@drawable/ic_video" />

                    <ImageView
                        android:layout_width="24dp"
                        android:layout_height="24dp"
                        android:layout_gravity="bottom|center"
                        android:layout_marginStart="16dp"
                        android:layout_marginLeft="16dp"
                        app:srcCompat="@drawable/ic_plus" />
                </FrameLayout>

                <TextView
                    android:id="@+id/tvNameAP"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="center_vertical|center_horizontal|bottom"
                    android:padding="5dp"
                    android:text="@string/add_play"
                    android:textColor="?attr/colorPrimary" />
            </LinearLayout>

            <requestFocus />
        </androidx.cardview.widget.CardView>

        <androidx.cardview.widget.CardView
            android:id="@+id/cvAdd"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_margin="3dp"
            android:layout_weight="1"
            android:clickable="true"
            android:focusable="true"
            android:foreground="@drawable/action_selector"
            android:foregroundTint="?attr/colorAccent"
            android:foregroundTintMode="multiply"
            app:cardBackgroundColor="@android:color/transparent"
            app:cardCornerRadius="5dp"
            app:cardElevation="0dp"
            app:cardUseCompatPadding="true">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="center"
                android:minWidth="90dp"
                android:orientation="vertical"
                android:paddingTop="5dp">

                <ImageView
                    android:layout_width="48dp"
                    android:layout_height="48dp"
                    android:layout_gravity="center|top"
                    app:srcCompat="@drawable/ic_add" />

                <TextView
                    android:id="@+id/tvNameAdd"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="center_vertical|center_horizontal|bottom"
                    android:padding="5dp"
                    android:text="@string/add"
                    android:textColor="?attr/colorPrimary" />
            </LinearLayout>
        </androidx.cardview.widget.CardView>
    </LinearLayout>

    <com.google.android.material.switchmaterial.SwitchMaterial
        android:id="@+id/cbSaveChooseAction"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:paddingStart="10dp"
        android:paddingLeft="10dp"
        android:text="@string/make_as_def"
        android:textAllCaps="true"
        android:textColor="?attr/colorAccent" />

</LinearLayout>
```

## ./app/src/main/res/layout/main_fragment.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <ListView
        android:id="@+id/lvTorrents"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:divider="@drawable/gradient_divider_green"
        android:fadingEdge="vertical"
        android:fadingEdgeLength="84dp"
        android:listSelector="@drawable/action_selector"
        android:requiresFadingEdge="vertical" />

    <TextView
        android:id="@+id/empty_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="center"
        android:text="@string/no_torrents"
        android:textSize="18sp"
        android:visibility="gone" />

</FrameLayout>
```

## ./app/src/main/res/layout/server_settings_fragment.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_above="@+id/linearLayout"
        android:layout_alignParentStart="true"
        android:layout_alignParentLeft="true"
        android:fadingEdge="vertical"
        android:fadingEdgeLength="50dp"
        android:requiresFadingEdge="vertical">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:paddingTop="16.0dip"
                android:text="@string/torserver_title"
                android:textAllCaps="true"
                android:textAppearance="@style/TextAppearance.MaterialComponents.Subtitle1"
                android:textColor="?attr/colorPrimary"
                android:textSize="16sp" />

            <TextView
                android:id="@+id/tvServerAddr"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:textAppearance="@style/TextAppearance.AppCompat.Large"
                android:textColor="?attr/colorHost"
                android:textSize="16sp" />
            <!-- CACHE SIZE -->
            <com.google.android.material.textfield.TextInputLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:hint="@string/cache_size">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/etCacheSize"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="numberSigned" />

                <requestFocus />
            </com.google.android.material.textfield.TextInputLayout>
            <!-- READAHEAD -->
            <com.google.android.material.textfield.TextInputLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:hint="@string/torrent_preload">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/etPreloadTorrent"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="numberSigned" />
            </com.google.android.material.textfield.TextInputLayout>
            <!-- PRELOAD -->
            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/lbPreloadCache"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:hint="@string/torrent_preload_cache"
                android:visibility="gone"
                tools:visibility="visible">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/etPreloadCache"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="numberSigned"
                    android:nextFocusDown="@id/cbSaveOnDisk" />
            </com.google.android.material.textfield.TextInputLayout>
            <!-- BUFFER -->
            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/cbPreloadBuffer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/preload_before_start" />

            <TextView
                android:id="@+id/lbPreloadBuffer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="20dp"
                android:labelFor="@+id/cbPreloadBuffer"
                android:text="@string/preload_before_start_desc" />
            <!-- Cache on Disc -->
            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/cbSaveOnDisk"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/save_on_disk" />

            <TextView
                android:id="@+id/lbSaveOnDisk"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="20dp"
                android:labelFor="@+id/cbSaveOnDisk"
                android:text="@string/save_on_disk_desc" />
            <!-- Remove Cache on Drop -->
            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/cbRemoveCacheOnDrop"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/remove_cache_on_drop" />

            <TextView
                android:id="@+id/lbRemoveCacheOnDrop"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="20dp"
                android:labelFor="@+id/cbRemoveCacheOnDrop"
                android:text="@string/remove_cache_on_drop_desc" />
            <!-- Content Path -->
            <TextView
                android:id="@+id/lbContentPath"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="10dp"
                android:layout_marginBottom="5dp"
                android:labelFor="@+id/btnContentPath"
                android:text="@string/save_content_path"
                android:textColor="?attr/colorBright"
                android:textSize="16sp" />

            <Button
                android:id="@+id/btnContentPath"
                style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:nextFocusUp="@id/cbRemoveCacheOnDrop"
                android:nextFocusDown="@id/cbEnableIPv6" />
            <!-- IPv6 -->
            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/cbEnableIPv6"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/enable_ipv6" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="20dp"
                android:labelFor="@+id/cbEnableIPv6"
                android:text="@string/enable_ipv6_desc" />
            <!-- TCP -->
            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/cbDisableTCP"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/disable_tcp" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="20dp"
                android:labelFor="@+id/cbDisableTCP"
                android:text="@string/disable_tcp_desc" />
            <!-- UTP -->
            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/cbDisableUTP"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/disable_utp" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="20dp"
                android:labelFor="@+id/cbDisableUTP"
                android:text="@string/disable_utp_desc" />
            <!-- PEX -->
            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/cbDisablePEX"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/disable_pex" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="20dp"
                android:labelFor="@+id/cbDisablePEX"
                android:text="@string/disable_pex_desc" />
            <!-- Force Encrypt -->
            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/cbForceEncrypt"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:nextFocusDown="@id/etDisconnectTimeout"
                android:text="@string/force_encrypt" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="20dp"
                android:labelFor="@+id/cbForceEncrypt"
                android:text="@string/force_encrypt_desc" />
            <!-- Disconnect Timeout -->
            <com.google.android.material.textfield.TextInputLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:hint="@string/torrent_disconnect_timeout">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/etDisconnectTimeout"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="numberSigned" />
            </com.google.android.material.textfield.TextInputLayout>
            <!-- Conn Limit -->
            <com.google.android.material.textfield.TextInputLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:hint="@string/connections_limit">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/etConnectionsLimit"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="numberSigned"
                    android:nextFocusDown="@id/cbDisableDHT" />
            </com.google.android.material.textfield.TextInputLayout>
            <!-- DHT -->
            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/cbDisableDHT"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:nextFocusUp="@id/etConnectionsLimit"
                android:nextFocusDown="@id/etDownloadRateLimit"
                android:text="@string/disable_dht" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="20dp"
                android:labelFor="@+id/cbDisableDHT"
                android:text="@string/disable_dht_desc" />
            <!-- Limit DHT -->
            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/tvConnectionsDhtLimit"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:hint="@string/connections_dht_limit">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/etConnectionsDhtLimit"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content" />
            </com.google.android.material.textfield.TextInputLayout>
            <!-- Download Speed -->
            <com.google.android.material.textfield.TextInputLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:hint="@string/download_rate_limit">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/etDownloadRateLimit"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="numberSigned"
                    android:nextFocusDown="@id/cbDisableUpload" />
            </com.google.android.material.textfield.TextInputLayout>
            <!-- Disable Upload -->
            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/cbDisableUpload"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:nextFocusDown="@id/etUploadRateLimit"
                android:text="@string/disable_upload" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="20dp"
                android:labelFor="@+id/cbDisableUpload"
                android:text="@string/disable_upload_desc" />
            <!-- Upload Speed -->
            <com.google.android.material.textfield.TextInputLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:hint="@string/upload_rate_limit">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/etUploadRateLimit"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content" />
            </com.google.android.material.textfield.TextInputLayout>
            <!-- Peers Port -->
            <com.google.android.material.textfield.TextInputLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:hint="@string/peers_listen_port">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/etPeersListenPort"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="numberSigned"
                    android:nextFocusDown="@id/cbDisableUPNP" />
            </com.google.android.material.textfield.TextInputLayout>
            <!-- UPNP -->
            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/cbDisableUPNP"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:nextFocusUp="@id/etPeersListenPort"
                android:text="@string/disable_upnp" />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="20dp"
                android:labelFor="@+id/cbDisableUPNP"
                android:text="@string/disable_upnp_desc" />
            <!-- DLNA -->
            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/cbEnableDLNA"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/enable_dlna"
                android:visibility="gone"
                tools:visibility="visible" />

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/tvFriendlyName"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:hint="@string/dlna_friendly_name"
                android:visibility="gone"
                app:helperText="@string/dlna_name_hint"
                app:helperTextEnabled="true"
                tools:visibility="visible">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/etFriendlyName"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="text" />
            </com.google.android.material.textfield.TextInputLayout>
            <!-- RUTOR -->
            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/cbEnableRutorSearch"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/enable_rutor_search"
                android:visibility="gone"
                tools:visibility="visible" />

            <TextView
                android:id="@+id/tvEnableRutorSearch"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="20dp"
                android:labelFor="@+id/cbEnableRutorSearch"
                android:text="@string/enable_rutor_search_desc"
                android:visibility="gone"
                tools:visibility="visible" />
            <!-- DEBUG -->
            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/cbEnableDebug"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:text="@string/enable_debug"
                android:visibility="gone"
                tools:visibility="visible" />
            <!-- READER -->
            <com.google.android.material.switchmaterial.SwitchMaterial
                android:id="@+id/cbResponsiveMode"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:text="@string/enable_responsive_mode"
                android:visibility="gone"
                tools:visibility="visible" />

            <View
                android:layout_width="match_parent"
                android:layout_height="10dp"
                android:background="@android:color/transparent" />
            <!-- Retrackers -->
            <com.google.android.material.textfield.TextInputLayout
                style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox.ExposedDropdownMenu"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="@string/retrackers">

                <AutoCompleteTextView
                    android:id="@+id/actvRetracker"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="none" />
            </com.google.android.material.textfield.TextInputLayout>

            <View
                android:layout_width="match_parent"
                android:layout_height="30dp"
                android:background="@android:color/transparent" />

            <Button
                android:id="@+id/btnDefaultSets"
                style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/default_sets" />

            <View
                android:layout_width="match_parent"
                android:layout_height="10dp"
                android:background="@android:color/transparent" />

        </LinearLayout>
    </ScrollView>

    <LinearLayout
        android:id="@+id/linearLayout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:orientation="vertical">

        <!--TextView
            android:id="@+id/textViewStatus"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content" /-->

        <LinearLayout
            android:id="@+id/footer"
            style="@android:style/DeviceDefault.ButtonBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_margin="10dp"
            android:divider="?android:attr/dividerVertical"
            android:orientation="horizontal"
            android:showDividers="none">

            <Button
                android:id="@+id/btnApply"
                style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                android:layout_width="0px"
                android:layout_height="match_parent"
                android:layout_marginStart="5dp"
                android:layout_marginLeft="5dp"
                android:layout_marginEnd="8dp"
                android:layout_marginRight="8dp"
                android:layout_weight="1"
                android:text="@string/apply" />

            <Button
                android:id="@+id/btnCancel"
                style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                android:layout_width="0px"
                android:layout_height="match_parent"
                android:layout_marginStart="8dp"
                android:layout_marginLeft="8dp"
                android:layout_marginEnd="5dp"
                android:layout_marginRight="5dp"
                android:layout_weight="1"
                android:text="@android:string/cancel" />
        </LinearLayout>
    </LinearLayout>

</RelativeLayout>

```

## ./app/src/main/res/layout/server_finder_fragment.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:orientation="vertical"
        android:padding="8dp">

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="5dp"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:paddingStart="10dp"
                android:paddingLeft="10dp"
                android:paddingEnd="4dp"
                android:paddingRight="4dp"
                android:text="@string/local_ip"
                android:textSize="16sp" />

            <TextView
                android:id="@+id/tvCurrentIP"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:maxLines="2"
                android:textColor="?attr/colorBright"
                android:textSize="16sp"
                tools:text="192.168.177.211, 192.168.131.124" />
        </LinearLayout>

        <com.google.android.material.textfield.TextInputLayout
            android:id="@+id/tvFriendlyName"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:layout_marginLeft="8dp"
            android:layout_marginTop="8dp"
            android:layout_marginEnd="8dp"
            android:layout_marginRight="8dp"
            android:hint="@string/host_title"
            app:helperText="@string/host_title_hint"
            app:helperTextEnabled="true">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/etHost"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:inputType="textUri"
                android:textAppearance="@style/TextAppearance.AppCompat.Medium"
                android:textColor="?attr/colorHost">

                <requestFocus />
            </com.google.android.material.textfield.TextInputEditText>
        </com.google.android.material.textfield.TextInputLayout>

        <Button
            android:id="@+id/btnFindHosts"
            style="@style/Widget.MaterialComponents.Button.OutlinedButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:paddingStart="40dp"
            android:paddingLeft="40dp"
            android:paddingEnd="40dp"
            android:paddingRight="40dp"
            android:text="@string/find_hosts"
            android:textSize="16sp" />

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/rvHosts"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:fadingEdgeLength="20dp"
            android:requiresFadingEdge="vertical" />

    </LinearLayout>

    <LinearLayout
        android:id="@+id/footer"
        style="@android:style/DeviceDefault.ButtonBar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_margin="10dp"
        android:divider="?android:attr/dividerVertical"
        android:orientation="horizontal"
        android:showDividers="none">

        <Button
            android:id="@+id/btnApply"
            style="@style/Widget.MaterialComponents.Button.OutlinedButton"
            android:layout_width="0px"
            android:layout_height="wrap_content"
            android:layout_marginStart="5dp"
            android:layout_marginLeft="5dp"
            android:layout_marginEnd="8dp"
            android:layout_marginRight="8dp"
            android:layout_weight="1"
            android:text="@string/apply" />

        <Button
            android:id="@+id/btnCancel"
            style="@style/Widget.MaterialComponents.Button.OutlinedButton"
            android:layout_width="0px"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:layout_marginLeft="8dp"
            android:layout_marginEnd="5dp"
            android:layout_marginRight="5dp"
            android:layout_weight="1"
            android:text="@android:string/cancel" />
    </LinearLayout>

</LinearLayout>
```

## ./app/src/main/res/layout/donate_fragment.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_marginTop="30dp"
    android:baselineAligned="false"
    android:orientation="vertical"
    android:padding="16dp">

    <ImageView
        android:id="@+id/boosty"
        android:layout_width="wrap_content"
        android:layout_height="64dp"
        android:layout_gravity="start"
        android:layout_marginTop="10dp"
        android:adjustViewBounds="true"
        android:contentDescription="@string/tbank"
        app:srcCompat="@drawable/boosty" />

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_marginStart="12dp"
            android:layout_marginLeft="12dp"
            android:layout_marginEnd="12dp"
            android:layout_marginRight="12dp"
            android:text="@string/boosty_msg"
            android:textSize="18sp" />

        <Button
            android:id="@+id/btnBoosty"
            style="@style/Widget.MaterialComponents.Button.OutlinedButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="3dp"
            android:text="@string/link"
            android:textSize="14sp" />

    </LinearLayout>

    <ImageView
        android:id="@+id/yandex"
        android:layout_width="wrap_content"
        android:layout_height="50dp"
        android:layout_gravity="start"
        android:layout_marginTop="15dp"
        android:adjustViewBounds="true"
        android:contentDescription="@string/yandex_money_card"
        app:srcCompat="@drawable/io" />

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_marginStart="12dp"
            android:layout_marginLeft="12dp"
            android:layout_marginEnd="12dp"
            android:layout_marginRight="12dp"
            android:text="@string/yandex_money_card"
            android:textSize="18sp" />

        <Button
            android:id="@+id/btnYandex"
            style="@style/Widget.MaterialComponents.Button.OutlinedButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/link"
            android:textSize="14sp" />

    </LinearLayout>

    <ImageView
        android:id="@+id/imgTB"
        android:layout_width="wrap_content"
        android:layout_height="58dp"
        android:layout_gravity="start"
        android:layout_marginStart="6dp"
        android:layout_marginLeft="6dp"
        android:layout_marginTop="10dp"
        android:adjustViewBounds="true"
        android:contentDescription="@string/tbank"
        app:srcCompat="@drawable/tbank" />

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_marginStart="12dp"
            android:layout_marginLeft="12dp"
            android:layout_marginEnd="12dp"
            android:layout_marginRight="12dp"
            android:text="@string/tbank"
            android:textSize="18sp" />

        <Button
            android:id="@+id/btnTB"
            style="@style/Widget.MaterialComponents.Button.OutlinedButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="3dp"
            android:text="@string/link"
            android:textSize="14sp" />

    </LinearLayout>

    <ImageView
        android:id="@+id/ivTelegram"
        android:layout_width="wrap_content"
        android:layout_height="60dp"
        android:layout_gravity="start"
        android:layout_marginTop="10dp"
        android:adjustViewBounds="true"
        android:contentDescription="@string/telegram_msg"
        app:srcCompat="@drawable/telegram" />

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_marginStart="12dp"
            android:layout_marginLeft="12dp"
            android:layout_marginEnd="12dp"
            android:layout_marginRight="12dp"
            android:text="@string/telegram_msg"
            android:textSize="18sp" />

        <Button
            android:id="@+id/btnTelegram"
            style="@style/Widget.MaterialComponents.Button.OutlinedButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="3dp"
            android:text="@string/link"
            android:textSize="14sp" />

    </LinearLayout>
</LinearLayout>
```

## ./app/src/main/res/layout/navigation_menu.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/menulayout"
    android:layout_width="240dp"
    android:layout_height="match_parent"
    android:layout_gravity="start"
    android:background="?attr/colorMainMenu"
    android:orientation="vertical">

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical">

            <FrameLayout
                android:id="@+id/header"
                android:layout_width="match_parent"
                android:layout_height="120dp"
                android:clickable="true"
                android:focusable="true"
                android:foreground="@drawable/action_selector">

                <ImageView
                    android:layout_width="72dp"
                    android:layout_height="72dp"
                    android:layout_gravity="center|top"
                    android:layout_marginTop="3dp"
                    android:contentDescription="@string/app_name"
                    android:padding="5dp"
                    android:src="@mipmap/ic_launcher" />

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:layout_gravity="center|bottom"
                    android:layout_marginBottom="7dp"
                    android:orientation="vertical">

                    <TextView
                        android:id="@+id/tvCurrentHost"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:gravity="center"
                        android:textAppearance="@android:style/TextAppearance.Medium"
                        android:textSize="16sp"
                        tools:text="http://localhost:8090"/>
                    <!--android:textColor="?attr/colorHost"-->

                    <TextView
                        android:id="@+id/tvStatus"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_gravity="center_horizontal"
                        android:includeFontPadding="true"
                        android:paddingStart="4dp"
                        android:paddingLeft="4dp"
                        android:paddingEnd="4dp"
                        android:paddingRight="4dp"
                        android:gravity="center"
                        tools:text="Status"
                        android:textSize="12sp" />
                </LinearLayout>

            </FrameLayout>

            <View
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:background="?android:attr/listDivider" />

            <FrameLayout
                android:id="@+id/btnAdd"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:clickable="true"
                android:focusable="true"
                android:foreground="@drawable/action_selector"
                android:padding="15dp">

                <ImageView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_gravity="left|center_vertical"
                    app:srcCompat="@drawable/ic_outline_add" />

                <TextView
                    style="@style/MainMenuTextAppearance"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="left|center_vertical"
                    android:paddingLeft="40dp"
                    android:paddingStart="40dp"
                    android:text="@string/add" />
            </FrameLayout>

            <View
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:background="?android:attr/listDivider" />

            <FrameLayout
                android:id="@+id/btnRemoveAll"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:clickable="true"
                android:focusable="true"
                android:foreground="@drawable/action_selector"
                android:padding="15dp">

                <ImageView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_gravity="left|center_vertical"
                    app:srcCompat="@drawable/ic_outline_remove" />

                <TextView
                    style="@style/MainMenuTextAppearance"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="left|center_vertical"
                    android:paddingLeft="40dp"
                    android:paddingStart="40dp"
                    android:text="@string/remove_all" />
            </FrameLayout>

            <View
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:background="?android:attr/listDivider" />

            <FrameLayout
                android:id="@+id/btnPlaylist"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:clickable="true"
                android:focusable="true"
                android:foreground="@drawable/action_selector"
                android:padding="15dp">

                <ImageView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_gravity="left|center_vertical"
                    app:srcCompat="@drawable/ic_outline_playlist_play" />

                <TextView
                    style="@style/MainMenuTextAppearance"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="left|center_vertical"
                    android:paddingLeft="40dp"
                    android:paddingStart="40dp"
                    android:text="@string/playlist" />
            </FrameLayout>

            <View
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:background="?android:attr/listDivider" />

            <FrameLayout
                android:id="@+id/btnDonate"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:clickable="true"
                android:focusable="true"
                android:foreground="@drawable/action_selector"
                android:padding="15dp">

                <ImageView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_gravity="left|center_vertical"
                    app:srcCompat="@drawable/ic_thumb_up" />

                <TextView
                    style="@style/MainMenuTextAppearance"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="left|center_vertical"
                    android:paddingLeft="40dp"
                    android:paddingStart="40dp"
                    android:text="@string/donate" />
            </FrameLayout>

            <View
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:background="?android:attr/listDivider" />

            <FrameLayout
                android:id="@+id/btnUpdate"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:clickable="true"
                android:focusable="true"
                android:foreground="@drawable/action_selector"
                android:padding="15dp">

                <ImageView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_gravity="left|center_vertical"
                    app:srcCompat="@drawable/ic_refresh" />

                <TextView
                    style="@style/MainMenuTextAppearance"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="left|center_vertical"
                    android:paddingLeft="40dp"
                    android:paddingStart="40dp"
                    android:text="@string/update" />
            </FrameLayout>

            <View
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:background="?android:attr/listDivider" />

            <FrameLayout
                android:id="@+id/btnSettings"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:clickable="true"
                android:focusable="true"
                android:foreground="@drawable/action_selector"
                android:padding="15dp">

                <ImageView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_gravity="left|center_vertical"
                    app:srcCompat="@drawable/ic_settings" />

                <TextView
                    style="@style/MainMenuTextAppearance"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="left|center_vertical"
                    android:paddingLeft="40dp"
                    android:paddingStart="40dp"
                    android:text="@string/settings" />
            </FrameLayout>

            <View
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:background="?android:attr/listDivider" />

            <FrameLayout
                android:id="@+id/btnExit"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:clickable="true"
                android:focusable="true"
                android:foreground="@drawable/action_selector"
                android:padding="15dp">

                <ImageView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:layout_gravity="left|center_vertical"
                    app:srcCompat="@drawable/ic_outline_exit_to_app" />

                <TextView
                    style="@style/MainMenuTextAppearance"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_gravity="left|center_vertical"
                    android:paddingLeft="40dp"
                    android:paddingStart="40dp"
                    android:text="@string/exit" />
            </FrameLayout>

            <View
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:background="?android:attr/listDivider" />

        </LinearLayout>
    </ScrollView>
</LinearLayout>
```

## ./app/src/main/res/layout/layout_toast.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<ru.yourok.torrserve.app.AppToastView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content" />
```

## ./app/src/main/res/layout/play_activity.xml
```xml
<?xml version="1.0" encoding="utf-8"?>

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/container"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    tools:context=".ui.activities.play.PlayActivity">

    <ImageView
        android:id="@+id/ivAd"
        android:layout_width="fill_parent"
        android:layout_height="100dp"
        android:layout_gravity="top|center"
        android:adjustViewBounds="true"
        android:maxHeight="50dp"
        android:paddingStart="5dp"
        android:paddingLeft="5dp"
        android:paddingTop="5dp"
        android:paddingEnd="5dp"
        android:paddingRight="5dp"
        android:scaleType="fitCenter"
        android:visibility="gone" />

    <TextView
        android:id="@+id/info_title"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="10dp"
        android:alpha="1.0"
        android:gravity="center"
        android:text="@string/app_name"
        android:textAppearance="@style/TextAppearance.AppCompat.Medium"
        android:textColor="?attr/colorPrimary" />

    <FrameLayout
        android:id="@+id/info_container"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:minHeight="6dp" />

    <com.google.android.material.progressindicator.LinearProgressIndicator
        android:id="@+id/progressBar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="top"
        android:layout_marginStart="12dp"
        android:layout_marginLeft="12dp"
        android:layout_marginTop="6dp"
        android:layout_marginEnd="12dp"
        android:layout_marginRight="12dp"
        android:layout_marginBottom="6dp"
        android:indeterminate="true"
        android:visibility="gone"
        app:trackCornerRadius="2dp"
        app:trackThickness="4dp"
        tools:visibility="visible" />

    <FrameLayout
        android:id="@+id/bottom_container"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:minHeight="6dp" />

</LinearLayout>
```

## ./app/src/main/res/layout/speedtest_fragment.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:gravity="center_horizontal"
            android:orientation="vertical">

            <TextView
                android:id="@+id/tvTitle"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:padding="16dp"
                android:text=""
                android:textAppearance="@style/TextAppearance.MaterialComponents.Subtitle1"
                android:textColor="?attr/colorHost"
                android:textSize="20sp"
                android:visibility="gone"
                tools:text="localhost:8090"
                tools:visibility="visible" />

            <FrameLayout
                android:id="@+id/speedometer"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content">

                <com.github.anastr.speedviewlib.PointerSpeedometer
                    android:id="@+id/tubeSpeedometer"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    app:sv_backgroundCircleColor="@android:color/transparent"
                    app:sv_indicator="NormalSmallIndicator"
                    app:sv_indicatorColor="@color/orange_dark"
                    app:sv_markColor="@color/orange_dark"
                    app:sv_pointerColor="@color/orange_dark"
                    app:sv_speedTextColor="?attr/colorPrimary"
                    app:sv_speedTextPadding="0dp"
                    app:sv_speedTextSize="20sp"
                    app:sv_speedometerColor="@color/orange_dark"
                    app:sv_speedometerWidth="8dp"
                    app:sv_textColor="@color/orange_dark"
                    app:sv_unitTextColor="?attr/colorPrimary"
                    app:sv_unitTextSize="20sp"
                    app:sv_unitUnderSpeedText="false"
                    app:sv_withPointer="false" />

                <LinearLayout
                    android:layout_width="88dp"
                    android:layout_height="88dp"
                    android:layout_gravity="center"
                    android:background="@drawable/ts_round" />

            </FrameLayout>

            <TextView
                android:id="@+id/tvSPStatus"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginStart="20dp"
                android:layout_marginLeft="20dp"
                android:layout_marginEnd="20dp"
                android:layout_marginRight="20dp"
                android:paddingTop="6dp"
                android:paddingBottom="3dp"
                android:text=""
                android:textAppearance="@style/TextAppearance.MaterialComponents.Subtitle1"
                android:textColor="?attr/colorBright"
                android:textSize="16sp"
                tools:text="Some error can produce long description here and take few lines" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="center_horizontal"
                android:orientation="vertical">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="3dp"
                    android:gravity="center_horizontal"
                    android:orientation="horizontal">

                    <Button
                        android:id="@+id/btn100mb"
                        style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_margin="3dp"
                        android:text="100 MB"
                        android:textSize="14sp" />

                    <Button
                        android:id="@+id/btn500mb"
                        style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_margin="3dp"
                        android:text="500 MB"
                        android:textSize="14sp" />

                    <Button
                        android:id="@+id/btn1000mb"
                        style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_margin="3dp"
                        android:text="1 GB"
                        android:textSize="14sp" />

                    <Button
                        android:id="@+id/btn5000mb"
                        style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_margin="3dp"
                        android:text="5 GB"
                        android:textSize="14sp" />
                </LinearLayout>

                <Button
                    android:id="@+id/btnStop"
                    style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/cancel"
                    android:textSize="14sp" />
            </LinearLayout>
        </LinearLayout>
    </ScrollView>
</LinearLayout>
```

## ./app/src/main/res/layout/directory_chooser_fragment.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <LinearLayout
        android:id="@+id/dirCtrlLayout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <ImageButton
            android:id="@+id/btnUpDir"
            android:background="@drawable/action_selector"
            android:focusable="true"
            android:clickable="true"
            app:srcCompat="@drawable/ic_arrow_upward"
            android:layout_width="65dp"
            android:layout_height="65dp" />

        <LinearLayout
            android:padding="5dp"
            android:layout_weight="1"
            android:orientation="vertical"
            android:layout_width="match_parent"
            android:layout_height="match_parent">

            <TextView
                android:id="@+id/tvCurrSize"
                android:textStyle="bold"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />

            <TextView
                android:id="@+id/tvCurrDir"
                android:layout_width="match_parent"
                android:layout_height="match_parent" />
        </LinearLayout>

        <ImageButton
            android:id="@+id/btnCreateDir"
            android:background="@drawable/action_selector"
            android:focusable="true"
            android:clickable="true"
            app:srcCompat="@drawable/ic_create_new_folder"
            android:layout_width="65dp"
            android:layout_height="65dp" />

    </LinearLayout>

    <LinearLayout
        android:id="@+id/dirNameLayout"
        android:visibility="gone"
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <EditText
            android:id="@+id/etDirName"
            android:layout_weight="1"
            android:layout_gravity="center"
            android:ems="10"
            android:inputType="textUri"
            android:nextFocusRight="@id/btnDone"
            android:nextFocusDown="@id/rvListDir"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <ImageButton
            android:id="@+id/btnDone"
            app:srcCompat="@drawable/ic_done"
            android:background="@drawable/action_selector"
            android:focusable="true"
            android:clickable="true"
            android:layout_width="65dp"
            android:layout_height="65dp" />

    </LinearLayout>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/rvListDir"
        android:layout_weight="1"
        android:layout_width="match_parent"
        android:layout_height="0dp" />


    <LinearLayout
        android:id="@+id/footer"
        style="@android:style/DeviceDefault.ButtonBar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_margin="10dp"
        android:divider="?android:attr/dividerVertical"
        android:orientation="horizontal"
        android:showDividers="none">

    </LinearLayout>

</LinearLayout>
```

## ./app/src/main/res/color/thumb_color.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_checked="true" android:color="?attr/colorAccent" />
    <item android:color="?attr/colorBright" /><!--unchecked-->
</selector>


```

## ./app/src/main/res/color/text_color.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_pressed="true" android:color="?attr/colorAccent" android:alpha="0.5" /><!-- pressed -->
    <item android:state_focused="true" android:color="?attr/colorAccent" android:alpha="1.0" /><!-- focused -->
    <item android:color="?attr/colorBright" android:alpha="1.0"/><!-- default -->
</selector>
```

## ./app/src/main/res/values-night/themes.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- DayNight Theme -->
    <style name="Theme.TorrServe.DayNight" parent="Theme.TorrServe.Black" />
    <style name="PlayDialog.DayNight" parent="PlayDialog.Black" />
</resources>
```

## ./app/src/main/res/values/colors.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="tv_white">#eee</color>
    <color name="orange">#ffa724</color>
    <color name="orange_dark">#ff7e00</color>
    <color name="green">#3fb57a</color>
    <color name="black">#000</color>
    <color name="black_opaque">#030303</color>
    <color name="white_10">#1affffff</color>
    <color name="light_gray">#ccc</color>
    <color name="gray">#555</color>
    <color name="dark_gray">#2b2b2b</color>
    <color name="dark_brown">#2a2122</color>
    <color name="scrim_20">#33777777</color>
    <color name="scrim_30">#4d777777</color>
    <color name="snackbar">#fa555555</color>
</resources>
```

## ./app/src/main/res/values/themes.xml
```xml
<resources xmlns:tools="http://schemas.android.com/tools">
    <attr name="colorBright" format="reference" />
    <attr name="colorHost" format="reference" />
    <attr name="colorMainMenu" format="reference" />
    <!-- Base application theme. https://material.io/develop/android/docs/getting-started -->
    <style name="Theme.TorrServe.Dark" parent="Theme.MaterialComponents">
        <item name="windowNoTitle">true</item>
        <item name="windowActionBar">false</item>
        <item name="android:windowBackground">@color/dark_gray</item>
        <!-- attr colors -->
        <item name="colorBright">@color/tv_white</item>
        <item name="colorHost">@color/green</item>
        <item name="colorMainMenu">@color/dark_gray</item>
        <!-- Primary brand color -->
        <item name="colorPrimary">@color/orange</item>
        <item name="colorPrimaryVariant">@color/orange_dark</item>
        <item name="colorOnPrimary">@color/green</item>
        <!-- Secondary brand color -->
        <item name="colorSecondary">@color/orange</item>
        <item name="colorSecondaryVariant">@color/orange_dark</item>
        <item name="colorOnSecondary">@color/green</item>
        <!-- Status bar color -->
        <item name="android:statusBarColor" tools:targetApi="l">@color/dark_gray</item>
        <!-- Bottom bar color -->
        <item name="android:navigationBarColor" tools:targetApi="l">@color/dark_gray</item>
        <!-- Custom -->
        <item name="android:activatedBackgroundIndicator">@drawable/activated_background</item>
        <item name="android:listDivider">@drawable/gradient_divider_green</item>
        <item name="checkboxStyle">@style/Widget.App.CheckBox</item>
        <item name="radioButtonStyle">@style/Widget.App.RadioButton</item>
        <item name="snackbarStyle">@style/MaterialSnackbarTheme</item>
        <item name="snackbarButtonStyle">@style/MaterialSnackbarButtonTheme</item>
        <item name="switchStyle">@style/Widget.App.Switch</item>
        <item name="textInputStyle">@style/Widget.App.TextInputLayout</item>
        <item name="alertDialogTheme">@style/AlertDialog</item>
    </style>
    <!-- Light Theme -->
    <style name="Theme.TorrServe.Light" parent="Theme.MaterialComponents.Light">
        <item name="windowNoTitle">true</item>
        <item name="windowActionBar">false</item>
        <item name="android:windowBackground">@color/tv_white</item>
        <!-- attr colors -->
        <item name="colorBright">@color/dark_brown</item>
        <item name="colorHost">@color/orange_dark</item>
        <item name="colorMainMenu">@color/light_gray</item>
        <!-- colors -->
        <item name="colorPrimary">@color/dark_brown</item>
        <item name="colorPrimaryVariant">@color/orange_dark</item>
        <item name="colorOnPrimary">@color/green</item>
        <item name="colorSecondary">@color/dark_brown</item>
        <item name="colorSecondaryVariant">@color/orange_dark</item>
        <item name="colorOnSecondary">@color/green</item>
        <!-- bars -->
        <item name="android:statusBarColor" tools:targetApi="l">@color/light_gray</item>
        <item name="android:navigationBarColor" tools:targetApi="l">@color/light_gray</item>
        <!-- custom -->
        <item name="android:activatedBackgroundIndicator">@drawable/activated_background</item>
        <item name="checkboxStyle">@style/Widget.App.CheckBox</item>
        <item name="radioButtonStyle">@style/Widget.App.RadioButton</item>
        <item name="snackbarStyle">@style/MaterialSnackbarTheme</item>
        <item name="snackbarButtonStyle">@style/MaterialSnackbarButtonTheme</item>
        <item name="switchStyle">@style/Widget.App.Switch</item>
        <item name="textInputStyle">@style/Widget.App.TextInputLayout</item>
        <item name="alertDialogTheme">@style/AlertDialog.Light</item>
    </style>
    <!-- Black Theme -->
    <style name="Theme.TorrServe.Black" parent="Theme.TorrServe.Dark">
        <!-- attr colors -->
        <item name="colorHost">@color/orange</item>
        <item name="colorMainMenu">@color/black</item>
        <!-- colors -->
        <item name="colorPrimary">@color/green</item>
        <item name="colorPrimaryDark">@color/black</item>
        <item name="colorOnPrimary">@color/orange</item>
        <item name="colorSecondary">@color/green</item>
        <item name="android:strokeColor" tools:targetApi="l">@color/white_10</item>
        <item name="android:windowBackground">@color/black</item>
        <item name="android:colorBackground">@color/black</item>
        <item name="colorBackgroundFloating">@color/black_opaque</item>
        <item name="android:statusBarColor" tools:targetApi="l">@color/black_opaque</item>
        <item name="android:navigationBarColor" tools:targetApi="l">@color/black_opaque</item>
        <item name="alertDialogTheme">@style/AlertDialog.Black</item>
    </style>
    <!-- DayNight Theme -->
    <style name="Theme.TorrServe.DayNight" parent="Theme.TorrServe.Dark" />
    <!-- Play Dialog Dark Style -->
    <style name="PlayDialog.Dark" parent="Theme.MaterialComponents.Dialog">
        <item name="windowNoTitle">true</item>
        <item name="windowActionBar">false</item>
        <item name="android:listDivider">@drawable/gradient_divider_white</item>
        <item name="android:windowBackground">@drawable/rc_background_dark</item>
        <!-- attr colors -->
        <item name="colorBright">@color/tv_white</item>
        <item name="colorHost">@color/green</item>
        <!-- colors -->
        <item name="colorPrimary">@color/orange</item>
        <item name="colorPrimaryVariant">@color/orange_dark</item>
        <item name="colorOnPrimary">@color/green</item>
        <item name="colorSecondary">@color/orange</item>
        <item name="colorSecondaryVariant">@color/orange_dark</item>
        <item name="colorOnSecondary">@color/green</item>
        <item name="android:statusBarColor" tools:targetApi="l">@color/dark_gray</item>
        <item name="android:navigationBarColor" tools:targetApi="l">@color/dark_gray</item>
        <item name="textInputStyle">@style/Widget.App.TextInputLayout</item>
        <item name="alertDialogTheme">@style/AlertDialog</item>
    </style>
    <!-- Play Dialog Light Style -->
    <style name="PlayDialog.Light" parent="Theme.MaterialComponents.Light.Dialog">
        <item name="windowNoTitle">true</item>
        <item name="windowActionBar">false</item>
        <item name="android:listDivider">@drawable/gradient_divider_white</item>
        <item name="android:windowBackground">@drawable/rc_background_light</item>
        <!-- attr colors -->
        <item name="colorBright">@color/dark_brown</item>
        <item name="colorHost">@color/orange_dark</item>
        <!-- colors -->
        <item name="colorPrimary">@color/dark_brown</item>
        <item name="colorPrimaryVariant">@color/orange_dark</item>
        <item name="colorOnPrimary">@color/green</item>
        <item name="colorSecondary">@color/dark_brown</item>
        <item name="colorSecondaryVariant">@color/orange_dark</item>
        <item name="colorOnSecondary">@color/green</item>
        <item name="android:statusBarColor" tools:targetApi="l">@color/light_gray</item>
        <item name="android:navigationBarColor" tools:targetApi="l">@color/light_gray</item>
        <item name="textInputStyle">@style/Widget.App.TextInputLayout</item>
        <item name="alertDialogTheme">@style/AlertDialog.Light</item>
    </style>
    <!-- Play Dialog Black Style -->
    <style name="PlayDialog.Black" parent="PlayDialog.Dark">
        <item name="android:windowBackground">@drawable/rc_background_black</item>
        <item name="colorPrimary">@color/green</item>
        <item name="colorSecondary">@color/green</item>
        <item name="alertDialogTheme">@style/AlertDialog.Black</item>
    </style>
    <!-- Play Dialog DayNight Style -->
    <style name="PlayDialog.DayNight" parent="PlayDialog.Dark" />
    <!-- Head Preference Category -->
    <style name="HeadPreferenceCategory" parent="@style/Preference.Category.Material">
        <item name="android:layout">@layout/head_preference_category</item>
    </style>
    <!-- Head Preference Category Text -->
    <style name="HeadPreferenceCategoryText" parent="TextAppearance.MaterialComponents.Subtitle1">
        <item name="android:textColor">?attr/colorPrimary</item>
        <item name="android:textAllCaps">true</item>
        <item name="android:textSize">16sp</item>
        <item name="android:paddingTop">32.0dip</item>
        <item name="android:paddingLeft">16.0dip</item>
        <item name="android:paddingBottom">16.0dip</item>
    </style>
    <!-- Main Menu -->
    <style name="MainMenuTextAppearance" parent="TextAppearance.MaterialComponents.Subtitle1">
        <item name="android:textAllCaps">true</item>
        <item name="android:textSize">16sp</item>
        <item name="android:textColor">?attr/colorPrimary</item>
    </style>
    <!-- Checkboxes Text -->
    <style name="Widget.App.CheckBox" parent="Widget.MaterialComponents.CompoundButton.CheckBox">
        <item name="android:textColor">@color/text_color</item>
        <item name="android:singleLine">true</item>
        <item name="android:ellipsize">end</item>
    </style>
    <!-- RadioButton -->
    <style name="Widget.App.RadioButton" parent="Widget.MaterialComponents.CompoundButton.RadioButton">
        <item name="android:textColor">@color/text_color</item>
    </style>
    <!-- Switch -->
    <style name="Widget.App.Switch" parent="Widget.MaterialComponents.CompoundButton.Switch">
        <item name="android:textColor">@color/text_color</item>
        <item name="android:textSize">16sp</item>
        <item name="thumbTint">@color/thumb_color</item>
    </style>
    <!-- TextInputLayout -->
    <style name="Widget.App.TextInputLayout" parent="Widget.MaterialComponents.TextInputLayout.OutlinedBox.Dense">
        <item name="hintTextColor">?attr/colorBright</item><!-- TODO: colorStateList -->
    </style>
    <!-- Dialog Dark Style -->
    <style name="AlertDialog" parent="@style/ThemeOverlay.MaterialComponents.MaterialAlertDialog">
        <item name="android:windowNoTitle">true</item>
        <item name="android:windowBackground">@drawable/rc_background_dark</item>
        <!-- Used for the title -->
        <item name="materialAlertDialogTitleTextStyle">@style/AlertTitleTextStyle</item>
        <!-- Used for the text -->
<!--        <item name="android:textColor">@color/text_color</item>-->
        <item name="android:textColorPrimary">@color/text_color</item>
        <!-- Set min width -->
        <item name="windowMinWidthMajor">50%</item><!-- landscape -->
        <item name="windowMinWidthMinor">70%</item><!-- portrait -->
        <!-- Used for the buttons -->
        <item name="colorPrimary">@color/orange</item>
        <item name="colorAccent">@color/orange</item>
        <!-- Dialog Buttons -->
        <item name="buttonBarPositiveButtonStyle">@style/AlertButtonStyle</item>
        <item name="buttonBarNegativeButtonStyle">@style/AlertButtonStyle</item>
        <item name="buttonBarNeutralButtonStyle">@style/AlertButtonStyle</item>
    </style>
    <!-- Dialog Light Style -->
    <style name="AlertDialog.Light" parent="AlertDialog">
        <item name="android:windowBackground">@drawable/rc_background_light</item>
        <item name="colorPrimary">@color/dark_brown</item>
        <item name="colorAccent">@color/dark_brown</item>
    </style>
    <!-- Dialog Black Style -->
    <style name="AlertDialog.Black" parent="AlertDialog">
        <item name="android:windowBackground">@drawable/rc_background_black</item>
        <item name="colorPrimary">@color/green</item>
        <item name="colorAccent">@color/green</item>
    </style>
    <!-- Dialog Title -->
    <style name="AlertTitleTextStyle" parent="@style/MaterialAlertDialog.MaterialComponents.Title.Text">
        <item name="android:textColor">?attr/colorPrimary</item>
        <item name="android:textAppearance">@style/TextAppearance.MaterialComponents.Headline6</item>
        <item name="android:layout_marginBottom">6dp</item>
    </style>
    <!-- Dialog Buttons -->
    <style name="AlertButtonStyle" parent="@style/Widget.MaterialComponents.Button.OutlinedButton">
        <item name="android:layout_marginLeft">6dp</item>
        <item name="android:layout_marginRight">6dp</item>
        <item name="android:layout_marginTop">6dp</item>
        <item name="android:layout_marginBottom">0dp</item>
    </style>
    <!-- Snackbar https://stackoverflow.com/questions/32425191/style-snackbar-in-theme-app -->
    <style name="MaterialSnackbarTheme" parent="@style/Widget.MaterialComponents.Snackbar">
        <item name="animationMode">slide</item>
        <item name="actionTextColorAlpha">1.0</item>
    </style>
    <!-- Snackbar Buttons -->
    <style name="MaterialSnackbarButtonTheme" parent="@style/Widget.MaterialComponents.Button.OutlinedButton">
        <item name="android:layout_marginRight">12dp</item>
        <item name="materialThemeOverlay">@style/WhiteButtonThemeOverlay</item>
        <item name="strokeColor">@color/tv_white</item>
        <item name="strokeWidth">1dp</item>
    </style>
    <!-- Snackbar Buttons Theme -->
    <style name="WhiteButtonThemeOverlay">
        <!--item name="backgroundTint">@color/tv_white</item-->
        <!-- For filled buttons, your theme's colorPrimary provides the default background color of the component -->
        <item name="android:textColor">@color/tv_white</item>
        <item name="colorPrimary">@color/tv_white</item>
    </style>
</resources>
```

## ./app/src/main/res/values/strings.xml
```xml
<resources>
    <string name="app_name" translatable="false">TorrServe MatriX</string>

    <string name="add">Add</string>
    <string name="rutor" translatable="false">RuTor</string>
    <string name="delete">Delete</string>
    <string name="remove_all">Delete All</string>
    <string name="playlist">Playlist</string>
    <string name="donate">Donate</string>
    <string name="update">Update</string>
    <string name="settings">Settings</string>
    <string name="exit">Exit</string>

    <string name="exit_title">Are You want to Exit?</string>
    <string name="exit_text">Local TorrServer will be stopped on Exit, if Accessibility Service is not enabled.</string>

    <string name="remove_all_warn">Do you want to delete all torrents?</string>
    <string name="share">Share</string>

    <string name="open_torrserve">Open TorrServe</string>
    <string name="open_with">Open With</string>
    <string name="show_menu">Show Main Menu</string>
    <string name="torrents">Torrents</string>

    <string name="apply">Apply</string>
    <string name="skip">Skip</string>
    <string name="yes">Yes</string>
    <string name="cancel">Cancel</string>

    <string name="default_sets">Default Settings</string>
    <string name="default_sets_applied">Default Settings Applied</string>

    <string name="cache_size">Cache Size (Megabytes)</string>
    <string name="preload_before_start">Preload Cache Before Start</string>
    <string name="preload_before_start_desc">If disabled, 32 MB buffer will be used for preload</string>
    <string name="torrent_preload" formatted="false">Readahead Cache (5‚Äì100%, rec. 95%)</string>
    <string name="torrent_preload_cache" formatted="false">Preload Cache Before Play (0‚Äì100%)</string>
    <string name="torrent_disconnect_timeout">Torrent Disconnect Timeout (seconds)</string>
    <string name="save_content_path">Path to Cache Store</string>
    <string name="save_on_disk">Use Cache on Disk</string>
    <string name="save_on_disk_desc">Better use RAM or external media on flash-based devices</string>
    <string name="remove_cache_on_drop">Remove Cache on Torrent Drop</string>
    <string name="remove_cache_on_drop_desc">If disabled, cache removed on torrent delete from DB</string>
    <string name="force_encrypt">Force Encrypt Headers</string>
    <string name="force_encrypt_desc">Can help with torrent blocking providers</string>
    <string name="enable_ipv6">IPv6</string>
    <string name="enable_ipv6_desc">Enable only if supported by ISP</string>
    <string name="enable_debug">Debug TorrServer Logging</string>
    <string name="enable_responsive_mode">Enable responsive reader mode</string>
    <string name="enable_dlna">DLNA Media Server</string>
    <string name="dlna_friendly_name">DLNA Server Name</string>
    <string name="dlna_name_hint">Leave blank to use default</string>
    <string name="disable_tcp">TCP - Transmission Control Protocol</string>
    <string name="disable_tcp_desc">Don\'t disable without ŒºTP enabled</string>
    <string name="disable_utp">ŒºTP - Micro Transport Protocol</string>
    <string name="disable_utp_desc">Not recommended to enable on weak devices</string>
    <string name="disable_upnp">UPnP - Universal Plug and Play</string>
    <string name="disable_upnp_desc">Auto-open port on router</string>
    <string name="enable_rutor_search">Enable Rutor Torrents Search</string>
    <string name="enable_rutor_search_desc">NOTE: torrents database will occupy about 500 MB in RAM</string>
    <string name="disable_dht">DHT - Distributed Hash Table</string>
    <string name="disable_dht_desc">Disable if there is no network after starting the server</string>
    <string name="disable_pex">PEX - Peer Exchange</string>
    <string name="disable_pex_desc">Better leave enabled</string>
    <string name="disable_upload">Upload</string>
    <string name="disable_upload_desc">Not recommended to disable</string>
    <string name="connections_limit">Torrent Connections (20‚Äì25 recommended)</string>
    <string name="connections_dht_limit">Limit of DHT Connections (0 - unlimited)</string>
    <string name="download_rate_limit">Download Speed Limit (Kilobytes, 0 - unlimited)</string>
    <string name="upload_rate_limit">Upload Speed Limit (Kilobytes, 0 - unlimited)</string>
    <string name="retrackers">Retrackers</string>
    <string name="peers_listen_port">Peers Listen Port (0 - default)</string>
    <string-array name="retracker_mode">
        <item>Default</item>
        <item>Add retrackers</item>
        <item>Remove retrackers</item>
        <item>Replace retrackers</item>
    </string-array>

    <string name="select_player">Select Player</string>
    <string name="use_as_default">Save as Default</string>
    <string name="default_player">OS Default Player</string>
    <string name="choose_player">Always Ask</string>
    <string name="player_pref_key" translatable="false">player</string>

    <string name="app_theme_title">App Theme</string>
    <string-array name="app_theme_entries">
        <item>Auto</item>
        <item>Light</item>
        <item>Dark</item>
        <item>AMOLED</item>
    </string-array>
    <string-array name="app_theme_entries_values" translatable="false">
        <item>auto</item>
        <item>light</item>
        <item>dark</item>
        <item>black</item>
    </string-array>

    <string name="add_play">Add &amp; Play</string>
    <string name="play">Play</string>
    <string name="play_from_start">Play from beginning</string>

    <string name="make_as_def">Make as default</string>
    <string name="reset_def">Defaults cleared</string>

    <string name="playlist_all">Play All</string>
    <string name="playlist_continue">Continue</string>

    <string name="torrent_link">Torrent URL</string>
    <string name="torrent_link_help">Enter Torrent URL / Magnet / Hash</string>
    <string name="title">Title</string>
    <string name="poster">Poster</string>
    <string name="poster_link">Poster URL</string>
    <string name="poster_link_help">Enter Poster URL (optional)</string>
    <string name="torrent_category">Category</string>
    <string name="torrent_category_help">Set Category for Torrent (optional)</string>

    <string name="local_ip">Local IP</string>
    <string name="connected_host">Connected</string>
    <string name="find_hosts">Find hosts</string>
    <string name="local_server">Local server</string>
    <string name="saved_server">Saved server</string>
    <string name="new_server">New server</string>
    <string name="online">Online</string>

    <string name="buffer">Buffer</string>
    <string name="peers">Peers</string>
    <string name="seeds">Seeds</string>
    <string name="size">Size</string>
    <string name="download_speed">Download speed</string>
    <string name="bit_rate">Bitrate</string>

    <string name="found_new_app_update">App update found</string>
    <string name="not_found_new_app_update">App update not found</string>
    <string name="current_version">Current version</string>
    <string name="new_version">New version</string>

    <string name="server_update">TorrServer update</string>
    <string name="install_server">Install TorrServer</string>
    <string name="install_server_latest">Install / Update server</string>
    <string name="install_server_local">Install server from the Download folder</string>
    <string name="delete_local_server">Delete local server</string>
    <string name="install_ffprobe">Install FFProbe</string>
    <string name="delete_ffprobe">Delete FFProbe</string>
    <string name="ffprobe_summary">Download FFProbe to obtain additional video data, such as the duration, bitrate, etc.</string>
    <string name="arch">Arch</string>
    <string name="update_server">Update version</string>
    <string name="warn_error_check_ver">Version check error</string>
    <string name="warn_error_download_server">Server download error</string>
    <string name="warn_no_local_updates">No local updates found</string>
    <string name="need_install_server">Server needs to be installed</string>
    <string name="need_update_server">Server needs to be updated</string>
    <string name="not_support_old_server">Server version 1.1.x is not supported. Update server or use client 1.1.x for it.</string>
    <string name="not_support_local_ip">Don\'t set local device IP as torrserver URL! Use localhost | 127.0.0.1 instead.</string>
    <string name="not_loaded_exit_hint">The local TorrServer is not running. Try clicking \"Exit\" in the Main Menu and launch the application again, or restart your device. If nothing changes after this, update TorrServer in the \"Update\" section.</string>
    <string name="not_loaded_select_hint">Select an available TorrServer from the list, or specify the address of a new one.</string>
    <string name="copy_to_clipboard">Copied to clipboard</string>
    <string name="stat_running">TorrServer is running</string>
    <string name="server_not_responding">TorrServer is not responding</string>
    <string name="done_sending_settings">Settings saved</string>

    <string name="loading_torrent">Retrieve torrent info‚Ä¶</string>

    <string name="error_add_torrent">Error adding torrent</string>
    <string name="error_app_not_found">No suitable applications found</string>
    <string name="error_download_ffprobe">FFProbe download error</string>
    <string name="error_empty_link">Torrent link is empty</string>
    <string name="error_intent_null">Intent is null</string>
    <string name="error_process_intent">Error opening player. Check settings.</string>
    <string name="error_retrieve_data">Error retrieve data</string>
    <string name="error_retrieve_torrent_file">No playable files found</string>
    <string name="error_retrieve_torrent_info">Error retrieve torrent info</string>
    <string name="error_retrieving_settings">Error getting settings</string>
    <string name="error_sending_settings">Error when send settings</string>
    <string name="error_user_cancel">User stop</string>
    <string name="error_unknown_command">Unknown command</string>

    <string name="permission_storage_msg">Access to memory is required to write settings to a file</string>
    <string name="permission_btn">GRANT</string>
    <string name="permission_deny">Permission Denied</string>

    <string name="link">Link</string>
    <string name="donate_message">TorrServe is free. Please consider donating to support the future development of TorrServe.</string>
    <string name="boosty_msg">Boosty site</string>
    <string name="yandex_money_card" translatable="false">5599 0050 6424 4747</string>
    <string name="tbank" translatable="false">TBank</string>
    <string name="telegram_msg">Telegram Channel</string>

    <!--    Settings    -->
    <string name="app_settings">App Settings</string>
    <string name="app_version">App Version</string>

    <string name="host_title">Set TorrServer URL</string>
    <string name="host_title_hint">http://localhost:8090 - for server on device</string>

    <string name="speedtest_title">TorrServer Speed Test</string>
    <string name="speedtest_title_desc">Test speed to TorrServer</string>

    <string name="host_authorization">Server Authorization</string>
    <string name="host_authorization_desc">Enter username and password separated by a colon (user:password), leave blank for no auth.</string>
    <string name="local_auth_title">Local TorrServer with Authorization</string>
    <string name="local_auth_sum_on">Use authorization on local server</string>
    <string name="local_auth_sum_off">Don\'t use authorization on local server</string>

    <string name="torserver_title">TorrServer Settings</string>
    <string name="torserver_summary">Configure TorrServer settings</string>

    <string name="remove_action_title">Clear Actions Defaults</string>
    <string name="remove_action_summary">Reset default OS application for torrent</string>

    <string name="boot_start_title">Start Server on Boot</string>
    <string name="boot_start_sum_on">Start server on boot enabled</string>
    <string name="boot_start_sum_off">Start server on boot disabled</string>

    <string name="root_start_title">Start Server by root</string>
    <string name="root_start_sum_on">Start server by root enabled</string>
    <string name="root_start_sum_off">Start server by root disabled</string>

    <string name="choose_player_title">Choose Player</string>

    <string name="show_banner_title">Show Banner</string>
    <string name="show_banner_sum_on">Show banner on load torrent</string>
    <string name="show_banner_sum_off">Don\'t show banner on load torrent</string>

    <string name="show_cover_title">Show Poster</string>
    <string name="show_cover_sum_on">Show torrent poster</string>
    <string name="show_cover_sum_off">Don\'t show torrent poster</string>

    <string name="sort_torrents_list_title">Sort Torrents List Alphabetically</string>
    <string name="sort_torrents_list_sum_on">Sort torrents alphabetically</string>
    <string name="sort_torrents_list_sum_off">Sort torrents by time added</string>

    <string name="show_battery_save_tv">Disable Battery Save in Apps / Special App Access / Energy optimization</string>
    <string name="show_battery_save_title">Show battery save settings</string>
    <string name="show_battery_save_summary">Open settings with battery save configs</string>

    <string name="show_fab_title">Floating menu button in portrait</string>
    <string name="show_fab_sum_on">Show floating action button</string>
    <string name="show_fab_sum_off">Don\'t show floating action button</string>

    <string name="show_sort_fab_title">Floating sort button in portrait</string>
    <string name="show_sort_fab_sum_on">Show floating sort button</string>
    <string name="show_sort_fab_sum_off">Don\'t show floating sort button</string>

    <string name="show_cat_fab_title">Floating categories button in portrait</string>
    <string name="show_cat_fab_sum_on">Show floating categories button</string>
    <string name="show_cat_fab_sum_off">Don\'t show floating categories button</string>

    <string name="accessibility_manual_on">Enable service %1$s in Device Preferences / Accessibility section</string>
    <string name="accessibility_manual_off">Disable service %1$s in Device Preferences / Accessibility section</string>
    <string name="accessibility_service_description">Enabling this service can prevent local TorrServer shutdown by OS</string>
    <string name="switch_accessibility_title">Accessibility Service</string>
    <string name="switch_accessibility_summary_on">Press to disable TorrServe service</string>

    <string name="stat_string_added">Torrent added</string>
    <string name="stat_string_info">Getting torrent info</string>
    <string name="stat_string_preload">Preload torrent</string>
    <string name="stat_string_working">Torrent working</string>
    <string name="stat_string_closed">Torrent closed</string>
    <string name="stat_string_in_db">Torrent in DB</string>

    <string name="fmt_h">h.</string>
    <string name="fmt_m">m.</string>
    <string name="fmt_s">s.</string>
    <string name="fmt_p">KMGTPE</string>
    <string name="fmt_b">B</string>
    <string name="fmt_bps">bps</string>
    <string name="runtime">Runtime</string>
    <string name="avg">average</string>
    <string name="max">max.</string>

    <string name="sort_by_name">Sort list by Title</string>
    <string name="sort_by_size">Sort list by Size</string>
    <string name="sort_by_seed">Sort list by Seeders</string>
    <string name="sort_by_date">Sort list by Date</string>

    <string name="no_data">No data</string>
    <string name="no_torrents">No Torrents</string>
    <string name="no_updates">No updates found</string>
    <string name="not_used">Not Used</string>
    <string name="not_installed">Not Installed</string>

    <string name="cat_movie">Movies</string>
    <string name="cat_tv">Series</string>
    <string name="cat_music">Music</string>
    <string name="cat_other">Other</string>
    <string name="cat_none">All torrents</string>

    <string name="accessibility_note">Disable Accessibility service to stop TorrServer</string>
    <string name="torrserver_log">TorrServer journal</string>
    <string name="torrserver_log_summary">View local TorrServer journal</string>
    <string name="torrserver_log_cleared">TorrServer journal cleared</string>
    <string name="torrserver_log_trimmed">Log content trimmed (showing last %s)</string>

</resources>
```

## ./app/src/main/res/xml/net_security.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <base-config cleartextTrafficPermitted="true">
        <trust-anchors>
            <certificates src="system" />
        </trust-anchors>
    </base-config>
</network-security-config>

```

## ./app/src/main/res/xml/global_torrserve_service.xml
```xml
<?xml version="1.0" encoding="utf-8"?>

<accessibility-service xmlns:android="http://schemas.android.com/apk/res/android"
    android:accessibilityFeedbackType="feedbackAudible"
    android:accessibilityFlags="flagReportViewIds"
    android:description="@string/accessibility_service_description"
    android:packageNames="ru.yourok.torrserve"
    android:settingsActivity="ru.yourok.torrserve.ui.activities.main.SettingsActivity" />
```

## ./app/src/main/res/xml/provider_paths.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<paths>
    <external-path
        name="external_files"
        path="." />
</paths>
```

## ./app/src/main/res/xml/preferences.xml
```xml
<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:key="prefs">

    <PreferenceCategory
        style="@style/HeadPreferenceCategory"
        android:key="data"
        android:title="@string/app_settings" />

    <Preference
        app:key="host"
        app:summary="@string/host_title"
        app:title="@string/host_title" />

    <Preference
        app:key="speedtest"
        app:summary="@string/speedtest_title_desc"
        app:title="@string/speedtest_title" />

    <Preference
        app:key="server_settings"
        app:summary="@string/torserver_summary"
        app:title="@string/torserver_title" />

    <Preference
        app:key="showlog"
        app:summary="@string/torrserver_log_summary"
        app:title="@string/torrserver_log" />

    <EditTextPreference
        app:key="server_auth"
        app:summary="@string/host_authorization_desc"
        app:title="@string/host_authorization" />

    <SwitchPreferenceCompat
        android:defaultValue="false"
        android:summaryOff="@string/local_auth_sum_off"
        android:summaryOn="@string/local_auth_sum_on"
        app:key="local_auth"
        app:title="@string/local_auth_title" />


    <SwitchPreferenceCompat
        android:defaultValue="false"
        android:dependency="switch_accessibility"
        android:summaryOff="@string/boot_start_sum_off"
        android:summaryOn="@string/boot_start_sum_on"
        app:key="boot_start"
        app:title="@string/boot_start_title" />

    <SwitchPreferenceCompat
        android:defaultValue="false"
        android:summaryOff="@string/root_start_sum_off"
        android:summaryOn="@string/root_start_sum_on"
        app:key="root_start"
        app:title="@string/root_start_title" />

    <ListPreference
        app:key="@string/player_pref_key"
        app:title="@string/choose_player_title" />

    <Preference
        app:key="remove_action"
        app:summary="@string/remove_action_summary"
        app:title="@string/remove_action_title" />

    <SwitchPreferenceCompat
        android:defaultValue="true"
        android:summaryOff="@string/show_banner_sum_off"
        android:summaryOn="@string/show_banner_sum_on"
        app:key="show_banner"
        app:title="@string/show_banner_title" />

    <SwitchPreferenceCompat
        android:defaultValue="true"
        android:summaryOff="@string/show_cover_sum_off"
        android:summaryOn="@string/show_cover_sum_on"
        app:key="show_cover"
        app:title="@string/show_cover_title" />

    <SwitchPreferenceCompat
        android:defaultValue="false"
        android:summaryOff="@string/sort_torrents_list_sum_off"
        android:summaryOn="@string/sort_torrents_list_sum_on"
        app:key="sort_torrents"
        app:title="@string/sort_torrents_list_title" />

    <SwitchPreferenceCompat
        android:defaultValue="true"
        android:summaryOff="@string/show_fab_sum_off"
        android:summaryOn="@string/show_fab_sum_on"
        app:key="show_fab"
        app:title="@string/show_fab_title" />

    <SwitchPreferenceCompat
        android:defaultValue="false"
        android:summaryOff="@string/show_sort_fab_sum_off"
        android:summaryOn="@string/show_sort_fab_sum_on"
        app:key="show_sort_fab"
        app:title="@string/show_sort_fab_title" />

    <SwitchPreferenceCompat
        android:defaultValue="false"
        android:summaryOff="@string/show_cat_fab_sum_off"
        android:summaryOn="@string/show_cat_fab_sum_on"
        app:key="show_cat_fab"
        app:title="@string/show_cat_fab_title" />

    <ListPreference
        android:defaultValue="auto"
        app:entries="@array/app_theme_entries"
        app:entryValues="@array/app_theme_entries_values"
        app:key="app_theme"
        app:summary="%s"
        app:title="@string/app_theme_title" />

    <SwitchPreferenceCompat
        android:defaultValue="false"
        android:disableDependentsState="true"
        android:summaryOff="@string/accessibility_service_description"
        android:summaryOn="@string/switch_accessibility_summary_on"
        app:key="switch_accessibility"
        app:title="@string/switch_accessibility_title" />

    <Preference
        app:key="show_battery_save"
        app:summary="@string/show_battery_save_summary"
        app:title="@string/show_battery_save_title" />

    <Preference
        app:key="version"
        app:title="@string/app_version" />

</PreferenceScreen>
```

## ./app/src/main/res/values-sw360dp/values-preference.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
    <bool name="config_materialPreferenceIconSpaceReserved" tools:ignore="MissingDefaultResource,PrivateResource">false</bool>
</resources>
```

## ./app/src/main/res/menu/torrents_action_menu.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/itemShowInfo"
        android:icon="@drawable/outline_info_24"
        android:title="@string/stat_string_info"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/itemRemoveViewed"
        android:icon="@drawable/ic_outline_visibility_off"
        android:title="@string/delete"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/itemRemoveTorrent"
        android:icon="@drawable/ic_outline_remove"
        android:title="@string/delete"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/itemShareMagnet"
        android:icon="@drawable/ic_outline_share"
        android:title="@string/share"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/itemCopyMagnet"
        android:icon="@drawable/ic_outline_content_copy"
        android:title="@string/copy"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/itemOpenWith"
        android:icon="@drawable/ic_outline_exit_to_app"
        android:title="@string/open_with"
        app:showAsAction="ifRoom" />

</menu>
```

## ./app/src/main/res/values-bg/strings.xml
```xml
<resources>
    <string name="add">–î–æ–±–∞–≤–∏</string>
    <string name="delete">–ò–∑—Ç—Ä–∏–π</string>
    <string name="remove_all">–ò–∑—Ç—Ä–∏–π –≤—Å–∏—á–∫–∏</string>
    <string name="playlist">–ü–ª–µ–π–ª–∏—Å—Ç</string>
    <string name="donate">–î–∞—Ä–µ—Ç–µ</string>
    <string name="update">–ê–∫—Ç—É–∞–ª–∏–∑–∞—Ü–∏—è</string>
    <string name="settings">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</string>
    <string name="exit">–ò–∑—Ö–æ–¥</string>
    <string name="exit_title">–ù–∞–∏—Å—Ç–∏–Ω–∞ –ª–∏ –∏—Å–∫–∞—Ç–µ –¥–∞ –∏–∑–ª–µ–∑–µ—Ç–µ?</string>
    <string name="exit_text">–õ–æ–∫–∞–ª–Ω–∏—è—Ç TorrServer —â–µ –±—ä–¥–µ —Å–ø—Ä—è–Ω –ø—Ä–∏ –ò–∑—Ö–æ–¥, –∞–∫–æ –£—Å–ª—É–≥–∞ –∑–∞ –¥–æ—Å—Ç—ä–ø–Ω–æ—Å—Ç –Ω–µ –µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∞.</string>
    <string name="remove_all_warn">–ò—Å–∫–∞—Ç–µ –ª–∏ –¥–∞ –∏–∑—Ç—Ä–∏–µ—Ç–µ –≤—Å–∏—á–∫–∏ —Ç–æ—Ä–µ–Ω—Ç–∏?</string>
    <string name="share">–°–ø–æ–¥–µ–ª–∏</string>
    <string name="open_torrserve">–û—Ç–≤–æ—Ä–∏ TorrServe</string>
    <string name="open_with">–û—Ç–≤–∞—Ä—è–Ω–µ —Å</string>
    <string name="show_menu">–ü–æ–∫–∞–∂–∏ –ì–ª–∞–≤–Ω–æ –º–µ–Ω—é</string>
    <string name="torrents">–¢–æ—Ä–µ–Ω—Ç–∏</string>
    <string name="apply">–ü—Ä–∏–ª–æ–∂–∏</string>
    <string name="skip">–ü—Ä–æ–ø—É—Å–Ω–∏</string>
    <string name="yes">–î–∞</string>
    <string name="cancel">–û—Ç–∫–∞–∑</string>
    <string name="default_sets">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ</string>
    <string name="default_sets_applied">–ù–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏</string>
    <string name="cache_size">–ö–µ—à —Ä–∞–∑–º–µ—Ä (–ú–µ–≥–∞–±–∞–π—Ç–∏)</string>
    <string name="preload_before_start">–ü–æ–¥–≥–æ—Ç–≤–∏—Ç–µ–ª–µ–Ω –±—É—Ñ–µ—Ä –ø—Ä–µ–¥–∏ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ</string>
    <string name="preload_before_start_desc">–ê–∫–æ –µ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–∞–Ω–æ, 32 MB –±—É—Ñ–µ—Ä —â–µ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –∑–∞ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª–Ω–æ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ</string>
    <string name="torrent_preload" formatted="false">–ö–µ—à –∑–∞ —á–µ—Ç–µ–Ω–µ –Ω–∞–ø—Ä–µ–¥ (5‚Äì100%, rec. 95%)</string>
    <string name="torrent_preload_cache" formatted="false">–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª–Ω–æ –∫–µ—à –ø—Ä–µ–¥–∏ –ø—Ä–æ—Å–≤–∏—Ä–≤–∞–Ω–µ (0‚Äì100%)</string>
    <string name="torrent_disconnect_timeout">–í—Ä–µ–º–µ –∑–∞ –ø—Ä–µ–∫—ä—Å–≤–∞–Ω–µ –Ω–∞ –≤—Ä—ä–∑–∫–∞—Ç–∞ —Å —Ç–æ—Ä–µ–Ω—Ç (—Å–µ–∫—É–Ω–¥–∏)</string>
    <string name="save_content_path">–ü—ä—Ç –¥–æ –∫–µ—à —Ö—Ä–∞–Ω–∏–ª–∏—â–µ—Ç–æ</string>
    <string name="save_on_disk">–ò–∑–ø–æ–∑–≤–∞–π –∫–µ—à –Ω–∞ –¥–∏—Å–∫–∞</string>
    <string name="save_on_disk_desc">–ü–æ-–¥–æ–±—Ä–µ –∏–∑–ø–æ–ª–∑–∞–≤–π—Ç–µ RAM –∏–ª–∏ –≤—ä–Ω—à–Ω–∞ –º–µ–¥–∏—è –∫–∞—Ç–æ —Ñ–ª–∞—à —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞</string>
    <string name="remove_cache_on_drop">–ü—Ä–µ–º–∞—Ö–≤–∞–Ω–µ –Ω–∞ –∫–µ—à–∞ –ø—Ä–∏ –æ—Ç–∫–∞–∑ –Ω–∞ —Ç–æ—Ä–µ–Ω—Ç–∞</string>
    <string name="remove_cache_on_drop_desc">–ê–∫–æ –µ –∑–∞–±—Ä–∞–±–Ω–µ–Ω, –∫–µ—à–∞ —Å–µ –∏–∑—Ç—Ä–∏–≤–∞, –∫–æ–≥–∞—Ç–æ —Ç–æ—Ä–µ–Ω—Ç–∞ —Å–µ –∏–∑—Ç—Ä–∏–µ –æ—Ç –±–∞–∑–∞—Ç–∞</string>
    <string name="force_encrypt">–ó–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ –∫—Ä–∏–ø—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Ö–µ–¥—ä—Ä–∏—Ç–µ</string>
    <string name="force_encrypt_desc">–ú–æ–∂–µ –¥–∞ –ø–æ–º–æ–≥–Ω–µ –ø—Ä–∏ –¥–æ—Å—Ç–∞–≤—á–∏—Ü–∏, –±–ª–æ–∫–∏—Ä–∞—â–∏ —Ç–æ—Ä–µ–Ω—Ç–∏</string>
    <string name="enable_ipv6">IPv6</string>
    <string name="enable_ipv6_desc">–†–∞–∑—Ä–µ—à–µ—Ç–µ, —Å–∞–º–æ –∞–∫–æ —Å–µ –ø–æ–¥–¥—ä—Ä–∂–∞ –æ—Ç –ò–Ω—Ç–µ—Ä–Ω–µ—Ç –¥–æ—Å—Ç–∞–≤—á–∏–∫–∞</string>
    <string name="enable_debug">–õ–æ–≥ —Ñ–∞–π–ª–æ–≤–µ —Å –¥–µ–±—ä–≥ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ TorrServer</string>
    <string name="enable_responsive_mode">–†–µ–∂–∏–º –Ω–∞ –æ—Ç–∑–∏–≤—á–∏–≤ —á–µ—Ç–µ—Ü</string>
    <string name="enable_dlna">DLNA –ú–µ–¥–∏—è —Å—ä—Ä–≤—ä—Ä</string>
    <string name="dlna_friendly_name">DLNA –ò–º–µ –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞</string>
    <string name="dlna_name_hint">–û—Å—Ç–∞–≤–µ—Ç–µ –ø—Ä–∞–∑–Ω–æ, –∑–∞ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞—Ç–µ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ</string>
    <string name="disable_tcp">TCP - Transmission Control Protocol</string>
    <string name="disable_tcp_desc">–ù–µ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–∞–π—Ç–µ –±–µ–∑ –∞–∫—Ç–∏–≤–∏—Ä–∞–Ω ŒºTP</string>
    <string name="disable_utp">ŒºTP - Micro Transport Protocol</string>
    <string name="disable_utp_desc">–ù–µ —Å–µ –ø—Ä–µ–ø–æ—Ä—ä—á–≤–∞ –¥–∞ —Å–µ –∞–∫—Ç–∏–≤–∏—Ä–∞ –Ω–∞ —Å–ª–∞–±–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞</string>
    <string name="disable_upnp">UPnP - Universal Plug and Play</string>
    <string name="disable_upnp_desc">–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –æ—Ç–≤–∞—Ä—è–Ω–µ –Ω–∞ –ø–æ—Ä—Ç –Ω–∞ —Ä—É—Ç–µ—Ä–∞</string>
    <string name="enable_rutor_search">–ê–∫—Ç–∏–≤–∏—Ä–∞–Ω–µ –Ω–∞ —Ç—ä—Ä—Å–µ–Ω –≤ Rutor</string>
    <string name="enable_rutor_search_desc">–ó–ê–ë–ï–õ–ï–ñ–ö–ê: —Ç–æ—Ä–µ–Ω—Ç –±–∞–∑–∞—Ç–∞ –¥–∞–Ω–Ω–∏ —â–µ –∑–∞–µ–º–∞ –æ–∫–æ–ª–æ 500 MB –≤ RAM</string>
    <string name="disable_dht">DHT - Distributed Hash Table</string>
    <string name="disable_dht_desc">–î–µ–∞–∫—Ç–∏–≤–∏—Ä–∞–π—Ç–µ, –∞–∫–æ –Ω—è–º–∞—Ç–µ –º—Ä–µ–∂–æ–≤–∞ –≤—Ä—ä–∑–∫–∞ —Å–ª–µ–¥ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞</string>
    <string name="disable_pex">PEX - Peer Exchange</string>
    <string name="disable_pex_desc">–ü–æ-–¥–æ–±—Ä–µ –æ—Å—Ç–∞–≤–µ—Ç–µ –≤–∫–ª—é—á–µ–Ω–æ</string>
    <string name="disable_upload">–ö–∞—á–≤–∞–Ω–µ</string>
    <string name="disable_upload_desc">–ù–µ —Å–µ –ø—Ä–µ–ø–æ—Ä—ä—á–≤–∞ –¥–∞ —Å–µ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–∞</string>
    <string name="connections_limit"> –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞ –≤—Ä—ä–∑–∫–∏ (20‚Äì25 –ø—Ä–µ–ø–æ—Ä—ä—á–∏—Ç–µ–ª–Ω–æ)</string>
    <string name="connections_dht_limit">–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∑–∞ DHT –≤—Ä—ä–∑–∫–∏—Ç–µ (0 - –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ)</string>
    <string name="download_rate_limit">–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞ —Å–∫–æ—Ä–æ—Å—Ç—Ç–∞ –Ω–∞ —Å–≤–∞–ª—è–Ω–µ (–∫–∏–ª–æ–±–∞–π—Ç–∏, 0 - –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ)</string>
    <string name="upload_rate_limit">–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞ —Å–∫–æ—Ä–æ—Å—Ç—Ç–∞ –Ω–∞ –∫–∞—á–≤–∞–Ω–µ (–∫–∏–ª–æ–±–∞–π—Ç–∏, 0 - –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ)</string>
    <string name="retrackers">–†–µ—Ç—Ä–∞–∫–µ—Ä–∏</string>
    <string name="peers_listen_port">–ü–æ—Ä—Ç –∑–∞ —Å–ª—É—à–∞–Ω–µ –Ω–∞ –ø–∏—ä—Ä–∏ (0 - –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞—â —Å–µ)</string>
    <string-array name="retracker_mode">
        <item>–ü–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ</item>
        <item>–î–æ–±–∞–≤–∏ —Ä–µ—Ç—Ä–∞–∫–µ—Ä</item>
        <item>–ü—Ä–µ–º–∞—Ö–Ω–∏ —Ä–µ—Ç—Ä–∞–∫–µ—Ä–∏</item>
        <item>–ü–æ–¥–º–µ–Ω–∏ —Ä–µ—Ç—Ä–∞–∫–µ—Ä–∏</item>
    </string-array>
    <string name="select_player">–ò–∑–±–µ—Ä–µ—Ç–µ –ø–ª–µ—ä—Ä</string>
    <string name="use_as_default">–ó–∞–ø–∞–∑–∏ –∫–∞—Ç–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ</string>
    <string name="default_player">–û—Å–Ω–æ–≤–Ω–∏—è—Ç –ø–ª–µ—ä—Ä –≤ OS</string>
    <string name="choose_player">–í–∏–Ω–∞–≥–∏ –ø–∏—Ç–∞–π</string>
    <string name="app_theme_title">–¢–µ–º–∞ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ</string>
    <string-array name="app_theme_entries">
        <item>–ê–≤—Ç–æ</item>
        <item>–°–≤–µ—Ç–ª–∞</item>
        <item>–¢—ä–º–Ω–∞</item>
        <item>AMOLED</item>
    </string-array>
    <string name="add_play">–î–æ–±–∞–≤–∏ &amp; –ü—É—Å–Ω–∏</string>
    <string name="play">–ü—É—Å–Ω–∏</string>
    <string name="play_from_start">–ü—É—Å–Ω–∏ –æ—Ç –Ω–∞—á–∞–ª–æ</string>
    <string name="make_as_def">–ù–∞–ø—Ä–∞–≤–∏ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ</string>
    <string name="reset_def">–ù–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ —Å–∞ –∏–∑—á–∏—Å—Ç–µ–Ω–∏</string>
    <string name="playlist_all">–ü—É—Å–Ω–∏ –≤—Å–∏—á–∫–∏</string>
    <string name="playlist_continue">–ü—Ä–æ–¥—ä–ª–∂–∏</string>
    <string name="torrent_link">–¢–æ—Ä–µ–Ω—Ç URL</string>
    <string name="torrent_link_help">–í—ä–≤–µ–¥–µ—Ç–µ URL –∞–¥—Ä–µ—Å –∫—ä–º –¢–æ—Ä–µ–Ω—Ç / –ú–∞–≥–Ω–µ—Ç / –•–µ—à</string>
    <string name="title">–ó–∞–≥–ª–∞–≤–∏–µ</string>
    <string name="poster">–ü–æ—Å—Ç—Ä–µ—Ä</string>
    <string name="poster_link">–ü–æ—Å—Ç–µ—Ä URL</string>
    <string name="poster_link_help">–í—ä–≤–µ–¥–µ—Ç–µ URL –∞–¥—Ä–µ—Å –∫—ä–º –ø–æ—Å—Ç–µ—Ä (–æ–ø—Ü–∏–æ–Ω–∞–ª–Ω–æ)</string>
    <string name="torrent_category">–ö–∞—Ç–µ–≥–æ—Ä–∏—è</string>
    <string name="torrent_category_help">–ó–∞–¥–∞–≤–∞–Ω–µ –Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—è –∑–∞ —Ç–æ—Ä–µ–Ω—Ç (–ø–æ –∏–∑–±–æ—Ä)</string>
    <string name="local_ip">–õ–æ–∫–∞–ª–Ω–æ IP</string>
    <string name="connected_host">–°–≤—ä—Ä–∑–∞–Ω</string>
    <string name="find_hosts">–û—Ç–∫—Ä–∏–π TorrServ –∞–¥—Ä–µ—Å–∏</string>
    <string name="local_server">–õ–æ–∫–∞–ª–µ–Ω —Å—ä—Ä–≤—ä—Ä</string>
    <string name="saved_server">–ó–∞–ø–∏—Å–∞–Ω —Å—ä—Ä–≤—ä—Ä</string>
    <string name="new_server">–ù–æ–≤ —Å—ä—Ä–≤—ä—Ä</string>
    <string name="online">–ù–∞ –ª–∏–Ω–∏—è</string>
    <string name="buffer">–ë—É—Ñ–µ—Ä</string>
    <string name="peers">–ü–∏—ä—Ä–∏</string>
    <string name="seeds">–°–∏–π–¥—ä—Ä–∏</string>
    <string name="size">–†–∞–∑–º–µ—Ä</string>
    <string name="download_speed">–°–∫–æ—Ä–æ—Å—Ç –Ω–∞ —Å–≤–∞–ª—è–Ω–µ</string>
    <string name="bit_rate">–ë–∏—Ç—Ä–µ–π—Ç</string>
    <string name="found_new_app_update">–û—Ç–∫—Ä–∏—Ç –µ —ä–¥–ø–µ–π—Ç –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ</string>
    <string name="not_found_new_app_update">–ù–µ –µ –æ—Ç–∫—Ä–∏—Ç —ä–ø–¥–µ–π—Ç</string>
    <string name="current_version">–¢–µ–∫—É—â–∞ –≤–µ—Ä—Å–∏—è</string>
    <string name="new_version">–ù–æ–≤–∞ –≤–µ—Ä—Å–∏—è</string>
    <string name="server_update">TorrServer —ä–ø–¥–µ–π—Ç</string>
    <string name="install_server">–ò–Ω—Å—Ç–∞–ª–∏—Ä–∞–Ω–µ –Ω–∞ TorrServer</string>
    <string name="install_server_latest">–ò–Ω—Å—Ç–∞–ª–∏—Ä–∞–Ω–µ/–™–ø–¥–µ–π—Ç –Ω–∞ —Å—ä—Ä–≤—ä—Ä</string>
    <string name="install_server_local">–ò–Ω—Å—Ç–∞–ª–∏—Ä–∞–Ω–µ –Ω–∞ —Å—ä—Ä–≤—ä—Ä –æ—Ç –ø–∞–ø–∫–∞ –°–≤–∞–ª–µ–Ω–∏</string>
    <string name="delete_local_server">–ò–∑—Ç—Ä–∏–π –ª–æ–∫–∞–ª–Ω–∏—è—Ç —Å—ä—Ä–≤—ä—Ä</string>
    <string name="install_ffprobe">–ò–Ω—Å—Ç–∞–ª–∏—Ä–∞–π FFProbe</string>
    <string name="delete_ffprobe">–ò–∑—Ç—Ä–∏–π FFProbe</string>
    <string name="ffprobe_summary">–°–≤–∞–ª–µ—Ç–µ FFProbe, –∑–∞ –¥–∞ –º–æ–∂–µ –¥–∞ —Å–µ –ø–æ–ª—É—á–∞–≤–∞—Ç –¥–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∏ –¥–∞–Ω–Ω–∏ –∑–∞ –≤–∏–¥–µ–æ—Ç–æ, –∫–∞—Ç–æ –ø—Ä–æ–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ—Å—Ç, –±–∏—Ç—Ä–µ–π—Ç –∏ —Ç.–Ω.</string>
    <string name="arch">–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞</string>
    <string name="update_server">–í–µ—Ä—Å–∏—è –Ω–∞ —ä–ø–¥–µ–π—Ç–∞</string>
    <string name="warn_error_check_ver">–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤–µ—Ä—Å–∏—è—Ç–∞</string>
    <string name="warn_error_download_server">–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Å–≤–∞–ª—è–Ω–µ –Ω–∞ —Å—ä—Ä–≤—ä—Ä–∞</string>
    <string name="warn_no_local_updates">–ù–µ —Å–∞ –æ—Ç–∫—Ä–∏—Ç–∏ –ª–æ–∫–∞–ª–Ω–∏ —ä–ø–¥–µ–π—Ç–∏</string>
    <string name="need_install_server">–°—ä—Ä–≤—ä—Ä—ä—Ç —Ç—Ä—è–±–≤–∞ –¥–∞ –±—ä–¥–µ –∏–Ω—Å—Ç–∞–ª–∏—Ä–∞–Ω</string>
    <string name="need_update_server">–°—ä—Ä–≤—ä—Ä—ä—Ç —Ç—Ä—è–±–≤–∞ –¥–∞ –±—ä–¥–µ —ä–ø–¥–µ–π—Ç–Ω–∞—Ç</string>
    <string name="not_support_old_server">–°—ä—Ä–≤—ä—Ä —Å –≤–µ—Ä—Å–∏—è 1.1.x –Ω–µ —Å–µ –ø–æ–¥–¥—ä—Ä–∂–∞. –û–ø—Ä–µ—Å–Ω–µ—Ç–µ —Å—ä—Ä–≤—ä—Ä–∞ –∏–ª–∏ –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ –∫–ª–∏–µ–Ω—Ç —Å –≤–µ—Ä—Å–∏—è 1.1.x –∑–∞ —Ç–∞–∫—ä–≤ —Å—ä—Ä–≤—ä—Ä.</string>
    <string name="not_support_local_ip">–ù–µ —Å–ª–∞–≥–∞–π—Ç–µ IP –∞–¥—Ä–µ—Å –∫–∞—Ç–æ URL –∞–¥—Ä–µ—Å –∫—ä–º —Å—ä—Ä–≤—ä—Ä–∞! –ò–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ localhost | 127.0.0.1 –≤–º–µ—Å—Ç–æ —Ç–æ–≤–∞.</string>
    <string name="not_loaded_exit_hint">–õ–æ–∫–∞–ª–Ω–∏—è—Ç TorrServer –Ω–µ —Ä–∞–±–æ—Ç–∏. –û–ø–∏—Ç–∞–π—Ç–µ –¥–∞ —â—Ä–∞–∫–Ω–µ—Ç–µ –≤—ä—Ä—Ö—É \"–ò–∑—Ö–æ–¥\" –≤ –≥–ª–∞–≤–Ω–æ—Ç–æ –º–µ–Ω—é –∏ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–π—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –æ—Ç–Ω–æ–≤–æ –∏–ª–∏ —Ä–µ—Å—Ç–∞—Ä—Ç–∏—Ä–∞–π—Ç–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ—Ç–æ —Å–∏. –ê–∫–æ –Ω–∏—â–æ –Ω–µ —Å–µ –ø—Ä–æ–º–µ–Ω–∏ —Å–ª–µ–¥ —Ç–æ–≤–∞, –∞–∫—Ç—É–∞–ª–∏–∑–∏—Ä–∞–π—Ç–µ TorrServer –≤ —Å–µ–∫—Ü–∏—è—Ç–∞ \"–ê–∫—Ç—É–∞–ª–∏–∑–∞—Ü–∏—è\".</string>
    <string name="not_loaded_select_hint">–ò–∑–±–µ—Ä–µ—Ç–µ –Ω–∞–ª–∏—á–µ–Ω TorrServer –æ—Ç —Å–ø–∏—Å—ä–∫–∞ –∏–ª–∏ –ø–æ—Å–æ—á–µ—Ç–µ –∞–¥—Ä–µ—Å–∞ –Ω–∞ –Ω–æ–≤.</string>
    <string name="copy_to_clipboard">–ö–æ–ø–∏—Ä–∞–Ω –≤ –∫–ª–∏–ø–±–æ—Ä–¥–∞</string>
    <string name="stat_running">–£—Å–ª—É–≥–∞—Ç–∞ —Ä–∞–±–æ—Ç–∏</string>
    <string name="server_not_responding">TorrServer –Ω–µ –æ—Ç–≥–æ–≤–∞—Ä—è</string>
    <string name="done_sending_settings">–ù–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ —Å–∞ –∑–∞–ø–∏—Å–∞–Ω–∏</string>
    <string name="loading_torrent">–ü–ª—É—á–∞–≤–∞—Ç —Å–µ –¥–∞–Ω–Ω–∏ –∑–∞ —Ç–æ—Ä–µ–Ω—Ç–∞‚Ä¶</string>
    <string name="error_add_torrent">–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤—è–Ω–µ –Ω–∞ —Ç–æ—Ä–µ–Ω—Ç–∞</string>
    <string name="error_app_not_found">–ù–µ —Å–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ –ø–æ–¥—Ö–æ–¥—è—â–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è</string>
    <string name="error_download_ffprobe">FFProbe –≥—Ä–µ—à–∫–∞ –ø—Ä–∏ —Å–≤–∞–ª—è–Ω–µ</string>
    <string name="error_empty_link">–í—Ä—ä–∑–∫–∞—Ç–∞ –∫—ä–º Torrent-–∞ –µ –ø—Ä–∞–∑–Ω–∞</string>
    <string name="error_intent_null">Intent is null</string>
    <string name="error_process_intent">–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –æ—Ç–≤–∞—Ä—è–Ω–µ –Ω–∞ –ø–ª–µ–π—ä—Ä–∞. –ü—Ä–æ–≤–µ—Ä–µ—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ.</string>
    <string name="error_retrieve_data">–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–∞–≤–∞–Ω–µ –Ω–∞ –¥–∞–Ω–Ω–∏—Ç–µ</string>
    <string name="error_retrieve_torrent_file">–ù–µ —Å–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ —Ñ–∞–π–ª–æ–≤–µ –∑–∞ –ø—É—Å–∫–∞–Ω–µ</string>
    <string name="error_retrieve_torrent_info">–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–∞–≤–∞–Ω–µ –Ω–∞ –∏–Ω—Ñ–æ—Ä–∞–º—Ü–∏—è –∑–∞ —Ç–æ—Ä–µ–Ω—Ç–∞</string>
    <string name="error_retrieving_settings">–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —á–µ—Ç–µ–Ω–µ –Ω–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ</string>
    <string name="error_sending_settings">–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ –∏–∑–ø—Ä–∞—â–∞–Ω–µ –Ω–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ</string>
    <string name="error_user_cancel">–ü–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—è —Å–ø—Ä—è</string>
    <string name="error_unknown_command">–ù–µ–ø–æ–∑–Ω–∞—Ç–∞ –∫–æ–º–∞–Ω–¥–∞</string>
    <string name="permission_storage_msg">–ù–µ–æ–±—Ö–æ–¥–∏–º –µ –¥–æ—Å—Ç—ä–ø –¥–æ –ø–∞–º–µ—Ç—Ç–∞, –∑–∞ –¥–∞ –∑–∞–ø–∏—à–µ—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ –≤—ä–≤ —Ñ–∞–π–ª</string>
    <string name="permission_btn">GRANT</string>
    <string name="permission_deny">–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ—Ç–æ –µ –æ—Ç–∫–∞–∑–∞–Ω–æ</string>
    <string name="link">–í—Ä—ä–∑–∫–∞</string>
    <string name="donate_message">TorrServe –µ —Å–≤–æ–±–æ–¥–µ–Ω —Å–æ—Ñ—Ç—É–µ—Ä. –ú–æ–ª—è, –ø–æ–º–∏—Å–ª–µ—Ç–µ –∑–∞ –¥–∞—Ä–µ–Ω–∏–µ –≤ –ø–æ–¥–∫—Ä–µ–ø–∞ –Ω–∞ –±—ä–¥–µ—â–æ—Ç–æ —Ä–∞–∑–≤–∏—Ç–∏–µ –Ω–∞ TorrServe.</string>
    <string name="boosty_msg">Boosty —Å–∞–π—Ç</string>
    <string name="telegram_msg">Telegram –ö–∞–Ω–∞–ª</string>
    <string name="app_settings">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</string>
    <string name="app_version">–í–µ—Ä—Å–∏—è</string>
    <string name="host_title">–ó–∞–¥–∞–π—Ç–µ URL –∞–¥—Ä–µ—Å –Ω–∞ TorrServer</string>
    <string name="host_title_hint">http://localhost:8090 - for server on device</string>
    <string name="speedtest_title">–¢–µ—Å—Ç –Ω–∞ —Å–∫–æ—Ä–æ—Å—Ç—Ç–∞ –∫—ä–º TorrServer</string>
    <string name="speedtest_title_desc">–¢–µ—Å—Ç–≤–∞–π—Ç–µ —Å–∫–æ—Ä–æ—Å—Ç—Ç–∞ –Ω–∞ TorrServer</string>
    <string name="host_authorization">–û—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –∫—ä–º —Å—ä—Ä–≤—ä—Ä–∞</string>
    <string name="host_authorization_desc">–í—ä–≤–µ–¥–µ—Ç–µ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—Å–∫–æ –∏–º–µ –∏ –ø–∞—Ä–æ–ª–∞, —Ä–∞–∑–¥–µ–ª–µ–Ω–∏ —Å –¥–≤–æ–µ—Ç–æ—á–∏–µ (–ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª:–ø–∞—Ä–æ–ª–∞), –æ—Å—Ç–∞–≤–µ—Ç–µ –ø—Ä–∞–∑–Ω–æ –∑–∞ –ª–∏–ø—Å–∞ –Ω–∞ —É–¥–æ—Å—Ç–æ–≤–µ—Ä—è–≤–∞–Ω–µ.</string>
    <string name="local_auth_title">–õ–æ–∫–∞–ª–µ–Ω TorrServer —Å –æ—Ç–æ—Ä–∏–∑–∞—Ü–∏—è</string>
    <string name="local_auth_sum_on">–ò–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ –æ—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –∫—ä–º –ª–æ–∫–∞–ª–µ–Ω —Å—ä—Ä–≤—ä—Ä</string>
    <string name="local_auth_sum_off">–ù–µ –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ –æ—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –∫—ä–º –ª–æ–∫–∞–ª–µ–Ω —Å—ä—Ä–≤—ä—Ä</string>
    <string name="torserver_title">TorrServer –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</string>
    <string name="torserver_summary">–ö–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–∞–Ω–µ –Ω–∞ TorrServer –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ</string>
    <string name="remove_action_title">–ò–∑—á–∏—Å—Ç–≤–∞–Ω–µ –Ω–∞ –¥–µ–π—Å—Ç–≤–∏—è—Ç–∞ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ</string>
    <string name="remove_action_summary">–ù—É–ª–∏—Ä–∞–Ω–µ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ—Ç–æ –≤ –û–° –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ –∑–∞ —Ç–æ—Ä–µ–Ω—Ç–∏</string>
    <string name="boot_start_title">–°—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å—ä—Ä–≤—ä—Ä—ä—Ç –ø—Ä–∏ –°—Ç–∞—Ä—Ç –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ—Ç–æ</string>
    <string name="boot_start_sum_on">–°—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ—Ç–æ –Ω–∞ —Å—ä—Ä–≤—ä—Ä—ä—Ç –µ —Ä–∞–∑—Ä–µ—à–µ–Ω–æ</string>
    <string name="boot_start_sum_off">–°—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ—Ç–æ –Ω–∞ —Å—ä—Ä–≤—ä—Ä—ä—Ç –µ –∑–∞–±—Ä–∞–Ω–µ–Ω–æ</string>
    <string name="root_start_title">–°—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å—ä—Ä–≤—ä—Ä—ä—Ç –∫–∞—Ç–æ root</string>
    <string name="root_start_sum_on">–†–∞–∑—Ä–µ—à–µ–Ω–æ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å—ä—Ä–≤—ä—Ä—ä—Ç –∫–∞—Ç–æ root</string>
    <string name="root_start_sum_off">–ó–∞–±—Ä–∞–Ω–µ–Ω–æ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å—ä—Ä–≤—ä—Ä—ä—Ç –∫–∞—Ç–æ root</string>
    <string name="choose_player_title">–ò–∑–±–æ—Ä –Ω–∞ –ü–ª–µ—ä—Ä</string>
    <string name="show_banner_title">–ü–æ–∫–∞–∂–∏ –±–∞–Ω–µ—Ä</string>
    <string name="show_banner_sum_on">–ü–æ–∫–∞–∂–∏ –±–∞–Ω–µ—Ä –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Ç–æ—Ä–µ–Ω—Ç</string>
    <string name="show_banner_sum_off">–ù–µ –ø–æ–∫–∞–∑–≤–∞–π –±–∞–Ω–µ—Ä –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Ç–æ—Ä–µ–Ω—Ç</string>
    <string name="show_cover_title">–ü–æ–∫–∞–∂–∏ –ø–æ—Å—Ç–µ—Ä</string>
    <string name="show_cover_sum_on">–ü–æ–∫–∞–∂–∏ –ø–æ—Å—Ç–µ—Ä–∞ –Ω–∞ —Ç–æ—Ä–µ–Ω—Ç–∞</string>
    <string name="show_cover_sum_off">–ù–µ –ø–æ–∫–∞–∑–≤–∞–π –ø–æ—Å—Ç–µ—Ä–∞ –Ω–∞ —Ç–æ—Ä–µ–Ω—Ç–∞</string>
    <string name="sort_torrents_list_title">–°–æ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å–ø–∏—Å—ä–∫–∞ —Å —Ç–æ—Ä–µ–Ω—Ç–∏ –ø–æ –∞–∑–±—É—á–µ–Ω —Ä–µ–¥</string>
    <string name="sort_torrents_list_sum_on">–°–æ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Ç–æ—Ä–µ–Ω—Ç–∏ –ø–æ –∞–∑–±—É—á–µ–Ω —Ä–µ–¥</string>
    <string name="sort_torrents_list_sum_off">–°–æ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Ç–æ—Ä–µ–Ω—Ç–∏ –ø–æ –≤—Ä–µ–º–µ—Ç–æ –Ω–∞ –¥–æ–±–∞–≤—è–Ω–µ</string>
    <string name="show_battery_save_tv">–î–µ–∞–∫—Ç–∏–≤–∏—Ä–∞–π—Ç–µ –ø–µ—Å—Ç–µ–Ω–µ—Ç–æ –Ω–∞ –±–∞—Ç–µ—Ä–∏—è –≤ –ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è / –°–ø–µ—Ü–∏–∞–ª–µ–Ω –¥–æ—Å—Ç—ä–ø –¥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è / –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–∞ –µ–Ω–µ—Ä–≥–∏—è—Ç–∞</string>
    <string name="show_battery_save_title">–ü–æ–∫–∞–∑–≤–∞–Ω–µ –Ω–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ –∑–∞ –ø–µ—Å—Ç–µ–Ω–µ –Ω–∞ –±–∞—Ç–µ—Ä–∏—è—Ç–∞</string>
    <string name="show_battery_save_summary">–û—Ç–≤–æ—Ä–µ—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ —Å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∑–∞ –ø–µ—Å—Ç–µ–Ω–µ –Ω–∞ –±–∞—Ç–µ—Ä–∏—è—Ç–∞</string>
    <string name="show_fab_title">–ü–ª–∞–≤–∞—â –±—É—Ç–æ–Ω –Ω–∞ –º–µ–Ω—é—Ç–æ –≤ –ø–æ—Ä—Ç—Ä–µ—Ç</string>
    <string name="show_fab_sum_on">–ü–æ–∫–∞–∑–≤–∞–Ω–µ –Ω–∞ –ø–ª–∞–≤–∞—â –±—É—Ç–æ–Ω –∑–∞ –¥–µ–π—Å—Ç–≤–∏–µ</string>
    <string name="show_fab_sum_off">–ù–µ –ø–æ–∫–∞–∑–≤–∞–π –ø–ª–∞–≤–∞—â –±—É—Ç–æ–Ω –∑–∞ –¥–µ–π—Å—Ç–≤–∏–µ</string>
    <string name="show_sort_fab_title">–ë—É—Ç–æ–Ω –∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ –≤—ä–≤ –≤–µ—Ä—Ç–∏–∫–∞–ª–Ω–∞ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è</string>
    <string name="show_sort_fab_sum_on">–ü–æ–∫–∞–∑–≤–∞–Ω–µ –Ω–∞ –ø–ª–∞–≤–∞—â –±—É—Ç–æ–Ω –∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ</string>
    <string name="show_sort_fab_sum_off">–ù–µ –ø–æ–∫–∞–∑–≤–∞–π –ø–ª–∞–≤–∞—â –±—É—Ç–æ–Ω –∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ</string>
    <string name="show_cat_fab_title">–ë—É—Ç–æ–Ω –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤—ä–≤ –≤–µ—Ä—Ç–∏–∫–∞–ª–Ω–∞ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è</string>
    <string name="show_cat_fab_sum_on">–ü–æ–∫–∞–∑–≤–∞–Ω–µ –Ω–∞ –±—É—Ç–æ–Ω–∞ –∑–∞ –ø–ª–∞–≤–∞—â–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏</string>
    <string name="show_cat_fab_sum_off">–ù–µ –ø–æ–∫–∞–∑–≤–∞–π –±—É—Ç–æ–Ω–∞ –∑–∞ –ø–ª–∞–≤–∞—â–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏</string>
    <string name="accessibility_manual_on">–ê–∫—Ç–∏–≤–∏—Ä–∞–π—Ç–µ —É—Å–ª—É–≥–∞—Ç–∞ %1$s –≤ —Å–µ–∫—Ü–∏—è—Ç–∞ –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–Ω–∏—è –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ—Ç–æ / –î–æ—Å—Ç—ä–ø–Ω–æ—Å—Ç</string>
    <string name="accessibility_manual_off">–î–µ–∞–∫—Ç–∏–≤–∏—Ä–∞–π—Ç–µ —É—Å–ª—É–≥–∞—Ç–∞ %1$s –≤ —Å–µ–∫—Ü–∏—è—Ç–∞ –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–Ω–∏—è –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ—Ç–æ / –î–æ—Å—Ç—ä–ø–Ω–æ—Å—Ç</string>
    <string name="accessibility_service_description">–ê–∫—Ç–∏–≤–∏—Ä–∞–Ω–µ—Ç–æ –Ω–∞ —Ç–∞–∑–∏ —É—Å–ª—É–≥–∞ –º–æ–∂–µ –¥–∞ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏ –∏–∑–∫–ª—é—á–≤–∞–Ω–µ –Ω–∞ –ª–æ–∫–∞–ª–Ω–∏—è—Ç TorrServer –æ—Ç –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–∞—Ç–∞ —Å–∏—Å—Ç–µ–º–∞</string>
    <string name="switch_accessibility_title">–£—Å–ª—É–≥–∞ –∑–∞ –¥–æ—Å—Ç—ä–ø–Ω–æ—Å—Ç</string>
    <string name="switch_accessibility_summary_on">–ù–∞—Ç–∏—Å–Ω–µ—Ç–µ, –∑–∞ –¥–∞ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–∞—Ç–µ —É—Å–ª—É–≥–∞—Ç–∞ TorrServe</string>
    <string name="stat_string_added">–î–æ–±–∞–≤–µ–Ω —Ç–æ—Ä–µ–Ω—Ç</string>
    <string name="stat_string_info">–ü–æ–ª—É—á–∞–≤–∞–Ω–µ –Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ —Ç–æ—Ä–µ–Ω—Ç</string>
    <string name="stat_string_preload">–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª–Ω–æ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Ç–æ—Ä–µ–Ω—Ç</string>
    <string name="stat_string_working">–¢–æ—Ä–µ–Ω—Ç —Ä–∞–±–æ—Ç–µ—â</string>
    <string name="stat_string_closed">–¢–æ—Ä–µ–Ω—Ç –∑–∞—Ç–≤–æ—Ä–µ–Ω</string>
    <string name="stat_string_in_db">–¢–æ—Ä–µ–Ω—Ç –≤ –±–∞–∑–∞—Ç–∞ –¥–∞–Ω–Ω–∏</string>
    <string name="fmt_h">h.</string>
    <string name="fmt_m">m.</string>
    <string name="fmt_s">s.</string>
    <string name="fmt_p">KMGTPE</string>
    <string name="fmt_b">B</string>
    <string name="fmt_bps">bps</string>
    <string name="runtime">–í—Ä–µ–º–µ—Ç—Ä–∞–µ–Ω–µ</string>
    <string name="avg">—Å—Ä–µ–¥–Ω.</string>
    <string name="max">–º–∞–∫—Å.</string>
    <string name="sort_by_name">–°–æ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å–ø–∏—Å—ä–∫–∞ –ø–æ –∑–∞–≥–ª–∞–≤–∏–µ</string>
    <string name="sort_by_size">–°–æ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å–ø–∏—Å—ä–∫–∞ –ø–æ —Ä–∞–∑–º–µ—Ä</string>
    <string name="sort_by_seed">–°–æ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å–ø–∏—Å—ä–∫–∞ –ø–æ —Å–∏–π–¥—ä—Ä–∏</string>
    <string name="sort_by_date">–°–æ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å–ø–∏—Å—ä–∫–∞ –ø–æ –¥–∞—Ç–∞</string>
    <string name="no_data">–ù—è–º–∞ –¥–∞–Ω–Ω–∏</string>
    <string name="no_torrents">–ù—è–º–∞ —Ç–æ—Ä–µ–Ω—Ç–∏</string>
    <string name="no_updates">–ù–µ —Å–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ —ä–ø–¥–µ–π—Ç–∏</string>
    <string name="not_used">–ù–µ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞</string>
    <string name="not_installed">–ù–µ –µ –∏–Ω—Å—Ç–∞–ª–∏—Ä–∞–Ω–æ</string>
    <string name="cat_movie">–§–∏–ª–º–∏</string>
    <string name="cat_tv">–°–µ—Ä–∏–∞–ª</string>
    <string name="cat_music">–ú—É–∑–∏–∫–∞</string>
    <string name="cat_other">–î—Ä—É–≥–æ</string>
    <string name="cat_none">–í—Å–∏—á–∫–∏ —Ç–æ—Ä–µ–Ω—Ç–∏</string>
    <string name="accessibility_note">–î–µ–∞–∫—Ç–∏–≤–∏—Ä–∞–π—Ç–µ —É—Å–ª—É–≥–∞—Ç–∞ –∑–∞ –¥–æ—Å—Ç—ä–ø–Ω–æ—Å—Ç, –∑–∞ –¥–∞ —Å–ø—Ä–µ—Ç–µ TorrServer</string>
    <string name="torrserver_log">–î–Ω–µ–≤–Ω–∏–∫ –Ω–∞ TorrServer</string>
    <string name="torrserver_log_summary">–ü—Ä–µ–≥–ª–µ–¥ –Ω–∞ –¥–Ω–µ–≤–Ω–∏–∫ –Ω–∞ –ª–æ–∫–∞–ª–Ω–∏—è TorrServer</string>
    <string name="torrserver_log_cleared">–î–Ω–µ–≤–Ω–∏–∫—ä—Ç –Ω–∞ TorrServer –µ –∏–∑—á–∏—Å—Ç–µ–Ω</string>
    <string name="torrserver_log_trimmed">–õ–æ–≥–∞ –µ —Å—ä–∫—Ä–∞—Ç–µ–Ω (–ø–æ–∫–∞–∑–≤–∞ —Å–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ç–µ %s)</string>
</resources>

```

## ./app/src/main/res/values-uk/strings.xml
```xml
<resources>
    <string name="add">–î–æ–¥–∞—Ç–∏</string>
    <string name="delete">–í–∏–¥–∞–ª–∏—Ç–∏</string>
    <string name="remove_all">–í–∏–¥–∞–ª–∏—Ç–µ –≤—Å–µ</string>
    <string name="playlist">–ü–ª–µ–π–ª—ñ—Å—Ç</string>
    <string name="donate">–ü–æ–∂–µ—Ä—Ç–≤–∞</string>
    <string name="update">–û–Ω–æ–≤–ª–µ–Ω–Ω—è</string>
    <string name="settings">–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</string>
    <string name="exit">–í–∏—Ö—ñ–¥</string>
    <string name="exit_title">–í–∏ —Ö–æ—á–µ—Ç–µ –≤–∏–π—Ç–∏?</string>
    <string name="exit_text">–õ–æ–∫–∞–ª—å–Ω–∏–π TorrServer –±—É–¥–µ –∑—É–ø–∏–Ω–µ–Ω–æ –ø—ñ–¥ —á–∞—Å –≤–∏—Ö–æ–¥—É, —è–∫—â–æ —Å–ª—É–∂–±—É –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—ñ –Ω–µ –≤–≤—ñ–º–∫–Ω–µ–Ω–æ.</string>
    <string name="remove_all_warn">–í–∏ —Ö–æ—á–µ—Ç–µ –≤–∏–¥–∞–ª–∏—Ç–∏ –≤—Å—ñ —Ç–æ—Ä—Ä–µ–Ω—Ç–∏?</string>
    <string name="share">–ü–æ–¥—ñ–ª–∏—Ç–∏—Å—å</string>
    <string name="open_torrserve">–í—ñ–¥–∫—Ä–∏—Ç–∏ TorrServe</string>
    <string name="open_with">–í—ñ–¥–∫—Ä–∏—Ç–∏ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é</string>
    <string name="show_menu">–ü–æ–∫–∞–∑–∞—Ç–∏ –≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é</string>
    <string name="torrents">–¢–æ—Ä—Ä–µ–Ω—Ç–∏</string>
    <string name="apply">–ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏</string>
    <string name="skip">–ü—Ä–æ–ø—É—Å—Ç–∏—Ç–∏</string>
    <string name="yes">–¢–∞–∫</string>
    <string name="cancel">–°–∫–∞—Å—É–≤–∞—Ç–∏</string>
    <string name="default_sets">–ó–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º</string>
    <string name="cache_size">–†–æ–∑–º—ñ—Ä –∫–µ—à—É (–ú–µ–≥–∞–±–∞–π—Ç–∏)</string>
    <string name="preload_before_start">–ó–∞–ø–æ–≤–Ω—é–≤–∞—Ç–∏ –∫–µ—à –ø–µ—Ä–µ–¥ —Å—Ç–∞—Ä—Ç–æ–º</string>
    <string name="preload_before_start_desc">–Ø–∫—â–æ –≤—ñ–¥–∫–ª—é—á–µ–Ω–æ, –±—É–¥–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏—Å—è 32 –ú–ë –±—É—Ñ–µ—Ä –≤ –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫—ñ</string>
    <string name="torrent_preload" formatted="false">–í–∏–ø–µ—Ä–µ–¥–∂–∞—é—á–µ –∫–µ—à (5‚Äì100%, —Ä–µ–∫. 95%) </string>
    <string name="torrent_preload_cache" formatted="false">–ë—É—Ñ–µ—Ä –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫—ñ (0‚Äì100%)</string>
    <string name="torrent_disconnect_timeout">–¢–∞–π–º–∞—É—Ç –≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è —Ç–æ—Ä—Ä–µ–Ω—Ç–∞ (—Å–µ–∫—É–Ω–¥)</string>
    <string name="save_content_path">–®–ª—è—Ö –¥–æ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –∫–µ—à—É</string>
    <string name="save_on_disk">–ó–±–µ—Ä—ñ–≥–∞—Ç–∏ –∫–µ—à –Ω–∞ –¥–∏—Å–∫</string>
    <string name="save_on_disk_desc">–ö—Ä–∞—â–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –∑–æ–≤–Ω—ñ—à–Ω—ñ –Ω–æ—Å—ñ—ó –Ω–∞ –ø—Ä–∏—Å—Ç—Ä–æ—è—Ö –∑ flash-–ø–∞–º`—è—Ç—Ç—é</string>
    <string name="remove_cache_on_drop">–û—á–∏—â–∞—Ç–∏ –∫–µ—à –ø—Ä–∏ –≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—ñ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞</string>
    <string name="remove_cache_on_drop_desc">–Ø–∫—â–æ –≤—ñ–¥–∫–ª—é—á–µ–Ω–æ, —Ñ–∞–π–ª–∏ –∫–µ—à–∞ –æ—á–∏—â–∞—é—Ç—å—Å—è –ø—Ä–∏ –≤–∏–¥–∞–ª–µ–Ω–Ω—ñ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞</string>
    <string name="force_encrypt">–ü—Ä–∏–º—É—Å–æ–≤–µ —à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è –∑–∞–≥–æ–ª–æ–≤–∫—ñ–≤</string>
    <string name="force_encrypt_desc">–ú–æ–∂–µ –¥–æ–ø–æ–º–æ–≥—Ç–∏ –∑ –±–ª–æ–∫—É—é—á–∏–º–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞–º–∏</string>
    <string name="enable_ipv6">IPv6</string>
    <string name="enable_ipv6_desc">–í–∫–ª—é—á–∏—Ç–µ —è–∫—â–æ –ø—ñ–¥—Ç—Ä–∏–º—É—î—Ç—å—Å—è</string>
    <string name="enable_debug">–î–æ–∫–ª–∞–¥–Ω–∏–π –ª–æ–≥ —Å–µ—Ä–≤–µ—Ä–∞</string>
    <string name="enable_responsive_mode">–£–≤—ñ–º–∫–Ω—É—Ç–∏ –∞–¥–∞–ø—Ç–∏–≤–Ω–∏–π —Ä–µ–∂–∏–º —á–∏—Ç–∞–Ω–Ω—è</string>
    <string name="enable_dlna">DLNA-–º–µ–¥–∏–∞—Å–µ—Ä–≤–µ—Ä</string>
    <string name="dlna_friendly_name">–Ü–º\'—è —Å–µ—Ä–≤–µ—Ä–∞ DLNA</string>
    <string name="dlna_name_hint">–ó–∞–ª–∏—à—Ç–µ –ø–æ—Ä–æ–∂–Ω—ñ–º, —â–æ–± –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –∑–Ω–∞—á–µ–Ω–Ω—è –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º.</string>
    <string name="disable_tcp">TCP - Transmission Control Protocol</string>
    <string name="disable_tcp_desc">–ù–µ –≤–∏–º–∏–∫–∞–π—Ç–µ –±–µ–∑ –≤–∫–ª—é—á–µ–Ω–æ–≥–æ ŒºTP</string>
    <string name="disable_utp">ŒºTP - Micro Transport Protocol</string>
    <string name="disable_utp_desc">–ù–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É—î—Ç—å—Å—è –Ω–∞ —Å–ª–∞–±–∫–∏—Ö –ø—Ä–∏—Å—Ç—Ä–æ—è—Ö</string>
    <string name="disable_upnp">UPnP - Universal Plug and Play</string>
    <string name="disable_upnp_desc">–ê–≤—Ç–æ–≤—ñ–¥–∫—Ä–∏—Ç—Ç—è –ø–æ—Ä—Ç—É –Ω–∞ —Ä–æ—É—Ç–µ—Ä—ñ</string>
    <string name="disable_dht">DHT - Distributed Hash Table</string>
    <string name="disable_dht_desc">–í—ñ–¥–∫–ª—é—á—ñ—Ç—å –ø—Ä–∏ –≤—ñ–¥—Å—É—Ç–Ω–æ—Å—Ç—ñ –º–µ—Ä–µ–∂—ñ –ø—ñ—Å–ª—è –∑–∞–ø—É—Å–∫—É —Å–µ—Ä–≤–µ—Ä–∞</string>
    <string name="disable_pex">PEX - Peer Exchange</string>
    <string name="disable_pex_desc">–ù–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É—î—Ç—å—Å—è –≤—ñ–¥–∫–ª—é—á–∞—Ç–∏</string>
    <string name="disable_upload">–í—ñ–¥–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è</string>
    <string name="disable_upload_desc">–ù–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É—î—Ç—å—Å—è –≤—ñ–¥–∫–ª—é—á–∞—Ç–∏</string>
    <string name="connections_limit">–¢–æ—Ä—Ä–µ–Ω—Ç‚Äì–∑\'—î–¥–Ω–∞–Ω–Ω—è (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ 20‚Äì25)</string>
    <string name="connections_dht_limit">–õ—ñ–º—ñ—Ç DHT –∑\'—î–¥–Ω–∞–Ω–Ω—å (0-–±–µ–∑ –æ–±–º–µ–∂–µ–Ω—å)</string>
    <string name="download_rate_limit">–û–±–º–µ–∂–µ–Ω–Ω—è —à–≤–∏–¥–∫–æ—Å—Ç—ñ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è (–ö—ñ–ª–æ–±–∞–π—Ç–∏, 0-–±–µ–∑ –æ–±–º–µ–∂–µ–Ω—å)</string>
    <string name="upload_rate_limit">–û–±–º–µ–∂–µ–Ω–Ω—è —à–≤–∏–¥–∫–æ—Å—Ç—ñ –≤—ñ–¥–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è (–ö—ñ–ª–æ–±–∞–π—Ç–∏, 0-–±–µ–∑ –æ–±–º–µ–∂–µ–Ω—å)</string>
    <string name="retrackers">–†–µ—Ç—Ä–µ–∫–µ—Ä–∏</string>
    <string name="peers_listen_port">–ü–æ—Ä—Ç –¥–ª—è –≤—Ö—ñ–¥–Ω–∏—Ö –ø—ñ–¥–∫–ª—é—á–µ–Ω—å (0-–∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º)</string>
    <string-array name="retracker_mode">
        <item>–ü–æ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—é</item>
        <item>–î–æ–¥–∞–≤–∞—Ç–∏</item>
        <item>–í–∏–¥–∞–ª—è—Ç–∏</item>
        <item>–ó–∞–º—ñ–Ω—è—Ç–∏</item>
    </string-array>
    <string name="select_player">–í–∏–±—ñ—Ä –ø–ª–µ—î—Ä–∞</string>
    <string name="use_as_default">–ó–∞–ø–∞–º\'—è—Ç–∞—Ç–∏ –≤–∏–±—ñ—Ä</string>
    <string name="default_player">–ü–ª–µ—î—Ä –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º</string>
    <string name="choose_player">–ó–∞–≤–∂–¥–∏ –∑–∞–ø–∏—Ç—É–≤–∞—Ç–∏</string>
    <string name="app_theme_title">–¢–µ–º–∞</string>
    <string-array name="app_theme_entries">
        <item>–ê–≤—Ç–æ</item>
        <item>–°–≤—ñ—Ç–ª–∞</item>
        <item>–¢–µ–º–Ω–∞</item>
        <item>AMOLED</item>
    </string-array>
    <string name="add_play">–î–æ–¥–∞—Ç–∏ —ñ –ø—Ä–æ–≥—Ä–∞—Ç–∏</string>
    <string name="play">–ü—Ä–æ–≥—Ä–∞—Ç–∏</string>
    <string name="play_from_start">–ì—Ä–∞—Ç–∏ –∑ –ø–æ—á–∞—Ç–∫—É</string>
    <string name="make_as_def">–ó–∞–ø–∞–º\'—è—Ç–∞—Ç–∏ –¥—ñ—é</string>
    <string name="reset_def">–î—ñ—è —Å–∫–∏–Ω—É—Ç–∞</string>
    <string name="playlist_all">–ü—Ä–æ–≥—Ä–∞—Ç–∏ –≤—Å–µ</string>
    <string name="playlist_continue">–ü—Ä–æ–¥–æ–≤–∂–∏—Ç–∏</string>
    <string name="torrent_link">–¢–æ—Ä—Ä–µ–Ω—Ç</string>
    <string name="torrent_link_help">–í–≤–µ–¥—ñ—Ç—å URL —Ç–æ—Ä—Ä–µ–Ω—Ç–∞ | Magnet-–ø–æ—Å–∏–ª–∞–Ω–Ω—è | –•–µ—à</string>
    <string name="title">–ù–∞–∑–≤–∞</string>
    <string name="poster">–ü–æ—Å—Ç–µ—Ä</string>
    <string name="poster_link">–ü–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ –ø–æ—Å—Ç–µ—Ä</string>
    <string name="poster_link_help">–í–≤–µ–¥—ñ—Ç—å URL-–∞–¥—Ä–µ—Å—É –Ω–∞ –ø–æ—Å—Ç–µ—Ä (–Ω–µ–æ–±–æ–≤‚Äô—è–∑–∫–æ–≤–æ)</string>
    <string name="torrent_category">–ö–∞—Ç–µ–≥–æ—Ä—ñ—è</string>
    <string name="torrent_category_help">–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –¥–ª—è —Ç–æ—Ä—Ä–µ–Ω—Ç–∞ (–Ω–µ–æ–±–æ–≤‚Äô—è–∑–∫–æ–≤–æ)</string>
    <string name="local_ip">–õ–æ–∫–∞–ª—å–Ω–∞ IP</string>
    <string name="connected_host">–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è</string>
    <string name="find_hosts">–ü–æ—à—É–∫ —Å–µ—Ä–≤–µ—Ä—ñ–≤</string>
    <string name="local_server">–õ–æ–∫–∞–ª—å–Ω–∏–π —Å–µ—Ä–≤–µ—Ä</string>
    <string name="saved_server">–ó–±–µ—Ä–µ–∂–µ–Ω–∏–π —Å–µ—Ä–≤–µ—Ä</string>
    <string name="new_server">–ù–æ–≤–∏–π —Å–µ—Ä–≤–µ—Ä</string>
    <string name="online">–û–Ω–ª–∞–π–Ω</string>
    <string name="buffer">–ë—É—Ñ–µ—Ä</string>
    <string name="peers">–ü—ñ—Ä–∏</string>
    <string name="seeds">–°—ñ–¥–∏</string>
    <string name="size">–†–æ–∑–º—ñ—Ä</string>
    <string name="download_speed">–®–≤–∏–¥–∫—ñ—Å—Ç—å –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è</string>
    <string name="found_new_app_update">–ó–Ω–∞–π–¥–µ–Ω–æ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–æ–¥–∞—Ç–∫—É</string>
    <string name="not_found_new_app_update">–û–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–æ–¥–∞—Ç–∫—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ</string>
    <string name="current_version">–ü–æ—Ç–æ—á–Ω–∞ –≤–µ—Ä—Å—ñ—è</string>
    <string name="new_version">–ù–æ–≤–∞ –≤–µ—Ä—Å—ñ—è</string>
    <string name="server_update">–û–Ω–æ–≤–ª–µ–Ω–Ω—è —Å–µ—Ä–≤–µ—Ä–∞</string>
    <string name="install_server">–í—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ TorrServer</string>
    <string name="install_server_latest">–í—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ / –æ–Ω–æ–≤–∏—Ç–∏ —Å–µ—Ä–≤–µ—Ä</string>
    <string name="install_server_local">–í—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ —Å–µ—Ä–≤–µ—Ä –∑ –ø–∞–ø–∫–∏ Download</string>
    <string name="delete_local_server">–í–∏–¥–∞–ª–∏—Ç–∏ –ª–æ–∫–∞–ª—å–Ω–∏–π —Å–µ—Ä–≤–µ—Ä</string>
    <string name="arch">–ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ –û–°</string>
    <string name="update_server">–û–Ω–æ–≤–ª–µ–Ω–Ω—è —Å–µ—Ä–≤–µ—Ä–∞</string>
    <string name="warn_error_check_ver">–ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –≤–µ—Ä—Å—ñ—ó</string>
    <string name="warn_error_download_server">–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ —Å–µ—Ä–≤–µ—Ä–∞</string>
    <string name="warn_no_local_updates">–ù–µ–º–∞—î –ª–æ–∫–∞–ª—å–Ω–∏—Ö –æ–Ω–æ–≤–ª–µ–Ω—å</string>
    <string name="need_install_server">–ù–µ–æ–±—Ö—ñ–¥–Ω–æ –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ —Å–µ—Ä–≤–µ—Ä</string>
    <string name="need_update_server">–ü–æ—Ç—Ä—ñ–±–Ω–æ –æ–Ω–æ–≤–∏—Ç–∏ —Å–µ—Ä–≤–µ—Ä</string>
    <string name="not_support_old_server">–°–µ—Ä–≤–µ—Ä –≤–µ—Ä—Å—ñ—ó 1.1.x –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î—Ç—å—Å—è. –û–Ω–æ–≤—ñ—Ç—å —Å–µ—Ä–≤–µ—Ä –∞–±–æ –∫–æ—Ä–∏—Å—Ç—É—î—Ç—å—Å—è –∫–ª—ñ—î–Ω—Ç–æ–º –≤–µ—Ä—Å—ñ—ó 1.1.x.</string>
    <string name="not_support_local_ip">–ù–µ –≤—Å—Ç–∞–Ω–æ–≤–ª—é–π—Ç–µ –ª–æ–∫–∞–ª—å–Ω—É IP —è–∫ URL TorrServer! –ù–∞—Ç–æ–º—ñ—Å—Ç—å –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ localhost | 127.0.0.1.</string>
    <string name="not_loaded_exit_hint">–õ–æ–∫–∞–ª—å–Ω–∏–π TorrServer –Ω–µ –∑–∞–ø—É—â–µ–Ω–æ. –°–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—Ç–∏—Å–Ω—É—Ç–∏ ¬´–í–∏—Ö—ñ–¥¬ª –≤ –≥–æ–ª–æ–≤–Ω–æ–º—É –º–µ–Ω—é —Ç–∞ –∑–Ω–æ–≤—É –∑–∞–ø—É—Å—Ç–∏—Ç–∏ –ø—Ä–æ–≥—Ä–∞–º—É –∞–±–æ –ø–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ –ø—Ä–∏—Å—Ç—Ä—ñ–π. –Ø–∫—â–æ –ø—ñ—Å–ª—è —Ü—å–æ–≥–æ –Ω—ñ—á–æ–≥–æ –Ω–µ –∑–º—ñ–Ω–∏—Ç—å—Å—è, –æ–Ω–æ–≤—ñ—Ç—å TorrServer —É —Ä–æ–∑–¥—ñ–ª—ñ ¬´–û–Ω–æ–≤–ª–µ–Ω–Ω—è¬ª.</string>
    <string name="not_loaded_select_hint">–í–∏–±–µ—Ä—ñ—Ç—å –¥–æ—Å—Ç—É–ø–Ω–∏–π TorrServer –∑—ñ —Å–ø–∏—Å–∫—É –∞–±–æ –≤–∫–∞–∂—ñ—Ç—å –∞–¥—Ä–µ—Å—É –Ω–æ–≤–æ–≥–æ.</string>
    <string name="copy_to_clipboard">–°–∫–æ–ø—ñ–π–æ–≤–∞–Ω–æ –¥–æ –±—É—Ñ–µ—Ä—É –æ–±–º—ñ–Ω—É</string>
    <string name="stat_running">–°–ª—É–∂–±—É –∑–∞–ø—É—â–µ–Ω–æ</string>
    <string name="server_not_responding">TorrServer –Ω–µ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î</string>
    <string name="done_sending_settings">–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∑–±–µ—Ä–µ–∂–µ–Ω–æ</string>
    <string name="loading_torrent">–û—Ç—Ä–∏–º–∞–Ω–Ω—è —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó —Ç–æ—Ä—Ä–µ–Ω—Ç—É‚Ä¶</string>
    <string name="error_add_torrent">–ù–µ–º–æ–∂–ª–∏–≤–æ –¥–æ–¥–∞—Ç–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç</string>
    <string name="error_app_not_found">–í—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏—Ö –¥–æ–¥–∞—Ç–∫—ñ–≤ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ</string>
    <string name="error_download_ffprobe">–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è FFProbe</string>
    <string name="error_empty_link">–ü–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ —Ç–æ—Ä—Ä–µ–Ω—Ç –ø–æ—Ä–æ–∂–Ω—î</string>
    <string name="error_intent_null">–ü–æ—Ä–æ–∂–Ω—ñ–π —ñ–Ω—Ç–µ–Ω—Ç</string>
    <string name="error_process_intent">–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è –ø–ª–µ—î—Ä–∞. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è.</string>
    <string name="error_retrieve_data">–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–Ω–∏—Ö</string>
    <string name="error_retrieve_torrent_file">–£ —Ç–æ—Ä—Ä–µ–Ω—Ç—ñ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ —Ñ–∞–π–ª—ñ–≤ –º—É–ª—å—Ç–∏–º–µ–¥—ñ–∞</string>
    <string name="error_retrieve_torrent_info">–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó —Ç–æ—Ä—Ä–µ–Ω—Ç—É</string>
    <string name="error_retrieving_settings">–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω—å</string>
    <string name="error_sending_settings">–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –≤—ñ–¥–ø—Ä–∞–≤—Ü—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—å</string>
    <string name="error_user_cancel">–°–∫–∞—Å–æ–≤–∞–Ω–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–µ–º</string>
    <string name="error_unknown_command">–ù–µ–≤—ñ–¥–æ–º–∞ –∫–æ–º–∞–Ω–¥–∞</string>
    <string name="permission_storage_msg">–í–∏–º–∞–≥–∞—î—Ç—å—Å—è –¥–æ—Å—Ç—É–ø –¥–æ –≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ—ó –ø–∞–º\'—è—Ç—ñ –¥–ª—è –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ –∑–∞–ø–∏—Å—É —Ñ–∞–π–ª—É –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω—å</string>
    <string name="permission_btn">–î–û–ó–í–û–õ–ò–¢–ò</string>
    <string name="link">–ü–æ—Å–∏–ª–∞–Ω–Ω—è</string>
    <string name="donate_message">TorrServe –±–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∏–π. –ë—É–¥—å –ª–∞—Å–∫–∞, –ø–æ–¥—É–º–∞–π—Ç–µ –ø—Ä–æ –ø–æ–∂–µ—Ä—Ç–≤—É–≤–∞–Ω–Ω—è –¥–ª—è –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ –º–∞–π–±—É—Ç–Ω—å–æ–≥–æ —Ä–æ–∑–≤–∏—Ç–∫—É TorrServe.</string>
    <string name="telegram_msg">–ö–∞–Ω–∞–ª —É Telegram</string>
    <string name="app_settings">–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –¥–æ–¥–∞—Ç–∫—É</string>
    <string name="app_version">–í–µ—Ä—Å—ñ—è –¥–æ–¥–∞—Ç–∫–∞</string>
    <string name="host_title">–í—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ URL-–∞–¥—Ä–µ—Å—É TorrServer</string>
    <string name="host_title_hint">http://localhost:8090 - –¥–ª—è —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ –ø—Ä–∏—Å—Ç—Ä–æ—ó</string>
    <string name="speedtest_title">–¢–µ—Å—Ç —à–≤–∏–¥–∫–æ—Å—Ç—ñ –¥–æ TorrServer</string>
    <string name="speedtest_title_desc">–ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ —à–≤–∏–¥–∫—ñ—Å—Ç—å TorrServer</string>
    <string name="host_authorization">–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä—ñ</string>
    <string name="host_authorization_desc">–í–≤–µ–¥—ñ—Ç—å –ª–æ–≥—ñ–Ω —Ç–∞ –ø–∞—Ä–æ–ª—å —á–µ—Ä–µ–∑ ¬´:¬ª (user:pass)</string>
    <string name="local_auth_title">–õ–æ–∫–∞–ª—å–Ω–∏–π TorrServer –∑ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—î—é</string>
    <string name="local_auth_sum_on">–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—é –Ω–∞ –ª–æ–∫–∞–ª—å–Ω–æ–º—É —Å–µ—Ä–≤–µ—Ä—ñ</string>
    <string name="local_auth_sum_off">–ù–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—é –Ω–∞ –ª–æ–∫–∞–ª—å–Ω–æ–º—É —Å–µ—Ä–≤–µ—Ä—ñ</string>
    <string name="torserver_title">–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è TorrServer</string>
    <string name="torserver_summary">–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ TorrServer</string>
    <string name="remove_action_title">–û—á–∏—Å—Ç–∏—Ç–∏ –¥—ñ—ó –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º</string>
    <string name="remove_action_summary">–°–∫–∏–Ω—É—Ç–∏ –¥—ñ—é –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º –ø—Ä–∏ –≤—ñ–¥–∫—Ä–∏—Ç—Ç—ñ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞</string>
    <string name="boot_start_title">–ó–∞–ø—É—Å–∫–∞—Ç–∏ —Å–µ—Ä–≤–µ—Ä –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ</string>
    <string name="boot_start_sum_on">–í–∫–ª—é—á–∏—Ç–∏ –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –ø—Ä–∏—Å—Ç—Ä–æ—é</string>
    <string name="boot_start_sum_off">–í—ñ–¥–∫–ª—é—á–∏—Ç–∏ –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –ø—Ä–∏—Å—Ç—Ä–æ—é</string>
    <string name="root_start_title">–ó–∞–ø—É—Å–∫–∞—Ç–∏ —Å–µ—Ä–≤–µ—Ä –≤—ñ–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ root</string>
    <string name="root_start_sum_on">–ó–∞–ø—É—Å–∫–∞—Ç–∏ –≤—ñ–¥ —ñ–º–µ–Ω—ñ root –¥–ª—è —É–Ω–∏–∫–Ω–µ–Ω–Ω—è –≤–∏–≥—Ä—É–∑–∫–∏ —Å–∏—Å—Ç–µ–º–æ—é</string>
    <string name="root_start_sum_off">–ù–µ –∑–∞–ø—É—Å–∫–∞—Ç–∏ –≤—ñ–¥ —ñ–º–µ–Ω—ñ root</string>
    <string name="choose_player_title">–í–∏–±—ñ—Ä –ø–ª–µ—î—Ä–∞</string>
    <string name="show_banner_title">–ü–æ–∫–∞–∑—É–≤–∞—Ç–∏ –±–∞–Ω–µ—Ä</string>
    <string name="show_banner_sum_on">–ü–æ–∫–∞–∑—É–≤–∞—Ç–∏ –±–∞–Ω–µ—Ä –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞</string>
    <string name="show_banner_sum_off">–ù–µ –ø–æ–∫–∞–∑—É–≤–∞—Ç–∏ –±–∞–Ω–µ—Ä –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞</string>
    <string name="show_cover_title">–í—ñ–¥–æ–±—Ä–∞–∂–∞—Ç–∏ –ø–æ—Å—Ç–µ—Ä–∏</string>
    <string name="show_cover_sum_on">–í—ñ–¥–æ–±—Ä–∞–∂–∞—Ç–∏ –ø–æ—Å—Ç–µ—Ä–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç—ñ–≤</string>
    <string name="show_cover_sum_off">–ù–µ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—Ç–∏ –ø–æ—Å—Ç–µ—Ä–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç—ñ–≤</string>
    <string name="sort_torrents_list_title">–°–æ—Ä—Ç—É–≤–∞—Ç–∏ —Å–ø–∏—Å–æ–∫ —Ç–æ—Ä—Ä–µ–Ω—Ç—ñ–≤ –∑–∞ –∞–ª—Ñ–∞–≤—ñ—Ç–æ–º</string>
    <string name="sort_torrents_list_sum_on">–°–æ—Ä—Ç—É–≤–∞—Ç–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç–∏ –∑–∞ –∞–ª—Ñ–∞–≤—ñ—Ç–æ–º</string>
    <string name="sort_torrents_list_sum_off">–°–æ—Ä—Ç—É–≤–∞—Ç–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç–∏ –∑–∞ —á–∞—Å–æ–º –¥–æ–¥–∞–≤–∞–Ω–Ω—è</string>
    <string name="show_battery_save_tv">–í–∏–º–∫–Ω—ñ—Ç—å –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—é –≤ ¬´–î–æ–¥–∞—Ç–∫–∏¬ª / ¬´–°–ø–µ—Ü—ñ–∞–ª—å–Ω–∏–π –¥–æ—Å—Ç—É–ø¬ª / ¬´–û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –µ–Ω–µ—Ä–≥–æ—Å–ø–æ–∂–∏–≤–∞–Ω–Ω—è¬ª</string>
    <string name="show_battery_save_title">–ü–æ–∫–∞–∑–∞—Ç–∏ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –µ–Ω–µ—Ä–≥–æ–∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è</string>
    <string name="show_battery_save_summary">–í—ñ–¥–∫—Ä–∏—Ç–∏ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –µ–Ω–µ—Ä–≥–æ–∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è</string>
    <string name="show_fab_title">–ö–Ω–æ–ø–∫–∞ –≤–∏–∫–ª–∏–∫—É –º–µ–Ω—é –Ω–∞ –µ–∫—Ä–∞–Ω—ñ</string>
    <string name="show_fab_sum_on">–í—ñ–¥–æ–±—Ä–∞–∂–∞—Ç–∏ –∫–Ω–æ–ø–∫—É –≤–∏–∫–ª–∏–∫—É –º–µ–Ω—é</string>
    <string name="show_fab_sum_off">–ù–µ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—Ç–∏ –∫–Ω–æ–ø–∫—É –≤–∏–∫–ª–∏–∫—É –º–µ–Ω—é</string>
    <string name="show_sort_fab_title">–ö–Ω–æ–ø–∫–∞ —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è –≤ –ø–æ—Ä—Ç—Ä–µ—Ç–Ω—ñ–π –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—ó</string>
    <string name="show_sort_fab_sum_on">–ü–æ–∫–∞–∑–∞—Ç–∏ –∫–Ω–æ–ø–∫—É —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è</string>
    <string name="show_sort_fab_sum_off">–ù–µ –ø–æ–∫–∞–∑—É–≤–∞—Ç–∏ –∫–Ω–æ–ø–∫—É —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è</string>
    <string name="show_cat_fab_title">–ö–Ω–æ–ø–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ–π –≤ –ø–æ—Ä—Ç—Ä–µ—Ç–Ω—ñ–π –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—ó</string>
    <string name="show_cat_fab_sum_on">–ü–æ–∫–∞–∑–∞—Ç–∏ –∫–Ω–æ–ø–∫—É –∫–∞—Ç–µ–≥–æ—Ä—ñ–π</string>
    <string name="show_cat_fab_sum_off">–ù–µ –ø–æ–∫–∞–∑—É–≤–∞—Ç–∏ –∫–Ω–æ–ø–∫—É –∫–∞—Ç–µ–≥–æ—Ä—ñ–π</string>
    <string name="accessibility_manual_on">–£–≤—ñ–º–∫–Ω—É—Ç–∏ —Å–ª—É–∂–±—É ¬´%1$s¬ª –≤ —Ä–æ–∑–¥—ñ–ª—ñ ¬´–ü–∞—Ä–∞–º–µ—Ç—Ä–∏ –ø—Ä–∏—Å—Ç—Ä–æ—é¬ª / ¬´–°–ø–µ—Ü—ñ–∞–ª—å–Ω—ñ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ¬ª</string>
    <string name="accessibility_manual_off">–í–∏–º–∫–Ω—É—Ç–∏ —Å–ª—É–∂–±—É ¬´%1$s¬ª –≤ —Ä–æ–∑–¥—ñ–ª—ñ ¬´–ü–∞—Ä–∞–º–µ—Ç—Ä–∏ –ø—Ä–∏—Å—Ç—Ä–æ—é¬ª / ¬´–°–ø–µ—Ü—ñ–∞–ª—å–Ω—ñ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ¬ª</string>
    <string name="accessibility_service_description">–í–∫–ª—é—á–µ–Ω–Ω—è —Ü—å–æ–≥–æ —Å–µ—Ä–≤—ñ—Å—É –º–æ–∂–µ –∑–∞–ø–æ–±—ñ–≥—Ç–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ TorrServer —Å–∏—Å—Ç–µ–º–æ—é</string>
    <string name="switch_accessibility_title">–°–µ—Ä–≤—ñ—Å —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–∏—Ö –º–æ–∂–ª–∏–≤–æ—Å—Ç–µ–π</string>
    <string name="switch_accessibility_summary_on">–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –¥–ª—è –≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è —Å–µ—Ä–≤—ñ—Å—É TorrServe</string>
    <string name="stat_string_added">–¢–æ—Ä—Ä–µ–Ω—Ç –¥–æ–¥–∞–Ω–æ</string>
    <string name="stat_string_info">–û—Ç—Ä–∏–º–∞–Ω–Ω—è —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó</string>
    <string name="stat_string_preload">–ü–æ–ø–µ—Ä–µ–¥–Ω—î –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è</string>
    <string name="stat_string_working">–¢–æ—Ä—Ä–µ–Ω—Ç –∞–∫—Ç–∏–≤–Ω–∏–π</string>
    <string name="stat_string_closed">–¢–æ—Ä—Ä–µ–Ω—Ç –∑–∞–∫—Ä–∏—Ç–æ</string>
    <string name="stat_string_in_db">–¢–æ—Ä—Ä–µ–Ω—Ç —É –ë–î</string>
    <string name="fmt_h">–≥–æ–¥.</string>
    <string name="fmt_m">—Ö–≤.</string>
    <string name="fmt_s">—Å.</string>
    <string name="fmt_p">–ö–ú–ì–¢–ü–ï</string>
    <string name="fmt_b">–ë</string>
    <string name="fmt_bps">–±—ñ—Ç/—Å</string>
    <string name="runtime">–¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å</string>
    <string name="avg">—Å–µ—Ä–µ–¥–Ω.</string>
    <string name="max">–º–∞–∫—Å.</string>
    <string name="sort_by_name">–°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è –∑–∞ –Ω–∞–∑–≤–æ—é</string>
    <string name="sort_by_size">–°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è –∑–∞ —Ä–æ–∑–º—ñ—Ä–æ–º</string>
    <string name="sort_by_seed">–°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è –∑–∞ —Ä–æ–∑–¥–∞–≤–∞–ª—å–Ω–∏–º</string>
    <string name="sort_by_date">–°–æ—Ä—Ç—É–≤–∞–Ω–Ω—è –∑–∞ –¥–∞—Ç–æ—é</string>
    <string name="no_data">–ù–µ–º–∞—î –¥–∞–Ω–∏—Ö</string>
    <string name="no_torrents">–ù–µ–º–∞—î —Ç–æ—Ä—Ä–µ–Ω—Ç—ñ–≤</string>
    <string name="no_updates">–ù–µ–º–∞—î –æ–Ω–æ–≤–ª–µ–Ω—å</string>
    <string name="not_used">–ù–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è</string>
    <string name="not_installed">–ù–µ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ</string>
    <string name="default_sets_applied">–í—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º</string>
    <string name="permission_deny">–£ –¥–æ—Å—Ç—É–ø—ñ –≤—ñ–¥–º–æ–≤–ª–µ–Ω–æ</string>
    <string name="boosty_msg">Boosty —Å–∞–π—Ç</string>
    <string name="enable_rutor_search">–£–≤—ñ–º–∫–Ω—É—Ç–∏ –ø–æ—à—É–∫ –ø–æ RuTor</string>
    <string name="enable_rutor_search_desc">–£–í–ê–ì–ê: –±–∞–∑–∞ –¥–∞–Ω–∏—Ö –∑–∞–π–º–µ –≤ –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ—ó –ø–∞–º\'—è—Ç—ñ –±–ª–∏–∑—å–∫–æ 500 –ú–ë</string>
    <string name="bit_rate">–ë—ñ—Ç—Ä–µ–π—Ç</string>
    <string name="install_ffprobe">–í—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ FFProbe</string>
    <string name="delete_ffprobe">–í–∏–¥–∞–ª–∏—Ç–∏ FFProbe</string>
    <string name="ffprobe_summary">–ó–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ FFProbe –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö –ø—Ä–æ –≤—ñ–¥–µ–æ, —Ç–∞–∫–∏—Ö —è–∫ —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å, –±—ñ—Ç—Ä–µ–π—Ç —Ç–æ—â–æ.</string>
    <string name="cat_movie">–§—ñ–ª—å–º–∏</string>
    <string name="cat_tv">–°–µ—Ä—ñ–∞–ª</string>
    <string name="cat_music">–ú—É–∑–∏–∫–∞</string>
    <string name="cat_other">–Ü–Ω—à–µ</string>
    <string name="cat_none">–£—Å—ñ —Ç–æ—Ä—Ä–µ–Ω—Ç–∏</string>
    <string name="accessibility_note">–í–∏–º–∫–Ω—ñ—Ç—å —Å–ª—É–∂–±—É –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—ñ, —â–æ–± –∑—É–ø–∏–Ω–∏—Ç–∏ TorrServer.</string>
    <string name="torrserver_log">–ñ—É—Ä–Ω–∞–ª TorrServer</string>
    <string name="torrserver_log_summary">–ü–µ—Ä–µ–≥–ª—è–¥ –∂—É—Ä–Ω–∞–ª—É –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ TorrServer</string>
    <string name="torrserver_log_cleared">–ñ—É—Ä–Ω–∞–ª TorrServer –æ—á–∏—â–µ–Ω–æ</string>
    <string name="torrserver_log_trimmed">–õ–æ–≥ –æ–±—Ä—ñ–∑–∞–Ω–æ (–ø–æ–∫–∞–∑–∞–Ω–æ –æ—Å—Ç–∞–Ω–Ω—ñ %s)</string>
</resources>

```

## ./app/src/main/AndroidManifest.xml
```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.ACCESS_ALL_DOWNLOADS" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission
        android:name="android.permission.ACCESS_WIFI_STATE"
        tools:ignore="LeanbackUsesWifi" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_SPECIAL_USE" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.QUICKBOOT_POWERON" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    <uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES" />
    <uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission
        android:name="android.permission.WRITE_SECURE_SETTINGS"
        tools:ignore="ProtectedPermissions" />
    <uses-permission
        android:name="android.permission.WRITE_SETTINGS"
        tools:ignore="ProtectedPermissions" />

    <uses-sdk tools:overrideLibrary="androidx.tvprovider" />

    <uses-feature
        android:name="android.software.leanback"
        android:required="false" />
    <uses-feature
        android:name="android.hardware.touchscreen"
        android:required="false" />

    <application
        android:name=".app.App"
        android:allowBackup="true"
        android:banner="@drawable/ic_banner"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:largeHeap="true"
        android:networkSecurityConfig="@xml/net_security"
        android:requestLegacyExternalStorage="true"
        android:roundIcon="@mipmap/ic_launcher"
        android:supportsRtl="true"
        android:theme="@style/Theme.TorrServe.DayNight">
        <activity
            android:name="ru.yourok.torrserve.ui.activities.main.MainActivity"
            android:configChanges="uiMode"
            android:exported="true"
            android:launchMode="singleInstance">
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />

                <category android:name="android.intent.category.BROWSABLE" />
                <category android:name="android.intent.category.DEFAULT" />

                <data
                    android:host="${applicationId}"
                    android:pathPrefix="/open_main_list"
                    android:scheme="torrserve" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LEANBACK_LAUNCHER" />
            </intent-filter>
        </activity>

        <activity
            android:name="ru.yourok.torrserve.ui.activities.play.PlayActivity"
            android:configChanges="uiMode"
            android:excludeFromRecents="true"
            android:exported="true"
            android:theme="@style/PlayDialog.DayNight">
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />

                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />

                <data android:scheme="magnet" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />

                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />

                <data
                    android:host="*"
                    android:mimeType="application/x-bittorrent"
                    android:scheme="http" />
                <data
                    android:host="*"
                    android:mimeType="application/x-bittorrent"
                    android:scheme="https" />
                <data
                    android:host="*"
                    android:mimeType="application/x-bittorrent"
                    android:scheme="content" />
                <data
                    android:host="*"
                    android:mimeType="application/x-bittorrent"
                    android:scheme="file" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />

                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />

                <data
                    android:host="*"
                    android:scheme="http" />
                <data
                    android:host="*"
                    android:scheme="https" />
                <data
                    android:host="*"
                    android:scheme="file" />
                <data
                    android:host="*"
                    android:scheme="content" />
                <data android:pathPattern=".*\.torrent" />
                <data android:pathPattern=".*\.TORRENT" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />

                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />

                <data
                    android:host="*"
                    android:mimeType="*/*"
                    android:scheme="http" />
                <data
                    android:host="*"
                    android:mimeType="*/*"
                    android:scheme="https" />
                <data
                    android:host="*"
                    android:mimeType="*/*"
                    android:scheme="file" />
                <data
                    android:host="*"
                    android:mimeType="*/*"
                    android:scheme="content" />
                <data android:pathPattern=".*\.torrent" />
                <data android:pathPattern=".*\.TORRENT" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />

                <category android:name="android.intent.category.DEFAULT" />

                <data android:scheme="magnet" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.SEND" />

                <category android:name="android.intent.category.DEFAULT" />

                <data android:scheme="magnet" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.SEND" />

                <category android:name="android.intent.category.DEFAULT" />

                <data android:mimeType="*/*" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <action android:name="android.intent.action.SEND" />

                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />

                <data android:scheme="http" />
                <data android:scheme="https" />
                <data android:scheme="file" />
                <data android:scheme="magnet" />
                <data android:host="*" />
                <data android:pathPattern=".*.TORRENT" />
                <data android:pathPattern=".*.torrent" />
                <data android:pathPattern=".*.torrent.*" />
                <data android:pathPattern=".*..*.torrent.*" />
                <data android:pathPattern=".*..*..*.torrent.*" />
                <data android:pathPattern=".*..*..*..*.torrent.*" />
                <data android:pathPattern=".*..*..*..*..*.torrent.*" />
                <data android:pathPattern=".*..*..*..*..*..*.torrent.*" />
                <data android:pathPattern=".*..*..*..*..*..*..*.torrent.*" />
                <data android:pathPattern=".*..*..*..*..*..*..*..*.torrent.*" />
                <data android:pathPattern=".*..*..*..*..*..*..*..*..*.torrent.*" />
                <data android:pathPattern=".*..*..*..*..*..*..*..*..*..*.torrent.*" />
                <data android:pathPattern=".*..*..*..*..*..*..*..*..*..*..*.torrent.*" />
                <data android:pathPattern=".*..*..*..*..*..*..*..*..*..*..*..*.torrent.*" />
                <data android:pathPattern=".*..*..*..*..*..*..*..*..*..*..*..*..*.torrent.*" />
                <data android:pathPattern=".*..*..*..*..*..*..*..*..*..*..*..*..*..*.torrent.*" />
                <data android:pathPattern=".*..*..*..*..*..*..*..*..*..*..*..*..*..*..*.torrent.*" />
            </intent-filter>
        </activity>

        <activity
            android:name="ru.yourok.torrserve.ui.activities.main.SettingsActivity"
            android:configChanges="uiMode"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.PREFERENCE" />
            </intent-filter>
        </activity>

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.provider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/provider_paths" />
        </provider>

        <receiver
            android:name=".server.local.services.BCReceiver"
            android:enabled="true"
            android:exported="false">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
                <action android:name="android.intent.action.QUICKBOOT_POWERON" />
                <action android:name="com.htc.intent.action.QUICKBOOT_POWERON" />

                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </receiver>
        <receiver
            android:name=".server.local.services.HomeWatch"
            android:enabled="true"
            android:exported="true">
            <intent-filter>
                <action android:name="android.media.tv.action.INITIALIZE_PROGRAMS" />
                <action android:name="android.media.tv.action.PREVIEW_PROGRAM_BROWSABLE_DISABLED" />
                <action android:name="android.media.tv.action.WATCH_NEXT_PROGRAM_BROWSABLE_DISABLED" />

                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>

        </receiver>

        <service
            android:name=".server.local.TorrService"
            android:exported="false"
            android:foregroundServiceType="mediaPlayback" />
        <service
            android:name=".server.local.services.NotificationTS"
            android:exported="false"
            android:foregroundServiceType="specialUse">
            <property
                android:name="android.app.PROPERTY_SPECIAL_USE_FGS_SUBTYPE"
                android:value="torrserver" />
        </service>
        <service
            android:name=".server.local.services.GlobalTorrService"
            android:exported="true"
            android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE">
            <intent-filter>
                <action android:name="android.accessibilityservice.AccessibilityService" />
            </intent-filter>
            <meta-data
                android:name="android.accessibilityservice"
                android:resource="@xml/global_torrserve_service" />
        </service>
    </application>

</manifest>
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/speedtest/SpeedTest.kt
```kt
package ru.yourok.torrserve.ui.fragments.speedtest

import android.content.res.Configuration
import android.graphics.Color
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.FrameLayout
import android.widget.TextView
import androidx.lifecycle.lifecycleScope
import com.github.anastr.speedviewlib.PointerSpeedometer
import com.github.anastr.speedviewlib.Speedometer
import com.github.anastr.speedviewlib.components.Section
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.atv.Utils
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.ui.fragments.TSFragment
import ru.yourok.torrserve.utils.Format.margin
import ru.yourok.torrserve.utils.Http
import ru.yourok.torrserve.utils.Net


class SpeedTest : TSFragment() {

    private val mbps = " M" + App.context.getString(R.string.fmt_bps)
    private var lastCheck = System.currentTimeMillis()
    private var lastReaded = 0L
    private var maxSpeed = 0f
    private var averageSpeed = 0f
    private var isStop = false

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val vi = inflater.inflate(R.layout.speedtest_fragment, container, false)

        val title = vi.findViewById<TextView?>(R.id.tvTitle)
        if (activity?.resources?.configuration?.orientation == Configuration.ORIENTATION_PORTRAIT) {
            title.apply {
                text = Settings.getHost().removePrefix("http://")
                visibility = View.VISIBLE
            }
        } else { // landscape
            title.visibility = View.GONE
            if (Utils.isTvBox()) {
                vi.margin(top = 56F)
            } else {
                vi.findViewById<FrameLayout>(R.id.speedometer).margin(top = 10F)
            }
        }

        val speedometer = vi.findViewById<PointerSpeedometer>(R.id.tubeSpeedometer)

        speedometer.unit = mbps
        speedometer.minSpeed = 0f
        speedometer.maxSpeed = 100f
        speedometer.withTremble = false
        speedometer.speedometerMode = Speedometer.Mode.NORMAL // TOP

        vi.findViewById<Button>(R.id.btn100mb)?.setOnClickListener {
            enableButtons(vi, false)
            lifecycleScope.launch(Dispatchers.Main) {
                speedTest(100)
            }
        }

        vi.findViewById<Button>(R.id.btn500mb)?.setOnClickListener {
            enableButtons(vi, false)
            lifecycleScope.launch(Dispatchers.Main) {
                speedTest(500)
            }
        }

        vi.findViewById<Button>(R.id.btn1000mb)?.setOnClickListener {
            enableButtons(vi, false)
            lifecycleScope.launch(Dispatchers.Main) {
                speedTest(1000)
            }
        }

        vi.findViewById<Button>(R.id.btn5000mb)?.setOnClickListener {
            enableButtons(vi, false)
            lifecycleScope.launch(Dispatchers.Main) {
                speedTest(5000)
            }
        }

        vi.findViewById<Button>(R.id.btnStop)?.apply {
            setOnClickListener {
                isStop = true
            }
            visibility = View.INVISIBLE // hide initially
        }
        // set initial focus
        vi.findViewById<Button>(R.id.btn100mb)?.requestFocus()

        return vi
    }

    private fun enableButtons(vi: View?, enabled: Boolean) {
        val btnStop = vi?.findViewById<Button>(R.id.btnStop)
        vi?.findViewById<Button>(R.id.btn100mb)?.isEnabled = enabled
        vi?.findViewById<Button>(R.id.btn500mb)?.isEnabled = enabled
        vi?.findViewById<Button>(R.id.btn1000mb)?.isEnabled = enabled
        vi?.findViewById<Button>(R.id.btn5000mb)?.isEnabled = enabled
        if (enabled) {
            btnStop?.visibility = View.INVISIBLE
            vi?.findViewById<Button>(R.id.btn100mb)?.requestFocus()
        } else
            btnStop?.apply {
                visibility = View.VISIBLE
                requestFocus()
            }
    }

    private suspend fun speedTest(sizeMB: Int) {
        setSpeedometer(sizeMB)
        averageSpeed = 0f
        maxSpeed = 0f
        lastReaded = 0
        lastCheck = System.currentTimeMillis()
        isStop = false

        lifecycleScope.launch(Dispatchers.IO) {
            val link = Net.getHostUrl("/download/$sizeMB")
            val http = Http(Uri.parse(link))
            try {
                http.setAuth(Net.getAuthB64())
                http.connect()
            } catch (e: Exception) {
                setStatus(e.message ?: "Error connect to server")
                withContext(Dispatchers.Main) {
                    enableButtons(view, true)
                }
                return@launch
            }

            val stream = http.getInputStream()
            stream ?: let {
                setStatus("Error connect to server")
                withContext(Dispatchers.Main) {
                    enableButtons(view, true)
                }
                return@launch
            }

            val b = ByteArray(1024 * 1024)
            val allSize = http.getSize()
            var readed = 0L
            try {
                while (readed < allSize) {
                    val sz = http.read(b)
                    readed += sz
                    calcSpeed(readed)
                    if (!this@SpeedTest.isVisible || isStop)
                        break
                }
            } catch (e: Exception) {
                setStatus(e.message ?: "Error read from server")
                withContext(Dispatchers.Main) {
                    enableButtons(view, true)
                }
            }

            withContext(Dispatchers.Main) {
                view?.findViewById<PointerSpeedometer>(R.id.tubeSpeedometer)?.speedTo(0.0f)
                enableButtons(view, true)
            }
        }
    }

    private suspend fun setStatus(st: String) {
        withContext(Dispatchers.Main) {
            val status = view?.findViewById<TextView>(R.id.tvSPStatus) ?: return@withContext
            status.text = st
        }
    }

    private suspend fun calcSpeed(readed: Long) {
        val time = System.currentTimeMillis() - lastCheck
        if (time > 1000) {
            val dReaded = readed - lastReaded

            val speed = dReaded.toFloat() / time.toFloat() * 0.008f // MBit/sec
            setSpeed(speed)

            lastCheck = System.currentTimeMillis()
            lastReaded = readed
        }
    }

    private suspend fun setSpeed(speed: Float) {
        if (speed > maxSpeed)
            maxSpeed = speed

        if (averageSpeed == 0f)
            averageSpeed = speed
        else {
            averageSpeed += speed
            averageSpeed /= 2f
        }
        withContext(Dispatchers.Main) {
            val ms = String.format("%s %.1f$mbps | %s %.1f$mbps", getString(R.string.avg), averageSpeed, getString(R.string.max), maxSpeed)
            view?.findViewById<TextView>(R.id.tvSPStatus)?.text = ms
            view?.findViewById<PointerSpeedometer>(R.id.tubeSpeedometer)?.speedTo(speed)
        }
    }


    private suspend fun setSpeedometer(sizeMB: Int) {
        when (sizeMB) {
            100 -> {
                setSection(100f)
            }

            500 -> {
                setSection(500f)
            }

            1000 -> {
                setSection(1000f)
            }

            5000 -> {
                setSection(5000f)
            }
        }
    }

    private suspend fun setSection(maxSpeed: Float) {
        withContext(Dispatchers.Main) {
            val speedometer = view?.findViewById<PointerSpeedometer>(R.id.tubeSpeedometer) ?: return@withContext
            speedometer.maxSpeed = maxSpeed
            speedometer.clearSections()
            if (maxSpeed <= 100) {
                speedometer.addSections(
                    Section(0f, getPrcSpeed(30f, maxSpeed), Color.RED),
                    Section(getPrcSpeed(30f, maxSpeed), getPrcSpeed(70f, maxSpeed), Color.YELLOW),
                    Section(getPrcSpeed(70f, maxSpeed), 1f, Color.parseColor("#00af50"))
                )
            } else {
                speedometer.addSections(
                    Section(0f, getPrcSpeed(30f, speedometer.maxSpeed), Color.RED),
                    Section(getPrcSpeed(30f, maxSpeed), getPrcSpeed(70f, maxSpeed), Color.YELLOW),
                    Section(getPrcSpeed(70f, maxSpeed), getPrcSpeed(100f, maxSpeed), Color.parseColor("#00af50")),
                    Section(getPrcSpeed(100f, maxSpeed), 1f, Color.parseColor("#00ccff"))
                )
            }
        }
    }

    private fun getPrcSpeed(sp: Float, max: Float): Float {
        return sp / max
    }
}

```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/donate/DonateFragment.kt
```kt
package ru.yourok.torrserve.ui.fragments.donate

import android.annotation.SuppressLint
import android.content.ActivityNotFoundException
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.ImageView
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.content.res.AppCompatResources
import androidx.core.content.ContextCompat
import androidx.lifecycle.lifecycleScope
import com.google.android.material.snackbar.Snackbar
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.atv.Utils
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.ui.fragments.TSFragment
import ru.yourok.torrserve.utils.Format
import ru.yourok.torrserve.utils.ThemeUtil

class DonateFragment : TSFragment() {

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val vi = inflater.inflate(R.layout.donate_fragment, container, false)
        Settings.setLastViewDonate(System.currentTimeMillis() + 24 * 60 * 60 * 1000)

        vi.findViewById<Button>(R.id.btnBoosty)?.setOnClickListener {
            val link = "https://boosty.to/yourok"
            val intent = Intent(Intent.ACTION_VIEW, Uri.parse(link))
            intent.addCategory(Intent.CATEGORY_BROWSABLE)
            intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
            startActivitySafely(intent)
            Settings.setLastViewDonate(System.currentTimeMillis() + 15 * 24 * 60 * 60 * 1000)
        }

        vi.findViewById<Button>(R.id.btnYandex)?.setOnClickListener {
            val link = "https://yoomoney.ru/to/410013733697114"
            val intent = Intent(Intent.ACTION_VIEW, Uri.parse(link))
            intent.addCategory(Intent.CATEGORY_BROWSABLE)
            intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
            startActivitySafely(intent)
            Settings.setLastViewDonate(System.currentTimeMillis() + 15 * 24 * 60 * 60 * 1000)
        }

        vi.findViewById<Button>(R.id.btnTB)?.setOnClickListener {
            val link = "https://www.tbank.ru/cf/742qEMhKhKn"
            val intent = Intent(Intent.ACTION_VIEW, Uri.parse(link))
            intent.addCategory(Intent.CATEGORY_BROWSABLE)
            intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
            startActivitySafely(intent)
            Settings.setLastViewDonate(System.currentTimeMillis() + 15 * 24 * 60 * 60 * 1000)
        }

        vi.findViewById<Button>(R.id.btnTelegram)?.setOnClickListener {
            val intent = Intent()
            intent.action = Intent.ACTION_VIEW
            intent.addCategory(Intent.CATEGORY_BROWSABLE)
            intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
            intent.data = Uri.parse("https://t.me/torrserve")
            startActivitySafely(intent)
            Settings.setLastViewDonate(System.currentTimeMillis() + 15 * 24 * 60 * 60 * 1000)
        }

        vi.findViewById<ImageView>(R.id.ivTelegram)?.apply {
            alpha = 0.6f
            setOnFocusChangeListener { _, hasFocus ->
                alpha = if (hasFocus)
                    1.0f
                else
                    0.6f
            }
            setOnClickListener {
                val intent = Intent()
                intent.action = Intent.ACTION_VIEW
                intent.addCategory(Intent.CATEGORY_BROWSABLE)
                intent.data = Uri.parse("https://t.me/torrserve")
                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
                startActivitySafely(intent)
            }
        }
        return vi
    }

    private fun startActivitySafely(intent: Intent): Boolean {
        try {
            if (intent.resolveActivity(App.context.packageManager) != null) {
                App.context.startActivity(intent)
                return true
            }
        } catch (e: ActivityNotFoundException) {
            e.printStackTrace()
        }
        // Maybe will be added a Toast to notify user
        return false
    }

}

object DonateMessage {
    private var showDonate = Any()

    @SuppressLint("RestrictedApi")
    fun showDonate(activity: AppCompatActivity) {
        activity.lifecycleScope.launch(Dispatchers.IO) {
            synchronized(showDonate) {
                val last: Long = Settings.getLastViewDonate()
                if (System.currentTimeMillis() < last || showDonate == true)
                    return@launch
                showDonate = true
            }

            val snackbar = Snackbar.make(activity.findViewById(android.R.id.content), R.string.donate_message, Snackbar.LENGTH_INDEFINITE)
            Handler(Looper.getMainLooper()).postDelayed({
                val snackbarLayout: Snackbar.SnackbarLayout? = snackbar.view as Snackbar.SnackbarLayout?
                var bg = R.drawable.snackbar
                var tc = R.color.tv_white
                if (ThemeUtil.selectedTheme == R.style.Theme_TorrServe_Light) {
                    bg = R.drawable.snackbar_dark
                    tc = R.color.tv_white
                }
                snackbarLayout?.background = AppCompatResources.getDrawable(App.context, bg)
                val textView = snackbarLayout?.findViewById<View>(com.google.android.material.R.id.snackbar_text) as TextView?
                textView?.maxLines = 10
                textView?.textSize = 18.0f
                textView?.setTextColor(ContextCompat.getColor(App.context, tc))

                val screenWidth = App.currentActivity?.window?.decorView?.rootView?.width ?: 0
                val screenHeight = App.currentActivity?.window?.decorView?.rootView?.height ?: 0
                val isInLandscape = screenWidth > screenHeight

                var hmargin = Format.dp2px(12f)
                if (isInLandscape) // landscape
                    hmargin = screenWidth / 6
                val vmargin = Format.dp2px(64f)

                val layoutParams = snackbarLayout?.layoutParams as ViewGroup.MarginLayoutParams
                layoutParams.setMargins(hmargin, vmargin, hmargin, vmargin)
                snackbarLayout.layoutParams = layoutParams

                if (!Utils.isTvBox())
                    snackbar
                        .setAction(android.R.string.ok) {
                            DonateFragment().show(activity, R.id.container, true)
                        }
                snackbar.show()
            }, 5000)
            Handler(Looper.getMainLooper()).postDelayed({
                if (snackbar.isShown) {
                    snackbar.dismiss()
                    Settings.setLastViewDonate(System.currentTimeMillis() + 3 * 60 * 60 * 1000)
                }
                showDonate = false
            }, 10000)
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/rutor/TorrentsAdapter.kt
```kt
package ru.yourok.torrserve.ui.fragments.rutor

import android.annotation.SuppressLint
import android.graphics.drawable.Drawable
import android.text.SpannableString
import android.text.Spanned
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.appcompat.content.res.AppCompatResources
import androidx.recyclerview.widget.RecyclerView
import ru.yourok.torrserve.R
import ru.yourok.torrserve.ext.normalize
import ru.yourok.torrserve.server.models.torrent.TorrentDetails
import ru.yourok.torrserve.utils.CImageSpan
import ru.yourok.torrserve.utils.Format.sDateFmt
import ru.yourok.torrserve.utils.SpanFormat

class TorrentsAdapter : RecyclerView.Adapter<TorrentsAdapter.ViewHolder>() {
    val list = mutableListOf<TorrentDetails>()

    var onClick: ((TorrentDetails) -> Unit)? = null
    var onLongClick: ((TorrentDetails) -> Unit)? = null

    @SuppressLint("NotifyDataSetChanged")
    fun set(tds: List<TorrentDetails>) {
        try {
            this.list.clear()
            this.list.addAll(tds)
            notifyDataSetChanged()
        } catch (_: Exception) {
        }
    }

    class ViewHolder(val view: View, val adapter: TorrentsAdapter) : RecyclerView.ViewHolder(view) {
        init {
            view.setOnClickListener {
                adapter.onClick?.invoke(adapter.list[adapterPosition])
            }
            view.setOnLongClickListener {
                adapter.onLongClick?.invoke(adapter.list[adapterPosition])
                true
            }
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val vi = LayoutInflater.from(parent.context).inflate(R.layout.torrent_details_item, parent, false)
        return ViewHolder(vi, this)
    }

    @SuppressLint("SetTextI18n")
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val torr = list[position]
        val sDate = sDateFmt(torr.CreateDate)
        val category = torr.Categories.normalize()
        if (category.isNotBlank()) {
            val sIcon = SpannableString(" ")
            val cDrawable: Drawable? = when {
                category.contains("movie", true) -> AppCompatResources.getDrawable(holder.view.context, R.drawable.round_movie_24)
                category.contains("tv", true) -> AppCompatResources.getDrawable(holder.view.context, R.drawable.round_live_tv_24)
                category.contains("music", true) -> AppCompatResources.getDrawable(holder.view.context, R.drawable.round_music_note_24)
                category.contains("other", true) -> AppCompatResources.getDrawable(holder.view.context, R.drawable.round_more_horiz_24)
                else -> null
            }
            if (cDrawable == null)
                holder.view.findViewById<TextView>(R.id.tvName).text = "${category.replaceFirstChar{ if (it.isLowerCase()) it.titlecase() else it.toString() }} ‚óè ${torr.Title}"
            else {
                cDrawable.setBounds(0, 0, cDrawable.intrinsicWidth, cDrawable.intrinsicHeight)
                val span = CImageSpan(cDrawable)
                sIcon.setSpan(span, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                holder.view.findViewById<TextView>(R.id.tvName).text = SpanFormat.format("%s ${torr.Title}", sIcon)
            }
        } else
            holder.view.findViewById<TextView>(R.id.tvName).text = torr.Title
        holder.view.findViewById<TextView>(R.id.tvInfo1).text = "${torr.Size} ‚ñ≤${torr.Seed} ‚ñº${torr.Peer}"
        holder.view.findViewById<TextView>(R.id.tvInfo2).text = sDate // Hash.uppercase()
    }

    override fun getItemCount() = list.size

}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/add/AddFragment.kt
```kt
package ru.yourok.torrserve.ui.fragments.add

import android.annotation.SuppressLint
import android.content.res.ColorStateList
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.text.Editable
import android.text.TextWatcher
import android.util.Log
import android.view.KeyEvent
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.inputmethod.EditorInfo
import android.widget.Button
import android.widget.LinearLayout
import androidx.appcompat.content.res.AppCompatResources
import androidx.appcompat.view.ContextThemeWrapper
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.textfield.TextInputEditText
import com.google.android.material.textfield.TextInputLayout
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.ext.normalize
import ru.yourok.torrserve.ext.popBackStackFragment
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.settings.BTSets
import ru.yourok.torrserve.ui.activities.play.addTorrent
import ru.yourok.torrserve.ui.fragments.TSFragment
import ru.yourok.torrserve.ui.fragments.rutor.TorrentsAdapter
import ru.yourok.torrserve.utils.Format
import ru.yourok.torrserve.utils.ThemeUtil
import ru.yourok.torrserve.utils.TorrentHelper

class AddFragment : TSFragment() {

    private val torrsAdapter = TorrentsAdapter()
    private var jobSearch: Job? = null
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        return inflater.inflate(R.layout.add_fragment, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        view.apply {
            // FOOTER
            findViewById<LinearLayout>(R.id.footer)?.visibility = View.VISIBLE
            findViewById<Button>(R.id.btnOK)?.setOnClickListener {
                val link = view.findViewById<TextInputEditText>(R.id.etMagnet)?.text?.toString() ?: ""
                val title = view.findViewById<TextInputEditText>(R.id.etTitle)?.text?.toString() ?: ""
                val poster = view.findViewById<TextInputEditText>(R.id.etPoster)?.text?.toString() ?: ""
                val category = view.findViewById<TextInputEditText>(R.id.etCategory)?.text?.toString() ?: ""

                if (link.isNotBlank())
                    lifecycleScope.launch(Dispatchers.IO) {
                        try {
                            addTorrent("", link, title, poster, category, "", true)
                        } catch (e: Exception) {
                            e.printStackTrace()
                            App.toast(e.message ?: getString(R.string.error_retrieve_data))
                        }
                    }
                popBackStackFragment()
            }
            findViewById<Button>(R.id.btnCancel)?.setOnClickListener {
                popBackStackFragment()
            }
            // SEARCH and CATEGORY
            lifecycleScope.launch {
                withContext(Dispatchers.IO) {
                    val rutorEnabled = loadSettings()?.EnableRutorSearch == true
                    val categoryEnabled = Api.getMatrixVersionInt() > 131
                    withContext(Dispatchers.Main) {
                        findViewById<TextInputLayout>(R.id.tvRutor)?.apply {
                            visibility = if (rutorEnabled)
                                View.VISIBLE
                            else
                                View.GONE
                        }
                        findViewById<TextInputLayout>(R.id.tvCategory)?.apply {
                            visibility = if (categoryEnabled)
                                View.VISIBLE
                            else
                                View.GONE
                        }
                    }
                }
            }
            findViewById<androidx.constraintlayout.widget.Group>(R.id.adder)?.visibility = View.VISIBLE
            findViewById<TextInputEditText>(R.id.etSearch)?.apply {
                setOnEditorActionListener { textView, actionId, _ ->
                    if (actionId == EditorInfo.IME_ACTION_DONE) {
                        jobSearch?.cancel()
                        jobSearch = lifecycleScope.launch(Dispatchers.IO) {
                            val result = try {
                                Api.searchTorrents(textView.text.toString().trim())
                            } catch (e: Exception) {
                                e.message?.let {
                                    App.toast(it)
                                }
                                null
                            }
                            result?.let {
                                if (BuildConfig.DEBUG) Log.d("*****", "onTextChanged: ${it.size}")
                                if (it.isNotEmpty())
                                    withContext(Dispatchers.Main) {
                                        torrsAdapter.set(it)
                                        showSortFab()
                                    }
                                else {
                                    App.toast(R.string.no_torrents)
                                    hideSortFab()
                                }
                            }
                        }
                    }
                    true
                }
                addTextChangedListener(object : TextWatcher {
                    override fun afterTextChanged(s: Editable) {
                        val query = s.toString().trim()
                        if (query.isNotBlank() && query.length >= 3) {
                            jobSearch?.cancel()
                            jobSearch = lifecycleScope.launch(Dispatchers.IO) {
                                if (BuildConfig.DEBUG) Log.d("*****", "Api.searchTorrents($query)")
                                val result = try {
                                    Api.searchTorrents(query)
                                } catch (e: Exception) {
                                    e.message?.let {
                                        App.toast(it)
                                    }
                                    null
                                }
                                result?.let {
                                    if (BuildConfig.DEBUG) Log.d("*****", "onTextChanged: ${it.size}")
                                    if (it.isNotEmpty())
                                        withContext(Dispatchers.Main) {
                                            torrsAdapter.set(it)
                                            view.findViewById<androidx.constraintlayout.widget.Group>(R.id.adder)?.visibility = View.GONE
                                            view.findViewById<LinearLayout>(R.id.footer)?.visibility = View.GONE
                                            showSortFab()
                                        }
                                }
                            }
                        }
                    }

                    override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}

                    override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {}
                })
            }
            // RESULTS
            findViewById<RecyclerView>(R.id.rvRTorrents)?.apply {
                setHasFixedSize(true)
                layoutManager = LinearLayoutManager(context)
                adapter = torrsAdapter
                addItemDecoration(DividerItemDecoration(context, LinearLayout.VERTICAL))
            }
            torrsAdapter.onClick = {
                lifecycleScope.launch(Dispatchers.IO) {
                    try {
                        val category = it.Categories.normalize()
                        val torrent = addTorrent("", it.Magnet, it.Title, "", category, "", true)
                        torrent?.let { App.toast("${App.context.getString(R.string.stat_string_added)}: ${it.title}", true) } ?: App.toast(R.string.error_add_torrent)
                    } catch (e: Exception) {
                        App.toast(e.message ?: App.context.getString(R.string.error_add_torrent))
                    }
                    popBackStackFragment()
                }
            }
            torrsAdapter.onLongClick = {
                lifecycleScope.launch(Dispatchers.IO) {
                    val category = it.Categories.normalize()
                    val torrent: Torrent
                    val torr = addTorrent("", it.Magnet, it.Title, "", category, "", false) ?: let {
                        return@launch
                    }
                    torrent = TorrentHelper.waitFiles(torr.hash) ?: let {
                        return@launch
                    }
                    TorrentHelper.showFFPInfo(view.context, it.Magnet, torrent)
                }
            }
            // SORT
            setupSortFab()
        }
    }

    fun onKeyUp(keyCode: Int): Boolean {
        when (keyCode) {
            KeyEvent.KEYCODE_INFO,
            KeyEvent.KEYCODE_MENU,
            KeyEvent.KEYCODE_BUTTON_X -> {
                return true
            }
        }
        return false
    }

    fun onKeyDown(keyCode: Int): Boolean {
        when (keyCode) {
            KeyEvent.KEYCODE_INFO -> {
                activity?.currentFocus?.let {
                    it.findViewById<RecyclerView>(R.id.rvRTorrents)?.let { rv ->
                        val itemPosition = rv.getChildAdapterPosition(rv.focusedChild)
                        if (itemPosition in torrsAdapter.list.indices) {
                            torrsAdapter.list[itemPosition].let {
                                lifecycleScope.launch(Dispatchers.IO) {
                                    val category = it.Categories.normalize()
                                    val torrent: Torrent
                                    val torr = addTorrent("", it.Magnet, it.Title, "", category, "", false) ?: let {
                                        return@launch
                                    }
                                    torrent = TorrentHelper.waitFiles(torr.hash) ?: let {
                                        return@launch
                                    }
                                    TorrentHelper.showFFPInfo(rv.context, it.Magnet, torrent)
                                }
                            }
                        }
                    }
                }
                return true
            }

            KeyEvent.KEYCODE_MENU,
            KeyEvent.KEYCODE_BUTTON_X -> {
                sortResults()
                return true
            }
        }

        return false
    }

    private var sortMode: Int = 0

    @SuppressLint("NotifyDataSetChanged")
    private fun sortResults() {
        val list = torrsAdapter.list //.toMutableList()
        when (sortMode) {
            0 -> {
                torrsAdapter.set(list.sortedBy { it.Title })
                App.toast(R.string.sort_by_name)
            }

            1 -> { // 10.22 GB
                val sort = list.sortedWith(compareBy(nullsLast(reverseOrder())) { td ->
                    if (td.Size.contains("GB", true))
                        td.Size.filter { it.isDigit() || it == '.' }.toDoubleOrNull()?.let { it * 1024 * 1024 }
                    else if (td.Size.contains("MB", true))
                        td.Size.filter { it.isDigit() || it == '.' }.toDoubleOrNull()?.let { it * 1024 }
                    else
                        td.Size.filter { it.isDigit() || it == '.' }.toDoubleOrNull()
                })
                torrsAdapter.set(sort) // list.sortedByDescending { it.Size }
                App.toast(R.string.sort_by_size)
            }

            2 -> {
                val sort = list.sortedWith(compareBy(nullsLast(reverseOrder())) { it.Seed })
                torrsAdapter.set(sort)
                App.toast(R.string.sort_by_seed)
            }

            3 -> { // 2021-06-21T00:00:00+03:00
                torrsAdapter.set(list.sortedByDescending { it.CreateDate })
//                val sort = list.sortedWith(compareBy(nullsLast(reverseOrder())) { td ->
//                    if (td.CreateDate.length == 25) td.CreateDate.substring(0, 10)
//                    else td.CreateDate
//                })
//                torrsAdapter.set(sort)
                App.toast(R.string.sort_by_date)
            }
        }
        torrsAdapter.notifyDataSetChanged()
        if (torrsAdapter.list.size > 0)
            activity?.findViewById<RecyclerView>(R.id.rvRTorrents)?.apply {
                scrollToPosition(0)
                // FIXME: Why RecycleView loose focus to Logo?
                Handler(Looper.getMainLooper()).postDelayed({
                    getChildAt(0).requestFocus()
                }, 500)
            }
        if (sortMode == 3) sortMode = 0 else sortMode++
    }

    private fun setupSortFab() { // Sort Fab
        val fab: FloatingActionButton? = requireActivity().findViewById(R.id.sortFab)
        val themedContext = ContextThemeWrapper(App.context, ThemeUtil.selectedTheme)
        val accentColor = ThemeUtil.getColorFromAttr(themedContext, R.attr.colorAccent)
        val actionsColor = ThemeUtil.getColorFromAttr(themedContext, R.attr.colorMainMenu)

        fab?.apply {
            setImageDrawable(AppCompatResources.getDrawable(this.context, R.drawable.round_sort_24))
            customSize = Format.dp2px(32f)
            setMaxImageSize(Format.dp2px(24f))
            setColorFilter(accentColor)
            setRippleColor(ColorStateList.valueOf(accentColor))
            backgroundTintList = ColorStateList.valueOf(actionsColor)
            isFocusable = true
            isClickable = true
            setOnClickListener {
                // TODO: add sort options menu
                sortResults()
            }
            visibility = View.GONE
        }
    }

    private fun showSortFab() {
        val fab: FloatingActionButton? = requireActivity().findViewById(R.id.sortFab)
        fab?.show()
    }

    private fun hideSortFab() {
        val fab: FloatingActionButton? = requireActivity().findViewById(R.id.sortFab)
        fab?.hide()
    }

    private fun loadSettings(): BTSets? {
        return try {
            Api.getSettings()
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/LogFragment.kt
```kt
package ru.yourok.torrserve.ui.fragments

import android.graphics.Typeface
import android.os.Bundle
import android.text.Spannable
import android.text.SpannableString
import android.text.SpannableStringBuilder
import android.text.style.ForegroundColorSpan
import android.text.style.StyleSpan
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.TextView
import androidx.core.content.res.ResourcesCompat
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.NonCancellable
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.utils.Format.byteFmt
import ru.yourok.torrserve.utils.ThemeUtil
import java.io.BufferedReader
import java.io.File
import java.io.FileReader
import java.io.RandomAccessFile
import java.util.regex.Pattern

class LogFragment : TSFragment() {
    // Chunk size for reading file
    private companion object {
        const val DEFAULT_BUFFER_SIZE = 8192
        const val MAX_LOG_SIZE = 512 * 1024 // 512 KB limit
    }

    // File handling
    private val logfile = File(Settings.logPath(), "torrserver.log")
    private lateinit var logView: TextView

    // Color cache
    private val warningColor by lazy { ResourcesCompat.getColor(resources, R.color.design_default_color_error, null) }
    private val startMarkerColor by lazy { ResourcesCompat.getColor(resources, R.color.orange_dark, null) }
    private val timestampColor by lazy { ThemeUtil.getColorFromAttr(requireContext(), R.attr.colorOnSurface).withAlpha(150) }
    private val hostColor by lazy { ThemeUtil.getColorFromAttr(requireContext(), R.attr.colorHost) }
    private val accentColor by lazy { ThemeUtil.getColorFromAttr(requireContext(), R.attr.colorAccent) }

    // Precompiled patterns (more efficient than Regex)
    private val startMarkerPattern by lazy { Pattern.compile("=+ START =+") }
    private val timestampPattern by lazy { Pattern.compile("\\d{4}/\\d{2}/\\d{2} \\d{2}:\\d{2}:\\d{2} UTC\\d+") }
    private val errorPattern by lazy { Pattern.compile("(?i)(error|warn|fail|exception)") }
    private val ipPattern by lazy { Pattern.compile("\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}") }
    private val simpleIpv6Pattern by lazy { Pattern.compile("[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4}){3,7}") }
    private val configBlockPattern by lazy { Pattern.compile("\\{.*?\\}") }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val vi = inflater.inflate(R.layout.log_fragment, container, false)
        val title = vi.findViewById<TextView>(R.id.tvTitle)
        val btnClear = vi.findViewById<Button>(R.id.btnClear)

        title.text = logfile.path
        logView = vi.findViewById(R.id.tvLog)
        updateFileSizeInfo(btnClear)

        btnClear?.setOnClickListener {
            clearLog(logfile)
            btnClear.text = getString(R.string.delete)
        }

        return vi
    }

    private fun updateFileSizeInfo(btnClear: Button?) {
        val (sizeText, exactBytes) = getFileSize(logfile)
        if (exactBytes > 0L) {
            btnClear?.text = "${getString(R.string.delete)} $sizeText"
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        if (logfile.canRead()) {
            loadLogFile()
        } else {
            App.toast("${getString(R.string.error_retrieve_data)} ${logfile.path}")
        }
    }

    private fun loadLogFile() {
        lifecycleScope.launch {
            try {
                showProgress()
                val (content, wasTrimmed) = withContext(Dispatchers.IO) {
                    val content = readLogFileWithChunks(logfile)
                    val trimmed = logfile.length() > MAX_LOG_SIZE
                    content to trimmed
                }

                // Process in chunks to avoid blocking UI thread
                val highlightedContent = withContext(Dispatchers.Default) {
                    if (wasTrimmed) {
                        val trimmedMessage = SpannableString("‚ö†Ô∏è " + getString(R.string.torrserver_log_trimmed, byteFmt(MAX_LOG_SIZE)) + "\n\n")
                        // Style the trimmed message
                        trimmedMessage.setSpan(
                            ForegroundColorSpan(warningColor),
                            0,
                            trimmedMessage.length,
                            Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                        )
                        trimmedMessage.setSpan(
                            StyleSpan(Typeface.BOLD),
                            0,
                            trimmedMessage.length,
                            Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                        )

                        val logSpannable = highlightLog(content)
                        // Combine both messages
                        val combined = SpannableStringBuilder()
                            .append(trimmedMessage)
                            .append(logSpannable)
                        combined
                    } else {
                        highlightLog(content)
                    }
                }

                logView.text = highlightedContent
            } catch (e: Exception) {
                logView.text = e.localizedMessage ?: "Error loading log"
            } finally {
                withContext(NonCancellable) { // Ensure this runs even if coroutine is cancelled
                    hideProgress()
                }
            }
        }
    }

    private fun readLogFileWithChunks(file: File, chunkSize: Int = DEFAULT_BUFFER_SIZE): String {
        return when {
            !file.exists() -> ""
            file.length() > MAX_LOG_SIZE -> {
                // For large files, read only the end portion
                RandomAccessFile(file, "r").use { raf ->
                    val startPos = file.length() - MAX_LOG_SIZE
                    var pos = maxOf(0, startPos)
                    // Find the next newline character
                    if (startPos > 0) {
                        raf.seek(pos)
                        while (pos < file.length()) {
                            if (raf.readByte().toInt().toChar() == '\n') {
                                pos = raf.filePointer
                                break
                            }
                            pos++
                        }
                    }
                    // Read from the found position
                    raf.seek(pos)
                    val buffer = ByteArray(minOf(MAX_LOG_SIZE, (file.length() - pos).toInt()))
                    raf.readFully(buffer)
                    String(buffer, Charsets.UTF_8)
                }
            }

            else -> {
                // Normal file reading
                BufferedReader(FileReader(file), chunkSize).use { it.readText() }
            }
        }
    }

    private fun highlightLog(content: String): SpannableString {
        val spannable = SpannableString(content)

        // Process highlights in order of most specific to least specific
        highlightPattern(spannable, startMarkerPattern, startMarkerColor, bold = true)
        highlightPattern(spannable, errorPattern, warningColor)
        highlightPattern(spannable, ipPattern, hostColor) // IPv4
        highlightPattern(spannable, simpleIpv6Pattern, hostColor) // IPv6
        highlightPattern(spannable, configBlockPattern, accentColor)
        highlightPattern(spannable, timestampPattern, timestampColor)

        return spannable
    }

    private fun highlightPattern(
        spannable: SpannableString,
        pattern: Pattern,
        color: Int,
        bold: Boolean = false
    ) {
        val matcher = pattern.matcher(spannable)
        while (matcher.find()) {
            val start = matcher.start()
            val end = matcher.end()

            spannable.setSpan(
                ForegroundColorSpan(color),
                start,
                end,
                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
            )
            if (bold) {
                spannable.setSpan(
                    StyleSpan(Typeface.BOLD),
                    start,
                    end,
                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                )
            }
        }
    }

    private fun Int.withAlpha(alpha: Int): Int {
        return (alpha shl 24) or (this and 0x00FFFFFF)
    }

    fun clearLog(file: File) {
        lifecycleScope.launch {
            try {
                withContext(Dispatchers.IO) {
                    file.writeText("")
                }
                logView.text = getString(R.string.torrserver_log_cleared)
                updateFileSizeInfo(view?.findViewById(R.id.btnClear))
            } catch (e: Exception) {
                logView.text = e.localizedMessage
            }
        }
    }

    fun getFileSize(file: File): Pair<String, Long> {
        return try {
            if (!file.exists()) return "File not found" to -1
            val bytes = file.length()
            byteFmt(bytes) to bytes
        } catch (_: SecurityException) {
            "No read permission" to -1
        } catch (e: Exception) {
            "Error: ${e.message}" to -1
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/TSFragment.kt
```kt
package ru.yourok.torrserve.ui.fragments

import android.view.View
import androidx.appcompat.view.ContextThemeWrapper
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.lifecycle.ViewModel
import androidx.lifecycle.lifecycleScope
import com.google.android.material.progressindicator.LinearProgressIndicator
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.ext.commitFragment
import ru.yourok.torrserve.ext.getLastFragment
import ru.yourok.torrserve.utils.ThemeUtil

abstract class TSFragment : Fragment() {
    var onResult: (suspend (Any?) -> Unit)? = null
    protected lateinit var viewModel: ViewModel

    fun show(activity: FragmentActivity?, id: Int, back: Boolean = false) {
        if (activity?.getLastFragment()?.javaClass?.name == this.javaClass.name)
            return
        activity?.commitFragment {
            replace(id, this@TSFragment)
            if (back)
                addToBackStack(this.toString())
        }
        // hide progress after main menu click
        lifecycleScope.launch { hideProgress() }
    }

    // https://material.io/components/progress-indicators/android
    suspend fun showProgress(prog: Int = -1) = withContext(Dispatchers.Main) {
        if (isActive) {
            val themedContext = ContextThemeWrapper(App.context, ThemeUtil.selectedTheme)
            val color = ThemeUtil.getColorFromAttr(themedContext, R.attr.colorAccent)
            activity?.findViewById<LinearProgressIndicator>(R.id.progressBar)?.apply {
                setIndicatorColor(color)
                visibility = View.VISIBLE
                isIndeterminate = prog < 0
                if (!isIndeterminate)
                    setProgressCompat(prog, true)
            }
        }
    }

    suspend fun hideProgress() = withContext(Dispatchers.Main) {
        if (isActive)
            activity?.findViewById<LinearProgressIndicator>(R.id.progressBar)?.apply {
                visibility = View.GONE
                isIndeterminate = true
            }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/play/viewmodels/InfoViewModel.kt
```kt
package ru.yourok.torrserve.ui.fragments.play.viewmodels

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.models.torrent.Torrent

data class InfoTorrent(val torrent: Torrent?, val error: String)

class InfoViewModel : ViewModel() {
    private var data: MutableLiveData<InfoTorrent>? = null
    private var lock = Any()
    private var torrent: Torrent? = null

    fun setTorrent(hash: String): LiveData<InfoTorrent> {
        if (data == null)
            data = MutableLiveData()

        viewModelScope.launch(Dispatchers.IO) {
            try {
                torrent = Api.getTorrent(hash)
                withContext(Dispatchers.Main) {
                    data?.value = InfoTorrent(torrent, "")
                }
                update()
            } catch (e: Exception) {
                e.printStackTrace()
                withContext(Dispatchers.Main) {
                    data?.value = InfoTorrent(null, e.message ?: App.context.getString(R.string.error_add_torrent))
                }
            }
        }

        return data!!
    }

    override fun onCleared() {
        lock = false
        super.onCleared()
    }

    private fun update() {
        if (torrent == null)
            return

        synchronized(lock) {
            if (lock == true)
                return
            lock = true
            viewModelScope.launch(Dispatchers.IO) {
                while (lock == true) {
                    try {
                        torrent?.let {
                            torrent = Api.getTorrent(it.hash)
                            withContext(Dispatchers.Main) {
                                data?.value = InfoTorrent(torrent, "")
                            }
                        }
                        delay(100)
                    } catch (e: Exception) {
                        withContext(Dispatchers.Main) {
                            data?.value = InfoTorrent(null, e.message ?: App.context.getString(R.string.error_retrieve_torrent_info))
                        }
                        delay(1000)
                    }
                }
            }
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/play/ChooserFragment.kt
```kt
package ru.yourok.torrserve.ui.fragments.play

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.CheckBox
import androidx.cardview.widget.CardView
import androidx.lifecycle.lifecycleScope
import com.google.android.material.switchmaterial.SwitchMaterial
import kotlinx.coroutines.launch
import ru.yourok.torrserve.R
import ru.yourok.torrserve.ext.commitFragment
import ru.yourok.torrserve.server.local.TorrService
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.ui.activities.play.PlayActivity
import ru.yourok.torrserve.ui.fragments.TSFragment


class ChooserFragment : TSFragment() {

    fun show(activity: PlayActivity, forceChoose: Boolean, onChoose: (Int) -> Unit) {
        val saveChoose = Settings.getChooserAction()
        if (!forceChoose && saveChoose in 1..3) {
            onChoose(saveChoose)
            return
        }

        this.onResult = {
            val action = (it as Int)
            if (action in 1..3)
                onChoose(action)

            activity.commitFragment {
                detach(this@ChooserFragment)
            }
        }
        show(activity, R.id.info_container)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val vi = inflater.inflate(R.layout.chooser_fragment, container, false)
        TorrService.start()
        return vi
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        view.apply {
            findViewById<CardView>(R.id.cvPlay)?.setOnClickListener {
                lifecycleScope.launch {
                    onResult?.invoke(1)
                    saveAction(1)
                }
            }
            findViewById<CardView>(R.id.cvAddPlay)?.setOnClickListener {
                lifecycleScope.launch {
                    onResult?.invoke(2)
                    saveAction(2)
                }
            }
            findViewById<CardView>(R.id.cvAdd)?.setOnClickListener {
                lifecycleScope.launch {
                    onResult?.invoke(3)
                    saveAction(3)
                }
            }
        }
    }

    private fun saveAction(action: Int) {
        view?.findViewById<SwitchMaterial>(R.id.cbSaveChooseAction)?.apply {
            if (isChecked)
                lifecycleScope.launch {
                    Settings.setChooserAction(action)
                }
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/play/TorrentFilesFragment.kt
```kt
package ru.yourok.torrserve.ui.fragments.play

import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.ListView
import androidx.fragment.app.FragmentActivity
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.ext.urlEncode
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.api.Viewed
import ru.yourok.torrserve.server.local.TorrService
import ru.yourok.torrserve.server.models.torrent.FileStat
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.ui.fragments.TSFragment
import ru.yourok.torrserve.ui.fragments.play.adapters.TorrentFilesAdapter
import ru.yourok.torrserve.utils.Net
import ru.yourok.torrserve.utils.TorrentHelper
import kotlin.math.max

class TorrentFilesFragment : TSFragment() {
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val vi = inflater.inflate(R.layout.torrent_file_fragment, container, false)
        TorrService.start()
        return vi
    }

    private val torrFilesAdapter = TorrentFilesAdapter()
    private var torrent: Torrent? = null
    private var viewed: List<Viewed>? = null
    private var onClickItem: ((file: FileStat) -> Unit)? = null

    suspend fun showTorrent(activity: FragmentActivity, torr: Torrent, viewed: List<Viewed>?, onClickItem: (file: FileStat) -> Unit) = withContext(Dispatchers.Main) {
        torrent = torr
        this@TorrentFilesFragment.viewed = viewed
        this@TorrentFilesFragment.onClickItem = onClickItem
        torrFilesAdapter.update(torr, viewed)
        show(activity, R.id.bottom_container)
    }

    override fun onResume() {
        super.onResume()
        lifecycleScope.launch(Dispatchers.IO) {
            val viewed = try {
                Api.listViewed(torrent?.hash ?: return@launch)
            } catch (_: Exception) {
                return@launch
            }
            if (viewed.size != torrFilesAdapter.viewed.size)
                withContext(Dispatchers.Main) {
                    torrFilesAdapter.update(torrent ?: return@withContext, viewed)
                    torrFilesAdapter.notifyDataSetChanged()
                }
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        view.apply {
            var last = 0
            viewed?.forEach { last = max(last, it.file_index) }
            val file = TorrentHelper.findFile(torrent ?: return, last)
            val next = if (file != null)
                TorrentHelper.findIndex(torrent ?: return, file)
            else
                last

            findViewById<Button>(R.id.btnPlaylist).setOnClickListener {
                lifecycleScope.launch(Dispatchers.IO) {
                    torrent?.let { torr ->
                        try {
                            if (Api.listTorrent().isNotEmpty()) {
                                val intent = Intent(Intent.ACTION_VIEW)
                                intent.setDataAndType(Uri.parse(Net.getHostUrl("/playlist/${torr.name.urlEncode()}.m3u?hash=${torr.hash}")), "video/*")
                                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
                                App.context.startActivity(intent)
                            }
                        } catch (e: Exception) {
                            e.message?.let { App.toast(it) }
                        }
                    }
                }
            }
            findViewById<Button>(R.id.btnPlaylistContinue).setOnClickListener {
                lifecycleScope.launch(Dispatchers.IO) {
                    torrent?.let { torr ->
                        try {
                            if (Api.listTorrent().isNotEmpty()) {
                                val intent = Intent(Intent.ACTION_VIEW)
                                intent.setDataAndType(Uri.parse(Net.getHostUrl("/playlist/${torr.name.urlEncode()}.m3u?hash=${torr.hash}&fromlast")), "video/*")
                                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
                                App.context.startActivity(intent)
                            }
                        } catch (e: Exception) {
                            e.message?.let { App.toast(it) }
                        }
                    }
                }
            }
            findViewById<ListView>(R.id.lvTorrentFiles).apply {
                adapter = torrFilesAdapter
                setOnItemClickListener { _, _, position, _ ->
                    val f = torrFilesAdapter.getItem(position) as FileStat? ?: return@setOnItemClickListener
                    onClickItem?.invoke(f)
                    // clear all viewed
                    if (torrFilesAdapter.count > 1 && position == count - 1) {
                        lifecycleScope.launch(Dispatchers.IO) {
                            torrent?.hash?.let { hash ->
                                try {
                                    Api.remViewed(hash)
                                } catch (e: Exception) {
                                    e.message?.let { App.toast(it) }
                                }
                            }
                        }
                    }
                }
                setOnItemLongClickListener { _, _, position, _ ->
                    val fs = torrFilesAdapter.getItem(position) as FileStat?
                    fs?.let { file ->
                        // rem viewed
                        if (torrFilesAdapter.viewed.any { it.file_index == file.id }) {
                            lifecycleScope.launch(Dispatchers.IO) {
                                torrent?.hash?.let { hash ->
                                    try {
                                        Api.remViewed(hash, file.id)
                                        withContext(Dispatchers.Main) {
                                            val element = torrFilesAdapter.viewed.find { it.file_index == file.id }
                                            val list = torrFilesAdapter.viewed.toMutableList()
                                            list.removeAt(torrFilesAdapter.viewed.indexOf(element))
                                            torrFilesAdapter.update(torrent ?: return@withContext, list)
                                            torrFilesAdapter.notifyDataSetChanged()
                                        }
                                    } catch (e: Exception) {
                                        e.message?.let { App.toast(it) }
                                    }
                                }
                            }
                        } else { // set viewed
                            lifecycleScope.launch(Dispatchers.IO) {
                                torrent?.hash?.let { hash ->
                                    try {
                                        Api.setViewed(hash, file.id)
                                        withContext(Dispatchers.Main) {
                                            val list = torrFilesAdapter.viewed.toMutableList()
                                            val item = Viewed(hash = hash, file_index = file.id)
                                            list.add(item)
                                            list.sortBy { it.file_index }
                                            torrFilesAdapter.update(torrent ?: return@withContext, list)
                                            torrFilesAdapter.notifyDataSetChanged()
                                        }
                                    } catch (e: Exception) {
                                        e.message?.let { App.toast(it) }
                                    }
                                }
                            }
                        }
                    }
                    true
                }
                postDelayed({
                    setSelection(next)
                    requestFocus()
                }, 500)
            }
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/play/adapters/TorrentFilesAdapter.kt
```kt
package ru.yourok.torrserve.ui.fragments.play.adapters

import android.annotation.SuppressLint
import android.content.res.ColorStateList
import android.graphics.text.LineBreaker
import android.os.Build
import android.text.SpannableString
import android.text.Spanned
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseAdapter
import android.widget.ImageView
import android.widget.TextView
import androidx.appcompat.content.res.AppCompatResources
import androidx.appcompat.view.ContextThemeWrapper
import androidx.core.graphics.ColorUtils
import com.google.android.material.shape.CornerFamily
import com.google.android.material.shape.MaterialShapeDrawable
import com.google.android.material.shape.ShapeAppearanceModel
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.ext.append
import ru.yourok.torrserve.ext.clearName
import ru.yourok.torrserve.ext.clearPath
import ru.yourok.torrserve.server.api.Viewed
import ru.yourok.torrserve.server.models.torrent.FileStat
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.utils.CImageSpan
import ru.yourok.torrserve.utils.Format
import ru.yourok.torrserve.utils.SpanFormat
import ru.yourok.torrserve.utils.ThemeUtil
import ru.yourok.torrserve.utils.TorrentHelper
import java.io.File


class TorrentFilesAdapter : BaseAdapter() {
    private var files: List<FileStat> = listOf()
    private val typeFile = 0
    private val typeButton = 1
    var viewed = listOf<Viewed>()

    fun update(torrent: Torrent, viewed: List<Viewed>?) {
        files = TorrentHelper.getPlayableFiles(torrent)
        if (viewed != null) this.viewed = viewed
    }

    @SuppressLint("SetTextI18n")
    override fun getView(position: Int, view: View?, parent: ViewGroup?): View {
        val type: Int = getItemViewType(position)
        val themedContext = ContextThemeWrapper(App.context, ThemeUtil.selectedTheme)
        val colorBright = ThemeUtil.getColorFromAttr(themedContext, R.attr.colorBright)
        val color1 = ColorUtils.setAlphaComponent(ThemeUtil.getColorFromAttr(themedContext, R.attr.colorBright), 140)
        val color2 = ColorUtils.setAlphaComponent(ThemeUtil.getColorFromAttr(themedContext, R.attr.colorBright), 250)
        // round labels model
        val radius = Format.dp2px(2.0f).toFloat()
        val shapeAppearanceModel = ShapeAppearanceModel()
            .toBuilder()
            .setAllCorners(CornerFamily.ROUNDED, radius)
            .build()

        val vi = view ?: if (type == typeFile) LayoutInflater.from(parent?.context).inflate(R.layout.torrent_files_item, parent, false)
        else LayoutInflater.from(parent?.context).inflate(R.layout.torrent_files_button, parent, false)
        if (files.size > 1 && position == count - 1) return vi

        val file = files[position]
        val tvFileName = vi.findViewById<TextView>(R.id.tvFileName)
        val path = File(file.path).parent
        val name = File(file.path).nameWithoutExtension.clearName()
        val ext = File(file.path).extension

        if (!path.isNullOrEmpty()) { // split path
            tvFileName.apply {
                val folder = path.substringAfterLast("/").clearPath()
                val sIcon = SpannableString(" ")
                val cDrawable = AppCompatResources.getDrawable(context, R.drawable.twotone_folder_16)
                cDrawable?.let {
                    it.setBounds(0, 0, it.intrinsicWidth, it.intrinsicHeight)
                    val span = CImageSpan(it)
                    sIcon.setSpan(span, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                }
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    breakStrategy = LineBreaker.BREAK_STRATEGY_SIMPLE
                }
                text = SpanFormat.format("%s\u00A0$folder\n", sIcon) // ""
                //append("$folder\n", color1) // folder
                append(name, color2) // file
                // if (ext.isNotEmpty()) // extension
                    // append(" .$ext", color1)
            }
        } else {
            tvFileName.apply {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    breakStrategy = LineBreaker.BREAK_STRATEGY_SIMPLE
                }
                text = ""
                append(name, color2) // file
                // if (ext.isNotEmpty()) // extension
                    // append(" .$ext", color1)
            }
        }

        if (ext.isNotEmpty()) { // extension
            // append(" .$ext", color1)
            vi.findViewById<TextView>(R.id.tvExt)?.apply {
                visibility = View.VISIBLE
                text = ".$ext"
                val shapeDrawable = MaterialShapeDrawable(shapeAppearanceModel)
                shapeDrawable.fillColor = ColorStateList.valueOf(colorBright).withAlpha(40)
                shapeDrawable.setStroke(2.0f, ColorStateList.valueOf(colorBright).withAlpha(140))
                background = shapeDrawable
                setTextColor(color1)
            }
        }

        val size = Format.byteFmt(file.length)
        vi.findViewById<TextView>(R.id.tvFileSize)?.apply {
            text = size
            val shapeDrawable = MaterialShapeDrawable(shapeAppearanceModel)
            shapeDrawable.fillColor = ColorStateList.valueOf(colorBright).withAlpha(240)
            shapeDrawable.setStroke(2.0f, ColorStateList.valueOf(colorBright).withAlpha(255))
            background = shapeDrawable
            setTextColor(ThemeUtil.getColorFromAttr(themedContext, R.attr.colorSurface))
        }

        vi.findViewById<ImageView>(R.id.ivViewed)?.apply {
            visibility = View.GONE
            for (it in viewed) {
                if (it.file_index == file.id) {
                    visibility = View.VISIBLE
                    break
                }
            }
        }
        return vi
    }

    override fun getItem(p0: Int): Any? {
        if (p0 < 0 || p0 >= count) return null
        // play from beginning
        if (files.size > 1 && p0 == count - 1) return files[0]
        return files[p0]
    }

    override fun getItemId(p0: Int): Long {
        return p0.toLong()
    }

    override fun getCount(): Int {
        return if (files.size > 1) files.size + 1
        else files.size
    }

    override fun getItemViewType(position: Int): Int {
        return if (files.size > 1 && position == count - 1) typeButton else typeFile
    }

    override fun getViewTypeCount(): Int {
        return 2
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/play/InfoFragment.kt
```kt
package ru.yourok.torrserve.ui.fragments.play

import android.annotation.SuppressLint
import android.graphics.drawable.Drawable
import android.os.Bundle
import android.text.SpannableString
import android.text.Spanned
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.appcompat.content.res.AppCompatResources
import androidx.appcompat.view.ContextThemeWrapper
import androidx.constraintlayout.widget.ConstraintLayout
import androidx.core.graphics.ColorUtils
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import com.bumptech.glide.Glide
import com.bumptech.glide.load.resource.bitmap.BitmapTransitionOptions
import com.bumptech.glide.load.resource.bitmap.RoundedCorners
import com.bumptech.glide.request.RequestOptions
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.R
import ru.yourok.torrserve.ext.append
import ru.yourok.torrserve.server.local.TorrService
import ru.yourok.torrserve.server.models.torrent.FileStat
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.ui.activities.play.PlayActivity
import ru.yourok.torrserve.ui.fragments.TSFragment
import ru.yourok.torrserve.ui.fragments.play.viewmodels.InfoTorrent
import ru.yourok.torrserve.ui.fragments.play.viewmodels.InfoViewModel
import ru.yourok.torrserve.utils.CImageSpan
import ru.yourok.torrserve.utils.Format
import ru.yourok.torrserve.utils.SpanFormat
import ru.yourok.torrserve.utils.ThemeUtil
import ru.yourok.torrserve.utils.ThemeUtil.Companion.getColorFromAttr
import ru.yourok.torrserve.utils.TorrentHelper
import java.io.File
import java.util.Locale

open class InfoFragment : TSFragment() {

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val vi = inflater.inflate(R.layout.info_fragment, container, false)
        lifecycleScope.launch {
            (activity as? PlayActivity)?.showProgress()
            vi.findViewById<TextView?>(R.id.tvTitle)?.setText(R.string.loading_torrent)
            vi.findViewById<ConstraintLayout?>(R.id.clInfo)?.visibility = View.GONE
        }
        TorrService.start()
        return vi
    }

    private var posterUrl = " "
    suspend fun startInfo(hash: String) = withContext(Dispatchers.Main) {
        try {
            viewModel = ViewModelProvider(this@InfoFragment)[InfoViewModel::class.java]
            if (isActive) {
                val data = (viewModel as InfoViewModel).setTorrent(hash)
                data.observe(this@InfoFragment) {
                    updateUI(it, (requireActivity() as PlayActivity).torrentFileIndex)
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @SuppressLint("SetTextI18n")
    private fun updateUI(info: InfoTorrent, index: Int) {
        lifecycleScope.launch {
            view?.findViewById<ConstraintLayout?>(R.id.clInfo)?.visibility = View.VISIBLE
            if (info.torrent == null && info.error.isNotEmpty()) {
                view?.findViewById<TextView?>(R.id.tvInfo)?.text = info.error
                return@launch
            }
            info.torrent?.let { torr ->
                view?.apply {
                    if (posterUrl != torr.poster) {
                        posterUrl = torr.poster ?: ""
                        if (posterUrl.isNotEmpty() && Settings.showCover())
                            findViewById<ImageView?>(R.id.ivPoster)?.let {
                                it.visibility = View.VISIBLE
                                Glide.with(this)
                                    .asBitmap()
                                    .load(posterUrl)
                                    .centerCrop()
                                    //.placeholder(ColorDrawable(0x3c000000))
                                    .apply(RequestOptions.bitmapTransform(RoundedCorners(6)))
                                    .transition(BitmapTransitionOptions.withCrossFade())
                                    .into(it)
                            }
                        else
                            findViewById<ImageView>(R.id.ivPoster)?.visibility = View.GONE
                    }
                    val category = torr.category ?: ""
                    val title = torr.title
                    val tv = findViewById<TextView?>(R.id.tvTitle)

                    if (title.isEmpty())
                        tv.visibility = View.GONE
                    else {
                        (activity as? PlayActivity)?.hideTitle()
                        tv.visibility = View.VISIBLE
                        //tv.text = title
                        if (category.isNotBlank()) {
                            val sIcon = SpannableString(" ")
                            val cDrawable: Drawable? = when {
                                category.contains("movie", true) -> AppCompatResources.getDrawable(requireContext(), R.drawable.round_movie_24)
                                category.contains("tv", true) -> AppCompatResources.getDrawable(requireContext(), R.drawable.round_live_tv_24)
                                category.contains("music", true) -> AppCompatResources.getDrawable(requireContext(), R.drawable.round_music_note_24)
                                category.contains("other", true) -> AppCompatResources.getDrawable(requireContext(), R.drawable.round_more_horiz_24)
                                else -> null
                            }
                            if (cDrawable == null)
                                tv.text = "${category.uppercase()} ‚óè $title"
                            else {
                                cDrawable.setBounds(0, 0, cDrawable.intrinsicWidth, cDrawable.intrinsicHeight)
                                val span = CImageSpan(cDrawable)
                                sIcon.setSpan(span, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                                tv.text = SpanFormat.format("%s $title", sIcon)
                            }
                        } else
                            tv.text = title
                    }

                    val file: FileStat? = if (index > 0 && index < torr.file_stats?.size!!) torr.file_stats?.get(index) else if (index == 0) TorrentHelper.getPlayableFiles(torr)[index] else null
                    val themedContext = ContextThemeWrapper(this.context, ThemeUtil.selectedTheme)
                    val color1 = ColorUtils.setAlphaComponent(getColorFromAttr(themedContext, R.attr.colorBright), 200)
                    val color2 = ColorUtils.setAlphaComponent(getColorFromAttr(themedContext, R.attr.colorBright), 240)
                    val tvFileName = findViewById<TextView>(R.id.tvFileName)
                    val tvFileSize = findViewById<TextView>(R.id.tvFileSize)
                    file?.let {
                        var name = it.path
                        if (name.isNotEmpty())
                            name = File(name).name

                        tvFileName.visibility = View.VISIBLE
                        tvFileSize.visibility = View.VISIBLE

                        tvFileName.apply {
                            text = "" // name
                            append(name, color2)
                        }

                        val size = it.length
                        if (size >= 0) {
                            // spannable
                            tvFileSize.apply {
                                text = "" // txt
                                append("${getString(R.string.size)} ", color1, true)
                                append(Format.byteFmt(size), color2, true)
                            }
                        }
                    } ?: let {
                        tvFileName.visibility = View.INVISIBLE
                        tvFileSize.visibility = View.GONE
                    }

                    var buffer = ""
                    var prc = 0.0
                    if (torr.preload_size > 0 && torr.preloaded_bytes > 0) {
                        prc = torr.preloaded_bytes.toDouble() * 100.0 / torr.preload_size.toDouble()
                        if (prc < 100.0)
                            buffer = "%.1f".format(prc) + "% "
                        buffer += Format.byteFmt(torr.preloaded_bytes)
                        if (prc < 100.0)
                            buffer += "/" + Format.byteFmt(torr.preload_size)
                    }

                    if (buffer.isNotEmpty()) {
                        // spannable
                        findViewById<TextView>(R.id.tvBuffer).apply {
                            text = "" // txt
                            append("${getString(R.string.buffer)} ", color1, true)
                            append(buffer, color2, true)
                        }
                    }

                    if (torr.stat < TorrentHelper.T_STATE_WORKING) {
                        if (prc > 0 && prc < 100)
                            (activity as? PlayActivity)?.showProgress(prc.toInt())
                        else
                            (activity as? PlayActivity)?.showProgress()
                    } else
                        (activity as? PlayActivity)?.hideProgress()

                    val peers = "${torr.active_peers}/${torr.total_peers}"
                    if (peers.isNotEmpty()) {
                        // spannable
                        findViewById<TextView>(R.id.tvPeers).apply {
                            text = "" // txt
                            append("${getString(R.string.peers)} ", color1, true)
                            append(peers, color2, true)
                        }
                    }

                    val seeds = "${torr.connected_seeders}"
                    if (seeds.isNotEmpty()) {
                        // spannable
                        findViewById<TextView>(R.id.tvSeeds).apply {
                            text = "" // txt
                            append("${getString(R.string.seeds)} ", color1, true)
                            append(seeds, color2, true)
                        }
                    }

                    //val speed = Format.byteFmt(torr.download_speed) + getString(R.string.fmt_s)
                    val speed = Format.speedFmt(torr.download_speed)
                    if (speed.isNotEmpty() && torr.download_speed > 50.0) {
                        // spannable
                        findViewById<TextView>(R.id.tvSpeed).apply {
                            text = "" // txt
                            append("${getString(R.string.download_speed)} ", color1, true)
                            append(speed, color2, true)
                        }
                    }
                    // ffprobe addons
                    val tvdr = findViewById<TextView>(R.id.tvDuration)
                    torr.duration_seconds?.let { ds ->
                        if (!ds.isNaN()) {
                            val duration = Format.durFmtS(ds)
                            tvdr.apply {
                                text = "" // txt
                                append("${getString(R.string.runtime)} ", color1, true)
                                append(duration, color2, true)
                                visibility = View.VISIBLE
                            }
                        }
                    } ?: let {
                        tvdr.visibility = View.GONE
                    }
                    val tvbr = findViewById<TextView>(R.id.tvBitrate)
                    torr.bit_rate?.let { br ->
                        if (br.isNotBlank()) {
                            val bitRate = Format.speedFmt(br.toDouble() / 8)
                            tvbr.apply {
                                text = "" // txt
                                append("${getString(R.string.bit_rate)} ", color1, true)
                                append(bitRate, color2, true)
                                visibility = View.VISIBLE
                            }
                        }
                    } ?: let {
                        tvbr.visibility = View.GONE
                    }

                    view?.findViewById<TextView>(R.id.tvInfo)?.apply {
                        text = when (torr.stat_string.lowercase(Locale.getDefault())) {
                            "torrent added" -> getString(R.string.stat_string_added)
                            "torrent getting info" -> getString(R.string.stat_string_info)
                            "torrent preload" -> getString(R.string.stat_string_preload)
                            "torrent working" -> getString(R.string.stat_string_working)
                            "torrent closed" -> getString(R.string.stat_string_closed)
                            "torrent in db" -> getString(R.string.stat_string_in_db)
                            else -> torr.stat_string
                        }
                    }

                }
            }
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/main/servfinder/HostAdapter.kt
```kt
package ru.yourok.torrserve.ui.fragments.main.servfinder

import android.content.res.ColorStateList
import android.text.SpannableString
import android.text.Spanned
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.appcompat.content.res.AppCompatResources
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.shape.CornerFamily
import com.google.android.material.shape.MaterialShapeDrawable
import com.google.android.material.shape.ShapeAppearanceModel
import ru.yourok.torrserve.R
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.utils.CImageSpan
import ru.yourok.torrserve.utils.Format
import ru.yourok.torrserve.utils.SpanFormat
import ru.yourok.torrserve.utils.ThemeUtil

class HostAdapter : RecyclerView.Adapter<HostAdapter.ViewHolder>() {
    val hosts = mutableListOf<ServerIp>()

    var onClick: ((String) -> Unit)? = null

    fun insert(servIp: ServerIp) {
        try {
            if (hosts.find { it.host == servIp.host } == null) {
                hosts.add(0, servIp)
                notifyItemInserted(0)
            }
        } catch (_: Exception) {
        }
    }

    fun add(servIp: ServerIp) {
        try {
            if (hosts.find { it.host == servIp.host } == null) {
                hosts.add(servIp)
                notifyItemInserted(hosts.size - 1)
            }
        } catch (_: Exception) {
        }
    }

    fun clear() {
        try {
            hosts.clear()
            notifyDataSetChanged()
        } catch (_: Exception) {
        }
    }


    class ViewHolder(val view: View, private val adapter: HostAdapter) : RecyclerView.ViewHolder(view) {
        init {
            view.setOnClickListener {
                adapter.onClick?.invoke(adapter.hosts[adapterPosition].host)
            }
            view.setOnLongClickListener {
                val lst = Settings.getHosts().toMutableList()
                if (lst.remove(adapter.hosts[adapterPosition].host)) {
                    Settings.setHosts(lst)
                    delete(adapter, adapter.hosts[adapterPosition])
                }
                true
            }
        }
    }


    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val vi = LayoutInflater.from(parent.context).inflate(R.layout.host_item, parent, false)
        return ViewHolder(vi, this)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        // round labels model
        val radius = Format.dp2px(2.0f).toFloat()
        val shapeAppearanceModel = ShapeAppearanceModel()
            .toBuilder()
            .setAllCorners(CornerFamily.ROUNDED, radius)
            .build()
        val hostColor = ColorStateList.valueOf(ThemeUtil.getColorFromAttr(holder.view.context, R.attr.colorHost))
        val versionColor = ColorStateList.valueOf(ThemeUtil.getColorFromAttr(holder.view.context, R.attr.colorPrimary))
        val labelsTextColor = ThemeUtil.getColorFromAttr(holder.view.context, R.attr.colorSurface)
        val hostView = holder.view.findViewById<TextView>(R.id.tvHost)

        hostView.apply {
            text = if (hosts[position].host.startsWith("https", true)) { // show https badge
                val sIcon = SpannableString(" ")
                AppCompatResources.getDrawable(holder.view.context, R.drawable.ssl)?.let { icon ->
                    icon.setBounds(0, 0, icon.intrinsicWidth, icon.intrinsicHeight)
                    sIcon.setSpan(CImageSpan(icon), 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                }
                SpanFormat.format("${hosts[position].host.removePrefix("https://")}  %s", sIcon)
            } else hosts[position].host.removePrefix("http://")
            val shapeDrawable = MaterialShapeDrawable(shapeAppearanceModel)
            shapeDrawable.fillColor = hostColor.withAlpha(10)
            shapeDrawable.setStroke(2.0f, hostColor.withAlpha(240))
            background = shapeDrawable
            setTextColor(hostColor)
        }

        val version = hosts[position].version
        val onlineView = holder.view.findViewById<TextView>(R.id.tvOnline)
        val onlineColor = AppCompatResources.getColorStateList(holder.view.context, R.color.green)
        // set online and dim by added version
        if (version.isNotBlank() && (version.startsWith("1.2.") || version.startsWith("MatriX"))) {
            onlineView?.apply {
                visibility = View.VISIBLE
                hostView.alpha = 1.0f
                val shapeDrawable = MaterialShapeDrawable(shapeAppearanceModel)
                shapeDrawable.fillColor = onlineColor.withAlpha(10)
                shapeDrawable.setStroke(2.0f, onlineColor)
                background = shapeDrawable
                setTextColor(onlineColor)
                text = holder.view.context.getString(R.string.online).lowercase()
            }
        } else {
            onlineView?.visibility = View.INVISIBLE
            hostView.alpha = 0.6f
        }
        val status = hosts[position].status
        holder.view.findViewById<TextView>(R.id.tvStatus).apply {
            if (status.isNotBlank()) {
                text = status
            } else {
                visibility = View.GONE
            }
        }

        holder.view.findViewById<TextView>(R.id.tvVersion).apply {
            if (version.isNotBlank()) {
                text = version
                val shapeDrawable = MaterialShapeDrawable(shapeAppearanceModel)
                shapeDrawable.fillColor = versionColor.withAlpha(160)
                shapeDrawable.setStroke(2.0f, versionColor.withAlpha(100))
                background = shapeDrawable
                setTextColor(labelsTextColor)
            } else {
                visibility = View.GONE
            }
        }
    }

    override fun getItemCount() = hosts.size

    companion object {
        fun delete(hostAdapter: HostAdapter, servIp: ServerIp) {
            try {
                val pos = hostAdapter.hosts.indexOf(servIp)
                if (pos != -1) {
                    hostAdapter.hosts.removeAt(pos)
                    hostAdapter.notifyItemRemoved(pos)
                }
            } catch (_: Exception) {
            }
        }
    }

}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/main/servfinder/ServerFinderFragment.kt
```kt
package ru.yourok.torrserve.ui.fragments.main.servfinder

import android.annotation.SuppressLint
import android.net.Uri
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.LinearLayout
import android.widget.TextView
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.textfield.TextInputEditText
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.ext.popBackStackFragment
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.local.ServerFile
import ru.yourok.torrserve.server.local.TorrService
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.ui.fragments.TSFragment
import ru.yourok.torrserve.utils.Accessibility
import ru.yourok.torrserve.utils.Net.isValidPublicIp4
import java.net.Inet4Address
import java.net.InterfaceAddress
import java.net.NetworkInterface
import java.util.Enumeration


class ServerFinderFragment : TSFragment() {

    private val hostAdapter = HostAdapter()
    private var ips = ""

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val vi = inflater.inflate(R.layout.server_finder_fragment, container, false)

        vi.findViewById<RecyclerView>(R.id.rvHosts)?.apply {
            setHasFixedSize(true)
            layoutManager = LinearLayoutManager(context)
            adapter = hostAdapter
            addItemDecoration(DividerItemDecoration(context, LinearLayout.VERTICAL))
        }

        hostAdapter.onClick = {
            vi.findViewById<TextInputEditText>(R.id.etHost)?.setText(it)
        }

        vi.findViewById<Button>(R.id.btnFindHosts)?.setOnClickListener {
            lifecycleScope.launch(Dispatchers.Default) {
                update()
            }
        }

        vi.findViewById<Button>(R.id.btnCancel)?.setOnClickListener {
            popBackStackFragment()
        }

        vi.findViewById<Button>(R.id.btnApply)?.setOnClickListener {
            setHost()
        }

        vi.findViewById<TextInputEditText>(R.id.etHost)?.setText(Settings.getHost().removePrefix("http://"))
        return vi
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        lifecycleScope.launch(Dispatchers.Default) {
            update()
        }
    }

    override fun onStop() {
        lifecycleScope.launch(Dispatchers.Main) {
            hideProgress()
        }
        super.onStop()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        lifecycleScope.launch {
            onResult?.invoke(null)
        }
    }

    private fun setHost() {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                var host = view?.findViewById<TextInputEditText>(R.id.etHost)?.text?.toString() ?: return@launch
                var uri = Uri.parse(host)
                // Don't allow current local IP as server address
                uri.host?.let { hst ->
                    val lst = ips.split(",").map { ip -> ip.trim() }
                    if (lst.contains(hst)) {
                        App.toast(R.string.not_support_local_ip, true)
                        return@launch
                    }
                }

                if (uri.scheme == null || !uri.scheme!!.contains("http", true))
                    host = "http://$host"

                uri = Uri.parse(host) // no port, set default
                if (uri.port == -1)
                    host += ":8090"

                val oldHost = Settings.getHost()
                Settings.setHost(host)
                if (Api.echo().startsWith("1.1.")) {
                    App.toast(R.string.not_support_old_server, true)
                    if (!TorrService.isLocal()) {
                        Settings.setHost(oldHost)
                        return@launch
                    }
                }

                if (ServerFile().exists() && TorrService.isLocal())
                    TorrService.start()
                else { // unload local service in case switch to remote
                    if (Api.echo().isNotEmpty() && Accessibility.isEnabledService(App.context))
                        Accessibility.enableService(App.context, false)
                    TorrService.stop()
                    ServerFile().stop() // killall 4 sure
                }

                val lst = Settings.getHosts().toMutableList()
                lst.add(host)
                Settings.setHosts(lst)
                popBackStackFragment()
            } catch (e: Exception) {
                e.message?.let {
                    App.toast(it)
                }
            }
        }
    }

    @SuppressLint("FragmentLiveDataObserve")
    private suspend fun update() = withContext(Dispatchers.Main) {
        view?.let {
            showProgress()
            ips = withContext(Dispatchers.IO) { getLocalIP() }

            val btnFind = view?.findViewById<Button>(R.id.btnFindHosts)

            btnFind?.isEnabled = false
            view?.findViewById<TextView>(R.id.tvCurrentIP)?.text = ips
            hostAdapter.clear()
            // add local
            val localhost = "http://localhost:8090"
            var status = App.context.getString(R.string.local_server)
            if (TorrService.isLocal())
                status += " ¬∑ ${App.context.getString(R.string.connected_host)}"
            val localVersion: String = withContext(Dispatchers.IO) {
                Api.remoteEcho(localhost) // .also {
//                    if (it.isNotEmpty()) {
//                        status += " ¬∑ ${App.context.getString(R.string.online)}"
//                    }
//                }
            }
            hostAdapter.add(ServerIp(localhost, localVersion, status))
            // add saved
            Settings.getHosts().forEach { host ->
                status = App.context.getString(R.string.saved_server)
                if (host == Settings.getHost())
                    status = App.context.getString(R.string.connected_host)
                val remoteVersion: String = withContext(Dispatchers.IO) {
                    Api.remoteEcho(host) // .also {
//                        if (it.isNotEmpty()) {
//                            status += " ¬∑ ${App.context.getString(R.string.online)}"
//                        }
//                    }
                }
                hostAdapter.add(ServerIp(host, remoteVersion, status))
            }
            // find on local network
            viewModel = ViewModelProvider(this@ServerFinderFragment)[ServerFinderViewModel::class.java]
            // java.lang.IllegalStateException: Can't access the Fragment View's LifecycleOwner when getView() is null
            // i.e., before onCreateView() or after onDestroyView()
            (viewModel as ServerFinderViewModel).getStats().observe(this@ServerFinderFragment) {
                btnFind?.text = it
            }
            (viewModel as ServerFinderViewModel).getServers().observe(this@ServerFinderFragment) {
                hostAdapter.add(it)
            }
            (viewModel as ServerFinderViewModel).getOnFinish().observe(this@ServerFinderFragment) {
                if (it) {
                    btnFind?.text = App.context.getString(R.string.find_hosts)
                    btnFind?.isEnabled = true
                    lifecycleScope.launch {
                        this@ServerFinderFragment.hideProgress()
                    }
                }
            }

            (viewModel as ServerFinderViewModel).find()
        }
    }

    private fun getLocalIP(): String {
        val interfaces: Enumeration<NetworkInterface> = NetworkInterface.getNetworkInterfaces()
        val ret = mutableListOf<InterfaceAddress>()
        while (interfaces.hasMoreElements()) {
            val networkInterface: NetworkInterface = interfaces.nextElement()
            if (networkInterface.isLoopback) // skip loopback
                continue
            if (networkInterface.isPointToPoint) // skip ptp / vpn
                continue
            for (interfaceAddress in networkInterface.interfaceAddresses) {
                val ip = interfaceAddress.address
                if (ip is Inet4Address && !isValidPublicIp4(ip.hostAddress)) {
                    ret.add(interfaceAddress)
                }
            }
        }

        return ret.joinToString(", ") { it.address.hostAddress ?: "" }
    }

}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/main/servfinder/ServerFinderViewModel.kt
```kt
package ru.yourok.torrserve.ui.fragments.main.servfinder

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.utils.Net.isValidPublicIp4
import java.net.*
import java.util.*

data class ServerIp(val host: String, val version: String, val status: String) {
    override fun equals(other: Any?): Boolean {
        if (other == null)
            return false
        return (other as ServerIp).host == host
    }
}

class ServerFinderViewModel : ViewModel() {
    private var isWork = Any()
    private var stats: MutableLiveData<String>? = null
    private var servers: MutableLiveData<ServerIp>? = null
    private var onFinish: MutableLiveData<Boolean>? = null

    fun getStats(): LiveData<String> {
        if (stats == null)
            stats = MutableLiveData()
        return stats!!
    }

    fun getServers(): MutableLiveData<ServerIp> {
        if (servers == null)
            servers = MutableLiveData()
        return servers!!
    }

    fun getOnFinish(): MutableLiveData<Boolean> {
        if (onFinish == null)
            onFinish = MutableLiveData()
        return onFinish!!
    }

    fun find() {
        update()
    }

    override fun onCleared() {
        isWork = false
        super.onCleared()
    }

    private fun update() {
        viewModelScope.launch(Dispatchers.IO) {
            synchronized(isWork) {
                if (isWork == true)
                    return@launch
            }
            isWork = true
            withContext(Dispatchers.Main) {
                onFinish?.value = false
            }
            try {
                val ifaces = getIFaces()
                ifaces.forEach { iface ->
                    val ipbytes = iface.address?.hostAddress?.split(".")
                    var ipRange = ""
                    if (ipbytes?.size == 4)
                        ipRange = "${ipbytes[0]}.${ipbytes[1]}.${ipbytes[2]}."
                    if (ipRange.isEmpty())
                        return@forEach
                    iface.address?.hostAddress?.let { findIn(ipRange, it) }
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
            isWork = false
            withContext(Dispatchers.Main) {
                onFinish?.value = true
            }
        }
    }

    private suspend fun findIn(ipRange: String, local: String) {
        if (isWork != true)
            return
        for (i in 1..254) {
            if (isWork == true) {
                val checkHost = "http://$ipRange$i:8090"

                if ("$ipRange$i" == local)
                    continue
                withContext(Dispatchers.Main) {
                    stats?.value = checkHost.removePrefix("http://")
                }
                viewModelScope.launch(Dispatchers.IO) {
                    val version = Api.remoteEcho(checkHost)
                    var status = if (!Settings.getHosts().contains(checkHost))
                            App.context.getString(R.string.new_server)
                        else ""
                    if (version.isNotEmpty() && (version.startsWith("1.2.") || version.startsWith("MatriX"))) {
//                        status += " ¬∑ ${App.context.getString(R.string.online)}"
                        withContext(Dispatchers.Main) {
                            servers?.value = ServerIp(checkHost, version, status)
                        }
                    }
                }
            }
        }
    }

    private fun getIFaces(): List<InterfaceAddress> {
        val interfaces: Enumeration<NetworkInterface> = NetworkInterface.getNetworkInterfaces()
        val ret = mutableListOf<InterfaceAddress>()
        while (interfaces.hasMoreElements()) {
            val networkInterface: NetworkInterface = interfaces.nextElement()
            if (networkInterface.isLoopback) // skip loopbask
                continue
            if (networkInterface.isPointToPoint) // skip ptp / vpn
                continue
            for (interfaceAddress in networkInterface.interfaceAddresses) {
                val ip = interfaceAddress.address
                if (ip is Inet4Address && !isValidPublicIp4(ip.hostAddress)) {
                    ret.add(interfaceAddress)
                }
            }
        }
        return ret
    }

}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/main/settings/SettingsFragment.kt
```kt
package ru.yourok.torrserve.ui.fragments.main.settings

import android.annotation.SuppressLint
import android.content.Context
import android.content.Context.POWER_SERVICE
import android.content.Intent
import android.os.Build
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.os.PowerManager
import android.util.Log
import android.view.View
import android.widget.TextView
import androidx.core.content.ContextCompat
import androidx.core.net.toUri
import androidx.fragment.app.FragmentActivity
import androidx.lifecycle.lifecycleScope
import androidx.preference.EditTextPreference
import androidx.preference.ListPreference
import androidx.preference.Preference
import androidx.preference.PreferenceFragmentCompat
import androidx.preference.PreferenceGroup
import androidx.preference.PreferenceGroupAdapter
import androidx.preference.PreferenceScreen
import androidx.preference.PreferenceViewHolder
import androidx.preference.SwitchPreferenceCompat
import androidx.recyclerview.widget.RecyclerView
import com.topjohnwu.superuser.Shell
import kotlinx.coroutines.Deferred
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.R
import ru.yourok.torrserve.ad.ADManager
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.atv.Utils
import ru.yourok.torrserve.ext.commitFragment
import ru.yourok.torrserve.ext.getLastFragment
import ru.yourok.torrserve.server.local.ServerFile
import ru.yourok.torrserve.server.local.TorrService
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.ui.activities.play.players.Players
import ru.yourok.torrserve.ui.fragments.LogFragment
import ru.yourok.torrserve.ui.fragments.main.servfinder.ServerFinderFragment
import ru.yourok.torrserve.ui.fragments.main.servsets.ServerSettingsFragment
import ru.yourok.torrserve.ui.fragments.main.update.apk.ApkUpdateFragment
import ru.yourok.torrserve.ui.fragments.main.update.apk.UpdaterApk
import ru.yourok.torrserve.ui.fragments.speedtest.SpeedTest
import ru.yourok.torrserve.utils.Accessibility
import ru.yourok.torrserve.utils.Format.dp2px
import ru.yourok.torrserve.utils.ThemeUtil
import ru.yourok.torrserve.utils.ThemeUtil.Companion.isDarkMode


class SettingsFragment : PreferenceFragmentCompat() {
    // https://stackoverflow.com/questions/27750901/how-to-manage-dividers-in-a-preferencefragment/55981453#55981453
    override fun onCreateAdapter(preferenceScreen: PreferenceScreen): RecyclerView.Adapter<*> {
        return CustomPreferenceAdapter(preferenceScreen)
    }

    @SuppressLint("RestrictedApi")
    internal class CustomPreferenceAdapter @SuppressLint("RestrictedApi")
    constructor(preferenceGroup: PreferenceGroup) : PreferenceGroupAdapter(preferenceGroup) {
        override fun onBindViewHolder(holder: PreferenceViewHolder, position: Int) {
            super.onBindViewHolder(holder, position)
            val currentPreference = getItem(position)
            if (currentPreference is Preference) {
                holder.itemView.background = ContextCompat.getDrawable(App.context, R.drawable.action_selector)
                holder.itemView.findViewById<TextView>(android.R.id.title)?.apply {
                    isSingleLine = false
                    maxLines = 2
                }
                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) {
                    holder.itemView.setPadding(dp2px(16f), 0, dp2px(16f), 0)
                }
            }
        }
    }

    fun show(activity: FragmentActivity, id: Int) {
        if (activity.getLastFragment()?.javaClass?.name == this.javaClass.name)
            return
        activity.commitFragment {
            replace(id, this@SettingsFragment)
            addToBackStack("Settings")
        }
    }

    // PreferenceFragment class
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val rv = listView // This holds the PreferenceScreen's items

        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) {
            rv?.setPadding(0, dp2px(32f), 0, dp2px(16f)) // (left, top, right, bottom)
        } else
            rv?.setPadding(0, 0, 0, dp2px(28f)) // (left, top, right, bottom)
    }

    override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
        setPreferencesFromResource(R.xml.preferences, rootKey)
        val ps = findPreference<PreferenceScreen>("prefs")

        val bannerPref = findPreference<Preference>("show_banner")
        lifecycleScope.launch(Dispatchers.IO) {
            if (ADManager.expired())
                bannerPref?.let { ps?.removePreference(it) }
        }

        findPreference<Preference>("host")?.apply {
            setOnPreferenceClickListener {
                ServerFinderFragment().show(requireActivity(), R.id.container, true)
                true
            }
        }

        findPreference<Preference>("speedtest")?.apply {
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP)
                isEnabled = false
            else
                setOnPreferenceClickListener {
                    SpeedTest().show(requireActivity(), R.id.container, true)
                    true
                }
        }

        findPreference<Preference>("server_settings")?.setOnPreferenceClickListener {
            ServerSettingsFragment().show(requireActivity(), R.id.container, true)
            true
        }

        findPreference<Preference>("remove_action")?.setOnPreferenceClickListener {
            Settings.setChooserAction(0)
            App.toast(R.string.reset_def)
            true
        }

        findPreference<ListPreference>(getString(R.string.player_pref_key))?.apply {
            val pList = Players.getList()
            val player = Settings.getPlayer()
            this.entryValues = pList.map { it.first }.toTypedArray()
            this.entries = pList.map { it.second }.toTypedArray()
            this.value = player
            this.summary = pList.find { it.first == player }?.second ?: player
            setOnPreferenceChangeListener { _, newValue ->
                Settings.setPlayer(newValue.toString())
                this.summary = (pList.find { it.first == newValue }?.second ?: newValue).toString()
                true
            }
        }

        findPreference<SwitchPreferenceCompat>("show_fab")?.apply {
            setOnPreferenceClickListener {
                requireActivity().recreate()
                true
            }
        }

        findPreference<SwitchPreferenceCompat>("show_sort_fab")?.apply {
            setOnPreferenceClickListener {
                requireActivity().recreate()
                true
            }
        }

        findPreference<SwitchPreferenceCompat>("show_cat_fab")?.apply {
            setOnPreferenceClickListener {
                requireActivity().recreate()
                true
            }
        }

        findPreference<ListPreference>("app_theme")?.apply {
            val darkMode = if (isDarkMode(this.context)) "NM" else "DM"
            summary = "$summary (${darkMode})"
            setOnPreferenceChangeListener { _, newValue ->
                Settings.setTheme(newValue.toString())
                ThemeUtil.setNightMode()
                requireActivity().recreate()
                true
            }
        }

        findPreference<Preference>("show_battery_save")?.apply {
            // https://developer.android.com/training/monitoring-device-state/doze-standby#support_for_other_use_cases
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                val powerManager = context.getSystemService(POWER_SERVICE) as PowerManager
                val pkgIgnored = powerManager.isIgnoringBatteryOptimizations(context.packageName)
                var intent = Intent(android.provider.Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS)
                if (!pkgIgnored) {
                    intent = Intent(android.provider.Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS)
                    intent.data = "package:${context.packageName}".toUri()
                }
                val cmp = intent.resolveActivity(requireActivity().packageManager)
                if (cmp == null)
                    ps?.removePreference(this)
                else {
                    setOnPreferenceClickListener {
                        //showPowerRequest(context)
                        try {
                            if (Utils.isAndroidTV) { // open Power Settings
                                if (Accessibility.isPackageInstalled(context, "com.android.settings")) {
                                    intent.`package` = "com.android.settings"
                                    requireActivity().startActivity(intent)
                                } else { // show TV Settings and info toast
                                    App.toast(R.string.show_battery_save_tv, true)
                                    Handler(Looper.getMainLooper()).postDelayed({
                                        intent = Intent(android.provider.Settings.ACTION_SETTINGS)
                                        requireActivity().startActivity(intent)
                                    }, App.LONG_TOAST_DURATION.toLong()) // as in toast duration

                                }
                            } else { // mobile - show request dialog / power prefs
                                requireActivity().startActivity(intent)
                            }
                        } catch (_: Exception) {
                        }
                        true
                    }
                }
            } else {
                ps?.removePreference(this)
            }
        }

        findPreference<SwitchPreferenceCompat>("switch_accessibility")?.apply {
            setOnPreferenceClickListener {
                val enable = Accessibility.isEnabledService(App.context)
                Accessibility.enableService(App.context, !enable)
                this.isChecked = Accessibility.isEnabledService(App.context)
                if (this.isChecked)
                    findPreference<SwitchPreferenceCompat>("boot_start")?.isChecked = true
                true
            }
        }

        findPreference<Preference>("version")?.apply {
            this.summary = BuildConfig.VERSION_NAME
            setOnPreferenceClickListener {
                lifecycleScope.launch(Dispatchers.IO) {
                    if (UpdaterApk.check())
                        withContext(Dispatchers.Main) {
                            ApkUpdateFragment().show(requireActivity(), R.id.container, true)
                        }
                    else {
                        withContext(Dispatchers.Main) {
                            App.toast(R.string.not_found_new_app_update, true)
                        }
                    }
                }
                true
            }
            // Set up long click by finding the preference's view
            setOnPreferenceChangeListener { _, _ -> false } // Needed to make sure the view is created
            // Long click action
            // Wait for the view to be created
            view?.setOnLongClickListener {
                // Your long click action here

                true
            }
        }

        findPreference<Preference>("showlog")?.apply {
            setOnPreferenceClickListener {
                lifecycleScope.launch(Dispatchers.Main) {
                    LogFragment().show(requireActivity(), R.id.container, true)
                }
                true
            }
        }

        findPreference<EditTextPreference>("server_auth")?.apply {
            setOnPreferenceChangeListener { _, newValue ->
                if (BuildConfig.DEBUG) Log.d("*****", "OnPreferenceChange(\"server_auth\"), new value \"$newValue\"")
                if (TorrService.isLocal()) {
                    runBlocking {
                        val sfl = ServerFile()
                        val std: Deferred<Unit> = async(Dispatchers.Default) {
                            sfl.stop()
                        }
                        std.await()
                        delay(1000)
                        sfl.run(newValue as String)
                    }
                }
                true
            }
        }
        // hide FAB prefs on TVs (no FAB in landscape) and on old APIs (fab focus buggy for now)
        val fabPref = findPreference<Preference>("show_fab")
        val sortFabPref = findPreference<Preference>("show_sort_fab")
        val catFabPref = findPreference<Preference>("show_cat_fab")
        if (Utils.isTvBox()) {
            fabPref?.let { ps?.removePreference(it) }
            sortFabPref?.let { ps?.removePreference(it) }
            catFabPref?.let { ps?.removePreference(it) }
        }
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) { // TODO Fix FAB focus
            fabPref?.let { ps?.removePreference(it) }
        }
    }

    override fun onResume() {
        super.onResume()

        findPreference<Preference>("host")?.apply {
            summary = Settings.getHost()
        }

        // Handle showlog preference
        val showLogPref = TorrService.isLocal()
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            findPreference<Preference>("showlog")?.let { logPreference ->
                // Modern API (23+) - use isVisible property
                logPreference.isVisible = showLogPref
                // Add action
                logPreference.setOnPreferenceClickListener {
                    lifecycleScope.launch(Dispatchers.Main) {
                        LogFragment().show(requireActivity(), R.id.container, true)
                    }
                    true
                }
            }
        } else {
            // Legacy API - properly handle preference hierarchy
            val parent = preferenceScreen.findPreference<PreferenceScreen>("prefs")
                ?: preferenceScreen
            val logPreference = parent.findPreference<Preference>("showlog")
            if (showLogPref) {
                // Only add if not already present
                if (logPreference == null) {
                    // Create the showlog preference programmatically
                    val newLogPref = Preference(requireContext()).apply {
                        key = "showlog"
                        title = getString(R.string.torrserver_log)
                        summary = getString(R.string.torrserver_log_summary)
                        // Add action
                        setOnPreferenceClickListener {
                            lifecycleScope.launch(Dispatchers.Main) {
                                LogFragment().show(requireActivity(), R.id.container, true)
                            }
                            true
                        }
                    }
                    parent.addPreference(newLogPref)
                    // Reorder to ensure correct position
                    val serverSettingsIndex = parent?.findPreference<Preference>("server_settings")?.order ?: 0
                    newLogPref.order = serverSettingsIndex + 1
                }
            } else {
                // Only remove if currently present
                if (logPreference != null) {
                    parent.removePreference(logPreference)
                }
            }
        }

        findPreference<SwitchPreferenceCompat>("root_start")?.apply {
            val isRootAvail = Shell.rootAccess()
            this.isEnabled = isRootAvail
            if (!isRootAvail) {
                this.isChecked = false
            }
        }

        findPreference<SwitchPreferenceCompat>("switch_accessibility")?.apply {
            this.isChecked = Accessibility.isEnabledService(App.context)
            if (this.isChecked)
                findPreference<SwitchPreferenceCompat>("boot_start")?.isChecked = true
        }
    }

    fun showPowerRequest(context: Context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            val pm = context.getSystemService(POWER_SERVICE) as PowerManager
            val isIgnoringBatteryOptimizations = pm.isIgnoringBatteryOptimizations(
                context.packageName
            )
            if (!isIgnoringBatteryOptimizations) {
                val intent = Intent()
                intent.action = android.provider.Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS
                intent.data = "package:${context.packageName}".toUri()
                try {
                    startActivity(intent)
                } catch (_: Exception) {
                }
            }
        }
    }

}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/main/torrents/TorrentsAdapter.kt
```kt
package ru.yourok.torrserve.ui.fragments.main.torrents


import android.graphics.drawable.Drawable
import android.text.SpannableString
import android.text.Spanned
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseAdapter
import android.widget.ImageView
import android.widget.TextView
import androidx.appcompat.content.res.AppCompatResources
import androidx.fragment.app.FragmentActivity
import com.bumptech.glide.Glide
import com.bumptech.glide.load.resource.bitmap.BitmapTransitionOptions
import com.bumptech.glide.load.resource.bitmap.RoundedCorners
import com.bumptech.glide.request.RequestOptions
import ru.yourok.torrserve.R
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.utils.CImageSpan
import ru.yourok.torrserve.utils.Format
import ru.yourok.torrserve.utils.SpanFormat
import java.util.Locale


class TorrentsAdapter(private val activity: FragmentActivity) : BaseAdapter() {
    val list = mutableListOf<Torrent>()

    fun update(list: List<Torrent>) {
        if (this.list.size != list.size) {
            this.list.clear()
            this.list.addAll(list)
            notifyDataSetChanged()
        } else {
            var changed = false
            for (i in list.indices) {
                if (this.list[i] != list[i]) {
                    this.list[i] = list[i]
                    changed = true
                }
            }
            if (changed)
                notifyDataSetChanged()
        }
    }

    override fun getView(position: Int, view: View?, parent: ViewGroup?): View {
        val vi = view ?: LayoutInflater.from(parent?.context).inflate(R.layout.torrent_item, parent, false)

        val category = list[position].category ?: ""
        var title = list[position].title
        val poster = list[position].poster
        val hash = list[position].hash
        val size = list[position].torrent_size
        val addTime = list[position].timestamp
        var addStr = ""

        if (addTime > 0)
            addStr = Format.sDateFmt(addTime)

        if (title.isBlank())
            title = list[position].name

        vi.findViewById<ImageView>(R.id.ivPoster)?.visibility = View.GONE
        if (!poster.isNullOrBlank() && Settings.showCover())
            vi.findViewById<ImageView>(R.id.ivPoster)?.let {
                it.visibility = View.VISIBLE
                Glide.with(activity)
                    .asBitmap()
                    .load(poster)
                    .centerCrop()
                    //.placeholder(ColorDrawable(0x3c000000))
                    .apply(RequestOptions.bitmapTransform(RoundedCorners(5)))
                    .transition(BitmapTransitionOptions.withCrossFade())
                    .into(it)
            }

        if (category.isNotBlank()) {
            val sIcon = SpannableString(" ")
            val cDrawable: Drawable? = when {
                category.contains("movie", true) -> AppCompatResources.getDrawable(vi.context, R.drawable.round_movie_24)
                category.contains("tv", true) -> AppCompatResources.getDrawable(vi.context, R.drawable.round_live_tv_24)
                category.contains("music", true) -> AppCompatResources.getDrawable(vi.context, R.drawable.round_music_note_24)
                category.contains("other", true) -> AppCompatResources.getDrawable(vi.context, R.drawable.round_more_horiz_24)
                else -> null
            }
            if (cDrawable == null)
                vi.findViewById<TextView>(R.id.tvTorrName)?.text = "${category.uppercase()} ‚óè $title"
            else {
                cDrawable.setBounds(0, 0, cDrawable.intrinsicWidth, cDrawable.intrinsicHeight)
                val span = CImageSpan(cDrawable)
                sIcon.setSpan(span, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                vi.findViewById<TextView>(R.id.tvTorrName)?.text = SpanFormat.format("%s $title", sIcon)
            }
        } else
            vi.findViewById<TextView>(R.id.tvTorrName)?.text = title

        vi.findViewById<TextView>(R.id.tvTorrHash)?.text = hash.uppercase(Locale.getDefault())
        val td = vi.findViewById<TextView>(R.id.tvTorrDate)
        val ts = vi.findViewById<TextView>(R.id.tvTorrSize)
        if (addStr.isNotEmpty()) {
            td?.text = addStr
            td?.visibility = View.VISIBLE
        } else
            td?.visibility = View.GONE

        if (size > 0.0) {
            ts?.text = Format.byteFmt(size)
            ts?.visibility = View.VISIBLE
        } else
            ts?.visibility = View.GONE

        return vi
    }

    override fun getItem(p0: Int): Any? {
        if (p0 < 0 || p0 >= list.size)
            return null
        return list[p0]
    }

    override fun getItemId(p0: Int): Long {
        return p0.toLong()
    }

    override fun getCount(): Int = list.size
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/main/torrents/TorrentsViewModel.kt
```kt
package ru.yourok.torrserve.ui.fragments.main.torrents

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.models.torrent.Torrent

class TorrentsViewModel : ViewModel() {
    private var isWork = Any()
    var data: MutableLiveData<List<Torrent>>? = null

    fun getData(): LiveData<List<Torrent>> {
        if (data == null) {
            data = MutableLiveData()
            update()
        }
        return data!!
    }

    override fun onCleared() {
        isWork = false
        super.onCleared()
    }

    private fun update() {
        viewModelScope.launch(Dispatchers.IO) {
            synchronized(isWork) {
                if (isWork == true)
                    return@launch
            }
            isWork = true
            while (isWork == true) {
                try {
                    val list = Api.listTorrent()
                    val oldList = data?.value
                    if (oldList == null || list != oldList)
                        withContext(Dispatchers.Main) { data?.value = list }
                    delay(1000)
                } catch (e: Exception) {
                    delay(2000)
                    withContext(Dispatchers.Main) { data?.value = emptyList() }
                }
            }
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/main/torrents/TorrentsFragment.kt
```kt
package ru.yourok.torrserve.ui.fragments.main.torrents

import android.annotation.SuppressLint
import android.content.Intent
import android.os.Bundle
import android.view.KeyEvent
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ListView
import android.widget.TextView
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.atv.Utils
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.ui.activities.play.PlayActivity
import ru.yourok.torrserve.ui.fragments.TSFragment
import ru.yourok.torrserve.utils.TorrentHelper


class TorrentsFragment : TSFragment() {

    private var torrentAdapter: TorrentsAdapter? = null
    private lateinit var emptyView: TextView
    private var sortMode: Boolean = Settings.sortTorrByTitle

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val vi = inflater.inflate(R.layout.main_fragment, container, false)
        torrentAdapter = TorrentsAdapter(requireActivity())
        emptyView = vi.findViewById(R.id.empty_view)
        vi.findViewById<ListView>(R.id.lvTorrents)?.let { lvTorrents ->
            lvTorrents.adapter = torrentAdapter
            lvTorrents.setOnItemClickListener { _, _, i, _ ->
                val torr = torrentAdapter?.getItem(i) as Torrent
                val intent = Intent(App.context, PlayActivity::class.java)
                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
                intent.action = Intent.ACTION_VIEW
                intent.putExtra("hash", torr.hash)
                intent.putExtra("title", torr.title)
                torr.category?.let { if (it.isNotBlank()) intent.putExtra("category", it) }
                intent.putExtra("poster", torr.poster)
                intent.putExtra("action", "play")
                App.context.startActivity(intent)
            }
            lvTorrents.choiceMode = ListView.CHOICE_MODE_MULTIPLE_MODAL
            lvTorrents.setMultiChoiceModeListener(TorrentsActionBar(lvTorrents))
        }
        return vi
    }

    override fun onResume() {
        super.onResume()
        lifecycleScope.launch {
            start()
        }
    }

    fun sort(mode: Boolean = sortMode) {
        val list = torrentAdapter!!.list
        if (list.size > 0) {
            when (mode) {
                false -> {
                    torrentAdapter?.update(list.sortedBy { it.title })
                    App.toast(R.string.sort_by_name)
                }

                true -> {
                    torrentAdapter?.update(list.sortedByDescending { it.timestamp })
                    App.toast(R.string.sort_by_date)
                }
            }
            sortMode = !mode
            Settings.set("sort_torrents", sortMode)
            activity?.findViewById<ListView>(R.id.lvTorrents)?.apply {
                this.setSelection(0)
                requestFocus()
            }
        }
    }

    suspend fun filter(cat: String = "") = withContext(Dispatchers.Main) {
        val data = (viewModel as TorrentsViewModel).getData()
        data.observe(this@TorrentsFragment) { list ->
            val fltList = if (cat.isNotBlank())
                list.filter { it.category?.contains(cat, true) == true }
            else
                list
            torrentAdapter?.update(fltList)
            if (fltList.isEmpty()) {
                emptyView.visibility = View.VISIBLE
            } else {
                emptyView.visibility = View.GONE
            }
        }
    }

    suspend fun start() = withContext(Dispatchers.Main) {
        viewModel = ViewModelProvider(this@TorrentsFragment)[TorrentsViewModel::class.java]
        val data = (viewModel as TorrentsViewModel).getData()
        data.observe(this@TorrentsFragment) {
            torrentAdapter?.update(it)
            if (it.isEmpty()) {
                emptyView.visibility = View.VISIBLE
            } else {
                emptyView.visibility = View.GONE
            }
        }
    }

    fun onKeyUp(keyCode: Int): Boolean {
        when (keyCode) {
            KeyEvent.KEYCODE_INFO,
            KeyEvent.KEYCODE_MENU,
            KeyEvent.KEYCODE_BUTTON_X -> {
                return true
            }
        }
        return false
    }

    @SuppressLint("NotifyDataSetChanged")
    fun onKeyDown(keyCode: Int): Boolean {
        when (keyCode) {
            KeyEvent.KEYCODE_INFO -> {
                activity?.currentFocus?.let {
                    it.findViewById<ListView>(R.id.lvTorrents)?.let { lv ->
                        val itemPosition = lv.selectedItemPosition
                        if (itemPosition in torrentAdapter!!.list.indices) {
                            torrentAdapter!!.list[itemPosition].let {
                                lifecycleScope.launch(Dispatchers.IO) {
                                    val torrent = TorrentHelper.waitFiles(it.hash) ?: let {
                                        return@launch
                                    }
                                    TorrentHelper.showFFPInfo(lv.context, "", torrent)
                                }
                            }
                        }
                    }
                }
                return true
            }

            KeyEvent.KEYCODE_MENU,
            KeyEvent.KEYCODE_BUTTON_X -> {
                sort(sortMode)
                if (Utils.isTvBox()) return true
            }

        }
        return false
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/main/torrents/TorrentsActionBar.kt
```kt
package ru.yourok.torrserve.ui.fragments.main.torrents

import android.content.ClipData
import android.content.ClipboardManager
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Build
import android.view.ActionMode
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.widget.AbsListView
import android.widget.AbsListView.MultiChoiceModeListener
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.utils.TorrentHelper
import ru.yourok.torrserve.utils.TorrentHelper.getTorrentMagnet
import kotlin.concurrent.thread


class TorrentsActionBar(private val listView: AbsListView) : MultiChoiceModeListener {

    override fun onItemCheckedStateChanged(actionMode: ActionMode, i: Int, l: Long, b: Boolean) {
        when (val selectedCount = listView.checkedItemCount) {
            0 -> actionMode.subtitle = null
            else -> actionMode.title = selectedCount.toString()
        }
    }

    override fun onCreateActionMode(actionMode: ActionMode, menu: Menu?): Boolean {
        val inflater: MenuInflater = actionMode.menuInflater
        inflater.inflate(R.menu.torrents_action_menu, menu)
        return true
    }

    override fun onPrepareActionMode(actionMode: ActionMode?, menu: Menu?): Boolean {
        return false
    }

    override fun onActionItemClicked(actionMode: ActionMode, item: MenuItem): Boolean {
        val selected = selectedItems
        when (item.itemId) {
            R.id.itemOpenWith -> {
                val magnetUris = mutableListOf<Uri>()
                selected.forEach {
                    val magnet = getTorrentMagnet(it)
                    if (magnet.isNotEmpty()) {
                        magnetUris.add(Uri.parse(magnet))
                    }
                }
                if (magnetUris.isNotEmpty()) {
                    val magnetIntent = Intent()
//                    if (magnetUris.size == 1) {
                    val uri = magnetUris.first()
                    magnetIntent.apply {
                        action = Intent.ACTION_VIEW
                        data = uri
                        addCategory(Intent.CATEGORY_DEFAULT)
                        addCategory(Intent.CATEGORY_BROWSABLE)
                    }
//                    } else {
//                        val arrayList = arrayListOf<Uri>()
//                        arrayList.addAll(magnetUris)
//                        magnetIntent.apply {
//                            action = Intent.ACTION_SEND_MULTIPLE
//                            putParcelableArrayListExtra(Intent.EXTRA_STREAM, arrayList)
//                            addCategory(Intent.CATEGORY_BROWSABLE)
//                        }
//                    }
                    val chooser = Intent.createChooser(magnetIntent, App.context.getString(R.string.open_with)).apply {
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                            val excludedComponentNames = arrayOf(ComponentName(BuildConfig.APPLICATION_ID, "${BuildConfig.APPLICATION_ID}.ui.activities.play.PlayActivity"))
                            putExtra(Intent.EXTRA_EXCLUDE_COMPONENTS, excludedComponentNames)
                        }
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    }

                    if (magnetIntent.resolveActivity(App.context.packageManager) != null) {
                        App.context.startActivity(chooser)
                    } else { // Handle the case where no activity can handle the intent
                        App.toast(R.string.error_app_not_found, true)
                    }

                }
            }

            R.id.itemShareMagnet -> {
                val msg = selected.joinToString("\n\n") { getTorrentMagnet(it) }
                if (msg.isNotEmpty()) {
                    val share = Intent().apply {
                        action = Intent.ACTION_SEND
                        type = "text/plain"
                        putExtra(Intent.EXTRA_TEXT, msg)
                    }

                    val shareIntent = Intent.createChooser(share, null)
                    shareIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    App.context.startActivity(shareIntent)
                }
            }

            R.id.itemCopyMagnet -> {
                val msg = selected.joinToString("\n\n") { getTorrentMagnet(it) }
                if (msg.isNotEmpty()) {
                    val clipboard = App.context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
                    val clip = ClipData.newPlainText("magnets", msg)
                    clipboard.setPrimaryClip(clip)
                    App.toast(App.context.getString(R.string.copy_to_clipboard))
                }
            }

            R.id.itemRemoveTorrent -> {
                thread {
                    selected.forEach {
                        try {
                            Api.remTorrent(it.hash)
                        } catch (e: Exception) {
                            e.printStackTrace()
                        }
                    }
                }
            }

            R.id.itemRemoveViewed -> {
                thread {
                    selected.forEach {
                        try {
                            Api.remViewed(it.hash)
                        } catch (e: Exception) {
                            e.printStackTrace()
                        }
                    }
                }
            }

            R.id.itemShowInfo -> {
                selected.forEach {
                    CoroutineScope(Dispatchers.IO).launch {
                        val torrent: Torrent = TorrentHelper.waitFiles(it.hash) ?: let {
                            return@launch
                        }
                        TorrentHelper.showFFPInfo(listView.context, "", torrent)
                    }
                }
            }
        }
        actionMode.finish()
        return false
    }

    override fun onDestroyActionMode(actionMode: ActionMode?) {
    }

    private val selectedItems: List<Torrent>
        get() {
            val selectedFiles: MutableList<Torrent> = ArrayList()
            val sparseBooleanArray = listView.checkedItemPositions
            for (i in 0 until sparseBooleanArray.size()) {
                if (sparseBooleanArray.valueAt(i)) {
                    val selectedItem = listView.getItemAtPosition(sparseBooleanArray.keyAt(i)) as Torrent?
                    if (selectedItem != null) {
                        selectedFiles.add(selectedItem)
                    }
                }
            }
            return selectedFiles
        }

}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/main/update/apk/ApkVersions.kt
```kt
package ru.yourok.torrserve.ui.fragments.main.update.apk

class ApkVersions : ArrayList<ApkVersion>()

data class ApkVersion(
    val desc: String,
    val link: String,
    val version: String,
    val versionInt: Int
)
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/main/update/apk/ApkUpdateFragment.kt
```kt
package ru.yourok.torrserve.ui.fragments.main.update.apk

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.TextView
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.ext.popBackStackFragment
import ru.yourok.torrserve.ui.fragments.TSFragment
import ru.yourok.torrserve.ui.fragments.main.update.server.ServerUpdateFragment

class ApkUpdateFragment : TSFragment() {

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        lifecycleScope.launch { showProgress() }
        val vi = inflater.inflate(R.layout.apk_update_fragment, container, false)
        vi.findViewById<TextView>(R.id.tvCurrentVersion)?.text = getString(R.string.current_version) + " " + BuildConfig.VERSION_NAME

        vi.findViewById<Button>(R.id.btnUpdate)?.also { btn ->
            btn.setOnClickListener {
                btn.isEnabled = false
                lifecycleScope.launch(Dispatchers.IO) {
                    UpdaterApk.installNewVersion {
                        lifecycleScope.launch(Dispatchers.Main) {
                            showProgress(it)
                        }
                    }
                    hideProgress()
                    withContext(Dispatchers.Main) {
                        btn.isEnabled = true
                    }
                }
            }
        }

        vi?.findViewById<Button>(R.id.btnCancel)?.setOnClickListener {
            ServerUpdateFragment().show(requireActivity(), R.id.container, true)
        }
        return vi
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        lifecycleScope.launch(Dispatchers.IO) {
            if (!UpdaterApk.check()) withContext(Dispatchers.Main) {
                App.toast(R.string.not_found_new_app_update, true)
                hideProgress()
                popBackStackFragment()
            }
            val newVer = UpdaterApk.getVersion()
            val overview = UpdaterApk.getOverview()
            withContext(Dispatchers.Main) {
                view.findViewById<TextView>(R.id.tvNewVersion)?.text = getString(R.string.new_version) + " ‚Äì " + newVer
                view.findViewById<TextView>(R.id.tvOverview)?.text = overview
            }
            hideProgress()
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/main/update/apk/UpdaterApk.kt
```kt
package ru.yourok.torrserve.ui.fragments.main.update.apk

import android.content.Intent
import android.net.Uri
import android.os.Environment
import android.text.Spanned
import androidx.core.content.FileProvider
import androidx.core.text.HtmlCompat
import com.google.gson.Gson
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.app.Consts
import ru.yourok.torrserve.utils.Http
import ru.yourok.torrserve.utils.Net
import java.io.File
import java.io.FileOutputStream

object UpdaterApk {
    private var versions: ApkVersions? = null
    private var newVersion: ApkVersion? = null

    fun check(): Boolean {
        try {
            val body = Net.get(Consts.UPDATE_APK_PATH)
            val gson = Gson()
            versions = gson.fromJson(body, ApkVersions::class.java)
            versions?.let {
                it.forEach { ver ->
                    if (ver.versionInt > BuildConfig.VERSION_CODE) {
                        newVersion = ver
                        return true
                    }
                }
            }
            return false
        } catch (e: Exception) {
            e.printStackTrace()
            return false
        }
    }

    fun getVersion(): String {
        if (newVersion == null)
            check()
        return newVersion?.version ?: ""
    }

    fun getOverview(): Spanned {
        var ret = ""

        versions?.forEach { ver ->
            if (ver.versionInt > BuildConfig.VERSION_CODE) {
                ret += "<font color='white'><b>${ver.version}</b></font><br/><br/>"
                ret += "<i>${ver.desc.replace("\n", "<br/>")}</i><br/><br/><br/>"
            } else {
                ret += "${ver.version}<br/><br/>"
                ret += "<i>${ver.desc.replace("\n", "<br>")}</i><br/><br/><br/>"
            }
        }
        return HtmlCompat.fromHtml(ret.trim(), HtmlCompat.FROM_HTML_MODE_LEGACY)
    }

    private val download = Any()

    private fun downloadApk(file: File, onProgress: ((prc: Int) -> Unit)?) {
        synchronized(download) {
            newVersion?.let { ver ->
                try {
                    if (file.exists())
                        file.delete()
                    val conn = Http(Uri.parse(ver.link))
                    conn.connect()
                    conn.getInputStream().use { input ->
                        FileOutputStream(file).use { fileOut ->
                            val contentLength = conn.getSize()
                            if (onProgress == null)
                                input?.copyTo(fileOut)
                            else {
                                val buffer = ByteArray(65535)
                                val length = contentLength + 1
                                var offset: Long = 0
                                while (true) {
                                    val readed = input?.read(buffer) ?: 0
                                    offset += readed
                                    val prc = (offset * 100 / length).toInt()
                                    onProgress(prc)
                                    if (readed <= 0)
                                        break
                                    fileOut.write(buffer, 0, readed)
                                }
                                fileOut.flush()
                            }
                            fileOut.flush()
                            fileOut.close()
                        }
                    }
                    conn.close()
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }
    }

    fun installNewVersion(onProgress: ((prc: Int) -> Unit)?) {
        if (newVersion == null && !check())
            return

        newVersion?.let {
            val destination = File(
                Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),
                "TorrServe.apk"
            ).apply {
                mkdirs()
                deleteOnExit()
            }
            downloadApk(destination, onProgress)
            if (destination.exists()) {
                if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.N) {
                    val uri = Uri.fromFile(destination)
                    val install = Intent(Intent.ACTION_VIEW)
                    install.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    install.setDataAndType(uri, "application/vnd.android.package-archive")
                    if (install.resolveActivity(App.context.packageManager) != null)
                        App.context.startActivity(install)
                    else
                        App.toast(R.string.error_app_not_found)
                } else {
                    val fileUri =
                        FileProvider.getUriForFile(
                            App.context,
                            BuildConfig.APPLICATION_ID + ".provider",
                            destination
                        )
                    val install = Intent(Intent.ACTION_VIEW, fileUri)
                    install.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    install.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
                    install.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                    if (install.resolveActivity(App.context.packageManager) != null)
                        App.context.startActivity(install)
                    else
                        App.toast(R.string.error_app_not_found)
                }
            } else {
                App.toast(R.string.error_retrieve_data)
            }
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/main/update/server/ServerUpdateFragment.kt
```kt
package ru.yourok.torrserve.ui.fragments.main.update.server

import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.TextView
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.server.local.ServerFile
import ru.yourok.torrserve.server.local.TorrService
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.ui.dialogs.DialogList
import ru.yourok.torrserve.ui.fragments.TSFragment
import java.io.File
import java.util.Timer
import kotlin.concurrent.timerTask

class ServerUpdateFragment : TSFragment() {

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val vi = inflater.inflate(R.layout.server_update_fragment, container, false)
        vi.findViewById<Button>(R.id.btnUpdate)?.also { btn ->
            btn.setOnClickListener {
                btn.isEnabled = false
                lifecycleScope.launch(Dispatchers.IO) {
                    showProgress()
                    try {
                        Settings.setHost("") // revert to local server
                        UpdaterServer.updateFromNet {
                            lifecycleScope.launch(Dispatchers.Main) {
                                showProgress(it)
                            }
                        }
                        delay(1000)
                        updateUI()
                        hideProgress()
                        withContext(Dispatchers.Main) {
                            btn.isEnabled = true
                        }
                    } catch (e: Exception) {
                        withContext(Dispatchers.Main) {
                            App.toast(App.context.getString(R.string.warn_error_download_server) + ": " + e.message, true)
                            btn.isEnabled = true
                        }
                        hideProgress()
                    }
                }
            }
        }

        vi.findViewById<Button>(R.id.btnUpdateDownload).setOnClickListener {
            installFromDownload()
        }

        vi.findViewById<Button>(R.id.btnDeleteServer).setOnClickListener {
            lifecycleScope.launch {
                showProgress()
                TorrService.stop()
                ServerFile().stop()
                ServerFile().delete()
                updateUI()
                hideProgress()
            }
            clickOnMenu()
        }

        vi.findViewById<Button>(R.id.btnDownloadFFProbe)?.also { btn ->
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
                btn.visibility = View.VISIBLE
                val tvInfo = vi.findViewById<TextView>(R.id.tvInfo)
                val file = File(App.context.filesDir, "ffprobe")
                tvInfo.alpha = 0.7f

                if (file.exists()) {
                    btn.setText(R.string.delete_ffprobe)
                    tvInfo.visibility = View.INVISIBLE
                } else {
                    btn.setText(R.string.install_ffprobe)
                    tvInfo.visibility = View.VISIBLE
                }

                btn.setOnClickListener {
                    btn.isEnabled = false
                    if (file.exists()) {
                        lifecycleScope.launch(Dispatchers.IO) {
                            showProgress()
                            try {
                                file.delete()
                                hideProgress()
                                withContext(Dispatchers.Main) {
                                    btn.setText(R.string.install_ffprobe)
                                    btn.isEnabled = true
                                }
                            } catch (_: Exception) {
                                hideProgress()
                            }
                        }
                        tvInfo.visibility = View.VISIBLE
                    } else {
                        lifecycleScope.launch(Dispatchers.IO) {
                            showProgress()
                            try {
                                UpdaterServer.downloadFFProbe {
                                    lifecycleScope.launch(Dispatchers.Main) {
                                        showProgress(it)
                                    }
                                }
                                delay(1000)
                                hideProgress()
                                withContext(Dispatchers.Main) {
                                    btn.setText(R.string.delete_ffprobe)
                                    btn.isEnabled = true
                                }
                            } catch (e: Exception) {
                                withContext(Dispatchers.Main) {
                                    App.toast(App.context.getString(R.string.error_download_ffprobe) + ": " + e.message, true)
                                    btn.isEnabled = true
                                }
                                hideProgress()
                            }
                        }
                        tvInfo.visibility = View.INVISIBLE
                    }
                }
            } else {
                btn.visibility = View.GONE
            }
        }

        return vi
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        Thread.sleep(500)
        updateUI()
    }

    override fun onStop() {
        lifecycleScope.launch(Dispatchers.Main) {
            hideProgress()
        }
        super.onStop()
    }

    private fun updateUI() {
        lifecycleScope.launch(Dispatchers.IO) {
            withContext(Dispatchers.Main) {
                view?.findViewById<TextView>(R.id.tvArch)?.text = UpdaterServer.getArch()
                view?.findViewById<TextView>(R.id.tvLocalVersion)?.text = UpdaterServer.getLocalVersion()
            }
            UpdaterServer.check()
            withContext(Dispatchers.Main) {
                view?.findViewById<TextView>(R.id.tvRemoteVersion)?.text = UpdaterServer.getRemoteVersion()
            }
        }
    }

    private var countClick = 0
    private var timer: Timer? = null

    private fun clickOnMenu() {
        if (timer != null)
            timer?.cancel()
        timer = Timer()
        timer?.schedule(timerTask {
            countClick = 0
        }, 3000)

        countClick++
        if (countClick > 4)
            view?.findViewById<Button>(R.id.btnUpdateDownload)?.visibility = View.VISIBLE
    }

    private fun installFromDownload() {
        val dw = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
        val files = dw.listFiles { file ->
            if (file.isFile)
                file.name.contains("TorrServer", true)
            else
                false
        }
        if (files.isNullOrEmpty()) {
            App.toast(R.string.warn_no_local_updates, true)
            return
        }

        DialogList.show(context ?: return, "", files.map { it.name }) { _: String, pos: Int ->
            lifecycleScope.launch(Dispatchers.IO) {
                val file = files[pos]
                showProgress()
                try {
                    Settings.setHost("") // revert to local server
                    UpdaterServer.updateFromFile(file.path)
                    delay(1000)
                    updateUI()
                    hideProgress()
                } catch (e: Exception) {
                    withContext(Dispatchers.Main) {
                        val msg = "Error copy server: " + (e.message ?: "unknown error")
                        val tvInfo = view?.findViewById<TextView>(R.id.tvInfo)
                        tvInfo?.text = msg
                        tvInfo?.visibility = View.VISIBLE
                        App.toast(msg)
                    }
                    hideProgress()
                }
            }
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/main/update/server/UpdaterServer.kt
```kt
package ru.yourok.torrserve.ui.fragments.main.update.server

import android.net.Uri
import android.os.Build
import androidx.annotation.RequiresApi
import com.google.gson.Gson
import kotlinx.coroutines.*
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.app.Consts
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.local.ServerFile
import ru.yourok.torrserve.server.local.TorrService
//import ru.yourok.torrserve.utils.Accessibility
import ru.yourok.torrserve.utils.Http
import ru.yourok.torrserve.utils.Net
import java.io.*
import java.util.zip.ZipEntry
import java.util.zip.ZipFile

object UpdaterServer {
    private var version: ServVersion? = null
    private var error: String = ""
    private val serverFile = ServerFile()

    suspend fun getLocalVersion(): String {
        var lv: String
        if (TorrService.isLocal()) {
            if (!serverFile.exists()) {
                lv = App.context.getString(R.string.not_installed)
            } else {
                //TorrService.start()
                withContext(Dispatchers.IO) {
                    lv = Api.echo()
                }
            }
        } else {
            lv = App.context.getString(R.string.not_used)
        }
        return lv
    }

    fun updateFromNet(onProgress: ((prc: Int) -> Unit)?) {
        val url = getLink()
        if (url.isNotBlank()) {
            val http = Http(Uri.parse(url))
            http.connect()
            if (TorrService.isLocal() && Api.echo().isNotEmpty()) {
//                if (Accessibility.isEnabledService(App.context))
//                    Accessibility.enableService(App.context, false)
                TorrService.stop()
                ServerFile().stop()
            }
            http.getInputStream().also { content ->
                content ?: throw IOException("error connect server, url: $url")

                val serverFile = ServerFile()
                val updateFile = File(App.context.filesDir, "torrserver_update")
                val contentLength = http.getSize()

                FileOutputStream(updateFile).use { fileOut ->
                    if (onProgress == null)
                        content.copyTo(fileOut)
                    else {
                        val buffer = ByteArray(65535)
                        val length = contentLength + 1
                        var offset: Long = 0
                        while (true) {
                            val readed = content.read(buffer)
                            offset += readed
                            val prc = (offset * 100 / length).toInt()
                            onProgress(prc)
                            if (readed <= 0) break
                            fileOut.write(buffer, 0, readed)
                        }
                        fileOut.flush()
                    }
                    fileOut.flush()
                    fileOut.close()
                    if (!updateFile.renameTo(serverFile)) {
                        updateFile.delete()
                        throw IOException("error write torrserver update")
                    }
                    if (!serverFile.setExecutable(true)) {
                        serverFile.delete()
                        throw IOException("error set exec permission")
                    }
                }
            }
        }
        if (TorrService.isLocal()) {
            TorrService.start()
        }
    }

    fun updateFromFile(filePath: String) {
        if (TorrService.isLocal() && Api.echo().isNotEmpty()) {
//            if (Accessibility.isEnabledService(App.context))
//                Accessibility.enableService(App.context, false)
            TorrService.stop()
            ServerFile().stop()
        }
        val file = File(filePath)
        if (file.canRead()) {
            val serverFile = ServerFile()
            serverFile.delete()
            val input = FileInputStream(file)
            val output = FileOutputStream(serverFile)
            input.copyTo(output)
            input.close()
            output.flush()
            output.close()
            if (!serverFile.setExecutable(true))
                throw IOException("error set server exec permission")
        }
        if (TorrService.isLocal()) {
            TorrService.start()
        }
    }

    @Suppress("DEPRECATION")
    fun getArch(): String {
        val arch = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)
            Build.SUPPORTED_ABIS[0]
        else
            Build.CPU_ABI

        when (arch) {
            "arm64-v8a" -> return "arm64"
            "armeabi-v7a" -> return "arm7"
            "x86_64" -> return "amd64"
            "x86" -> return "386"
        }
        return ""
    }

    fun check(): Boolean {
        return try {
            val body = Net.get(Consts.UPDATE_SERVER_PATH)
            val gson = Gson()
            version = gson.fromJson(body, ServVersion::class.java)
            true
        } catch (e: Exception) {
            error = e.message ?: App.context.getString(R.string.warn_error_check_ver)
            App.toast(error)
            false
        }
    }

    @RequiresApi(Build.VERSION_CODES.KITKAT)
    fun downloadFFProbe(onProgress: ((prc: Int) -> Unit)?) {
        val fileZip = File(App.context.filesDir, "ffprobe.zip")
        val file = File(App.context.filesDir, "ffprobe")

        if (file.exists())
            return

        val arch = getArch()
        var link = ""
        when (arch) {
            "arm7" -> link = "https://github.com/ffbinaries/ffbinaries-prebuilt/releases/download/v4.4.1/ffprobe-4.4.1-linux-armhf-32.zip"
            "arm64" -> link = "https://github.com/ffbinaries/ffbinaries-prebuilt/releases/download/v4.4.1/ffprobe-4.4.1-linux-arm-64.zip"
            "386" -> link = "https://github.com/ffbinaries/ffbinaries-prebuilt/releases/download/v4.4.1/ffprobe-4.4.1-linux-32.zip"
            "amd64" -> link = "https://github.com/ffbinaries/ffbinaries-prebuilt/releases/download/v4.4.1/ffprobe-4.4.1-linux-64.zip"
        }
        val http = Http(Uri.parse(link))
        http.connect()
        http.getInputStream().also { content ->
            content ?: let {
                fileZip.delete()
                file.delete()
                throw IOException("error connect server, url: $link")
            }

            val contentLength = http.getSize()

            FileOutputStream(fileZip).use { fileOut ->
                if (onProgress == null)
                    content.copyTo(fileOut)
                else {
                    val buffer = ByteArray(65535)
                    val length = contentLength + 1
                    var offset: Long = 0
                    while (true) {
                        val readed = content.read(buffer)
                        offset += readed
                        val prc = (offset * 100 / length).toInt()
                        onProgress(prc)
                        if (readed <= 0) break
                        fileOut.write(buffer, 0, readed)
                    }
                    fileOut.flush()
                }
                fileOut.flush()
                fileOut.close()

                fileZip.unzip(App.context.filesDir)
                fileZip.delete()
                if (!file.setExecutable(true)) {
                    file.delete()
                    throw IOException("error set exec permission")
                }
            }
        }
    }

    fun getRemoteVersion(): String {
        var rv = App.context.getString(R.string.no_updates)
        if (version == null)
            check()
        runBlocking {
            val lv: Deferred<String> = async(context = Dispatchers.IO) {
                getLocalVersion()
            }
            version?.let {
                if (it.version != lv.await())
                    rv = it.version
            }
        }
        if (version == null)
            rv = App.context.getString(R.string.no_data) // error
        return rv
    }

    private fun getLink(): String {
        if (version == null)
            check()
        if (version == null)
            return ""
        version?.let { ver ->
            val arch = getArch()
            if (arch.isEmpty())
                throw IOException("error get arch")
            return if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) ver.links["linux-$arch"] ?: ""
            else ver.links["android-$arch"] ?: ""
        }
        return ""
    }

    data class ZipIO(val entry: ZipEntry, val output: File)

    @RequiresApi(Build.VERSION_CODES.KITKAT)
    private fun File.unzip(unzipLocationRoot: File? = null) {

        val rootFolder = unzipLocationRoot ?: File(parentFile!!.absolutePath + File.separator + nameWithoutExtension)
        if (!rootFolder.isDirectory) rootFolder.mkdirs()

        ZipFile(this).use { zip ->
            zip.entries().asSequence().map {
                val outputFile = File(rootFolder.absolutePath + File.separator + it.name)
                ZipIO(it, outputFile)
            }.map {
                it.output.parentFile?.run {
                    if (!exists()) mkdirs()
                }
                it
            }.filter { !it.entry.isDirectory }.forEach { (entry, output) ->
                zip.getInputStream(entry).use { input ->
                    output.outputStream().use { output ->
                        input.copyTo(output)
                    }
                }
            }
        }

    }

//    private suspend fun <T> withZipFromUri(
//        context: Context,
//        uri: Uri, block: suspend (ZipInputStream) -> T
//    ): T =
//        withContext(Dispatchers.IO) {
//            kotlin.run {
//                context.contentResolver.openInputStream(uri).use { input ->
//                    if (input == null) throw FileNotFoundException("openInputStream failed")
//                    ZipInputStream(input).use {
//                        block.invoke(it)
//                    }
//                }
//            }
//        }

}

```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/main/update/server/ServVersions.kt
```kt
package ru.yourok.torrserve.ui.fragments.main.update.server

data class ServVersion(
    val version: String,
    val links: Map<String, String>
)
```

## ./app/src/main/java/ru/yourok/torrserve/ui/fragments/main/servsets/ServerSettingsFragment.kt
```kt
package ru.yourok.torrserve.ui.fragments.main.servsets

import android.annotation.SuppressLint
import android.content.res.Configuration
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.AutoCompleteTextView
import android.widget.Button
import android.widget.TextView
import androidx.lifecycle.lifecycleScope
import com.google.android.material.switchmaterial.SwitchMaterial
import com.google.android.material.textfield.TextInputEditText
import com.google.android.material.textfield.TextInputLayout
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.ext.popBackStackFragment
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.local.TorrService
import ru.yourok.torrserve.settings.BTSets
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.ui.dialogs.DirectoryDialog
import ru.yourok.torrserve.ui.fragments.TSFragment


class ServerSettingsFragment : TSFragment() {

    private var btsets: BTSets? = null
    private var loaded = false

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        lifecycleScope.launch {
            showProgress()
        }

        val vi = inflater.inflate(R.layout.server_settings_fragment, container, false)

        vi.findViewById<TextView>(R.id.tvServerAddr).let {
            if (resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE)
                it.visibility = View.INVISIBLE
            else {
                it.visibility = View.VISIBLE
                it.text = Settings.getHost().removePrefix("http://")
            }
        }
        vi.findViewById<Button>(R.id.btnContentPath)?.let {
            it.setOnClickListener { _ ->
                DirectoryDialog.show(context ?: return@setOnClickListener, "") { path ->
                    it.text = path
                    btsets?.TorrentsSavePath = path
                    lifecycleScope.launch {
                        updateUI()
                    }
                }
            }
            it.isEnabled = TorrService.isLocal()
        }
        // hide options for older server versions
        lifecycleScope.launch(Dispatchers.IO) {
            val ver = Api.getMatrixVersionInt()
            if (ver < 94) // MatriX.94 is 1st disk cache release
            {
                withContext(Dispatchers.Main) {
                    vi.findViewById<SwitchMaterial>(R.id.cbSaveOnDisk)?.visibility = View.GONE
                    vi.findViewById<TextView>(R.id.lbSaveOnDisk)?.visibility = View.GONE
                    vi.findViewById<SwitchMaterial>(R.id.cbRemoveCacheOnDrop)?.visibility = View.GONE
                    vi.findViewById<TextView>(R.id.lbRemoveCacheOnDrop)?.visibility = View.GONE
                    vi.findViewById<TextView>(R.id.lbContentPath)?.visibility = View.GONE
                    vi.findViewById<Button>(R.id.btnContentPath)?.visibility = View.GONE
                }
            }
            if (ver > 100) // MatriX.101 add PreloadCache
            {
                withContext(Dispatchers.Main) {
                    vi.findViewById<TextInputLayout>(R.id.lbPreloadCache)?.visibility = View.VISIBLE
                    //vi.findViewById<TextInputEditText>(R.id.etPreloadCache)?.visibility = View.VISIBLE
                    vi.findViewById<SwitchMaterial>(R.id.cbPreloadBuffer)?.visibility = View.GONE
                    vi.findViewById<TextView>(R.id.lbPreloadBuffer)?.visibility = View.GONE
                }
            }
            if (ver > 104) // MatriX.105 add DLNA / disable DhtConnectionLimit
            {
                withContext(Dispatchers.Main) {
                    vi.findViewById<TextInputLayout>(R.id.tvConnectionsDhtLimit)?.visibility = View.GONE
                    //vi.findViewById<TextInputEditText>(R.id.etConnectionsDhtLimit)?.visibility = View.GONE
                    vi.findViewById<SwitchMaterial>(R.id.cbEnableDLNA)?.visibility = View.VISIBLE
                }
            }
            if (ver > 114) // MatriX.115 add DLNA Friendly Name
            {
                withContext(Dispatchers.Main) {
                    vi.findViewById<TextInputLayout>(R.id.tvFriendlyName)?.visibility = View.VISIBLE
                    //vi.findViewById<TextInputEditText>(R.id.etFriendlyName)?.visibility = View.VISIBLE
                }
            }
            if (ver > 119) // MatriX.120 add Rutor search
            {
                withContext(Dispatchers.Main) {
                    vi.findViewById<SwitchMaterial>(R.id.cbEnableRutorSearch)?.visibility = View.VISIBLE
                    vi.findViewById<TextView>(R.id.tvEnableRutorSearch)?.visibility = View.VISIBLE
                }
            }
            if (ver > 132) // MatriX.133 add ResponsiveMode
            {
                withContext(Dispatchers.Main) {
                    vi.findViewById<SwitchMaterial>(R.id.cbResponsiveMode)?.visibility = View.VISIBLE
                }
            }
        }

        vi.findViewById<Button>(R.id.btnApply)?.setOnClickListener {
            lifecycleScope.launch(Dispatchers.IO) {
                showProgress()
                saveSettings()
                hideProgress()
                popBackStackFragment()
            }
        }

        vi.findViewById<Button>(R.id.btnCancel)?.setOnClickListener {
            popBackStackFragment()
        }

        val adpRetracker = ArrayAdapter(requireContext(), R.layout.list_item, resources.getStringArray(R.array.retracker_mode))
        vi.findViewById<AutoCompleteTextView>(R.id.actvRetracker)?.setAdapter(adpRetracker)

        vi.findViewById<Button>(R.id.btnDefaultSets)?.let {
            it.setOnClickListener {
                lifecycleScope.launch(Dispatchers.IO) {
                    try {
                        Api.defSettings()
                        withContext(Dispatchers.Main) {
                            App.toast(R.string.default_sets_applied)
                        }
                    } catch (e: Exception) {
                        withContext(Dispatchers.Main) {
                            //e.message?.let { msg -> App.Toast(msg) }
                            App.toast(R.string.error_sending_settings)
                        }
                    }
                    popBackStackFragment()
                }
            }
        }

        return vi
    }

    override fun onResume() {
        super.onResume()
        lifecycleScope.launch { load() }
    }

    override fun onStop() {
        lifecycleScope.launch(Dispatchers.Main) {
            hideProgress()
        }
        super.onStop()
    }

    private suspend fun load() = withContext(Dispatchers.Main) {
        if (!loaded) {
            showProgress()
            withContext(Dispatchers.IO) { btsets = loadSettings() }
            updateUI()
            hideProgress()
            loaded = true
        }
    }

    @SuppressLint("NewApi")
    private suspend fun updateUI() = withContext(Dispatchers.Main) {
        try {
            view?.apply {
                btsets?.let { sets ->
                    val rtm = resources.getStringArray(R.array.retracker_mode)[sets.RetrackersMode]
                    findViewById<TextInputEditText>(R.id.etCacheSize)?.setText((sets.CacheSize / (1024 * 1024)).toString())
                    findViewById<SwitchMaterial>(R.id.cbPreloadBuffer)?.isChecked = sets.PreloadBuffer
                    findViewById<TextInputEditText>(R.id.etPreloadTorrent)?.setText(sets.ReaderReadAHead.toString())
                    findViewById<TextInputEditText>(R.id.etPreloadCache)?.setText(sets.PreloadCache.toString())
                    findViewById<SwitchMaterial>(R.id.cbSaveOnDisk)?.isChecked = sets.UseDisk
                    findViewById<SwitchMaterial>(R.id.cbRemoveCacheOnDrop)?.isChecked = sets.RemoveCacheOnDrop
                    findViewById<Button>(R.id.btnContentPath)?.text = sets.TorrentsSavePath.ifBlank { getString(R.string.not_installed) }
                    findViewById<AutoCompleteTextView>(R.id.actvRetracker)?.setText(rtm, false)
                    findViewById<TextInputEditText>(R.id.etDisconnectTimeout)?.setText(sets.TorrentDisconnectTimeout.toString())
                    findViewById<SwitchMaterial>(R.id.cbForceEncrypt)?.isChecked = sets.ForceEncrypt
                    findViewById<SwitchMaterial>(R.id.cbEnableDebug)?.isChecked = sets.EnableDebug
                    findViewById<SwitchMaterial>(R.id.cbResponsiveMode)?.isChecked = sets.ResponsiveMode
                    findViewById<SwitchMaterial>(R.id.cbEnableDLNA)?.isChecked = sets.EnableDLNA
                    findViewById<TextInputEditText>(R.id.etFriendlyName)?.setText(sets.FriendlyName)
                    findViewById<SwitchMaterial>(R.id.cbEnableRutorSearch)?.isChecked = sets.EnableRutorSearch
                    findViewById<SwitchMaterial>(R.id.cbEnableIPv6)?.isChecked = sets.EnableIPv6
                    findViewById<SwitchMaterial>(R.id.cbDisableTCP)?.isChecked = !sets.DisableTCP
                    findViewById<SwitchMaterial>(R.id.cbDisableUTP)?.isChecked = !sets.DisableUTP
                    findViewById<SwitchMaterial>(R.id.cbDisableUPNP)?.isChecked = !sets.DisableUPNP
                    findViewById<SwitchMaterial>(R.id.cbDisableDHT)?.isChecked = !sets.DisableDHT
                    findViewById<SwitchMaterial>(R.id.cbDisablePEX)?.isChecked = !sets.DisablePEX
                    findViewById<SwitchMaterial>(R.id.cbDisableUpload)?.isChecked = !sets.DisableUpload
                    findViewById<TextInputEditText>(R.id.etDownloadRateLimit)?.setText(sets.DownloadRateLimit.toString())
                    findViewById<TextInputEditText>(R.id.etUploadRateLimit)?.setText(sets.UploadRateLimit.toString())
                    findViewById<TextInputEditText>(R.id.etConnectionsLimit)?.setText(sets.ConnectionsLimit.toString())
                    findViewById<TextInputEditText>(R.id.etConnectionsDhtLimit)?.setText(sets.DhtConnectionLimit.toString())
                    findViewById<TextInputEditText>(R.id.etPeersListenPort)?.setText(sets.PeersListenPort.toString())
                }
                if (BuildConfig.DEBUG)
                    findViewById<SwitchMaterial>(R.id.cbEnableDebug)?.visibility = View.VISIBLE
            }
        } catch (e: Exception) {
            e.printStackTrace()
            App.toast(R.string.error_retrieving_settings)
        }
    }

    private suspend fun saveSettings() = withContext(Dispatchers.Main) {
        try {
            view?.apply {
                val rtmode = findViewById<AutoCompleteTextView>(R.id.actvRetracker)?.text
                val values = resources.getStringArray(R.array.retracker_mode)
                val rtIndex = values.indices.find { values[it] == rtmode.toString() } // values.indexOf(rtmode.toString())
                btsets = BTSets(
                    CacheSize = (findViewById<TextInputEditText>(R.id.etCacheSize)?.text?.toString()?.toLong() ?: 96L) * 1024 * 1024,
                    PreloadBuffer = findViewById<SwitchMaterial>(R.id.cbPreloadBuffer)?.isChecked ?: false,
                    ReaderReadAHead = findViewById<TextInputEditText>(R.id.etPreloadTorrent)?.text?.toString()?.toInt() ?: 95,
                    PreloadCache = findViewById<TextInputEditText>(R.id.etPreloadCache)?.text?.toString()?.toInt() ?: 0,
                    UseDisk = findViewById<SwitchMaterial>(R.id.cbSaveOnDisk)?.isChecked ?: false,
                    RemoveCacheOnDrop = findViewById<SwitchMaterial>(R.id.cbRemoveCacheOnDrop)?.isChecked ?: false,
                    TorrentsSavePath = btsets?.TorrentsSavePath ?: "",
                    ForceEncrypt = findViewById<SwitchMaterial>(R.id.cbForceEncrypt)?.isChecked ?: false,
                    RetrackersMode = rtIndex ?: 0,
                    TorrentDisconnectTimeout = findViewById<TextInputEditText>(R.id.etDisconnectTimeout)?.text?.toString()?.toInt() ?: 30,
                    EnableDebug = findViewById<SwitchMaterial>(R.id.cbEnableDebug)?.isChecked ?: false,
                    ResponsiveMode = findViewById<SwitchMaterial>(R.id.cbResponsiveMode)?.isChecked ?: false,
                    EnableDLNA = findViewById<SwitchMaterial>(R.id.cbEnableDLNA)?.isChecked ?: false,
                    FriendlyName = findViewById<TextInputEditText>(R.id.etFriendlyName)?.text?.toString() ?: "",
                    EnableRutorSearch = findViewById<SwitchMaterial>(R.id.cbEnableRutorSearch)?.isChecked ?: false,
                    EnableIPv6 = findViewById<SwitchMaterial>(R.id.cbEnableIPv6)?.isChecked ?: false,
                    DisableTCP = findViewById<SwitchMaterial>(R.id.cbDisableTCP)?.isChecked != true,
                    DisableUTP = findViewById<SwitchMaterial>(R.id.cbDisableUTP)?.isChecked != true,
                    DisableUPNP = findViewById<SwitchMaterial>(R.id.cbDisableUPNP)?.isChecked != true,
                    DisableDHT = findViewById<SwitchMaterial>(R.id.cbDisableDHT)?.isChecked != true,
                    DisablePEX = findViewById<SwitchMaterial>(R.id.cbDisablePEX)?.isChecked != true,
                    DisableUpload = findViewById<SwitchMaterial>(R.id.cbDisableUpload)?.isChecked != true,
                    DownloadRateLimit = findViewById<TextInputEditText>(R.id.etDownloadRateLimit)?.text?.toString()?.toInt() ?: 0,
                    UploadRateLimit = findViewById<TextInputEditText>(R.id.etUploadRateLimit)?.text?.toString()?.toInt() ?: 0,
                    ConnectionsLimit = findViewById<TextInputEditText>(R.id.etConnectionsLimit)?.text?.toString()?.toInt() ?: 23,
                    DhtConnectionLimit = findViewById<TextInputEditText>(R.id.etConnectionsDhtLimit)?.text?.toString()?.toInt() ?: 500,
                    PeersListenPort = findViewById<TextInputEditText>(R.id.etPeersListenPort)?.text?.toString()?.toInt() ?: 0,
                )
                btsets?.let { sets ->
                    withContext(Dispatchers.IO) {
                        saveSettings(sets)
                        App.toast(R.string.done_sending_settings)
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
            App.toast(R.string.error_sending_settings)
        }
    }

    private fun saveSettings(sets: BTSets) {
        try {
            Api.setSettings(sets)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    private fun loadSettings(): BTSets? {
        return try {
            Api.getSettings()
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/dialogs/DirectoryAdapter.kt
```kt
package ru.yourok.torrserve.ui.dialogs

import android.os.Build
import android.os.StatFs
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.utils.Format
import java.io.File

class DirectoryAdapter : RecyclerView.Adapter<DirectoryAdapter.ViewHolder>() {
    private var path = ""
    private var list = emptyList<String>()

    var onClick: ((String) -> Unit)? = null

    fun setPath(path: String) {
        this.path = path
        update()
    }

    fun update() {
        list = File(path).listFiles()?.filter {
            it.isDirectory
        }?.map { it.name }?.toList() ?: emptyList()
        notifyDataSetChanged()
        onClick?.invoke(path)
    }

    fun getPath(): String {
        return path
    }

    @Suppress("DEPRECATION")
    fun getSize(): String {
        val size = try {
            val stat = StatFs(path)
            val bytesAvailable = if (Build.VERSION.SDK_INT >=
                Build.VERSION_CODES.JELLY_BEAN_MR2
            ) {
                stat.blockSizeLong * stat.availableBlocksLong
            } else {
                stat.blockSize.toLong() * stat.availableBlocks.toLong()
            }
            Format.byteFmt(bytesAvailable)
        } catch (_: Exception) {
            "N/A"
        }
        return size
    }

    fun dirUp() {
        val par = File(path).parentFile
        if (par == null) {
            path = "/"
            return
        }
        path = par.path
        update()
    }

    class ViewHolder(val view: View, private val adapter: DirectoryAdapter) : RecyclerView.ViewHolder(view) {
        init {
            view.setOnClickListener {
                val ff = File(adapter.path, adapter.list[adapterPosition])
                if (ff.canRead()) {
                    adapter.path = ff.path
                    adapter.update()
                } else {
                    App.toast("permission deny")
                }
            }
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val vi = LayoutInflater.from(parent.context).inflate(R.layout.directory_item, parent, false)
        return ViewHolder(vi, this)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        (holder.view as TextView).text = list[position]
    }

    override fun getItemCount() = list.size
}

```

## ./app/src/main/java/ru/yourok/torrserve/ui/dialogs/DirectoryDialog.kt
```kt
package ru.yourok.torrserve.ui.dialogs

import android.content.Context
import android.view.LayoutInflater
import android.widget.EditText
import android.widget.ImageButton
import android.widget.LinearLayout
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import ru.yourok.torrserve.R
import ru.yourok.torrserve.animations.FIO
import ru.yourok.torrserve.app.App
import java.io.File

object DirectoryDialog {

    fun show(context: Context, msg: String, onSelect: (dir: String) -> Unit) {
        val builder = AlertDialog.Builder(context)
        if (msg.isNotEmpty())
            builder.setTitle(msg)

        val directoryAdapter = DirectoryAdapter()
        val vi = LayoutInflater.from(context).inflate(R.layout.directory_chooser_fragment, null)

        vi.findViewById<RecyclerView>(R.id.rvListDir)?.apply {
            setHasFixedSize(true)
            layoutManager = LinearLayoutManager(context)
            adapter = directoryAdapter
            addItemDecoration(DividerItemDecoration(context, LinearLayout.VERTICAL))
            directoryAdapter.setPath("/sdcard/")
        }

        vi?.findViewById<TextView>(R.id.tvCurrSize)?.text = directoryAdapter.getSize()
        vi?.findViewById<TextView>(R.id.tvCurrDir)?.text = directoryAdapter.getPath()

        directoryAdapter.onClick = {
            vi?.findViewById<TextView>(R.id.tvCurrSize)?.text = directoryAdapter.getSize()
            vi?.findViewById<TextView>(R.id.tvCurrDir)?.text = directoryAdapter.getPath()
        }

        vi.findViewById<ImageButton>(R.id.btnUpDir).setOnClickListener {
            directoryAdapter.dirUp()
        }

        vi.findViewById<ImageButton>(R.id.btnCreateDir).setOnClickListener {
            val view1 = vi.findViewById<LinearLayout>(R.id.dirCtrlLayout) ?: return@setOnClickListener
            val view2 = vi.findViewById<LinearLayout>(R.id.dirNameLayout) ?: return@setOnClickListener
            FIO.anim(view1, view2, 300) {
                vi.findViewById<EditText>(R.id.etDirName)?.requestFocus()
            }
        }

        vi.findViewById<ImageButton>(R.id.btnDone).setOnClickListener {
            val view1 = vi.findViewById<LinearLayout>(R.id.dirCtrlLayout) ?: return@setOnClickListener
            val view2 = vi.findViewById<LinearLayout>(R.id.dirNameLayout) ?: return@setOnClickListener
            FIO.anim(view2, view1, 300)

            val dirName = vi.findViewById<EditText>(R.id.etDirName)?.text?.toString() ?: ""
            if (dirName.isNotBlank()) {
                val path = directoryAdapter.getPath()
                if (File(path).canWrite()) {
                    val dir = File(path, dirName)
                    if (dir.exists() || dir.mkdirs()) {
                        directoryAdapter.setPath(dir.path)
                        vi.findViewById<EditText>(R.id.etDirName)?.setText("")
                        return@setOnClickListener
                    }
                }
                App.toast(context.getString(R.string.permission_deny))
            }
        }

        builder.setView(vi)

        builder.setPositiveButton(R.string.apply) { dialog, _ ->
            val path = directoryAdapter.getPath()
            if (!File(path).canWrite())
                App.toast(context.getString(R.string.permission_deny))
            onSelect(path)
            dialog.dismiss()
        }

        builder.setNegativeButton(android.R.string.cancel) { dialog, _ ->
            dialog.dismiss()
        }

        builder.show()
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/dialogs/AppListAdapter.kt
```kt
package ru.yourok.torrserve.ui.dialogs

import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.ResolveInfo
import android.graphics.drawable.Drawable
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseAdapter
import android.widget.ImageView
import android.widget.TextView
import ru.yourok.torrserve.R
import java.util.Locale


class AppListAdapter internal constructor(context: Context, private val appsInfo: List<ResolveInfo>) : BaseAdapter() {
    private val mLayoutInflater: LayoutInflater = LayoutInflater.from(context)
    private val pm: PackageManager = context.packageManager

    override fun getCount(): Int {
        return appsInfo.size
    }

    override fun getItem(position: Int): ResolveInfo {
        return appsInfo[position]
    }

    fun getItemPackage(position: Int): String {
        return getItem(position).activityInfo.packageName.lowercase(Locale.getDefault())
    }

    private fun getItemLabel(position: Int): String {
        var loadLabel = getItem(position).loadLabel(pm)
        if (loadLabel.isNullOrEmpty()) {
            loadLabel = getItemPackage(position)
        }
        return loadLabel.toString()
    }

    private fun getItemIcon(position: Int): Drawable {
        return getItem(position).loadIcon(pm)
    }

    override fun getItemId(position: Int): Long {
        return position.toLong()
    }

    override fun getView(position: Int, cv: View?, parent: ViewGroup?): View {
        val view = cv ?: mLayoutInflater.inflate(R.layout.app_list_item, null)
        val image = view?.findViewById<ImageView>(R.id.imageViewIcon)
        val textViewMain = view?.findViewById<TextView>(R.id.textViewMain)
        val textViewSecond = view?.findViewById<TextView>(R.id.textViewSecond)
        image?.setImageDrawable(getItemIcon(position))
        textViewMain?.text = getItemLabel(position)
        textViewSecond?.text = getItemPackage(position)
        return view!!
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/dialogs/DialogList.kt
```kt
package ru.yourok.torrserve.ui.dialogs

import android.content.Context
import androidx.appcompat.app.AlertDialog

object DialogList {
    fun show(context: Context, msg: String, list: List<String>, onSelect: (value: String, select: Int) -> Unit) {
        val builder = AlertDialog.Builder(context)
        if (msg.isNotEmpty())
            builder.setTitle(msg)

        builder.setItems(list.toTypedArray()) { dlg, sel ->
            onSelect(list[sel], sel)
            dlg?.dismiss()
        }

        val dialog = builder.create()
        dialog.show()
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/dialogs/InfoDialog.kt
```kt
package ru.yourok.torrserve.ui.dialogs

import android.content.Context
import android.content.DialogInterface
import android.content.res.ColorStateList
import android.text.SpannableString
import android.text.Spanned
import android.view.LayoutInflater
import android.view.View
import android.widget.LinearLayout
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.content.res.AppCompatResources
import com.google.android.material.shape.CornerFamily
import com.google.android.material.shape.MaterialShapeDrawable
import com.google.android.material.shape.ShapeAppearanceModel
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.ui.activities.play.addTorrent
import ru.yourok.torrserve.utils.CImageSpan
import ru.yourok.torrserve.utils.Format.dp2px
import ru.yourok.torrserve.utils.SpanFormat
import ru.yourok.torrserve.utils.ThemeUtil.Companion.getColorFromAttr

class InfoDialog(private val context: Context) {
    // round labels model
    private val radius = dp2px(5.0f).toFloat()
    private val shapeAppearanceModel = ShapeAppearanceModel()
        .toBuilder()
        .setAllCorners(CornerFamily.ROUNDED, radius)
        .build()

    private val labelsColor = ColorStateList.valueOf(getColorFromAttr(this.context, R.attr.colorPrimary))
    private val labelsTextColor = getColorFromAttr(this.context, R.attr.colorSurface)

    fun show(torrLink: String, title: String, category: String, format: String, video: String, audio: String, subtitles: String, size: String, runtime: String, bitrate: String) {
        val view = (context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater)
            .inflate(R.layout.dialog_info, null) as LinearLayout? ?: return

        view.findViewById<TextView>(R.id.format)?.apply {
            if (format.isNotBlank()) {
                val sIcon = SpannableString(" ")
                val cDrawable = AppCompatResources.getDrawable(context, R.drawable.outline_format_24)
                cDrawable?.let {
                    it.setBounds(0, 0, it.intrinsicWidth, it.intrinsicHeight)
                    val span = CImageSpan(it)
                    sIcon.setSpan(span, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                }
                text = SpanFormat.format("%s $format", sIcon)
            } else
                visibility = View.GONE
        }
        view.findViewById<TextView>(R.id.video)?.apply {
            if (video.isNotBlank()) {
                val sIcon = SpannableString(" ")
                val cDrawable = AppCompatResources.getDrawable(context, R.drawable.outline_video_24)
                cDrawable?.let {
                    it.setBounds(0, 0, it.intrinsicWidth, it.intrinsicHeight)
                    val span = CImageSpan(it)
                    sIcon.setSpan(span, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                }
                text = SpanFormat.format("%s $video", sIcon)
            } else
                visibility = View.GONE
        }
        view.findViewById<TextView>(R.id.audio)?.apply {
            if (audio.isNotBlank()) {
                val sIcon = SpannableString(" ")
                val cDrawable = AppCompatResources.getDrawable(context, R.drawable.outline_audio_24)
                cDrawable?.let {
                    it.setBounds(0, 0, it.intrinsicWidth, it.intrinsicHeight)
                    val span = CImageSpan(it)
                    sIcon.setSpan(span, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                }
                text = SpanFormat.format("%s $audio", sIcon)
            } else
                visibility = View.GONE
        }
        view.findViewById<TextView>(R.id.subtitles)?.apply {
            if (subtitles.isNotBlank()) {
                val sIcon = SpannableString(" ")
                val cDrawable = AppCompatResources.getDrawable(context, R.drawable.outline_subtitles_24)
                cDrawable?.let {
                    it.setBounds(0, 0, it.intrinsicWidth, it.intrinsicHeight)
                    val span = CImageSpan(it)
                    sIcon.setSpan(span, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                }
                text = SpanFormat.format("%s $subtitles", sIcon)
            } else
                visibility = View.GONE
        }
        view.findViewById<TextView>(R.id.infoline)?.apply {
            visibility = View.GONE
        }
        view.findViewById<TextView>(R.id.tvSize)?.apply {
            if (size.isNotBlank()) {
                text = size
                val shapeDrawable = MaterialShapeDrawable(shapeAppearanceModel)
                shapeDrawable.fillColor = labelsColor.withAlpha(220)
                shapeDrawable.setStroke(2.0f, labelsColor.withAlpha(128))
                background = shapeDrawable
                setTextColor(labelsTextColor)
            } else
                visibility = View.GONE
        }
        view.findViewById<TextView>(R.id.tvRuntime)?.apply {
            if (runtime.isNotBlank()) {
                text = runtime
                val shapeDrawable = MaterialShapeDrawable(shapeAppearanceModel)
                shapeDrawable.fillColor = labelsColor.withAlpha(220)
                shapeDrawable.setStroke(2.0f, labelsColor.withAlpha(128))
                background = shapeDrawable
                setTextColor(labelsTextColor)
            } else
                visibility = View.GONE
        }
        view.findViewById<TextView>(R.id.tvBitrate)?.apply {
            if (bitrate.isNotBlank()) {
                text = bitrate
                val shapeDrawable = MaterialShapeDrawable(shapeAppearanceModel)
                shapeDrawable.fillColor = labelsColor.withAlpha(220)
                shapeDrawable.setStroke(2.0f, labelsColor.withAlpha(128))
                background = shapeDrawable
                setTextColor(labelsTextColor)
            } else
                visibility = View.GONE
        }

        val builder = AlertDialog.Builder(context)
        if (title.isNotEmpty())
            builder.setTitle(title)

        if (torrLink.isNotBlank()) {
            builder.setPositiveButton(R.string.add) { dlg, _ ->
                CoroutineScope(Dispatchers.IO).launch {
                    try {
                        val torrent = addTorrent("", torrLink, title, "", category, "", true)
                        torrent?.let { App.toast("${context.getString(R.string.stat_string_added)}: ${it.title}") } ?: App.toast(context.getString(R.string.error_add_torrent))
                    } catch (e: Exception) {
                        e.printStackTrace()
                        App.toast(e.message ?: context.getString(R.string.error_add_torrent))
                    }
                }
                dlg.dismiss()
            }
            builder.setNegativeButton(android.R.string.cancel) { dlg, _ ->
                dlg.dismiss()
            }
        } else {
            builder.setNeutralButton(android.R.string.ok) { dlg, _ ->
                dlg.dismiss()
            }
        }

        val dialog = builder.create()
        dialog.setView(view)
        dialog.show()
        dialog.getButton(DialogInterface.BUTTON_POSITIVE)?.requestFocus()
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/dialogs/PlayersDialog.kt
```kt
package ru.yourok.torrserve.ui.dialogs

import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.content.pm.ResolveInfo
import android.os.Build
import android.view.LayoutInflater
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.widget.SwitchCompat
import androidx.core.net.toUri
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.app.Consts.PLAYERS_BLACKLIST
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.utils.Mime
import ru.yourok.torrserve.utils.TorrentHelper
import java.util.Locale

object PlayersDialog {
    fun show(context: Context, torrent: Torrent, index: Int, onSelect: (player: String) -> Unit) {
        val file = TorrentHelper.findFile(torrent, index) ?: throw Exception("file in torrent not found")
        val link = TorrentHelper.getTorrentPlayLink(torrent, index)
        val mime = Mime.getMimeType(file.path)
        val intent = Intent(Intent.ACTION_VIEW)
        intent.setDataAndType(link.toUri(), mime)

        val resInfo =
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                App.context.packageManager.queryIntentActivities(intent, PackageManager.MATCH_ALL)
            } else {
                App.context.packageManager.queryIntentActivities(intent, 0)
            } // PackageManager.MATCH_DEFAULT_ONLY

        val filteredList: MutableList<ResolveInfo> = mutableListOf()
        for (info in resInfo) {
            if (!PLAYERS_BLACKLIST.contains(info.activityInfo.packageName.lowercase(Locale.getDefault()))) {
                filteredList.add(info)
            }
        }

        if (filteredList.isEmpty()) {
            App.toast(R.string.error_app_not_found, false)
            return
        }

        val listAdapter = AppListAdapter(context, filteredList)
        val builder = AlertDialog.Builder(context)
        val appTitleView = LayoutInflater.from(context).inflate(R.layout.app_list_title, null)
        val switch = appTitleView.findViewById<SwitchCompat>(R.id.useDefault)

        builder.setCustomTitle(appTitleView)
        builder.setAdapter(listAdapter) { dlg, which ->
            val setDefaultPlayer = switch.isChecked
            val selectedPlayer = listAdapter.getItemPackage(which)
            onSelect(selectedPlayer)
            if (setDefaultPlayer) Settings.setPlayer(selectedPlayer)
            dlg.dismiss()
        }
        val dialog = builder.create()
        dialog.show()
        dialog.listView.requestFocus()
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/activities/play/Helper.kt
```kt
package ru.yourok.torrserve.ui.activities.play

import android.content.ContentResolver
import android.content.Intent
import android.net.Uri
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.models.torrent.Torrent
import java.util.Locale

fun PlayActivity.readArgs() {
    intent.data?.let {
        torrentLink = it.toString()
    }
    if (intent.action?.equals(Intent.ACTION_SEND) == true) {
        if (intent.getStringExtra(Intent.EXTRA_TEXT) != null)
            torrentLink = intent.getStringExtra(Intent.EXTRA_TEXT)!!
        if (intent.extras?.get(Intent.EXTRA_STREAM) != null)
            torrentLink = intent.extras?.get(Intent.EXTRA_STREAM)?.toString() ?: ""
    }

    intent?.extras?.apply {
        keySet().forEach { key ->
            when (key.lowercase(Locale.getDefault())) {
                "hash" -> torrentHash = this.getString(key) ?: ""
                "title" -> torrentTitle = this.getString(key) ?: ""
                "poster" -> torrentPoster = this.getString(key) ?: ""
                "category" -> torrentCategory = this.getString(key) ?: ""
                "data" -> torrentData = this.getString(key) ?: ""
                "fileindex" -> torrentFileIndex = this.getInt(key, -1)
                "save" -> torrentSave = this.getBoolean(key)
            }
        }
    }
}

fun PlayActivity.successful(intent: Intent) {
    setResult(AppCompatActivity.RESULT_OK, intent)
    finish()
}

fun PlayActivity.error(err: ReturnError) {
    lifecycleScope.launch(Dispatchers.Default) {
        val ret = Intent()
        ret.putExtra("errCode", err.errCode)
        ret.putExtra("errMessage", err.errMessage)
        setResult(AppCompatActivity.RESULT_CANCELED, ret)
        App.toast(err.errMessage, true)
        delay(App.LONG_TOAST_DURATION.toLong()) // as in toast duration
        if (err != ErrTorrServerNotResponding)
            finish()
    }
}

fun PlayActivity.addAndExit() {
    lifecycleScope.launch(Dispatchers.IO) {
        try {
            addTorrent(torrentHash, torrentLink, torrentTitle, torrentPoster, torrentCategory, torrentData, true)
        } catch (e: Exception) {
            error(ErrLoadTorrent)
            return@launch
        }
    }
    torrentHash = ""
    finish()
}

fun addTorrent(torrentHash: String, torrentLink: String, torrentTitle: String, torrentPoster: String, torrentCategory: String, torrentData: String, torrentSave: Boolean): Torrent? {
    return if (torrentHash.isNotEmpty()) {
        try {
            Api.getTorrent(torrentHash)
        } catch (e: Exception) {
            null
        }
    } else if (torrentLink.isNotEmpty()) {
        val scheme = Uri.parse(torrentLink).scheme
        if (ContentResolver.SCHEME_CONTENT == scheme || ContentResolver.SCHEME_FILE == scheme) {
            val fis = App.context.contentResolver.openInputStream(Uri.parse(torrentLink))
            fis?.let {
                try {
                    Api.uploadTorrent(fis, torrentTitle, torrentPoster, torrentCategory, torrentData, torrentSave)
                } catch (e: Exception) {
                    null
                }
            }
        } else try {
            Api.addTorrent(torrentLink, torrentTitle, torrentPoster, torrentCategory, torrentData, torrentSave)
        } catch (e: Exception) {
            null
        }
    } else
        null
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/activities/play/SerialFilter.kt
```kt
package ru.yourok.torrserve.ui.activities.play

import android.content.Intent
import ru.yourok.torrserve.server.models.torrent.FileStat
import java.util.*

object SerialFilter {
    fun filter(intent: Intent, files: List<FileStat>): Int {
        var season = -1
        var episode = -1
        intent.extras?.apply {
            try {
                keySet().forEach {
                    when (it.lowercase(Locale.getDefault())) {
                        "season" -> season = this.getInt(it)
                        "episode" -> episode = this.getInt(it)
                    }
                }
            } catch (e: Exception) {
            }
        }

        if (season == -1 && episode == -1)
            return -1

        files.forEach {
            val name = it.path.lowercase(Locale.getDefault())
            if (
                name.contains("s${season.toString().padStart(2, '0')}e${episode.toString().padStart(2, '0')}") ||
                name.contains("e${episode.toString().padStart(2, '0')}s${season.toString().padStart(2, '0')}") ||
                name.contains("s${season}e${episode}") ||
                name.contains("e${season}s${episode}") ||
                (name.contains("s${season.toString().padStart(2, '0')}") &&
                        name.contains("e${episode.toString().padStart(2, '0')}")) ||
                (name.contains("e${season}") &&
                        name.contains("s${episode}"))
            )
                return it.id
        }
        return -1
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/activities/play/players/Players.kt
```kt
package ru.yourok.torrserve.ui.activities.play.players

import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.os.Environment
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.app.Consts.PLAYERS_BLACKLIST
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.utils.Mime
import ru.yourok.torrserve.utils.TorrentHelper
import java.io.File
import java.util.Locale
import androidx.core.net.toUri

object Players {

    fun getIntent(torrent: Torrent, index: Int, selectedPlayer: String?): Intent? {
        val file = TorrentHelper.findFile(torrent, index) ?: throw Exception("file in torrent not found")
        val link = TorrentHelper.getTorrentPlayLink(torrent, index)
        var player = Settings.getPlayer()
        if (!selectedPlayer.isNullOrEmpty()) {
            player = selectedPlayer
        }
        val mime = Mime.getMimeType(file.path)
        val intent = Intent(Intent.ACTION_VIEW)
        intent.setDataAndType(link.toUri(), mime)
        intent.putExtra("title", torrent.title)
        intent.putExtra("poster", torrent.poster)
        // default os player
        if (player == "0" && intent.resolveActivity(App.context.packageManager) != null)
            return intent
        // ViMu player
        if (player == "net.gtvbox.videoplayer" || player == "net.gtvbox.vimuhd") {
            val vimuIntent = Vimu.getIntent(player, torrent, index)
            if (vimuIntent.resolveActivity(App.context.packageManager) != null)
                return vimuIntent
        }
        // MX player
        if (player.contains("com.mxtech.videoplayer", true)) {
            val mxIntent = MX.getIntent(player, torrent, index)
            if (mxIntent.resolveActivity(App.context.packageManager) != null)
                return mxIntent
        }
        // UPlayer
        if (player.contains("com.uapplication.uplayer", true)) {
            val uIntent = UPlayer.getIntent(player, torrent, index)
            if (uIntent.resolveActivity(App.context.packageManager) != null)
                return uIntent
        }
        // user defined player
        if (player.isNotEmpty()) {
            intent.`package` = player
            if (intent.resolveActivity(App.context.packageManager) != null)
                return intent
            intent.`package` = null
        }
        // always ask / wrong package set
        return Intent.createChooser(intent, "")
    }

    fun getList(): List<Pair<String, String>> {
        val intent = Intent(Intent.ACTION_VIEW)
        intent.setDataAndType(Uri.fromFile(File(Environment.getExternalStorageDirectory().path, "file.mp4")), "video/*")
        var apps = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            App.context.packageManager.queryIntentActivities(intent, PackageManager.MATCH_ALL)
        } else {
            App.context.packageManager.queryIntentActivities(intent, 0)
        } // PackageManager.MATCH_DEFAULT_ONLY
        val list = mutableListOf<Pair<String, String>>()
        list.add("" to App.context.getString(R.string.choose_player))
        list.add("0" to App.context.getString(R.string.default_player))
        for (a in apps) {
            val name = a.loadLabel(App.context.packageManager).toString() // ?: a.activityInfo.packageName
            if (!PLAYERS_BLACKLIST.contains(a.activityInfo.packageName.lowercase(Locale.getDefault()))) {
                list.add(a.activityInfo.packageName to name)
            }
        }

        intent.setDataAndType(Uri.fromFile(File(Environment.getExternalStorageDirectory().path, "file.mp3")), "audio/*")
        apps = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            App.context.packageManager.queryIntentActivities(intent, PackageManager.MATCH_ALL)
        } else {
            App.context.packageManager.queryIntentActivities(intent, 0)
        } // PackageManager.MATCH_DEFAULT_ONLY
        for (a in apps) {
            val name = a.loadLabel(App.context.packageManager).toString() // ?: a.activityInfo.packageName
            if (!PLAYERS_BLACKLIST.contains(a.activityInfo.packageName.lowercase(Locale.getDefault()))) {
                list.add(a.activityInfo.packageName to name)
            }
        }

        return list.distinctBy { it.first }
    }

}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/activities/play/players/Vimu.kt
```kt
package ru.yourok.torrserve.ui.activities.play.players

import android.content.Intent
import android.net.Uri
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.utils.Mime
import ru.yourok.torrserve.utils.TorrentHelper
import java.io.File

object Vimu {
    fun getIntent(pkg: String, torrent: Torrent, index: Int): Intent {
        val link = TorrentHelper.getTorrentPlayLink(torrent, index)

        val file = TorrentHelper.findFile(torrent, index) ?: throw Exception("file in torrent not found")
        val mime = Mime.getMimeType(file.path)

        val intent = Intent(Intent.ACTION_VIEW)
        intent.setPackage(pkg)
        intent.putExtra("forcename", torrent.title)
        intent.putExtra("forcedirect", true)
        intent.putExtra("forceresume", true)
        intent.setDataAndType(Uri.parse(link), mime)

        val torrfiles = TorrentHelper.getPlayableFiles(torrent)
        if (torrfiles.size > 1) {
            val names = ArrayList<String>()
            val files = ArrayList<String>()
            var idx = 0
            for (i in torrfiles.indices) {
                names.add(File(torrfiles[i].path).name)
                files.add(TorrentHelper.getFileLink(torrent, torrfiles[i]))
                if (torrfiles[i].id == index) idx = i
            }
            intent.setDataAndType(Uri.parse(link), "application/vnd.gtvbox.filelist")
            intent.putStringArrayListExtra("asusfilelist", files)
            intent.putStringArrayListExtra("asusnamelist", names)
            intent.putExtra("startindex", idx)
        }
        return intent
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/activities/play/players/UPlayer.kt
```kt
package ru.yourok.torrserve.ui.activities.play.players

import android.content.Intent
import android.net.Uri
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.utils.Mime
import ru.yourok.torrserve.utils.TorrentHelper
import java.io.File

object UPlayer {
    fun getIntent(pkg: String, torrent: Torrent, index: Int): Intent {
        val link = TorrentHelper.getTorrentPlayLink(torrent, index)

        val file = TorrentHelper.findFile(torrent, index) ?: throw Exception("file in torrent not found")

        val intent = Intent(Intent.ACTION_VIEW)
        intent.setPackage(pkg)
//        intent.component = ComponentName(pkg, "$pkg.Comp")

        val mime = Mime.getMimeType(file.path)
        intent.setDataAndType(Uri.parse(link), mime)

        val torrfiles = TorrentHelper.getPlayableFiles(torrent)
        if (torrfiles.size > 1) {
            intent.putExtra("playlistTitle", torrent.title)
            val names = ArrayList<String>()
            val files = ArrayList<String>()
            var idx = 0
            for (i in torrfiles.indices) {
                names.add(File(torrfiles[i].path).name)
                files.add(TorrentHelper.getFileLink(torrent, torrfiles[i]))
                if (torrfiles[i].id == index) idx = i
            }
            intent.putExtra("titleList", names) // ArrayList<String>
            intent.putExtra("videoList", files) // ArrayList<String>
            intent.putExtra("playlistPosition", idx) // Int
        }
        return intent
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/activities/play/players/MX.kt
```kt
package ru.yourok.torrserve.ui.activities.play.players

import android.content.ComponentName
import android.content.Intent
import android.net.Uri
import android.os.Parcelable
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.utils.Mime
import ru.yourok.torrserve.utils.TorrentHelper
import java.io.File

object MX {
    fun getIntent(pkg: String, torrent: Torrent, index: Int): Intent {
        val link = TorrentHelper.getTorrentPlayLink(torrent, index)

        val file = TorrentHelper.findFile(torrent, index) ?: throw Exception("file in torrent not found")
        val mime = Mime.getMimeType(file.path)

        val intent = Intent(Intent.ACTION_VIEW)
//        intent.setPackage(pkg)
        intent.component = ComponentName(pkg, "$pkg.ActivityScreen")
        intent.putExtra("title", torrent.title)
        intent.putExtra("sticky", false)
        intent.setDataAndType(Uri.parse(link), mime)

        val torrfiles = TorrentHelper.getPlayableFiles(torrent)
        if (torrfiles.size > 1) {
            val names = ArrayList<String>()
            val parcelableArr = arrayOfNulls<Parcelable>(torrfiles.size)
            for (i in torrfiles.indices) {
                names.add(File(torrfiles[i].path).name)
                parcelableArr[i] = Uri.parse(TorrentHelper.getFileLink(torrent, torrfiles[i]))
            }
            val ta = names.toTypedArray()
            intent.putExtra("video_list", parcelableArr)
            intent.putExtra("video_list.name", ta)
            intent.putExtra(
                "video_list.filename",
                ta
            )
            intent.putExtra("video_list_is_explicit", true)
        }
        return intent
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/activities/play/ReturnErrors.kt
```kt
package ru.yourok.torrserve.ui.activities.play

import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App

data class ReturnError(val errCode: Int, val errMessage: String)

val ErrIntentNull = ReturnError(-1, App.context.getString(R.string.error_intent_null))
val ErrUnknownCmd = ReturnError(-2, App.context.getString(R.string.error_unknown_command))
val ErrProcessIntent = ReturnError(-3, App.context.getString(R.string.error_process_intent))
val ErrEmptyTorrent = ReturnError(-4, App.context.getString(R.string.error_empty_link))
val ErrLoadTorrent = ReturnError(-5, App.context.getString(R.string.error_add_torrent))
val ErrLoadTorrentInfo = ReturnError(-6, App.context.getString(R.string.error_retrieve_torrent_info))
val ErrUserStop = ReturnError(-7, App.context.getString(R.string.error_user_cancel))
val ErrTorrServerNotResponding = ReturnError(-8, App.context.getString(R.string.server_not_responding))
val ErrLoadTorrentFiles = ReturnError(-9, App.context.getString(R.string.error_retrieve_torrent_file))

```

## ./app/src/main/java/ru/yourok/torrserve/ui/activities/play/PlayActivity.kt
```kt
package ru.yourok.torrserve.ui.activities.play

import android.content.res.Configuration
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.TextView
import androidx.activity.OnBackPressedCallback
import androidx.appcompat.app.AppCompatActivity
import androidx.fragment.app.FragmentActivity
import androidx.lifecycle.lifecycleScope
import com.google.android.material.progressindicator.LinearProgressIndicator
import com.google.firebase.analytics.FirebaseAnalytics
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.R
import ru.yourok.torrserve.ad.AD
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.local.TorrService
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.ui.activities.play.Play.play
import ru.yourok.torrserve.ui.fragments.main.servfinder.ServerFinderFragment
import ru.yourok.torrserve.ui.fragments.main.update.server.UpdaterServer
import ru.yourok.torrserve.ui.fragments.play.ChooserFragment
import ru.yourok.torrserve.ui.fragments.play.InfoFragment
import ru.yourok.torrserve.utils.ThemeUtil
import kotlin.concurrent.thread


class PlayActivity : AppCompatActivity() {
    var torrentLink: String = ""
    var torrentHash: String = ""
    var torrentTitle: String = ""
    var torrentPoster: String = ""
    var torrentCategory: String = ""
    var torrentData: String = ""
    var torrentSave: Boolean = false
    var torrentFileIndex: Int = -1

    private var userClose = false

    var ad: AD? = null

    private val themeUtil = ThemeUtil()

    val infoFragment = InfoFragment()

    private var firebaseAnalytics: FirebaseAnalytics? = null

    private val onBackPressedCallback: OnBackPressedCallback = object : OnBackPressedCallback(true) {
        override fun handleOnBackPressed() {
            if (BuildConfig.DEBUG) Log.d("PlayActivity", "handleOnBackPressed() set userClose = true")
            userClose = true
            finish()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        //// DayNight Theme // AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM)
        when (Settings.getTheme()) {
            "dark" -> setTheme(R.style.PlayDialog_Dark)
            "light" -> setTheme(R.style.PlayDialog_Light)
            "black" -> setTheme(R.style.PlayDialog_Black)
            else -> setTheme(R.style.PlayDialog_DayNight)
        }
        setContentView(R.layout.play_activity)
        setWindow()

        onBackPressedDispatcher.addCallback(this, onBackPressedCallback)

        lifecycleScope.launch { showProgress() }

        firebaseAnalytics = FirebaseAnalytics.getInstance(this)

        if (intent == null) {
            error(ErrIntentNull)
            return
        }

        TorrService.start()
    }

    override fun onResume() {
        super.onResume()
        readArgs()
        lifecycleScope.launch(Dispatchers.IO) {
            if (!TorrService.wait(5)) {
                error(ErrTorrServerNotResponding)
                delay(App.LONG_TOAST_DURATION.toLong())
                if (TorrService.isLocal() && !TorrService.isInstalled()) {
                    withContext(Dispatchers.Main) {
                        findViewById<TextView>(R.id.info_title)?.setText(R.string.install_server)
                    }
                    UpdaterServer.updateFromNet {
                        lifecycleScope.launch(Dispatchers.Main) {
                            showProgress(it)
                        }
                    }
                    if (TorrService.wait(5))
                        withContext(Dispatchers.Main) {
                            findViewById<TextView>(R.id.info_title)?.setText(R.string.app_name)
                            processIntent()
                        }
                } else {
                    //server is not local, change
                    ServerFinderFragment().apply {
                        show(App.currentActivity as? FragmentActivity?, R.id.bottom_container, true)
                        onResult = {
                            withContext(Dispatchers.Main) {
                                processIntent()
                            }
                        }
                    }
                }
            } else {
                withContext(Dispatchers.Main) {
                    processIntent()
                }
            }
        }
    }

    override fun onUserLeaveHint() {
        super.onUserLeaveHint()
        if (BuildConfig.DEBUG) Log.d("PlayActivity", "onUserLeaveHint()")
        lifecycleScope.cancel()
        finish() // back from player to files list
    }

    override fun onDestroy() {
        if (userClose) {
            if (torrentHash.isNotEmpty())
                thread {
                    try {
                        if (BuildConfig.DEBUG) Log.d("PlayActivity", "onDestroy() drop torrent $torrentHash")
                        Api.dropTorrent(torrentHash)
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
        }
        super.onDestroy()
    }


    override fun onConfigurationChanged(newConfig: Configuration) {
        if (App.inForeground) super.onConfigurationChanged(newConfig)
        themeUtil.onConfigurationChanged(this, newConfig)
    }

    private fun setWindow() {
        setFinishOnTouchOutside(false)
        val attr = window.attributes
        if (resources.displayMetrics.widthPixels <= resources.displayMetrics.heightPixels)
            attr.width = (resources.displayMetrics.widthPixels * 0.90).toInt()
        else if (resources.displayMetrics.widthPixels > resources.displayMetrics.heightPixels)
            attr.width = (resources.displayMetrics.widthPixels * 0.70).toInt()
        window.attributes = attr
    }

    private fun processIntent() {
        ad = AD(findViewById(R.id.ivAd), this)
        ad?.get()
        //// Play torrent
        if (intent.hasExtra("action") && intent.getStringExtra("action") == "play")
            play(false)
        else {
            lifecycleScope.launch { hideProgress() }
            if (App.inForeground) {
                val isForceChoose = (intent.hasExtra("action") && intent.getStringExtra("action") == "choose")
                ChooserFragment().show(this, isForceChoose) {
                    when (it) {
                        1, 2 -> {
                            play(it == 2)
                        }

                        3 -> {
                            addAndExit()
                        }
                    }
                }
            }
        }
    }

    // https://material.io/components/progress-indicators/android
    suspend fun showProgress(prc: Int = -1) = withContext(Dispatchers.Main) {
        if (isActive) {
            val color = ThemeUtil.getColorFromAttr(this@PlayActivity, R.attr.colorAccent)
            findViewById<LinearProgressIndicator>(R.id.progressBar)?.apply {
                setIndicatorColor(color)
                visibility = View.VISIBLE
                isIndeterminate = prc < 0
                if (!isIndeterminate)
                    setProgressCompat(prc, true)
            }
        }
    }

    suspend fun hideProgress() = withContext(Dispatchers.Main) {
        if (isActive)
            findViewById<LinearProgressIndicator>(R.id.progressBar)?.apply {
                visibility = View.INVISIBLE
                isIndeterminate = true
            }
    }

    suspend fun hideTitle() = withContext(Dispatchers.Main) {
        if (isActive)
            findViewById<TextView>(R.id.info_title)?.visibility = View.GONE
    }

}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/activities/play/Play.kt
```kt
package ru.yourok.torrserve.ui.activities.play

import android.content.Intent
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.ui.activities.play.players.Players
import ru.yourok.torrserve.ui.dialogs.PlayersDialog
import ru.yourok.torrserve.ui.fragments.play.TorrentFilesFragment
import ru.yourok.torrserve.utils.TorrentHelper

object Play {

    fun PlayActivity.play(save: Boolean) {
        infoFragment.show(this, R.id.info_container)
        lifecycleScope.launch(Dispatchers.IO) {
            showProgress(-1)
            torrentSave = save

            val torrent: Torrent
            try {
                val torr = addTorrent(torrentHash, torrentLink, torrentTitle, torrentPoster, torrentCategory, torrentData, torrentSave)
                    ?: let {
                        error(ErrLoadTorrent)
                        return@launch
                    }
                infoFragment.startInfo(torr.hash)
                if (torrentHash.isEmpty() && torr.hash.isNotBlank()) // store hash for Api.dropTorrent on close
                    torrentHash = torr.hash
                torrent = TorrentHelper.waitFiles(torr.hash) ?: let {
                    error(ErrLoadTorrentInfo)
                    return@launch
                }
            } catch (e: Exception) {
                e.message?.let { App.toast(it, true) }
                delay(App.LONG_TOAST_DURATION.toLong())
                return@launch
            }

            val viewed = try {
                Api.listViewed(torrent.hash)
            } catch (_: Exception) {
                emptyList()
            }
            val files = TorrentHelper.getPlayableFiles(torrent)

            if (intent.hasExtra("FileTemplate") && torrentFileIndex == -1) // For lostfilm app
                torrentFileIndex = SerialFilter.filter(intent, files)

            lifecycleScope.launch {
                when {
                    files.isEmpty() -> {
                        error(ErrLoadTorrentFiles)
                    }

                    files.size == 1 -> {
                        torrentFileIndex = 0
                        lifecycleScope.launch {
                            streamTorrent(torrent, files.first().id)
                        }
                    }

                    torrentFileIndex > 0 -> {
                        lifecycleScope.launch {
                            streamTorrent(torrent, torrentFileIndex)
                        }
                    }

                    else -> {
                        hideProgress()
                        TorrentFilesFragment().showTorrent(this@play, torrent, viewed) { file ->
                            torrentFileIndex = TorrentHelper.findIndex(torrent, file)
                            lifecycleScope.launch {
                                streamTorrent(torrent, file.id)
                            }
                        }
                    }
                }
            }
        }
    }

    private suspend fun PlayActivity.streamTorrent(torrent: Torrent, index: Int) {
        var torr = torrent

        TorrentHelper.preloadTorrent(torr, index)
        delay(200)

        withContext(Dispatchers.IO) {
            try {
                torr = Api.getTorrent(torr.hash)
            } catch (_: Exception) {
            }
            while (torr.stat == TorrentHelper.T_STATE_PRELOAD) {
                delay(1000)
                try {
                    torr = Api.getTorrent(torr.hash)
                } catch (_: Exception) {
                }
            }
        }

        ad?.waitAd()
        var playerIntent: Intent? = null
        try {
            if (Settings.getPlayer().isEmpty()) {
                // show chooser
                PlayersDialog.show(this, torr, index) { player ->
                    playerIntent = Players.getIntent(torr, index, player)
                    //if (BuildConfig.DEBUG) Log.d("*****", "Player intent: ${playerIntent?.toUri(0)}")
                    playerIntent?.let {
                        it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                        try {
                            App.context.startActivity(it)
                            successful(it)
                        } catch (e: Exception) {
                            error(ErrProcessIntent)
                        }
                    }
                }
            } else
                playerIntent = Players.getIntent(torr, index, null)
        } catch (e: Exception) {
            e.message?.let { App.toast(it) }
        }
        //if (BuildConfig.DEBUG) Log.d("*****", "Player intent: ${playerIntent?.toUri(0)}")
        playerIntent?.let {
            it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            try {
                App.context.startActivity(it)
                successful(it)
            } catch (e: Exception) {
                error(ErrProcessIntent)
            }
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/activities/main/MainActivity.kt
```kt
package ru.yourok.torrserve.ui.activities.main

import android.content.DialogInterface.BUTTON_POSITIVE
import android.content.Intent
import android.content.res.ColorStateList
import android.content.res.Configuration
import android.os.Bundle
import android.text.SpannableString
import android.text.Spanned
import android.util.Log
import android.view.KeyEvent
import android.view.View
import android.widget.FrameLayout
import android.widget.TextView
import androidx.activity.OnBackPressedCallback
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.content.res.AppCompatResources
import androidx.core.net.toUri
import androidx.core.view.GravityCompat
import androidx.drawerlayout.widget.DrawerLayout
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import com.google.android.material.floatingactionbutton.FloatingActionButton
import com.google.android.material.shape.CornerFamily
import com.google.android.material.shape.MaterialShapeDrawable
import com.google.android.material.shape.ShapeAppearanceModel
import com.google.firebase.analytics.FirebaseAnalytics
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.atv.Utils
import ru.yourok.torrserve.ext.clearStackFragment
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.local.ServerFile
import ru.yourok.torrserve.server.local.TorrService
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.ui.fragments.add.AddFragment
import ru.yourok.torrserve.ui.fragments.donate.DonateFragment
import ru.yourok.torrserve.ui.fragments.donate.DonateMessage
import ru.yourok.torrserve.ui.fragments.main.servfinder.ServerFinderFragment
import ru.yourok.torrserve.ui.fragments.main.servsets.ServerSettingsFragment
import ru.yourok.torrserve.ui.fragments.main.settings.SettingsFragment
import ru.yourok.torrserve.ui.fragments.main.torrents.TorrentsFragment
import ru.yourok.torrserve.ui.fragments.main.update.apk.ApkUpdateFragment
import ru.yourok.torrserve.ui.fragments.main.update.apk.UpdaterApk
import ru.yourok.torrserve.ui.fragments.main.update.server.ServerUpdateFragment
import ru.yourok.torrserve.ui.fragments.main.update.server.UpdaterServer
import ru.yourok.torrserve.utils.CImageSpan
import ru.yourok.torrserve.utils.Format.dp2px
import ru.yourok.torrserve.utils.Net
import ru.yourok.torrserve.utils.Permission
import ru.yourok.torrserve.utils.SpanFormat
import ru.yourok.torrserve.utils.ThemeUtil
import kotlin.system.exitProcess


class MainActivity : AppCompatActivity() {

    private lateinit var viewModel: StatusViewModel
    private val themeUtil = ThemeUtil()
    private var firebaseAnalytics: FirebaseAnalytics? = null

    private val onBackPressedCallback: OnBackPressedCallback = object : OnBackPressedCallback(true) {
        override fun handleOnBackPressed() {
            if (BuildConfig.DEBUG) Log.d("MainActivity", "handleOnBackPressed()")
            if (isMenuVisible)
                closeMenu()
            else if (supportFragmentManager.backStackEntryCount > 0) {
                supportFragmentManager.popBackStack()
            } else finish()
        }
    }

    private val isInTorrents: Boolean
        get() {
            val f = supportFragmentManager.findFragmentById(R.id.container)
            return f is TorrentsFragment
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        firebaseAnalytics = FirebaseAnalytics.getInstance(this)

        themeUtil.onCreate(this)
        setContentView(R.layout.main_activity)

        Permission.requestPermissionWithRationale(this)

        onBackPressedDispatcher.addCallback(this, onBackPressedCallback)

        viewModel = ViewModelProvider(this)[StatusViewModel::class.java]

        setupNavigator()

        lifecycleScope.launch(Dispatchers.IO) {
            TorrService.start()
            if (TorrService.wait(10)) {
                if (TorrService.isLocal()) {
                    val ver = Api.echo()
                    if (ver.startsWith("1.1.")) {
                        withContext(Dispatchers.Main) {
                            ServerUpdateFragment().show(this@MainActivity, R.id.container, true)
                            App.toast(R.string.need_update_server, true)
                        }
                    }
                } else {
                    val ver = Api.echo()
                    if (ver.startsWith("1.1.")) {
                        withContext(Dispatchers.Main) {
                            App.toast(R.string.not_support_old_server, true)
                        }
                    }
                }
            } else { // no server response
                withContext(Dispatchers.Main) {
                    if (App.inForeground)
                        if (TorrService.isLocal()) {
                            if (!ServerFile().exists()) {
                                ServerUpdateFragment().show(this@MainActivity, R.id.container, true)
                                App.toast(R.string.need_install_server, true)
                            } else // local torrserver exists but not started, show restart hint
                                App.toast(R.string.not_loaded_exit_hint)
                        } else {
                            ServerFinderFragment().show(this@MainActivity, R.id.container, true)
                            App.toast(R.string.not_loaded_select_hint)
                        }
                }
            }
        }

        if (savedInstanceState == null) {
            clearStackFragment()
            TorrentsFragment().apply {
                show(this@MainActivity, R.id.container)
            }
            DonateMessage.showDonate(this)
            checkUpdate()
        }
    }

    override fun onResume() {
        super.onResume()
        themeUtil.onResume(this)
        //TorrService.start()
        updateStatus()
        if (Settings.showFab) setupFab()
        if (Settings.showSortFab) setupSortFab()
        lifecycleScope.launch(Dispatchers.IO) {
            if (TorrService.wait(10) && isShowCat()) {
                withContext(Dispatchers.Main) {
                    setupCatFab()
                }
            }
        }
    }

    override fun onConfigurationChanged(newConfig: Configuration) {
        super.onConfigurationChanged(newConfig)
        themeUtil.onConfigurationChanged(this, newConfig)
    }

    private fun updateStatus() {
        val host = viewModel.getHost()
        val hostView = findViewById<TextView>(R.id.tvCurrentHost)
        val statusView = findViewById<TextView>(R.id.tvStatus)
        val hostColor = ThemeUtil.getColorFromAttr(this, R.attr.colorHost)
        val inactiveColor = ThemeUtil.getColorFromAttr(this, R.attr.colorOnSurface)
        val labelTextColor = ThemeUtil.getColorFromAttr(this, R.attr.colorSurface)
        val versionColorList = ColorStateList.valueOf(ThemeUtil.getColorFromAttr(this, R.attr.colorPrimary))
        val radius = dp2px(2.0f).toFloat()
        val shapeAppearanceModel = ShapeAppearanceModel()
            .toBuilder()
            .setAllCorners(CornerFamily.ROUNDED, radius)
            .build()

        host.observe(this) {
            hostView?.text = if (it.startsWith("https", true)) {
                val sIcon = SpannableString(" ")
                AppCompatResources.getDrawable(this, R.drawable.ssl)?.let { icon ->
                    icon.setBounds(0, 0, icon.intrinsicWidth, icon.intrinsicHeight)
                    sIcon.setSpan(CImageSpan(icon), 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                }
                SpanFormat.format("%s ${it.removePrefix("https://")}", sIcon)
            } else it.removePrefix("http://")
        }
        val data = viewModel.get()
        data.observe(this) {
            statusView?.text = it
            if (it.equals(getString(R.string.server_not_responding))) {
                statusView?.apply {
                    background = null
                    setTextColor(inactiveColor)
                }
                hostView?.apply {
                    setTextColor(inactiveColor)
                    alpha = 0.75f
                }
            } else {
                statusView?.apply {
                    val shapeDrawable = MaterialShapeDrawable(shapeAppearanceModel)
                    shapeDrawable.fillColor = versionColorList.withAlpha(160) // 160
                    shapeDrawable.setStroke(2.0f, versionColorList.withAlpha(100)) // 100
                    background = shapeDrawable
                    setTextColor(labelTextColor)
                }
                hostView?.apply {
                    setTextColor(hostColor)
                    alpha = 1.0f
                }
            }
        }
    }

    private val isMenuVisible: Boolean
        get() {
            return findViewById<DrawerLayout>(R.id.drawerLayout)?.isDrawerOpen(GravityCompat.START) == true
        }

    private val drawerListener = object : DrawerLayout.SimpleDrawerListener() {
        override fun onDrawerOpened(drawerView: View) {
            super.onDrawerOpened(drawerView)

            if (Settings.showFab) showFab(false)
            if (Settings.showSortFab) showSortFab(false)
            lifecycleScope.launch(Dispatchers.IO) {
                if (isShowCat()) withContext(Dispatchers.Main) { showCatFab(false) }
            }
        }

        override fun onDrawerClosed(drawerView: View) {
            super.onDrawerClosed(drawerView)
            if (Settings.showFab) showFab()
            if (Settings.showSortFab && isInTorrents) showSortFab()
            lifecycleScope.launch(Dispatchers.IO) {
                if (isShowCat() && isInTorrents)
                    withContext(Dispatchers.Main) { showCatFab() }
                else
                    withContext(Dispatchers.Main) { showCatFab(false) }
            }
        }
    }

    private fun closeMenu() {
        findViewById<DrawerLayout>(R.id.drawerLayout)?.apply {
            addDrawerListener(drawerListener)
            closeDrawers()
        }
    }

    private fun openMenu() {
        findViewById<DrawerLayout>(R.id.drawerLayout)?.apply {
            addDrawerListener(drawerListener)
            openDrawer(GravityCompat.START)
        }
    }

    override fun onKeyUp(keyCode: Int, event: KeyEvent?): Boolean {
        supportFragmentManager.fragments.forEach {
            when (it) {
                is AddFragment ->
                    if (it.onKeyUp(keyCode))
                        return true

                is TorrentsFragment ->
                    if (it.onKeyUp(keyCode))
                        return true
            }
        }
        return super.onKeyUp(keyCode, event)
    }

    override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
        supportFragmentManager.fragments.forEach {
            when (it) {
                is AddFragment -> {
                    if (it.onKeyDown(keyCode))
                        return true
                }

                is TorrentsFragment ->
                    if (it.onKeyDown(keyCode))
                        return true
            }
        }
        if (keyCode == KeyEvent.KEYCODE_MENU) {
            if (isMenuVisible)
                closeMenu()
            else
                openMenu()
            return true
        }
        return super.onKeyDown(keyCode, event)
    }

    private fun checkUpdate() {
        lifecycleScope.launch(Dispatchers.IO) {
            if (UpdaterApk.check())
                withContext(Dispatchers.Main) {
                    App.toast(R.string.found_new_app_update, true)
                }
        }
        lifecycleScope.launch(Dispatchers.IO) {
            UpdaterServer.check()
        }
    }

    private fun setupFab() { // Fab
        if (Utils.isTvBox()) return
        val fab: FloatingActionButton? = findViewById(R.id.fab)
        fab?.apply {
            setImageDrawable(AppCompatResources.getDrawable(this.context, R.mipmap.ic_launcher))
            customSize = dp2px(32f)
            setMaxImageSize(dp2px(30f))
            setOnClickListener {
                if (isMenuVisible) {
                    closeMenu()
                    showFab()
                } else {
                    openMenu()
                    showFab(false)
                }
            }
        }
        if (!isMenuVisible) {
            showFab()
        }
    }

    private fun showFab(show: Boolean = true) {
        val fab: FloatingActionButton? = findViewById(R.id.fab)
        if (show)
            fab?.show()
        else
            fab?.hide()
    }

    private fun setupSortFab() {
        if (Utils.isTvBox()) return

        val accentColor = ThemeUtil.getColorFromAttr(this, R.attr.colorAccent)
        val actionsColor = ThemeUtil.getColorFromAttr(this, R.attr.colorMainMenu)

        val fab: FloatingActionButton? = findViewById(R.id.sort_fab)
        fab?.apply {
            if (Settings.sortTorrByTitle)
                setImageDrawable(AppCompatResources.getDrawable(this.context, R.drawable.round_filter_list_24))
            else
                setImageDrawable(AppCompatResources.getDrawable(this.context, R.drawable.round_sort_by_alpha_24))
            customSize = dp2px(32f)
            setMaxImageSize(dp2px(24f))
            backgroundTintList = ColorStateList.valueOf(actionsColor)
            setColorFilter(accentColor)
            setRippleColor(ColorStateList.valueOf(accentColor))
            setOnClickListener {
                if (isInTorrents) {
                    val f = supportFragmentManager.findFragmentById(R.id.container)
                    (f as TorrentsFragment?)?.sort()
                }
                if (Settings.sortTorrByTitle)
                    setImageDrawable(AppCompatResources.getDrawable(this.context, R.drawable.round_filter_list_24))
                else
                    setImageDrawable(AppCompatResources.getDrawable(this.context, R.drawable.round_sort_by_alpha_24))
            }
        }
        // visibility change
        if (isInTorrents)
            showSortFab()
        else
            showSortFab(false)
    }

    private fun showSortFab(show: Boolean = true) {
        val fab: FloatingActionButton? = findViewById(R.id.sort_fab)
        if (show)
            fab?.show()
        else
            fab?.hide()
    }

    private var isCatsOpen = false
    private var movFab: FloatingActionButton? = null
    private var movText: TextView? = null
    private var tvFab: FloatingActionButton? = null
    private var tvText: TextView? = null
    private var musFab: FloatingActionButton? = null
    private var musText: TextView? = null
    private var othFab: FloatingActionButton? = null
    private var othText: TextView? = null
    private var allFab: FloatingActionButton? = null
    private var allText: TextView? = null


    suspend fun isShowCat(): Boolean {
        return try {
            val vi = Api.getMatrixVersionInt()
            vi > 131 && Settings.get("show_cat_fab", false) // MatriX.132 add Categories
        } catch (_: Exception) {
            false
        }
    }

    private fun setupCatFab() { // categories options menu
        if (Utils.isTvBox()) return

        val accentColor = ThemeUtil.getColorFromAttr(this, R.attr.colorAccent)
        val actionsColor = ThemeUtil.getColorFromAttr(this, R.attr.colorMainMenu)
        //val textColor = ThemeUtil.getColorFromAttr(this, R.attr.colorBright)

        val catFab: FloatingActionButton? = findViewById(R.id.cat_fab)
        movFab = findViewById(R.id.mov_fab)
        movText = findViewById<TextView?>(R.id.mov_fab_text)?.apply { setTextColor(accentColor) }
        tvFab = findViewById(R.id.tv_fab)
        tvText = findViewById<TextView?>(R.id.tv_fab_text)?.apply { setTextColor(accentColor) }
        musFab = findViewById(R.id.mus_fab)
        musText = findViewById<TextView?>(R.id.mus_fab_text)?.apply { setTextColor(accentColor) }
        othFab = findViewById(R.id.oth_fab)
        othText = findViewById<TextView?>(R.id.oth_fab_text)?.apply { setTextColor(accentColor) }
        allFab = findViewById(R.id.all_fab)
        allText = findViewById<TextView?>(R.id.all_fab_text)?.apply { setTextColor(accentColor) }
        catFab?.apply {
            setImageDrawable(AppCompatResources.getDrawable(this.context, R.drawable.round_view_list_24))
            customSize = dp2px(32f)
            setMaxImageSize(dp2px(24f))
            backgroundTintList = ColorStateList.valueOf(actionsColor)
            setColorFilter(accentColor)
            setRippleColor(ColorStateList.valueOf(accentColor))
            setOnClickListener {
                if (!isCatsOpen) {
                    showActions()
                } else {
                    hideActions()
                }
                isCatsOpen = !isCatsOpen
            }
        }
        movFab?.apply {
            backgroundTintList = ColorStateList.valueOf(actionsColor)
            setColorFilter(accentColor)
            setRippleColor(ColorStateList.valueOf(accentColor))
            setOnClickListener {
                filterTorrents("movie")
                hideActions()
                isCatsOpen = false
            }
        }
        tvFab?.apply {
            backgroundTintList = ColorStateList.valueOf(actionsColor)
            setColorFilter(accentColor)
            setRippleColor(ColorStateList.valueOf(accentColor))
            setOnClickListener {
                filterTorrents("tv")
                hideActions()
                isCatsOpen = false
            }
        }
        musFab?.apply {
            backgroundTintList = ColorStateList.valueOf(actionsColor)
            setColorFilter(accentColor)
            setRippleColor(ColorStateList.valueOf(accentColor))
            setOnClickListener {
                filterTorrents("music")
                hideActions()
                isCatsOpen = false
            }
        }
        othFab?.apply {
            backgroundTintList = ColorStateList.valueOf(actionsColor)
            setColorFilter(accentColor)
            setRippleColor(ColorStateList.valueOf(accentColor))
            setOnClickListener {
                filterTorrents("other")
                hideActions()
                isCatsOpen = false
            }
        }
        allFab?.apply {
            backgroundTintList = ColorStateList.valueOf(actionsColor)
            setColorFilter(accentColor)
            setRippleColor(ColorStateList.valueOf(accentColor))
            setOnClickListener {
                filterTorrents()
                hideActions()
                isCatsOpen = false
            }
        }
        // visibility change
        if (isInTorrents) {
            showCatFab()
        } else {
            showCatFab(false)
        }
    }

    private fun showCatFab(show: Boolean = true) {
        val catFab: FloatingActionButton? = findViewById(R.id.cat_fab)
        if (show) {
            catFab?.show()
        } else {
            hideActions()
            isCatsOpen = false
            catFab?.hide()
        }
    }

    private fun showActions() {
        movFab?.show()
        tvFab?.show()
        musFab?.show()
        othFab?.show()
        allFab?.show()
        movText?.visibility = View.VISIBLE
        tvText?.visibility = View.VISIBLE
        musText?.visibility = View.VISIBLE
        othText?.visibility = View.VISIBLE
        allText?.visibility = View.VISIBLE
    }

    private fun hideActions() {
        movFab?.hide()
        tvFab?.hide()
        musFab?.hide()
        othFab?.hide()
        allFab?.hide()
        movText?.visibility = View.GONE
        tvText?.visibility = View.GONE
        musText?.visibility = View.GONE
        othText?.visibility = View.GONE
        allText?.visibility = View.GONE
    }

    private fun filterTorrents(category: String = "") {
        if (isInTorrents) {
            val f = supportFragmentManager.findFragmentById(R.id.container)
            lifecycleScope.launch { (f as TorrentsFragment?)?.filter(category) }
        }
    }

    private fun setupNavigator() {
        // Logo
        findViewById<FrameLayout>(R.id.header)?.setOnClickListener {
            val currFragment = supportFragmentManager.findFragmentById(R.id.container)
            if (currFragment is TorrentsFragment)
                ServerFinderFragment().show(this, R.id.container, true)
            else {
                clearStackFragment()
                TorrentsFragment().show(this, R.id.container)
            }
            closeMenu()
        }
        findViewById<FrameLayout>(R.id.header)?.setOnLongClickListener {
            ServerSettingsFragment().show(this, R.id.container, true)
            closeMenu()
            true
        }

        findViewById<FrameLayout>(R.id.btnAdd)?.setOnClickListener {
            AddFragment().show(this@MainActivity, R.id.container, true)
            closeMenu()
        }

        findViewById<FrameLayout>(R.id.btnRemoveAll)?.setOnClickListener { _ ->
            val dialog = AlertDialog.Builder(this)
                .setTitle(R.string.remove_all_warn)
                .setPositiveButton(R.string.yes) { dialog, _ ->
                    lifecycleScope.launch(Dispatchers.IO) {
                        try {
                            val list = Api.listTorrent()
                            list.forEach {
                                Api.remTorrent(it.hash)
                            }
                            withContext(Dispatchers.Main) { dialog.dismiss() }
                        } catch (e: Exception) {
                            e.message?.let {
                                App.toast(it)
                            }
                        }
                    }
                }
                .setNegativeButton(R.string.cancel) { dialog, _ ->
                    dialog.dismiss()
                }
                .create()
            dialog.show()
            dialog.getButton(BUTTON_POSITIVE)?.requestFocus()
            closeMenu()
        }

        findViewById<FrameLayout>(R.id.btnPlaylist)?.setOnClickListener {
            lifecycleScope.launch(Dispatchers.IO) {
                try {
                    if (Api.listTorrent().isNotEmpty()) {
                        val intent = Intent(Intent.ACTION_VIEW)
                        intent.setDataAndType(Net.getHostUrl("/playlistall/all.m3u").toUri(), "video/*")
                        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
                        App.context.startActivity(intent)
                    }
                } catch (e: Exception) {
                    e.message?.let {
                        App.toast(it)
                    }
                }
            }
            closeMenu()
        }

        findViewById<FrameLayout>(R.id.btnDonate)?.setOnClickListener {
            DonateFragment().show(this, R.id.container, true)
            closeMenu()
        }

        findViewById<FrameLayout>(R.id.btnUpdate)?.setOnClickListener {
            lifecycleScope.launch(Dispatchers.IO) {
                if (UpdaterApk.check())
                    withContext(Dispatchers.Main) {
                        ApkUpdateFragment().show(this@MainActivity, R.id.container, true)
                    }
                else
                    withContext(Dispatchers.Main) {
                        ServerUpdateFragment().show(this@MainActivity, R.id.container, true)
                    }
            }
            closeMenu()
        }

        findViewById<FrameLayout>(R.id.btnSettings)?.setOnClickListener {
            SettingsFragment().show(this@MainActivity, R.id.container)
            closeMenu()
        }

        findViewById<FrameLayout>(R.id.btnExit)?.setOnClickListener {
            val dialog = AlertDialog.Builder(this)
                .setTitle(R.string.exit_title)
                .setMessage(getString(R.string.exit_text))
                .setPositiveButton(R.string.exit) { _, _ ->
                    TorrService.stop()
                    finishAffinity()
                    exitProcess(0)
                }
                .setNegativeButton(R.string.cancel) { dialog, _ ->
                    dialog.dismiss()
                }
                .create()
            dialog.show()
            dialog.getButton(BUTTON_POSITIVE)?.requestFocus()
            closeMenu()
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/activities/main/StatusViewModel.kt
```kt
package ru.yourok.torrserve.ui.activities.main

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.settings.Settings

class StatusViewModel : ViewModel() {
    private var isWork = Any()
    private var isWorkHost = Any()
    var data: MutableLiveData<String>? = null
    var host: MutableLiveData<String>? = null

    fun get(): LiveData<String> {
        if (data == null) {
            data = MutableLiveData()
            update()
        }
        return data!!
    }

    fun getHost(): LiveData<String> {
        if (host == null) {
            host = MutableLiveData()
            updateHost()
        }
        return host!!
    }

    override fun onCleared() {
        super.onCleared()
        isWork = false
        isWorkHost = false
    }

    private fun update() {
        viewModelScope.launch(Dispatchers.IO) {
            synchronized(isWork) {
                if (isWork == true)
                    return@launch
            }
            isWork = true
            while (isWork == true) {
                try {
                    var st = Api.echo()
                    val old = data?.value

                    if (st.isEmpty())
                        st = App.context.getString(R.string.server_not_responding)

                    if (old == null || st != old)
                        withContext(Dispatchers.Main) { data?.value = st }
                    delay(1000)
                } catch (e: Exception) {
                    delay(2000)
                }
            }
        }
    }

    private fun updateHost() {
        viewModelScope.launch(Dispatchers.Main) {
            synchronized(isWorkHost) {
                if (isWorkHost == true)
                    return@launch
            }
            isWorkHost = true
            while (isWorkHost == true) {
                val sv = Settings.getHost()
                val old = host?.value
                if (old == null || sv != old)
                    host?.value = sv
                delay(1000)
            }
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ui/activities/main/SettingsActivity.kt
```kt
package ru.yourok.torrserve.ui.activities.main

import android.content.res.Configuration
import android.os.Build
import android.os.Bundle
import android.util.Log
import androidx.activity.OnBackPressedCallback
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.ext.clearStackFragment
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.local.TorrService
import ru.yourok.torrserve.ui.fragments.main.servfinder.ServerFinderFragment
import ru.yourok.torrserve.ui.fragments.main.settings.SettingsFragment
import ru.yourok.torrserve.ui.fragments.main.update.server.ServerUpdateFragment
import ru.yourok.torrserve.utils.Permission
import ru.yourok.torrserve.utils.ThemeUtil

/* Activity to show settings from Accessibility */
class SettingsActivity : AppCompatActivity() {

    private val themeUtil = ThemeUtil()

    private val onBackPressedCallback: OnBackPressedCallback = object : OnBackPressedCallback(true) {
        override fun handleOnBackPressed() {
            if (BuildConfig.DEBUG) Log.d("SettingsActivity", "handleOnBackPressed()")
            if (supportFragmentManager.backStackEntryCount > 1)
                supportFragmentManager.popBackStack()
            else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)
                finishAndRemoveTask()
            else
                finishAffinity()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Permission.requestPermissionWithRationale(this)
        themeUtil.onCreate(this)
        setContentView(R.layout.settings_activity)

        onBackPressedDispatcher.addCallback(this, onBackPressedCallback)

        lifecycleScope.launch(Dispatchers.IO) {
            TorrService.start()
            if (TorrService.wait(10)) {
                if (TorrService.isLocal()) {
                    val ver = Api.echo()
                    if (ver.startsWith("1.1.")) {
                        withContext(Dispatchers.Main) {
                            ServerUpdateFragment().show(this@SettingsActivity, R.id.container, true)
                            App.toast(R.string.need_update_server, true)
                        }
                    }
                } else {
                    val ver = Api.echo()
                    if (ver.startsWith("1.1.")) {
                        withContext(Dispatchers.Main) {
                            App.toast(R.string.not_support_old_server, true)
                        }
                    }
                }
            } else {
                withContext(Dispatchers.Main) {
                    if (TorrService.isLocal())
                        ServerUpdateFragment().show(this@SettingsActivity, R.id.container, true)
                    else
                        ServerFinderFragment().show(this@SettingsActivity, R.id.container, true)
                    App.toast(R.string.need_install_server, true)
                }
            }
        }

        if (savedInstanceState == null) {
            clearStackFragment()
            SettingsFragment().apply {
                show(this@SettingsActivity, R.id.container)
            }
        }
    }

    override fun onResume() {
        super.onResume()
        themeUtil.onResume(this)
    }

    override fun onConfigurationChanged(newConfig: Configuration) {
        super.onConfigurationChanged(newConfig)
        themeUtil.onConfigurationChanged(this, newConfig)
    }

}
```

## ./app/src/main/java/ru/yourok/torrserve/settings/Settings.kt
```kt
package ru.yourok.torrserve.settings

import android.os.Build
import android.os.Environment
import android.util.Log
import androidx.preference.PreferenceManager
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import java.io.File
import androidx.core.content.edit
import androidx.core.net.toUri

object Settings {
    val showFab: Boolean
        get() = if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) false // TODO Fix FAB focus
        else
            get("show_fab", true)

    val showSortFab: Boolean
        get() = get("show_sort_fab", false)

    val sortTorrByTitle: Boolean
        get() = get("sort_torrents", false)

    fun getServerAuth(): String = get("server_auth", "").trim()
    fun useLocalAuth(): Boolean = get("local_auth", false)
    fun getHosts(): List<String> {
        val prefs = PreferenceManager.getDefaultSharedPreferences(App.context)
        val ret = prefs.getStringSet("saved_hosts", mutableSetOf())
        return ret?.toList() ?: emptyList()
    }

    fun setHosts(hosts: List<String>) {
        val prefs = PreferenceManager.getDefaultSharedPreferences(App.context)
        prefs.edit { putStringSet("saved_hosts", hosts.toMutableSet()) }
    }

    fun getLastViewDonate() = get("last_view_donate", 0L)
    fun setLastViewDonate(v: Long) = set("last_view_donate", v)

    fun getPlayer(): String = get(App.context.getString(R.string.player_pref_key), "")
    fun setPlayer(v: String) = set(App.context.getString(R.string.player_pref_key), v)

    fun getChooserAction(): Int = get("chooser_action", 0)
    fun setChooserAction(v: Int) = set("chooser_action", v)

    fun isAccessibilityOn(): Boolean = get("switch_accessibility", false)
    fun isBootStart(): Boolean = get("boot_start", false)
    fun isRootStart(): Boolean = get("root_start", false)

    fun showBanner(): Boolean = get("show_banner", true)
    fun setShowBanner(v: Boolean) = set("show_banner", v)

    fun showCover(): Boolean = get("show_cover", true)
    fun getTheme(): String = get("theme", "auto")
    fun setTheme(v: String) = set("theme", v)

    fun getHost(): String = get("host", "http://localhost:8090")
    fun setHost(host: String) {
        var hst = host
        if (hst.isEmpty())
            hst = "http://localhost:8090"
        val url = hst.toUri()
        if (url.scheme.isNullOrBlank())
            hst = "http://$hst"
        if (url.port == -1)
            hst = "$hst:8090"

        set("host", hst)
    }

    fun getTorrPath(): String {
        var filesDir: File?
        filesDir = App.context.getExternalFilesDir(null)

        if (filesDir?.canWrite() != true || Build.VERSION.SDK_INT > Build.VERSION_CODES.TIRAMISU) {
            if (BuildConfig.DEBUG) Log.d("*****", "Can't write to $filesDir or SDK>33")
            filesDir = null
        }

        if (filesDir == null) {
            filesDir = App.context.filesDir
            if (BuildConfig.DEBUG) Log.d("*****", "Use $filesDir for settings path")
        }

        if (filesDir == null) {
            filesDir = File(Environment.getExternalStorageDirectory().path, "TorrServe")
            if (!filesDir.exists())
                filesDir.mkdirs()
        }

        return filesDir.path
    }

    fun logPath(): String {
        var filesDir: File?
        filesDir = App.context.getExternalFilesDir(null)
        if (filesDir?.canWrite() != true || Build.VERSION.SDK_INT > Build.VERSION_CODES.TIRAMISU)
            filesDir = File(Environment.getExternalStorageDirectory().path, "TorrServe")
        if (!filesDir.exists())
            filesDir.mkdirs()
        if (filesDir.canWrite() != true) {
            if (BuildConfig.DEBUG) Log.d("*****", "Can't write to $filesDir")
            filesDir = null
        } else
            if (BuildConfig.DEBUG) Log.d("*****", "Use $filesDir for log path")
        return filesDir?.path ?: ""
    }

    @Suppress("UNCHECKED_CAST")
    fun <T> get(name: String, def: T): T {
        try {
            val prefs = PreferenceManager.getDefaultSharedPreferences(App.context)
            if (prefs.all.containsKey(name))
                return prefs.all[name] as T
            return def
        } catch (_: Exception) {
            return def
        }
    }

    @Suppress("UNCHECKED_CAST")
    fun set(name: String, value: Any?) {
        val prefs = PreferenceManager.getDefaultSharedPreferences(App.context)
        when (value) {
            is String -> prefs.edit { putString(name, value) }
            is Boolean -> prefs.edit { putBoolean(name, value) }
            is Float -> prefs.edit { putFloat(name, value) }
            is Int -> prefs.edit { putInt(name, value) }
            is Long -> prefs.edit { putLong(name, value) }
            is MutableSet<*>? -> prefs.edit { putStringSet(name, value as MutableSet<String>?) }
            else -> prefs.edit { putString(name, value.toString()) }
        }
    }
}

```

## ./app/src/main/java/ru/yourok/torrserve/settings/BTSets.kt
```kt
package ru.yourok.torrserve.settings

data class BTSets(
    // Cache
    var CacheSize: Long,
    var PreloadBuffer: Boolean,
    var PreloadCache: Int,
    var ReaderReadAHead: Int,
    // Storage
    var UseDisk: Boolean,
    var TorrentsSavePath: String,
    var RemoveCacheOnDrop: Boolean,
    // Torrent
    var ForceEncrypt: Boolean,
    var RetrackersMode: Int,
    var TorrentDisconnectTimeout: Int,
    var EnableDebug: Boolean,
    var ResponsiveMode: Boolean,
    // DLNA
    var EnableDLNA: Boolean,
    var FriendlyName: String,
    // Rutor search
    var EnableRutorSearch:Boolean,
    // BT Config
    var EnableIPv6: Boolean,
    var DisableTCP: Boolean,
    var DisableUTP: Boolean,
    var DisableUPNP: Boolean,
    var DisableDHT: Boolean,
    var DisablePEX: Boolean,
    var DisableUpload: Boolean,
    var DownloadRateLimit: Int,
    var UploadRateLimit: Int,
    var ConnectionsLimit: Int,
    var DhtConnectionLimit: Int,
    var PeersListenPort: Int,
)

```

## ./app/src/main/java/ru/yourok/torrserve/ad/ADManager.kt
```kt
package ru.yourok.torrserve.ad

import com.google.gson.Gson
import ru.yourok.torrserve.ad.model.ADData
import ru.yourok.torrserve.app.Consts
import ru.yourok.torrserve.utils.Net
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

object ADManager {
    private var addata: ADData? = null

    fun expired(): Boolean {
        get()?.let {
            if (it.expired != "0") {
                val formatter = SimpleDateFormat("dd.MM.yyyy", Locale.US)
                val date = formatter.parse(it.expired) as Date
                return System.currentTimeMillis() > date.time
            }
        }
        return true
    }

    fun get(): ADData? {
        addata?.let {
            return it
        }
        try {
            val link = Consts.AD_LINK + "/ad.json"
            val buf = Net.get(link)
            val data = Gson().fromJson(buf, ADData::class.java)
            addata = data
            return data
        } catch (e: Exception) {
            e.printStackTrace()
        }
        return null
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ad/AD.kt
```kt
package ru.yourok.torrserve.ad

import android.graphics.drawable.ColorDrawable
import android.view.View
import android.widget.ImageView
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import com.bumptech.glide.Glide
import com.bumptech.glide.load.resource.bitmap.BitmapTransitionOptions
import com.google.firebase.analytics.FirebaseAnalytics
import kotlinx.coroutines.*
import ru.yourok.torrserve.ad.model.Image
import ru.yourok.torrserve.app.Consts
import ru.yourok.torrserve.settings.Settings

class AD(private val iv: ImageView, private val activity: AppCompatActivity) {
    private val lock = Any()

    fun get() {
        activity.lifecycleScope.launch(Dispatchers.IO) {
            synchronized(lock) {
                ADManager.get()?.let { js ->
                    try {
                        if (ADManager.expired()) {
                            Settings.setShowBanner(true)
                            return@launch
                        }

                        if (!Settings.showBanner()) {
                            FirebaseAnalytics.getInstance(activity).logEvent("view_ad_disable", null)
                            return@launch
                        }

                        if (js.images.isNotEmpty()) {
                            loadImages(js.images)
                            FirebaseAnalytics.getInstance(activity).logEvent("view_ad", null)
                            Thread.sleep(5000)
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }
        }
    }

    fun waitAd() {
        synchronized(lock) {}
    }

    suspend fun hideAd() = withContext(Dispatchers.Main) {
        iv.visibility = View.GONE
    }

    suspend fun showAd() = withContext(Dispatchers.Main) {
        iv.visibility = View.VISIBLE
    }

    private fun loadImages(lst: List<Image>) {
        activity.lifecycleScope.launch {
            withContext(Dispatchers.Main) { iv.visibility = View.VISIBLE }

            if (lst.size == 1) {
                loadImg(lst[0].url)
                return@launch
            }

            try {
                var currImg = 0
                while (this.isActive) {
                    val img = lst[currImg]
                    loadImg(img.url)
                    currImg++
                    if (currImg >= lst.size)
                        currImg = 0

                    delay(img.wait * 1000)
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    private fun loadImg(linkImg: String) {
        var link = linkImg
        if (!link.startsWith("http"))
            link = Consts.AD_LINK + link

        Glide.with(activity)
            .asBitmap()
            .load(link)
            .fitCenter()
            .placeholder(ColorDrawable(0x3c000000))
            .transition(BitmapTransitionOptions.withCrossFade())
            .into(iv)
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ad/model/ADData.kt
```kt
package ru.yourok.torrserve.ad.model

data class ADData(
    val expired: String,
    val images: List<Image>
)

data class Image(
    val url: String,
    val wait: Long,
)
```

## ./app/src/main/java/ru/yourok/torrserve/app/App.kt
```kt
package ru.yourok.torrserve.app

import android.annotation.SuppressLint
import android.app.Activity
import android.content.Context
import android.os.Handler
import android.os.Looper
import android.os.PowerManager
import android.view.View
import android.view.ViewGroup
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.ProcessLifecycleOwner
import androidx.multidex.MultiDexApplication
import ru.yourok.torrserve.utils.ThemeUtil


class App : MultiDexApplication() {

    init {
        instance = this
    }

    val mActivityLifecycleCallbacks = ActivityCallbacks()

    companion object {
        private var instance: App? = null
        private lateinit var appContext: Context
        var inForeground: Boolean = false
        const val SHORT_TOAST_DURATION: Int = 1200
        const val LONG_TOAST_DURATION: Int = 3000
        private lateinit var wakeLock: PowerManager.WakeLock

        val context: Context
            get() {
                return appContext
            }

        private val lifecycleEventObserver = LifecycleEventObserver { _, event ->
            if (event == Lifecycle.Event.ON_STOP) {
                inForeground = false
            } else if (event == Lifecycle.Event.ON_START) {
                inForeground = true
            }
        }

        val currentActivity: Activity?
            get() {
                return instance?.mActivityLifecycleCallbacks?.currentActivity
            }

        @SuppressLint("RestrictedApi")
        fun toast(txt: String, long: Boolean = false) {
            Handler(Looper.getMainLooper()).post {
                val dur = if (long) LONG_TOAST_DURATION else SHORT_TOAST_DURATION
                val view: View = currentActivity?.findViewById(android.R.id.content) ?: return@post
                AppToast
                    .make(view as ViewGroup, txt)
                    .setDuration(dur)
                    .show()
            }
        }

        @SuppressLint("RestrictedApi")
        fun toast(txt: Int, long: Boolean = false) {
            Handler(Looper.getMainLooper()).post {
                val dur = if (long) LONG_TOAST_DURATION else SHORT_TOAST_DURATION
                val view: View = currentActivity?.findViewById(android.R.id.content) ?: return@post
                AppToast
                    .make(view as ViewGroup, context.getString(txt))
                    .setDuration(dur)
                    .show()
            }
        }
    }

    override fun onCreate() {
        super.onCreate()
        appContext = applicationContext
        ProcessLifecycleOwner
            .get().lifecycle
            .addObserver(lifecycleEventObserver)
        // Track activities
        registerActivityLifecycleCallbacks(mActivityLifecycleCallbacks)
        // DayNight Auto ON/OFF
        ThemeUtil.setNightMode()

        val powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
        wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "TorrServe:WakeLock")
    }

}
```

## ./app/src/main/java/ru/yourok/torrserve/app/ActivityCallbacks.kt
```kt
package ru.yourok.torrserve.app

import android.app.Activity
import android.app.Application
import android.os.Bundle

class ActivityCallbacks : Application.ActivityLifecycleCallbacks {

    var currentActivity: Activity? = null
    var numStarted = 0

    override fun onActivityPaused(activity: Activity) {
        currentActivity = activity
    }

    override fun onActivityResumed(activity: Activity) {
        currentActivity = activity
    }

    override fun onActivityStarted(activity: Activity) {
        currentActivity = activity
        if (numStarted == 0) {
            //app went to foreground
        }
        numStarted++
    }

    override fun onActivityDestroyed(activity: Activity) {
    }

    override fun onActivitySaveInstanceState(activity: Activity, outState: Bundle) {
    }

    override fun onActivityStopped(activity: Activity) {
        numStarted--
        if (numStarted == 0) {
            // app went to background
        }
    }

    override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) {
        currentActivity = activity
    }

}
```

## ./app/src/main/java/ru/yourok/torrserve/app/AppToastView.kt
```kt
package ru.yourok.torrserve.app

import android.animation.ValueAnimator
import android.content.Context
import android.util.AttributeSet
import android.view.View
import android.widget.ImageView
import androidx.constraintlayout.widget.ConstraintLayout
import com.google.android.material.snackbar.ContentViewCallback
import ru.yourok.torrserve.R

class AppToastView @JvmOverloads constructor(
    context: Context,
    attributeSet: AttributeSet? = null,
    defaultStyle: Int = 0
) : ConstraintLayout(context, attributeSet, defaultStyle), ContentViewCallback {
    private val content: View = View.inflate(context, R.layout.item_toast, this)

    companion object {
        private const val ANIM_IN_DURATION = 500L
        private const val ANIM_OUT_DURATION = 150L
    }

    override fun animateContentIn(delay: Int, duration: Int) {
        content.alpha = 0f
        content.animate().apply {
            alpha(1.0f)
            setDuration(ANIM_IN_DURATION)
            startDelay = delay.toLong()
        }
        val logo = content.findViewById<ImageView?>(R.id.ivLogo)
        breathFadeAnimation(logo, App.LONG_TOAST_DURATION.toLong())
    }

    override fun animateContentOut(delay: Int, duration: Int) {
        content.animate().apply {
            alpha(0f)
            setDuration(ANIM_OUT_DURATION)
            startDelay = delay.toLong()
        }
    }

    private fun breathFadeAnimation(view: View?, period: Long) {
        val minAlpha = 0.25f // Minimum alpha value
        val maxAlpha = 1.0f // Maximum alpha value

        // Create alpha animator for fading in
        val fadeInAnimator = ValueAnimator.ofFloat(minAlpha, maxAlpha).apply {
            duration = period / 2
            repeatCount = ValueAnimator.INFINITE
            repeatMode = ValueAnimator.REVERSE
            addUpdateListener { valueAnimator ->
                val alphaValue = valueAnimator.animatedValue as Float
                view?.alpha = alphaValue
            }
        }

        // Create alpha animator for fading out
        val fadeOutAnimator = ValueAnimator.ofFloat(maxAlpha, minAlpha).apply {
            duration = period / 2
            repeatCount = ValueAnimator.INFINITE
            repeatMode = ValueAnimator.REVERSE
            addUpdateListener { valueAnimator ->
                val alphaValue = valueAnimator.animatedValue as Float
                view?.alpha = alphaValue
            }
        }

        // Start both animators simultaneously
        fadeInAnimator.start()
        fadeOutAnimator.start()
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/app/AppToast.kt
```kt
package ru.yourok.torrserve.app

import android.os.Build
import android.text.TextUtils
import android.util.LayoutDirection
import android.view.LayoutInflater
import android.view.ViewGroup
import android.view.ViewGroup.MarginLayoutParams
import android.view.ViewTreeObserver
import android.widget.ImageView
import android.widget.TextView
import androidx.core.content.ContextCompat
import androidx.core.text.layoutDirection
import androidx.core.view.updateLayoutParams
import com.google.android.material.snackbar.BaseTransientBottomBar
import ru.yourok.torrserve.R
import ru.yourok.torrserve.utils.Format.dp2px
import ru.yourok.torrserve.utils.ThemeUtil
import java.util.Locale

class AppToast(
    parent: ViewGroup,
    content: AppToastView
) : BaseTransientBottomBar<AppToast>(parent, content, content) {

    init {
        var bg = R.drawable.snackbar
        var tc = R.color.tv_white
        if (ThemeUtil.selectedTheme == R.style.Theme_TorrServe_Light) {
            bg = R.drawable.snackbar_dark
            tc = R.color.tv_white
        }
        getView().setBackgroundResource(bg)
        getView().findViewById<TextView>(R.id.tvMessage).setTextColor(ContextCompat.getColor(view.context, tc))
    }

    companion object {
        private const val TEXT_SIZE = 18f
        private val logoSizePx = dp2px(25f)

        fun make(viewGroup: ViewGroup, txt: String): AppToast {
            val screenWidth = App.currentActivity?.window?.decorView?.rootView?.width ?: 0
            val screenHeight = App.currentActivity?.window?.decorView?.rootView?.height ?: 0
            val isInLandscape = screenWidth > screenHeight

            val paddingPx = if (isInLandscape) dp2px(16f) else dp2px(12f)

            val snackView = LayoutInflater.from(viewGroup.context).inflate(
                R.layout.layout_toast,
                viewGroup,
                false
            ) as AppToastView

            val ivLogo = snackView.findViewById<ImageView>(R.id.ivLogo)
            ivLogo.updateLayoutParams {
                width = logoSizePx
                height = logoSizePx
            }

            val tvMessage = snackView.findViewById<TextView>(R.id.tvMessage)
            tvMessage.textSize = TEXT_SIZE
            if (txt.isNotEmpty()) tvMessage.apply {
                text = txt
                val offset = if (isInLandscape) dp2px(4f) else dp2px(2f)
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && Locale.getDefault().layoutDirection == LayoutDirection.RTL)
                    this.setPadding(paddingPx, 0, paddingPx - offset, 0)
                else
                    this.setPadding(paddingPx - offset, 0, paddingPx, 0)
            }

            val appToast = AppToast(viewGroup, snackView)

            appToast.setGestureInsetBottomIgnored(true) // don't add toolbar margin

            appToast.getView().setPadding(paddingPx, paddingPx, paddingPx, paddingPx)

            var hMargin = dp2px(12f)
            if (isInLandscape)
                hMargin = screenWidth / 6
            val vMargin = dp2px(64f)

            val layoutParams = appToast.getView().layoutParams as MarginLayoutParams
            layoutParams.setMargins(hMargin, vMargin, hMargin, vMargin)
            appToast.getView().layoutParams = layoutParams // apply margins

            if (Build.VERSION.SDK_INT > Build.VERSION_CODES.KITKAT)
                tvMessage.viewTreeObserver.addOnPreDrawListener(object : ViewTreeObserver.OnPreDrawListener {
                    override fun onPreDraw(): Boolean {
                        tvMessage.viewTreeObserver.removeOnPreDrawListener(this)
                        // adjust tvMessage height to fit view
                        val compoundPadding = tvMessage.getCompoundPaddingTop() + tvMessage.getCompoundPaddingBottom()
                        val noOfLinesVisible: Int = (tvMessage.height - compoundPadding) / tvMessage.lineHeight
                        tvMessage.setMaxLines(noOfLinesVisible)
                        tvMessage.ellipsize = TextUtils.TruncateAt.END
                        return true
                    }
                })

            return appToast
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/app/Consts.kt
```kt
package ru.yourok.torrserve.app

object Consts {
    private const val REL_HOST = "https://releases.yourok.ru/torr"
    const val AD_LINK = "$REL_HOST/ad"
    const val UPDATE_APK_PATH = "$REL_HOST/apk_release.json"
    const val UPDATE_SERVER_PATH = "$REL_HOST/server_release.json"
    val PLAYERS_BLACKLIST = hashSetOf(
        "com.android.gallery3d",
        "com.android.tv.frameworkpackagestubs",
        "com.estrongs.android.pop",
        "com.estrongs.android.pop.pro",
        "com.ghisler.android.totalcommander",
        "com.google.android.apps.photos",
        "com.google.android.tv.frameworkpackagestubs",
        "com.instantbits.cast.webvideo",
        "com.lonelycatgames.xplore",
        "com.mitv.videoplayer",
        "com.mixplorer.silver",
        "com.opera.browser",
        "com.tcl.browser",
        "nextapp.fx",
        "org.droidtv.contentexplorer",
        "pl.solidexplorer2",
        // more to add...
    )
}
```

## ./app/src/main/java/ru/yourok/torrserve/atv/Utils.kt
```kt
package ru.yourok.torrserve.atv

import android.app.UiModeManager
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.content.res.Configuration
import android.net.Uri
import android.os.Build
import android.util.Log
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.atv.channels.UpdaterCards
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.local.TorrService
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.ui.activities.play.PlayActivity
import ru.yourok.torrserve.utils.TorrentHelper
import kotlin.concurrent.thread


object Utils {

    private const val FEATURE_FIRE_TV = "amazon.hardware.fire_tv"

    private var lock = Any()

    val isChangHong: Boolean
        get() {
            return deviceName.lowercase().contains("changhong", ignoreCase = true)
        }

    val isAmazonTV: Boolean
        get() {
            return App.context.packageManager.hasSystemFeature(FEATURE_FIRE_TV)
        }

    val isAndroidTV: Boolean
        get() {
            return App.context.packageManager.hasSystemFeature("android.software.leanback") &&
                    Build.VERSION.SDK_INT >= Build.VERSION_CODES.O &&
                    isTvContentProviderAvailable
        }

    val isBrokenTCL: Boolean
        get() {
            val deviceName = deviceName
            return deviceName.contains("(tcl_m7642)")
        }

    val isGoogleTV: Boolean // wide posters on home
        get() {
            return App.context.packageManager.hasSystemFeature("com.google.android.tv") && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O
        }

    private val deviceName: String
        get() = String.format("%s (%s)", Build.MODEL, Build.PRODUCT)

    fun buildPendingIntent(torr: Torrent): Intent {
        return Intent(App.context, PlayActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK
            action = Intent.ACTION_VIEW
            data = Uri.parse(TorrentHelper.getTorrentMagnet(torr))
            putExtra("action", "play")
            putExtra("hash", torr.hash)
            putExtra("title", torr.title)
            putExtra("save", false)
            torr.poster.takeIf { !it.isNullOrBlank() }?.let { putExtra("poster", it) }
            torr.category.takeIf { !it.isNullOrBlank() }?.let { putExtra("category", it) }
            torr.data.takeIf { !it.isNullOrBlank() }?.let { putExtra("data", it) }
        }
    }

    fun isTvBox(): Boolean {
        val pm = App.context.packageManager
        // TV for sure
        val uiModeManager = App.context.getSystemService(Context.UI_MODE_SERVICE) as UiModeManager
        if (uiModeManager.currentModeType == Configuration.UI_MODE_TYPE_TELEVISION) {
            return true
        }
        if (pm.hasSystemFeature(FEATURE_FIRE_TV)) {
            return true
        }
        // Missing Files app (DocumentsUI) means box (some boxes still have non functional app or stub)
        if (!hasSAFChooser(pm)) {
            return true
        }
        // Legacy storage no longer works on Android 11 (level 30)
        if (Build.VERSION.SDK_INT < 30) {
            // (Some boxes still report touchscreen feature)
            if (!pm.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {
                return true
            }
            if (pm.hasSystemFeature("android.hardware.hdmi.cec")) {
                return true
            }
            if (Build.MANUFACTURER.equals("zidoo", ignoreCase = true)) {
                return true
            }
        }
        // Default: No TV - use SAF
        return false
    }

    fun updateAtvCards() {
        if (isAndroidTV) {
            synchronized(lock) {
                if (lock == true)
                    return
                lock = true
            }
            TorrService.wait(5)
            if (BuildConfig.DEBUG) Log.d("*****", "updateAtvCards()")
            var lastList = emptyList<Torrent>()
            try {
                lastList = Api.listTorrent()
            } catch (_: Exception) {
            }
            UpdaterCards.updateCards()
            thread {
                while (lock == true) {
                    var torrs = emptyList<Torrent>()
                    try {
                        torrs = Api.listTorrent()
                    } catch (_: Exception) {
                    }
                    if (!equalTorrs(lastList, torrs)) {
                        lastList = torrs
                        UpdaterCards.updateCards()
                        Thread.sleep(1000)
                    } else
                        Thread.sleep(5000)
                }
            }
        }
    }

    /**
     * Checks if the device supports Android TV content provider
     */
    val isTvContentProviderAvailable: Boolean
        get() {
            return Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && // to simplify checks on Pre-Oreo devices
                    isContentProviderAvailable(App.context, "android.media.tv")
        }

    /**
     * Generic content provider availability checker
     */
    private fun isContentProviderAvailable(context: Context, authority: String): Boolean {
        return try {
            context.packageManager.resolveContentProvider(authority, 0) != null
        } catch (_: Exception) {
            false
        }
    }

    private fun hasSAFChooser(pm: PackageManager?): Boolean {
        val intent = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            Intent(Intent.ACTION_OPEN_DOCUMENT)
        } else {
            return true // VERSION.SDK_INT < KITKAT
        }
        intent.addCategory(Intent.CATEGORY_OPENABLE)
        intent.type = "video/*"
        return intent.resolveActivity(pm!!) != null
    }

    private fun equalTorrs(lst1: List<Torrent>, lst2: List<Torrent>): Boolean {
        if (lst1.size != lst2.size)
            return false
        lst1.forEachIndexed { index, torr ->
            if (torr.hash != lst2[index].hash ||
                torr.title != lst2[index].title ||
                torr.poster != lst2[index].poster
            )
                return false
        }
        return true
    }

}

```

## ./app/src/main/java/ru/yourok/torrserve/atv/channels/ChannelService.kt
```kt
package ru.yourok.torrserve.atv.channels

import android.util.Log
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.atv.channels.providers.Provider

object ChannelService {
    fun updateChannels() {
        if (BuildConfig.DEBUG)
            Log.i("*****", "ChannelService: updateChannels()")

        with(App.context) {
            try {
                ChannelProvider("Torrents", getString(R.string.torrents)).update(Provider.get(Provider.Torrents))
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/atv/channels/providers/Torrents.kt
```kt
package ru.yourok.torrserve.atv.channels.providers

import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.models.torrent.Torrent

class Torrents : VideoProvider() {
    override fun get(): List<Torrent> {
        if (Api.echo().isNotEmpty())
            return Api.listTorrent()
        return emptyList()
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/atv/channels/providers/VideoProvider.kt
```kt
package ru.yourok.torrserve.atv.channels.providers

import ru.yourok.torrserve.server.models.torrent.Torrent


open class VideoProvider {
    open fun get(): List<Torrent> = emptyList()
}

object Provider {
    const val Torrents = "torrents"

    private val providers = mapOf<String, VideoProvider>(
        Torrents to Torrents()
    )

    fun get(name: String): List<Torrent> {
        try {
            return providers[name]?.get() ?: emptyList()
        } catch (e: Exception) {
            return emptyList()
        }
    }
}

```

## ./app/src/main/java/ru/yourok/torrserve/atv/channels/ChannelProvider.kt
```kt
package ru.yourok.torrserve.atv.channels

import android.annotation.SuppressLint
import android.content.ContentResolver
import android.content.ContentUris
import android.content.Intent
import android.graphics.BitmapFactory
import android.net.Uri
import androidx.tvprovider.media.tv.Channel
import androidx.tvprovider.media.tv.ChannelLogoUtils
import androidx.tvprovider.media.tv.PreviewProgram
import androidx.tvprovider.media.tv.TvContractCompat
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.atv.Utils
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.ui.activities.main.MainActivity
import ru.yourok.torrserve.utils.Format
import java.nio.charset.Charset
import java.util.Locale


class ChannelProvider(private val iName: String, private val dName: String) {

    private fun create(): Long {
        var channelId = findChannel()
        if (channelId != -1L)
            return channelId

        val builder = Channel.Builder()
        builder.setType(TvContractCompat.Channels.TYPE_PREVIEW)
            .setDisplayName(dName)
            .setInternalProviderData(iName)
            .setAppLinkIntentUri(Uri.parse("torrserve://${BuildConfig.APPLICATION_ID}/open_main_list"))

        val channelUri = App.context.contentResolver.insert(
            TvContractCompat.Channels.CONTENT_URI,
            builder.build().toContentValues()
        )
        channelId = channelUri?.let { ContentUris.parseId(it) } ?: 0
        val bitmap = BitmapFactory.decodeResource(App.context.resources, R.drawable.ts_round)
        ChannelLogoUtils.storeChannelLogo(App.context, channelId, bitmap)
        TvContractCompat.requestChannelBrowsable(App.context, channelId)
        return channelId
    }

    fun update(list: List<Torrent>) {
        val channelId = create()
        App.context.contentResolver.delete(
            TvContractCompat.buildPreviewProgramsUriForChannel(channelId),
            null,
            null
        )
        val channel = Channel.Builder()
        channel.setType(TvContractCompat.Channels.TYPE_PREVIEW)
            .setDisplayName(dName)
            .setInternalProviderData(iName)
            .setAppLinkIntentUri(Uri.parse("torrserve://${BuildConfig.APPLICATION_ID}/open_main_list"))
            .build()

        App.context.contentResolver.update(
            TvContractCompat.buildChannelUri(channelId),
            channel.build().toContentValues(), null, null
        )

        if (list.isNotEmpty())
            list.forEachIndexed { index, torrent ->
                val prg = getProgram(channelId, torrent, list.size - index)
                App.context.contentResolver.insert(
                    Uri.parse("content://android.media.tv/preview_program"),
                    prg.toContentValues()
                )
            }
        else
            App.context.contentResolver.insert(
                Uri.parse("content://android.media.tv/preview_program"),
                emptyProgram(channelId).toContentValues()
            )

        //remove stale channels with null data
        list().filter { it.internalProviderDataByteArray == null }.forEach {
            rem(it)
        }

    }

    @SuppressLint("RestrictedApi")
    private val PROGRAMS_PROJECTION = arrayOf(
        TvContractCompat.PreviewPrograms._ID,
        TvContractCompat.PreviewPrograms.COLUMN_SHORT_DESCRIPTION
    )

    @SuppressLint("RestrictedApi")
    fun findProgramHashById(id: Long): String {
        val cursor = App.context.contentResolver.query(
            TvContractCompat.PreviewPrograms.CONTENT_URI,
            PROGRAMS_PROJECTION,
            null,
            null,
            null
        )
        cursor?.let {
            if (it.moveToFirst())
                do {
                    val program = PreviewProgram.fromCursor(it)
                    if (id == program.id) {
                        cursor.close()
                        return program.description
                    }
                } while (it.moveToNext())
            cursor.close()
        }
        return ""
    }

    @SuppressLint("RestrictedApi")
    private fun emptyProgram(channelId: Long): PreviewProgram {
        val vintent = Intent(App.context, MainActivity::class.java)
        vintent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
        val resourceId = R.drawable.emptyposter
        val ep = Uri.Builder()
            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
            .authority(App.context.resources.getResourcePackageName(resourceId))
            .appendPath(App.context.resources.getResourceTypeName(resourceId))
            .appendPath(App.context.resources.getResourceEntryName(resourceId))
            .build()
        val preview = PreviewProgram.Builder()
            .setChannelId(channelId)
            .setTitle(App.context.getString(R.string.app_name))
            .setAvailability(TvContractCompat.PreviewProgramColumns.AVAILABILITY_FREE)
            .setDescription(App.context.getString(R.string.open_torrserve))
            .setReviewRating("5")
            .setIntent(vintent)
            .setType(TvContractCompat.PreviewPrograms.TYPE_MOVIE)
            .setSearchable(true)
            .setLive(false)
            .setPosterArtUri(ep)
            .setPosterArtAspectRatio(TvContractCompat.PreviewProgramColumns.ASPECT_RATIO_2_3)

        return preview.build()
    }

    @SuppressLint("RestrictedApi")
    private fun getProgram(channelId: Long, torr: Torrent, size: Int): PreviewProgram {
        val info = mutableListOf<String>()
        var posterUri = Uri.parse(torr.poster)
        if (posterUri.toString().isEmpty()) {
            val resourceId = R.drawable.emptyposter
            posterUri = Uri.Builder()
                .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
                .authority(App.context.resources.getResourcePackageName(resourceId))
                .appendPath(App.context.resources.getResourceTypeName(resourceId))
                .appendPath(App.context.resources.getResourceEntryName(resourceId))
                .build()
        }
        val type = if (torr.category.equals("tv", true)) TvContractCompat.PreviewPrograms.TYPE_TV_SERIES else TvContractCompat.PreviewPrograms.TYPE_MOVIE
        val preview = PreviewProgram.Builder()
            .setChannelId(channelId)
            .setTitle(torr.title)
            .setAvailability(TvContractCompat.PreviewProgramColumns.AVAILABILITY_AVAILABLE)
            .setGenre(info.joinToString(" ¬∑ "))
            .setIntent(Utils.buildPendingIntent(torr))
            .setWeight(size)
            .setType(type)
            .setSearchable(true)
            .setLive(false)
            .setPosterArtUri(posterUri)
            .setPosterArtAspectRatio(TvContractCompat.PreviewProgramColumns.ASPECT_RATIO_2_3)
            .setDescription(buildDescription(torr))

        return preview.build()
    }

    private val CHANNELS_PROJECTION = arrayOf(
        TvContractCompat.Channels._ID,
        TvContractCompat.Channels.COLUMN_DISPLAY_NAME,
        TvContractCompat.Channels.COLUMN_INTERNAL_PROVIDER_DATA,
        TvContractCompat.Channels.COLUMN_BROWSABLE
    )

    private fun findChannel(): Long {
        val cursor = App.context.contentResolver.query(
            TvContractCompat.Channels.CONTENT_URI,
            CHANNELS_PROJECTION,
            null,
            null,
            null
        )

        cursor?.let {
            if (it.moveToFirst())
                do {
                    val channel = Channel.fromCursor(it)
                    if (iName == channel.internalProviderDataByteArray?.toString(Charset.defaultCharset())) {
                        cursor.close()
                        return channel.id
                    }
                } while (it.moveToNext())
            cursor.close()
        }
        return -1
    }

    private fun list(): List<Channel> {
        val chnl = mutableListOf<Channel>()

        val cursor = App.context.contentResolver.query(
            TvContractCompat.Channels.CONTENT_URI,
            CHANNELS_PROJECTION,
            null,
            null,
            null
        )

        cursor?.let {
            if (it.moveToFirst())
                do {
                    val channel = Channel.fromCursor(it)
                    chnl.add(channel)
                } while (it.moveToNext())
            cursor.close()
        }
        return chnl
    }

    private fun rem(ch: Channel) {
        App.context.contentResolver.delete(TvContractCompat.buildChannelUri(ch.id), null, null)
    }

    private fun buildDescription(torr: Torrent): String {
        var retStr = ""
        if (torr.title.isNotBlank())
            retStr = torr.title
        else if (torr.name.isNotBlank())
            retStr = torr.name
        else
            retStr = torr.hash.uppercase(Locale.getDefault())

        if (torr.torrent_size > 0)
            retStr += " ‚Ä¢ ${Format.byteFmt(torr.torrent_size)}"

        return retStr
    }
}

```

## ./app/src/main/java/ru/yourok/torrserve/atv/channels/UpdaterCards.kt
```kt
package ru.yourok.torrserve.atv.channels

import ru.yourok.torrserve.atv.Utils
import kotlin.concurrent.thread

object UpdaterCards {

    private val lock = Any()
    private var isUpdate = false

    fun updateCards() {
        thread {
            if (!Utils.isAndroidTV)
                return@thread

            synchronized(lock) {
                if (isUpdate)
                    return@thread
                isUpdate = true
            }

            ChannelService.updateChannels()
            isUpdate = false
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ext/Fragment.kt
```kt
package ru.yourok.torrserve.ext

import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.fragment.app.FragmentTransaction

fun FragmentActivity.commitFragment(block: FragmentTransaction.() -> Unit) {
    val transact = supportFragmentManager.beginTransaction()
        .setCustomAnimations(
            android.R.anim.fade_in,
            android.R.anim.fade_out,
            android.R.anim.fade_in,
            android.R.anim.fade_out
        )
    block(transact)
    // experimental, to avoid frequent FCs in TSFragment
    transact.commitAllowingStateLoss() //transact.commit()
}

fun FragmentActivity.getLastFragment(): Fragment? {
    if (supportFragmentManager.backStackEntryCount > 0)
        return supportFragmentManager.fragments.last()
    return null
}

fun Fragment.getLastFragment() = requireActivity().getLastFragment()

fun FragmentActivity.clearStackFragment() {
    if (supportFragmentManager.backStackEntryCount > 0)
        supportFragmentManager.popBackStack(null, androidx.fragment.app.FragmentManager.POP_BACK_STACK_INCLUSIVE)
}

fun Fragment.clearStackFragment() = requireActivity().clearStackFragment()

fun FragmentActivity.popBackStackFragment() {
    if (supportFragmentManager.backStackEntryCount > 0)
        supportFragmentManager.popBackStack()
}

fun Fragment.popBackStackFragment() = requireActivity().popBackStackFragment()
```

## ./app/src/main/java/ru/yourok/torrserve/ext/String.kt
```kt
package ru.yourok.torrserve.ext

fun String.removeNonPrintable(): String // All Control Char
{
    return this.replace("[\\p{C}]".toRegex(), "")
}

fun String.removeSomeControlChar(): String // Some Control Char
{
    return this.replace("[\\p{Cntrl}\\p{Cc}\\p{Cf}\\p{Co}\\p{Cn}]".toRegex(), "")
}

fun String.removeFullControlChar(): String {
    return removeNonPrintable().replace("[\\r\\n\\t]".toRegex(), "")
}

fun String.removeOtherSymbolChar(): String // Some Control Char
{
    return this.replace("[\\p{So}]".toRegex(), "")
}

fun String.clearName(): String {
    return this.removeOtherSymbolChar()
        .replace(",", " ")
        .replace(".", " ")
        .replace("_", " ")
        .replace("\\s+".toRegex(), " ") // clear &nbsp and wide spaces
        .trim()
}

fun String.clearPath(): String {
    return this.removeOtherSymbolChar()
        .replace(",", " ")
        .replace(".", " ")
        .replace("\\s+".toRegex(), Typography.nbsp.toString()) // use &nbsp (don't break)
        .trim()
}

// https://github.com/YouROK/NUMParser/blob/be9eb56f1b4b53ff251d84f75186f162019ddac4/db/models/torrentDetails.go#L9
fun String.normalize(): String {
    return when {
        this.contains("movie", true) -> "movie"
        this.contains("series", true) -> "tv"
        this.equals("tvshow", true) -> "tv"
        else -> this.lowercase()
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/ext/TextView.kt
```kt
package ru.yourok.torrserve.ext

import android.graphics.Typeface
import android.text.Spannable
import android.text.SpannableString
import android.text.style.ForegroundColorSpan
import android.text.style.StyleSpan
import android.widget.TextView
import androidx.annotation.ColorInt

// textView.text = "" // Remove old text
// textView.append("Red Text", Color.RED)
// textView.append("Blue Bold Text", Color.BLUE, true)
fun TextView.append(string: String?, @ColorInt color: Int = 0, bold: Boolean = false) {
    if (string.isNullOrEmpty()) {
        return
    }
    val spannable: Spannable = SpannableString(string)
    if (color != 0)
        spannable.setSpan(
            ForegroundColorSpan(color),
            0,
            spannable.length,
            Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
        )
    if (bold)
        spannable.setSpan(
            StyleSpan(Typeface.BOLD),
            0,
            spannable.length,
            Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
        )
    append(spannable)
}
```

## ./app/src/main/java/ru/yourok/torrserve/ext/Net.kt
```kt
package ru.yourok.torrserve.ext

import java.net.URLEncoder

fun String.urlEncode(): String = URLEncoder.encode(this, "utf8")
```

## ./app/src/main/java/ru/yourok/torrserve/server/models/ffp/Disposition.kt
```kt
package ru.yourok.torrserve.server.models.ffp

data class Disposition(
    val attached_pic: Int,
    val clean_effects: Int,
    val comment: Int,
    val default: Int,
    val dub: Int,
    val forced: Int,
    val hearing_impaired: Int,
    val karaoke: Int,
    val lyrics: Int,
    val original: Int,
    val visual_impaired: Int
)
```

## ./app/src/main/java/ru/yourok/torrserve/server/models/ffp/TagsX.kt
```kt
package ru.yourok.torrserve.server.models.ffp

data class TagsX(
    val BPS: String?,
    val DURATION: String?,
    val NUMBER_OF_BYTES: String?,
    val NUMBER_OF_FRAMES: String?,
    val _STATISTICS_TAGS: String?,
    val _STATISTICS_WRITING_APP: String?,
    val _STATISTICS_WRITING_DATE_UTC: String?,
    val language: String?,
    val title: String?
)
```

## ./app/src/main/java/ru/yourok/torrserve/server/models/ffp/FFPModel.kt
```kt
package ru.yourok.torrserve.server.models.ffp

data class FFPModel(
    val format: Format,
    val streams: List<Stream>
)
```

## ./app/src/main/java/ru/yourok/torrserve/server/models/ffp/Tags.kt
```kt
package ru.yourok.torrserve.server.models.ffp

data class Tags(
    val creation_time: String,
    val encoder: String,
    val title: String?
)
```

## ./app/src/main/java/ru/yourok/torrserve/server/models/ffp/Format.kt
```kt
package ru.yourok.torrserve.server.models.ffp

data class Format(
    val bit_rate: String,
    val duration: String,
    val filename: String,
    val format_long_name: String,
    val format_name: String,
    val nb_programs: Int,
    val nb_streams: Int,
    val probe_score: Int,
    val size: String,
    val start_time: String,
    val tags: Tags?
)
```

## ./app/src/main/java/ru/yourok/torrserve/server/models/ffp/Stream.kt
```kt
package ru.yourok.torrserve.server.models.ffp

data class Stream(
    val avg_frame_rate: String,
    val bit_rate: String,
    val bits_per_raw_sample: String,
    val channel_layout: String?,
    val channels: Int,
    val codec_long_name: String,
    val codec_name: String,
    val codec_tag: String,
    val codec_tag_string: String,
    val codec_time_base: String,
    val codec_type: String,
    val display_aspect_ratio: String,
    val disposition: Disposition,
    val duration: String,
    val duration_ts: Long,
    val field_order: String,
    val has_b_frames: Int,
    val height: Int,
    val id: String,
    val index: Int,
    val level: Int,
    val nb_frames: String,
    val pix_fmt: String,
    val profile: String,
    val r_frame_rate: String,
    val sample_aspect_ratio: String,
    val sample_fmt: String,
    val sample_rate: String,
    val start_pts: Int,
    val start_time: String,
    val tags: TagsX?,
    val time_base: String,
    val width: Int
)
```

## ./app/src/main/java/ru/yourok/torrserve/server/models/torrent/TorrentDetails.kt
```kt
package ru.yourok.torrserve.server.models.torrent

data class TorrentDetails(
    val Title: String,
    val Name: String,
    val Names: List<String>,
    val Categories: String,
    val Size: String,
    val CreateDate: String,
    val Tracker: String,
    val Link: String,
    val Year: Int,
    val Peer: Int,
    val Seed: Int,
    val Magnet: String,
    val Hash: String,
    val IMDBID: String,
    val VideoQuality: Int,
    val AudioQuality: Int
)

```

## ./app/src/main/java/ru/yourok/torrserve/server/models/torrent/Torrent.kt
```kt
package ru.yourok.torrserve.server.models.torrent

data class Torrent(
    var title: String,
    var poster: String?,
    var category: String?,
    var data: String?,
    var timestamp: Long,
    var name: String,
    var hash: String,
    var stat: Int,
    var stat_string: String,
    var loaded_size: Long,
    var torrent_size: Long,
    var preloaded_bytes: Long,
    var preload_size: Long,
    var download_speed: Double,
    var upload_speed: Double,
    var total_peers: Int,
    var pending_peers: Int,
    var active_peers: Int,
    var connected_seeders: Int,
    var half_open_peers: Int,
    var bytes_written: Long,
    var bytes_written_data: Long,
    var bytes_read: Long,
    var bytes_read_data: Long,
    var bytes_read_useful_data: Long,
    var chunks_written: Long,
    var chunks_read: Long,
    var chunks_read_useful: Long,
    var chunks_read_wasted: Long,
    var pieces_dirtied_good: Long,
    var pieces_dirtied_bad: Long,
    var duration_seconds: Double?,
    var bit_rate: String?,

    var file_stats: List<FileStat>?
)

data class FileStat(
    var id: Int,
    var path: String,
    var length: Long
)
```

## ./app/src/main/java/ru/yourok/torrserve/server/local/TorrService.kt
```kt
package ru.yourok.torrserve.server.local

import android.app.Service
import android.content.Intent
import android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK
import android.os.Build
import android.os.IBinder
import android.util.Log
import androidx.core.app.NotificationCompat
import androidx.core.app.ServiceCompat
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.R
import ru.yourok.torrserve.ad.ADManager
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.atv.Utils
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.local.services.NotificationHelper
import ru.yourok.torrserve.server.local.services.NotificationTS
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.settings.Settings.isAccessibilityOn
import ru.yourok.torrserve.utils.Accessibility
import kotlin.concurrent.thread
import kotlin.coroutines.EmptyCoroutineContext

class TorrService : Service() {
    private val notification = NotificationHelper()
    private val serverFile = ServerFile()
    private val job = SupervisorJob()
    private val scope = CoroutineScope(Dispatchers.IO + job)
    private val serviceScope = CoroutineScope(EmptyCoroutineContext)

    override fun onBind(p0: Intent?): IBinder? = null
    override fun onCreate() {
        super.onCreate()
        scope.launch {
            try {
                ADManager.get()
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        job.cancel()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        intent?.let {
            val needToMoveToForeground = intent.getBooleanExtra(NEED_FOREGROUND_KEY, false)
            if (it.action != null) {
                when (it.action) {
                    ACTION_START -> {
                        startServer(needToMoveToForeground)
                        return START_STICKY
                    }

                    ACTION_STOP -> {
                        stopServer(intent.hasExtra("forceclose"))
                        return START_NOT_STICKY
                    }
                }
            }
        }
        return START_NOT_STICKY
    }

    private fun startServer(needForeground: Boolean = false) {
        serviceScope.launch {
            if (BuildConfig.DEBUG) Log.d("TorrService", "startServer(needForeground:$needForeground)")

            if (isLocal() && isAccessibilityOn() && !Accessibility.isEnabledService(App.context)) {
                if (BuildConfig.DEBUG) Log.d("TorrService", "Try to enable AssessibilityService")
                Accessibility.enableService(App.context, true)
            }

            if (serverFile.exists() && isLocal() && Api.echo().isEmpty()) {
                if (needForeground) { // fix start local server on boot
                    val builder = NotificationCompat.Builder(this@TorrService, NotificationTS().channelId)
                        .setSmallIcon(R.mipmap.ic_launcher)
                        .setContentTitle(getString(R.string.app_name))
                        .setContentText("Start Foreground")
                        .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                    ServiceCompat.startForeground(this@TorrService, NotificationTS().notificationId, builder.build(), FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK)
                }
                serverFile.run()
                notification.doBindService(this@TorrService)
            }

            Utils.updateAtvCards()
        }
    }

    private fun stopServer(forceClose: Boolean) {
        serviceScope.launch {
            if (BuildConfig.DEBUG) Log.d("TorrService", "stopServer(forceClose:$forceClose)")
            if (isLocal() && Api.echo().isNotEmpty())
                Api.shutdown()
            if (!isAccessibilityOn())
                serverFile.stop()
            notification.doUnbindService(this@TorrService)
            stopSelf()
            if (forceClose) {
                thread {
                    Thread.sleep(200)
                    Runtime.getRuntime().exit(0)
                }
            }
        }
    }

    companion object {
        const val ACTION_START = "ru.yourok.torrserve.server.action_start"
        const val ACTION_STOP = "ru.yourok.torrserve.server.action_stop"
        const val NEED_FOREGROUND_KEY = "need_foreground"


        fun start() {
            val context = App.context
            val intent = Intent(context, TorrService::class.java)
            intent.action = ACTION_START
            intent.putExtra(NEED_FOREGROUND_KEY, false)
            try {
                context.startService(intent)
            } catch (ex: IllegalStateException) {
                if (isLocal()) { // avoid ANR on remote
                    intent.putExtra(NEED_FOREGROUND_KEY, true)
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                        try {
                            context.startForegroundService(intent)
                        } catch (_: Exception) {
                            // need then call Service.startForeground() or ANR
                        }
                    }
                }
            }
        }

        fun stop() {
            val context = App.context
            val intent = Intent(context, TorrService::class.java)
            intent.action = ACTION_STOP
            try {
                context.startService(intent)
            } catch (ex: Exception) {
                ex.printStackTrace()
            }
        }

        fun wait(timeout: Int = -1): Boolean {
            var count = 0
            if (timeout < 0)
                count = -20
            while (Api.echo() == "") {
                Thread.sleep(1000)
                count++
                if (count > timeout)
                    return false
            }
            return true
        }

        fun isLocal(): Boolean {
            val host = Settings.getHost()
            return host.contains("://127.0.0.1") || host.contains("://localhost")
        }

        fun isInstalled(): Boolean = ServerFile().exists()
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/server/local/services/GlobalTorrService.kt
```kt
package ru.yourok.torrserve.server.local.services

import android.accessibilityservice.AccessibilityService
import android.content.Intent
import android.util.Log
import android.view.accessibility.AccessibilityEvent
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.local.ServerFile
import ru.yourok.torrserve.server.local.TorrService


class GlobalTorrService : AccessibilityService() {
    private val notification = NotificationHelper()
    private val serverFile = ServerFile()
    private val TAG = javaClass.simpleName.take(21)

    override fun onServiceConnected() {
        // Api.echo() is always empty
        if (serverFile.exists() && TorrService.isLocal()) {
            if (BuildConfig.DEBUG) Log.d(TAG, "onServiceConnected()")
            Api.shutdown()
            serverFile.run()
            notification.doBindService(this)
        }
    }

    override fun onAccessibilityEvent(event: AccessibilityEvent) {}

    override fun onInterrupt() {}

    override fun onUnbind(intent: Intent?): Boolean {
        notification.doUnbindService(this)
        return false
    }

}
```

## ./app/src/main/java/ru/yourok/torrserve/server/local/services/HomeWatch.kt
```kt
package ru.yourok.torrserve.server.local.services

import android.annotation.TargetApi
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.os.Build
import android.util.Log
import androidx.tvprovider.media.tv.TvContractCompat
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.atv.Utils
import ru.yourok.torrserve.atv.channels.ChannelProvider
import ru.yourok.torrserve.server.api.Api

@DelicateCoroutinesApi
@TargetApi(Build.VERSION_CODES.O)
class HomeWatch : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val action = intent.action
        if (action == null || !Utils.isAndroidTV) return

        val previewProgramId = intent.getLongExtra(TvContractCompat.EXTRA_PREVIEW_PROGRAM_ID, -1L)
        val watchNextInternalId = intent.getLongExtra(TvContractCompat.EXTRA_WATCH_NEXT_PROGRAM_ID, -1L)

        when (action) {

            TvContractCompat.ACTION_INITIALIZE_PROGRAMS -> {
                if (BuildConfig.DEBUG)
                    Log.d(TAG, "onReceive: ACTION_INITIALIZE_PROGRAMS")
            }

            TvContractCompat.ACTION_PREVIEW_PROGRAM_BROWSABLE_DISABLED -> {
                if (BuildConfig.DEBUG)
                    Log.d(TAG, "onReceive: ACTION_PREVIEW_PROGRAM_BROWSABLE_DISABLED, $previewProgramId")
                val hash = ChannelProvider("Torrents", App.context.getString(R.string.torrents)).findProgramHashById(previewProgramId)
                if (hash.isNotBlank()) {
                    GlobalScope.launch(Dispatchers.IO) {
                        try {
                            Api.remTorrent(hash)
                        } catch (e: Exception) {
                            e.printStackTrace()
                        }
                    }
                }
            }

            TvContractCompat.ACTION_WATCH_NEXT_PROGRAM_BROWSABLE_DISABLED -> {
                if (BuildConfig.DEBUG)
                    Log.d(TAG, "onReceive: ACTION_WATCH_NEXT_PROGRAM_BROWSABLE_DISABLED, $watchNextInternalId")
            }
        }
    }

    companion object {
        private const val TAG = "HomeWatch"
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/server/local/services/BCReceiver.kt
```kt
package ru.yourok.torrserve.server.local.services

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import ru.yourok.torrserve.atv.Utils
import ru.yourok.torrserve.server.local.TorrService
import ru.yourok.torrserve.settings.Settings

class BCReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context?, intent: Intent?) {
        if (Intent.ACTION_BOOT_COMPLETED == intent!!.action) {
            if (Settings.isBootStart()) {
                TorrService.start()
            }
            Utils.updateAtvCards()
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/server/local/services/NotificationHelper.kt
```kt
package ru.yourok.torrserve.server.local.services

import android.annotation.SuppressLint
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.ServiceConnection
import android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_SPECIAL_USE
import android.graphics.BitmapFactory
import android.os.Binder
import android.os.Build
import android.os.IBinder
import androidx.core.app.NotificationCompat
import androidx.core.app.ServiceCompat
import androidx.core.graphics.drawable.IconCompat
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.atv.Utils
import ru.yourok.torrserve.server.local.TorrService
import ru.yourok.torrserve.ui.activities.main.MainActivity
import ru.yourok.torrserve.utils.Accessibility

class NotificationHelper {
    private var mService: NotificationTS? = null

    private val mConnection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
            mService = (service as NotificationTS.LocalBinder).service
        }

        override fun onServiceDisconnected(name: ComponentName?) {
            mService = null
        }

    }

    fun doBindService(context: Context) {
        if (mService == null) {
            context.bindService(
                Intent(context, NotificationTS::class.java),
                mConnection,
                Context.BIND_AUTO_CREATE
            )
        }
    }

    fun doUnbindService(context: Context) {
        mService?.let {
            try {
                context.unbindService(mConnection)
            } catch (_: Exception) {
            }
        }
    }
}

class NotificationTS : Service() {
    private lateinit var notificationManager: NotificationManager
    private var builder: NotificationCompat.Builder? = null

    private val mBinder = LocalBinder()

    val notificationId = 42
    val channelId = "ru.yourok.torrserve"
    private val channelName = "ru.yourok.torrserve"
    private val lock = Any()

    inner class LocalBinder : Binder() {
        internal val service: NotificationTS
            get() = this@NotificationTS
    }

    override fun onCreate() {
        notificationManager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager
        createNotification()
    }

    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {
        return START_NOT_STICKY
    }

    @Suppress("DEPRECATION")
    override fun onDestroy() {
        synchronized(lock) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                stopForeground(STOP_FOREGROUND_REMOVE)
            } else
                stopForeground(true)
        }
    }

    override fun onBind(intent: Intent): IBinder {
        return mBinder
    }

    @SuppressLint("InlinedApi")
    private fun createNotification() {
        synchronized(lock) {
            val exitIntent = Intent(this, TorrService::class.java)
            exitIntent.action = TorrService.ACTION_STOP
            exitIntent.putExtra("forceclose", true)
            val exitPendingIntent = if ((Build.VERSION.SDK_INT >= Build.VERSION_CODES.M))
                PendingIntent.getService(this, 0, exitIntent, PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_ONE_SHOT)
            else
                PendingIntent.getService(this, 0, exitIntent, PendingIntent.FLAG_ONE_SHOT)

            val contentIntent = Intent(this, MainActivity::class.java)
            contentIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)

            val contentPendingIntent = if ((Build.VERSION.SDK_INT >= Build.VERSION_CODES.M))
                PendingIntent.getActivity(this, 0, contentIntent, PendingIntent.FLAG_IMMUTABLE)
            else
                PendingIntent.getActivity(this, 0, contentIntent, 0)

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                val channel =
                    NotificationChannel(channelId, channelName, NotificationManager.IMPORTANCE_LOW)
                this.getSystemService(NotificationManager::class.java)!!
                    .createNotificationChannel(channel)
            }
            val accEnabled = Accessibility.isEnabledService(App.context)
            val accessibilityNote = if (accEnabled) getText(R.string.accessibility_note) else getText(R.string.stat_running)
            if (builder == null) {
                builder = NotificationCompat.Builder(this, channelId)
                    .setContentTitle(getString(R.string.app_name))
                    .setContentText(getString(R.string.stat_running))
                    .setAutoCancel(false)
                    .setOngoing(true)
                    .setContentIntent(contentPendingIntent)
                    .setStyle(NotificationCompat.BigTextStyle().bigText(accessibilityNote))
                if (!accEnabled)
                    builder?.addAction(
                        android.R.drawable.ic_menu_close_clear_cancel,
                        this.getText(R.string.exit).toString().uppercase(),
                        exitPendingIntent
                    )
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)
                    builder?.setSmallIcon(IconCompat.createWithResource(this, R.drawable.ts_icon))
                else
                    builder?.setSmallIcon(R.drawable.ts_icon_white)
            } else
                builder?.setStyle(NotificationCompat.BigTextStyle().bigText(accessibilityNote))
            if (Utils.isAmazonTV)
                builder?.setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.ic_notification))

            builder?.let {
                ServiceCompat.startForeground(this, notificationId, it.build(), FOREGROUND_SERVICE_TYPE_SPECIAL_USE)
            }
        }
    }
}

```

## ./app/src/main/java/ru/yourok/torrserve/server/local/ServerFile.kt
```kt
package ru.yourok.torrserve.server.local

import android.util.Log
import com.topjohnwu.superuser.Shell
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.settings.Settings.useLocalAuth
import java.io.ByteArrayInputStream
import java.io.File

class ServerFile : File(App.context.filesDir, "torrserver") {
    private val lock = Any()
    private var shellJob: Shell.Job? = null
    private val setspath = Settings.getTorrPath()
    private val logfpath = Settings.logPath()
    private val logfile = if (logfpath.isNotEmpty()) File(logfpath, "torrserver.log").path else "/dev/null"
    private val accsFile = File(setspath, "accs.db")

    fun run(auth: String = Settings.getServerAuth()) {
        if (!exists())
            return
        synchronized(lock) {
            var akey = ""
            if (useLocalAuth() && auth.isNotBlank() && storeAccs(auth))
                akey = "--httpauth"
            Shell.enableVerboseLogging = BuildConfig.DEBUG
            if (shellJob == null) {
                if (BuildConfig.DEBUG) Log.d("*****", "CMD: $path -k --path $setspath --logpath $logfile $akey 1>>$logfile 2>&1 &")
                val shell = if (Settings.isRootStart()) Shell.Builder.create()
                    .build()
                else Shell.Builder.create()
                    .setFlags(Shell.FLAG_NON_ROOT_SHELL)
                    .build()
                shellJob = shell.newJob()
                    .add("export GODEBUG=madvdontneed=1")
                    .add("$path -k --path $setspath --logpath $logfile $akey 1>>$logfile 2>&1 &")
                shellJob?.exec()
            }
        }
    }

    fun stop() {
        if (!exists())
            return
        synchronized(lock) {
            // do nothing with -k startup switch?
            Shell.enableVerboseLogging = BuildConfig.DEBUG
            if (Shell.rootAccess())
                Shell.su("killall -9 torrserver").exec()
            else
                Shell.sh("killall -9 torrserver").exec()
            shellJob = null
        }
    }

    private fun storeAccs(auth: String): Boolean {
        if (auth.isNotBlank() && auth.split(":").size == 2) { // && !accsFile.exists()
            if (BuildConfig.DEBUG) Log.d("*****", "storeAccs() got auth \"$auth\"")
            try {
                // remove stale auth
                if (accsFile.exists() && accsFile.canWrite()) {
                    if (BuildConfig.DEBUG) Log.d("*****", "storeAccs() delete $accsFile")
                    accsFile.delete()
                }
                // create new accs.db
                val user = auth.split(":")[0].trim()
                val pass = auth.split(":")[1].trim()
                if (BuildConfig.DEBUG) Log.d("*****", "storeAccs() save auth \"$user:$pass\" to $accsFile")
                val content = "{\"$user\":\"$pass\"}"
                val inputStream = ByteArrayInputStream(content.toByteArray())
                if (accsFile.createNewFile())
                    inputStream.use { input ->
                        accsFile.outputStream().use { output ->
                            input.copyTo(output)
                            output.flush()
                            output.close()
                        }
                    }
            } catch (e: Exception) {
                return false
            }
            return true
//        } else {
//            if (BuildConfig.DEBUG) Log.d("*****", "storeAccs() empty|bad auth \"$auth\"")
        }
        return false
    }

//    fun md5(input: String): String {
//        val md = MessageDigest.getInstance("MD5")
//        return BigInteger(1, md.digest(input.toByteArray())).toString(16).padStart(32, '0')
//    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/server/api/Api.kt
```kt
package ru.yourok.torrserve.server.api

import com.google.gson.Gson
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.server.models.ffp.FFPModel
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.server.models.torrent.TorrentDetails
import ru.yourok.torrserve.settings.BTSets
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.utils.Net
import java.io.InputStream
import java.net.URLEncoder

object Api {
    /// all getAuth / postAuth calls can throw network exceptions
    class ApiException(msg: String, val code: Int) : Exception(msg)

    /// Server
    fun echo(): String {
        return try {
            val host = Net.getHostUrl("/echo")
            Net.getAuth(host)
        } catch (e: Exception) {
            if (BuildConfig.DEBUG) println(e.message)
            ""
        }
    }

    /* used for remote server version check */
    fun remoteEcho(url: String): String {
        return try {
            val host = "$url/echo"
            Net.getAuth(host, 3000) // fast response, in ms
        } catch (e: Exception) {
            if (BuildConfig.DEBUG) println(e.message)
            ""
        }
    }

    fun shutdown(): String {
        return try {
            val host = Net.getHostUrl("/shutdown")
            Net.getAuth(host)
        } catch (e: Exception) {
            if (BuildConfig.DEBUG) println(e.message)
            ""
        }
    }

    /// Torrents
    fun addTorrent(link: String, title: String, poster: String, category: String, data: String, save: Boolean): Torrent {
        val host = Net.getHostUrl("/torrents")
        val req = TorrentReq("add", link = link, title = title, poster = poster, category = category, data = data, save_to_db = save).toString()
        val resp = postJson(host, req)
        return Gson().fromJson(resp, Torrent::class.java)
    }

    fun getTorrent(hash: String): Torrent {
        val host = Net.getHostUrl("/torrents")
        val req = TorrentReq("get", hash).toString()
        val resp = postJson(host, req)
        return Gson().fromJson(resp, Torrent::class.java)
    }

    fun remTorrent(hash: String) {
        val host = Net.getHostUrl("/torrents")
        val req = TorrentReq("rem", hash).toString()
        postJson(host, req)
    }

    fun listTorrent(): List<Torrent> {
        val host = Net.getHostUrl("/torrents")
        val req = TorrentReq("list").toString()
        val resp = postJson(host, req)
        return if (Settings.sortTorrByTitle)
            Gson().fromJson(resp, Array<Torrent>::class.java).toList().sortedWith(compareBy { it.title })
        else
            Gson().fromJson(resp, Array<Torrent>::class.java).toList()
    }

    fun dropTorrent(hash: String) {
        val host = Net.getHostUrl("/torrents")
        val req = TorrentReq("drop", hash).toString()
        postJson(host, req)
    }

    fun uploadTorrent(file: InputStream, title: String, poster: String, category: String, data: String, save: Boolean): Torrent {
        val host = Net.getHostUrl("/torrent/upload")
        val resp = Net.uploadAuth(host, title, poster, category, data, file, save)
        return Gson().fromJson(resp, Torrent::class.java)
    }

    // Settings
    fun getSettings(): BTSets {
        val host = Net.getHostUrl("/settings")
        val req = Request("get").toString()
        val resp = postJson(host, req)
        return Gson().fromJson(resp, BTSets::class.java)
    }

    fun setSettings(sets: BTSets) {
        val host = Net.getHostUrl("/settings")
        val req = SettingsReq("set", sets).toString()
        postJson(host, req)
    }

    fun defSettings() {
        val host = Net.getHostUrl("/settings")
        val req = Request("def").toString()
        postJson(host, req)
    }

    // Viewed
    fun listViewed(hash: String): List<Viewed> {
        val host = Net.getHostUrl("/viewed")
        val req = ViewedReq("list", hash).toString()
        val resp = postJson(host, req)
        if (resp.isBlank())
            return emptyList()
        return Gson().fromJson(resp, Array<Viewed>::class.java).toList()
    }

    fun setViewed(hash: String, index: Int) {
        val host = Net.getHostUrl("/viewed")
        val req = ViewedReq("set", hash, index).toString()
        postJson(host, req)
    }

    fun remViewed(hash: String, id: Int = -1) {
        val host = Net.getHostUrl("/viewed")
        val req = if (id > 0) ViewedReq("rem", hash, id).toString() else ViewedReq("rem", hash).toString()
        postJson(host, req)
    }

    fun getFFP(hash: String, id: Int): FFPModel? {
        val host = Net.getHostUrl("/ffp/${hash}/${id}")
        val resp = Net.getAuth(host, 30000) // long response, in ms
        if (resp.isBlank())
            return null
        return Gson().fromJson(resp, FFPModel::class.java)
    }

    fun searchTorrents(query: String): List<TorrentDetails>? {
        val host = Net.getHostUrl("/search?query=${URLEncoder.encode(query, "UTF-8")}")
        val resp = Net.getAuth(host)
        if (resp.isBlank())
            return null
        return Gson().fromJson(resp, Array<TorrentDetails>::class.java).toList()
    }

    private fun postJson(url: String, json: String): String {
        return Net.postAuth(url, json)
    }

    suspend fun getMatrixVersionInt(): Int {
        return try {
            var verStr: String
            withContext(Dispatchers.IO) {
                verStr = echo()
            }
            val isMatrix = verStr.contains("MatriX", true)
            val numbers = Regex("[0-9]+").findAll(verStr)
                .map(MatchResult::value)
                .toList()
            val verMajor = numbers.firstOrNull()?.toIntOrNull() ?: 0
            //val verMinor = numbers.getOrNull(1)?.toIntOrNull() ?: 0
            //Log.i("getMatrixVersionInt", "$verMajor")
            return if (isMatrix) verMajor else 0
        } catch (e: Exception) {
            0
        }
    }

    suspend fun haveCategories(): Boolean {
        var vi = 0
        coroutineScope {
            val data = async(Dispatchers.IO) {
                getMatrixVersionInt()
            }
            val result = data.await()
            vi = result
        }
        return vi > 131 // MatriX.132 add Categories
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/server/api/Request.kt
```kt
package ru.yourok.torrserve.server.api

import com.google.gson.Gson
import ru.yourok.torrserve.settings.BTSets

open class Request(val action: String) {
    override fun toString(): String {
        return Gson().toJson(this)
    }
}

class SettingsReq(
    action: String,
    val Sets: BTSets
) : Request(action)

class TorrentReq(
    action: String,
    val hash: String = "",
    val link: String = "",
    val title: String = "",
    val poster: String = "",
    val category: String = "",
    val data: String = "",
    val save_to_db: Boolean = false,
) : Request(action)

class ViewedReq(
    action: String,
    val hash: String = "",
    val file_index: Int = -1
) : Request(action)

data class Viewed(
    val hash: String,
    val file_index: Int
)
```

## ./app/src/main/java/ru/yourok/torrserve/utils/Http.kt
```kt
package ru.yourok.torrserve.utils

import android.net.Uri
import android.os.Build
import info.guardianproject.netcipher.NetCipher
import java.io.IOException
import java.io.InputStream
import java.net.HttpURLConnection
import java.net.HttpURLConnection.HTTP_MOVED_PERM
import java.net.HttpURLConnection.HTTP_MOVED_TEMP
import java.net.HttpURLConnection.HTTP_OK
import java.net.HttpURLConnection.HTTP_PARTIAL
import java.net.HttpURLConnection.HTTP_SEE_OTHER
import java.net.URL
import java.security.GeneralSecurityException
import java.util.Locale
import java.util.zip.GZIPInputStream
import javax.net.ssl.HostnameVerifier
import javax.net.ssl.HttpsURLConnection


/**
 * Created by yourok on 07.11.17.
 */

class Http(url: Uri) {
    private var currUrl: String = url.toString()
    private var isConn: Boolean = false
    private var connection: HttpURLConnection? = null
    private var errMsg: String = ""
    private var inputStream: InputStream? = null
    private var auth: String = ""

    private var timeout = 30000

    fun connect() {
        connect(0)
    }

    private fun connect(pos: Long): Long {

        var responseCode: Int
        var redirCount = 0
        do {
            if (!currUrl.contains("://"))
                currUrl = currUrl.replace(":/", "://")

            val url = URL(currUrl)

            connection = if (currUrl.startsWith("https"))
                NetCipher.getHttpsURLConnection(url)
                    .also {
                        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
                            val trustAllHostnames = HostnameVerifier { _, _ ->
                                true // Just allow them all
                            }
                            HttpsURLConnection.setDefaultHostnameVerifier(trustAllHostnames)
                        }
                        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {
                            try {
                                // Only TLSv1.2 and TLSv1.3 protocol available and trust all certs (insecure).
                                HttpsURLConnection.setDefaultSSLSocketFactory(TlsSocketFactory())
                            } catch (_: GeneralSecurityException) {
                            }
                        }
                    }
            else
                NetCipher.getHttpURLConnection(url)
            connection!!.connectTimeout = timeout
            connection!!.readTimeout = 15000
            connection!!.requestMethod = "GET"
            connection!!.doInput = true

            connection!!.setRequestProperty("UserAgent", "DWL/1.1.0 (Linux; Android;)")
            connection!!.setRequestProperty("Accept", "*/*")
            connection!!.setRequestProperty("Accept-Encoding", "gzip")
            if (pos > 0)
                connection!!.setRequestProperty("Range", "bytes=$pos-")

            if (auth.isNotBlank())
                connection!!.setRequestProperty("Authorization", auth)

            connection!!.connect()

            responseCode = connection!!.responseCode
            var redirected =
                responseCode == HTTP_MOVED_PERM || responseCode == HTTP_MOVED_TEMP || responseCode == HTTP_SEE_OTHER
            if (redirected) {
                currUrl = connection!!.getHeaderField("Location")
                connection!!.disconnect()
                redirCount++
            }

            if (responseCode == 429) {
                var retry = connection!!.getHeaderField("Retry-After")
                if (retry.isNullOrEmpty() || retry == "0")
                    retry = "1"
                redirCount++
                redirected = true
                Thread.sleep(retry.toLong() * 1000L)
            }

            if (redirCount > 5) {
                throw IOException("Error connect to: $currUrl too many redirects")
            }
        } while (redirected)


        if (responseCode != HTTP_OK && responseCode != HTTP_PARTIAL) {
            throw IOException("Error connect to: " + currUrl + " " + connection!!.responseMessage)
        }
        isConn = true
        if (connection!!.getHeaderField("Accept-Ranges")?.lowercase(Locale.getDefault()) == "none")
            return -1
        return getSize()
    }

    fun setTimeout(timeout: Int) {
        this.timeout = timeout
    }

    fun isConnected(): Boolean {
        return isConn
    }

    fun setAuth(auth: String) {
        this.auth = auth
    }

    fun getSize(): Long {
        if (!isConn)
            return 0

        var cl = connection!!.getHeaderField("Content-Range")
        try {
            if (!cl.isNullOrEmpty()) {
                val cr = cl.split("/")
                if (cr.isNotEmpty())
                    cl = cr.last()
                return cl.toLong()
            }
        } catch (_: Exception) {
        }

        cl = connection!!.getHeaderField("Content-Length")
        try {
            if (!cl.isNullOrEmpty()) {
                return cl.toLong()
            }
        } catch (_: Exception) {
        }

        return 0
    }

    fun getUrl(): String {
        return currUrl
    }

    fun getInputStream(): InputStream? {
        if (inputStream == null && connection != null) {
            inputStream = if ("gzip" == connection?.contentEncoding)
                GZIPInputStream(connection!!.inputStream)
            else
                connection!!.inputStream
        }

        return inputStream
    }

    fun read(b: ByteArray): Int {
        if (!isConn or (getInputStream() == null))
            throw IOException("connect before read")
        var sz = getInputStream()!!.read(b)
        var size = sz
        while (sz > 0 && sz < b.size / 2) {
            try {
                sz = getInputStream()!!.read(b, size, b.size - size)
                if (sz > 0)
                    size += sz
                else
                    break
            } catch (e: Exception) {
                e.printStackTrace()
                break
            }
        }
        return size
    }

    fun getErrorMessage(): String {
        return errMsg
    }

    fun close() {
        try {
            inputStream?.close()
        } catch (_: Exception) {
        }
        connection?.disconnect()
        isConn = false
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/utils/TlsSocketFactory.kt
```kt
package ru.yourok.torrserve.utils

import org.conscrypt.Conscrypt
import java.io.IOException
import java.net.InetAddress
import java.net.Socket
import java.security.KeyManagementException
import java.security.NoSuchAlgorithmException
import java.security.Provider
import java.security.Security
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocket
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.TrustManager

class TlsSocketFactory : SSLSocketFactory {
    private val enabledProtocols: Array<String>
    private val delegate: SSLSocketFactory

    constructor(enabledProtocols: Array<String>) {
        this.enabledProtocols = enabledProtocols
        this.delegate = socketFactory
    }

    constructor() {
        this.enabledProtocols = TLS_RESTRICTED
        this.delegate = socketFactory
    }

    constructor(base: SSLSocketFactory) {
        this.enabledProtocols = TLS_RESTRICTED
        this.delegate = base
    }

    override fun getDefaultCipherSuites(): Array<String> {
        return delegate.defaultCipherSuites
    }

    override fun getSupportedCipherSuites(): Array<String> {
        return delegate.supportedCipherSuites
    }

    @Throws(IOException::class)
    override fun createSocket(): Socket {
        return patch(delegate.createSocket())
    }

    @Throws(IOException::class)
    override fun createSocket(s: Socket, host: String, port: Int, autoClose: Boolean): Socket {
        return patch(delegate.createSocket(s, host, port, autoClose))
    }

    @Throws(IOException::class)
    override fun createSocket(host: String, port: Int): Socket {
        return patch(delegate.createSocket(host, port))
    }

    @Throws(IOException::class)
    override fun createSocket(host: String, port: Int, localHost: InetAddress, localPort: Int): Socket {
        return patch(delegate.createSocket(host, port, localHost, localPort))
    }

    @Throws(IOException::class)
    override fun createSocket(host: InetAddress, port: Int): Socket {
        return patch(delegate.createSocket(host, port))
    }

    @Throws(IOException::class)
    override fun createSocket(address: InetAddress, port: Int, localAddress: InetAddress, localPort: Int): Socket {
        return patch(delegate.createSocket(address, port, localAddress, localPort))
    }

    private fun patch(s: Socket): Socket {
        if (s is SSLSocket) {
            s.enabledProtocols = enabledProtocols
        }
        return s
    }

    companion object {
        private var conscrypt: Provider? = null
        val TLS_MODERN: Array<String> = arrayOf("TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3")
        val TLS_RESTRICTED: Array<String> = arrayOf("TLSv1.2", "TLSv1.3")

        @get:Throws(NoSuchAlgorithmException::class, KeyManagementException::class)
        private val socketFactory: SSLSocketFactory
            get() {
                if (conscrypt == null) {
                    conscrypt = Conscrypt.newProvider()
                    // Add as provider
                    Security.insertProviderAt(conscrypt, 1)
                }
                val context = SSLContext.getInstance("TLS", conscrypt)
                context.init(null, arrayOf<TrustManager>(AllTrustManager()), null)
                return context.socketFactory
            }
    }
}

```

## ./app/src/main/java/ru/yourok/torrserve/utils/AllTrustManager.kt
```kt
package ru.yourok.torrserve.utils

import android.annotation.SuppressLint
import java.security.cert.X509Certificate
import javax.net.ssl.X509TrustManager

@SuppressLint("CustomX509TrustManager")
class AllTrustManager : X509TrustManager {
    @SuppressLint("TrustAllX509TrustManager")
    override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) {
        // Perform no check whatsoever on the validity of the SSL certificate
    }

    @SuppressLint("TrustAllX509TrustManager")
    override fun checkServerTrusted(chain: Array<X509Certificate>, authType: String) {
        // Perform no check whatsoever on the validity of the SSL certificate
    }

    override fun getAcceptedIssuers(): Array<X509Certificate> {
        return arrayOf()
    }
}

```

## ./app/src/main/java/ru/yourok/torrserve/utils/CImageSpan.kt
```kt
package ru.yourok.torrserve.utils

import android.graphics.Canvas
import android.graphics.Paint
import android.graphics.Rect
import android.graphics.drawable.Drawable
import android.text.style.ImageSpan
import java.lang.ref.WeakReference

class CImageSpan(dr: Drawable) : ImageSpan(dr) {
    private var mDrawableRef: WeakReference<Drawable>? = null
    override fun getSize(paint: Paint, text: CharSequence?, start: Int, end: Int, fm: Paint.FontMetricsInt?): Int {
        val d = cachedDrawable
        val rect: Rect = d!!.bounds
        val pfm = paint.fontMetricsInt
        if (fm != null) {
            fm.ascent = -rect.height() / 2 + pfm.ascent / 2
            fm.descent = 0.coerceAtLeast(rect.height() / 2 + pfm.ascent / 2)
            fm.top = fm.ascent
            fm.bottom = fm.descent
        }
        return rect.right
    }

    override fun draw(canvas: Canvas, text: CharSequence?, start: Int, end: Int, x: Float, top: Int, y: Int, bottom: Int, paint: Paint) {
        val b = cachedDrawable!!
        canvas.save()
        val transY = (bottom + top) / 2 - b.bounds.height() / 2
        canvas.translate(x, transY.toFloat())
        b.draw(canvas)
        canvas.restore()
    }

    // Redefined locally because it is a private member from DynamicDrawableSpan
    private val cachedDrawable: Drawable?
        get() {
            val wr: WeakReference<Drawable>? = mDrawableRef
            var d: Drawable? = null
            if (wr != null) d = wr.get()
            if (d == null) {
                d = drawable
                mDrawableRef = WeakReference(d)
            }
            return d
        }
}
```

## ./app/src/main/java/ru/yourok/torrserve/utils/TorrentHelper.kt
```kt
package ru.yourok.torrserve.utils

import android.content.Context
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.ext.urlEncode
import ru.yourok.torrserve.server.api.Api
import ru.yourok.torrserve.server.models.torrent.FileStat
import ru.yourok.torrserve.server.models.torrent.Torrent
import ru.yourok.torrserve.ui.dialogs.InfoDialog
import java.io.File
import java.util.Locale

object TorrentHelper {
    const val T_STATE_ADDED = 0
    const val T_STATE_GETINFO = 1
    const val T_STATE_PRELOAD = 2
    const val T_STATE_WORKING = 3
    const val T_STATE_CLOSED = 4
    const val T_STATE_INDB = 5

    fun getPlayableFiles(torr: Torrent): List<FileStat> {
        if (torr.file_stats.isNullOrEmpty())
            return emptyList()

        val files = torr.file_stats
        val retList = mutableListOf<FileStat>()

        files?.forEach {
            val path = it.path
            if (Mime.getMimeType(path) != "*/*") {
                val size = it.length
                if (File(path).extension.lowercase() == "m2ts" ||
                    File(path).extension.lowercase() == "mts" ||
                    File(path).extension.lowercase() == "ts"
                ) {
                    if (size > 524288000L) // 500MB 1073741824 = 1GB
                        retList.add(it)
                } else
                    retList.add(it)
            } else if (path.lowercase(Locale.getDefault()).contains("bdmv/index.bdmv")) {
                retList.add(it)
            }
        }
        return retList
    }

    fun waitFiles(hash: String): Torrent? {
        var count = 0
        while (true) {
//            if (BuildConfig.DEBUG) Log.d("*****", "waitFiles($count) for $hash")
            try {
                val torr = Api.getTorrent(hash)
                if ((torr.file_stats?.size ?: 0) > 0 || count > 59)
                    return torr
                count++
                Thread.sleep(1000)
            } catch (e: Exception) {
                count++
                if (count > 59)
                    return null
                Thread.sleep(1000)
            }
        }
    }

    fun getTorrentMagnet(torr: Torrent): String {
        return "magnet:?xt=urn:btih:${torr.hash}&dn=${torr.title.urlEncode()}"
    }

    fun getTorrentPlayLink(torr: Torrent, index: Int): String {
        val file = findFile(torr, index)
        val name = file?.let { File(it.path).name } ?: torr.title
        return Net.getHostUrl("/stream/${name.urlEncode()}?link=${torr.hash}&index=${index}&play")
    }

    fun getFileLink(torr: Torrent, file: FileStat?): String {
        val name = file?.let { File(it.path).name } ?: torr.title
        return Net.getHostUrl("/stream/${name.urlEncode()}?link=${torr.hash}&index=${file?.id}&play")
    }

    private fun getTorrentPreloadLink(torr: Torrent, index: Int): String {
        return Net.getHostUrl("/stream/${torr.title.urlEncode()}?link=${torr.hash}&index=${index}&preload")
    }

    suspend fun preloadTorrent(torr: Torrent, index: Int) = withContext(Dispatchers.IO) {
        try {
            val link = getTorrentPreloadLink(torr, index)
            Net.getAuth(link)
        } catch (_: Exception) {
            // FIXME: Net.getAuth(link) throw and error on request timeout (but preload works)
        }
    }

    fun findFile(torrent: Torrent, index: Int): FileStat? {
        torrent.file_stats?.forEach {
            if (it.id == index)
                return it
        }
        return null
    }

    fun findIndex(torrent: Torrent, file: FileStat): Int {
        val list = getPlayableFiles(torrent)
        list.forEachIndexed { index, fileStat ->
            if (fileStat.id == file.id)
                return index
        }
        return -1
    }

    suspend fun showFFPInfo(context: Context, torrLink: String, torrent: Torrent) {
        val probe = try { // stats 1st torrent file
            if (torrLink.isNotBlank())
                App.toast("${context.getString(R.string.stat_string_info)}‚Ä¶", true)
            val files = getPlayableFiles(torrent)
            if (files.isNotEmpty()) {
                Api.getFFP(torrent.hash, files.first().id)
            } else {
                null
            }
        } catch (e: Exception) {
            App.toast(e.message ?: context.getString(R.string.error_retrieve_data))
            null
        }
        probe?.let { ffp ->
            val format = ffp.format
            val streams = ffp.streams
            val videoDesc = mutableListOf<String>()
            val audioDesc = mutableListOf<String>()
            val subsDesc = mutableListOf<String>()
            try {
                streams.forEach { st -> // count in format.nb_streams
                    when (st.codec_type) {
                        "video" -> {
                            if (st.codec_name != "mjpeg" && st.codec_name != "png") { // exclude posters
                                videoDesc.add("${st.width}x${st.height}")
                                videoDesc.add(st.codec_long_name.ifEmpty { st.codec_name.uppercase() })
                            }
                        }

                        "audio" -> {
                            var audio = ""
                            st.tags?.let {
                                it.language?.let { lang ->
                                    audio = if (!it.title.isNullOrBlank())
                                        "[" + lang.uppercase() + "] " + it.title.uppercase().cleanup()
                                    else
                                        "[" + lang.uppercase() + "]"
                                } ?: { audio = it.title?.uppercase()?.cleanup().toString() }
                            }
                            val channels = st.channel_layout ?: (st.channels.toString() + "CH")
                            if (audio.isNotBlank())
                                audioDesc.add(audio + " " + st.codec_name.uppercase() + "/" + channels)
                            else
                                audioDesc.add(st.codec_name.uppercase() + "/" + channels)
                        }

                        "subtitle" -> {
                            var titles = ""
                            st.tags?.let {
                                it.language?.let { lang ->
                                    titles = if (it.title.isNullOrBlank())
                                        "[" + lang.uppercase() + "]"
                                    else
                                        "[" + lang.uppercase() + "] " + it.title.cleanup()
                                } ?: { titles = it.title?.cleanup().toString() }
                                subsDesc.add(titles)
                            }
                        }

                        else -> {
                            // TODO
                        }
                    }
                }
                val title = format.tags?.title ?: torrent.title
                val category = torrent.category ?: ""
                val size = Format.byteFmt(ffp.format.size.toDouble())
                val duration = Format.durFmtS(ffp.format.duration.toDouble())
                val bitrate = Format.speedFmt(ffp.format.bit_rate.toDouble() / 8)
                withContext(Dispatchers.Main) {
                    InfoDialog(context).show(torrLink, title.trim(), category, format.format_long_name, videoDesc.joinToString(" ‚óè "), audioDesc.joinToString(" ‚óè "), subsDesc.joinToString(" ‚óè "), size, duration, bitrate)
                }
            } catch (e: Exception) {
                e.message?.let { App.toast(it) }
            }
        }
    }

    private fun String.cleanup(): String {
        return this
            .replace("[", "")
            .replace("]", "")
            .trim()
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/utils/Accessibility.kt
```kt
package ru.yourok.torrserve.utils

import android.content.ActivityNotFoundException
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Handler
import android.os.Looper
import android.provider.Settings
import com.topjohnwu.superuser.Shell
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.server.local.services.GlobalTorrService


object Accessibility {
    private fun openAccessibilitySettings(context: Context): Boolean {
        val intent = Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS)
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK or Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS)
        return try {
            context.startActivity(intent)
            true
        } catch (e: Exception) {
            false
        }
    }

    private fun openTvAccessibilitySettings(context: Context): Boolean {
        val tvintent = Intent("android.intent.action.MAIN")
        tvintent.addCategory("android.intent.category.LAUNCHER")
        tvintent.setClassName("com.android.tv.settings", "com.android.tv.settings.system.AccessibilityActivity")
        tvintent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK or Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS)
        return try {
            context.startActivity(tvintent)
            true
        } catch (e: ActivityNotFoundException) {
            tvintent.setClassName("com.android.tv.settings", "com.android.tv.settings.MainSettings")
            try {
                context.startActivity(tvintent)
                true
            } catch (e: Exception) {
                false
            }
        } catch (e: Exception) {
            false
        }
    }

    private fun openSettings(context: Context) {
        val intent = Intent(Settings.ACTION_SETTINGS)
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK or Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS)
        try {
            context.startActivity(intent)
        } catch (e: Exception) {
            e.printStackTrace()
            e.message?.let { App.toast(it) }
        }
    }

    private fun showAccessibilitySettings(context: Context) {
        if (isPackageInstalled(context, "com.android.tv.settings")) {
            openTvAccessibilitySettings(context)
        } else if (isPackageInstalled(context, "com.android.settings")) {
            openAccessibilitySettings(context)
        } else {
            openSettings(context)
        }
    }

    fun enableService(requireContext: Context, enable: Boolean) {
        val permission = "android.permission.WRITE_SECURE_SETTINGS"
        if (!Permission.isPermissionGranted(requireContext, permission) && Shell.rootAccess()) {
            Shell.su("pm grant ${requireContext.packageName} $permission").exec()
        }
        if (Permission.isPermissionGranted(requireContext, permission)) {
            val contentResolver = requireContext.contentResolver
            var enServices = Settings.Secure.getString(contentResolver, Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES)
            val myService = requireContext.packageName + "/" + GlobalTorrService::class.java.name
            enServices = if (enable) {
                if (enServices.isNullOrEmpty()) {
                    myService
                } else {
                    "$enServices:$myService"
                }
            } else {
                enServices.replace(myService, "")
            }
            try {
                Settings.Secure.putString(contentResolver, Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES, enServices)
                if (enable) Settings.Secure.putString(contentResolver, Settings.Secure.ACCESSIBILITY_ENABLED, "1")
            } catch (e: Exception) {
                e.message?.let { App.toast(it) }
                Handler(Looper.getMainLooper()).postDelayed({
                    showAccessibilitySettings(requireContext)
                }, App.SHORT_TOAST_DURATION.toLong()) // as in toast duration
            }
        } else {
            val appName = App.context.getString(R.string.app_name)
            if (enable)
                App.toast(App.context.getString(R.string.accessibility_manual_on, appName), true)
            else
                App.toast(App.context.getString(R.string.accessibility_manual_off, appName), true)
            Handler(Looper.getMainLooper()).postDelayed({
                showAccessibilitySettings(requireContext)
            }, App.LONG_TOAST_DURATION.toLong()) // as in toast duration
        }
    }

    fun isEnabledService(requireContext: Context): Boolean {
        val contentResolver = requireContext.contentResolver
        val enServices = Settings.Secure.getString(contentResolver, Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES)
        val myService = requireContext.packageName + "/" + GlobalTorrService::class.java.name
        if (enServices?.contains(myService) == true) return true
        return false
    }

    fun isPackageInstalled(context: Context, packageName: String): Boolean {
        return try {
            context.packageManager.getPackageInfo(packageName, 0)
            true
        } catch (e: PackageManager.NameNotFoundException) {
            false
        }
    }

    fun isPackageEnabled(context: Context, packageName: String): Boolean {
        return try {
            context.packageManager.getApplicationInfo(packageName, 0).enabled
        } catch (e: PackageManager.NameNotFoundException) {
            false
        }
    }

}
```

## ./app/src/main/java/ru/yourok/torrserve/utils/Permission.kt
```kt
package ru.yourok.torrserve.utils

import android.Manifest
import android.app.Activity
import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import androidx.core.app.ActivityCompat
import com.google.android.material.snackbar.Snackbar
import ru.yourok.torrserve.R
import ru.yourok.torrserve.atv.Utils.isChangHong
import kotlin.concurrent.thread


object Permission {
    fun requestPermissionWithRationale(activity: Activity) {
        if (!isChangHong) // TODO
            thread {
                if (ActivityCompat.shouldShowRequestPermissionRationale(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
                    Snackbar.make(activity.findViewById(android.R.id.content) ?: return@thread, R.string.permission_storage_msg, Snackbar.LENGTH_INDEFINITE)
                        .setAction(R.string.permission_btn) {
                            ActivityCompat.requestPermissions(activity, arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE), 1)
                        }
                        .show()
                } else {
                    ActivityCompat.requestPermissions(activity, arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE), 1)
                }
            }
    }

    fun isPermissionGranted(context: Context, permission: String): Boolean {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            return context.checkCallingOrSelfPermission(permission) == PackageManager.PERMISSION_GRANTED
        }
        return true
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/utils/SpanFormat.kt
```kt
package ru.yourok.torrserve.utils

import android.text.SpannableStringBuilder
import android.text.Spanned
import android.text.SpannedString
import java.util.regex.Pattern

/*
* Copyright ¬© 2014 George T. Steel
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//https://github.com/george-steel/android-utils/blob/master/src/org/oshkimaadziig/george/androidutils/SpanFormatter.java
/**
 * Provides [String.format] style functions that work with [Spanned] strings and preserve formatting.
 *
 * @author George T. Steel
 */
object SpanFormat {
    private val FORMAT_SEQUENCE: Pattern = Pattern.compile("%([0-9]+\\$|<?)([^a-zA-z%]*)([[a-zA-Z%]&&[^tT]]|[tT][a-zA-Z])")

    /**
     * Version of [String.format] that works on [Spanned] strings to preserve rich text formatting.
     * Both the `format` as well as any `%s args` can be Spanned and will have their formatting preserved.
     * Due to the way [android.text.Spannable]s work, any argument's spans will can only be included **once** in the result.
     * Any duplicates will appear as text only.
     *
     * @param format the format string (see [java.util.Formatter.format])
     * @param args
     * the list of arguments passed to the formatter. If there are
     * more arguments than required by `format`,
     * additional arguments are ignored.
     * @return the formatted string (with spans).
     */
    fun format(format: CharSequence?, vararg args: Any?): SpannedString {
        return format(java.util.Locale.getDefault(), format, *args)
    }

    /**
     * Version of [String.format] that works on [Spanned] strings to preserve rich text formatting.
     * Both the `format` as well as any `%s args` can be Spanned and will have their formatting preserved.
     * Due to the way [android.text.Spannable]s work, any argument's spans will can only be included **once** in the result.
     * Any duplicates will appear as text only.
     *
     * @param locale
     * the locale to apply; `null` value means no localization.
     * @param format the format string (see [java.util.Formatter.format])
     * @param args
     * the list of arguments passed to the formatter.
     * @return the formatted string (with spans).
     * @see String.format
     */
    fun format(locale: java.util.Locale, format: CharSequence?, vararg args: Any?): SpannedString {
        val out = SpannableStringBuilder(format)
        var i = 0
        var argAt: Int = -1
        while (i < out.length) {
            val m: java.util.regex.Matcher = FORMAT_SEQUENCE.matcher(out)
            if (!m.find(i))
                break
            i = m.start()
            val exprEnd: Int = m.end()
            val argTerm: String? = m.group(1)
            val modTerm: String? = m.group(2)
            val typeTerm: String? = m.group(3)
            var cookedArg: CharSequence
            when (typeTerm) {
                "%" -> cookedArg = "%"
                "n" -> cookedArg = "\n"
                else -> {
                    val argIdx: Int = when (argTerm) {
                        "" -> ++argAt
                        "<" -> argAt
                        else -> argTerm!!.substring(0, argTerm.length - 1).toInt() - 1
                    }
                    val argItem: Any? = args[argIdx]
                    cookedArg = if ((typeTerm == "s") && argItem is Spanned) {
                        argItem
                    } else {
                        String.format(locale, "%$modTerm$typeTerm", argItem)
                    }
                }
            }
            out.replace(i, exprEnd, cookedArg)
            i += cookedArg.length
        }
        return SpannedString(out)
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/utils/Mime.kt
```kt
package ru.yourok.torrserve.utils

import java.io.File
import java.util.Locale

/**
 * Created by yourok on 03.03.18.
 */
object Mime {

    fun getMimeType(filepath: String): String {
        val ext = File(filepath).extension.lowercase(Locale.getDefault())
        if (extVideo.contains(ext))
            return "video/*"
        if (extAudio.contains(ext))
            return "audio/*"
        return "*/*"
    }

    val extVideo = listOf(
        "3g2",
        "3gp",
        "aaf",
        "asf",
        "avchd",
        "avi",
        "drc",
        "flv",
        "iso",
        "m2v",
        "m2ts",
        "m4p",
        "m4v",
        "mkv",
        "mng",
        "mov",
        "mp2",
        "mp4",
        "mpe",
        "mpeg",
        "mpg",
        "mpv",
        "mxf",
        "nsv",
        "ogg",
        "ogv",
        "ts",
        "qt",
        "rm",
        "rmvb",
        "roq",
        "svi",
        "vob",
        "webm",
        "wmv",
        "yuv"
    )

    val extAudio = listOf(
        "aac",
        "aiff",
        "ape",
        "au",
        "flac",
        "gsm",
        "it",
        "m3u",
        "m4a",
        "mid",
        "mod",
        "mp3",
        "mpa",
        "pls",
        "ra",
        "s3m",
        "sid",
        "wav",
        "wma",
        "xm"
    )
}
```

## ./app/src/main/java/ru/yourok/torrserve/utils/Format.kt
```kt
package ru.yourok.torrserve.utils

import android.content.Context
import android.util.TypedValue
import android.view.View
import android.view.ViewGroup
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.TimeZone
import kotlin.math.ln
import kotlin.math.pow
import kotlin.time.DurationUnit
import kotlin.time.toDuration

/**
 * Created by yourok on 23.02.18.
 */
object Format {

    fun speedFmt(bytes: Double): String {
        val bits = bytes * 8
        if (bits < 1000)
            return "%.1f".format(bits) + " " + App.context.getString(R.string.fmt_bps)
        val exp = (ln(bits) / ln(1000.0)).toInt()
        val pre = App.context.getString(R.string.fmt_p)[exp - 1].toString()
        return "%.1f %s".format(bits / 1000.0.pow(exp.toDouble()), pre) + App.context.getString(R.string.fmt_bps)
    }

    fun byteFmt(bytes: Double): String {
        if (bytes < 1024)
            return "%.1f".format(bytes) + " " + App.context.getString(R.string.fmt_b)
        val exp = (ln(bytes) / ln(1024.0)).toInt()
        val pre = App.context.getString(R.string.fmt_p)[exp - 1].toString()
        return "%.1f %s".format(bytes / 1024.0.pow(exp.toDouble()), pre) + App.context.getString(R.string.fmt_b)
    }

    fun byteFmt(bytes: Float): String {
        return byteFmt(bytes.toDouble())
    }

    fun byteFmt(bytes: Long): String {
        return byteFmt(bytes.toDouble())
    }

    fun byteFmt(bytes: Int): String {
        return byteFmt(bytes.toDouble())
    }

    fun sDateFmt(timestamp: Long): String {
        val sdf = SimpleDateFormat("dd.MM.yyyy", Locale("US"))
        sdf.timeZone = TimeZone.getDefault()
        return sdf.format(Date(timestamp * 1000))
    }

    fun sDateFmt(dateTimeString: String): String { //2021-06-21T00:00:00+03:00
        val idf = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale("US"))
        val date = idf.parse(dateTimeString)
        val sdf = SimpleDateFormat("dd.MM.yyyy", Locale("US"))
        sdf.timeZone = TimeZone.getDefault()
        return date?.let { sdf.format(it) } ?: dateTimeString
    }

    fun durFmtS(data: Double): String {
        val duration = data.toDuration(DurationUnit.SECONDS)
//        return duration.toComponents { hours, minutes, seconds, _ ->
//            String.format("%02d:%02d:%02d", hours, minutes, seconds)
//        }
        val strDur = mutableListOf<String>()
        duration.toComponents { hours, minutes, seconds, _ ->
            if (hours > 0)
                strDur.add(String.format("%d %s", hours, App.context.getString(R.string.fmt_h)))
            if (minutes > 0)
                strDur.add(String.format("%d %s", minutes, App.context.getString(R.string.fmt_m)))
            if (hours == 0L && seconds > 0)
                strDur.add(String.format("%d %s", seconds, App.context.getString(R.string.fmt_s)))
        }
        return strDur.joinToString(" ")
    }

    fun dp2px(dip: Float): Int {
        val dm = App.context.resources.displayMetrics
        return TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dip, dm).toInt()
    }

    fun View.margin(left: Float? = null, top: Float? = null, right: Float? = null, bottom: Float? = null) {
        layoutParams<ViewGroup.MarginLayoutParams> {
            left?.run { leftMargin = dpToPx(this) }
            top?.run { topMargin = dpToPx(this) }
            right?.run { rightMargin = dpToPx(this) }
            bottom?.run { bottomMargin = dpToPx(this) }
        }
    }

    private inline fun <reified T : ViewGroup.LayoutParams> View.layoutParams(block: T.() -> Unit) {
        if (layoutParams is T) block(layoutParams as T)
    }

    private fun View.dpToPx(dp: Float): Int = context.dpToPx(dp)
    private fun Context.dpToPx(dp: Float): Int = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp, resources.displayMetrics).toInt()
}
```

## ./app/src/main/java/ru/yourok/torrserve/utils/Net.kt
```kt
package ru.yourok.torrserve.utils

import android.annotation.SuppressLint
import android.net.Uri
import org.jsoup.Connection
import org.jsoup.Jsoup
import ru.yourok.torrserve.atv.Utils.isBrokenTCL
import ru.yourok.torrserve.settings.Settings
import java.io.InputStream
import java.net.Inet4Address
import java.net.InetAddress
import java.net.UnknownHostException
import java.nio.charset.Charset
import java.security.KeyManagementException
import java.security.cert.CertificateException
import java.security.cert.X509Certificate
import javax.net.ssl.*

object Net {
    private const val timeout = 5000 // total request timeout duration, in ms

    fun getHostUrl(path: String): String {
        val url = Settings.getHost()
        if (path.isEmpty())
            return url

        return if (url.last() == '/')
            url + path.substring(1)
        else
            url + path
    }

    fun getAuthB64(): String {
        val auth = Settings.getServerAuth()
        if (auth.isNotEmpty())
            return "Basic " + android.util.Base64.encode(auth.toByteArray(), android.util.Base64.NO_WRAP).toString(Charset.defaultCharset())
        return ""
    }

    fun uploadAuth(url: String, title: String, poster: String, category: String, data: String, file: InputStream, save: Boolean): String {
        val req = Jsoup.connect(url)
            .data("file1", "filename", file)
            .ignoreHttpErrors(true)
            .ignoreContentType(true)
            .method(Connection.Method.POST)
        if (!isBrokenTCL)
            req.sslSocketFactory(TlsSocketFactory())
        if (save)
            req.data("save", "true")
        req.data("title", title)
        req.data("poster", poster)
        req.data("category", category)
        req.data("data", data)

        val auth = getAuthB64()
        if (auth.isNotEmpty())
            req.header("Authorization", auth)

        val response = req.execute()
        return response.body()
    }

    fun postAuth(url: String, req: String): String {
        val conn = Jsoup.connect(url)
            .requestBody(req)
            .ignoreHttpErrors(true)
            .ignoreContentType(true)
            .method(Connection.Method.POST)
            .maxBodySize(0) // The default maximum is 2MB, 0 = unlimited body
        if (!isBrokenTCL)
            conn.sslSocketFactory(TlsSocketFactory())

        val auth = getAuthB64()
        if (auth.isNotEmpty())
            conn.header("Authorization", auth)

        val response = conn.execute()

        return when (response.statusCode()) {
            200 -> {
                response.body()
            }

            302 -> {
                ""
            }

            else -> {
                throw Exception(response.statusMessage())
            }
        }
    }

    fun getAuth(url: String, duration: Int = timeout): String {
        val conn = Jsoup.connect(url)
            .ignoreHttpErrors(true)
            .ignoreContentType(true)
            .timeout(duration)
        if (!isBrokenTCL)
            conn.sslSocketFactory(TlsSocketFactory())

        val auth = getAuthB64()
        if (auth.isNotEmpty())
            conn.header("Authorization", auth)

        val response = conn.execute()
        return when (response.statusCode()) {
            200 -> {
                response.body()
            }

            302 -> {
                ""
            }

            else -> {
                throw Exception(response.statusMessage())
            }
        }
    }

    /* used for apk / server update check */
    fun get(url: String, duration: Int = timeout): String {
        val link = Uri.parse(url)
        if (link.scheme.equals("https", true)) {
            val trustAllHostnames = HostnameVerifier { _, _ ->
                true // Just allow them all
            }
            HttpsURLConnection.setDefaultHostnameVerifier(trustAllHostnames)
        }
        val conn = Jsoup.connect(url)
            .ignoreHttpErrors(true)
            .ignoreContentType(true)
            .timeout(duration)
        if (!isBrokenTCL)
            conn.sslSocketFactory(TlsSocketFactory())

        val response = conn.execute()

        return when (response.statusCode()) {
            200 -> {
                response.body()
            }

            302 -> {
                ""
            }

            else -> {
                throw Exception(response.statusMessage())
            }
        }
    }

    fun isValidPublicIp4(ip: String?): Boolean {
        val address: Inet4Address? = try {
            InetAddress.getByName(ip) as? Inet4Address
        } catch (exception: UnknownHostException) {
            return false // assuming no logging, exception handling required
        }
        if (address != null) {
            return !(address.isSiteLocalAddress ||
                    address.isAnyLocalAddress ||
                    address.isLinkLocalAddress ||
                    address.isLoopbackAddress ||
                    address.isMulticastAddress)
        }
        return false
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/utils/ThemeUtil.kt
```kt
package ru.yourok.torrserve.utils

import android.content.Context
import android.content.res.Configuration
import android.os.Build
import android.util.Log
import android.util.TypedValue
import androidx.annotation.AttrRes
import androidx.annotation.ColorInt
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.app.AppCompatDelegate
import ru.yourok.torrserve.BuildConfig
import ru.yourok.torrserve.R
import ru.yourok.torrserve.app.App
import ru.yourok.torrserve.atv.Utils
import ru.yourok.torrserve.settings.Settings
import ru.yourok.torrserve.settings.Settings.getTheme

class ThemeUtil {
    private var currentTheme = 0
    fun onCreate(activity: AppCompatActivity) {
        currentTheme = selectedTheme
        activity.setTheme(currentTheme)
    }

    fun onResume(activity: AppCompatActivity) {
        if (currentTheme != selectedTheme) {
            activity.recreate()
        }
    }

    fun onConfigurationChanged(activity: AppCompatActivity, newConfig: Configuration) {
        val config = activity.resources.configuration
        val isNightModeActive =
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                config.isNightModeActive
            } else {
                config.uiMode and
                        Configuration.UI_MODE_NIGHT_MASK ==
                        Configuration.UI_MODE_NIGHT_YES
            }
        if (BuildConfig.DEBUG) Log.d("*****", "ThemeUtil onConfigurationChanged isNightModeActive = $isNightModeActive")
    }

    companion object {
        val selectedTheme: Int
            get() {
                return when (getTheme()) {
                    "light" -> R.style.Theme_TorrServe_Light
                    "dark" -> R.style.Theme_TorrServe_Dark
                    "black" -> R.style.Theme_TorrServe_Black
                    else -> R.style.Theme_TorrServe_DayNight
                }
            }

        @ColorInt
        fun getColorFromAttr(
            context: Context,
            @AttrRes attrColor: Int,
            typedValue: TypedValue = TypedValue(),
            resolveRefs: Boolean = true
        ): Int {
            context.theme.resolveAttribute(attrColor, typedValue, resolveRefs)
            return typedValue.data
        }

        fun isDarkMode(context: Context): Boolean {
            return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                context.resources.configuration.isNightModeActive
            } else {
                val darkModeFlag = context.resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK
                darkModeFlag == Configuration.UI_MODE_NIGHT_YES
            }
        }

        fun setNightMode() {
            when (getTheme()) {
                "dark", "black" -> AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES)
                "light" -> AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO)
                else -> if (Utils.isTvBox()) AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_AUTO_TIME) else
                    AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM) // phones
            }
        }
    }
}
```

## ./app/src/main/java/ru/yourok/torrserve/animations/FIO.kt
```kt
package ru.yourok.torrserve.animations

import android.view.View

object FIO {

    fun anim(view1: View, view2: View, time: Long, onEnd: (() -> Unit)? = null) {
        view2.visibility = View.GONE
        view2.alpha = 0.0f

        view1.animate().apply {
            duration = time / 2
            alpha(0.0f)
            withEndAction {
                view1.visibility = View.GONE
                view2.visibility = View.VISIBLE
                view2.animate()?.apply {
                    duration = time / 2
                    alpha(1.0f)
                    start()
                    withEndAction {
                        onEnd?.invoke()
                    }
                }
            }
            start()
        }
    }

}
```

## ./gradle/wrapper/gradle-wrapper.properties
```properties
#Wed Nov 18 12:32:26 MSK 2020
distributionBase=GRADLE_USER_HOME
distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-bin.zip
distributionPath=wrapper/dists
zipStorePath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME

```

## ./build.gradle
```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    ext.kotlin_version = "1.9.22"
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.10.1'
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:${kotlin_version}"
        classpath 'com.google.gms:google-services:4.4.2'
        classpath 'com.google.firebase:firebase-crashlytics-gradle:3.0.2'
    }
}

plugins {
    id 'com.google.devtools.ksp' version "${kotlin_version}-1.0.16" apply false
    id 'org.jetbrains.kotlin.android' version "${kotlin_version}" apply false
}

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

tasks.register('clean', Delete) {
    delete rootProject.buildDir
}
```

## ./gradle.properties
```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app"s APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Kotlin code style for this project: "official" or "obsolete":
kotlin.code.style=official
android.nonTransitiveRClass=false
android.nonFinalResIds=false
```

## ./settings.gradle
```gradle
rootProject.name = "TorrServe"
include ':app'

```

```

---

### docs/POSTER_BATTLE_HISTORY.md

```md
# ‚öîÔ∏è –•—Ä–æ–Ω–∏–∫–∏ –ë–∏—Ç–≤—ã –∑–∞ –ü–æ—Å—Ç–µ—Ä—ã: TMDB vs ISP

–≠—Ç–æ –¥–µ—Ç–∞–ª—å–Ω—ã–π –ª–æ–≥ –Ω–∞—à–µ–π –≤–æ–π–Ω—ã —Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞–º–∏ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ –∑–∞ –ø—Ä–∞–≤–æ –≤–∏–¥–µ—Ç—å –æ–±–ª–æ–∂–∫–∏ —Ñ–∏–ª—å–º–æ–≤.

## üõë –ü—Ä–æ–ª–æ–≥: –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞
**–ü—Ä–æ–±–ª–µ–º–∞:** –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –Ω–∞ —Ç–µ–ª–µ–≤–∏–∑–æ—Ä–µ (Android TV) –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞–ª–æ –∫–∞—Ä—Ç–∏–Ω–∫–∏.
**–ü—Ä–∏—á–∏–Ω–∞:** –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ `api.themoviedb.org` –∏ `image.tmdb.org` –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–º (–†–ö–ù).
**–ü–µ—Ä–≤–æ–µ —Ä–µ—à–µ–Ω–∏–µ:** –ú—ã —Ä–µ—à–∏–ª–∏ —Å–¥–µ–ª–∞—Ç—å **Server-Side Proxy** –Ω–∞ Node.js (NAS), —á—Ç–æ–±—ã —Ç–µ–ª–µ–≤–∏–∑–æ—Ä –æ–±—Ä–∞—â–∞–ª—Å—è –∫ –ª–æ–∫–∞–ª—å–Ω–æ–º—É —Å–µ—Ä–≤–µ—Ä—É, –∞ —Å–µ—Ä–≤–µ—Ä —É–∂–µ —à–µ–ª –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç.

---

## üé≠ –ê–∫—Ç 1: –ó–µ—Ä–∫–∞–ª—å–Ω—ã–µ –í–æ–π–Ω—ã
–°–µ—Ä–≤–µ—Ä (NAS) —Ç–æ–∂–µ –æ–∫–∞–∑–∞–ª—Å—è –ø–æ–¥ –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞. –ú—ã –Ω–∞—á–∞–ª–∏ –ø–µ—Ä–µ–±–∏—Ä–∞—Ç—å "–ø–∏—Ä–∞—Ç—Å–∫–∏–µ" –∑–µ—Ä–∫–∞–ª–∞.

### –ü–æ–ø—ã—Ç–∫–∞ ‚Ññ1: `apitmdb.cub.watch`
*   **–ò–¥–µ—è:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ–ø—É–ª—è—Ä–Ω–æ–µ –∑–µ—Ä–∫–∞–ª–æ –æ—Ç —Å–µ—Ä–≤–∏—Å–∞ Lampa.
*   **–†–µ–∑—É–ª—å—Ç–∞—Ç:** `JSON Parse Error: <!doctype html>`.
*   **–ê–Ω–∞–ª–∏–∑:** –ó–µ—Ä–∫–∞–ª–æ –∑–∞—â–∏—â–µ–Ω–æ Cloudflare –∏–ª–∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ–π —Å–∏—Å—Ç–µ–º–æ–π ("Checking your browser"), –∫–æ—Ç–æ—Ä–∞—è –æ—Ç–¥–∞–µ—Ç HTML-–∫–∞–ø—á—É –≤–º–µ—Å—Ç–æ JSON-–æ—Ç–≤–µ—Ç–∞ –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–º–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã —Å —Å–µ—Ä–≤–µ—Ä–∞.

### –ü–æ–ø—ã—Ç–∫–∞ ‚Ññ2: `api.tmdb.best`
*   **–ò–¥–µ—è:** –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–µ –∑–µ—Ä–∫–∞–ª–æ.
*   **–†–µ–∑—É–ª—å—Ç–∞—Ç:** –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ. –°–µ—Ä–≤–µ—Ä –ø–æ–ª—É—á–∞–µ—Ç HTML —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å –æ—à–∏–±–∫–æ–π –¥–æ—Å—Ç—É–ø–∞ –∏–ª–∏ –∑–∞–≥–ª—É—à–∫—É —Ö–æ—Å—Ç–∏–Ω–≥–∞.

### –ü–æ–ø—ã—Ç–∫–∞ ‚Ññ3: `api.1080.club`
*   **–ò–¥–µ—è:** "–ñ–µ–ª–µ–∑–æ–±–µ—Ç–æ–Ω–Ω–æ–µ" –∑–µ—Ä–∫–∞–ª–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–µ –º–Ω–æ–≥–∏–º–∏ –±–∞–ª–∞–Ω—Å–µ—Ä–∞–º–∏.
*   **–†–µ–∑—É–ª—å—Ç–∞—Ç:** `fetch failed` / `UDP Timeout`. –ü—Ä–æ–≤–∞–π–¥–µ—Ä –±–ª–æ–∫–∏—Ä—É–µ—Ç IP-–∞–¥—Ä–µ—Å–∞ —ç—Ç–æ–≥–æ –∑–µ—Ä–∫–∞–ª–∞ –Ω–∞ —É—Ä–æ–≤–Ω–µ DNS –∏–ª–∏ DPI.
*   **–•–∞–∫–∏:** –ú—ã –ø—Ä–æ–±–æ–≤–∞–ª–∏ –æ—Ç–∫–ª—é—á–∞—Ç—å SSL-–ø—Ä–æ–≤–µ—Ä–∫—É (`NODE_TLS_REJECT_UNAUTHORIZED = '0'`), –º–µ–Ω—è—Ç—å `User-Agent` –Ω–∞ Chrome/Windows, –¥–æ–±–∞–≤–ª—è—Ç—å `Referer`. –ë–µ—Å–ø–æ–ª–µ–∑–Ω–æ.

---

## üõ† –ê–∫—Ç 2: –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –ò–∑–æ—â—Ä–µ–Ω–∏—è

–ö–æ–≥–¥–∞ –ø—Ä—è–º—ã–µ –∑–µ—Ä–∫–∞–ª–∞ –ø–∞–ª–∏, –º—ã –ø–µ—Ä–µ—à–ª–∏ –∫ "—Ç—É–Ω–Ω–µ–ª–∏—Ä–æ–≤–∞–Ω–∏—é".

### –ü–æ–ø—ã—Ç–∫–∞ ‚Ññ4: Google Translate Hack ü•ã
*   **–ò–¥–µ—è:** –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å —Ç—Ä–∞—Ñ–∏–∫ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫ Google (`api-themoviedb-org.translate.goog`). –¢—Ä–∞—Ñ–∏–∫ –≤—ã–≥–ª—è–¥–∏—Ç –¥–ª—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ –∫–∞–∫ –ª–µ–≥–∞–ª—å–Ω—ã–π –ø–æ—Ö–æ–¥ –≤ Google.
*   **–†–µ–∑—É–ª—å—Ç–∞—Ç:** **–û—à–∏–±–∫–∞ 408 (Timeout)** –∏ HTML —Å —Ç–µ–∫—Å—Ç–æ–º "Can't translate this page".
*   **–ü—Ä–∏—á–∏–Ω–∞:** Google —Ä–∞—Å–ø–æ–∑–Ω–∞–ª, —á—Ç–æ –º—ã –≥–æ–Ω—è–µ–º —á–µ—Ä–µ–∑ –Ω–µ–≥–æ API-–∑–∞–ø—Ä–æ—Å—ã (JSON), –∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª —ç—Ç–æ—Ç —Ç—Ä—é–∫ –¥–ª—è –Ω–∞—à–µ–≥–æ IP.

### –ü–æ–ø—ã—Ç–∫–∞ ‚Ññ5: `corsproxy.io`
*   **–ò–¥–µ—è:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—É–±–ª–∏—á–Ω—ã–π CORS-–ø—Ä–æ–∫—Å–∏.
*   **–†–µ–∑—É–ª—å—Ç–∞—Ç:** `Cloudflare Block`. –°–µ—Ä–≤–∏—Å `corsproxy` —Å–∞–º –ø–æ —Å–µ–±–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –Ω–æ TMDB (—Ü–µ–ª–µ–≤–æ–π —Å–∞–π—Ç) –±–ª–æ–∫–∏—Ä—É–µ—Ç –∑–∞–ø—Ä–æ—Å—ã, –ø—Ä–∏—Ö–æ–¥—è—â–∏–µ –æ—Ç —ç—Ç–æ–≥–æ –ø—Ä–æ–∫—Å–∏, –ª–∏–±–æ –ø—Ä–æ–≤–∞–π–¥–µ—Ä –±–ª–æ–∫–∏—Ä—É–µ—Ç —Å–∞–º –ø—Ä–æ–∫—Å–∏.

### –ü–æ–ø—ã—Ç–∫–∞ ‚Ññ6: –ü—É–±–ª–∏—á–Ω—ã–µ CDN (`allorigins.win` + `wsrv.nl`)
*   **–ò–¥–µ—è:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `allorigins` –¥–ª—è JSON –∏ `wsrv.nl` (Image Proxy) –¥–ª—è –∫–∞—Ä—Ç–∏–Ω–æ–∫.
*   **–†–µ–∑—É–ª—å—Ç–∞—Ç:**
    *   –ü–æ–∏—Å–∫: –ß–∞—Å—Ç–∏—á–Ω–æ —Ä–∞–±–æ—Ç–∞–ª, –Ω–æ –æ—á–µ–Ω—å –º–µ–¥–ª–µ–Ω–Ω–æ.
    *   –ö–∞—Ä—Ç–∏–Ω–∫–∏: –û—à–∏–±–∫–∏ 500.
    *   **–ò—Ç–æ–≥:** –°–µ—Ä–≤–µ—Ä –Ω–∞—á–∞–ª "–∑–∞—Ö–ª–µ–±—ã–≤–∞—Ç—å—Å—è" —Ç–∞–π–º–∞—É—Ç–∞–º–∏, –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –Ω–∞ –¢–í —Å—Ç–∞–ª —Ç–æ—Ä–º–æ–∑–∏—Ç—å (—Ñ—Ä–∏–∑—ã –ø—Ä–∏ –ø—Ä–æ–∫—Ä—É—Ç–∫–µ), —Ç–∞–∫ –∫–∞–∫ –æ–∂–∏–¥–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞ –∑–∞–Ω–∏–º–∞–ª–æ —Å–µ–∫—É–Ω–¥—ã.

---

## üè≥Ô∏è –≠–ø–∏–ª–æ–≥ (–í—Ä–µ–º–µ–Ω–Ω—ã–π): Offline Mode
–ú—ã –ø–æ–Ω—è–ª–∏, —á—Ç–æ –±–µ–∑ VPN –Ω–∞ —É—Ä–æ–≤–Ω–µ —Ä–æ—É—Ç–µ—Ä–∞/NAS –ø—Ä–æ–±–∏—Ç—å —ç—Ç—É —Å—Ç–µ–Ω—É **—Å–µ—Ä–≤–µ—Ä–Ω—ã–º–∏ –º–µ—Ç–æ–¥–∞–º–∏** –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ. –ú—ã –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–∏–ª–∏ –ø—Ä–æ–∫—Å–∏ (404 stubs) –∏ —Å–¥–µ–ª–∞–ª–∏ –∫—Ä–∞—Å–∏–≤—ã–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç—ã, —á—Ç–æ–±—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å "–ª–µ—Ç–∞–ª".

---

## üöÄ –ê–∫—Ç 3: –í–æ–∑—Ä–æ–∂–¥–µ–Ω–∏–µ (Full Client Strategy)

–ü–æ—Å–ª–µ –∞–Ω–∞–ª–∏–∑–∞ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã Lampa –º—ã –ø–æ–Ω—è–ª–∏ –æ—à–∏–±–∫—É: **–º—ã –ø—ã—Ç–∞–ª–∏—Å—å –ø—Ä–æ–∫—Å–∏—Ä–æ–≤–∞—Ç—å —Ç—Ä–∞—Ñ–∏–∫ —á–µ—Ä–µ–∑ –°–µ—Ä–≤–µ—Ä (NAS)**, –∫–æ—Ç–æ—Ä—ã–π –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ç–æ–π –∂–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —Å–µ—Ç–∏, –Ω–æ –º–µ–Ω–µ–µ "–≥–∏–±–æ–∫", —á–µ–º –±—Ä–∞—É–∑–µ—Ä –∫–ª–∏–µ–Ω—Ç–∞.

### –°–º–µ–Ω–∞ –ø–∞—Ä–∞–¥–∏–≥–º—ã:
–ú—ã –ø–µ—Ä–µ–Ω–µ—Å–ª–∏ –í–°–Æ –ª–æ–≥–∏–∫—É –∑–∞–≥—Ä—É–∑–∫–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –Ω–∞ **–ö–ª–∏–µ–Ω—Ç (–¢–í)**, –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏—Å–∫–ª—é—á–∏–≤ –ª–æ–∫–∞–ª—å–Ω—ã–π Node.js —Å–µ—Ä–≤–µ—Ä –∏–∑ —Ü–µ–ø–æ—á–∫–∏ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ—Å—Ç–µ—Ä–æ–≤.

### –ü–æ–±–µ–¥–Ω–∞—è —Å—Ö–µ–º–∞:
1.  **–ü–æ–∏—Å–∫ (Metadata):** –ö–ª–∏–µ–Ω—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `api.allorigins.win` (CORS-Proxy).
    *   *–ó–∞—á–µ–º:* –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å JSON —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Ñ–∏–ª—å–º–µ (title, poster_path).
    *   *–ü–æ—á–µ–º—É —Ä–∞–±–æ—Ç–∞–µ—Ç:* –¢–µ–ª–µ–≤–∏–∑–æ—Ä –∏–¥–µ—Ç –Ω–∞ `allorigins.win` (–∫–æ—Ç–æ—Ä—ã–π –æ–±—ã—á–Ω–æ –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è), –∞ —Ç–æ—Ç —É–∂–µ –∏–¥–µ—Ç –≤ TMDB –∏–∑ "—Å–≤–æ–±–æ–¥–Ω–æ–π –∑–æ–Ω—ã".
2.  **–ö–∞—Ä—Ç–∏–Ω–∫–∞ (Image):** –ö–ª–∏–µ–Ω—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `wsrv.nl` (Image CDN).
    *   *–ó–∞—á–µ–º:* –ü–æ–ª—É—á–∏—Ç—å –±–∏–Ω–∞—Ä–Ω–∏–∫ –∫–∞—Ä—Ç–∏–Ω–∫–∏.
    *   *Warum —Ä–∞–±–æ—Ç–∞–µ—Ç:* –¢—Ä–∞—Ñ–∏–∫ –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ –æ–±—ã—á–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ä—Ç–∏–Ω–∫–∏ —Å–æ —Å—Ç–æ—Ä–æ–Ω–Ω–µ–≥–æ CDN, –∞ –Ω–µ –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ –∑–∞–ø—Ä–µ—â–µ–Ω–Ω–æ–º—É `tmdb.org`.
3.  **Fallback (–°—Ç—Ä–∞—Ö–æ–≤–∫–∞):**
    *   –ï—Å–ª–∏ –¥–∞–∂–µ —ç—Ç–∏ –º–µ—Ç–æ–¥—ã –Ω–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–∏ –æ—Ç–≤–∞–ª–µ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞), –∫–ª–∏–µ–Ω—Ç **–º–≥–Ω–æ–≤–µ–Ω–Ω–æ** —Ä–∏—Å—É–µ—Ç –Ω–∞—à–∏ –∫—Ä–∞—Å–∏–≤—ã–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç—ã.

### –ò—Ç–æ–≥ –ë–∏—Ç–≤—ã: üèÜ WIN
*   **–ü–æ—Å—Ç–µ—Ä—ã:** –ï–°–¢–¨ (–≥—Ä—É–∑—è—Ç—Å—è —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏).
*   **–°–∫–æ—Ä–æ—Å—Ç—å:** –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–ê–Ø (—Å–µ—Ä–≤–µ—Ä –Ω–µ —Ç—É–ø–∏—Ç, –∫–ª–∏–µ–Ω—Ç –≥—Ä—É–∑–∏—Ç –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ).
*   **–°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å:** 100% (Offline Fallback –≤—Å–µ–≥–¥–∞ –Ω–∞ —Å—Ç—Ä–∞–∂–µ).

---

## üîç –ê–∫—Ç 4: –ì–ª—É–±–∏–Ω–Ω–∞—è –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ (–î–µ–∫–∞–±—Ä—å 2024)

### –°–∏–º–ø—Ç–æ–º—ã:
–ü–æ—Å—Ç–µ—Ä—ã –ø–µ—Ä–µ—Å—Ç–∞–ª–∏ –≥—Ä—É–∑–∏—Ç—å—Å—è –¥–∞–∂–µ —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏. –î–æ–±–∞–≤–∏–ª–∏ –∫–Ω–æ–ø–∫—É "üß™ –¢–µ—Å—Ç –∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ—Å—Ç–µ—Ä–æ–≤" –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏.

### –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–∞:
```
üß™ –¢–µ—Å—Ç –ø–æ—Å—Ç–µ—Ä–∞: "The Beekeeper"

1Ô∏è‚É£ CapacitorHttp: ‚ùå –û—à–∏–±–∫–∞: Failed to connect to api.themoviedb.org/127.0.0.1:443
2Ô∏è‚É£ corsproxy.io: ‚ùå HTTP 403
```

### –î–∏–∞–≥–Ω–æ–∑: üö® DNS Poisoning
–ü—Ä–æ–≤–∞–π–¥–µ—Ä –ø–æ–¥–º–µ–Ω—è–µ—Ç DNS ‚Äî `api.themoviedb.org` —Ä–µ–∑–æ–ª–≤–∏—Ç—Å—è –≤ `127.0.0.1` (localhost)!
–≠—Ç–æ –Ω–µ –ø—Ä–æ—Å—Ç–æ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ ‚Äî —ç—Ç–æ **–æ—Ç—Ä–∞–≤–ª–µ–Ω–∏–µ DNS-–∫—ç—à–∞**.

### –ö–∞–∫ Lampa —Ä–µ—à–∞–µ—Ç —ç—Ç—É –ø—Ä–æ–±–ª–µ–º—É:
–ò–∑—É—á–∏–ª–∏ –∏—Å—Ö–æ–¥–Ω–∏–∫–∏ Lampa ‚Äî –æ–Ω–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç **DNS-over-HTTPS (Quad9)**:
```kotlin
val dns = DnsOverHttps.Builder()
    .url("https://dns.quad9.net/dns-query")
    .bootstrapDnsHosts(InetAddress.getByName("9.9.9.9"))
    .build()
```

### –ù–∞—à–∏ —Ä–µ—à–µ–Ω–∏—è:

#### 1Ô∏è‚É£ VPN ‚úÖ
**–†–µ–∑—É–ª—å—Ç–∞—Ç:** –†–∞–±–æ—Ç–∞–µ—Ç! –° VPN —Ç–µ—Å—Ç –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç:
```
1Ô∏è‚É£ CapacitorHttp: ‚úÖ –ù–∞–π–¥–µ–Ω–æ: –ü—á–µ–ª–æ–≤–æ–¥
2Ô∏è‚É£ corsproxy.io: ‚úÖ –ù–∞–π–¥–µ–Ω–æ: –ü—á–µ–ª–æ–≤–æ–¥
```

#### 2Ô∏è‚É£ –°–º–µ–Ω–∞ DNS –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ
–ù–∞—Å—Ç—Ä–æ–∏—Ç—å DNS –Ω–∞ —Ä–æ—É—Ç–µ—Ä–µ –∏–ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ:
- **Cloudflare:** `1.1.1.1`
- **Google:** `8.8.8.8`
- **Quad9:** `9.9.9.9`

#### 3Ô∏è‚É£ –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã–π TMDB Proxy (–∫–∞–∫ –≤ Lampa)
–î–æ–±–∞–≤–∏–ª–∏ –≤ Settings ‚Üí Advanced ‚Üí **TMDB API Proxy**
–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç —É–∫–∞–∑–∞—Ç—å —Å–≤–æ–π –ø—Ä–æ–∫—Å–∏ –¥–ª—è –æ–±—Ö–æ–¥–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏.

---

## üèÜ –ê–∫—Ç 5: –§–∏–Ω–∞–ª—å–Ω–∞—è –ü–æ–±–µ–¥–∞ (–î–µ–∫–∞–±—Ä—å 2024)

### –ò–∑—É—á–µ–Ω–∏–µ –ø–ª–∞–≥–∏–Ω–æ–≤ Lampa
–ù–∞—à–ª–∏ –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏ Lampa –≥–æ—Ç–æ–≤—ã–µ —Ä–µ—à–µ–Ω–∏—è:
- `tmdb_proxy.js` ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `apn-latest.onrender.com`
- `kp_source.js` ‚Äî –ö–∏–Ω–æ–ø–æ–∏—Å–∫ API –∫–∞–∫ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ TMDB
- `cloudflare_worker.js` ‚Äî –∫–æ–¥ –¥–ª—è —Ä–∞–∑–≤—ë—Ä—Ç—ã–≤–∞–Ω–∏—è —Å–≤–æ–µ–≥–æ –ø—Ä–æ–∫—Å–∏

### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Ä–µ—à–µ–Ω–∏–π
1. **Lampa Proxy** (`apn-latest.onrender.com`) ‚Äî –¥–æ–±–∞–≤–ª–µ–Ω –∫–∞–∫ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π fallback
2. **–ö–∏–Ω–æ–ø–æ–∏—Å–∫ API** ‚Äî –¥–æ–±–∞–≤–ª–µ–Ω –∫–∞–∫ –ø–æ—Å–ª–µ–¥–Ω–∏–π fallback –µ—Å–ª–∏ TMDB –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç
3. **–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è Cloudflare Worker** ‚Äî —Å–æ–∑–¥–∞–Ω–∞ –¥–ª—è —Ä–∞–∑–≤—ë—Ä—Ç—ã–≤–∞–Ω–∏—è –ª–∏—á–Ω–æ–≥–æ –ø—Ä–æ–∫—Å–∏

### –§–∏–Ω–∞–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ fetchPoster:
```
1Ô∏è‚É£ –ö–∞—Å—Ç–æ–º–Ω—ã–π –ø—Ä–æ–∫—Å–∏ (–µ—Å–ª–∏ –∑–∞–¥–∞–Ω –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö)
      ‚Üì (fallback)
2Ô∏è‚É£ Lampa Proxy (apn-latest.onrender.com) ‚Üê –†–ê–ë–û–¢–ê–ï–¢ –ë–ï–ó VPN!
      ‚Üì (fallback)
3Ô∏è‚É£ CapacitorHttp –∫ TMDB –Ω–∞–ø—Ä—è–º—É—é (—Ç—Ä–µ–±—É–µ—Ç VPN/DNS)
      ‚Üì (fallback)  
4Ô∏è‚É£ corsproxy.io (CORS –ø—Ä–æ–∫—Å–∏ –¥–ª—è –±—Ä–∞—É–∑–µ—Ä–∞)
      ‚Üì (fallback)
5Ô∏è‚É£ –ö–∏–Ω–æ–ø–æ–∏—Å–∫ API (kinopoiskapiunofficial.tech) ‚Üê –ê–õ–¨–¢–ï–†–ù–ê–¢–ò–í–ê TMDB
      ‚Üì (fallback)
6Ô∏è‚É£ –ö—Ä–∞—Å–∏–≤—ã–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç—ã üé®
```

### –ò—Ç–æ–≥: üèÜ VICTORY!
*   **–ü–æ—Å—Ç–µ—Ä—ã –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –ë–ï–ó VPN** —á–µ—Ä–µ–∑ Lampa Proxy
*   **–ü–æ—Å—Ç–µ—Ä—ã –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –° VPN** –Ω–∞–ø—Ä—è–º—É—é
*   **5-—É—Ä–æ–≤–Ω–µ–≤—ã–π fallback** ‚Äî –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç—å
*   **–ö–∏–Ω–æ–ø–æ–∏—Å–∫ –∫–∞–∫ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞** ‚Äî –µ—Å–ª–∏ TMDB –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–±–ª–æ–∫–∏—Ä—É—é—Ç
*   **–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –¥–ª—è —Å–≤–æ–µ–≥–æ Worker** ‚Äî –Ω–∞ —Å–ª—É—á–∞–π –æ—Ç–∫–ª—é—á–µ–Ω–∏—è —á—É–∂–∏—Ö –ø—Ä–æ–∫—Å–∏

---

## üîê –ê–∫—Ç 6: –°–µ—Ä–≤–µ—Ä–Ω—ã–π DoH (–î–µ–∫–∞–±—Ä—å 2024)

### –ü—Ä–æ–±–ª–µ–º–∞
Lampa Proxy –Ω–∞ Render.com "–∑–∞—Å—ã–ø–∞–µ—Ç" –ø—Ä–∏ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏, –≤—ã–∑—ã–≤–∞—è –∑–∞–¥–µ—Ä–∂–∫–∏ cold start.
–ö–ª–∏–µ–Ω—Ç—Å–∫–∏–π fallback —Ä–∞–±–æ—Ç–∞–ª, –Ω–æ –º—ã —Ä–µ—à–∏–ª–∏ —É—Å–∏–ª–∏—Ç—å —Å–µ—Ä–≤–µ—Ä–Ω—É—é —á–∞—Å—Ç—å.

### –†–µ—à–µ–Ω–∏–µ: DNS-over-HTTPS –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ

–°–æ–∑–¥–∞–Ω –º–æ–¥—É–ª—å `server/utils/doh.js`:

```javascript
// –†–µ–∑–æ–ª–≤–∏–º IP —á–µ—Ä–µ–∑ Cloudflare DoH
const DOH_PROVIDER = 'https://cloudflare-dns.com/dns-query';

async function resolveIP(hostname) {
    const response = await fetch(DOH_PROVIDER, {
        params: { name: hostname, type: 'A' },
        headers: { 'Accept': 'application/dns-json' }
    });
    // –ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ 10 –º–∏–Ω—É—Ç
    return response.Answer.find(r => r.type === 1)?.data;
}

export async function smartFetch(url) {
    const ip = await resolveIP(new URL(url).hostname);
    // –û–±—Ö–æ–¥ DNS poisoning: –∏–¥—ë–º –Ω–∞–ø—Ä—è–º—É—é –Ω–∞ IP —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º Host –∑–∞–≥–æ–ª–æ–≤–∫–æ–º
    return fetch(url.replace(hostname, ip), { headers: { Host: hostname } });
}
```

### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è

–í `server/index.js` TMDB —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã —Ç–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É—é—Ç `smartFetch`:

```javascript
import { smartFetch } from './utils/doh.js'

app.get('/api/tmdb/search', async (req, res) => {
    const response = await smartFetch(`https://api.themoviedb.org/3/search/multi?...`)
    res.json(response.data)
})
```

### –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è

1. **Client Warmup** ‚Äî –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è HEAD –∑–∞–ø—Ä–æ—Å –∫ `apn-latest.onrender.com/ping` –¥–ª—è "–ø—Ä–æ–±—É–∂–¥–µ–Ω–∏—è" –ø—Ä–æ–∫—Å–∏
1.  **Client Warmup** ‚Äî –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è HEAD –∑–∞–ø—Ä–æ—Å –∫ `apn-latest.onrender.com/ping` –¥–ª—è "–ø—Ä–æ–±—É–∂–¥–µ–Ω–∏—è" –ø—Ä–æ–∫—Å–∏

2.  **–ë–µ–∑ –≤–Ω–µ—à–Ω–∏—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π** ‚Äî DoH –º–æ–¥—É–ª—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π Node.js `fetch` (Node 18+), –Ω–µ —Ç—Ä–µ–±—É–µ—Ç axios

### –ò—Ç–æ–≥
- ‚úÖ –°–µ—Ä–≤–µ—Ä –æ–±—Ö–æ–¥–∏—Ç DNS poisoning —á–µ—Ä–µ–∑ Cloudflare DoH
- ‚úÖ –ö–ª–∏–µ–Ω—Ç ¬´–ø—Ä–æ–≥—Ä–µ–≤–∞–µ—Ç¬ª –≤–Ω–µ—à–Ω–∏–µ —Å–µ—Ä–≤–∏—Å—ã
- ‚úÖ –†–∞–±–æ—Ç–∞–µ—Ç –±–µ–∑ VPN –∏ –±–µ–∑ –≤–Ω–µ—à–Ω–∏—Ö npm-–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π

---

## üßπ –ê–∫—Ç 7: –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –∏ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è (–î–µ–∫–∞–±—Ä—å 2024)

### –ü—Ä–æ–±–ª–µ–º–∞
`App.jsx` —Ä–∞–∑—Ä–æ—Å—Å—è –¥–æ **1223 —Å—Ç—Ä–æ–∫** ‚Äî —Å–ª–æ–∂–Ω–æ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å –∏ —Ä–∞—Å—à–∏—Ä—è—Ç—å.

### –†–µ—à–µ–Ω–∏–µ: –ö–æ–º–ø–æ–Ω–µ–Ω—Ç–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

–†–∞–∑–±–∏–ª–∏ –º–æ–Ω–æ–ª–∏—Ç –Ω–∞ –º–æ–¥—É–ª–∏:

```
client/src/
‚îú‚îÄ‚îÄ App.jsx                    (622 —Å—Ç—Ä–æ–∫–∏, –±—ã–ª–æ 1223)
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ Poster.jsx            (226) ‚Äî –∫–∞—Ä—Ç–æ—á–∫–∞ —Å –ø–æ—Å—Ç–µ—Ä–æ–º
‚îÇ   ‚îú‚îÄ‚îÄ SettingsPanel.jsx     (172) ‚Äî –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–ª–µ–µ—Ä–∞ –∏ —Å–µ—Ä–≤–µ—Ä–∞
‚îÇ   ‚îú‚îÄ‚îÄ TorrentModal.jsx      (117) ‚Äî –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ —Ñ–∞–π–ª–æ–≤
‚îÇ   ‚îú‚îÄ‚îÄ StatusBanners.jsx     (108) ‚Äî –±–∞–Ω–Ω–µ—Ä—ã –æ—à–∏–±–æ–∫
‚îÇ   ‚îî‚îÄ‚îÄ SearchPanel.jsx       (83)  ‚Äî –ø–æ–∏—Å–∫ –ø–æ RuTracker
‚îî‚îÄ‚îÄ utils/
    ‚îî‚îÄ‚îÄ helpers.js            (96)  ‚Äî cleanTitle, formatSize, formatSpeed
```

### –†–µ–∑—É–ª—å—Ç–∞—Ç: ‚úÖ –°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –Ω–∞ 49%

---

## ‚ö° –ê–∫—Ç 8: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–∏–º–∏–Ω–≥–∞ (–î–µ–∫–∞–±—Ä—å 2024)

### –¢–∏–ø–æ–≤—ã–µ –ø—Ä–æ–±–ª–µ–º—ã TV-—Å—Ç—Ä–∏–º–∏–Ω–≥–∞
- ‚ùå –î–æ–ª–≥–∏–π —Å—Ç–∞—Ä—Ç (buffering)
- ‚ùå –ó–∞—Ç—ã–∫–∏ –ø—Ä–∏ –ø–µ—Ä–µ–º–æ—Ç–∫–µ
- ‚ùå –°–∫–∞—á–∏–≤–∞–µ—Ç—Å—è ¬´–Ω–µ —Ç–æ—Ç¬ª –∫—É—Å–æ–∫

### –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

#### 1Ô∏è‚É£ –ê–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π Piece Prioritization
```javascript
// –ë—ã–ª–æ: 15MB –∏–ª–∏ 5%
// –°—Ç–∞–ª–æ: 50MB –∏–ª–∏ 10%
const priorityBytes = Math.min(file.length * 0.1, 50 * 1024 * 1024)
```

–ü—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞ **—Å—Ä–∞–∑—É** –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∏–º –ø–µ—Ä–≤—ã–π –≤–∏–¥–µ–æ—Ñ–∞–π–ª:
```javascript
// –ê–≤—Ç–æ-–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –ø–µ—Ä–≤–æ–≥–æ –≤–∏–¥–µ–æ
if (firstVideoIdx >= 0) {
    prioritizeFileInternal(engine, firstVideoIdx)
}
```

#### 2Ô∏è‚É£ Readahead –ø—Ä–∏ –ø–µ—Ä–µ–º–æ—Ç–∫–µ
–ü—Ä–∏ –∫–∞–∂–¥–æ–º Range-–∑–∞–ø—Ä–æ—Å–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∏–º –∫—É—Å–∫–∏ –æ—Ç –ø–æ–∑–∏—Ü–∏–∏ seek:
```javascript
// –í /stream/:infoHash/:fileIndex
readahead(infoHash, parseInt(fileIndex, 10), start)
```

–õ–æ–≥:
```
[Readahead] Seeking to byte 81197027701 in file 0
[Priority] File 0: pieces 19358-19358 (13 pieces, ~50MB)
```

#### 3Ô∏è‚É£ Keep-Alive (Frozen Torrents)
–í–º–µ—Å—Ç–æ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è ‚Äî ¬´–∑–∞–º–æ—Ä–∞–∂–∏–≤–∞–µ–º¬ª —Ç–æ—Ä—Ä–µ–Ω—Ç –Ω–∞ 30 –º–∏–Ω—É—Ç:
```javascript
// –ü—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏
frozenTorrents.set(infoHash, { engine, magnetURI, frozenAt: Date.now() })

// –ü—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–º –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ ‚Äî –º–≥–Ω–æ–≤–µ–Ω–Ω—ã–π —Å—Ç–∞—Ä—Ç!
const frozen = frozenTorrents.get(hash)
engines.set(magnetURI, frozen.engine)
```

### –ò—Ç–æ–≥
- ‚úÖ –°—Ç–∞—Ä—Ç –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è: **< 3 —Å–µ–∫—É–Ω–¥—ã**
- ‚úÖ –ü–µ—Ä–µ–º–æ—Ç–∫–∞: **–º–≥–Ω–æ–≤–µ–Ω–Ω–∞—è** (readahead)
- ‚úÖ –ü–æ–≤—Ç–æ—Ä–Ω–æ–µ –æ—Ç–∫—Ä—ã—Ç–∏–µ: **instant** (keep-alive)

---

## üåê –ê–∫—Ç 9: –õ–∏—á–Ω—ã–π Cloudflare Worker (–î–µ–∫–∞–±—Ä—å 2024)

### –î–µ–ø–ª–æ–π —Å–≤–æ–µ–≥–æ CORS-–ø—Ä–æ–∫—Å–∏
–°–æ–∑–¥–∞–Ω –∏ —Ä–∞–∑–≤—ë—Ä–Ω—É—Ç –ª–∏—á–Ω—ã–π Cloudflare Worker –¥–ª—è –æ–±—Ö–æ–¥–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ TMDB.

**URL:** `https://super-sea-46c7.*.workers.dev`

### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
–î–æ–±–∞–≤–ª–µ–Ω –∫–∞–∫ **–ø–µ—Ä–≤—ã–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç** –≤ fetchPoster:
```javascript
// 1Ô∏è‚É£ Custom Cloudflare Worker (–≤–∞—à –ª–∏—á–Ω—ã–π –ø—Ä–æ–∫—Å–∏)
if (!result && CUSTOM_PROXY) {
    const proxyUrl = `${CUSTOM_PROXY}/api.themoviedb.org/3/search/multi?...`
    // ...
}
```

### –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
```env
# –í .env (–∫–ª–∏–µ–Ω—Ç, –Ω–∞ —ç—Ç–∞–ø–µ —Å–±–æ—Ä–∫–∏)
VITE_TMDB_PROXY_URL=https://your-worker.workers.dev
```

### –ò—Ç–æ–≥
- ‚úÖ –õ–∏—á–Ω—ã–π –ø—Ä–æ–∫—Å–∏ —Å –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å—é
- ‚úÖ –ù–µ –∑–∞–≤–∏—Å–∏–º –æ—Ç —á—É–∂–∏—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
- ‚úÖ 100 000 –∑–∞–ø—Ä–æ—Å–æ–≤/–¥–µ–Ω—å –±–µ—Å–ø–ª–∞—Ç–Ω–æ

---

## üì¶ –ê–∫—Ç 10: –£–ª—É—á—à–µ–Ω–Ω—ã–π Docker Deployment (–î–µ–∫–∞–±—Ä—å 2024)

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –Ω–∞ Synology NAS
```
/volume1/docker/pwa-torserve/
‚îú‚îÄ‚îÄ .env                    # API –∫–ª—é—á–∏ (–º–æ–Ω—Ç–∏—Ä—É–µ—Ç—Å—è –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä)
‚îú‚îÄ‚îÄ server/                 # –°–µ—Ä–≤–µ—Ä–Ω—ã–π –∫–æ–¥ (hot-swap –±–µ–∑ rebuild)
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ torrent.js
‚îÇ   ‚îú‚îÄ‚îÄ jacred.js
‚îÇ   ‚îú‚îÄ‚îÄ watchdog.js
‚îÇ   ‚îú‚îÄ‚îÄ utils/doh.js
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îú‚îÄ‚îÄ data/db.json           # Persistence
‚îî‚îÄ‚îÄ downloads/             # –¢–æ—Ä—Ä–µ–Ω—Ç—ã
```

### docker-compose.synology.yml
```yaml
volumes:
  - ./server:/app/server          # Hot-swap —Å–µ—Ä–≤–µ—Ä–Ω–æ–≥–æ –∫–æ–¥–∞
  - ./server/utils:/app/server/utils
  - ./.env:/app/.env:ro           # –ö–æ–Ω—Ñ–∏–≥ —Å –∫–ª—é—á–∞–º–∏
  - ./data:/app/data
```

### –ò—Ç–æ–≥
- ‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–µ—Ä–≤–µ—Ä–∞ **–±–µ–∑ –ø–µ—Ä–µ—Å–±–æ—Ä–∫–∏ –æ–±—Ä–∞–∑–∞**
- ‚úÖ .env –º–æ–Ω—Ç–∏—Ä—É–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ
- ‚úÖ `docker restart torserve` = –¥–µ–ø–ª–æ–π –∑–∞ 2 —Å–µ–∫—É–Ω–¥—ã

---

## üî¨ –ê–∫—Ç 11: –§–∏–Ω–∞–ª—å–Ω–∞—è –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –∏ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è (14 –î–µ–∫–∞–±—Ä—è 2024)

### –ü—Ä–æ–±–ª–µ–º–∞
–ü–æ—Å—Ç–µ—Ä—ã –Ω–µ –∑–∞–≥—Ä—É–∂–∞–ª–∏—Å—å –Ω–∞ Android TV –±–µ–∑ VPN. –¢–µ—Å—Ç –ø–æ–∫–∞–∑—ã–≤–∞–ª –æ—à–∏–±–∫–∏ –¥–ª—è –≤—Å–µ—Ö –º–µ—Ç–æ–¥–æ–≤.

### –†–∞—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ
–î–æ–±–∞–≤–ª–µ–Ω–∞ **–¥–µ—Ç–∞–ª—å–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞** –≤ Settings ‚Üí "üß™ –¢–µ—Å—Ç":
- –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é (TMDB_KEY, KP_KEY, CUSTOM_PROXY)
- –¢–µ—Å—Ç–∏—Ä—É–µ—Ç –≤—Å–µ 5 –º–µ—Ç–æ–¥–æ–≤ —Å —Ç–∞–π–º–∞—É—Ç–∞–º–∏
- –í—ã–≤–æ–¥–∏—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º
- –ü–æ–∑–≤–æ–ª—è–µ—Ç –≤–≤–µ—Å—Ç–∏ –ª—é–±–æ–π —Ñ–∏–ª—å–º –¥–ª—è —Ç–µ—Å—Ç–∞

### –ù–∞–π–¥–µ–Ω–Ω—ã–µ –±–∞–≥–∏

#### 1Ô∏è‚É£ client/.env –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞–ª
```bash
# –ù–µ –±—ã–ª–æ —Ñ–∞–π–ª–∞ ‚Üí APK —Å–æ–±–∏—Ä–∞–ª—Å—è –±–µ–∑ –∫–ª—é—á–µ–π
VITE_TMDB_API_KEY=  # –ø—É—Å—Ç–æ–π!
```
**–†–µ—à–µ–Ω–∏–µ:** –°–æ–∑–¥–∞–Ω `client/.env` —Å –∫–ª—é—á–∞–º–∏, –ø–µ—Ä–µ—Å–æ–±—Ä–∞–Ω APK.

#### 2Ô∏è‚É£ Custom Worker - –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π URL —Ñ–æ—Ä–º–∞—Ç
```javascript
// –ë—ã–ª–æ: Worker –¥–æ–±–∞–≤–ª—è–ª /3/, –∞ –º—ã —Ç–æ–∂–µ –ø–µ—Ä–µ–¥–∞–≤–∞–ª–∏ /3/
const proxyUrl = `${PROXY}/3/search/multi?...`  // ‚Üí /3/3/search/multi ‚ùå

// –°—Ç–∞–ª–æ:
const proxyUrl = `${PROXY}/search/multi?...`    // Worker –¥–æ–±–∞–≤–∏—Ç /3 ‚úÖ
```

#### 3Ô∏è‚É£ Lampa Proxy - –ª–æ–º–∞–ª—Å—è encodeURIComponent
```javascript
// –ë—ã–ª–æ:
const lampaUrl = proxy + encodeURIComponent(targetUrl)  // –õ–æ–º–∞–µ—Ç URL ‚ùå

// –°—Ç–∞–ª–æ:
const lampaUrl = `https://apn-latest.onrender.com/${targetUrl}`  // ‚úÖ
```

#### 4Ô∏è‚É£ –ö–∏–Ω–æ–ø–æ–∏—Å–∫ - –∫–ª—é—á –Ω–µ –±—ã–ª –¥–æ–±–∞–≤–ª–µ–Ω
```env
# –ë—ã–ª–æ:
VITE_KP_API_KEY=

# –°—Ç–∞–ª–æ:
VITE_KP_API_KEY=2a4a0808-81a3-40ae-b0d3-e11335ede616
```

### Cloudflare Worker Geolocation Block
**–ü—Ä–æ–±–ª–µ–º–∞:** TMDB –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `error 1102` (geolocation not permitted) –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö Cloudflare Edge —Å–µ—Ä–≤–µ—Ä–æ–≤.
- –° Mac (–ï–≤—Ä–æ–ø–∞): ‚úÖ —Ä–∞–±–æ—Ç–∞–µ—Ç
- –° Android TV (–†–æ—Å—Å–∏—è): ‚ùå 403

**–ü—Ä–∏—á–∏–Ω–∞:** Cloudflare Workers –∏—Å–ø–æ–ª—å–∑—É—é—Ç IP –±–ª–∏–∂–∞–π—à–µ–≥–æ edge-—Å–µ—Ä–≤–µ—Ä–∞. TMDB –±–ª–æ–∫–∏—Ä—É–µ—Ç –∑–∞–ø—Ä–æ—Å—ã –∏–∑ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã—Ö —Ä–µ–≥–∏–æ–Ω–æ–≤.

### –§–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç

| # | –ú–µ—Ç–æ–¥ | –°—Ç–∞—Ç—É—Å | –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π |
|---|-------|--------|-------------|
| 1Ô∏è‚É£ | Custom Worker | ‚ùå | TMDB –≥–µ–æ–±–ª–æ–∫ –¥–ª—è RU edge |
| 2Ô∏è‚É£ | **Lampa Proxy** | ‚úÖ | –†–∞–±–æ—Ç–∞–µ—Ç! |
| 3Ô∏è‚É£ | CapacitorHttp | üö´ | DNS Poisoning –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–º |
| 4Ô∏è‚É£ | **corsproxy.io** | ‚úÖ | –†–∞–±–æ—Ç–∞–µ—Ç! |
| 5Ô∏è‚É£ | **–ö–∏–Ω–æ–ø–æ–∏—Å–∫** | ‚úÖ | –†–∞–±–æ—Ç–∞–µ—Ç! |

### –ö–æ–¥ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
```javascript
const handleTestPoster = async () => {
    const userInput = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∏–ª—å–º–∞:', 'Gladiator 2')
    // ...—Ç–µ—Å—Ç–∏—Ä—É–µ—Ç 5 –º–µ—Ç–æ–¥–æ–≤ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ —Å —Ç–∞–π–º–∞—É—Ç–∞–º–∏...
    // ...–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏...
}
```

### –ò—Ç–æ–≥
- ‚úÖ **3 —Ä–∞–±–æ—á–∏—Ö –º–µ—Ç–æ–¥–∞** –±–µ–∑ VPN (Lampa, corsproxy, –ö–∏–Ω–æ–ø–æ–∏—Å–∫)
- ‚úÖ Fallback-—Å–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç—Å—è –Ω–∞ —Ä–∞–±–æ—á–∏–π –º–µ—Ç–æ–¥
- ‚úÖ –î–µ—Ç–∞–ª—å–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –¥–ª—è troubleshooting
- ‚úÖ APK v2.7 —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º–∏

---

## üìä –ò—Ç–æ–≥–æ–≤–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ—Å—Ç–µ—Ä–æ–≤

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      Poster.jsx                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  1. Custom Worker ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [–ë–ª–æ–∫ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏ RU]              ‚îÇ
‚îÇ         ‚îÇ                                                    ‚îÇ
‚îÇ         ‚ñº                                                    ‚îÇ
‚îÇ  2. Lampa Proxy ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ apn-latest.onrender.com ‚îÄ‚îÄ‚îÄ‚ñ∫ TMDB ‚îÇ
‚îÇ         ‚îÇ                        ‚úÖ                          ‚îÇ
‚îÇ         ‚ñº                                                    ‚îÇ
‚îÇ  3. CapacitorHttp ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [DNS Poisoning 127.0.0.1]         ‚îÇ
‚îÇ         ‚îÇ                                                    ‚îÇ
‚îÇ         ‚ñº                                                    ‚îÇ
‚îÇ  4. corsproxy.io ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ corsproxy.io ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ TMDB  ‚îÇ
‚îÇ         ‚îÇ                        ‚úÖ                          ‚îÇ
‚îÇ         ‚ñº                                                    ‚îÇ
‚îÇ  5. –ö–∏–Ω–æ–ø–æ–∏—Å–∫ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ kinopoiskapiunofficial ‚îÄ‚îÄ‚îÄ‚ñ∫ KP    ‚îÇ
‚îÇ         ‚îÇ                        ‚úÖ                          ‚îÇ
‚îÇ         ‚ñº                                                    ‚îÇ
‚îÇ  6. Gradient Fallback ‚îÄ‚îÄ‚ñ∫ –ö—Ä–∞—Å–∏–≤—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### üèÜ –ü–æ–±–µ–¥–∞ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞!
–ü–æ—Å—Ç–µ—Ä—ã –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –Ω–∞ Android TV –±–µ–∑ VPN —á–µ—Ä–µ–∑ –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—É—é —Å–∏—Å—Ç–µ–º—É fallback.

```

---

### docs/TMDB_CENSORSHIP_ANALYSIS.md

```md
# üõ° –ê–Ω–∞–ª–∏–∑ –º–µ—Ç–æ–¥–æ–≤ –æ–±—Ö–æ–¥–∞ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫ TMDB: Reverse Engineering –æ—Ç—á–µ—Ç

–≠—Ç–æ—Ç –¥–æ–∫—É–º–µ–Ω—Ç –æ–±–æ–±—â–∞–µ—Ç —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –º–µ—Ç–æ–¥—ã, –∫–æ—Ç–æ—Ä—ã–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ Android-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (Lampa, Vokino, NUM) –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–æ—Å—Ç—É–ø–∞ –∫ TMDB –≤ —É—Å–ª–æ–≤–∏—è—Ö —Å–µ—Ç–µ–≤–æ–π —Ü–µ–Ω–∑—É—Ä—ã (–†–ö–ù, DPI, SNI/IP Blocking).

## 1. –ö–æ–Ω—Ç–µ–∫—Å—Ç: –ü–æ—á–µ–º—É –±–ª–æ–∫–∏—Ä—É—é—Ç?
*   **–¶–µ–ª—å:** –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞—Ç–∞–ª–æ–≥–∞–º "–ø–∏—Ä–∞—Ç—Å–∫–æ–≥–æ" –∫–æ–Ω—Ç–µ–Ω—Ç–∞.
*   **–ú–µ—Ç–æ–¥:** –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –¥–æ–º–µ–Ω–æ–≤ `api.themoviedb.org` –∏ `image.tmdb.org` –ø–æ SNI (Server Name Indication) –∏ IP-–∞–¥—Ä–µ—Å–∞–º CDN (Cloudflare/Fastly).
*   **–ü—Ä–æ–±–ª–µ–º–∞:** –ü—Ä—è–º–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ª–æ–º–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –¥–æ–º–∞—à–Ω–∏—Ö –º–µ–¥–∏–∞-—Ü–µ–Ω—Ç—Ä–æ–≤.

---

## 2. –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è (–ø–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è–º)

### 2.1. Lampa ("–¢–æ–Ω–∫–∏–π –ö–ª–∏–µ–Ω—Ç" / JS-Injection)
*   **–§–∏–ª–æ—Å–æ—Ñ–∏—è:** –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ ‚Äî —ç—Ç–æ –±—Ä–∞—É–∑–µ—Ä (WebView), –ª–æ–≥–∏–∫–∞ ‚Äî —ç—Ç–æ JS, –∑–∞–≥—Ä—É–∂–∞–µ–º—ã–π –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏.
*   **CUB Mirror Network:**
    *   –ò—Å–ø–æ–ª—å–∑—É–µ—Ç —Å–µ—Ç—å Nginx-–ø—Ä–æ–∫—Å–∏ (`cub.red`, `cub.watch`), —Ä–∞–∑–º–µ—â–µ–Ω–Ω—ã—Ö –≤ "—Å–≤–æ–±–æ–¥–Ω—ã—Ö" —é—Ä–∏—Å–¥–∏–∫—Ü–∏—è—Ö (–ù–∏–¥–µ—Ä–ª–∞–Ω–¥—ã).
    *   **Anti-DPI:** –ò—Å–ø–æ–ª—å–∑—É–µ—Ç SSL Termination —Å –≤–∞–ª–∏–¥–Ω—ã–º–∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞–º–∏ Let's Encrypt –¥–ª—è –¥–æ–º–µ–Ω–æ–≤, –Ω–µ –Ω–∞—Ö–æ–¥—è—â–∏—Ö—Å—è –≤ —á–µ—Ä–Ω–æ–º —Å–ø–∏—Å–∫–µ.
    *   **Rate Limiting Bypass:** –°–µ—Ä–≤–µ—Ä CUB —Ä–æ—Ç–∏—Ä—É–µ—Ç –ø—É–ª API-–∫–ª—é—á–µ–π TMDB, —á—Ç–æ–±—ã –Ω–µ —É–ø–µ—Ä–µ—Ç—å—Å—è –≤ –ª–∏–º–∏—Ç—ã –æ–¥–Ω–æ–≥–æ –∫–ª—é—á–∞.
*   **Image Optimization (wsrv.nl):**
    *   –≠–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–∞ "–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –Ω–∞ –ª–µ—Ç—É".
    *   –ö–ª–∏–µ–Ω—Ç -> `wsrv.nl` (–ª–µ–≥–∏—Ç–∏–º–Ω—ã–π CDN) -> `tmdb.org` (–±—ç–∫–µ–Ω–¥).
    *   –¢—Ä–∞—Ñ–∏–∫ –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ –∑–∞–≥—Ä—É–∑–∫–∞ –ª–µ–≥–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç–∏–Ω–∫–∏ —Å CDN.
*   **Plugins:** JS-–ø–ª–∞–≥–∏–Ω—ã –ø–æ–∑–≤–æ–ª—è—é—Ç —Å–æ–æ–±—â–µ—Å—Ç–≤—É –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –º–µ–Ω—è—Ç—å –∞–¥—Ä–µ—Å–∞ –∑–µ—Ä–∫–∞–ª –±–µ–∑ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è APK.

### 2.2. Vokino (–ù–∞—Ç–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ / BFF)
*   **–°—Ç–µ–∫:** Kotlin + OkHttp.
*   **BFF (Backend for Frontend):** –ö–ª–∏–µ–Ω—Ç —Ö–æ–¥–∏—Ç –Ω–µ –≤ TMDB, –∞ –Ω–∞ —Å–≤–æ–π –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π —Å–µ—Ä–≤–µ—Ä `api.vokino.tv`. –°–µ—Ä–≤–µ—Ä –∫–µ—à–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç—ã TMDB –∏ –æ–±–æ–≥–∞—â–∞–µ—Ç –∏—Ö (–ö–∏–Ω–æ–ø–æ–∏—Å–∫, IMDb).
*   **DDoS Protection & DNS:**
    *   **DoH (DNS over HTTPS):** –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Cloudflare DNS (`1.1.1.1`) –≤–Ω—É—Ç—Ä–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è. –≠—Ç–æ —Å–∫—Ä—ã–≤–∞–µ—Ç DNS-–∑–∞–ø—Ä–æ—Å—ã –æ—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞.
    *   **Remote Config:** –ê–¥—Ä–µ—Å–∞ API –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –ø—Ä–∏–ª–µ—Ç–∞—é—Ç –∏–∑ Firebase. –ï—Å–ª–∏ –æ–¥–∏–Ω –¥–æ–º–µ–Ω –±–∞–Ω—è—Ç, —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ –º–µ–Ω—è—é—Ç –∫–æ–Ω—Ñ–∏–≥, –∏ –∫–ª–∏–µ–Ω—Ç—ã "–ø–µ—Ä–µ–µ–∑–∂–∞—é—Ç" –Ω–∞ –∑–µ—Ä–∫–∞–ª–æ.
*   **–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ —Ç—Ä–∞—Ñ–∏–∫–∞:** "Control Plane" (–º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ) –∏–¥–µ—Ç —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏, "Data Plane" (—Ç–æ—Ä—Ä–µ–Ω—Ç—ã) ‚Äî –Ω–∞–ø—Ä—è–º—É—é P2P.

### 2.3. NUM (Tor & Scraping)
*   **Onion Routing:** –í—à–∏—Ç–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ `libtor.so` –ø–æ–∑–≤–æ–ª—è–µ—Ç –∑–∞–≤–µ—Ä–Ω—É—Ç—å API-–∑–∞–ø—Ä–æ—Å—ã –≤ —Å–µ—Ç—å Tor –≤ —Å–ª—É—á–∞–µ —Ç–æ—Ç–∞–ª—å–Ω–æ–≥–æ —à–∞—Ç–¥–∞—É–Ω–∞.
*   **Web Scraping Fallback:** –ï—Å–ª–∏ API –º–µ—Ä—Ç–≤–æ, –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –ø–∞—Ä—Å–∏—Ç HTML-—Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å–∞–π—Ç–æ–≤-–∞–≥—Ä–µ–≥–∞—Ç–æ—Ä–æ–≤ (Rezka, Kinopoisk), –∏—Å–ø–æ–ª—å–∑—É—è CSS-—Å–µ–ª–µ–∫—Ç–æ—Ä—ã. –≠—Ç–æ –≤—ã–≥–ª—è–¥–∏—Ç –¥–ª—è DPI –∫–∞–∫ –æ–±—ã—á–Ω—ã–π –≤–µ–±-—Å–µ—Ä—Ñ–∏–Ω–≥.

---

## 3. –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –º–µ—Ç–æ–¥—ã –æ–±—Ö–æ–¥–∞ DPI (Deep Packet Inspection)

### 3.1. ClientHello Fragmentation
*   **–°—É—Ç—å:** –†–∞–∑–±–∏–µ–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ TCP-–ø–∞–∫–µ—Ç–∞ (TLS ClientHello) –Ω–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã.
*   **–≠—Ñ—Ñ–µ–∫—Ç:** –î–æ–º–µ–Ω–Ω–æ–µ –∏–º—è (SNI) –æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è "—Ä–∞–∑—Ä–µ–∑–∞–Ω–æ" –º–µ–∂–¥—É –ø–∞–∫–µ—Ç–∞–º–∏. DPI, –Ω–µ —É–º–µ—é—â–∏–π —Å–æ–±–∏—Ä–∞—Ç—å —Å–µ—Å—Å–∏–∏ (Stateful Reassembly) –Ω–∞ –ª–µ—Ç—É, –Ω–µ –≤–∏–¥–∏—Ç –∑–∞–ø—Ä–µ—â–µ–Ω–Ω–æ–≥–æ –¥–æ–º–µ–Ω–∞ –∏ –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç –ø–∞–∫–µ—Ç—ã. –°–µ—Ä–≤–µ—Ä –∂–µ —Å–æ–±–∏—Ä–∞–µ—Ç –∏—Ö –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ.

### 3.2. ECH (Encrypted Client Hello)
*   **–°—É—Ç—å:** –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ SNI –∫–ª—é—á–æ–º, –ø–æ–ª—É—á–µ–Ω–Ω—ã–º —á–µ—Ä–µ–∑ DNS.
*   **–°—Ç–∞—Ç—É—Å:** "–°–µ—Ä–µ–±—Ä—è–Ω–∞—è –ø—É–ª—è". –ï—Å–ª–∏ TMDB –≤–Ω–µ–¥—Ä–∏—Ç ECH + Cloudflare, —Ç–æ—á–µ—á–Ω–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —Å—Ç–∞–Ω–µ—Ç –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ–π –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –≤—Å–µ–≥–æ Cloudflare –ø–æ IP.

### 3.3. QUIC (HTTP/3)
*   **–°—É—Ç—å:** –†–∞–±–æ—Ç–∞ –ø–æ–≤–µ—Ä—Ö UDP.
*   **–≠—Ñ—Ñ–µ–∫—Ç:** –ú–Ω–æ–≥–∏–µ —Å–∏—Å—Ç–µ–º—ã DPI –ø–ª–æ—Ö–æ –∞–Ω–∞–ª–∏–∑–∏—Ä—É—é—Ç UDP –∏–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã —Ç–æ–ª—å–∫–æ –Ω–∞ TCP-—Å–±—Ä–æ—Å—ã.

---

## 4. –í—ã–≤–æ–¥—ã –¥–ª—è PWA-TorServe

1.  **–ù–∞—à–µ —Ç–µ–∫—É—â–µ–µ —Ä–µ—à–µ–Ω–∏–µ (Offline Mode + Gradients)** ‚Äî —ç—Ç–æ –ø—Ä–∏–∑–Ω–∞–Ω–∏–µ "–ø–æ—Ä–∞–∂–µ–Ω–∏—è" –≤ –ø—Ä—è–º–æ–π –±–∏—Ç–≤–µ, –Ω–æ –ø–æ–±–µ–¥–∞ –≤ UX. –ú—ã —É—à–ª–∏ —Å –ø–æ–ª—è –±–æ—è.
2.  **–ü—É—Ç—å —Ä–∞–∑–≤–∏—Ç–∏—è:** –ß—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å –ø–æ—Å—Ç–µ—Ä—ã, –Ω–∞–º –Ω–µ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–æ—Å—Ç–æ `fetch`. –ù–∞–º –Ω—É–∂–Ω–æ:
    *   –õ–∏–±–æ **BFF** (—Å–≤–æ–π —Å–µ—Ä–≤–µ—Ä –≤ –ï–≤—Ä–æ–ø–µ + –ø—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ).
    *   –õ–∏–±–æ **Client-Side Proxy** (wsrv.nl), –Ω–æ –Ω—É–∂–Ω–æ –±—ã—Ç—å –≥–æ—Ç–æ–≤—ã–º –∫ –∫–∞–ø—á–∞–º.
    *   –õ–∏–±–æ **VPN –Ω–∞ —É—Ä–æ–≤–Ω–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞** (—Å–∞–º—ã–π –Ω–∞–¥–µ–∂–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –¥–ª—è –¥–æ–º–∞).

*–ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º. –ê–Ω–∞–ª–∏–∑ –≤—ã–ø–æ–ª–Ω–µ–Ω Antigravity.*

```

---

### docs/alt_search.js

```js
(function () {
    'use strict';

    function startsWith(str, searchString) {
      return str.lastIndexOf(searchString, 0) === 0;
    }

    var network = new Lampa.Reguest();
    var cache = {};
    var CACHE_SIZE = 100;
    var CACHE_TIME = 1000 * 60 * 60;
    var SOURCE_NAME = atob('SU1EQg==');
    var SOURCE_TITLE = atob('SU1EQg==');
    var SEARCH_METHOD = atob('c3VnZ2VzdGlvbi90aXRsZXMveC8=');
    var SEARCH_SUFFIX = atob('Lmpzb24/aW5jbHVkZVZpZGVvcz0x');
    var prox = (window.location.protocol === 'https:' ? 'https://' : 'http://') + 'iqslgbok.deploy.cx/';
    var host = atob('aHR0cHM6Ly93d3cuaW1kYi5jb20=');
    var ref = host + '/';
    var user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36';
    var headers = Lampa.Platform.is('android') ? {
      'Origin': host,
      'Referer': ref,
      'User-Agent': user_agent
    } : {};

    if (Lampa.Platform.is('android') || !startsWith(window.location.protocol, 'http')) {
      prox = '';
    }

    var prox_enc = '';

    if (prox) {
      prox_enc += 'param/Origin=' + encodeURIComponent(host) + '/';
      prox_enc += 'param/Referer=' + encodeURIComponent(ref) + '/';
      prox_enc += 'param/User-Agent=' + encodeURIComponent(user_agent) + '/';
    }

    function get(method, oncomplite, onerror) {
      var url = atob('aHR0cHM6Ly92My5zZy5tZWRpYS1pbWRiLmNvbS8=');
      url += method;
      network.timeout(15000);
      network["native"](prox + prox_enc + url, function (json) {
        oncomplite(json);
      }, onerror, false, {
        headers: headers
      });
    }

    function getCache(key) {
      var res = cache[key];

      if (res) {
        var cache_timestamp = new Date().getTime() - CACHE_TIME;
        if (res.timestamp > cache_timestamp) return res.value;

        for (var ID in cache) {
          var node = cache[ID];
          if (!(node && node.timestamp > cache_timestamp)) delete cache[ID];
        }
      }

      return null;
    }

    function setCache(key, value) {
      var timestamp = new Date().getTime();
      var size = Object.keys(cache).length;

      if (size >= CACHE_SIZE) {
        var cache_timestamp = timestamp - CACHE_TIME;

        for (var ID in cache) {
          var node = cache[ID];
          if (!(node && node.timestamp > cache_timestamp)) delete cache[ID];
        }

        size = Object.keys(cache).length;

        if (size >= CACHE_SIZE) {
          var timestamps = [];

          for (var _ID in cache) {
            var _node = cache[_ID];
            timestamps.push(_node && _node.timestamp || 0);
          }

          timestamps.sort(function (a, b) {
            return a - b;
          });
          cache_timestamp = timestamps[Math.floor(timestamps.length / 2)];

          for (var _ID2 in cache) {
            var _node2 = cache[_ID2];
            if (!(_node2 && _node2.timestamp > cache_timestamp)) delete cache[_ID2];
          }
        }
      }

      cache[key] = {
        timestamp: timestamp,
        value: value
      };
    }

    function getFromCache(method, oncomplite, onerror) {
      var json = getCache(method);

      if (json) {
        setTimeout(function () {
          oncomplite(json, true);
        }, 10);
      } else get(method, oncomplite, onerror);
    }

    function clear() {
      network.clear();
    }

    function convertElem(elem) {
      var type = !elem.qid || elem.qid === 'movie' || elem.qid === 'tvMovie' ? 'movie' : 'tv';
      var alt_id = elem.id || '';
      var title = elem.l || '';
      var original_title = elem.l || '';
      var result = {
        "source": SOURCE_NAME,
        "type": type,
        "adult": false,
        "id": SOURCE_NAME + '_' + alt_id,
        "title": title,
        "original_title": original_title,
        "overview": '',
        "img": elem.i && elem.i.imageUrl || '',
        "background_image": elem.i && elem.i.imageUrl || '',
        "genres": [],
        "production_companies": [],
        "production_countries": [],
        "vote_average": 0,
        "vote_count": 0,
        "kinopoisk_id": '',
        "kp_rating": 0,
        "imdb_id": alt_id,
        "imdb_rating": 0
      };
      var first_air_date = elem.y || '';

      if (type === 'tv') {
        result.name = title;
        result.original_name = original_title;
        result.first_air_date = first_air_date + '';
      } else {
        result.release_date = first_air_date + '';
      }

      if (type === 'tv') {
        result.number_of_seasons = 1;
        result.seasons = [];
        result.number_of_episodes = 0;
      }

      return result;
    }

    function cleanTitle(str) {
      return str.replace(/[\s.,:;‚Äô'`!?]+/g, ' ').trim();
    }

    function normalizeTitle(str) {
      return cleanTitle(str.toLowerCase().replace(/[\-\u2010-\u2015\u2E3A\u2E3B\uFE58\uFE63\uFF0D]+/g, '-').replace(/—ë/g, '–µ'));
    }

    function containsTitle(str, title) {
      return typeof str === 'string' && typeof title === 'string' && normalizeTitle(str).indexOf(normalizeTitle(title)) !== -1;
    }

    function getList(method) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var oncomplite = arguments.length > 2 ? arguments[2] : undefined;
      var onerror = arguments.length > 3 ? arguments[3] : undefined;
      var url = method;

      if (params.query) {
        var clean_title = params.query && cleanTitle(decodeURIComponent(params.query));

        if (!clean_title) {
          onerror();
          return;
        }

        url += encodeURIComponent(clean_title) + SEARCH_SUFFIX;
      }

      getFromCache(url, function (json, cached) {
        var items = [];
        if (json && json.d && json.d.length) items = json.d;
        if (!cached && items.length) setCache(url, json);
        var results = items.map(function (elem) {
          return convertElem(elem);
        });
        results = results.filter(function (elem) {
          return !elem.adult;
        });
        var res = {
          "results": results,
          "url": method,
          "page": 1,
          "total_pages": 1,
          "total_results": 0,
          "more": 0
        };
        oncomplite(res);
      }, onerror);
    }

    function _getById(id) {
      var oncomplite = arguments.length > 2 ? arguments[2] : undefined;
      var onerror = arguments.length > 3 ? arguments[3] : undefined;
      var url = SEARCH_METHOD + id + SEARCH_SUFFIX;
      var film = getCache(url);

      if (film) {
        setTimeout(function () {
          if (film && film.d && film.d[0] && film.d[0].id) {
            oncomplite(convertElem(film.d[0]));
          } else onerror();
        }, 10);
      } else {
        get(url, function (film) {
          if (film && film.d && film.d[0] && film.d[0].id) {
            oncomplite(convertElem(film.d[0]));
          } else onerror();
        }, onerror);
      }
    }

    function getById(id) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var oncomplite = arguments.length > 2 ? arguments[2] : undefined;
      var onerror = arguments.length > 3 ? arguments[3] : undefined;
      menu({}, function () {
        return _getById(id, params, oncomplite, onerror);
      });
    }

    function main() {
      var oncomplite = arguments.length > 1 ? arguments[1] : undefined;
      var onerror = arguments.length > 2 ? arguments[2] : undefined;
      var parts_limit = 0;
      var parts_data = [];

      function loadPart(partLoaded, partEmpty) {
        Lampa.Api.partNext(parts_data, parts_limit, partLoaded, partEmpty);
      }

      loadPart(oncomplite, onerror);
      return loadPart;
    }

    function category() {
      var oncomplite = arguments.length > 1 ? arguments[1] : undefined;
      var onerror = arguments.length > 2 ? arguments[2] : undefined;
      var parts_limit = 0;
      var parts_data = [];

      function loadPart(partLoaded, partEmpty) {
        Lampa.Api.partNext(parts_data, parts_limit, partLoaded, partEmpty);
      }

      loadPart(oncomplite, onerror);
      return loadPart;
    }

    function full() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var oncomplite = arguments.length > 1 ? arguments[1] : undefined;
      var onerror = arguments.length > 2 ? arguments[2] : undefined;
      var alt_id = '';

      if (params.card && params.card.source === SOURCE_NAME) {
        if (params.card.imdb_id) {
          alt_id = params.card.imdb_id;
        } else if (startsWith(params.card.id + '', SOURCE_NAME + '_')) {
          alt_id = (params.card.id + '').substring(SOURCE_NAME.length + 1);
          params.card.imdb_id = alt_id;
        }
      }

      if (alt_id) {
        getById(alt_id, params, function (json) {
          var status = new Lampa.Status(4);
          status.onComplite = oncomplite;
          status.append('movie', json);
          status.append('persons', json && json.persons);
          status.append('collection', json && json.collection);
          status.append('simular', json && json.simular);
        }, onerror);
      } else onerror();
    }

    function list() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var oncomplite = arguments.length > 1 ? arguments[1] : undefined;
      var onerror = arguments.length > 2 ? arguments[2] : undefined;
      var method = params.url;
      getList(method, params, oncomplite, onerror);
    }

    function search() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var oncomplite = arguments.length > 1 ? arguments[1] : undefined;
      var title = decodeURIComponent(params.query || '');
      var status = new Lampa.Status(1);

      status.onComplite = function (data) {
        var items = [];

        if (data.query && data.query.results) {
          var tmp = data.query.results.filter(function (elem) {
            return containsTitle(elem.title, title) || containsTitle(elem.original_title, title);
          });

          if (tmp.length && tmp.length !== data.query.results.length) {
            data.query.results = tmp;
            data.query.more = true;
          }

          var movie = {};
          Lampa.Arrays.extend(movie, data.query);
          movie.results = data.query.results.filter(function (elem) {
            return elem.type === 'movie';
          });
          movie.title = Lampa.Lang.translate('menu_movies');
          movie.type = 'movie';
          if (movie.results.length) items.push(movie);
          var tv = {};
          Lampa.Arrays.extend(tv, data.query);
          tv.results = data.query.results.filter(function (elem) {
            return elem.type === 'tv';
          });
          tv.title = Lampa.Lang.translate('menu_tv');
          tv.type = 'tv';
          if (tv.results.length) items.push(tv);
        }

        oncomplite(items);
      };

      getList(SEARCH_METHOD, params, function (json) {
        status.append('query', json);
      }, status.error.bind(status));
    }

    function discovery() {
      return {
        title: SOURCE_TITLE,
        search: search,
        params: {
          align_left: true,
          object: {
            source: SOURCE_NAME
          }
        },
        onMore: function onMore(params) {
          Lampa.Activity.push({
            url: SEARCH_METHOD,
            title: Lampa.Lang.translate('search') + ' - ' + params.query,
            component: 'category_full',
            page: 1,
            query: encodeURIComponent(params.query),
            source: SOURCE_NAME
          });
        },
        onCancel: network.clear.bind(network)
      };
    }

    function person() {
      var oncomplite = arguments.length > 1 ? arguments[1] : undefined;
      oncomplite({});
    }

    function menu() {
      var oncomplite = arguments.length > 1 ? arguments[1] : undefined;
      oncomplite([]);
    }

    function menuCategory(params, oncomplite) {
      oncomplite([]);
    }

    function seasons(tv, from, oncomplite) {
      oncomplite({});
    }

    var ALT = {
      SOURCE_NAME: SOURCE_NAME,
      SOURCE_TITLE: SOURCE_TITLE,
      main: main,
      menu: menu,
      full: full,
      list: list,
      category: category,
      clear: clear,
      person: person,
      seasons: seasons,
      menuCategory: menuCategory,
      discovery: discovery
    };

    function startPlugin() {
      window.alt_source_plugin = true;

      function addPlugin() {
        if (Lampa.Api.sources[ALT.SOURCE_NAME]) {
          Lampa.Noty.show('–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–ª–∞–≥–∏–Ω –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π —Å alt_search');
          return;
        }

        Lampa.Api.sources[ALT.SOURCE_NAME] = ALT;
        Object.defineProperty(Lampa.Api.sources, ALT.SOURCE_NAME, {
          get: function get() {
            return ALT;
          }
        });
      }

      if (window.appready) addPlugin();else {
        Lampa.Listener.follow('app', function (e) {
          if (e.type == 'ready') addPlugin();
        });
      }
    }

    if (!window.alt_source_plugin) startPlugin();

})();

```

---

### docs/cloudflare_worker.js

```js
export default {
  async fetch(request) {
    const corsHeaders = {
      headers: {
        "Access-Control-Allow-Origin": "*",
      },
    };
    const corsOptionsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, HEAD, POST, OPTIONS",
      "Access-Control-Max-Age": "86400",
    };

    async function handleRequest(request) {
      const url = new URL(request.url);
      let api_pos = url.origin.length + 1;
      let api = url.href.substring(api_pos);
      let proxy_url = url.href;
      let proxy = "";
      let proxy_enc = "";
      let enc = "";
      let ip = "";
      let redirect = request.method === "POST" ? "manual" : "follow";
      let get_cookie = false;
      let cookie_plus = false;
      let get_redirect = false;
      let force_head = false;
      let remove_compression = false;
      let params = [];
      let cdn_info = "cdn_X8v8IbU8";
      let user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36";

      if (api === "headers") {
        let body = "";
        request.headers.forEach((value, key) => body += key + " = " + value + "\n");
        body += "request_url" + " = " + request.url + "\n";
        body += "worker_version = 1.14\n";
        return new Response(body, corsHeaders);
      }

      let real_ip = "";
      let forwarded_for = request.headers.get("X-Forwarded-For");
      if (forwarded_for) real_ip = forwarded_for.split(",").map(s=>s.trim()).find(s=>s && !s.match(/^(127\.|10\.|172\.1[6-9]|172\.2[0-9]|172\.3[01]|192\.168\.)/)) || "";
      if (!real_ip) real_ip = request.headers.get("cf-connecting-ip");
      if (!real_ip) real_ip = request.headers.get("X-Real-IP");

      if (api === "jsonip") {
          return new Response(JSON.stringify({ip: real_ip}), {
            headers: {
              "Access-Control-Allow-Origin": "*",
              "Vary": "Origin",
              "Content-Type": "application/json; charset=utf-8",
            },
          });
      }

      if (api.startsWith("?")) {
        api_pos += 1;
        api = api.substring(1);
      }

      let next_param = true;
      while (next_param) {
        if (api.startsWith("ip")) {
          let pos = api.indexOf("/");
          if (pos !== -1) {
            ip = api.substring(2, pos);
            api_pos += pos + 1;
            api = api.substring(pos + 1);
          } else {
            ip = api.substring(2);
            api_pos += api.length;
            api = "";
          }
        } else if (api.startsWith("redirect=")) {
          let pos = api.indexOf("/");
          if (pos !== -1) {
            redirect = api.substring(9, pos);
            api_pos += pos + 1;
            api = api.substring(pos + 1);
          } else {
            redirect = api.substring(9);
            api_pos += api.length;
            api = "";
          }
        } else if (api.startsWith("get_cookie/")) {
          get_cookie = true;
          api_pos += 11;
          api = api.substring(11);
        } else if (api.startsWith("cookie_plus/")) {
          cookie_plus = true;
          remove_compression = true;
          api_pos += 12;
          api = api.substring(12);
        } else if (api.startsWith("get_redirect/")) {
          get_redirect = true;
          redirect = "manual";
          api_pos += 13;
          api = api.substring(13);
        } else if (api.startsWith("head/")) {
          force_head = true;
          api_pos += 5;
          api = api.substring(5);
        } else if (api.startsWith("param?") || api.startsWith("param/")) {
          api_pos += 6;
          api = api.substring(6);
          let param;
          let pos = api.indexOf("/");
          if (pos !== -1) {
            param = api.substring(0, pos);
            api_pos += pos + 1;
            api = api.substring(pos + 1);
          } else {
            param = api.substring(0);
            api_pos += api.length;
            api = "";
          }
          pos = param.indexOf("=");
          if (pos !== -1) {
            params.push([param.substring(0, pos), param.substring(pos + 1)]);
          } else {
            params.push([param]);
          }
        } else if (api.startsWith("enc/") || api.startsWith("enc1/") || api.startsWith("enc2/")) {
          let cur_enc = api.substring(0, api.indexOf("/"));
          if (enc) {
            proxy_enc += proxy_url.substring(0, api_pos);
          } else {
            proxy += proxy_url.substring(0, api_pos);
            enc = cur_enc;
          }
          api = api.substring(cur_enc.length + 1);
          let pos = api.indexOf("/");
          if (pos !== -1) {
            api = atob(decodeURIComponent(api.substring(0, pos))) + (cur_enc === "enc2" ? "" : api.substring(pos + 1));
          } else {
            api = atob(decodeURIComponent(api.substring(0)));
          }
          proxy_url = api;
          api_pos = 0;
        } else {
          next_param = false;
        }
      }

      if (enc) {
        proxy_enc += proxy_url.substring(0, api_pos);
      } else {
        proxy += proxy_url.substring(0, api_pos);
      }

      let forwarded_proto = request.headers.get("X-Forwarded-Proto");
      if (forwarded_proto) forwarded_proto = forwarded_proto.split(",")[0].trim();
      if (forwarded_proto === "https") proxy = proxy.replace("http://", "https://");

      if (!ip) ip = real_ip;

      if (!api || !/^https?:\/\/[^\/]/.test(api)) {
        let error = "Malformed URL";
        return new Response(error + ": " + api, {
          ...corsHeaders,
          status: 404,
          statusText: error,
        });
      }
      const apiUrl = new URL(api);
      let apiBase = apiUrl.href.substring(0, apiUrl.href.lastIndexOf("/") + 1);

      // Rewrite request to point to API URL. This also makes the request mutable
      // so you can add the correct Origin header to make the API server think
      // that this request is not cross-site.
      request = new Request(api, request);
      if (force_head) {
        request = new Request(request, {method: "HEAD"});
      }

      let cdn_loop = request.headers.get("CDN-Loop");
      if (cdn_loop && cdn_loop.indexOf(cdn_info) !== -1) {
        let error = "CDN-Loop detected";
        return new Response(error, {
          ...corsHeaders,
          status: 403,
          statusText: error,
        });
      } else {
        request.headers.append("CDN-Loop", cdn_info);
      }

      request.headers.set("Origin", apiUrl.origin);
      request.headers.set("Referer", apiUrl.origin + "/");
      if (true) {
        request.headers.delete("Sec-Fetch-Dest");
        request.headers.delete("Sec-Fetch-Mode");
        request.headers.delete("Sec-Fetch-Site");
        request.headers.delete("Sec-Fetch-User");
        request.headers.delete("Sec-CH-UA");
        request.headers.delete("Sec-CH-UA-Mobile");
        request.headers.delete("Sec-CH-UA-Platform");
        request.headers.delete("Host");
      }
      if (true) {
        request.headers.delete("X-Forwarded-For");
        request.headers.delete("X-Forwarded-Proto");
        //request.headers.delete("X-Real-IP");
        //request.headers.delete("cf-connecting-ip");
        request.headers.delete("cf-ipcountry");
        request.headers.delete("cf-ray");
        request.headers.delete("cf-visitor");
      }
      if (ip && ip !== "no") {
        //request.headers.set("X-Forwarded-For", ip);
        //request.headers.set("X-Forwarded-Proto", "https");
        request.headers.set("X-Real-IP", ip);
        request.headers.set("cf-connecting-ip", ip);
      }
      if (apiUrl.hostname === "rezka.ag" || apiUrl.hostname === "hdrezka.ag" || apiUrl.hostname === "hdrezka.me" || apiUrl.hostname === "hdrezka.sh" || apiUrl.hostname === "hdrezka.cm" || apiUrl.hostname === "hdrezka.kim" || apiUrl.hostname === "hdrezka.la" || apiUrl.hostname === "rezka.pub" || apiUrl.hostname === "kinopub.me") {
        request.headers.set("User-Agent", user_agent);
      }
      if (apiUrl.hostname.endsWith(".svetacdn.in")) {
        request.headers.set("Origin", "https://videocdn.tv");
        request.headers.set("Referer", "https://videocdn.tv/");
      }
      if (apiUrl.hostname === "api.lumex.pw") {
        request.headers.set("User-Agent", user_agent);
        request.headers.set("Origin", "https://p.lumex.pw");
        request.headers.set("Referer", "https://p.lumex.pw/");
        request.headers.set("Sec-Fetch-Dest", "empty");
        request.headers.set("Sec-Fetch-Mode", "cors");
        request.headers.set("Sec-Fetch-Site", "same-site");
      }
      if (apiUrl.hostname.endsWith("cdnmovies-stream.online") || apiUrl.hostname.endsWith("cdnmovies-hls-stream.online") || apiUrl.hostname.endsWith(".sarnage.cc")) {
        request.headers.set("Origin", "https://cdnmovies.net");
        request.headers.set("Referer", "https://cdnmovies.net/");
      }
      if (apiUrl.hostname.endsWith(".bazon.site")) {
        request.headers.set("User-Agent", user_agent);
        request.headers.set("Origin", "https://bazon.cc");
        request.headers.set("Referer", "https://bazon.cc/");
      }
      if (["kodikapi.com", "kodik.biz", "kodik.info"].indexOf(apiUrl.hostname) !== -1) {
        request.headers.delete("Origin");
        request.headers.delete("Referer");
      }
      if (apiUrl.hostname === "kinoplay.site" || apiUrl.hostname === "kinoplay1.site" || apiUrl.hostname === "kinoplay2.site") {
        request.headers.set("Cookie", "invite=a246a3f46c82fe439a45c3dbbbb24ad5");
      }
      if (remove_compression) {
        let encoding = (request.headers.get("Accept-Encoding") || "");
        if (encoding.includes("zstd") || encoding.includes("deflate")) {
          encoding = encoding.split(",").filter(enc=>!(enc.includes("zstd") || enc.includes("deflate"))).join(",") || "identity";
          request.headers.set("Accept-Encoding", encoding);
        }
      }
      params.forEach(param => {
        if (param[0]) {
          if (param[1]) {
            request.headers.set(decodeURIComponent(param[0]), decodeURIComponent(param[1] || ""));
          } else {
            request.headers.delete(decodeURIComponent(param[0]));
          }
        }
      });
      let response = await fetch(request, {
        redirect: redirect,
      });
      let currentUrl = response.url;

      // Recreate the response so you can modify the headers
      response = new Response(response.body, response);

      // Set CORS headers
      response.headers.set("Access-Control-Allow-Origin", "*");

      // Append to/Add Vary header so browser will cache response correctly
      response.headers.append("Vary", "Origin");

      if (response.status >= 200 && response.status < (get_redirect ? 400 : 300)) {
        let ctype = (response.headers.get("Content-Type") || "").split(";")[0].toLowerCase();
        if (get_cookie || cookie_plus || get_redirect) {
          let json = {};
          json.currentUrl = currentUrl;
          if (get_redirect) {
            let target = response.headers.get("Location");
            if (target) {
                json.redirectUrl = fixLink(target, apiUrl, apiBase);
                response.headers.set("Location", json.redirectUrl);
            }
          }
          if (get_cookie || cookie_plus) {
            json.cookie = response.headers.getSetCookie();
          }
          if (cookie_plus) {
            let headers = {};
            for (let key of response.headers.keys()) {
              if (key === "set-cookie") {
                headers[key] = json.cookie;
              } else {
                headers[key] = response.headers.get(key);
              }
            }
            json.headers = headers;
            if (ctype.startsWith("text/") || ["application/json", "application/xml", "application/x-mpegurl", "application/vnd.apple.mpegurl", "application/dash+xml"].indexOf(ctype) !== -1) {
              json.body = await response.text();
            }
          }
          return new Response(JSON.stringify(json), {
            headers: {
              "Access-Control-Allow-Origin": "*",
              "Vary": "Origin",
              "Content-Type": "application/json; charset=utf-8",
            },
          });
        }
      }

      // Fix redirect URL
      if (response.status >= 300 && response.status < 400) {
        let target = response.headers.get("Location");
        if (target) {
          response.headers.set("Location", proxyLink(fixLink(target, apiUrl, apiBase), proxy, proxy_enc, enc));
        }
      }

      return response;
    }

    function fixLink(link, url, base) {
      if (link) {
        if (link.indexOf("://") !== -1) return link;
        if (link.startsWith("//")) return url.protocol + link;
        if (link.startsWith("/")) return url.origin + link;
        if (link.startsWith("?")) return url.origin + url.pathname + link;
        if (link.startsWith("#")) return url.origin + url.pathname + url.search + link;
        return base + link;
      }
      return link;
    }

    function proxyLink(link, proxy, proxy_enc, enc) {
      if (link) {
        if (enc === "enc") {
          let pos = link.indexOf("/");
          if (pos !== -1 && link.charAt(pos + 1) === "/") pos++;
          let part1 = pos !== -1 ? link.substring(0, pos + 1) : "";
          let part2 = pos !== -1 ? link.substring(pos + 1) : link;
          return proxy + "enc/" + encodeURIComponent(btoa(proxy_enc + part1)) + "/" + part2;
        }
        if (enc === "enc1") {
          let pos = link.lastIndexOf("/");
          let part1 = pos !== -1 ? link.substring(0, pos + 1) : "";
          let part2 = pos !== -1 ? link.substring(pos + 1) : link;
          return proxy + "enc1/" + encodeURIComponent(btoa(proxy_enc + part1)) + "/" + part2;
        }
        if (enc === "enc2") {
          let posEnd = link.lastIndexOf("?");
          let posStart = link.lastIndexOf("://");
          if (posEnd === -1 || posEnd <= posStart) posEnd = link.length;
          if (posStart === -1) posStart = -3;
          let name = link.substring(posStart + 3, posEnd);
          posStart = name.lastIndexOf("/");
          name = posStart !== -1 ? name.substring(posStart + 1) : "";
          return proxy + "enc2/" + encodeURIComponent(btoa(proxy_enc + link)) + "/" + name;
        }
        return proxy + proxy_enc + link;
      }
      return link;
    }

    async function handleOptions(request) {
      if (
        request.headers.get("Origin") !== null &&
        request.headers.get("Access-Control-Request-Method") !== null &&
        request.headers.get("Access-Control-Request-Headers") !== null
      ) {
        // Handle CORS preflight requests.
        return new Response(null, {
          headers: {
            ...corsOptionsHeaders,
            "Access-Control-Allow-Headers": request.headers.get(
              "Access-Control-Request-Headers"
            ),
          },
        });
      } else {
        // Handle standard OPTIONS request.
        return new Response(null, {
          headers: {
            Allow: "GET, HEAD, POST, OPTIONS",
          },
        });
      }
    }

    try {
      if (request.method === "OPTIONS") {
        // Handle CORS preflight requests
        return await handleOptions(request);
      } else if (
        request.method === "GET" ||
        request.method === "HEAD" ||
        request.method === "POST"
      ) {
        // Handle requests to the API server
        return await handleRequest(request);
      } else {
        let error = "Method Not Allowed";
        return new Response(error + ": " + request.method, {
          ...corsHeaders,
          status: 405,
          statusText: error,
        });
      }
    } catch (err) {
      let error = "Internal Server Error";
      return new Response(error + ": " + err + "\n" + (err.stack || ""), {
          ...corsHeaders,
        status: 500,
        statusText: error,
      });
    }
  },
};
```

---

### docs/deno_apn.js

```js
async function handle(request, connInfo) {
    const corsHeaders = {
      headers: {
        "Access-Control-Allow-Origin": "*",
      },
    };
    const corsOptionsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, HEAD, POST, OPTIONS",
      "Access-Control-Max-Age": "86400",
    };

    async function handleRequest(request, connInfo) {
      const url = new URL(request.url);
      let api_pos = url.origin.length + 1;
      let api = url.href.substring(api_pos);
      let proxy_url = url.href;
      let proxy = "";
      let proxy_enc = "";
      let enc = "";
      let ip = "no";
      let redirect = request.method === "POST" ? "manual" : "follow";
      let get_cookie = false;
      let cookie_plus = false;
      let get_redirect = false;
      let force_head = false;
      let remove_compression = false;
      let params = [];
      let cdn_info = "cdn_c8Bc9aMo";
      let user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36";

      if (api === "headers") {
        let body = "";
        request.headers.forEach((value, key) => body += key + " = " + value + "\n");
        if (connInfo && connInfo.remoteAddr) {
          body += "connInfo" + " = " + JSON.stringify(connInfo.remoteAddr) + "\n";
        }
        body += "request_url" + " = " + request.url + "\n";
        body += "apn_version = 1.14\n";
        return new Response(body, corsHeaders);
      }

      let real_ip = "";
      let forwarded_for = request.headers.get("X-Forwarded-For");
      if (forwarded_for) real_ip = forwarded_for.split(",").map(s=>s.trim()).find(s=>s && !s.match(/^(127\.|10\.|172\.1[6-9]|172\.2[0-9]|172\.3[01]|192\.168\.)/)) || "";
      if (!real_ip) real_ip = request.headers.get("cf-connecting-ip");
      if (!real_ip) real_ip = request.headers.get("X-Real-IP");
      if (!real_ip) real_ip = connInfo && connInfo.remoteAddr && connInfo.remoteAddr.hostname || "";

      if (api === "jsonip") {
          return new Response(JSON.stringify({ip: real_ip}), {
            headers: {
              "Access-Control-Allow-Origin": "*",
              "Vary": "Origin",
              "Content-Type": "application/json; charset=utf-8",
            },
          });
      }

      if (api.startsWith("?")) {
        api_pos += 1;
        api = api.substring(1);
      }

      let next_param = true;
      while (next_param) {
        if (api.startsWith("ip")) {
          let pos = api.indexOf("/");
          if (pos !== -1) {
            ip = api.substring(2, pos);
            api_pos += pos + 1;
            api = api.substring(pos + 1);
          } else {
            ip = api.substring(2);
            api_pos += api.length;
            api = "";
          }
        } else if (api.startsWith("redirect=")) {
          let pos = api.indexOf("/");
          if (pos !== -1) {
            redirect = api.substring(9, pos);
            api_pos += pos + 1;
            api = api.substring(pos + 1);
          } else {
            redirect = api.substring(9);
            api_pos += api.length;
            api = "";
          }
        } else if (api.startsWith("get_cookie/")) {
          get_cookie = true;
          api_pos += 11;
          api = api.substring(11);
        } else if (api.startsWith("cookie_plus/")) {
          cookie_plus = true;
          remove_compression = true;
          api_pos += 12;
          api = api.substring(12);
        } else if (api.startsWith("get_redirect/")) {
          get_redirect = true;
          redirect = "manual";
          api_pos += 13;
          api = api.substring(13);
        } else if (api.startsWith("head/")) {
          force_head = true;
          api_pos += 5;
          api = api.substring(5);
        } else if (api.startsWith("param?") || api.startsWith("param/")) {
          api_pos += 6;
          api = api.substring(6);
          let param;
          let pos = api.indexOf("/");
          if (pos !== -1) {
            param = api.substring(0, pos);
            api_pos += pos + 1;
            api = api.substring(pos + 1);
          } else {
            param = api.substring(0);
            api_pos += api.length;
            api = "";
          }
          pos = param.indexOf("=");
          if (pos !== -1) {
            params.push([param.substring(0, pos), param.substring(pos + 1)]);
          } else {
            params.push([param]);
          }
        } else if (api.startsWith("enc/") || api.startsWith("enc1/") || api.startsWith("enc2/")) {
          let cur_enc = api.substring(0, api.indexOf("/"));
          if (enc) {
            proxy_enc += proxy_url.substring(0, api_pos);
          } else {
            proxy += proxy_url.substring(0, api_pos);
            enc = cur_enc;
          }
          api = api.substring(cur_enc.length + 1);
          let pos = api.indexOf("/");
          if (pos !== -1) {
            api = atob(decodeURIComponent(api.substring(0, pos))) + (cur_enc === "enc2" ? "" : api.substring(pos + 1));
          } else {
            api = atob(decodeURIComponent(api.substring(0)));
          }
          proxy_url = api;
          api_pos = 0;
        } else {
          next_param = false;
        }
      }

      if (enc) {
        proxy_enc += proxy_url.substring(0, api_pos);
      } else {
        proxy += proxy_url.substring(0, api_pos);
      }

      let forwarded_proto = request.headers.get("X-Forwarded-Proto");
      if (forwarded_proto) forwarded_proto = forwarded_proto.split(",")[0].trim();
      if (forwarded_proto === "https") proxy = proxy.replace("http://", "https://");

      if (!ip) ip = real_ip;

      if (!api || !/^https?:\/\/[^\/]/.test(api)) {
        let error = "Malformed URL";
        return new Response(error + ": " + api, {
          ...corsHeaders,
          status: 404,
          statusText: error,
        });
      }
      const apiUrl = new URL(api);
      let apiBase = apiUrl.href.substring(0, apiUrl.href.lastIndexOf("/") + 1);

      let clientUserAgent = request.headers.get("User-Agent") || '';
      let clientOrigin = request.headers.get("Origin") || '';
      if(
            (/\blampishe\b|\bprisma_client\b/).test(clientUserAgent) ||
            clientOrigin.endsWith("lampishe.cc") ||
            clientOrigin.endsWith("prisma.ws") ||
            clientOrigin.endsWith("bylampa.online")
      ) {
        let error = "Malformed URL";
        return new Response(error + ": " + api, {
          ...corsHeaders,
          status: 404,
          statusText: error,
        });
      }

      // Rewrite request to point to API URL. This also makes the request mutable
      // so you can add the correct Origin header to make the API server think
      // that this request is not cross-site.
      request = new Request(api, request);
      if (force_head) {
        request = new Request(request, {method: "HEAD"});
      }

      let cdn_loop = request.headers.get("CDN-Loop");
      if (cdn_loop && cdn_loop.indexOf(cdn_info) !== -1) {
        let error = "CDN-Loop detected";
        return new Response(error, {
          ...corsHeaders,
          status: 403,
          statusText: error,
        });
      } else {
        request.headers.append("CDN-Loop", cdn_info);
      }

      request.headers.set("Origin", apiUrl.origin);
      request.headers.set("Referer", apiUrl.origin + "/");
      if (true) {
        request.headers.delete("Sec-Fetch-Dest");
        request.headers.delete("Sec-Fetch-Mode");
        request.headers.delete("Sec-Fetch-Site");
        request.headers.delete("Sec-Fetch-User");
        request.headers.delete("Sec-CH-UA");
        request.headers.delete("Sec-CH-UA-Mobile");
        request.headers.delete("Sec-CH-UA-Platform");
        request.headers.delete("Host");
      }
      if (true) {
        request.headers.delete("X-Forwarded-For");
        request.headers.delete("X-Forwarded-Proto");
        //request.headers.delete("X-Real-IP");
        //request.headers.delete("cf-connecting-ip");
        request.headers.delete("cf-ipcountry");
        request.headers.delete("cf-ray");
        request.headers.delete("cf-visitor");
      }
      if (ip && ip !== "no") {
        request.headers.set("X-Forwarded-For", ip);
        request.headers.set("X-Forwarded-Proto", "https");
        request.headers.set("X-Real-IP", ip);
        request.headers.set("cf-connecting-ip", ip);
      }
      if (apiUrl.hostname === "rezka.ag" || apiUrl.hostname === "hdrezka.ag" || apiUrl.hostname === "hdrezka.me" || apiUrl.hostname === "hdrezka.sh" || apiUrl.hostname === "hdrezka.cm" || apiUrl.hostname === "hdrezka.kim" || apiUrl.hostname === "hdrezka.la" || apiUrl.hostname === "rezka.pub" || apiUrl.hostname === "kinopub.me") {
        request.headers.set("User-Agent", user_agent);
      }
      if (apiUrl.hostname.endsWith(".svetacdn.in")) {
        request.headers.set("Origin", "https://videocdn.tv");
        request.headers.set("Referer", "https://videocdn.tv/");
      }
      if (apiUrl.hostname === "api.lumex.pw") {
        request.headers.set("User-Agent", user_agent);
        request.headers.set("Origin", "https://p.lumex.pw");
        request.headers.set("Referer", "https://p.lumex.pw/");
        request.headers.set("Sec-Fetch-Dest", "empty");
        request.headers.set("Sec-Fetch-Mode", "cors");
        request.headers.set("Sec-Fetch-Site", "same-site");
      }
      if (apiUrl.hostname.endsWith("cdnmovies-stream.online") || apiUrl.hostname.endsWith("cdnmovies-hls-stream.online") || apiUrl.hostname.endsWith(".sarnage.cc")) {
        request.headers.set("Origin", "https://cdnmovies.net");
        request.headers.set("Referer", "https://cdnmovies.net/");
      }
      if (apiUrl.hostname.endsWith(".bazon.site")) {
        request.headers.set("User-Agent", user_agent);
        request.headers.set("Origin", "https://bazon.cc");
        request.headers.set("Referer", "https://bazon.cc/");
      }
      if (["kodikapi.com", "kodik.biz", "kodik.info"].indexOf(apiUrl.hostname) !== -1) {
        request.headers.delete("Origin");
        request.headers.delete("Referer");
      }
      if (apiUrl.hostname === "kinoplay.site" || apiUrl.hostname === "kinoplay1.site" || apiUrl.hostname === "kinoplay2.site") {
        request.headers.set("Cookie", "invite=a246a3f46c82fe439a45c3dbbbb24ad5");
      }
      if (apiUrl.pathname.endsWith(".m3u8") || apiUrl.pathname.endsWith(".m3u") || apiUrl.pathname.endsWith(".M3U8") || apiUrl.pathname.endsWith(".M3U") || apiUrl.pathname.endsWith(".mpd") || apiUrl.pathname.endsWith(".MPD")) {
        request.headers.delete("Range");
        remove_compression = true;
      }
      if (remove_compression) {
        let encoding = (request.headers.get("Accept-Encoding") || "");
        if (encoding.includes("zstd") || encoding.includes("deflate")) {
          encoding = encoding.split(",").filter(enc=>!(enc.includes("zstd") || enc.includes("deflate"))).join(",") || "identity";
          request.headers.set("Accept-Encoding", encoding);
        }
      }
      params.forEach(param => {
        if (param[0]) {
          if (param[1]) {
            request.headers.set(decodeURIComponent(param[0]), decodeURIComponent(param[1] || ""));
          } else {
            request.headers.delete(decodeURIComponent(param[0]));
          }
        }
      });
      let response = await fetch(request, {
        redirect: redirect,
      });
      let currentUrl = response.url;

      // Recreate the response so you can modify the headers
      response = new Response(response.body, response);

      // Set CORS headers
      response.headers.set("Access-Control-Allow-Origin", "*");

      // Append to/Add Vary header so browser will cache response correctly
      response.headers.append("Vary", "Origin");

      if (response.status >= 200 && response.status < (get_redirect ? 400 : 300)) {
        let ctype = (response.headers.get("Content-Type") || "").split(";")[0].toLowerCase();
        if (get_cookie || cookie_plus || get_redirect) {
          let json = {};
          json.currentUrl = currentUrl;
          if (get_redirect) {
            let target = response.headers.get("Location");
            if (target) {
                json.redirectUrl = fixLink(target, apiUrl, apiBase);
                response.headers.set("Location", json.redirectUrl);
            }
          }
          if (get_cookie || cookie_plus) {
            json.cookie = response.headers.getSetCookie();
          }
          if (cookie_plus) {
            let headers = {};
            for (let key of response.headers.keys()) {
              if (key === "set-cookie") {
                headers[key] = json.cookie;
              } else {
                headers[key] = response.headers.get(key);
              }
            }
            json.headers = headers;
            if (ctype.startsWith("text/") || ["application/json", "application/xml", "application/x-mpegurl", "application/vnd.apple.mpegurl", "application/dash+xml"].indexOf(ctype) !== -1) {
              json.body = await response.text();
            }
          }
          return new Response(JSON.stringify(json), {
            headers: {
              "Access-Control-Allow-Origin": "*",
              "Vary": "Origin",
              "Content-Type": "application/json; charset=utf-8",
            },
          });
        }
        if (["application/x-mpegurl", "application/vnd.apple.mpegurl"].indexOf(ctype) !== -1) {
          let body = edit_m3u8(await response.text(), apiUrl, apiBase, proxy, proxy_enc, enc);
          response.headers.delete("Content-Length");
          response.headers.delete("Content-Range");
          response.headers.set("Accept-Ranges", "none");
          return new Response(body, response);
        }
        if (["application/dash+xml"].indexOf(ctype) !== -1) {
          let body = edit_mpd(await response.text(), apiUrl, apiBase, proxy, proxy_enc, enc);
          response.headers.delete("Content-Length");
          response.headers.delete("Content-Range");
          response.headers.set("Accept-Ranges", "none");
          return new Response(body, response);
        }
      }

      // Fix redirect URL
      if (response.status >= 300 && response.status < 400) {
        let target = response.headers.get("Location");
        if (target) {
          response.headers.set("Location", proxyLink(fixLink(target, apiUrl, apiBase), proxy, proxy_enc, enc));
        }
      }

      return response;
    }

    function fixLink(link, url, base) {
      if (link) {
        if (link.indexOf("://") !== -1) return link;
        if (link.startsWith("//")) return url.protocol + link;
        if (link.startsWith("/")) return url.origin + link;
        if (link.startsWith("?")) return url.origin + url.pathname + link;
        if (link.startsWith("#")) return url.origin + url.pathname + url.search + link;
        return base + link;
      }
      return link;
    }

    function proxyLink(link, proxy, proxy_enc, enc) {
      if (link) {
        if (enc === "enc") {
          let pos = link.indexOf("/");
          if (pos !== -1 && link.charAt(pos + 1) === "/") pos++;
          let part1 = pos !== -1 ? link.substring(0, pos + 1) : "";
          let part2 = pos !== -1 ? link.substring(pos + 1) : link;
          return proxy + "enc/" + encodeURIComponent(btoa(proxy_enc + part1)) + "/" + part2;
        }
        if (enc === "enc1") {
          let pos = link.lastIndexOf("/");
          let part1 = pos !== -1 ? link.substring(0, pos + 1) : "";
          let part2 = pos !== -1 ? link.substring(pos + 1) : link;
          return proxy + "enc1/" + encodeURIComponent(btoa(proxy_enc + part1)) + "/" + part2;
        }
        if (enc === "enc2") {
          let posEnd = link.lastIndexOf("?");
          let posStart = link.lastIndexOf("://");
          if (posEnd === -1 || posEnd <= posStart) posEnd = link.length;
          if (posStart === -1) posStart = -3;
          let name = link.substring(posStart + 3, posEnd);
          posStart = name.lastIndexOf("/");
          name = posStart !== -1 ? name.substring(posStart + 1) : "";
          return proxy + "enc2/" + encodeURIComponent(btoa(proxy_enc + link)) + "/" + name;
        }
        return proxy + proxy_enc + link;
      }
      return link;
    }

    function edit_m3u8(m3u8, url, base, proxy, proxy_enc, enc) {
      try {
        return m3u8.split("\n").map(org_line => {
          let line = org_line.trim();
          if (line.charAt(0) === "#") {
            return org_line.replace(/\bURI="([^"]*)"/g, (str, link) => {
              link = link.trim();
              if (link) {
                return 'URI="' + proxyLink(fixLink(link, url, base), proxy, proxy_enc, enc) + '"';
              }
              return str;
            });
          } else if(line) {
            return proxyLink(fixLink(line, url, base), proxy, proxy_enc, enc);
          }
          return org_line;
        }).join("\n");
      } catch (err) {
        return m3u8;
      }
    }

    function unescapeXml(str) {
      return str.replace(/&lt;|&gt;|&amp;|&apos;|&quot;/g, function (c) {
        switch (c) {
          case "&lt;": return "<";
          case "&gt;": return ">";
          case "&amp;": return "&";
          case "&apos;": return "'";
          case "&quot;": return '"';
        }
      });
    }

    function escapeXml(str) {
      return str.replace(/[<>&'"]/g, function (c) {
        switch (c) {
          case "<": return "&lt;";
          case ">": return "&gt;";
          case "&": return "&amp;";
          case "'": return "&apos;";
          case '"': return "&quot;";
        }
      });
    }

    function edit_mpd(mpd, url, base, proxy, proxy_enc, enc) {
      try {
        return mpd.replace(/<BaseURL>([^<]*)/g, (str, link) => {
          link = link.trim();
          if (link) {
            return "<BaseURL>" + escapeXml(proxyLink(fixLink(unescapeXml(link), url, base), proxy, proxy_enc, (enc === "enc2" ? "enc1" : enc)));
          }
          return str;
        });
      } catch (err) {
        return mpd;
      }
    }

    async function handleOptions(request, connInfo) {
      if (
        request.headers.get("Origin") !== null &&
        request.headers.get("Access-Control-Request-Method") !== null &&
        request.headers.get("Access-Control-Request-Headers") !== null
      ) {
        // Handle CORS preflight requests.
        return new Response(null, {
          headers: {
            ...corsOptionsHeaders,
            "Access-Control-Allow-Headers": request.headers.get(
              "Access-Control-Request-Headers"
            ),
          },
        });
      } else {
        // Handle standard OPTIONS request.
        return new Response(null, {
          headers: {
            Allow: "GET, HEAD, POST, OPTIONS",
          },
        });
      }
    }

    try {
      if (request.method === "OPTIONS") {
        // Handle CORS preflight requests
        return await handleOptions(request, connInfo);
      } else if (
        request.method === "GET" ||
        request.method === "HEAD" ||
        request.method === "POST"
      ) {
        // Handle requests to the API server
        return await handleRequest(request, connInfo);
      } else {
        let error = "Method Not Allowed";
        return new Response(error + ": " + request.method, {
          ...corsHeaders,
          status: 405,
          statusText: error,
        });
      }
    } catch (err) {
      let error = "Internal Server Error";
      return new Response(error + ": " + err + "\n" + (err.stack || ""), {
          ...corsHeaders,
        status: 500,
        statusText: error,
      });
    }
}

const port = parseInt(Deno.env.get("PORT") || "8000");
Deno.serve({port: port}, handle);
```

---

### docs/deno_worker.js

```js
async function handle(request, connInfo) {
    const corsHeaders = {
      headers: {
        "Access-Control-Allow-Origin": "*",
      },
    };
    const corsOptionsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, HEAD, POST, OPTIONS",
      "Access-Control-Max-Age": "86400",
    };

    async function handleRequest(request, connInfo) {
      const url = new URL(request.url);
      let api_pos = url.origin.length + 1;
      let api = url.href.substring(api_pos);
      let proxy_url = url.href;
      let proxy = "";
      let proxy_enc = "";
      let enc = "";
      let ip = "";
      let redirect = request.method === "POST" ? "manual" : "follow";
      let get_cookie = false;
      let cookie_plus = false;
      let get_redirect = false;
      let force_head = false;
      let remove_compression = false;
      let params = [];
      let cdn_info = "cdn_pDvQc7ZT";
      let user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36";

      if (api === "headers") {
        let body = "";
        request.headers.forEach((value, key) => body += key + " = " + value + "\n");
        if (connInfo && connInfo.remoteAddr) {
          body += "connInfo" + " = " + JSON.stringify(connInfo.remoteAddr) + "\n";
        }
        body += "request_url" + " = " + request.url + "\n";
        body += "worker_version = 1.14\n";
        return new Response(body, corsHeaders);
      }

      let real_ip = "";
      let forwarded_for = request.headers.get("X-Forwarded-For");
      if (forwarded_for) real_ip = forwarded_for.split(",").map(s=>s.trim()).find(s=>s && !s.match(/^(127\.|10\.|172\.1[6-9]|172\.2[0-9]|172\.3[01]|192\.168\.)/)) || "";
      if (!real_ip) real_ip = request.headers.get("cf-connecting-ip");
      if (!real_ip) real_ip = request.headers.get("X-Real-IP");
      if (!real_ip) real_ip = connInfo && connInfo.remoteAddr && connInfo.remoteAddr.hostname || "";

      if (api === "jsonip") {
          return new Response(JSON.stringify({ip: real_ip}), {
            headers: {
              "Access-Control-Allow-Origin": "*",
              "Vary": "Origin",
              "Content-Type": "application/json; charset=utf-8",
            },
          });
      }

      if (api.startsWith("?")) {
        api_pos += 1;
        api = api.substring(1);
      }

      let next_param = true;
      while (next_param) {
        if (api.startsWith("ip")) {
          let pos = api.indexOf("/");
          if (pos !== -1) {
            ip = api.substring(2, pos);
            api_pos += pos + 1;
            api = api.substring(pos + 1);
          } else {
            ip = api.substring(2);
            api_pos += api.length;
            api = "";
          }
        } else if (api.startsWith("redirect=")) {
          let pos = api.indexOf("/");
          if (pos !== -1) {
            redirect = api.substring(9, pos);
            api_pos += pos + 1;
            api = api.substring(pos + 1);
          } else {
            redirect = api.substring(9);
            api_pos += api.length;
            api = "";
          }
        } else if (api.startsWith("get_cookie/")) {
          get_cookie = true;
          api_pos += 11;
          api = api.substring(11);
        } else if (api.startsWith("cookie_plus/")) {
          cookie_plus = true;
          remove_compression = true;
          api_pos += 12;
          api = api.substring(12);
        } else if (api.startsWith("get_redirect/")) {
          get_redirect = true;
          redirect = "manual";
          api_pos += 13;
          api = api.substring(13);
        } else if (api.startsWith("head/")) {
          force_head = true;
          api_pos += 5;
          api = api.substring(5);
        } else if (api.startsWith("param?") || api.startsWith("param/")) {
          api_pos += 6;
          api = api.substring(6);
          let param;
          let pos = api.indexOf("/");
          if (pos !== -1) {
            param = api.substring(0, pos);
            api_pos += pos + 1;
            api = api.substring(pos + 1);
          } else {
            param = api.substring(0);
            api_pos += api.length;
            api = "";
          }
          pos = param.indexOf("=");
          if (pos !== -1) {
            params.push([param.substring(0, pos), param.substring(pos + 1)]);
          } else {
            params.push([param]);
          }
        } else if (api.startsWith("enc/") || api.startsWith("enc1/") || api.startsWith("enc2/")) {
          let cur_enc = api.substring(0, api.indexOf("/"));
          if (enc) {
            proxy_enc += proxy_url.substring(0, api_pos);
          } else {
            proxy += proxy_url.substring(0, api_pos);
            enc = cur_enc;
          }
          api = api.substring(cur_enc.length + 1);
          let pos = api.indexOf("/");
          if (pos !== -1) {
            api = atob(decodeURIComponent(api.substring(0, pos))) + (cur_enc === "enc2" ? "" : api.substring(pos + 1));
          } else {
            api = atob(decodeURIComponent(api.substring(0)));
          }
          proxy_url = api;
          api_pos = 0;
        } else {
          next_param = false;
        }
      }

      if (enc) {
        proxy_enc += proxy_url.substring(0, api_pos);
      } else {
        proxy += proxy_url.substring(0, api_pos);
      }

      let forwarded_proto = request.headers.get("X-Forwarded-Proto");
      if (forwarded_proto) forwarded_proto = forwarded_proto.split(",")[0].trim();
      if (forwarded_proto === "https") proxy = proxy.replace("http://", "https://");

      if (!ip) ip = real_ip;

      if (!api || !/^https?:\/\/[^\/]/.test(api)) {
        let error = "Malformed URL";
        return new Response(error + ": " + api, {
          ...corsHeaders,
          status: 404,
          statusText: error,
        });
      }
      const apiUrl = new URL(api);
      let apiBase = apiUrl.href.substring(0, apiUrl.href.lastIndexOf("/") + 1);

      // Rewrite request to point to API URL. This also makes the request mutable
      // so you can add the correct Origin header to make the API server think
      // that this request is not cross-site.
      request = new Request(api, request);
      if (force_head) {
        request = new Request(request, {method: "HEAD"});
      }

      let cdn_loop = request.headers.get("CDN-Loop");
      if (cdn_loop && cdn_loop.indexOf(cdn_info) !== -1) {
        let error = "CDN-Loop detected";
        return new Response(error, {
          ...corsHeaders,
          status: 403,
          statusText: error,
        });
      } else {
        request.headers.append("CDN-Loop", cdn_info);
      }

      request.headers.set("Origin", apiUrl.origin);
      request.headers.set("Referer", apiUrl.origin + "/");
      if (true) {
        request.headers.delete("Sec-Fetch-Dest");
        request.headers.delete("Sec-Fetch-Mode");
        request.headers.delete("Sec-Fetch-Site");
        request.headers.delete("Sec-Fetch-User");
        request.headers.delete("Sec-CH-UA");
        request.headers.delete("Sec-CH-UA-Mobile");
        request.headers.delete("Sec-CH-UA-Platform");
        request.headers.delete("Host");
      }
      if (true) {
        request.headers.delete("X-Forwarded-For");
        request.headers.delete("X-Forwarded-Proto");
        //request.headers.delete("X-Real-IP");
        //request.headers.delete("cf-connecting-ip");
        request.headers.delete("cf-ipcountry");
        request.headers.delete("cf-ray");
        request.headers.delete("cf-visitor");
      }
      if (ip && ip !== "no") {
        request.headers.set("X-Forwarded-For", ip);
        request.headers.set("X-Forwarded-Proto", "https");
        request.headers.set("X-Real-IP", ip);
        request.headers.set("cf-connecting-ip", ip);
      }
      if (apiUrl.hostname === "rezka.ag" || apiUrl.hostname === "hdrezka.ag" || apiUrl.hostname === "hdrezka.me" || apiUrl.hostname === "hdrezka.sh" || apiUrl.hostname === "hdrezka.cm" || apiUrl.hostname === "hdrezka.kim" || apiUrl.hostname === "hdrezka.la" || apiUrl.hostname === "rezka.pub" || apiUrl.hostname === "kinopub.me") {
        request.headers.set("User-Agent", user_agent);
      }
      if (apiUrl.hostname.endsWith(".svetacdn.in")) {
        request.headers.set("Origin", "https://videocdn.tv");
        request.headers.set("Referer", "https://videocdn.tv/");
      }
      if (apiUrl.hostname === "api.lumex.pw") {
        request.headers.set("User-Agent", user_agent);
        request.headers.set("Origin", "https://p.lumex.pw");
        request.headers.set("Referer", "https://p.lumex.pw/");
        request.headers.set("Sec-Fetch-Dest", "empty");
        request.headers.set("Sec-Fetch-Mode", "cors");
        request.headers.set("Sec-Fetch-Site", "same-site");
      }
      if (apiUrl.hostname.endsWith("cdnmovies-stream.online") || apiUrl.hostname.endsWith("cdnmovies-hls-stream.online") || apiUrl.hostname.endsWith(".sarnage.cc")) {
        request.headers.set("Origin", "https://cdnmovies.net");
        request.headers.set("Referer", "https://cdnmovies.net/");
      }
      if (apiUrl.hostname.endsWith(".bazon.site")) {
        request.headers.set("User-Agent", user_agent);
        request.headers.set("Origin", "https://bazon.cc");
        request.headers.set("Referer", "https://bazon.cc/");
      }
      if (["kodikapi.com", "kodik.biz", "kodik.info"].indexOf(apiUrl.hostname) !== -1) {
        request.headers.delete("Origin");
        request.headers.delete("Referer");
      }
      if (apiUrl.hostname === "kinoplay.site" || apiUrl.hostname === "kinoplay1.site" || apiUrl.hostname === "kinoplay2.site") {
        request.headers.set("Cookie", "invite=a246a3f46c82fe439a45c3dbbbb24ad5");
      }
      if (remove_compression) {
        let encoding = (request.headers.get("Accept-Encoding") || "");
        if (encoding.includes("zstd") || encoding.includes("deflate")) {
          encoding = encoding.split(",").filter(enc=>!(enc.includes("zstd") || enc.includes("deflate"))).join(",") || "identity";
          request.headers.set("Accept-Encoding", encoding);
        }
      }
      params.forEach(param => {
        if (param[0]) {
          if (param[1]) {
            request.headers.set(decodeURIComponent(param[0]), decodeURIComponent(param[1] || ""));
          } else {
            request.headers.delete(decodeURIComponent(param[0]));
          }
        }
      });
      let response = await fetch(request, {
        redirect: redirect,
      });
      let currentUrl = response.url;

      // Recreate the response so you can modify the headers
      response = new Response(response.body, response);

      // Set CORS headers
      response.headers.set("Access-Control-Allow-Origin", "*");

      // Append to/Add Vary header so browser will cache response correctly
      response.headers.append("Vary", "Origin");

      if (response.status >= 200 && response.status < (get_redirect ? 400 : 300)) {
        let ctype = (response.headers.get("Content-Type") || "").split(";")[0].toLowerCase();
        if (get_cookie || cookie_plus || get_redirect) {
          let json = {};
          json.currentUrl = currentUrl;
          if (get_redirect) {
            let target = response.headers.get("Location");
            if (target) {
                json.redirectUrl = fixLink(target, apiUrl, apiBase);
                response.headers.set("Location", json.redirectUrl);
            }
          }
          if (get_cookie || cookie_plus) {
            json.cookie = response.headers.getSetCookie();
          }
          if (cookie_plus) {
            let headers = {};
            for (let key of response.headers.keys()) {
              if (key === "set-cookie") {
                headers[key] = json.cookie;
              } else {
                headers[key] = response.headers.get(key);
              }
            }
            json.headers = headers;
            if (ctype.startsWith("text/") || ["application/json", "application/xml", "application/x-mpegurl", "application/vnd.apple.mpegurl", "application/dash+xml"].indexOf(ctype) !== -1) {
              json.body = await response.text();
            }
          }
          return new Response(JSON.stringify(json), {
            headers: {
              "Access-Control-Allow-Origin": "*",
              "Vary": "Origin",
              "Content-Type": "application/json; charset=utf-8",
            },
          });
        }
      }

      // Fix redirect URL
      if (response.status >= 300 && response.status < 400) {
        let target = response.headers.get("Location");
        if (target) {
          response.headers.set("Location", proxyLink(fixLink(target, apiUrl, apiBase), proxy, proxy_enc, enc));
        }
      }

      return response;
    }

    function fixLink(link, url, base) {
      if (link) {
        if (link.indexOf("://") !== -1) return link;
        if (link.startsWith("//")) return url.protocol + link;
        if (link.startsWith("/")) return url.origin + link;
        if (link.startsWith("?")) return url.origin + url.pathname + link;
        if (link.startsWith("#")) return url.origin + url.pathname + url.search + link;
        return base + link;
      }
      return link;
    }

    function proxyLink(link, proxy, proxy_enc, enc) {
      if (link) {
        if (enc === "enc") {
          let pos = link.indexOf("/");
          if (pos !== -1 && link.charAt(pos + 1) === "/") pos++;
          let part1 = pos !== -1 ? link.substring(0, pos + 1) : "";
          let part2 = pos !== -1 ? link.substring(pos + 1) : link;
          return proxy + "enc/" + encodeURIComponent(btoa(proxy_enc + part1)) + "/" + part2;
        }
        if (enc === "enc1") {
          let pos = link.lastIndexOf("/");
          let part1 = pos !== -1 ? link.substring(0, pos + 1) : "";
          let part2 = pos !== -1 ? link.substring(pos + 1) : link;
          return proxy + "enc1/" + encodeURIComponent(btoa(proxy_enc + part1)) + "/" + part2;
        }
        if (enc === "enc2") {
          let posEnd = link.lastIndexOf("?");
          let posStart = link.lastIndexOf("://");
          if (posEnd === -1 || posEnd <= posStart) posEnd = link.length;
          if (posStart === -1) posStart = -3;
          let name = link.substring(posStart + 3, posEnd);
          posStart = name.lastIndexOf("/");
          name = posStart !== -1 ? name.substring(posStart + 1) : "";
          return proxy + "enc2/" + encodeURIComponent(btoa(proxy_enc + link)) + "/" + name;
        }
        return proxy + proxy_enc + link;
      }
      return link;
    }

    async function handleOptions(request, connInfo) {
      if (
        request.headers.get("Origin") !== null &&
        request.headers.get("Access-Control-Request-Method") !== null &&
        request.headers.get("Access-Control-Request-Headers") !== null
      ) {
        // Handle CORS preflight requests.
        return new Response(null, {
          headers: {
            ...corsOptionsHeaders,
            "Access-Control-Allow-Headers": request.headers.get(
              "Access-Control-Request-Headers"
            ),
          },
        });
      } else {
        // Handle standard OPTIONS request.
        return new Response(null, {
          headers: {
            Allow: "GET, HEAD, POST, OPTIONS",
          },
        });
      }
    }

    try {
      if (request.method === "OPTIONS") {
        // Handle CORS preflight requests
        return await handleOptions(request, connInfo);
      } else if (
        request.method === "GET" ||
        request.method === "HEAD" ||
        request.method === "POST"
      ) {
        // Handle requests to the API server
        return await handleRequest(request, connInfo);
      } else {
        let error = "Method Not Allowed";
        return new Response(error + ": " + request.method, {
          ...corsHeaders,
          status: 405,
          statusText: error,
        });
      }
    } catch (err) {
      let error = "Internal Server Error";
      return new Response(error + ": " + err + "\n" + (err.stack || ""), {
          ...corsHeaders,
        status: 500,
        statusText: error,
      });
    }
}

const port = parseInt(Deno.env.get("PORT") || "8000");
Deno.serve({port: port}, handle);
```

---

### docs/kp_source.js

```js
(function () {
    'use strict';

    function startsWith(str, searchString) {
      return str.lastIndexOf(searchString, 0) === 0;
    }

    var network = new Lampa.Reguest();
    var cache = {};
    var total_cnt = 0;
    var proxy_cnt = 0;
    var good_cnt = 0;
    var genres_list = [];
    var countries_list = [];
    var genres_map = {};
    var countries_map = {};
    var CACHE_SIZE = 100;
    var CACHE_TIME = 1000 * 60 * 60;
    var SOURCE_NAME = 'KP';
    var SOURCE_TITLE = 'KP';

    function get(method, oncomplite, onerror) {
      var use_proxy = total_cnt >= 10 && good_cnt > total_cnt / 2;
      if (!use_proxy) total_cnt++;
      var kp_prox = 'https://cors.kp556.workers.dev:8443/';
      var url = 'https://kinopoiskapiunofficial.tech/';
      url += method;
      network.timeout(20000);
      network.silent((use_proxy ? kp_prox : '') + url, function (json) {
        oncomplite(json);
      }, function (a, c) {
        use_proxy = !use_proxy && (proxy_cnt < 10 || good_cnt > proxy_cnt / 2);

        if (use_proxy && (a.status == 429 || a.status == 0 && a.statusText !== 'timeout')) {
          proxy_cnt++;
          network.timeout(20000);
          network.silent(kp_prox + url, function (json) {
            good_cnt++;
            oncomplite(json);
          }, onerror, false, {
            headers: {
              'X-API-KEY': '2a4a0808-81a3-40ae-b0d3-e11335ede616'
            }
          });
        } else onerror(a, c);
      }, false, {
        headers: {
          'X-API-KEY': '2a4a0808-81a3-40ae-b0d3-e11335ede616'
        }
      });
    }

    function getComplite(method, oncomplite) {
      get(method, oncomplite, function () {
        oncomplite(null);
      });
    }

    function getCompliteIf(condition, method, oncomplite) {
      if (condition) getComplite(method, oncomplite);else {
        setTimeout(function () {
          oncomplite(null);
        }, 10);
      }
    }

    function getCache(key) {
      var res = cache[key];

      if (res) {
        var cache_timestamp = new Date().getTime() - CACHE_TIME;
        if (res.timestamp > cache_timestamp) return res.value;

        for (var ID in cache) {
          var node = cache[ID];
          if (!(node && node.timestamp > cache_timestamp)) delete cache[ID];
        }
      }

      return null;
    }

    function setCache(key, value) {
      var timestamp = new Date().getTime();
      var size = Object.keys(cache).length;

      if (size >= CACHE_SIZE) {
        var cache_timestamp = timestamp - CACHE_TIME;

        for (var ID in cache) {
          var node = cache[ID];
          if (!(node && node.timestamp > cache_timestamp)) delete cache[ID];
        }

        size = Object.keys(cache).length;

        if (size >= CACHE_SIZE) {
          var timestamps = [];

          for (var _ID in cache) {
            var _node = cache[_ID];
            timestamps.push(_node && _node.timestamp || 0);
          }

          timestamps.sort(function (a, b) {
            return a - b;
          });
          cache_timestamp = timestamps[Math.floor(timestamps.length / 2)];

          for (var _ID2 in cache) {
            var _node2 = cache[_ID2];
            if (!(_node2 && _node2.timestamp > cache_timestamp)) delete cache[_ID2];
          }
        }
      }

      cache[key] = {
        timestamp: timestamp,
        value: value
      };
    }

    function getFromCache(method, oncomplite, onerror) {
      var json = getCache(method);

      if (json) {
        setTimeout(function () {
          oncomplite(json, true);
        }, 10);
      } else get(method, oncomplite, onerror);
    }

    function clear() {
      network.clear();
    }

    function convertElem(elem) {
      var type = !elem.type || elem.type === 'FILM' || elem.type === 'VIDEO' ? 'movie' : 'tv';
      var kinopoisk_id = elem.kinopoiskId || elem.filmId || 0;
      var kp_rating = +elem.rating || +elem.ratingKinopoisk || 0;
      var imdb_rating = +elem.ratingImdb || 0;
      var title = elem.nameRu || elem.nameEn || elem.nameOriginal || '';
      var original_title = elem.nameOriginal || elem.nameEn || elem.nameRu || '';
      var adult = false;
      var result = {
        "source": SOURCE_NAME,
        "type": type,
        "adult": false,
        "id": SOURCE_NAME + '_' + kinopoisk_id,
        "title": title,
        "original_title": original_title,
        "overview": elem.description || elem.shortDescription || '',
        "img": elem.posterUrlPreview || elem.posterUrl || '',
        "background_image": elem.coverUrl || elem.posterUrl || elem.posterUrlPreview || '',
        "genres": elem.genres && elem.genres.map(function (e) {
          if (e.genre === '–¥–ª—è –≤–∑—Ä–æ—Å–ª—ã—Ö') {
            adult = true;
          }

          return {
            "id": e.genre && genres_map[e.genre] || 0,
            "name": e.genre,
            "url": 'genre'
          };
        }) || [],
        "production_companies": [],
        "production_countries": elem.countries && elem.countries.map(function (e) {
          return {
            "name": e.country
          };
        }) || [],
        "vote_average": kp_rating,
        "vote_count": elem.ratingVoteCount || elem.ratingKinopoiskVoteCount || 0,
        "kinopoisk_id": kinopoisk_id,
        "kp_rating": kp_rating,
        "imdb_id": elem.imdbId || '',
        "imdb_rating": imdb_rating
      };
      result.adult = adult;
      var first_air_date = elem.year && elem.year !== 'null' ? elem.year : '';
      var last_air_date = '';

      if (type === 'tv') {
        if (elem.startYear && elem.startYear !== 'null') first_air_date = elem.startYear;
        if (elem.endYear && elem.endYear !== 'null') last_air_date = elem.endYear;
      }

      if (elem.distributions_obj) {
        var distributions = elem.distributions_obj.items || [];
        var year_timestamp = Date.parse(first_air_date);
        var min = null;
        distributions.forEach(function (d) {
          if (d.date && (d.type === 'WORLD_PREMIER' || d.type === 'ALL')) {
            var timestamp = Date.parse(d.date);

            if (!isNaN(timestamp) && (min == null || timestamp < min) && (isNaN(year_timestamp) || timestamp >= year_timestamp)) {
              min = timestamp;
              first_air_date = d.date;
            }
          }
        });
      }

      if (type === 'tv') {
        result.name = title;
        result.original_name = original_title;
        result.first_air_date = first_air_date + '';
        if (last_air_date) result.last_air_date = last_air_date + '';
      } else {
        result.release_date = first_air_date + '';
      }

      if (elem.seasons_obj) {
        var _seasons = elem.seasons_obj.items || [];

        result.number_of_seasons = elem.seasons_obj.total || _seasons.length || 1;
        result.seasons = _seasons.map(function (s) {
          return convertSeason(s);
        });
        var number_of_episodes = 0;
        result.seasons.forEach(function (s) {
          number_of_episodes += s.episode_count;
        });
        result.number_of_episodes = number_of_episodes;
      }

      if (elem.staff_obj) {
        var staff = elem.staff_obj || [];
        var cast = [];
        var crew = [];
        staff.forEach(function (s) {
          var person = convertPerson(s);
          if (s.professionKey === 'ACTOR') cast.push(person);else crew.push(person);
        });
        result.persons = {
          "cast": cast,
          "crew": crew
        };
      }

      if (elem.sequels_obj) {
        var sequels = elem.sequels_obj || [];
        result.collection = {
          "results": sequels.map(function (s) {
            return convertElem(s);
          })
        };
      }

      if (elem.similars_obj) {
        var similars = elem.similars_obj.items || [];
        result.simular = {
          "results": similars.map(function (s) {
            return convertElem(s);
          })
        };
      }

      return result;
    }

    function convertSeason(season) {
      var episodes = season.episodes || [];
      episodes = episodes.map(function (e) {
        return {
          "season_number": e.seasonNumber,
          "episode_number": e.episodeNumber,
          "name": e.nameRu || e.nameEn || 'S' + e.seasonNumber + ' / ' + Lampa.Lang.translate('torrent_serial_episode') + ' ' + e.episodeNumber,
          "overview": e.synopsis || '',
          "air_date": e.releaseDate
        };
      });
      return {
        "season_number": season.number,
        "episode_count": episodes.length,
        "episodes": episodes,
        "name": Lampa.Lang.translate('torrent_serial_season') + ' ' + season.number,
        "overview": ''
      };
    }

    function convertPerson(person) {
      return {
        "id": person.staffId,
        "name": person.nameRu || person.nameEn || '',
        "url": 'person',
        "img": person.posterUrl || '',
        "character": person.description || '',
        "job": Lampa.Utils.capitalizeFirstLetter((person.professionKey || '').toLowerCase())
      };
    }

    function cleanTitle(str) {
      return str.replace(/[\s.,:;‚Äô'`!?]+/g, ' ').trim();
    }

    function kpCleanTitle(str) {
      return cleanTitle(str).replace(/^[ \/\\]+/, '').replace(/[ \/\\]+$/, '').replace(/\+( *[+\/\\])+/g, '+').replace(/([+\/\\] *)+\+/g, '+').replace(/( *[\/\\]+ *)+/g, '+');
    }

    function normalizeTitle(str) {
      return cleanTitle(str.toLowerCase().replace(/[\-\u2010-\u2015\u2E3A\u2E3B\uFE58\uFE63\uFF0D]+/g, '-').replace(/—ë/g, '–µ'));
    }

    function containsTitle(str, title) {
      return typeof str === 'string' && typeof title === 'string' && normalizeTitle(str).indexOf(normalizeTitle(title)) !== -1;
    }

    function getList(method) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var oncomplite = arguments.length > 2 ? arguments[2] : undefined;
      var onerror = arguments.length > 3 ? arguments[3] : undefined;
      var url = method;

      if (params.query) {
        var clean_title = params.query && kpCleanTitle(decodeURIComponent(params.query));

        if (!clean_title) {
          onerror();
          return;
        }

        url = Lampa.Utils.addUrlComponent(url, 'keyword=' + encodeURIComponent(clean_title));
      }

      var page = params.page || 1;
      url = Lampa.Utils.addUrlComponent(url, 'page=' + page);
      getFromCache(url, function (json, cached) {
        var items = [];
        if (json.items && json.items.length) items = json.items;else if (json.films && json.films.length) items = json.films;else if (json.releases && json.releases.length) items = json.releases;
        if (!cached && items.length) setCache(url, json);
        var results = items.map(function (elem) {
          return convertElem(elem);
        });
        results = results.filter(function (elem) {
          return !elem.adult;
        });
        var total_pages = json.pagesCount || json.totalPages || 1;
        var res = {
          "results": results,
          "url": method,
          "page": page,
          "total_pages": total_pages,
          "total_results": 0,
          "more": total_pages > page
        };
        oncomplite(res);
      }, onerror);
    }

    function _getById(id) {
      var oncomplite = arguments.length > 2 ? arguments[2] : undefined;
      var onerror = arguments.length > 3 ? arguments[3] : undefined;
      var url = 'api/v2.2/films/' + id;
      var film = getCache(url);

      if (film) {
        setTimeout(function () {
          oncomplite(convertElem(film));
        }, 10);
      } else {
        get(url, function (film) {
          if (film.kinopoiskId) {
            var type = !film.type || film.type === 'FILM' || film.type === 'VIDEO' ? 'movie' : 'tv';
            getCompliteIf(type == 'tv', 'api/v2.2/films/' + id + '/seasons', function (seasons) {
              film.seasons_obj = seasons;
              getComplite('api/v2.2/films/' + id + '/distributions', function (distributions) {
                film.distributions_obj = distributions;
                getComplite('/api/v1/staff?filmId=' + id, function (staff) {
                  film.staff_obj = staff;
                  getComplite('api/v2.1/films/' + id + '/sequels_and_prequels', function (sequels) {
                    film.sequels_obj = sequels;
                    getComplite('api/v2.2/films/' + id + '/similars', function (similars) {
                      film.similars_obj = similars;
                      setCache(url, film);
                      oncomplite(convertElem(film));
                    });
                  });
                });
              });
            });
          } else onerror();
        }, onerror);
      }
    }

    function getById(id) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var oncomplite = arguments.length > 2 ? arguments[2] : undefined;
      var onerror = arguments.length > 3 ? arguments[3] : undefined;
      menu({}, function () {
        return _getById(id, params, oncomplite, onerror);
      });
    }

    function main$1() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var oncomplite = arguments.length > 1 ? arguments[1] : undefined;
      var onerror = arguments.length > 2 ? arguments[2] : undefined;
      var parts_limit = 5;
      var parts_data = [function (call) {
        getList('api/v2.2/films/collections?type=TOP_POPULAR_MOVIES', params, function (json) {
          json.title = '–°–µ–π—á–∞—Å —Å–º–æ—Ç—Ä—è—Ç —Ñ–∏–ª—å–º—ã';
          call(json);
        }, call);
      }, function (call) {
        getList('api/v2.2/films/collections?type=POPULAR_SERIES', params, function (json) {
          json.title = '–°–µ–π—á–∞—Å —Å–º–æ—Ç—Ä—è—Ç —Å–µ—Ä–∏–∞–ª—ã';
          call(json);
        }, call);
      }, function (call) {
        getList('api/v2.2/films/collections?type=TOP_250_MOVIES', params, function (json) {
          json.title = '–¢–æ–ø —Ñ–∏–ª—å–º—ã';
          call(json);
        }, call);
      }, function (call) {
        getList('api/v2.2/films/collections?type=TOP_250_TV_SHOWS', params, function (json) {
          json.title = '–¢–æ–ø —Å–µ—Ä–∏–∞–ª—ã';
          call(json);
        }, call);
      }, function (call) {
        getList('api/v2.2/films?order=NUM_VOTE&type=FILM', params, function (json) {
          json.title = '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ñ–∏–ª—å–º—ã';
          call(json);
        }, call);
      }, function (call) {
        getList('api/v2.2/films?order=NUM_VOTE&type=TV_SERIES', params, function (json) {
          json.title = '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Å–µ—Ä–∏–∞–ª—ã';
          call(json);
        }, call);
      }, function (call) {
        getList('api/v2.2/films?order=NUM_VOTE&type=MINI_SERIES', params, function (json) {
          json.title = '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ –º–∏–Ω–∏-—Å–µ—Ä–∏–∞–ª—ã';
          call(json);
        }, call);
      }, function (call) {
        getList('api/v2.2/films?order=NUM_VOTE&type=TV_SHOW', params, function (json) {
          json.title = '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ç–µ–ª–µ—à–æ—É';
          call(json);
        }, call);
      }];

      function loadPart(partLoaded, partEmpty) {
        Lampa.Api.partNext(parts_data, parts_limit, partLoaded, partEmpty);
      }

      menu({}, function () {
        var rus_id = countries_map['–†–æ—Å—Å–∏—è'];

        if (rus_id) {
          parts_data.splice(5, 0, function (call) {
            getList('api/v2.2/films?order=NUM_VOTE&countries=' + rus_id + '&type=FILM', params, function (json) {
              json.title = '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ä–æ—Å—Å–∏–π—Å–∫–∏–µ —Ñ–∏–ª—å–º—ã';
              call(json);
            }, call);
          });
          parts_data.splice(7, 0, function (call) {
            getList('api/v2.2/films?order=NUM_VOTE&countries=' + rus_id + '&type=TV_SERIES', params, function (json) {
              json.title = '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ä–æ—Å—Å–∏–π—Å–∫–∏–µ —Å–µ—Ä–∏–∞–ª—ã';
              call(json);
            }, call);
          });
          parts_data.splice(9, 0, function (call) {
            getList('api/v2.2/films?order=NUM_VOTE&countries=' + rus_id + '&type=MINI_SERIES', params, function (json) {
              json.title = '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ä–æ—Å—Å–∏–π—Å–∫–∏–µ –º–∏–Ω–∏-—Å–µ—Ä–∏–∞–ª—ã';
              call(json);
            }, call);
          });
        }

        loadPart(oncomplite, onerror);
      });
      return loadPart;
    }

    function category() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var oncomplite = arguments.length > 1 ? arguments[1] : undefined;
      var onerror = arguments.length > 2 ? arguments[2] : undefined;
      var parts_limit = 5;
      var parts_data = [];

      if (['movie', 'tv'].indexOf(params.url) > -1 && !params.genres) {
        var books = Lampa.Favorite.continues(params.url);
        books.forEach(function (elem) {
          if (!elem.source) elem.source = 'tmdb';
        });
        books = books.filter(function (elem) {
          return [SOURCE_NAME, 'tmdb', 'cub'].indexOf(elem.source) !== -1;
        });
        var recomend = Lampa.Arrays.shuffle(Lampa.Recomends.get(params.url)).slice(0, 19);
        recomend.forEach(function (elem) {
          if (!elem.source) elem.source = 'tmdb';
        });
        recomend = recomend.filter(function (elem) {
          return [SOURCE_NAME, 'tmdb', 'cub'].indexOf(elem.source) !== -1;
        });
        parts_data = [function (call) {
          call({
            results: books,
            title: params.url == 'tv' ? Lampa.Lang.translate('title_continue') : Lampa.Lang.translate('title_watched')
          });
        }, function (call) {
          call({
            results: recomend,
            title: Lampa.Lang.translate('title_recomend_watch')
          });
        }];
      }

      function loadPart(partLoaded, partEmpty) {
        Lampa.Api.partNext(parts_data, parts_limit, partLoaded, partEmpty);
      }

      menu({}, function () {
        var url = 'api/v2.2/films?order=NUM_VOTE';
        var filter = '';
        if (params.url == 'movie') filter = '&type=FILM';else if (params.url == 'tv') filter = '&type=TV_SERIES';else if (params.url == 'anime') filter = '&genres=' + genres_map['–∞–Ω–∏–º–µ'];else if (params.url == 'cartoon') filter = '&genres=' + genres_map['–º—É–ª—å—Ç—Ñ–∏–ª—å–º'];
        {
          var now = new Date();
          var yearFrom = now.getFullYear() - (now.getMonth() < 6);
          var yearTo = now.getFullYear();
          parts_data.push(function (call) {
            getList(url + filter + '&yearFrom=' + yearFrom + '&yearTo=' + yearTo, params, function (json) {
              json.title = '–ó–∞ –≥–æ–¥';
              call(json);
            }, call);
          });
        }

        if (!startsWith(filter, '&type=')) {
          parts_data.push(function (call) {
            getList(url + filter + '&type=FILM', params, function (json) {
              json.title = '–§–∏–ª—å–º—ã';
              call(json);
            }, call);
          });
          parts_data.push(function (call) {
            getList(url + filter + '&type=TV_SERIES', params, function (json) {
              json.title = '–°–µ—Ä–∏–∞–ª—ã';
              call(json);
            }, call);
          });
          parts_data.push(function (call) {
            getList(url + filter + '&type=MINI_SERIES', params, function (json) {
              json.title = '–ú–∏–Ω–∏-—Å–µ—Ä–∏–∞–ª—ã';
              call(json);
            }, call);
          });
          parts_data.push(function (call) {
            getList(url + filter + '&type=TV_SHOW', params, function (json) {
              json.title = '–¢–µ–ª–µ—à–æ—É';
              call(json);
            }, call);
          });
        }

        if (!startsWith(filter, '&genres=')) {
          genres_list.forEach(function (g) {
            if (!g.hide && !g.separator) {
              parts_data.push(function (call) {
                getList(url + filter + '&genres=' + g.id, params, function (json) {
                  json.title = Lampa.Utils.capitalizeFirstLetter(g.title);
                  call(json);
                }, call);
              });
            }
          });
        }

        loadPart(oncomplite, onerror);
      });
      return loadPart;
    }

    function full() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var oncomplite = arguments.length > 1 ? arguments[1] : undefined;
      var onerror = arguments.length > 2 ? arguments[2] : undefined;
      var kinopoisk_id = '';

      if (params.card && params.card.source === SOURCE_NAME) {
        if (params.card.kinopoisk_id) {
          kinopoisk_id = params.card.kinopoisk_id;
        } else if (startsWith(params.card.id + '', SOURCE_NAME + '_')) {
          kinopoisk_id = (params.card.id + '').substring(SOURCE_NAME.length + 1);
          params.card.kinopoisk_id = kinopoisk_id;
        }
      }

      if (kinopoisk_id) {
        getById(kinopoisk_id, params, function (json) {
          var status = new Lampa.Status(4);
          status.onComplite = oncomplite;
          status.append('movie', json);
          status.append('persons', json && json.persons);
          status.append('collection', json && json.collection);
          status.append('simular', json && json.simular);
        }, onerror);
      } else onerror();
    }

    function list() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var oncomplite = arguments.length > 1 ? arguments[1] : undefined;
      var onerror = arguments.length > 2 ? arguments[2] : undefined;
      var method = params.url;

      if ((method === '' || method === 'movie' || method === 'tv' || method === 'genre') && params.genres) {
        method = 'api/v2.2/films?order=NUM_VOTE&genres=' + params.genres;
      }

      if (method === 'filter' && params.filter_url) {
        method = params.filter_url;
      }

      getList(method, params, oncomplite, onerror);
    }

    function search$1() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var oncomplite = arguments.length > 1 ? arguments[1] : undefined;
      var title = decodeURIComponent(params.query || '');
      var status = new Lampa.Status(1);

      status.onComplite = function (data) {
        var items = [];

        if (data.query && data.query.results) {
          var tmp = data.query.results.filter(function (elem) {
            return containsTitle(elem.title, title) || containsTitle(elem.original_title, title);
          });

          if (tmp.length && tmp.length !== data.query.results.length) {
            data.query.results = tmp;
            data.query.more = true;
          }

          var movie = {};
          Lampa.Arrays.extend(movie, data.query);
          movie.results = data.query.results.filter(function (elem) {
            return elem.type === 'movie';
          });
          movie.title = Lampa.Lang.translate('menu_movies');
          movie.type = 'movie';
          if (movie.results.length) items.push(movie);
          var tv = {};
          Lampa.Arrays.extend(tv, data.query);
          tv.results = data.query.results.filter(function (elem) {
            return elem.type === 'tv';
          });
          tv.title = Lampa.Lang.translate('menu_tv');
          tv.type = 'tv';
          if (tv.results.length) items.push(tv);
        }

        oncomplite(items);
      };

      getList('api/v2.1/films/search-by-keyword', params, function (json) {
        status.append('query', json);
      }, status.error.bind(status));
    }

    function discovery() {
      return {
        title: SOURCE_TITLE,
        search: search$1,
        params: {
          align_left: true,
          object: {
            source: SOURCE_NAME
          }
        },
        onMore: function onMore(params) {
          Lampa.Activity.push({
            url: 'api/v2.1/films/search-by-keyword',
            title: Lampa.Lang.translate('search') + ' - ' + params.query,
            component: 'category_full',
            page: 1,
            query: encodeURIComponent(params.query),
            source: SOURCE_NAME
          });
        },
        onCancel: network.clear.bind(network)
      };
    }

    function person() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var oncomplite = arguments.length > 1 ? arguments[1] : undefined;
      var status = new Lampa.Status(1);

      status.onComplite = function (data) {
        var result = {};

        if (data.query) {
          var p = data.query;
          result.person = {
            "id": p.personId,
            "name": p.nameRu || p.nameEn || '',
            "url": 'person',
            "img": p.posterUrl || '',
            "gender": p.sex === 'MALE' ? 2 : p.sex === 'FEMALE' ? 1 : 0,
            "birthday": p.birthday,
            "place_of_birth": p.birthplace,
            "deathday": p.death,
            "place_of_death": p.deathplace,
            "known_for_department": p.profession || '',
            "biography": (p.facts || []).join(' ')
          };
          var director_films = [];
          var director_map = {};
          var actor_films = [];
          var actor_map = {};

          if (p.films) {
            p.films.forEach(function (f) {
              if (f.professionKey === 'DIRECTOR' && !director_map[f.filmId]) {
                director_map[f.filmId] = true;
                director_films.push(convertElem(f));
              } else if (f.professionKey === 'ACTOR' && !actor_map[f.filmId]) {
                actor_map[f.filmId] = true;
                actor_films.push(convertElem(f));
              }
            });
          }

          var knownFor = [];

          if (director_films.length) {
            director_films.sort(function (a, b) {
              var res = b.vote_average - a.vote_average;
              if (res) return res;
              return a.id - b.id;
            });
            knownFor.push({
              "name": Lampa.Lang.translate('title_producer'),
              "credits": director_films
            });
          }

          if (actor_films.length) {
            actor_films.sort(function (a, b) {
              var res = b.vote_average - a.vote_average;
              if (res) return res;
              return a.id - b.id;
            });
            knownFor.push({
              "name": Lampa.Lang.translate(p.sex === 'FEMALE' ? 'title_actress' : 'title_actor'),
              "credits": actor_films
            });
          }

          result.credits = {
            "knownFor": knownFor
          };
        }

        oncomplite(result);
      };

      var url = 'api/v1/staff/' + params.id;
      getFromCache(url, function (json, cached) {
        if (!cached && json.personId) setCache(url, json);
        status.append('query', json);
      }, status.error.bind(status));
    }

    function kpFilters() {
      var oncomplite = arguments.length > 1 ? arguments[1] : undefined;
      if (genres_list.length) oncomplite(genres_list, countries_list, genres_map, countries_map);else {
        get('api/v2.2/films/filters', function (j) {
          if (j.genres) {
            var priority_order = ['—Å–µ–º–µ–π–Ω—ã–π', '–¥–µ—Ç—Å–∫–∏–π', '–∫–æ—Ä–æ—Ç–∫–æ–º–µ—Ç—Ä–∞–∂–∫–∞', '–º—É–ª—å—Ç—Ñ–∏–ª—å–º', '–∞–Ω–∏–º–µ'];
            var priority_list = [];
            var other_list = [];
            j.genres.forEach(function (g) {
              var list = priority_order.indexOf(g.genre) !== -1 ? priority_list : other_list;
              list.push({
                "id": g.id,
                "title": g.genre,
                "url": 'genre',
                "hide": g.genre === '–¥–ª—è –≤–∑—Ä–æ—Å–ª—ã—Ö',
                "separator": !g.genre
              });
              genres_map[g.genre] = g.id;
            });
            priority_list.sort(function (a, b) {
              return priority_order.indexOf(a.title) - priority_order.indexOf(b.title);
            });
            genres_list = priority_list.concat(other_list);
          }

          if (j.countries) {
            var _priority_order = ['–†–æ—Å—Å–∏—è', '–°–°–°–†', '–°–®–ê', '–ò–Ω–¥–∏—è', '–Ø–ø–æ–Ω–∏—è', '–ö–æ—Ä–µ—è –Æ–∂–Ω–∞—è', '–ö–∏—Ç–∞–π', '–ì–æ–Ω–∫–æ–Ω–≥', '–¢–∞–π–≤–∞–Ω—å', '–í–µ–ª–∏–∫–æ–±—Ä–∏—Ç–∞–Ω–∏—è', '–ê–≤—Å—Ç—Ä–∞–ª–∏—è', '–§—Ä–∞–Ω—Ü–∏—è', '–ö–∞–Ω–∞–¥–∞'];
            var _priority_list = [];
            var _other_list = [];
            j.countries.forEach(function (c) {
              var list = _priority_order.indexOf(c.country) !== -1 ? _priority_list : _other_list;
              list.push({
                "id": c.id,
                "title": c.country,
                "url": 'country',
                "hide": false,
                "separator": !c.country
              });
              countries_map[c.country] = c.id;
            });

            _priority_list.sort(function (a, b) {
              return _priority_order.indexOf(a.title) - _priority_order.indexOf(b.title);
            });

            countries_list = _priority_list.concat(_other_list);
          }

          oncomplite(genres_list, countries_list, genres_map, countries_map);
        }, function () {
          oncomplite([], [], {}, {});
        });
      }
    }

    function menu() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var oncomplite = arguments.length > 1 ? arguments[1] : undefined;
      kpFilters(params, function (menu_list) {
        oncomplite(menu_list);
      });
    }

    function menuCategory(params, oncomplite) {
      oncomplite([]);
    }

    function seasons(tv, from, oncomplite) {
      var status = new Lampa.Status(from.length);
      status.onComplite = oncomplite;
      from.forEach(function (season) {
        var seasons = tv.seasons || [];
        seasons = seasons.filter(function (s) {
          return s.season_number === season;
        });

        if (seasons.length) {
          status.append('' + season, seasons[0]);
        } else {
          status.error();
        }
      });
    }

    var KP = {
      SOURCE_NAME: SOURCE_NAME,
      SOURCE_TITLE: SOURCE_TITLE,
      kpFilters: kpFilters,
      main: main$1,
      menu: menu,
      full: full,
      list: list,
      category: category,
      clear: clear,
      person: person,
      seasons: seasons,
      menuCategory: menuCategory,
      discovery: discovery
    };

    var data = {};
    var initialized = false;
    data.type = {
      title: '#{title_type}',
      items: [{
        title: '#{filter_any}'
      }, {
        selected: true,
        title: '–§–∏–ª—å–º—ã',
        typeName: 'FILM'
      }, {
        title: '–°–µ—Ä–∏–∞–ª—ã',
        typeName: 'TV_SERIES'
      }, {
        title: '–ú–∏–Ω–∏-—Å–µ—Ä–∏–∞–ª—ã',
        typeName: 'MINI_SERIES'
      }, {
        title: '–¢–µ–ª–µ—à–æ—É',
        typeName: 'TV_SHOW'
      }]
    };
    data.rating = {
      title: '#{title_rating}',
      items: [{
        selected: true,
        title: '#{filter_any}'
      }, {
        title: '#{filter_rating_from} 9',
        ratingFrom: 9,
        ratingTo: 10
      }, {
        title: '#{filter_rating_from} 8',
        ratingFrom: 8,
        ratingTo: 10
      }, {
        title: '#{filter_rating_from} 8 #{filter_rating_to} 9',
        ratingFrom: 8,
        ratingTo: 9
      }, {
        title: '#{filter_rating_from} 6',
        ratingFrom: 6,
        ratingTo: 10
      }, {
        title: '#{filter_rating_from} 6 #{filter_rating_to} 8',
        ratingFrom: 6,
        ratingTo: 8
      }, {
        title: '#{filter_rating_to} 6',
        ratingFrom: 0,
        ratingTo: 6
      }, {
        title: '#{filter_rating_to} 4',
        ratingFrom: 0,
        ratingTo: 4
      }, {
        title: '#{filter_rating_to} 2',
        ratingFrom: 0,
        ratingTo: 2
      }, {
        title: '#{filter_rating_to} 1',
        ratingFrom: 0,
        ratingTo: 1
      }]
    };
    data.sort = {
      title: '#{filter_sorted}',
      items: [{
        selected: true,
        title: '–ü–æ–ø—É–ª—è—Ä–Ω–æ—Å—Ç—å',
        sortName: 'NUM_VOTE'
      }, {
        title: '–†–µ–π—Ç–∏–Ω–≥',
        sortName: 'RATING'
      }]
    };
    data.genre = {
      title: '#{title_genre}',
      items: [{
        selected: true,
        title: '#{filter_any}'
      }]
    };
    data.country = {
      title: '#{title_country}',
      items: [{
        selected: true,
        title: '#{filter_any}'
      }]
    };
    data.year = {
      title: '#{title_year}',
      items: [{
        selected: true,
        title: '#{filter_any}'
      }]
    };
    var now = new Date().getFullYear();
    var i = now - now % 10;

    for (var a = 0; a < 5; a++) {
      var y = now - a;
      data.year.items.push({
        title: y + '',
        yearFrom: y,
        yearTo: y
      });
    }

    if (i != now) {
      data.year.items.push({
        title: i + '-' + now,
        yearFrom: i,
        yearTo: now
      });
    }

    i -= 10;

    while (i >= 1900) {
      data.year.items.push({
        title: i + '-' + (i + 9),
        yearFrom: i,
        yearTo: i + 9
      });
      i -= 10;
    }
    /**
     * –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
     */


    function main() {
      for (var i in data) {
        selected(data[i]);
      }

      var items = [{
        title: Lampa.Lang.translate('search_start'),
        search: true
      }, data.type, data.rating, data.sort, data.genre, data.country, data.year];
      items.forEach(function (itm) {
        itm.title = Lampa.Lang.translate(itm.title);
        if (itm.subtitle) itm.subtitle = Lampa.Lang.translate(itm.subtitle);

        if (itm.items) {
          itm.items.forEach(function (inr) {
            inr.title = Lampa.Lang.translate(inr.title);
          });
        }
      });
      Lampa.Select.show({
        title: Lampa.Lang.translate('title_filter'),
        items: items,
        onBack: function onBack() {
          Lampa.Controller.toggle('content');
        },
        onSelect: function onSelect(a) {
          if (a.search) search();else submenu(a);
        }
      });
    }
    /**
     * –ó–∞–ø—Ä–æ—Å –¥–ª—è KP
     * @returns {string} - —Å—Ç—Ä–æ–∫–∞ –∑–∞–ø—Ä–æ—Å–∞
     */


    function getFilterUrl() {
      var url = 'api/v2.2/films?order=' + (data.sort.items.find(function (s) {
        return s.selected;
      }).sortName || 'NUM_VOTE');
      var typeName = data.type.items.find(function (s) {
        return s.selected;
      }).typeName;
      if (typeName) url += '&type=' + typeName;
      var genre = data.genre.items.find(function (s) {
        return s.selected;
      }).id;
      if (genre != null) url += '&genres=' + genre;
      var country = data.country.items.find(function (s) {
        return s.selected;
      }).id;
      if (country != null) url += '&countries=' + country;
      var ratingFrom = data.rating.items.find(function (s) {
        return s.selected;
      }).ratingFrom;
      if (ratingFrom != null) url += '&ratingFrom=' + ratingFrom;
      var ratingTo = data.rating.items.find(function (s) {
        return s.selected;
      }).ratingTo;
      if (ratingTo != null) url += '&ratingTo=' + ratingTo;
      var yearFrom = data.year.items.find(function (s) {
        return s.selected;
      }).yearFrom;
      if (yearFrom != null) url += '&yearFrom=' + yearFrom;
      var yearTo = data.year.items.find(function (s) {
        return s.selected;
      }).yearTo;
      if (yearTo != null) url += '&yearTo=' + yearTo;
      return url;
    }
    /**
     * –ó–∞–ø—É—Å–∫ –ø–æ–∏—Å–∫–∞
     */


    function search() {
      Lampa.Controller.toggle('content');
      var source = Lampa.Storage.field('source');
      var activity = {
        url: 'filter',
        filter_url: getFilterUrl(),
        title: Lampa.Lang.translate('title_filter'),
        component: 'category_full',
        source: source,
        card_type: true,
        page: 1
      };
      var object = Lampa.Activity.active();
      if (object.component == 'category_full' && object.url == 'filter') Lampa.Activity.replace(activity, true);else Lampa.Activity.push(activity);
    }
    /**
     * –í—ã–±–æ—Ä —ç–ª–µ–º–µ–Ω—Ç–∞
     * @param {Array} where - –º–∞—Å—Å–∏–≤ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
     * @param {Object} a - –≤—ã–±—Ä–∞–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç
     */


    function select(where, a) {
      where.forEach(function (element) {
        element.selected = false;
      });
      a.selected = true;
    }
    /**
     * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–¥–∑–∞–≥–æ–ª–æ–≤–∫–∞
     * @param {Object} where - –æ–±—ä–µ–∫—Ç —Å –º–∞—Å—Å–∏–≤–æ–º items
     */


    function selected(where) {
      var title = [];
      where.items.forEach(function (a) {
        if (a.selected || a.checked) title.push(a.title);
      });
      where.subtitle = title.length ? title.join(', ') : Lampa.Lang.translate('nochoice');
    }
    /**
     * –ü–æ–¥–º–µ–Ω—é
     * @param {Object} item - –æ–±—ä–µ–∫—Ç —ç–ª–µ–º–µ–Ω—Ç–∞
     */


    function submenu(item) {
      Lampa.Select.show({
        title: item.title,
        items: item.items,
        onBack: main,
        onSelect: function onSelect(a) {
          select(item.items, a);
          main();
        }
      });
    }
    /**
     * –ó–∞–ø—É—Å–∫ —Ñ–∏–ª—å—Ç—Ä–∞
     */


    function show(genres_list, countries_list) {
      if (!initialized) {
        initialized = true;
        genres_list.forEach(function (g) {
          if (!g.hide) {
            data.genre.items.push({
              title: g.title,
              id: g.id
            });
          }
        });
        countries_list.forEach(function (c) {
          if (!c.hide) {
            data.country.items.push({
              title: c.title,
              id: c.id
            });
          }
        });
      }

      main();
    }

    var KP_FILTER = {
      show: show
    };

    var ALL_SOURCES = [{
      name: 'tmdb',
      title: 'TMDB'
    }, {
      name: 'cub',
      title: 'CUB'
    }, {
      name: 'pub',
      title: 'PUB'
    }, {
      name: 'filmix',
      title: 'FILMIX'
    }, {
      name: KP.SOURCE_NAME,
      title: KP.SOURCE_TITLE
    }];

    function startPlugin() {
      window.kp_source_plugin = true;

      function addPlugin() {
        if (Lampa.Api.sources[KP.SOURCE_NAME]) {
          Lampa.Noty.show('–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–ª–∞–≥–∏–Ω –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π —Å kp_source');
          return;
        }

        Lampa.Api.sources[KP.SOURCE_NAME] = KP;
        Object.defineProperty(Lampa.Api.sources, KP.SOURCE_NAME, {
          get: function get() {
            return KP;
          }
        });
        var sources = {};

        if (Lampa.Params.values && Lampa.Params.values['source']) {
          Lampa.Arrays.extend(sources, Lampa.Params.values['source']);
          sources[KP.SOURCE_NAME] = KP.SOURCE_TITLE;
        } else {
          ALL_SOURCES.forEach(function (s) {
            if (Lampa.Api.sources[s.name]) sources[s.name] = s.title;
          });
        }

        Lampa.Params.select('source', sources, 'tmdb');

        if (Lampa.Router) {
          Lampa.Listener.follow('menu', function (e) {
            if (e.type == 'action' && Lampa.Storage.field('source') == KP.SOURCE_NAME) {
              if (
              /*e.action == 'anime' ||*/
              e.action == 'cartoon') {
                Lampa.Router.call('category', {
                  url: e.action,
                  title: (e.action == 'anime' ? Lampa.Lang.translate('menu_anime') : Lampa.Lang.translate('menu_multmovie')) + ' - ' + KP.SOURCE_NAME.toUpperCase(),
                  source: KP.SOURCE_NAME
                });
                e.abort();
              }

              if (e.action == 'filter') {
                KP.kpFilters({}, function (genres_list, countries_list) {
                  KP_FILTER.show(genres_list, countries_list);
                });
                e.abort();
              }
            }
          });
        }
      }

      if (window.appready) addPlugin();else {
        Lampa.Listener.follow('app', function (e) {
          if (e.type == 'ready') addPlugin();
        });
      }
    }

    if (!window.kp_source_plugin) startPlugin();

})();

```

---

### docs/tmdb_proxy.js

```js
(function () {
    'use strict';

    function filter(u) {
      return u.replace(/\/\/+/g, '/');
    }

    function proxyLink(u) {
      var proxy = Lampa.Storage.field('proxy_tmdb') ? 'https://apn-latest.onrender.com/' : '';
      return proxy + u;
    }

    Lampa.TMDB.image = function (url) {
      var base = Lampa.Utils.protocol() + filter('image.tmdb.org/' + url);
      return proxyLink(base);
    };

    Lampa.TMDB.api = function (url) {
      var base = Lampa.Utils.protocol() + filter('api.themoviedb.org/3/' + url);
      return proxyLink(base);
    };

    Lampa.Settings.listener.follow('open', function (e) {
      if (e.name == 'tmdb') {
        e.body.find('[data-parent="proxy"]').remove();
      }
    });
    console.log('TMDB-Proxy', 'nb557, enabled:', Lampa.Storage.field('proxy_tmdb'));

})();

```

---

### generate-docs.js

```js
import fs from 'fs';
import path from 'path';

const projectRoot = process.cwd();
const outputFile = path.join(projectRoot, 'project-code.md');

const includedExtensions = ['.js', '.jsx', '.json', '.md', '.yml', '.yaml', '.Dockerfile'];
const excludedDirs = ['node_modules', 'dist', '.git', '.vscode', 'android', 'downloads', '.gemini'];
const excludedFiles = ['package-lock.json', 'project-code.md', 'MediaBox-v2.3.1.apk', 'MediaBox-v2.3.apk'];

let output = `# PWA-TorServe Project Source Code\n\n`;
output += `Generated on: ${new Date().toISOString()}\n\n`;

function getFiles(dir, allFiles = []) {
    const files = fs.readdirSync(dir);
    for (const file of files) {
        const name = path.join(dir, file);
        if (excludedDirs.some(d => name.includes(d))) continue;
        if (excludedFiles.includes(file)) continue;

        if (fs.statSync(name).isDirectory()) {
            getFiles(name, allFiles);
        } else {
            const ext = path.extname(file);
            if (includedExtensions.includes(ext) || file === 'Dockerfile') {
                allFiles.push(name);
            }
        }
    }
    return allFiles;
}

const files = getFiles(projectRoot);
output += `## Project Statistics\n\n`;
output += `- Total files included: ${files.length}\n`;
output += `- Date: ${new Date().toLocaleDateString()}\n\n`;

output += `## Table of Contents\n\n`;
files.forEach(f => {
    const relativePath = path.relative(projectRoot, f);
    output += `- [${relativePath}](#${relativePath.replace(/\//g, '-').replace(/\./g, '-')})\n`;
});

output += `\n---\n\n`;

files.forEach(f => {
    const relativePath = path.relative(projectRoot, f);
    const content = fs.readFileSync(f, 'utf8');
    const ext = path.extname(f).substring(1);
    const lang = ext === 'jsx' ? 'javascript' : (ext === 'yml' ? 'yaml' : ext || 'text');
    
    output += `### ${relativePath}\n\n`;
    output += `\`\`\`${lang}\n${content}\n\`\`\`\n\n`;
    output += `---\n\n`;
});

fs.writeFileSync(outputFile, output);
console.log(`Documentation generated: ${outputFile}`);

```

---

### package.json

```json
{
  "name": "pwa-torserve",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node server/index.js",
    "dev": "node server/index.js",
    "client:install": "cd client && npm install",
    "client:build": "cd client && npm run build"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "lowdb": "^7.0.1",
    "torrent-stream": "^1.2.0"
  }
}
```

---

### roadmap.md

```md
# üó∫Ô∏è PWA-TorServe ‚Äî –§–∏–Ω–∞–ª—å–Ω–∞—è –¥–æ—Ä–æ–∂–Ω–∞—è –∫–∞—Ä—Ç–∞ —Ä–∞–∑–≤–∏—Ç–∏—è —Ç–æ—Ä—Ä–µ–Ω—Ç-–∞–≥—Ä–µ–≥–∞—Ü–∏–∏ (FINAL)

## üìå 0. –ö–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–æ–µ–∫—Ç–∞

**PWA-TorServe** ‚Äî self-hosted Node.js middleware –¥–ª—è –ø–æ–∏—Å–∫–∞, –∞–≥—Ä–µ–≥–∞—Ü–∏–∏ –∏ —Å—Ç—Ä–∏–º–∏–Ω–≥–∞ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤ —Å PWA-–∫–ª–∏–µ–Ω—Ç–æ–º.

–ü—Ä–æ–µ–∫—Ç:
- –Ω–µ —Ö–æ—Å—Ç–∏—Ç –∫–æ–Ω—Ç–µ–Ω—Ç
- –∞–≥—Ä–µ–≥–∏—Ä—É–µ—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–∏
- –≤—ã–±–∏—Ä–∞–µ—Ç –ª—É—á—à–∏–π —Ä–µ–ª–∏–∑
- –ø–µ—Ä–µ–¥–∞—ë—Ç magnet –≤ –ª–æ–∫–∞–ª—å–Ω—ã–π streaming engine

–ö–ª—é—á–µ–≤–∞—è –∏–¥–µ—è:  
üëâ **—É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å, –∫–æ–Ω—Ç—Ä–æ–ª—å –∏ –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–æ—Å—Ç—å**, –∞ –Ω–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –æ—Ö–≤–∞—Ç.

---

## üéØ 1. –ì–ª–æ–±–∞–ª—å–Ω–∞—è —Ü–µ–ª—å (North Star)

–ü–æ—Å—Ç—Ä–æ–∏—Ç—å **—É—Å—Ç–æ–π—á–∏–≤—É—é —Å–∏—Å—Ç–µ–º—É –∞–≥—Ä–µ–≥–∞—Ü–∏–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç-–∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤**, –≥–¥–µ:

- –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –Ω–µ –ª–æ–º–∞–µ—Ç core
- –ø–∞–¥–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ —Ç—Ä–µ–∫–µ—Ä–∞ –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ —Å–∏—Å—Ç–µ–º—É
- AutoDownloader –Ω–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –æ–¥–Ω–æ–≥–æ API
- —Å–∏—Å—Ç–µ–º–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ —É—Å–ª–æ–≤–∏—è—Ö –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫
- –∫–æ–¥ –æ—Å—Ç–∞—ë—Ç—Å—è —á–∏—Ç–∞–µ–º—ã–º –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–º

---

## üß† 2. –£—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã

### 2.1 Core-–ø—Ä–∏–Ω—Ü–∏–ø—ã
- JavaScript-–ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã –∫–∞–∫ –æ—Å–Ω–æ–≤–∞
- –µ–¥–∏–Ω—ã–π `SearchResult`
- —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π Aggregator
- partial success –¥–æ–ø—É—Å—Ç–∏–º
- self-hosted first
- graceful degradation

### 2.2 –û—Å–æ–∑–Ω–∞–Ω–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
- –Ω–µ –∑–∞–º–µ–Ω—è—Ç—å Jackett
- –Ω–µ –≥–Ω–∞—Ç—å—Å—è –∑–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Ç—Ä–µ–∫–µ—Ä–æ–≤
- –Ω–µ —Å—Ç—Ä–æ–∏—Ç—å —Å–µ—Ç–µ–≤–æ–π ‚Äú–∫–æ–º–±–∞–π–Ω‚Äù
- –Ω–µ –∑–∞–≤–∏—Å–µ—Ç—å –æ—Ç –≤–Ω–µ—à–Ω–∏—Ö –æ–±–ª–∞—á–Ω—ã—Ö API

---

## üåê 3. –≠—Ç–∞–ø 1 ‚Äî Unified Network Layer

### –¶–µ–ª—å
–°–¥–µ–ª–∞—Ç—å —Å–µ—Ç–µ–≤–æ–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —É—Å—Ç–æ–π—á–∏–≤—ã–º –∫:
- DPI
- Cloudflare / anti-bot
- –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω—ã–º –∑–µ—Ä–∫–∞–ª–∞–º

### –°–æ—Å—Ç–∞–≤
- –µ–¥–∏–Ω—ã–π HTTP-–∫–ª–∏–µ–Ω—Ç
- browser-like TLS / headers
- retries + —Ç–∞–π–º–∞—É—Ç—ã
- mirror failover
- rate limiting per provider
- –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤

### –ü—Ä–∏–Ω—Ü–∏–ø—ã
- direct —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ ‚Äî –æ—Å–Ω–æ–≤–Ω–æ–π –ø—É—Ç—å
- fallback-—Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –≤–æ–∑–º–æ–∂–Ω—ã
- –ø—Ä–æ–∫—Å–∏ / Tor **–Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã**, –Ω–æ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º—ã

---

## üîå 4. –≠—Ç–∞–ø 2 ‚Äî Unified Provider Architecture

### –¶–µ–ª—å
–£–±—Ä–∞—Ç—å —Ö–∞—Ä–¥–∫–æ–¥ –∏ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ª–æ–≥–∏–∫–∏.

### –ú–æ–¥–µ–ª—å
- `BaseProvider`
- `ProviderManager`
- –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π `SearchResult`

–ö–∞–∂–¥—ã–π –ø—Ä–æ–≤–∞–π–¥–µ—Ä:
- –∏–Ω–∫–∞–ø—Å—É–ª–∏—Ä—É–µ—Ç –ø–∞—Ä—Å–∏–Ω–≥ –∏ —Å–µ—Ç—å
- —Ä–µ–∞–ª–∏–∑—É–µ—Ç –∫–æ–Ω—Ç—Ä–∞–∫—Ç
- –Ω–µ –∑–Ω–∞–µ—Ç –æ UI –∏ AutoDownloader

---

## üìö 5. –≠—Ç–∞–ø 3 ‚Äî –ö–ª—é—á–µ–≤—ã–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã

### –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –Ω–∞–¥—ë–∂–Ω—ã–π –Ω–∞–±–æ—Ä
- **Jacred** ‚Äî –æ—Å–Ω–æ–≤–Ω–æ–π –∞–≥—Ä–µ–≥–∞—Ç–æ—Ä
- **RuTracker** ‚Äî –ø—Ä–∏–≤–∞—Ç–Ω—ã–π RU-–∏—Å—Ç–æ—á–Ω–∏–∫
- **Rutor** ‚Äî –ø—É–±–ª–∏—á–Ω—ã–π –±—ã—Å—Ç—Ä—ã–π
- **TorLook** ‚Äî fallback

### –£—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å
- mirror rotation
- rate limiting (–æ—Å–æ–±–µ–Ω–Ω–æ RuTracker)
- persisted cookies
- –º–∏–Ω–∏–º—É–º –ª–æ–≥–∏–Ω–æ–≤

---

## üß† 6. –≠—Ç–∞–ø 4 ‚Äî Aggregator + Ranking

### Aggregator
- –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
- `Promise.allSettled`
- timeout per provider
- –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏—è –ø–æ infohash
- partial success

### Ranking
- —Å–∏–¥—ã
- —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
- —è–∑—ã–∫
- –∏—Å—Ç–æ—á–Ω–∏–∫
- sanity-check –ø–æ —Ä–∞–∑–º–µ—Ä—É
- —É—á—ë—Ç REPACK / PROPER

> –í–∞–∂–Ω–æ: –ª–æ–≥–∏–∫–∞ –≤—ã–±–æ—Ä–∞ –ª—É—á—à–µ–≥–æ —Ä–µ–ª–∏–∑–∞ ‚Äî **–æ–±—â–∞—è**, –Ω–µ —Ç–æ–ª—å–∫–æ –¥–ª—è AutoDownloader.

---

## üì• 7. –≠—Ç–∞–ø 5 ‚Äî AutoDownloader v2

### –¶–µ–ª—å
–°–¥–µ–ª–∞—Ç—å –∞–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫—É –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ–π –æ—Ç –æ–¥–Ω–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞.

### –ò–∑–º–µ–Ω–µ–Ω–∏—è
- –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ Aggregator
- –≤—ã–±–æ—Ä best candidate
- –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏—è
- —Å—Ç—Ä–æ–≥–æ 1 —Ç–æ—Ä—Ä–µ–Ω—Ç –Ω–∞ —ç–ø–∏–∑–æ–¥
- –∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å REPACK / BATCH

---

## üõ°Ô∏è 8. –≠—Ç–∞–ø 6 ‚Äî Hardening

- provider health checks
- circuit breaker per provider
- short-lived search cache (5‚Äì10 –º–∏–Ω)
- persisted sessions (RuTracker)
- –∑–∞—â–∏—Ç–∞ –æ—Ç –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤

---

# üîÆ 9. –ü–ª–∞–Ω –Ω–∞ –±—É–¥—É—â–µ–µ (Future considerations)

> –≠—Ç–æ—Ç —Ä–∞–∑–¥–µ–ª **–ù–ï —è–≤–ª—è–µ—Ç—Å—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º roadmap**.  
> –û–Ω –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω, —á—Ç–æ–±—ã:
> - –Ω–µ –∑–∞–±—ã—Ç—å –æ–±—Å—É–∂–¥—ë–Ω–Ω—ã–µ –∏–¥–µ–∏
> - –ø–æ–Ω–∏–º–∞—Ç—å, *–∑–∞—á–µ–º* –æ–Ω–∏ –º–æ–≥—É—Ç –ø–æ–Ω–∞–¥–æ–±–∏—Ç—å—Å—è
> - –Ω–µ –ø—Ä–∏–Ω–∏–º–∞—Ç—å –∏–º–ø—É–ª—å—Å–∏–≤–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π –ø–æ–∑–∂–µ

---

## 9.1 RSS Providers

**–ß—Ç–æ —ç—Ç–æ:**  
–ü—Ä–æ–≤–∞–π–¥–µ—Ä—ã, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–µ RSS –≤–º–µ—Å—Ç–æ HTML-–ø–æ–∏—Å–∫–∞.

**–ó–∞—á–µ–º:**  
- –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ —Ç—Ä–µ–∫–µ—Ä—ã —á–∞—Å—Ç–æ —Ä–∞–∑—Ä–µ—à–∞—é—Ç —Ç–æ–ª—å–∫–æ RSS
- –º–µ–Ω—å—à–µ –±–∞–Ω–æ–≤ –∏ –∫–∞–ø—á
- –∏–¥–µ–∞–ª—å–Ω–æ –¥–ª—è AutoDownloader

**–ü–æ—á–µ–º—É –Ω–µ core:**  
- –Ω–µ –Ω—É–∂–µ–Ω –¥–ª—è –ø—É–±–ª–∏—á–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
- –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –ø–æ–≤–µ—Ä—Ö —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ Aggregator

---

## 9.2 YAML / Cardigann Providers

**–ß—Ç–æ —ç—Ç–æ:**  
–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è YAML-–æ–ø–∏—Å–∞–Ω–∏–π —Ç—Ä–µ–∫–µ—Ä–æ–≤ (–ø–æ —Ç–∏–ø—É Cardigann).

**–ó–∞—á–µ–º:**  
- –±—ã—Å—Ç—Ä–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Å—Ç—ã—Ö –ø—É–±–ª–∏—á–Ω—ã—Ö —Ç—Ä–µ–∫–µ—Ä–æ–≤
- –ø—Ä–∞–≤–∫–∞ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è JS-–∫–æ–¥–∞

**–ü–æ—á–µ–º—É –Ω–µ core:**  
- YAML –ø–ª–æ—Ö–æ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:
  - –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
  - –∫–∞–ø—á–∏
  - —Å–ª–æ–∂–Ω—ã—Ö retry-–ª–æ–≥–∏–∫
- —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å –ø–æ–¥–¥–µ—Ä–∂–∫–∏

**–ü–æ–∑–∏—Ü–∏—è:**  
YAML ‚Äî *–æ–¥–∏–Ω –∏–∑ —Ç–∏–ø–æ–≤ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤*, –∞ –Ω–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–∞—è –æ—Å–Ω–æ–≤–∞.

---

## 9.3 Captcha Handling

**–ß—Ç–æ —ç—Ç–æ:**  
–ü–µ—Ä–µ—Ö–≤–∞—Ç –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞–ø—á–∏ (RuTracker –∏ –¥—Ä.).

**–ó–∞—á–µ–º:**  
- –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ —Ç—Ä–µ–∫–µ—Ä—ã —Ç—Ä–µ–±—É—é—Ç –∫–∞–ø—á—É
- –±–µ–∑ —ç—Ç–æ–≥–æ –ø—Ä–æ–≤–∞–π–¥–µ—Ä –º–æ–∂–µ—Ç –±—ã—Ç—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω

**–§–æ—Ä–º–∞:**  
- semi-manual (–ø–æ–∫–∞–∑ –≤ UI)
- –∏–ª–∏ –≤–Ω–µ—à–Ω–∏–π —Å–µ—Ä–≤–∏—Å (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)

**–ü–æ—á–µ–º—É –Ω–µ core:**  
- provider-specific edge-case
- –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É –≤ —Ü–µ–ª–æ–º

---

## 9.4 Jackett / Torznab API

**–ß—Ç–æ —ç—Ç–æ:**  
–°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å Sonarr / Radarr / Bazarr.

**–ó–∞—á–µ–º:**  
- –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –≤–Ω–µ—à–Ω–µ–π —ç–∫–æ—Å–∏—Å—Ç–µ–º–æ–π
- –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ PWA-TorServe –∫–∞–∫ backend

**–ü–æ—á–µ–º—É –Ω–µ core:**  
- –Ω–µ –Ω—É–∂–µ–Ω –¥–ª—è UI –∏ AutoDownloader
- –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –ø–æ—Å–ª–µ —Å—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏–∏

---

## 9.5 Proxy / Tor / Headless Browser

**–ß—Ç–æ —ç—Ç–æ:**  
–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–µ—Ç–µ–≤—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏.

**–ó–∞—á–µ–º:**  
- –∫—Ä–∞–π–Ω–∏–µ —Å–ª—É—á–∞–∏ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫
- —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—ã

**–ü–æ—á–µ–º—É –Ω–µ core:**  
- —Å–ª–æ–∂–Ω–æ—Å—Ç—å
- –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å
- –≤—ã—Å–æ–∫–∏–π overhead

**–ü–æ–∑–∏—Ü–∏—è:**  
Last-resort, experimental.

---

## üö´ 10. –Ø–≤–Ω—ã–µ –Ω–µ-—Ü–µ–ª–∏ (–¥–∞–∂–µ –≤ –±—É–¥—É—â–µ–º)

- –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –≤ Jackett-replacement
- –ø–æ–¥–¥–µ—Ä–∂–∫–∞ —Å–æ—Ç–µ–Ω —Ç—Ä–µ–∫–µ—Ä–æ–≤ –ª—é–±–æ–π —Ü–µ–Ω–æ–π
- –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–π –æ–±—Ö–æ–¥ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫ ‚Äú–ª—é–±–æ–π —Ü–µ–Ω–æ–π‚Äù
- —É—Ö–æ–¥ –æ—Ç self-hosted –º–æ–¥–µ–ª–∏

---

## ‚úÖ 11. Definition of Done (–∏—Ç–æ–≥–æ–≤—ã–π)

- –Ω–æ–≤—ã–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è –±–µ–∑ –ø—Ä–∞–≤–æ–∫ core
- —Å–∏—Å—Ç–µ–º–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∏ –ø–∞–¥–µ–Ω–∏–∏ —á–∞—Å—Ç–∏ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
- AutoDownloader –Ω–µ –¥—É–±–ª–∏—Ä—É–µ—Ç –∑–∞–≥—Ä—É–∑–∫–∏
- –Ω–µ—Ç –∂—ë—Å—Ç–∫–æ–π –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–¥–Ω–æ–≥–æ API
- –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –æ—Å—Ç–∞—ë—Ç—Å—è —á–∏—Ç–∞–µ–º–æ–π


```

---

### server/__tests__/logger.test.js

```js
/**
 * Logger Module Tests
 * Tests for server/utils/logger.js
 */

import { test, expect } from './test-runner.js'

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Logger Tests
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

test('logger.child creates module-specific logger', async () => {
    const { logger } = await import('../utils/logger.js')
    const childLogger = logger.child('TestModule')

    expect(childLogger).toBeDefined()
    expect(typeof childLogger.info).toBe('function')
    expect(typeof childLogger.error).toBe('function')
    expect(typeof childLogger.warn).toBe('function')
    expect(typeof childLogger.debug).toBe('function')
})

test('logger has all required methods', async () => {
    const { logger } = await import('../utils/logger.js')

    expect(typeof logger.info).toBe('function')
    expect(typeof logger.error).toBe('function')
    expect(typeof logger.warn).toBe('function')
    expect(typeof logger.debug).toBe('function')
    expect(typeof logger.child).toBe('function')
})

test('logger.info does not throw', async () => {
    const { logger } = await import('../utils/logger.js')

    // Should not throw
    logger.info('Test message', { key: 'value' })
    expect(true).toBe(true)
})

test('logger.error does not throw', async () => {
    const { logger } = await import('../utils/logger.js')

    // Should not throw
    logger.error('Test error', { errorCode: 500 })
    expect(true).toBe(true)
})

```

---

### server/__tests__/run-tests.js

```js
/**
 * PWA-TorServe Test Entry Point
 * 
 * Run: node server/__tests__/run-tests.js
 */

import { runTests } from './test-runner.js'

// Import all test files (they register tests on import)
await import('./logger.test.js')
await import('./torrent.test.js')
await import('./watchdog.test.js')

// Run all registered tests
await runTests()

```

---

### server/__tests__/test-runner.js

```js
/**
 * Unit Tests for PWA-TorServe Server
 * 
 * Run with: node --experimental-vm-modules server/__tests__/run-tests.js
 * 
 * Note: These are simple assertion-based tests that work without Jest/Vitest
 *       to avoid npm install requirements on NAS
 */

const tests = []
let passed = 0
let failed = 0

// Test registration helper
function test(name, fn) {
    tests.push({ name, fn })
}

// Assertion helpers
function expect(actual) {
    return {
        toBe: (expected) => {
            if (actual !== expected) {
                throw new Error(`Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`)
            }
        },
        toEqual: (expected) => {
            if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                throw new Error(`Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`)
            }
        },
        toBeTruthy: () => {
            if (!actual) {
                throw new Error(`Expected truthy value, got ${JSON.stringify(actual)}`)
            }
        },
        toBeFalsy: () => {
            if (actual) {
                throw new Error(`Expected falsy value, got ${JSON.stringify(actual)}`)
            }
        },
        toContain: (expected) => {
            if (!actual.includes(expected)) {
                throw new Error(`Expected "${actual}" to contain "${expected}"`)
            }
        },
        toBeGreaterThan: (expected) => {
            if (actual <= expected) {
                throw new Error(`Expected ${actual} to be greater than ${expected}`)
            }
        },
        toBeNull: () => {
            if (actual !== null) {
                throw new Error(`Expected null, got ${JSON.stringify(actual)}`)
            }
        },
        toBeDefined: () => {
            if (actual === undefined) {
                throw new Error(`Expected value to be defined`)
            }
        }
    }
}

// Run all tests
async function runTests() {
    console.log('\nüß™ PWA-TorServe Test Suite\n')
    console.log('‚ïê'.repeat(50))

    for (const { name, fn } of tests) {
        try {
            await fn()
            console.log(`‚úÖ ${name}`)
            passed++
        } catch (err) {
            console.log(`‚ùå ${name}`)
            console.log(`   ‚îî‚îÄ ${err.message}`)
            failed++
        }
    }

    console.log('‚ïê'.repeat(50))
    console.log(`\nüìä Results: ${passed} passed, ${failed} failed, ${tests.length} total\n`)

    if (failed > 0) {
        process.exit(1)
    }
}

// Export for test files
export { test, expect, runTests }

```

---

### server/__tests__/torrent.test.js

```js
/**
 * Torrent Module Tests
 * Tests for server/torrent.js utilities
 */

import { test, expect } from './test-runner.js'

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Helper Function Tests (can be run without actual torrents)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

test('PUBLIC_TRACKERS should be defined and non-empty', async () => {
    // We test by checking torrent.js exports
    const torrentModule = await import('../torrent.js')

    // Module should export required functions
    expect(typeof torrentModule.addTorrent).toBe('function')
    expect(typeof torrentModule.removeTorrent).toBe('function')
    expect(typeof torrentModule.getTorrent).toBe('function')
    expect(typeof torrentModule.getAllTorrents).toBe('function')
})

test('getAllTorrents returns array', async () => {
    const { getAllTorrents } = await import('../torrent.js')
    const torrents = getAllTorrents()

    expect(Array.isArray(torrents)).toBe(true)
})

test('getTorrent returns null for non-existent hash', async () => {
    const { getTorrent } = await import('../torrent.js')
    const result = getTorrent('nonexistent_hash_123456')

    expect(result).toBeNull()
})

test('removeTorrent returns false for non-existent hash', async () => {
    const { removeTorrent } = await import('../torrent.js')
    const result = removeTorrent('nonexistent_hash_123456')

    expect(result).toBeFalsy()
})

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Magnet URI Parsing (if you have such utilities)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

test('magnet URI format validation', () => {
    const validMagnet = 'magnet:?xt=urn:btih:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
    const invalidMagnet = 'not-a-magnet'

    expect(validMagnet.startsWith('magnet:')).toBe(true)
    expect(invalidMagnet.startsWith('magnet:')).toBe(false)
})

```

---

### server/__tests__/watchdog.test.js

```js
/**
 * Watchdog Module Tests
 * Tests for server/watchdog.js
 */

import { test, expect } from './test-runner.js'

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Watchdog API Tests
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

test('watchdog exports required functions', async () => {
    const watchdog = await import('../watchdog.js')

    expect(typeof watchdog.getServerState).toBe('function')
    expect(typeof watchdog.startWatchdog).toBe('function')
    expect(typeof watchdog.stopWatchdog).toBe('function')
})

test('getServerState returns valid state object', async () => {
    const { getServerState } = await import('../watchdog.js')
    const state = getServerState()

    expect(state).toBeDefined()
    expect(typeof state.serverStatus).toBe('string')
    expect(typeof state.lastStateChange).toBe('number')
})

test('serverStatus is valid value', async () => {
    const { getServerState } = await import('../watchdog.js')
    const state = getServerState()

    const validStatuses = ['ok', 'degraded', 'error', 'circuit_open']
    expect(validStatuses.includes(state.serverStatus)).toBe(true)
})

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// RAM Helper Test
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

test('process.memoryUsage returns valid data', () => {
    const mem = process.memoryUsage()

    expect(mem.heapUsed).toBeGreaterThan(0)
    expect(mem.heapTotal).toBeGreaterThan(0)
    expect(mem.rss).toBeGreaterThan(0)
})

```

---

### server/aggregator.js

```js
/**
 * Aggregator - Multi-source torrent search aggregation
 * PWA-TorServe Provider Architecture v2.8.0
 * 
 * Combines results from multiple providers using Promise.allSettled
 * Implements:
 * - Parallel search across all enabled providers
 * - Timeout per provider
 * - Deduplication by infohash
 * - Partial success (returns results even if some providers fail)
 * - Search cache (5 min TTL)
 * - Circuit breaker per provider
 */

import { providerManager } from './providers/index.js'
import { searchCache } from './searchCache.js'
import { logger } from './utils/logger.js'

const log = logger.child('Aggregator')

// Search timeout per provider (ms)
const PROVIDER_TIMEOUT = 30000

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üîí Circuit Breaker: Auto-disable failing providers
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const FAILURE_THRESHOLD = 3        // Failures before opening circuit
const RECOVERY_TIMEOUT = 5 * 60000 // 5 minutes before retry

const circuitBreakers = new Map() // provider -> { failures, openedAt }

function getCircuitState(providerName) {
    if (!circuitBreakers.has(providerName)) {
        circuitBreakers.set(providerName, { failures: 0, openedAt: null })
    }
    return circuitBreakers.get(providerName)
}

function isCircuitOpen(providerName) {
    const state = getCircuitState(providerName)
    if (!state.openedAt) return false

    // Check if recovery timeout passed
    if (Date.now() - state.openedAt > RECOVERY_TIMEOUT) {
        state.failures = 0
        state.openedAt = null
        log.info('Circuit closed (recovery)', { provider: providerName })
        return false
    }
    return true
}

function recordSuccess(providerName) {
    const state = getCircuitState(providerName)
    state.failures = 0
    state.openedAt = null
}

function recordFailure(providerName) {
    const state = getCircuitState(providerName)
    state.failures++

    if (state.failures >= FAILURE_THRESHOLD && !state.openedAt) {
        state.openedAt = Date.now()
        log.warn('Circuit opened', { provider: providerName, failures: state.failures })
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Search across all enabled providers (with cache)
 * @param {string} query - Search query
 * @param {Object} options - Search options
 * @param {boolean} options.skipCache - Skip cache lookup
 * @returns {Promise<{results: Array, errors: Array, providers: Object, cached: boolean}>}
 */
export async function search(query, options = {}) {
    // Check cache first
    if (!options.skipCache) {
        const cached = searchCache.get(query)
        if (cached) {
            log.info('üì¶ Cache hit', { query, resultsCount: cached.results.length })
            return { ...cached, errors: [], cached: true }
        }
    }

    const providers = providerManager.getEnabled()
        .filter(p => !isCircuitOpen(p.name))

    if (providers.length === 0) {
        log.warn('No available providers')
        return { results: [], errors: ['No available providers'], providers: {}, cached: false }
    }

    log.info('üîç Aggregated search', { query, providersCount: providers.length })

    // Create search promises with timeout
    const searchPromises = providers.map(async (provider) => {
        const timeoutPromise = new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Timeout')), PROVIDER_TIMEOUT)
        )

        try {
            const results = await Promise.race([
                provider.search(query),
                timeoutPromise
            ])
            recordSuccess(provider.name)
            return { provider: provider.name, results, success: true }
        } catch (error) {
            recordFailure(provider.name)
            return { provider: provider.name, error: error.message, success: false }
        }
    })

    // Wait for all providers (partial success allowed)
    const outcomes = await Promise.allSettled(searchPromises)

    // Collect results and errors
    const allResults = []
    const errors = []
    const providerStats = {}

    for (const outcome of outcomes) {
        if (outcome.status === 'fulfilled') {
            const { provider, results, success, error } = outcome.value

            if (success && results) {
                allResults.push(...results)
                providerStats[provider] = { count: results.length, status: 'ok' }
                log.info(`‚úÖ ${provider}`, { count: results.length })
            } else {
                errors.push({ provider, error })
                providerStats[provider] = { count: 0, status: 'error', error }
                log.warn(`‚ùå ${provider}`, { error })
            }
        } else {
            log.error('Unexpected rejection', outcome.reason)
        }
    }

    // Add skipped providers (circuit open)
    const skipped = providerManager.getEnabled()
        .filter(p => isCircuitOpen(p.name))
    for (const p of skipped) {
        providerStats[p.name] = { count: 0, status: 'circuit_open' }
    }

    // Deduplicate by infohash
    const deduped = deduplicateByInfohash(allResults)

    // Store in cache if we got results
    if (deduped.length > 0) {
        searchCache.set(query, deduped, providerStats)
    }

    log.info('‚úÖ Aggregation complete', {
        totalResults: deduped.length,
        fromProviders: Object.keys(providerStats).length,
        errors: errors.length
    })

    return { results: deduped, errors, providers: providerStats, cached: false }
}

/**
 * Get magnet link for a torrent from specific provider
 */
export async function getMagnet(providerName, id) {
    const provider = providerManager.get(providerName)
    if (!provider) {
        return { error: `Provider not found: ${providerName}` }
    }
    return provider.getMagnet(id)
}

/**
 * Get status of all providers (including circuit state)
 */
export function getProvidersStatus() {
    return providerManager.getAll().map(p => ({
        name: p.name,
        enabled: p.enabled,
        healthy: p.isHealthy(),
        circuitOpen: isCircuitOpen(p.name),
        failures: getCircuitState(p.name).failures
    }))
}

/**
 * Get cache statistics
 */
export function getCacheStats() {
    return searchCache.getStats()
}

/**
 * Reset circuit breaker for a provider
 */
export function resetCircuit(providerName) {
    const state = getCircuitState(providerName)
    state.failures = 0
    state.openedAt = null
    log.info('Circuit reset', { provider: providerName })
}

/**
 * Deduplicate results by infohash
 */
function deduplicateByInfohash(results) {
    const seen = new Map()

    for (const result of results) {
        const hash = extractInfohash(result.magnet)

        if (!hash) {
            seen.set(`nohash_${Math.random()}`, result)
            continue
        }

        const existing = seen.get(hash)
        if (!existing || (result.seeders > existing.seeders)) {
            seen.set(hash, result)
        }
    }

    return Array.from(seen.values())
}

/**
 * Extract infohash from magnet link
 */
function extractInfohash(magnet) {
    if (!magnet) return null

    const hexMatch = magnet.match(/urn:btih:([a-fA-F0-9]{40})/i)
    if (hexMatch) return hexMatch[1].toLowerCase()

    const base32Match = magnet.match(/urn:btih:([A-Z2-7]{32})/i)
    if (base32Match) return base32Match[1].toLowerCase()

    return null
}

```

---

### server/autodownloader.js

```js
/**
 * Auto-Downloader Module v2.7.0 - MULTI-SOURCE
 * PWA-TorServe
 *
 * üÜï v2.7.0 FEATURES:
 * - MULTI-SOURCE: Uses Aggregator (Jacred + RuTracker + future providers)
 * - PARTIAL SUCCESS: Works even if some providers fail
 * - DEDUPLICATION: Results deduplicated by infohash across providers
 *
 * üÜï v2.6.7 FIXES:
 * - FIX: Translation now returns ARRAY ["Fallout", "Fallout S02"]
 * - FIX: Base name searched first (finds Russian releases like "–§–æ–ª–ª–∞—É—Ç 2 —Å–µ–∑–æ–Ω")
 *
 * üÜï v2.6.6 FEATURES:
 * - SMART QUERY: Auto-removes quality tags (DV, HDR, HMAX, WEB etc.)
 * - MULTI-VARIANT: Tries multiple query variants for better results
 *
 * üÜï v2.6.3 OPTIMIZATIONS:
 * - ATOMIC WRITES: Grouped DB updates to prevent race conditions & corruption
 * - LOGIC FIX: lastEpisode is no longer updated by REPACK releases
 */

import { db, safeWrite } from './db.js'
import { search as aggregatorSearch } from './aggregator.js'
import { addTorrent } from './torrent.js'
import { logger } from './utils/logger.js'

const log = logger.child('AutoDownloader')

// Runtime DEBUG toggle
const DEBUG = process.env.AUTO_DL_DEBUG === '1'
const MAX_DOWNLOADS_PER_RULE = 1  // Only download the BEST torrent per episode

// Keywords detection
const BATCH_KEYWORDS = /complete|season|batch|pack|collection|ÂÖ®ÈõÜ|box[\s\.]?set/i
const FIX_KEYWORDS = /repack|proper|rerip|real\.proper|internal/i

// Global blacklist (defaults)
const GLOBAL_BLACKLIST = [
    'camrip', 'cam', 'hdcam',
    'ts', 'hdts', 'telesync',
    'tc', 'telecine',
    'workprint', 'screener',
    'hindi', 'tamil', 'telugu', 'dubbed',
    'linedub', 'korean', 'chinese',
    'sample', 'trailer'
]

// REPACK window (hours)
const REPACK_WINDOW_HOURS = 72  // 3 days

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÔøΩ Query Normalization for Better Search Results
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Normalize search query by removing quality tags, codecs, groups etc.
 * This helps find results on jacred.xyz which doesn't parse these tags.
 * 
 * Examples:
 * - "IT Welcome to Derry S01 HMAX DV HDR WEB" ‚Üí "Welcome to Derry S01"
 * - "–§–æ–ª–ª–∞—É—Ç 2" ‚Üí "–§–æ–ª–ª–∞—É—Ç 2" (unchanged, but we'll try English too)
 */
function normalizeQuery(query) {
    let normalized = query.trim()

    // Remove quality/codec tags (case insensitive)
    const removeTags = [
        // Quality
        /\b(2160p|1080p|720p|480p|4k|uhd)\b/gi,
        // HDR variants
        /\b(hdr10\+?|hdr|dv|dolby\s*vision|hlg)\b/gi,
        // Codecs
        /\b(hevc|h\.?265|x\.?265|h\.?264|x\.?264|av1|avc)\b/gi,
        // Audio
        /\b(atmos|truehd|dts-?hd|dts|aac|ac3|eac3|flac)\b/gi,
        // Source tags (including standalone WEB)
        /\b(web-?dl|web-?rip|webrip|web|blu-?ray|bdrip|hdtv|dvdrip|hdrip|remux)\b/gi,
        // Streaming services
        /\b(hmax|hbo|netflix|nf|amzn|amazon|atvp|dsnp|disney\+?|hulu|paramount\+?)\b/gi,
        // Release groups (at end)
        /-[a-z0-9]+$/i,
        // Release groups in brackets
        /\[[^\]]+\]$/g,
        // "IT" prefix (often means International)
        /^IT\s+/i,
    ]

    for (const pattern of removeTags) {
        normalized = normalized.replace(pattern, '')
    }

    // Clean up multiple spaces and trim
    normalized = normalized.replace(/\s+/g, ' ').trim()

    // Remove trailing/leading dashes and dots
    normalized = normalized.replace(/^[\s.\-]+|[\s.\-]+$/g, '').trim()

    return normalized
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üåê RU‚ÜíEN Translation Dictionary for Popular Titles
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const RU_EN_TRANSLATIONS = {
    // Popular series
    '—Ñ–æ–ª–ª–∞—É—Ç': 'Fallout',
    'fallout': 'Fallout',
    '–≤–µ–¥—å–º–∞–∫': 'The Witcher',
    '–∏–≥—Ä–∞ –ø—Ä–µ—Å—Ç–æ–ª–æ–≤': 'Game of Thrones',
    '–¥–æ–º –¥—Ä–∞–∫–æ–Ω–∞': 'House of the Dragon',
    '–º–∞–Ω–¥–∞–ª–æ—Ä–µ—Ü': 'The Mandalorian',
    '–ª–æ–∫–∏': 'Loki',
    '–≤–∞–Ω–¥–∞ –≤–∏–∂–Ω': 'WandaVision',
    '—Å–æ–∫–æ–ª–∏–Ω—ã–π –≥–ª–∞–∑': 'Hawkeye',
    '–ª—É–Ω–Ω—ã–π —Ä—ã—Ü–∞—Ä—å': 'Moon Knight',
    '–º–∏—Å—Å –º–∞—Ä–≤–µ–ª': 'Ms Marvel',
    '–∂–µ–Ω—â–∏–Ω–∞ —Ö–∞–ª–∫': 'She Hulk',
    '—Å–µ–∫—Ä–µ—Ç–Ω–æ–µ –≤—Ç–æ—Ä–∂–µ–Ω–∏–µ': 'Secret Invasion',
    '–∞–≥–∞—Ç–∞': 'Agatha All Along',
    '–∑–≤—ë–∑–¥–Ω—ã–µ –≤–æ–π–Ω—ã': 'Star Wars',
    '–∑–≤–µ–∑–¥–Ω—ã–µ –≤–æ–π–Ω—ã': 'Star Wars',
    '–æ–±–∏ –≤–∞–Ω': 'Obi-Wan Kenobi',
    '–∞—Å–æ–∫–∞': 'Ahsoka',
    '–∞–Ω–¥–æ—Ä': 'Andor',
    '–∞–∫–æ–ª–∏—Ç': 'The Acolyte',
    '—Å–∫–µ–ª–µ—Ç–æ–Ω –∫—Ä—é': 'Skeleton Crew',
    '–∫–æ–ª—å—Ü–∞ –≤–ª–∞—Å—Ç–∏': 'Rings of Power',
    '–≤–ª–∞—Å—Ç–µ–ª–∏–Ω –∫–æ–ª–µ—Ü': 'Lord of the Rings',
    '–ø–æ—Å–ª–µ–¥–Ω–∏–µ –∏–∑ –Ω–∞—Å': 'The Last of Us',
    '–æ–¥–Ω–∏ –∏–∑ –Ω–∞—Å': 'The Last of Us',
    '–ø–æ—Å–ª–µ–¥–Ω–∏–π –∏–∑ –Ω–∞—Å': 'The Last of Us',
    '—Ö–æ–¥—è—á–∏–µ –º–µ—Ä—Ç–≤–µ—Ü—ã': 'The Walking Dead',
    '–æ—á–µ–Ω—å —Å—Ç—Ä–∞–Ω–Ω—ã–µ –¥–µ–ª–∞': 'Stranger Things',
    '—á—ë—Ä–Ω–æ–µ –∑–µ—Ä–∫–∞–ª–æ': 'Black Mirror',
    '—á–µ—Ä–Ω–æ–µ –∑–µ—Ä–∫–∞–ª–æ': 'Black Mirror',
    '–±—É–º–∞–∂–Ω—ã–π –¥–æ–º': 'Money Heist',
    '–ª–∞ –∫–∞—Å–∞ –¥–µ –ø–∞–ø–µ–ª—å': 'Money Heist',
    '–≤–æ –≤—Å–µ —Ç—è–∂–∫–∏–µ': 'Breaking Bad',
    '–ª—É—á—à–µ –∑–≤–æ–Ω–∏—Ç–µ —Å–æ–ª—É': 'Better Call Saul',
    '–æ—Å—Ç—Ä—ã–µ –∫–æ–∑—ã—Ä—å–∫–∏': 'Peaky Blinders',
    '–≤–∏–∫–∏–Ω–≥–∏': 'Vikings',
    '–∫–æ—Ä–æ–Ω–∞': 'The Crown',
    '—ç–π—Ñ–æ—Ä–∏—è': 'Euphoria',
    '—Å—É–∫–∞—Å–∏—è–Ω–∏–µ': 'The Shining', // :)
    '—Å–∏—è–Ω–∏–µ': 'The Shining',
    '–æ–Ω–æ': 'IT',
    '–ø–µ–Ω–Ω–∏—É–∞–π–∑': 'Pennywise',
    '–¥–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –¥–µ—Ä—Ä–∏': 'Welcome to Derry',
    // Movies
    '–¥—é–Ω–∞': 'Dune',
    '–∞–≤–∞—Ç–∞—Ä': 'Avatar',
    '–º—Å—Ç–∏—Ç–µ–ª–∏': 'Avengers',
    '—á–µ–ª–æ–≤–µ–∫ –ø–∞—É–∫': 'Spider-Man',
    '–±—ç—Ç–º–µ–Ω': 'Batman',
    '–¥–∂–æ–∫–µ—Ä': 'Joker',
    '—Å—É–ø–µ—Ä–º–µ–Ω': 'Superman',
    // Add more as needed
}

/**
 * Translate Russian query to English using dictionary
 * üÜï v2.6.7: Returns array of variants (with season AND without)
 */
function translateRuToEn(query) {
    const lowerQuery = query.toLowerCase().trim()
    const variants = []

    // Check for exact match first
    if (RU_EN_TRANSLATIONS[lowerQuery]) {
        variants.push(RU_EN_TRANSLATIONS[lowerQuery])
        return variants
    }

    // Check for partial matches (title + season)
    for (const [ru, en] of Object.entries(RU_EN_TRANSLATIONS)) {
        if (lowerQuery.startsWith(ru)) {
            // Always add base English name first (most likely to find results)
            variants.push(en)

            // Extract season/episode info after the title
            const suffix = lowerQuery.slice(ru.length).trim()
            const seasonMatch = suffix.match(/(?:—Å–µ–∑–æ–Ω\s*)?(\d+)/i)
            if (seasonMatch) {
                // Also add with season format (e.g., "Fallout S02")
                variants.push(`${en} S${seasonMatch[1].padStart(2, '0')}`)
            }

            return variants
        }
    }

    return []  // Return empty array if no translation found
}

/**
 * Generate query variants to try (for better search coverage)
 * Returns array of queries to try in order
 * üÜï v2.6.7: Translation returns array of variants
 */
function generateQueryVariants(query) {
    const variants = []
    const normalized = normalizeQuery(query)

    // 1. Try English translations first (most likely to find results)
    const englishTranslations = translateRuToEn(normalized || query)
    if (englishTranslations.length > 0) {
        variants.push(...englishTranslations)
    }

    // 2. Normalized query (without tags)
    if (normalized && normalized !== query && !variants.includes(normalized)) {
        variants.push(normalized)
    }

    // 3. Original query (might work if user entered it correctly)
    if (!variants.includes(query)) {
        variants.push(query)
    }

    // 4. If query has season info, try without it
    const seasonMatch = query.match(/S(\d{1,2})/i) || query.match(/Season\s*(\d+)/i)
    if (seasonMatch) {
        const withoutSeason = normalized
            .replace(/S\d{1,2}/i, '')
            .replace(/Season\s*\d+/i, '')
            .replace(/\s+/g, ' ')
            .trim()
        if (withoutSeason && !variants.includes(withoutSeason)) {
            // Also try English translation without season
            const enWithoutSeason = translateRuToEn(withoutSeason)
            for (const tr of enWithoutSeason) {
                if (!variants.includes(tr)) {
                    variants.push(tr)
                }
            }
            variants.push(withoutSeason)
        }
    }

    // Remove duplicates while preserving order
    return [...new Set(variants)]
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÔøΩüì∫ Enhanced Title Parser
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export function parseTorrentTitle(title, sizeFromAPI = 0) {
    const result = {
        title: '',
        season: null,
        episode: 0,
        resolution: '',
        group: '',
        qualityScore: 0,
        sizeGB: sizeFromAPI,
        isHevc: false,
        isBatch: false,
        isRepack: false,
        _raw: title
    }

    let cleanTitle = title.trim()

    // Detect REPACK/PROPER
    result.isRepack = FIX_KEYWORDS.test(cleanTitle)

    // Batch detection
    result.isBatch = BATCH_KEYWORDS.test(cleanTitle)

    // Quality score extraction
    if (/2160p|4k|uhd/i.test(cleanTitle)) {
        result.qualityScore = 4
        result.resolution = '2160p'
    } else if (/1080p/i.test(cleanTitle)) {
        result.qualityScore = 3
        result.resolution = '1080p'
    } else if (/720p/i.test(cleanTitle)) {
        result.qualityScore = 2
        result.resolution = '720p'
    } else if (/480p/i.test(cleanTitle)) {
        result.qualityScore = 1
        result.resolution = '480p'
    }

    // HEVC detection
    result.isHevc = /x265|hevc/i.test(cleanTitle)

    // Size extraction
    if (!result.sizeGB) {
        const sizeMatch = cleanTitle.match(/(\d+(?:\.\d+)?)\s*(GB|GiB)/i)
        if (sizeMatch) {
            result.sizeGB = parseFloat(sizeMatch[1])
        }
    }

    // Release group extraction
    const groupBracketMatch = cleanTitle.match(/^\[([^\]]+)\]/)
    const groupDashMatch = cleanTitle.match(/-([A-Za-z0-9]+)(?:\.[a-z]{2,4})?$/)
    if (groupBracketMatch) {
        result.group = groupBracketMatch[1]
    } else if (groupDashMatch) {
        result.group = groupDashMatch[1]
    }

    // Pattern 1: SxxExx
    const sxxexxMatch = cleanTitle.match(/[\.\s]S(\d{1,2})E(\d{1,3})/i)
    if (sxxexxMatch) {
        result.season = parseInt(sxxexxMatch[1], 10)
        result.episode = parseInt(sxxexxMatch[2], 10)
        const titlePart = cleanTitle.split(/S\d{1,2}E\d{1,3}/i)[0]
        result.title = cleanTitlePart(titlePart)
        return result
    }

    // Pattern 2: Season X Episode Y
    const verboseMatch = cleanTitle.match(/Season\s*(\d+)\s*Episode\s*(\d+)/i)
    if (verboseMatch) {
        result.season = parseInt(verboseMatch[1], 10)
        result.episode = parseInt(verboseMatch[2], 10)
        const titlePart = cleanTitle.split(/Season/i)[0]
        result.title = cleanTitlePart(titlePart)
        return result
    }

    // Pattern 3: Anime style
    const animeMatch = cleanTitle.match(/(.+?)\s*[-‚Äì]\s*(\d{1,4})(?:v\d)?(?:\s|$|\[|\()/)
    if (animeMatch) {
        result.episode = parseInt(animeMatch[2], 10)
        result.title = cleanTitlePart(animeMatch[1])
        return result
    }

    // Pattern 4: Episode keyword
    const epMatch = cleanTitle.match(/(.+?)\s*(?:Episode|Ep\.?|E)\s*(\d{1,3})/i)
    if (epMatch) {
        result.episode = parseInt(epMatch[2], 10)
        result.title = cleanTitlePart(epMatch[1])
        return result
    }

    // Pattern 5: Simple number
    const simpleNumberMatch = cleanTitle.match(/(.+?)\s+(\d{1,3})\s+(?:\d{3,4}p|\[|$)/i)
    if (simpleNumberMatch) {
        result.episode = parseInt(simpleNumberMatch[2], 10)
        result.title = cleanTitlePart(simpleNumberMatch[1])
        return result
    }

    // Generic fallback
    result.title = cleanTitlePart(cleanTitle)
    return result
}

function cleanTitlePart(title) {
    return title
        .replace(/^\[([^\]]+)\]\s*/, '')
        .replace(/\./g, ' ')
        .replace(/\s*\([^)]+\)\s*/g, ' ')
        .replace(/\s*\[[^\]]+\]\s*/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üîç Enhanced Rule Matching
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function matchesRule(parsed, rule) {
    // 1. Blacklist Check
    const globalBlacklist = db.data.autoDownloadSettings?.globalBlacklist || GLOBAL_BLACKLIST
    const ruleBlacklist = rule.excludeKeywords || []
    const combinedBlacklist = [...globalBlacklist, ...ruleBlacklist]

    if (combinedBlacklist.length > 0) {
        const lowerTitle = parsed._raw.toLowerCase()
        const blockedKeyword = combinedBlacklist.find(keyword =>
            lowerTitle.includes(keyword.toLowerCase())
        )
        if (blockedKeyword) {
            if (DEBUG) log.debug('‚ùå Excluded by keyword', { keyword: blockedKeyword })
            return false
        }
    }

    // 2. Batch detection
    if (parsed.isBatch && rule.lastEpisode > 0) {
        if (DEBUG) log.debug('‚ùå Batch detected, skipping')
        return false
    }

    // 3. Block REPACKs if no original downloaded yet
    if (parsed.isRepack && rule.lastEpisode === 0) {
        if (DEBUG) log.debug('‚ùå REPACK not allowed (no original downloaded yet)', { episode: parsed.episode })
        return false
    }

    // 4. Title fuzzy matching
    const queryLower = rule.query.toLowerCase()
    const titleLower = parsed.title.toLowerCase()

    const hasExactMatch =
        queryLower.length > 3 &&
        (titleLower.includes(queryLower) || queryLower.includes(titleLower))

    if (!hasExactMatch) {
        const queryWords = queryLower.split(/\s+/).filter(w => w.length > 2)
        const titleWords = titleLower.split(/\s+/).filter(w => w.length > 2)

        if (queryWords.length === 0) {
            if (DEBUG) log.debug('‚ùå Query too short')
            return false
        }

        const matchCount = queryWords.filter(qw =>
            titleWords.some(tw => tw.includes(qw) || qw.includes(tw))
        ).length

        const minMatches = Math.max(1, Math.ceil(queryWords.length * 0.5))

        if (matchCount < minMatches) {
            if (DEBUG) log.debug('‚ùå Title mismatch')
            return false
        }
    }

    // 5. Quality/Resolution Filters
    if (rule.quality && rule.quality !== 'any') {
        const requiredQuality = {
            '4k': 4, '2160p': 4,
            '1080p': 3, '720p': 2, '480p': 1
        }[rule.quality.toLowerCase()]

        // Strict mode: Allow equal or better quality
        if (rule.strictQuality && requiredQuality) {
            if (parsed.qualityScore < requiredQuality) {
                if (DEBUG) log.debug('‚ùå Strict quality filter (below minimum)', {
                    required: rule.quality,
                    requiredScore: requiredQuality,
                    gotScore: parsed.qualityScore
                })
                return false
            }
        }
    }

    // 6. Resolution filter (strict: if rule requires resolution, torrent must have it)
    if (rule.resolution && rule.resolution.trim() !== '') {
        if (!parsed.resolution) {
            if (DEBUG) log.debug('‚ùå Resolution required but not found')
            return false
        }
        if (!parsed.resolution.includes(rule.resolution.toLowerCase())) {
            if (DEBUG) log.debug('‚ùå Resolution mismatch')
            return false
        }
    }

    // 7. Group Filter
    if (rule.group && rule.group.trim() !== '') {
        if (parsed.group && !parsed.group.toLowerCase().includes(rule.group.toLowerCase())) {
            if (DEBUG) log.debug('‚ùå Group mismatch')
            return false
        }
    }

    // 8. Season Filter
    if (rule.season && rule.season > 0) {
        if (parsed.season === null) {
            if (DEBUG) log.debug('‚ùå Season required but not parsed')
            return false
        }
        if (parsed.season !== rule.season) {
            if (DEBUG) log.debug('‚ùå Season mismatch')
            return false
        }
    }

    // 9. Episode Check with Smart REPACK Handling
    if (parsed.episode > 0 && parsed.episode <= rule.lastEpisode) {
        if (parsed.isRepack) {
            const timestampKey = `${rule.id}_${parsed.episode}`
            const lastDownloadTime = db.data.autoDownloadTimestamps?.[timestampKey] || 0
            const hoursSinceDownload = (Date.now() - lastDownloadTime) / (1000 * 60 * 60)

            if (hoursSinceDownload < REPACK_WINDOW_HOURS) {
                if (DEBUG) log.debug('‚úÖ REPACK allowed (within window)', {
                    hoursSince: Math.round(hoursSinceDownload)
                })
                return true
            } else {
                if (DEBUG) log.debug('‚ùå REPACK too old', {
                    hoursSince: Math.round(hoursSinceDownload)
                })
                return false
            }
        }

        if (DEBUG) log.debug('‚ùå Episode too old')
        return false
    }

    if (parsed.episode === 0 && rule.lastEpisode > 0 && !parsed.isBatch) {
        if (DEBUG) log.debug('‚ö†Ô∏è Unknown episode detected, allowing')
    }

    return true
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üèÜ Smart Candidate Selection
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function selectBestCandidate(candidates, rule) {
    if (candidates.length === 0) return null
    if (candidates.length === 1) return candidates[0]

    candidates.sort((a, b) => {
        // 1. Quality
        if (b.parsed.qualityScore !== a.parsed.qualityScore) {
            return b.parsed.qualityScore - a.parsed.qualityScore
        }
        // 2. HEVC Preference
        if (rule.preferHevc) {
            if (b.parsed.isHevc !== a.parsed.isHevc) {
                return (b.parsed.isHevc ? 1 : 0) - (a.parsed.isHevc ? 1 : 0)
            }
        }
        // 3. Size
        if (b.parsed.sizeGB !== a.parsed.sizeGB) {
            return b.parsed.sizeGB - a.parsed.sizeGB
        }
        // 4. Non-HEVC Fallback
        if (!rule.preferHevc) {
            if (a.parsed.isHevc !== b.parsed.isHevc) {
                return (a.parsed.isHevc ? 1 : 0) - (b.parsed.isHevc ? 1 : 0)
            }
        }
        return 0
    })

    return candidates[0]
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üöÄ Main Check Logic
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export async function checkRules() {
    await db.read()

    const settings = db.data.autoDownloadSettings || { enabled: false }
    const rules = db.data.autoDownloadRules || []

    if (!settings.enabled || rules.length === 0) {
        return { checked: 0, downloaded: 0, errors: 0 }
    }

    db.data.autoDownloadTimestamps ||= {}

    log.info('üîç Starting auto-download check', { rulesCount: rules.length })

    let downloaded = 0
    let errors = 0
    let totalTorrentsChecked = 0
    const downloadedHashes = new Set(db.data.autoDownloadHistory || [])

    for (const rule of rules) {
        if (!rule.enabled) continue

        try {
            // Generate query variants (normalized, original, without season)
            const queryVariants = generateQueryVariants(rule.query)

            log.info('üîç Checking rule', {
                query: rule.query,
                variants: queryVariants,
                lastEpisode: rule.lastEpisode
            })

            // Try each query variant until we get results
            let results = []
            let usedQuery = null

            for (const variant of queryVariants) {
                log.info('üîé Trying query variant', { variant })
                const searchResult = await aggregatorSearch(variant)

                if (searchResult.results && searchResult.results.length > 0) {
                    results = searchResult.results
                    usedQuery = variant
                    log.info('‚úÖ Found results with variant', {
                        variant,
                        count: results.length,
                        providers: Object.keys(searchResult.providers || {})
                    })
                    break
                }

                // Small delay between variants to avoid rate limiting
                await new Promise(r => setTimeout(r, 1000))
            }

            if (results.length === 0) {
                log.warn('‚ö†Ô∏è No results found for any variant', {
                    originalQuery: rule.query,
                    triedVariants: queryVariants
                })
                continue
            }

            log.info('üì¶ Search results', { usedQuery, count: results.length })

            // Group candidates
            const episodeCandidates = new Map()
            let unknownEpisodeCounter = 0

            for (const torrent of results) {
                totalTorrentsChecked++

                const magnetHash = extractHash(torrent.magnet)
                if (magnetHash && downloadedHashes.has(magnetHash)) {
                    if (DEBUG) log.debug('‚è≠Ô∏è Already downloaded')
                    continue
                }

                const sizeGB = torrent.Size ? parseFloat(torrent.Size) / (1024 ** 3) : 0
                const parsed = parseTorrentTitle(torrent.title, sizeGB)

                if (matchesRule(parsed, rule)) {
                    let episodeKey
                    if (parsed.episode > 0) {
                        episodeKey = `e${parsed.episode}`
                    } else {
                        episodeKey = `unknown_${unknownEpisodeCounter++}`
                    }

                    if (!episodeCandidates.has(episodeKey)) {
                        episodeCandidates.set(episodeKey, [])
                    }
                    episodeCandidates.get(episodeKey).push({ torrent, parsed })
                }
            }

            // Process best candidates
            let downloadsThisRule = 0

            for (const [episodeKey, candidates] of episodeCandidates.entries()) {
                if (downloadsThisRule >= MAX_DOWNLOADS_PER_RULE) break

                const best = selectBestCandidate(candidates, rule)
                if (!best) continue

                log.info('üéØ MATCH FOUND', {
                    title: best.parsed.title,
                    episode: best.parsed.episode,
                    repack: best.parsed.isRepack
                })

                try {
                    await addTorrent(best.torrent.magnet)
                    downloaded++
                    downloadsThisRule++

                    // üöÄ ATOMIC WRITE BLOCK
                    let dbChanged = false

                    // 1. Update lastEpisode (Only for originals)
                    // Prevents REPACKs from incorrectly advancing the episode counter
                    if (best.parsed.episode > 0 && !best.parsed.isRepack) {
                        rule.lastEpisode = Math.max(rule.lastEpisode, best.parsed.episode)
                        dbChanged = true
                    }

                    // 2. Update Timestamp (Only for originals or safety fill)
                    if (best.parsed.episode > 0 && !best.parsed.isRepack) {
                        const timestampKey = `${rule.id}_${best.parsed.episode}`
                        if (!db.data.autoDownloadTimestamps[timestampKey]) {
                            db.data.autoDownloadTimestamps[timestampKey] = Date.now()
                            dbChanged = true
                        }
                    }

                    // 3. Update History
                    const magnetHash = extractHash(best.torrent.magnet)
                    if (magnetHash) {
                        downloadedHashes.add(magnetHash)
                        db.data.autoDownloadHistory = [...downloadedHashes].slice(-500)
                        dbChanged = true
                    }

                    // 4. Perform Atomic Write
                    if (dbChanged) {
                        await safeWrite(db)
                    }

                    log.info('‚úÖ Download started')
                } catch (err) {
                    log.error('‚ùå Failed to add torrent', { error: err.message })
                    errors++
                }
            }

        } catch (err) {
            log.error('‚ùå Rule check error', { error: err.message })
            errors++
        }
    }

    log.info('‚úÖ Check complete', { downloaded, errors, torrentsChecked: totalTorrentsChecked })
    return { checked: rules.length, downloaded, errors }
}

/**
 * Extract infohash from magnet link
 * Supports both hex (40 chars) and base32 (32 chars) formats
 */
function extractHash(magnet) {
    if (!magnet) return null
    // Try hex format first (40 chars)
    const hexMatch = magnet.match(/urn:btih:([a-fA-F0-9]{40})/i)
    if (hexMatch) return hexMatch[1].toLowerCase()
    // Try base32 format (32 chars)
    const base32Match = magnet.match(/urn:btih:([A-Z2-7]{32})/i)
    if (base32Match) return base32Match[1].toLowerCase()
    return null
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üìã Rule Management API
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export async function getRules() {
    await db.read()
    return {
        settings: db.data.autoDownloadSettings || {
            enabled: false,
            intervalMinutes: 30,
            globalBlacklist: GLOBAL_BLACKLIST
        },
        rules: db.data.autoDownloadRules || []
    }
}

export async function addRule(rule) {
    await db.read()
    db.data.autoDownloadRules ||= []

    const newRule = {
        id: Date.now(),
        query: rule.query,
        quality: rule.quality || '',
        strictQuality: rule.strictQuality || false,
        preferHevc: rule.preferHevc || false,
        excludeKeywords: rule.excludeKeywords || [],
        resolution: rule.resolution || '',
        group: rule.group || '',
        season: rule.season || 0,
        lastEpisode: rule.lastEpisode || 0,
        enabled: true,
        createdAt: Date.now()
    }

    db.data.autoDownloadRules.push(newRule)
    await safeWrite(db)
    return newRule
}

export async function updateRule(id, updates) {
    await db.read()
    const rules = db.data.autoDownloadRules || []
    const index = rules.findIndex(r => r.id === id)

    if (index === -1) throw new Error('Rule not found')

    rules[index] = { ...rules[index], ...updates }
    await safeWrite(db)
    return rules[index]
}

export async function deleteRule(id) {
    await db.read()
    const before = db.data.autoDownloadRules?.length || 0
    db.data.autoDownloadRules = (db.data.autoDownloadRules || []).filter(r => r.id !== id)

    if (db.data.autoDownloadRules.length < before) {
        await safeWrite(db)
        return true
    }
    return false
}

export async function updateSettings(settings) {
    await db.read()
    db.data.autoDownloadSettings = {
        ...db.data.autoDownloadSettings,
        ...settings
    }
    await safeWrite(db)
    return db.data.autoDownloadSettings
}

```

---

### server/db.js

```js
import { Low } from 'lowdb'
import { JSONFile } from 'lowdb/node'
import { safeWrite } from './dbQueue.js'

// Initialize DB
const defaultData = {
    serverStatus: 'ok',        // 'ok' | 'degraded' | 'error' | 'circuit_open'
    lastStateChange: Date.now(),
    storageFailures: 0,
    progress: {},
    seenFiles: {},             // { [infoHash]: [fileName1, fileName2, ...] } - for new episode detection
    torrents: [],              // Array of { magnet, name, addedAt } for persistence
    // Auto-Downloader
    autoDownloadSettings: {
        enabled: false,
        intervalMinutes: 720  // 12 hours
    },
    autoDownloadRules: [],     // [{ id, query, resolution, group, season, lastEpisode, enabled }]
    autoDownloadHistory: []    // Array of magnet hashes to prevent duplicates
}
const dbPath = process.env.DB_PATH || 'db.json'
const adapter = new JSONFile(dbPath)
const db = new Low(adapter, defaultData)

// Ensure DB is ready and migrate existing data
await db.read()

// Merge defaults with existing data (handles DB migrations)
db.data = { ...defaultData, ...db.data }

// Ensure nested objects are initialized
db.data.progress ||= {}
db.data.seenFiles ||= {}
db.data.autoDownloadSettings ||= { enabled: false, intervalMinutes: 30 }
db.data.autoDownloadRules ||= []
db.data.autoDownloadHistory ||= []

await db.write()

export { db, safeWrite }


```

---

### server/dbQueue.js

```js
/**
 * DB Write Queue - prevents race conditions in LowDB writes
 * 
 * LowDB rewrites entire JSON file on each write.
 * Concurrent writes can corrupt the file.
 * This module serializes all writes through a Promise chain.
 */

let writeQueue = Promise.resolve()
let pendingWrites = 0

/**
 * Safe write to database with serialization
 * @param {object} db - LowDB instance
 * @returns {Promise} - resolves when write is complete
 */
export function safeWrite(db) {
    pendingWrites++

    writeQueue = writeQueue
        .then(() => db.write())
        .then(() => {
            pendingWrites--
        })
        .catch((err) => {
            pendingWrites--
            console.error('[DB] Write failed:', err.message)
            // Don't break the chain - allow subsequent writes
        })

    return writeQueue
}

/**
 * Get number of pending writes (for debugging/monitoring)
 */
export function getPendingWrites() {
    return pendingWrites
}

```

---

### server/index.js

```js
// Security: SSL validation enabled globally (see jacred.js for targeted exceptions)

import express from 'express'
import cors from 'cors'
import path from 'path'
import { fileURLToPath } from 'url'
import dotenv from 'dotenv'
import fs from 'fs'
import fsPromises from 'fs/promises'
import { addTorrent, getAllTorrents, getTorrent, getRawTorrent, removeTorrent, restoreTorrents, prioritizeFile, readahead, boostTorrent, destroyAllTorrents, setSpeedMode, getActiveTorrentsCount, getFrozenTorrentsCount } from './torrent.js'
import { db, safeWrite } from './db.js'
import { startWatchdog, stopWatchdog, getServerState } from './watchdog.js'
import { LagMonitor } from './utils/lag-monitor.js'
import { getRules, addRule, updateRule, deleteRule, updateSettings, checkRules } from './autodownloader.js'

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üìä Lag Monitor v2.3: Detect event loop blocking
// Auto-detects production mode for adaptive thresholds
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const lagMonitor = new LagMonitor()  // v2.3: auto-detects prod/dev
lagMonitor.start()

dotenv.config()

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const app = express()
const PORT = process.env.PORT || 3000

// Middleware
app.use(cors())
app.use(express.json())

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üõ°Ô∏è Rate Limiting (Zero-Dependency)
// 30 requests per minute per IP for /api/* routes
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const rateLimitMap = new Map()
const RATE_LIMIT_WINDOW_MS = 60 * 1000 // 1 minute
const RATE_LIMIT_MAX = 60 // üî• v2.3: increased from 30 for diagnostics polling

// ‚úÖ FIX: –°–æ—Ö—Ä–∞–Ω—è–µ–º ID –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –ø—Ä–∏ shutdown
let rateLimitCleanupId = null

// Cleanup old entries every 5 minutes
rateLimitCleanupId = setInterval(() => {
    const now = Date.now()
    for (const [ip, data] of rateLimitMap.entries()) {
        if (now - data.windowStart > RATE_LIMIT_WINDOW_MS * 2) {
            rateLimitMap.delete(ip)
        }
    }
}, 5 * 60 * 1000)

app.use('/api/', (req, res, next) => {
    const ip = req.ip || req.connection.remoteAddress || 'unknown'
    const now = Date.now()

    let entry = rateLimitMap.get(ip)
    if (!entry || now - entry.windowStart > RATE_LIMIT_WINDOW_MS) {
        // New window
        entry = { windowStart: now, count: 1 }
        rateLimitMap.set(ip, entry)
    } else {
        entry.count++
    }

    // Set rate limit headers
    res.set('X-RateLimit-Limit', RATE_LIMIT_MAX)
    res.set('X-RateLimit-Remaining', Math.max(0, RATE_LIMIT_MAX - entry.count))
    res.set('X-RateLimit-Reset', Math.ceil((entry.windowStart + RATE_LIMIT_WINDOW_MS) / 1000))

    if (entry.count > RATE_LIMIT_MAX) {
        console.warn(`[RateLimit] Too many requests from ${ip}: ${entry.count}`)
        return res.status(429).json({
            error: 'Too many requests',
            retryAfter: Math.ceil((entry.windowStart + RATE_LIMIT_WINDOW_MS - now) / 1000)
        })
    }

    next()
})

// DEBUG: Log all non-static requests
app.use((req, res, next) => {
    if (!req.url.match(/\.(js|css|png|jpg|ico|map)$/)) {
        console.log(`[HTTP] ${req.method} ${req.url}`)
    }
    next()
})

// Serve static frontend
const distPath = path.join(__dirname, '../client/dist')
app.use(express.static(distPath))

// API: Health Check (lightweight)
app.get('/api/health', (req, res) => {
    const state = getServerState()
    res.json({
        serverStatus: state.serverStatus,
        lastStateChange: state.lastStateChange
    })
})

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üè• v2.3.3: Health Endpoint for monitoring systems
// Compatible with: Home Assistant, Uptime Robot, Kubernetes
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
app.get('/health', (req, res) => {
    const state = getServerState()
    const memUsage = process.memoryUsage()
    const ramMB = Math.round(memUsage.rss / 1024 / 1024)

    // Determine health status
    const isHealthy = state.serverStatus === 'ok'
    const isDegraded = state.serverStatus === 'degraded'
    const isUnhealthy = state.serverStatus === 'circuit_open' || state.serverStatus === 'error'

    const healthData = {
        status: isHealthy ? 'healthy' : (isDegraded ? 'degraded' : 'unhealthy'),
        timestamp: new Date().toISOString(),
        uptime: Math.round(process.uptime()),
        version: '2.3.3',
        checks: {
            memory: {
                status: ramMB < 800 ? 'pass' : (ramMB < 1000 ? 'warn' : 'fail'),
                rss_mb: ramMB,
                heap_mb: Math.round(memUsage.heapUsed / 1024 / 1024)
            },
            storage: {
                status: state.serverStatus === 'circuit_open' ? 'fail' : 'pass',
                failures: state.storageFailures || 0
            },
            torrents: {
                active: getActiveTorrentsCount(),
                frozen: getFrozenTorrentsCount()
            }
        }
    }

    // Return appropriate HTTP status
    if (isUnhealthy) {
        res.status(503).json(healthData)
    } else if (isDegraded) {
        res.status(200).json(healthData) // 200 with degraded status
    } else {
        res.status(200).json(healthData)
    }
})

// API: Lag Stats (enhanced performance monitoring v2.3)
app.get('/api/lag-stats', (req, res) => {
    const memUsage = process.memoryUsage()
    const stats = lagMonitor.getStats()

    res.json({
        ...stats,
        // üî• v2.3: Enhanced server diagnostics
        server: {
            uptime: Math.round(process.uptime()),
            nodeVersion: process.version,
            platform: process.platform,
            pid: process.pid,
            ram: {
                rss: Math.round(memUsage.rss / 1024 / 1024),
                heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024),
                heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024),
                external: Math.round(memUsage.external / 1024 / 1024)
            },
            torrents: {
                active: getActiveTorrentsCount(),
                frozen: getFrozenTorrentsCount()
            }
        }
    })
})

// API: Speed Mode (eco/balanced/turbo)
app.post('/api/speed-mode', (req, res) => {
    const { mode } = req.body
    if (!['eco', 'balanced', 'turbo'].includes(mode)) {
        return res.status(400).json({ error: 'Invalid mode. Use: eco, balanced, or turbo' })
    }
    const result = setSpeedMode(mode)
    res.json(result)
})

// API: Status (with server state)
app.get('/api/status', (req, res) => {
    const state = getServerState()

    // Return 503 with Retry-After for critical states
    if (state.serverStatus === 'circuit_open' || state.serverStatus === 'error') {
        res.set('Retry-After', '300') // 5 minutes
        return res.status(503).json({
            serverStatus: state.serverStatus,
            lastStateChange: state.lastStateChange,
            torrents: []
        })
    }

    const torrents = getAllTorrents()
    const status = torrents.map(t => ({
        infoHash: t.infoHash,
        name: t.name,
        progress: t.progress,
        isReady: t.isReady,  // ‚úÖ Fix: –ø–µ—Ä–µ–¥–∞—ë–º isReady –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ UI
        downloaded: t.downloaded,
        totalSize: t.totalSize,
        downloadSpeed: t.downloadSpeed,
        numPeers: t.numPeers,
        eta: t.eta,
        files: t.files.map(f => ({
            name: f.name,
            length: f.length,
            index: f.index
        }))
    }))

    res.json({
        serverStatus: state.serverStatus,
        lastStateChange: state.lastStateChange,
        torrents: status
    })
})

// API: TMDB Proxy with DoH bypass
import { smartFetch, insecureAgent } from './utils/doh.js'

const TMDB_API_KEY = process.env.TMDB_API_KEY || ''

app.get('/api/tmdb/search', async (req, res) => {
    const { query } = req.query
    if (!query) return res.status(400).json({ error: 'Query required' })

    try {
        const url = `https://api.themoviedb.org/3/search/multi?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}&language=ru-RU`
        const response = await smartFetch(url)
        res.json(response.data)
    } catch (err) {
        console.error('[TMDB] Search error:', err.message)
        res.status(502).json({ error: 'TMDB API unavailable', details: err.message })
    }
})

app.get('/api/tmdb/image/:size/:path', async (req, res) => {
    const { size, path: imagePath } = req.params
    try {
        const url = `https://image.tmdb.org/t/p/${size}/${imagePath}`
        const response = await smartFetch(url, { responseType: 'arraybuffer' })
        res.set('Content-Type', response.headers['content-type'] || 'image/jpeg')
        res.set('Cache-Control', 'public, max-age=86400')
        res.send(response.data)
    } catch (err) {
        console.error('[TMDB] Image error:', err.message)
        res.status(502).send('Image unavailable')
    }
})
// API: Jacred Torrent Search (like Lampa)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

import { searchJacred, getMagnetFromJacred } from './jacred.js'

// Search torrents via Jacred
app.get('/api/rutracker/search', async (req, res) => {
    const { query } = req.query
    if (!query) {
        return res.status(400).json({ error: 'Query required' })
    }

    console.log(`[Jacred] Searching: ${query}`)
    const result = await searchJacred(query)
    res.json(result)
})

// Get magnet link (already in search results, but keeping for compatibility)
app.get('/api/rutracker/magnet/:topicId', async (req, res) => {
    const { topicId } = req.params
    // topicId is actually the magnet URL for Jacred
    const result = await getMagnetFromJacred(decodeURIComponent(topicId))
    res.json(result)
})

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Debug API: View and manage persisted torrents in DB
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// View all torrents saved in db.json
app.get('/api/db/torrents', async (req, res) => {
    await db.read()
    const torrents = db.data.torrents || []
    res.json({
        count: torrents.length,
        torrents: torrents.map(t => ({
            name: t.name,
            addedAt: t.addedAt,
            magnetPreview: t.magnet.substring(0, 80) + '...'
        }))
    })
})

// Force remove a torrent from DB by partial hash match
app.delete('/api/db/torrents/:hash', async (req, res) => {
    const { hash } = req.params
    await db.read()

    const before = db.data.torrents?.length || 0
    const hashLower = hash.toLowerCase()

    db.data.torrents = (db.data.torrents || []).filter(t => {
        const magnetLower = t.magnet.toLowerCase()
        return !magnetLower.includes(hashLower)
    })

    const removed = before - db.data.torrents.length

    if (removed > 0) {
        await safeWrite(db)
        console.log(`[DB API] Force removed ${removed} torrent(s) by hash: ${hash}`)
        res.json({ success: true, removed })
    } else {
        res.status(404).json({ error: 'No matching torrent found in DB', hash })
    }
})

// Clear ALL torrents from DB (nuclear option)
app.delete('/api/db/torrents', async (req, res) => {
    await db.read()
    const count = db.data.torrents?.length || 0
    db.data.torrents = []
    await safeWrite(db)
    console.log(`[DB API] Cleared ALL ${count} torrents from DB`)
    res.json({ success: true, cleared: count })
})

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üì∫ Auto-Downloader API: Manage auto-download rules
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Get all rules and settings
app.get('/api/autodownload/rules', async (req, res) => {
    try {
        const data = await getRules()
        res.json(data)
    } catch (err) {
        res.status(500).json({ error: err.message })
    }
})

// Add new rule
app.post('/api/autodownload/rules', async (req, res) => {
    const { query, resolution, group, season, lastEpisode } = req.body
    if (!query) {
        return res.status(400).json({ error: 'Query (series name) is required' })
    }
    try {
        const rule = await addRule({ query, resolution, group, season, lastEpisode })
        res.json(rule)
    } catch (err) {
        res.status(500).json({ error: err.message })
    }
})

// Update rule
app.put('/api/autodownload/rules/:id', async (req, res) => {
    const id = parseInt(req.params.id, 10)
    try {
        const rule = await updateRule(id, req.body)
        res.json(rule)
    } catch (err) {
        res.status(err.message === 'Rule not found' ? 404 : 500).json({ error: err.message })
    }
})

// Delete rule
app.delete('/api/autodownload/rules/:id', async (req, res) => {
    const id = parseInt(req.params.id, 10)
    const deleted = await deleteRule(id)
    if (deleted) {
        res.json({ success: true })
    } else {
        res.status(404).json({ error: 'Rule not found' })
    }
})

// Update global settings (enable/disable, interval)
app.put('/api/autodownload/settings', async (req, res) => {
    try {
        const settings = await updateSettings(req.body)
        res.json(settings)
    } catch (err) {
        res.status(500).json({ error: err.message })
    }
})

// Trigger manual check
app.post('/api/autodownload/check', async (req, res) => {
    try {
        const result = await checkRules()
        res.json(result)
    } catch (err) {
        res.status(500).json({ error: err.message })
    }
})

// API: Generate M3U Playlist for Video Files
// Helper: sanitize filename for M3U metadata (remove newlines and control chars)
const sanitizeM3U = (str) => str.replace(/[\r\n\x00-\x1f]/g, ' ').trim()

app.get('/playlist.m3u', (req, res) => {
    // 1. Determine Host (Synology IP or Localhost)
    const host = req.get('host') || `localhost:${PORT}`
    const protocol = req.protocol || 'http'

    // 2. Get All Torrents
    const torrents = getAllTorrents()

    let m3u = '#EXTM3U\n'
    const videoExtensions = ['.mp4', '.mkv', '.avi', '.webm', '.mov', '.mpg', '.mpeg']

    // 3. Filter & Generate
    for (const torrent of torrents) {
        if (!torrent.files) continue;

        for (const file of torrent.files) {
            const ext = path.extname(file.name).toLowerCase()
            if (videoExtensions.includes(ext)) {
                // Metadata for player
                // Use -1 for live/unknown duration, or try to guess if available
                m3u += `#EXTINF:-1,${sanitizeM3U(file.name)}\n`

                // Stream URL: http://<NAS_IP>:3000/stream/<HASH>/<INDEX>
                m3u += `${protocol}://${host}/stream/${torrent.infoHash}/${file.index}\n`
            }
        }
    }

    res.set('Content-Type', 'audio/x-mpegurl')
    res.set('Content-Disposition', 'attachment; filename="playlist.m3u"')
    res.send(m3u)
})

// API: Add Torrent
app.post('/api/add', async (req, res) => {
    const { magnet } = req.body
    if (!magnet) return res.status(400).json({ error: 'Magnet URI required' })

    try {
        const torrent = await addTorrent(magnet)
        res.json({ infoHash: torrent.infoHash, name: torrent.name })
    } catch (err) {
        res.status(500).json({ error: err.message })
    }
})

// Map of MIME types
const mimeMap = {
    '.mp4': 'video/mp4',
    '.mkv': 'video/x-matroska',
    '.webm': 'video/webm',
    '.avi': 'video/avi',
    '.mov': 'video/quicktime',
    '.mpg': 'video/mpeg',
    '.mpeg': 'video/mpeg'
}

// API: Remove Torrent (with File Hygiene)
app.delete('/api/delete/:infoHash', async (req, res) => {
    const { infoHash } = req.params
    const torrent = getTorrent(infoHash) // Get info BEFORE deletion

    const success = removeTorrent(infoHash)

    if (success) {
        // üî• PHYSICAL DELETION (FILE HYGIENE - ASYNC) üî•
        if (torrent && torrent.name) {
            const downloadPath = process.env.DOWNLOAD_PATH || './downloads'
            const fullPath = path.join(downloadPath, torrent.name)

            // Fire-and-forget async deletion to avoid blocking the server
            fsPromises.rm(fullPath, { recursive: true, force: true })
                .then(() => console.log(`[File Hygiene] Successfully removed: ${fullPath}`))
                .catch(e => console.error(`[Delete Error] Could not remove ${fullPath}: ${e.message}`))
        }
        res.json({ success: true, message: 'Deletion started asynchronously' })
    } else {
        res.status(404).json({ error: 'Torrent not found' })
    }
})

// API: Stream
app.get('/stream/:infoHash/:fileIndex', async (req, res) => {
    const { infoHash, fileIndex } = req.params
    const range = req.headers.range

    // üî• ACTIVATE TURBO MODE when user starts watching
    boostTorrent(infoHash)

    // Use raw engine to access createReadStream
    const engine = getRawTorrent(infoHash)
    if (!engine) return res.status(404).send('Torrent not found')

    const file = engine.files?.[fileIndex]
    if (!file) return res.status(404).send('File not found')

    // Smart Priority: Prioritize this file's first chunks for instant playback
    prioritizeFile(infoHash, parseInt(fileIndex, 10))

    // Detect Content-Type
    const ext = path.extname(file.name).toLowerCase()
    const contentType = mimeMap[ext] || 'application/octet-stream'

    // Note: Download path check moved to startup (cached)

    if (!range) {
        const head = {
            'Content-Length': file.length,
            'Content-Type': contentType,
        }
        res.writeHead(200, head)
        file.createReadStream().pipe(res)
    } else {
        const parts = range.replace(/bytes=/, "").split("-")
        const start = parseInt(parts[0], 10)
        const end = parts[1] ? parseInt(parts[1], 10) : file.length - 1
        const chunksize = (end - start) + 1

        // üî• READAHEAD: Prioritize chunks starting from seek position
        // This ensures smooth playback after seeking
        readahead(infoHash, parseInt(fileIndex, 10), start)

        // Smart Progress Tracking
        const duration = parseFloat(req.query.duration) || 0
        const progressTime = duration > 0 ? (start / file.length) * duration : 0

        // üî• Debounced DB save (fire-and-forget, no await)
        const trackKey = `${infoHash}_${fileIndex}`
        const now = Date.now()
        const lastUpdate = db.data.progress[trackKey]?.timestamp || 0

        if (now - lastUpdate > 10000) {
            db.data.progress[trackKey] = {
                timestamp: now,
                position: start,
                progressTime: progressTime,
                percentage: (start / file.length) * 100
            }
            // Fire-and-forget: don't block streaming
            safeWrite(db)
        }

        const head = {
            'Content-Range': `bytes ${start}-${end}/${file.length}`,
            'Accept-Ranges': 'bytes',
            'Content-Length': chunksize,
            'Content-Type': contentType,
        }

        res.writeHead(206, head)

        // CRITICAL: Cleanup stream on client disconnect to prevent resource leaks
        const stream = file.createReadStream({ start, end })

        // ‚úÖ FIX: –§—É–Ω–∫—Ü–∏—è –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –æ—á–∏—Å—Ç–∫–∏ —Å—Ç—Ä–∏–º–∞
        const cleanup = () => {
            if (!stream.destroyed) {
                stream.destroy()
            }
        }

        // üî• v2.3: Handle stream errors to prevent hanging responses
        stream.on('error', (err) => {
            console.error(`[Stream] Error for ${infoHash}/${fileIndex}:`, err.message)
            cleanup()
            if (!res.headersSent) {
                res.status(500).send('Stream error')
            }
        })

        // ‚úÖ FIX: –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–æ–º
        res.on('close', cleanup)
        res.on('error', cleanup)

        stream.pipe(res)
    }
})

// Fallback for SPA (index.html existence cached at startup)
let indexHtmlExists = false
try {
    indexHtmlExists = fs.existsSync(path.join(distPath, 'index.html'))
} catch (e) { }

app.get('*', (req, res) => {
    if (indexHtmlExists) {
        res.sendFile(path.join(distPath, 'index.html'))
    } else {
        res.send('Frontend not built. Run npm run client:build')
    }
})

const server = app.listen(PORT, '0.0.0.0', () => {
    console.log(`Server running on http://0.0.0.0:${PORT}`)

    // Restore saved torrents from db.json
    restoreTorrents().catch(err => {
        console.error('[Server] Restore failed:', err.message)
    })

    // Start watchdog in background (non-blocking)
    startWatchdog().catch(err => {
        console.error('[Server] Watchdog failed:', err.message)
    })
})

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üõë Graceful Shutdown
// Handles: Docker stop, NAS restart, Ctrl+C
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let isShuttingDown = false

const gracefulShutdown = async (signal) => {
    if (isShuttingDown) return
    isShuttingDown = true

    console.log(`\n[Shutdown] Received ${signal}, starting graceful shutdown...`)

    // ‚úÖ FIX: –û—á–∏—â–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª rate limit cleanup
    if (rateLimitCleanupId) {
        clearInterval(rateLimitCleanupId)
        rateLimitCleanupId = null
    }

    // 1. Stop accepting new connections
    server.close(() => {
        console.log('[Shutdown] HTTP server closed')
    })

    // 2. Stop watchdog and lag monitor
    stopWatchdog()
    lagMonitor.stop()

    // 3. Destroy all torrent engines
    destroyAllTorrents()

    // 4. Save DB state
    try {
        await safeWrite(db)
        console.log('[Shutdown] Database saved')
    } catch (e) {
        console.error('[Shutdown] DB save failed:', e.message)
    }

    console.log('[Shutdown] Cleanup complete, exiting...')
    process.exit(0)
}

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'))
process.on('SIGINT', () => gracefulShutdown('SIGINT'))

```

---

### server/jacred.js

```js
/**
 * Jacred Torrent Search API - LEGACY WRAPPER
 * PWA-TorServe v2.7.0
 * 
 * This module now wraps JacredProvider for backward compatibility.
 * New code should use:
 * - aggregator.search() for multi-source search
 * - JacredProvider directly for Jacred-only access
 * 
 * Security note: SSL validation disabled for Jacred mirrors
 * (see JacredProvider.js for details)
 */

import { JacredProvider } from './providers/JacredProvider.js'

// Singleton provider instance for backward compatibility
const _provider = new JacredProvider()

/**
 * Search torrents via Jacred API
 * @deprecated Use aggregator.search() for multi-source, or JacredProvider for direct
 * @param {string} query
 * @returns {Promise<{results: Array}|{error: string, results: []}>}
 */
export const searchJacred = async (query) => {
    const results = await _provider.search(query)
    if (results.length > 0) {
        return { results }
    }
    return { error: 'No results', results: [] }
}

/**
 * Get magnet from result (already included in search results)
 * @param {string} magnetUrl
 * @returns {Promise<{magnet: string}|{error: string}>}
 */
export const getMagnetFromJacred = async (magnetUrl) => {
    return _provider.getMagnet(magnetUrl)
}

```

---

### server/providers/BaseProvider.js

```js
/**
 * BaseProvider - Abstract base class for torrent search providers
 * PWA-TorServe Provider Architecture
 * 
 * All providers must implement:
 * - search(query) ‚Üí Promise<SearchResult[]>
 * - getMagnet(id) ‚Üí Promise<{magnet}|{error}>
 * 
 * SearchResult format:
 * {
 *   id: string,           // Unique identifier (can be guid, topic id, etc.)
 *   title: string,        // Torrent title
 *   size: string,         // Human-readable size (e.g., "1.5 GB")
 *   sizeBytes: number,    // Size in bytes (for sorting/filtering)
 *   seeders: number,      // Number of seeders
 *   tracker: string,      // Tracker name
 *   magnet: string|null,  // Magnet link (if available immediately)
 *   provider: string      // Provider name (for deduplication/logging)
 * }
 */

export class BaseProvider {
    /** Provider name (used in logs and results) */
    name = 'base'

    /** Whether provider is enabled */
    enabled = true

    /** Provider-specific configuration */
    config = {}

    /**
     * Search for torrents
     * @param {string} query - Search query
     * @returns {Promise<Array>} Array of SearchResult objects
     */
    async search(query) {
        throw new Error('search() must be implemented by subclass')
    }

    /**
     * Get magnet link for a specific torrent
     * @param {string} id - Torrent identifier
     * @returns {Promise<{magnet: string}|{error: string}>}
     */
    async getMagnet(id) {
        throw new Error('getMagnet() must be implemented by subclass')
    }

    /**
     * Check if provider is healthy and ready to accept requests
     * @returns {boolean}
     */
    isHealthy() {
        return this.enabled
    }

    /**
     * Normalize result to standard SearchResult format
     * @param {Object} raw - Raw result from provider
     * @returns {Object} Normalized SearchResult
     */
    normalizeResult(raw) {
        return {
            id: raw.id || String(Math.random()),
            title: raw.title || 'Unknown',
            size: raw.size || 'N/A',
            sizeBytes: raw.sizeBytes || raw.Size || 0,
            seeders: raw.seeders || 0,
            tracker: raw.tracker || this.name,
            magnet: raw.magnet || raw.magnetUrl || null,
            provider: this.name
        }
    }
}

/**
 * Format bytes to human-readable string
 * @param {number} bytes
 * @returns {string}
 */
export function formatSize(bytes) {
    if (!bytes) return 'N/A'
    const units = ['B', 'KB', 'MB', 'GB', 'TB']
    let i = 0
    let size = bytes
    while (size >= 1024 && i < units.length - 1) {
        size /= 1024
        i++
    }
    return `${size.toFixed(1)} ${units[i]}`
}

```

---

### server/providers/JacredProvider.js

```js
/**
 * JacredProvider - Jacred torrent search provider
 * PWA-TorServe Provider Architecture
 * 
 * Implements Jacred API search with:
 * - Mirror rotation
 * - User-Agent rotation
 * - Retry with exponential backoff
 * - Rate limiting (429) handling
 * 
 * Security note: SSL validation disabled for Jacred mirrors
 * (see header comments in original jacred.js for explanation)
 */

import https from 'https'
import http from 'http'
import { BaseProvider, formatSize } from './BaseProvider.js'
import { logger } from '../utils/logger.js'
import { withRetry, retryPredicates } from '../utils/retry.js'

const log = logger.child('JacredProvider')

// Jacred mirrors (only working ones)
const JACRED_MIRRORS = [
    { host: 'jacred.xyz', port: 443, protocol: 'https' },
    { host: 'jacred.xyz', port: 80, protocol: 'http' },
]

// User-Agent rotation to avoid rate limiting
const USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1',
]

const getRandomUserAgent = () => USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)]
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms))

export class JacredProvider extends BaseProvider {
    name = 'jacred'

    constructor() {
        super()
        this.currentMirror = JACRED_MIRRORS[0].host
    }

    /**
     * Search torrents via Jacred API
     * @param {string} query
     * @returns {Promise<Array>} Normalized SearchResult[]
     */
    async search(query) {
        log.info('üîç Starting search', { query, mirrorsCount: JACRED_MIRRORS.length })

        for (let i = 0; i < JACRED_MIRRORS.length; i++) {
            const mirror = JACRED_MIRRORS[i]
            const mirrorId = `${mirror.protocol}://${mirror.host}:${mirror.port}`
            log.info('Trying mirror', { mirror: mirrorId, attempt: i + 1 })

            try {
                const data = await withRetry(() => this._doSearch(mirror, query), {
                    maxRetries: 3,
                    baseDelayMs: 5000,
                    shouldRetry: (err) => {
                        if (err.message.includes('Rate limited')) return true
                        return retryPredicates.transient(err)
                    },
                    onRetry: (err, attempt, delay) => {
                        log.warn('Mirror retry', { mirror: mirrorId, attempt, delay: Math.round(delay), error: err.message })
                    }
                })

                if (data && data.length > 0) {
                    this.currentMirror = mirror.host
                    log.info('‚úÖ Mirror connected', { mirror: mirrorId, resultsCount: data.length })
                    return data
                } else {
                    log.warn('Mirror returned empty results', { mirror: mirrorId })
                }
            } catch (err) {
                log.warn('‚ùå Mirror failed', { mirror: mirrorId, error: err.message })
            }

            if (i < JACRED_MIRRORS.length - 1) {
                await sleep(500)
            }
        }

        log.error('‚ùå All mirrors failed', { query, triedMirrors: JACRED_MIRRORS.length })
        return []
    }

    /**
     * Get magnet from result (already included in search results)
     * @param {string} magnetUrl
     * @returns {Promise<{magnet: string}|{error: string}>}
     */
    async getMagnet(magnetUrl) {
        if (magnetUrl && magnetUrl.startsWith('magnet:')) {
            return { magnet: magnetUrl }
        }
        return { error: 'No magnet link' }
    }

    /**
     * Do search request to specific mirror
     * @private
     */
    _doSearch(mirror, query, redirectCount = 0) {
        const MAX_REDIRECTS = 3

        return new Promise((resolve, reject) => {
            const searchPath = `/api/v2.0/indexers/all/results?apikey=&Query=${encodeURIComponent(query)}`

            const options = {
                hostname: mirror.host,
                port: mirror.port,
                path: searchPath,
                method: 'GET',
                rejectUnauthorized: false,
                headers: {
                    'User-Agent': getRandomUserAgent(),
                    'Accept': 'application/json'
                },
                timeout: 15000
            }

            const protocol = mirror.protocol === 'https' ? https : http

            const req = protocol.request(options, (res) => {
                // Handle redirects
                if ([301, 302, 307, 308].includes(res.statusCode) && res.headers.location) {
                    if (redirectCount >= MAX_REDIRECTS) {
                        reject(new Error('Too many redirects'))
                        return
                    }

                    try {
                        const redirectUrl = new URL(res.headers.location, `${mirror.protocol}://${mirror.host}`)
                        const newMirror = {
                            host: redirectUrl.hostname,
                            port: redirectUrl.port || (redirectUrl.protocol === 'https:' ? 443 : 80),
                            protocol: redirectUrl.protocol.replace(':', '')
                        }
                        log.debug('Following redirect', { to: redirectUrl.href })
                        resolve(this._doSearch(newMirror, query, redirectCount + 1))
                    } catch (e) {
                        reject(new Error(`Invalid redirect: ${res.headers.location}`))
                    }
                    return
                }

                // Handle rate limiting
                if (res.statusCode === 429) {
                    const retryAfter = parseInt(res.headers['retry-after'] || '5', 10)
                    reject(new Error(`Rate limited (retry after ${retryAfter}s)`))
                    return
                }

                if (res.statusCode !== 200) {
                    reject(new Error(`HTTP ${res.statusCode}`))
                    return
                }

                let data = ''
                res.setEncoding('utf8')

                res.on('data', chunk => data += chunk)
                res.on('end', () => {
                    try {
                        if (data.trim().startsWith('<')) {
                            reject(new Error('Received HTML instead of JSON (possible Cloudflare block)'))
                            return
                        }

                        const json = JSON.parse(data)
                        const results = (json.Results || json.results || []).slice(0, 50).map(r =>
                            this.normalizeResult({
                                id: r.Guid || r.guid || Math.random().toString(36),
                                title: r.Title || r.title || 'Unknown',
                                size: formatSize(r.Size || r.size || 0),
                                sizeBytes: r.Size || r.size || 0,
                                seeders: r.Seeders || r.seeders || 0,
                                tracker: r.Tracker || r.tracker || 'Unknown',
                                magnet: r.MagnetUri || r.magnetUri || r.Link || r.link || null
                            })
                        )
                        resolve(results)
                    } catch (err) {
                        reject(new Error('Parse error: ' + err.message))
                    }
                })
            })

            req.on('error', reject)
            req.on('timeout', () => {
                req.destroy()
                reject(new Error('Timeout'))
            })

            req.end()
        })
    }
}

```

---

### server/providers/ProviderManager.js

```js
/**
 * ProviderManager - Registry and coordinator for torrent providers
 * PWA-TorServe Provider Architecture
 * 
 * Manages provider registration, enables/disables, and health status.
 */

import { logger } from '../utils/logger.js'

const log = logger.child('ProviderManager')

class ProviderManager {
    constructor() {
        /** @type {Map<string, import('./BaseProvider.js').BaseProvider>} */
        this.providers = new Map()
    }

    /**
     * Register a provider instance
     * @param {import('./BaseProvider.js').BaseProvider} provider
     */
    register(provider) {
        if (!provider.name) {
            throw new Error('Provider must have a name')
        }

        this.providers.set(provider.name, provider)
        log.info('Provider registered', {
            name: provider.name,
            enabled: provider.enabled
        })
    }

    /**
     * Get provider by name
     * @param {string} name
     * @returns {import('./BaseProvider.js').BaseProvider|undefined}
     */
    get(name) {
        return this.providers.get(name)
    }

    /**
     * Get all enabled and healthy providers
     * @returns {import('./BaseProvider.js').BaseProvider[]}
     */
    getEnabled() {
        return Array.from(this.providers.values())
            .filter(p => p.enabled && p.isHealthy())
    }

    /**
     * Get all registered providers
     * @returns {import('./BaseProvider.js').BaseProvider[]}
     */
    getAll() {
        return Array.from(this.providers.values())
    }

    /**
     * Enable or disable a provider
     * @param {string} name
     * @param {boolean} enabled
     */
    setEnabled(name, enabled) {
        const provider = this.providers.get(name)
        if (provider) {
            provider.enabled = enabled
            log.info('Provider state changed', { name, enabled })
        }
    }

    /**
     * Get status of all providers
     * @returns {Object[]}
     */
    getStatus() {
        return Array.from(this.providers.values()).map(p => ({
            name: p.name,
            enabled: p.enabled,
            healthy: p.isHealthy()
        }))
    }
}

// Singleton instance
export const providerManager = new ProviderManager()

```

---

### server/providers/RuTrackerProvider.js

```js
/**
 * RuTrackerProvider - RuTracker torrent search provider
 * PWA-TorServe Provider Architecture v2.7.1
 * 
 * Implements RuTracker search with:
 * - Mirror rotation (rutracker.org, .nl, .net, .cc)
 * - DNS-over-HTTPS bypass for ISP blocking
 * - Cookie-based authentication
 * - HTML parsing via regex (no external deps)
 * - Retry with exponential backoff
 * 
 * Requires RUTRACKER_LOGIN and RUTRACKER_PASSWORD in .env
 */

import https from 'https'
import fs from 'fs'
import path from 'path'
import { BaseProvider } from './BaseProvider.js'
import { logger } from '../utils/logger.js'

const log = logger.child('RuTrackerProvider')

// RuTracker mirrors (in order of preference)
const RUTRACKER_MIRRORS = [
    'rutracker.org',   // Primary
    'rutracker.nl',    // Netherlands mirror  
    'rutracker.net',   // Alternative
]

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üåê DNS-over-HTTPS: Bypass ISP DNS blocking
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const DOH_PROVIDER = process.env.DOH_PROVIDER || 'https://cloudflare-dns.com/dns-query'
const DNS_CACHE_TTL = 10 * 60 * 1000 // 10 minutes

const dnsCache = new Map()

async function resolveIP(hostname) {
    if (dnsCache.has(hostname)) {
        const cached = dnsCache.get(hostname)
        if (Date.now() < cached.expires) {
            log.debug('DoH cache hit', { hostname, ip: cached.ip })
            return cached.ip
        }
        dnsCache.delete(hostname)
    }

    log.info('DoH resolving...', { hostname })
    try {
        const url = `${DOH_PROVIDER}?name=${encodeURIComponent(hostname)}&type=A`
        const response = await fetch(url, {
            method: 'GET',
            headers: { 'Accept': 'application/dns-json' },
            signal: AbortSignal.timeout(5000)
        })

        if (!response.ok) throw new Error(`HTTP ${response.status}`)
        const data = await response.json()

        if (data.Answer && data.Answer.length > 0) {
            const record = data.Answer.find(r => r.type === 1)
            if (record) {
                const ip = record.data
                log.info('DoH resolved', { hostname, ip })
                dnsCache.set(hostname, { ip, expires: Date.now() + DNS_CACHE_TTL })
                return ip
            }
        }
        log.warn('DoH no A record', { hostname })
    } catch (e) {
        log.warn('DoH failed', { hostname, error: e.message })
    }
    return null
}

// Session persistence file
const SESSION_FILE = path.join(process.cwd(), 'data', 'rutracker-session.json')

export class RuTrackerProvider extends BaseProvider {
    name = 'rutracker'

    constructor() {
        super()
        this.sessionCookie = null
        this.currentMirror = RUTRACKER_MIRRORS[0]
        this.login = process.env.RUTRACKER_LOGIN || ''
        this.password = process.env.RUTRACKER_PASSWORD || ''

        if (!this.login || !this.password) {
            this.enabled = false
            log.warn('RuTracker disabled: RUTRACKER_LOGIN/PASSWORD not set')
        } else {
            // Try to load persisted session
            this._loadSession()
        }
    }

    isHealthy() {
        return this.enabled && Boolean(this.login && this.password)
    }

    /**
     * Load session from file
     * @private
     */
    _loadSession() {
        try {
            if (fs.existsSync(SESSION_FILE)) {
                const data = JSON.parse(fs.readFileSync(SESSION_FILE, 'utf8'))
                if (data.cookie && data.expires > Date.now()) {
                    this.sessionCookie = data.cookie
                    this.currentMirror = data.mirror || RUTRACKER_MIRRORS[0]
                    log.info('Session loaded from file', { expires: new Date(data.expires).toISOString() })
                } else {
                    log.debug('Session expired, will re-login')
                }
            }
        } catch (e) {
            log.debug('No saved session', { error: e.message })
        }
    }

    /**
     * Save session to file
     * @private
     */
    _saveSession() {
        try {
            const dir = path.dirname(SESSION_FILE)
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true })
            }
            const data = {
                cookie: this.sessionCookie,
                mirror: this.currentMirror,
                expires: Date.now() + 24 * 60 * 60 * 1000 // 24 hours
            }
            fs.writeFileSync(SESSION_FILE, JSON.stringify(data, null, 2))
            log.debug('Session saved to file')
        } catch (e) {
            log.warn('Failed to save session', { error: e.message })
        }
    }

    /**
     * Search torrents on RuTracker with mirror fallback
     */
    async search(query) {
        if (!this.isHealthy()) {
            log.debug('Skipping search: not healthy')
            return []
        }

        // Try each mirror
        for (const mirror of RUTRACKER_MIRRORS) {
            log.info('Trying mirror', { mirror })
            try {
                // Login if needed
                if (!this.sessionCookie) {
                    log.debug('Logging in...', { mirror })
                    await this._loginToMirror(mirror)
                }

                log.debug('Searching...', { mirror, query })
                const results = await this._searchOnMirror(mirror, query)
                if (results.length > 0) {
                    this.currentMirror = mirror
                    log.info('Search successful', { mirror, count: results.length })
                    return results
                }
                log.warn('Empty results', { mirror })
            } catch (err) {
                log.warn(`Mirror ${mirror} failed`, { error: err.message })
                this.sessionCookie = null // Reset session for next mirror
            }
        }

        log.error('All mirrors failed')
        return []
    }

    /**
     * Get magnet link from topic page
     */
    async getMagnet(topicId) {
        if (!this.sessionCookie) {
            try {
                await this._loginToMirror(this.currentMirror)
            } catch {
                return { error: 'Login failed' }
            }
        }

        try {
            const options = await this._makeOptions(
                this.currentMirror,
                `/forum/viewtopic.php?t=${topicId}`,
                'GET'
            )
            options.headers['Cookie'] = this.sessionCookie

            return new Promise((resolve) => {
                const req = https.request(options, (res) => {
                    let data = ''
                    res.setEncoding('utf8')
                    res.on('data', chunk => data += chunk)
                    res.on('end', () => {
                        const match = data.match(/magnet:\?xt=urn:btih:[^"'\s]+/)
                        resolve(match ? { magnet: match[0] } : { error: 'Magnet not found' })
                    })
                })
                req.on('error', () => resolve({ error: 'Request failed' }))
                req.end()
            })
        } catch {
            return { error: 'Request failed' }
        }
    }

    /**
     * Create HTTPS options with DoH bypass
     * @private
     */
    async _makeOptions(mirror, path, method = 'GET') {
        const ip = await resolveIP(mirror)

        return {
            hostname: ip || mirror,
            port: 443,
            path: path,
            method: method,
            servername: mirror,
            rejectUnauthorized: true,
            headers: {
                'Host': mirror,
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            }
        }
    }

    /**
     * Login to specific mirror
     * @private
     */
    async _loginToMirror(mirror) {
        const postData = `login_username=${encodeURIComponent(this.login)}&login_password=${encodeURIComponent(this.password)}&login=%C2%F5%EE%E4`

        const options = await this._makeOptions(mirror, '/forum/login.php', 'POST')
        options.headers['Content-Type'] = 'application/x-www-form-urlencoded'
        options.headers['Content-Length'] = Buffer.byteLength(postData)

        return new Promise((resolve, reject) => {
            const req = https.request(options, (res) => {
                const cookies = res.headers['set-cookie']
                if (cookies) {
                    this.sessionCookie = cookies.map(c => c.split(';')[0]).join('; ')
                    this._saveSession() // Persist session
                    log.info('Login successful', { mirror })
                    resolve(this.sessionCookie)
                } else {
                    reject(new Error('No cookies received'))
                }
            })
            req.on('error', reject)
            req.write(postData)
            req.end()
        })
    }

    /**
     * Search on specific mirror
     * @private
     */
    async _searchOnMirror(mirror, query) {
        const options = await this._makeOptions(
            mirror,
            `/forum/tracker.php?nm=${encodeURIComponent(query)}`,
            'GET'
        )
        options.headers['Cookie'] = this.sessionCookie

        return new Promise((resolve, reject) => {
            const req = https.request(options, (res) => {
                let data = ''
                res.setEncoding('utf8')
                res.on('data', chunk => data += chunk)
                res.on('end', () => {
                    try {
                        resolve(this._parseResults(data))
                    } catch (err) {
                        reject(new Error(`Parse failed: ${err.message}`))
                    }
                })
            })
            req.on('error', reject)
            req.end()
        })
    }

    /**
     * Parse search results HTML
     * @private
     */
    _parseResults(html) {
        const results = []

        const titleRegex = /<a[^>]*class="tLink"[^>]*href="[^"]*t=(\d+)"[^>]*>([^<]+)<\/a>/g
        const sizeRegex = /<td[^>]*class="tor-size"[^>]*>[\s\S]*?<a[^>]*>([^<]+)<\/a>/g
        const seedRegex = /<b class="seedmed">(\d+)<\/b>/g

        const sizes = [], seeds = []
        let match

        while ((match = sizeRegex.exec(html))) sizes.push(match[1].trim())
        while ((match = seedRegex.exec(html))) seeds.push(parseInt(match[1]))

        let i = 0
        while ((match = titleRegex.exec(html)) && i < 20) {
            const topicId = match[1]
            const title = match[2]
                .replace(/&quot;/g, '"')
                .replace(/&amp;/g, '&')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .trim()

            const sizeStr = sizes[i] || 'N/A'
            let sizeBytes = 0
            const sizeMatch = sizeStr.match(/([\d.]+)\s*(GB|MB|KB|TB)/i)
            if (sizeMatch) {
                const num = parseFloat(sizeMatch[1])
                const unit = sizeMatch[2].toUpperCase()
                const mult = { 'KB': 1024, 'MB': 1024 ** 2, 'GB': 1024 ** 3, 'TB': 1024 ** 4 }
                sizeBytes = num * (mult[unit] || 1)
            }

            results.push(this.normalizeResult({
                id: topicId,
                title,
                size: sizeStr,
                sizeBytes,
                seeders: seeds[i] || 0,
                tracker: 'RuTracker',
                magnet: null
            }))
            i++
        }

        return results
    }
}

```

---

### server/providers/RutorProvider.js

```js
/**
 * RutorProvider - Rutor.info torrent search provider
 * PWA-TorServe Provider Architecture
 * 
 * Implements Rutor search with:
 * - Mirror rotation (rutor.info, rutor.is)
 * - HTML parsing via regex (no external deps)
 * - No authentication required (public tracker)
 * - Magnet links directly in search results
 */

import https from 'https'
import http from 'http'
import { BaseProvider, formatSize } from './BaseProvider.js'
import { logger } from '../utils/logger.js'

const log = logger.child('RutorProvider')

// Rutor mirrors
const RUTOR_MIRRORS = [
    { host: 'rutor.info', protocol: 'http', port: 80 },
    { host: 'rutor.is', protocol: 'http', port: 80 },
]

export class RutorProvider extends BaseProvider {
    name = 'rutor'

    constructor() {
        super()
        this.currentMirror = RUTOR_MIRRORS[0]
    }

    /**
     * Search torrents on Rutor with mirror fallback
     */
    async search(query) {
        log.info('üîç Starting search', { query, mirrorsCount: RUTOR_MIRRORS.length })

        for (const mirror of RUTOR_MIRRORS) {
            const mirrorId = `${mirror.protocol}://${mirror.host}`
            log.info('Trying mirror', { mirror: mirrorId })

            try {
                const results = await this._doSearch(mirror, query)
                if (results.length > 0) {
                    this.currentMirror = mirror
                    log.info('‚úÖ Search successful', { mirror: mirrorId, count: results.length })
                    return results
                }
                log.warn('Empty results', { mirror: mirrorId })
            } catch (err) {
                log.warn(`Mirror failed`, { mirror: mirrorId, error: err.message })
            }
        }

        log.error('All mirrors failed')
        return []
    }

    /**
     * Get magnet (already in search results)
     */
    async getMagnet(magnetUrl) {
        if (magnetUrl && magnetUrl.startsWith('magnet:')) {
            return { magnet: magnetUrl }
        }
        return { error: 'No magnet link' }
    }

    /**
     * Do search request to specific mirror
     * @private
     */
    _doSearch(mirror, query) {
        return new Promise((resolve, reject) => {
            // Rutor search URL format: /search/0/0/000/0/{query}
            const searchPath = `/search/0/0/000/0/${encodeURIComponent(query)}`

            const options = {
                hostname: mirror.host,
                port: mirror.port,
                path: searchPath,
                method: 'GET',
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Accept': 'text/html',
                    'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7'
                },
                timeout: 15000
            }

            const protocol = mirror.protocol === 'https' ? https : http

            const req = protocol.request(options, (res) => {
                if (res.statusCode !== 200) {
                    reject(new Error(`HTTP ${res.statusCode}`))
                    return
                }

                let data = ''
                res.setEncoding('utf8')

                res.on('data', chunk => data += chunk)
                res.on('end', () => {
                    try {
                        const results = this._parseResults(data)
                        resolve(results)
                    } catch (err) {
                        reject(new Error(`Parse failed: ${err.message}`))
                    }
                })
            })

            req.on('error', reject)
            req.on('timeout', () => {
                req.destroy()
                reject(new Error('Timeout'))
            })

            req.end()
        })
    }

    /**
     * Parse Rutor search results HTML
     * @private
     */
    _parseResults(html) {
        const results = []

        // Rutor HTML structure:
        // <tr class="gai"...> or <tr class="tum"...>
        // Contains: magnet link, title, size, seeders

        // Match table rows with torrent data
        const rowRegex = /<tr[^>]*class="(?:gai|tum)"[^>]*>([\s\S]*?)<\/tr>/gi

        let rowMatch
        while ((rowMatch = rowRegex.exec(html)) !== null && results.length < 30) {
            const rowHtml = rowMatch[1]

            // Extract magnet link
            const magnetMatch = rowHtml.match(/href="(magnet:\?xt=urn:btih:[^"]+)"/i)
            if (!magnetMatch) continue

            const magnet = magnetMatch[1]
                .replace(/&amp;/g, '&')

            // Extract title from the last link before size
            // Pattern: <a href="/torrent/...">Title</a>
            const titleMatch = rowHtml.match(/<a[^>]*href="\/torrent\/\d+[^"]*"[^>]*>([^<]+)<\/a>/i)
            if (!titleMatch) continue

            const title = titleMatch[1]
                .replace(/&quot;/g, '"')
                .replace(/&amp;/g, '&')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .trim()

            // Extract size (format: "1.5 GB" or "500 MB")
            const sizeMatch = rowHtml.match(/>(\d+(?:\.\d+)?\s*(?:GB|MB|KB|TB))</i)
            const sizeStr = sizeMatch ? sizeMatch[1] : 'N/A'

            // Parse size to bytes
            let sizeBytes = 0
            const sizeNumMatch = sizeStr.match(/([\d.]+)\s*(GB|MB|KB|TB)/i)
            if (sizeNumMatch) {
                const num = parseFloat(sizeNumMatch[1])
                const unit = sizeNumMatch[2].toUpperCase()
                const mult = { 'KB': 1024, 'MB': 1024 ** 2, 'GB': 1024 ** 3, 'TB': 1024 ** 4 }
                sizeBytes = num * (mult[unit] || 1)
            }

            // Extract seeders (green number in span)
            const seedMatch = rowHtml.match(/<span[^>]*class="[^"]*green[^"]*"[^>]*>(\d+)<\/span>/i)
            const seeders = seedMatch ? parseInt(seedMatch[1]) : 0

            results.push(this.normalizeResult({
                id: magnet, // Use magnet as ID
                title,
                size: sizeStr,
                sizeBytes,
                seeders,
                tracker: 'Rutor',
                magnet
            }))
        }

        return results
    }
}

```

---

### server/providers/TorLookProvider.js

```js
/**
 * TorLookProvider - TorLook.info torrent search provider
 * PWA-TorServe Provider Architecture
 * 
 * TorLook is a torrent aggregator/metasearch engine
 * Implements HTML parsing, no authentication required
 */

import https from 'https'
import { BaseProvider } from './BaseProvider.js'
import { logger } from '../utils/logger.js'

const log = logger.child('TorLookProvider')

const TORLOOK_HOST = 'torlook.info'

export class TorLookProvider extends BaseProvider {
    name = 'torlook'

    /**
     * Search torrents on TorLook
     */
    async search(query) {
        log.info('üîç Starting search', { query })

        try {
            const results = await this._doSearch(query)
            if (results.length > 0) {
                log.info('‚úÖ Search successful', { count: results.length })
            } else {
                log.warn('Empty results')
            }
            return results
        } catch (err) {
            log.warn('Search failed', { error: err.message })
            return []
        }
    }

    /**
     * Get magnet (already in search results)
     */
    async getMagnet(magnetUrl) {
        if (magnetUrl && magnetUrl.startsWith('magnet:')) {
            return { magnet: magnetUrl }
        }
        return { error: 'No magnet link' }
    }

    /**
     * Do search request
     * @private
     */
    _doSearch(query) {
        return new Promise((resolve, reject) => {
            // TorLook search URL: /search/query/
            const searchPath = `/search/${encodeURIComponent(query)}/`

            const options = {
                hostname: TORLOOK_HOST,
                port: 443,
                path: searchPath,
                method: 'GET',
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Accept': 'text/html',
                    'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7'
                },
                timeout: 15000
            }

            const req = https.request(options, (res) => {
                if (res.statusCode !== 200) {
                    reject(new Error(`HTTP ${res.statusCode}`))
                    return
                }

                let data = ''
                res.setEncoding('utf8')

                res.on('data', chunk => data += chunk)
                res.on('end', () => {
                    try {
                        const results = this._parseResults(data)
                        resolve(results)
                    } catch (err) {
                        reject(new Error(`Parse failed: ${err.message}`))
                    }
                })
            })

            req.on('error', reject)
            req.on('timeout', () => {
                req.destroy()
                reject(new Error('Timeout'))
            })

            req.end()
        })
    }

    /**
     * Parse TorLook search results HTML
     * @private
     */
    _parseResults(html) {
        const results = []

        // TorLook results are in divs with class "item"
        // Each contains: title, size, seeds, magnet link

        // Match torrent items
        const itemRegex = /<div[^>]*class="[^"]*item[^"]*"[^>]*>([\s\S]*?)<\/div>\s*<\/div>/gi

        let itemMatch
        while ((itemMatch = itemRegex.exec(html)) !== null && results.length < 25) {
            const itemHtml = itemMatch[1]

            // Extract magnet link
            const magnetMatch = itemHtml.match(/href="(magnet:\?xt=urn:btih:[^"]+)"/i)
            if (!magnetMatch) continue

            const magnet = magnetMatch[1].replace(/&amp;/g, '&')

            // Extract title
            const titleMatch = itemHtml.match(/<a[^>]*class="[^"]*title[^"]*"[^>]*>([^<]+)<\/a>/i) ||
                itemHtml.match(/<a[^>]*href="[^"]*"[^>]*title="([^"]+)"/i)
            if (!titleMatch) continue

            const title = titleMatch[1]
                .replace(/&quot;/g, '"')
                .replace(/&amp;/g, '&')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .trim()

            // Extract size
            const sizeMatch = itemHtml.match(/>(\d+(?:\.\d+)?\s*(?:GB|MB|KB|TB))</i)
            const sizeStr = sizeMatch ? sizeMatch[1] : 'N/A'

            // Parse size to bytes
            let sizeBytes = 0
            const sizeNumMatch = sizeStr.match(/([\d.]+)\s*(GB|MB|KB|TB)/i)
            if (sizeNumMatch) {
                const num = parseFloat(sizeNumMatch[1])
                const unit = sizeNumMatch[2].toUpperCase()
                const mult = { 'KB': 1024, 'MB': 1024 ** 2, 'GB': 1024 ** 3, 'TB': 1024 ** 4 }
                sizeBytes = num * (mult[unit] || 1)
            }

            // Extract seeders
            const seedMatch = itemHtml.match(/<span[^>]*class="[^"]*seed[^"]*"[^>]*>(\d+)<\/span>/i)
            const seeders = seedMatch ? parseInt(seedMatch[1]) : 0

            results.push(this.normalizeResult({
                id: magnet,
                title,
                size: sizeStr,
                sizeBytes,
                seeders,
                tracker: 'TorLook',
                magnet
            }))
        }

        return results
    }
}

```

---

### server/providers/index.js

```js
/**
 * Provider Index - Exports and auto-registers all providers
 * PWA-TorServe Provider Architecture
 */

export { BaseProvider, formatSize } from './BaseProvider.js'
export { providerManager } from './ProviderManager.js'
export { JacredProvider } from './JacredProvider.js'
export { RuTrackerProvider } from './RuTrackerProvider.js'
export { RutorProvider } from './RutorProvider.js'
export { TorLookProvider } from './TorLookProvider.js'

// Auto-registration of providers
import { providerManager } from './ProviderManager.js'
import { JacredProvider } from './JacredProvider.js'
import { RuTrackerProvider } from './RuTrackerProvider.js'
import { RutorProvider } from './RutorProvider.js'
import { TorLookProvider } from './TorLookProvider.js'

// Register providers on module load
providerManager.register(new JacredProvider())
providerManager.register(new RuTrackerProvider())
providerManager.register(new RutorProvider())
providerManager.register(new TorLookProvider())

```

---

### server/rutracker.js

```js
/**
 * RuTracker Search API - LEGACY WRAPPER
 * PWA-TorServe v2.7.0
 * 
 * This module now wraps RuTrackerProvider for backward compatibility.
 * New code should use:
 * - aggregator.search() for multi-source search
 * - RuTrackerProvider directly for RuTracker-only access
 */

import { RuTrackerProvider } from './providers/RuTrackerProvider.js'

// Singleton provider instance for backward compatibility
const _provider = new RuTrackerProvider()

/**
 * Search RuTracker
 * @deprecated Use aggregator.search() for multi-source, or RuTrackerProvider for direct
 * @param {string} query
 * @returns {Promise<{results: Array}|{error: string, results: []}>}
 */
export const searchRuTracker = async (query) => {
    const results = await _provider.search(query)
    if (results.length > 0) {
        return { results }
    }
    return { error: 'No results', results: [] }
}

/**
 * Get magnet link from topic page
 * @param {string} topicId
 * @returns {Promise<{magnet: string}|{error: string}>}
 */
export const getMagnetLink = async (topicId) => {
    return _provider.getMagnet(topicId)
}

```

---

### server/searchCache.js

```js
/**
 * Search Cache - Short-lived cache for search results
 * PWA-TorServe Provider Architecture
 * 
 * Reduces load on providers by caching search results for 5-10 minutes.
 * Uses LRU-like eviction when cache is full.
 */

import { logger } from './utils/logger.js'

const log = logger.child('SearchCache')

// Cache configuration
const CACHE_TTL_MS = 5 * 60 * 1000  // 5 minutes
const MAX_CACHE_SIZE = 100          // Max cached queries

class SearchCache {
    constructor() {
        /** @type {Map<string, {results: Array, expires: number, providers: Object}>} */
        this.cache = new Map()
        this.hits = 0
        this.misses = 0
    }

    /**
     * Generate cache key from query
     * @param {string} query
     * @returns {string}
     */
    _key(query) {
        return query.toLowerCase().trim()
    }

    /**
     * Get cached results if available and not expired
     * @param {string} query
     * @returns {{results: Array, providers: Object}|null}
     */
    get(query) {
        const key = this._key(query)
        const cached = this.cache.get(key)

        if (!cached) {
            this.misses++
            return null
        }

        if (Date.now() > cached.expires) {
            this.cache.delete(key)
            this.misses++
            log.debug('Cache expired', { query: key })
            return null
        }

        this.hits++
        log.debug('Cache hit', { query: key, age: Math.round((cached.expires - Date.now()) / 1000) + 's left' })
        return { results: cached.results, providers: cached.providers }
    }

    /**
     * Store search results in cache
     * @param {string} query
     * @param {Array} results
     * @param {Object} providers
     */
    set(query, results, providers) {
        const key = this._key(query)

        // Evict old entries if cache is full
        if (this.cache.size >= MAX_CACHE_SIZE) {
            this._evictOldest()
        }

        this.cache.set(key, {
            results,
            providers,
            expires: Date.now() + CACHE_TTL_MS
        })

        log.debug('Cache set', { query: key, resultsCount: results.length })
    }

    /**
     * Evict oldest entries (LRU-like)
     * @private
     */
    _evictOldest() {
        const now = Date.now()
        let evicted = 0

        // First, remove expired entries
        for (const [key, value] of this.cache) {
            if (now > value.expires) {
                this.cache.delete(key)
                evicted++
            }
        }

        // If still full, remove oldest 10%
        if (this.cache.size >= MAX_CACHE_SIZE) {
            const toRemove = Math.ceil(MAX_CACHE_SIZE * 0.1)
            const keys = Array.from(this.cache.keys()).slice(0, toRemove)
            keys.forEach(k => this.cache.delete(k))
            evicted += toRemove
        }

        if (evicted > 0) {
            log.debug('Cache evicted', { count: evicted })
        }
    }

    /**
     * Clear all cache
     */
    clear() {
        this.cache.clear()
        log.info('Cache cleared')
    }

    /**
     * Get cache statistics
     * @returns {Object}
     */
    getStats() {
        const total = this.hits + this.misses
        return {
            size: this.cache.size,
            maxSize: MAX_CACHE_SIZE,
            hits: this.hits,
            misses: this.misses,
            hitRate: total > 0 ? Math.round((this.hits / total) * 100) + '%' : 'N/A',
            ttlMinutes: CACHE_TTL_MS / 60000
        }
    }
}

// Singleton instance
export const searchCache = new SearchCache()

```

---

### server/torrent.js

```js
import torrentStream from 'torrent-stream'
import process from 'process'
import fs from 'fs'
import fsPromises from 'fs/promises'
import path from 'path'
import { db, safeWrite } from './db.js'

const engines = new Map()

// üî• Best Public Trackers (Tier 1 & 2)
const PUBLIC_TRACKERS = [
    'udp://tracker.opentrackr.org:1337/announce',
    'udp://open.stealth.si:80/announce',
    'udp://tracker.torrent.eu.org:451/announce',
    'udp://tracker.tiny-vps.com:6969/announce',
    'udp://tracker.cyberia.is:6969/announce',
    'udp://tracker.moeking.me:6969/announce',
    'udp://p4p.arenabg.com:1337/announce',
    'udp://explodie.org:6969/announce',
    'http://tracker.gbitt.info:80/announce'
]

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Keep-Alive: Frozen torrents for instant resume (5 min TTL)
// üî• Memory fix: reduced from 30min to 5min, max 3 frozen
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const frozenTorrents = new Map() // infoHash -> { engine, frozenAt, magnetURI }
const FROZEN_TTL = 5 * 60 * 1000 // üî• 5 minutes (was 30)
const MAX_FROZEN_TORRENTS = 3    // üî• Limit frozen count

// ‚úÖ FIX: –°–æ—Ö—Ä–∞–Ω—è–µ–º ID –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –ø—Ä–∏ shutdown
let frozenCleanupIntervalId = null

// Cleanup expired frozen torrents every 2 minutes
function startFrozenCleanup() {
    if (frozenCleanupIntervalId) return // –£–∂–µ –∑–∞–ø—É—â–µ–Ω

    frozenCleanupIntervalId = setInterval(() => {
        const now = Date.now()

        // üî• Memory fix: destroy oldest if over limit
        while (frozenTorrents.size > MAX_FROZEN_TORRENTS) {
            const oldest = [...frozenTorrents.entries()]
                .sort((a, b) => a[1].frozenAt - b[1].frozenAt)[0]
            if (oldest) {
                console.log(`[Keep-Alive] Over limit, destroying oldest: ${oldest[0]}`)
                oldest[1].engine.destroy()
                frozenTorrents.delete(oldest[0])
            }
        }

        for (const [hash, frozen] of frozenTorrents.entries()) {
            if (now - frozen.frozenAt > FROZEN_TTL) {
                console.log(`[Keep-Alive] Expired, destroying: ${hash}`)
                frozen.engine.destroy()
                frozenTorrents.delete(hash)
            }
        }
    }, 2 * 60 * 1000) // Check every 2 minutes

    console.log('[Keep-Alive] Cleanup interval started')
}

// ‚úÖ FIX: –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ –ø—Ä–∏ shutdown
function stopFrozenCleanup() {
    if (frozenCleanupIntervalId) {
        clearInterval(frozenCleanupIntervalId)
        frozenCleanupIntervalId = null
        console.log('[Keep-Alive] Cleanup interval stopped')
    }
}

// –ó–∞–ø—É—Å–∫–∞–µ–º –æ—á–∏—Å—Ç–∫—É –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥—É–ª—è
startFrozenCleanup()

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Persistence: Save/Remove torrents to db.json
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function saveTorrentToDB(magnetURI, name) {
    db.data.torrents ||= []
    // Avoid duplicates
    if (!db.data.torrents.find(t => t.magnet === magnetURI)) {
        db.data.torrents.push({ magnet: magnetURI, name, addedAt: Date.now(), completed: false })
        await safeWrite(db)
        console.log('[Persistence] Saved torrent:', name)
    }
}

// Mark torrent as completed in DB (survives restart)
async function markTorrentCompleted(infoHash) {
    const hashLower = infoHash.toLowerCase()
    const torrent = db.data.torrents?.find(t => t.magnet.toLowerCase().includes(hashLower))
    if (torrent && !torrent.completed) {
        torrent.completed = true
        await safeWrite(db)
        console.log('[Persistence] Marked as completed:', torrent.name)
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üì∫ Watchlist: Track seen files to detect new episodes
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function getNewFilesCount(infoHash, currentFiles) {
    const seenFiles = db.data.seenFiles?.[infoHash] || []
    if (seenFiles.length === 0) {
        // First time seeing this torrent, mark all as seen
        updateSeenFiles(infoHash, currentFiles)
        return 0
    }
    // Count files not in seenFiles
    const newFiles = currentFiles.filter(f => !seenFiles.includes(f.name))
    return newFiles.length
}

function updateSeenFiles(infoHash, currentFiles) {
    db.data.seenFiles ||= {}
    db.data.seenFiles[infoHash] = currentFiles.map(f => f.name)
    safeWrite(db).catch(e => console.warn('[Watchlist] Failed to save seenFiles:', e.message))
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üî• v2.3: Cache for isTorrentCompleted (expensive string search)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const completedCache = new Map()  // infoHash -> { value, time }
const COMPLETED_CACHE_TTL = 60000 // 1 minute

// Check if torrent is marked as completed in DB (CACHED)
function isTorrentCompleted(infoHash) {
    const hashLower = infoHash.toLowerCase()

    // Check cache first
    const cached = completedCache.get(hashLower)
    if (cached && Date.now() - cached.time < COMPLETED_CACHE_TTL) {
        return cached.value
    }

    // Expensive search
    const result = db.data.torrents?.some(t =>
        t.magnet.toLowerCase().includes(hashLower) && t.completed === true
    ) || false

    // Cache result
    completedCache.set(hashLower, { value: result, time: Date.now() })

    // üî• Limit cache size
    if (completedCache.size > 100) {
        const firstKey = completedCache.keys().next().value
        completedCache.delete(firstKey)
    }

    return result
}

async function removeTorrentFromDB(infoHash) {
    db.data.torrents ||= []
    const before = db.data.torrents.length
    const hashLower = infoHash.toLowerCase()

    // Case-insensitive match: magnet URI contains infoHash in format urn:btih:HASH
    db.data.torrents = db.data.torrents.filter(t => {
        const magnetLower = t.magnet.toLowerCase()
        const shouldRemove = magnetLower.includes(hashLower)
        if (shouldRemove) {
            console.log('[Persistence] Matching torrent for removal:', t.name)
        }
        return !shouldRemove
    })

    if (db.data.torrents.length < before) {
        await safeWrite(db)
        console.log(`[Persistence] Removed ${before - db.data.torrents.length} torrent(s) from DB:`, infoHash)
    } else {
        console.log('[Persistence] WARNING: No torrent found in DB for hash:', infoHash)
    }
}

// Restore all saved torrents on server startup
export async function restoreTorrents() {
    await db.read()
    const saved = db.data.torrents || []
    console.log(`[Persistence] Restoring ${saved.length} torrents...`)

    for (const { magnet, name } of saved) {
        try {
            await addTorrent(magnet, true) // true = skip saving (already in DB)
            console.log(`[Persistence] Restored: ${name}`)
        } catch (err) {
            console.warn(`[Persistence] Failed to restore ${name}: ${err.message}`)
        }
    }
}

export const addTorrent = (magnetURI, skipSave = false) => {
    return new Promise((resolve, reject) => {
        // Simple duplicate check
        for (const [key, engine] of engines.entries()) {
            if (key === magnetURI) {
                console.log('Torrent engine already exists for this magnet')
                return resolve(formatEngine(engine))
            }
        }

        // Check frozen torrents (Keep-Alive: instant resume!)
        for (const [hash, frozen] of frozenTorrents.entries()) {
            if (frozen.magnetURI === magnetURI || magnetURI.includes(hash)) {
                console.log(`[Keep-Alive] Reusing frozen torrent: ${hash}`)
                const engine = frozen.engine
                frozenTorrents.delete(hash)
                engines.set(magnetURI, engine)
                engines.set(engine.infoHash, engine)
                return resolve(formatEngine(engine))
            }
        }

        const path = process.env.DOWNLOAD_PATH || './downloads'
        console.log('[Torrent] Adding magnet, download path:', path)

        // üî• STRATEGY 1: Tracker Injection
        let enrichedMagnet = magnetURI
        if (magnetURI.startsWith('magnet:?')) {
            const extraTr = PUBLIC_TRACKERS
                .filter(tr => !magnetURI.includes(encodeURIComponent(tr)))
                .map(tr => `&tr=${encodeURIComponent(tr)}`)
                .join('')
            enrichedMagnet += extraTr
            console.log('[Torrent] Injected', PUBLIC_TRACKERS.length, 'public trackers')
        }

        let engine
        try {
            // üî• STRATEGY 2: Eco Mode (20 connections) by default
            engine = torrentStream(enrichedMagnet, {
                path: path,
                connections: 20,       // Eco Mode: RAM-safe limit
                uploads: 0,
                dht: true,             // ‚úÖ DHT enabled
                verify: false,
                tracker: true
            })
        } catch (err) {
            console.error('[Torrent] Failed to create engine:', err.message)
            return reject(err)
        }

        engine.on('ready', () => {
            // ‚úÖ FIX: –û—á–∏—â–∞–µ–º —Ç–∞–π–º–∞—É—Ç –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
            if (engine._timeoutId) {
                clearTimeout(engine._timeoutId)
                delete engine._timeoutId
            }

            console.log('[Torrent] Engine ready:', engine.infoHash)

            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // Download ALL files + AGGRESSIVE PRIORITIZATION
            // Prioritize first video file immediately for instant playback
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            if (engine.files && engine.files.length > 0) {
                let firstVideoIdx = -1
                engine.files.forEach((file, idx) => {
                    file.select()
                    // Find first video file
                    if (firstVideoIdx === -1 && /\.(mp4|mkv|avi|webm|mov)$/i.test(file.name)) {
                        firstVideoIdx = idx
                    }
                })

                // Aggressive priority: immediately prioritize first video
                if (firstVideoIdx >= 0) {
                    console.log(`[Torrent] Auto-prioritizing first video: ${engine.files[firstVideoIdx].name}`)
                    prioritizeFileInternal(engine, firstVideoIdx)
                }
            }

            engines.set(magnetURI, engine)
            engines.set(engine.infoHash, engine)

            // üîÑ Invalidate status cache on new torrent
            invalidateStatusCache()

            // Save to DB for persistence (unless restoring)
            if (!skipSave) {
                saveTorrentToDB(magnetURI, engine.torrent?.name || 'Unknown')
            }

            resolve(formatEngine(engine))
        })

        engine.on('error', (err) => {
            // ‚úÖ FIX: –û—á–∏—â–∞–µ–º —Ç–∞–π–º–∞—É—Ç –ø—Ä–∏ –æ—à–∏–±–∫–µ
            if (engine._timeoutId) {
                clearTimeout(engine._timeoutId)
                delete engine._timeoutId
            }

            console.error('[Torrent] Engine error:', err.message)
            engine.destroy()
            reject(err)
        })

        // üî• STRATEGY 3: Increased Timeout (90s)
        // ‚úÖ FIX: –°–æ—Ö—Ä–∞–Ω—è–µ–º ID —Ç–∞–π–º–∞—É—Ç–∞ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
        const timeoutId = setTimeout(() => {
            if (!engines.has(magnetURI)) {
                console.warn('[Torrent] Timeout: no peers found')
                engine.destroy()
                reject(new Error('Torrent timeout: no peers found within 90 seconds'))
            }
        }, 90000)

        // ‚úÖ FIX: –û—á–∏—â–∞–µ–º —Ç–∞–π–º–∞—É—Ç –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ (–≤–Ω—É—Ç—Ä–∏ engine.on('ready'))
        engine._timeoutId = timeoutId
    })
}

export const removeTorrent = (infoHash, forceDestroy = false) => {
    const engine = engines.get(infoHash)
    if (!engine) return false

    // üîÑ Invalidate status cache on torrent removal
    invalidateStatusCache()

    // Find magnetURI for this engine
    let magnetURI = null
    for (const [key, val] of engines.entries()) {
        if (val === engine && key.startsWith('magnet:')) {
            magnetURI = key
            break
        }
    }

    // Remove from active map
    engines.delete(infoHash)
    // ‚úÖ FIX: –°–æ–±–∏—Ä–∞–µ–º –∫–ª—é—á–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –æ—Ç–¥–µ–ª—å–Ω–æ, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å race condition
    const keysToDelete = []
    for (const [key, val] of engines.entries()) {
        if (val === engine) keysToDelete.push(key)
    }
    for (const key of keysToDelete) {
        engines.delete(key)
    }

    // Keep-Alive: freeze instead of destroy (unless forced)
    if (!forceDestroy) {
        console.log(`[Keep-Alive] Freezing torrent for 30min: ${infoHash}`)
        frozenTorrents.set(infoHash, {
            engine,
            magnetURI,
            frozenAt: Date.now()
        })
    } else {
        console.log('Destroying torrent:', infoHash)
        engine.destroy(() => {
            console.log('Engine destroyed:', infoHash)
        })
    }

    // üî• Memory fix: clear disk cache for this torrent
    diskDownloadCache.delete(infoHash)

    // Remove from persistent storage
    removeTorrentFromDB(infoHash)

    return true
}

export const getTorrent = (infoHash) => {
    const engine = engines.get(infoHash)
    if (engine) return formatEngine(engine)
    return null
}

// Get raw engine for streaming (with createReadStream)
export const getRawTorrent = (infoHash) => {
    return engines.get(infoHash) || null
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üöÄ Status Cache: Reduce CPU load from frequent polling
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let statusCache = null
let statusCacheTime = 0
const STATUS_CACHE_TTL = 5000 // üî• v2.3: increased from 2s to 5s for ARM CPU optimization

export const getAllTorrents = () => {
    const now = Date.now()

    // Return cached result if fresh
    if (statusCache && now - statusCacheTime < STATUS_CACHE_TTL) {
        return statusCache
    }

    // Recalculate and cache
    const uniqueEngines = new Set(engines.values())
    statusCache = Array.from(uniqueEngines).map(formatEngine)
    statusCacheTime = now

    return statusCache
}

// Invalidate cache when torrents change
export const invalidateStatusCache = () => {
    statusCache = null
    statusCacheTime = 0
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Calculate actual downloaded bytes from disk (CACHED)
// Uses background updates to avoid blocking event loop
// üî• Memory fix: added async dedup to prevent parallel storms
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const diskDownloadCache = new Map() // infoHash -> { bytes, updatedAt, updating }
const DISK_CACHE_TTL = 30000 // 30 seconds

// Non-blocking: returns cached value, schedules background update
function getDownloadedFromDisk(engine) {
    const infoHash = engine.infoHash

    // üî• Memory fix: hard cap on cache size
    if (diskDownloadCache.size > 50) {
        console.log('[Memory] Clearing diskDownloadCache (size exceeded 50)')
        diskDownloadCache.clear()
    }

    const cached = diskDownloadCache.get(infoHash)
    const now = Date.now()

    // Return cached value if fresh
    if (cached && now - cached.updatedAt < DISK_CACHE_TTL) {
        return cached.bytes
    }

    // üî• Memory fix: prevent parallel async updates (async dedup)
    if (!cached?.updating) {
        diskDownloadCache.set(infoHash, {
            bytes: cached?.bytes || 0,
            updatedAt: cached?.updatedAt || 0,
            updating: true
        })

        updateDiskCacheAsync(engine).finally(() => {
            const entry = diskDownloadCache.get(infoHash)
            if (entry) entry.updating = false
        })
    }

    // Return stale cache or 0 while updating
    return cached?.bytes || 0
}

// Background async update (doesn't block event loop)
async function updateDiskCacheAsync(engine) {
    const downloadPath = process.env.DOWNLOAD_PATH || './downloads'
    const infoHash = engine.infoHash

    if (!engine.torrent?.name || !engine.files) {
        diskDownloadCache.set(infoHash, { bytes: 0, updatedAt: Date.now() })
        return
    }

    let totalDownloaded = 0

    // Use async fs for non-blocking I/O (static import at top)

    for (const file of engine.files) {
        try {
            const filePath = path.join(downloadPath, file.path)
            const stats = await fsPromises.stat(filePath)
            const actualBytes = (stats.blocks !== undefined)
                ? stats.blocks * 512
                : stats.size
            totalDownloaded += Math.min(actualBytes, file.length)
        } catch (e) {
            // File doesn't exist or not accessible
        }
    }

    diskDownloadCache.set(infoHash, { bytes: totalDownloaded, updatedAt: Date.now() })
}

const formatEngine = (engine) => {
    const totalSize = engine.files?.reduce((sum, f) => sum + f.length, 0) || 0

    // Get downloaded bytes from different sources
    const diskDownloaded = getDownloadedFromDisk(engine)
    const swarmDownloaded = engine.swarm?.downloaded || 0

    // üî• Check if already marked as completed in DB (survives restart)
    const wasCompleted = isTorrentCompleted(engine.infoHash)

    // Determine downloaded bytes:
    // 1. If marked completed in DB ‚Üí use totalSize
    // 2. If swarm has data ‚Üí use swarm (active download)
    // 3. Otherwise ‚Üí use disk (restart scenario, partial download)
    let downloaded
    if (wasCompleted) {
        downloaded = totalSize
    } else if (swarmDownloaded > 0) {
        downloaded = swarmDownloaded
    } else {
        downloaded = diskDownloaded
    }

    // Calculate progress (0-1)
    const progress = totalSize > 0 ? Math.min(downloaded / totalSize, 1) : 0

    // Check if ready (and save completed status if newly completed)
    const isReady = wasCompleted || progress >= 0.99
    if (isReady && !wasCompleted && progress >= 0.99) {
        // Mark as completed in DB (async, fire-and-forget)
        markTorrentCompleted(engine.infoHash)
    }

    // Get download speed
    const downloadSpeed = engine.swarm?.downloadSpeed() || 0

    // Calculate ETA (seconds remaining)
    let eta = null
    if (downloadSpeed > 0 && progress < 1) {
        const remaining = totalSize - downloaded
        eta = Math.round(remaining / downloadSpeed)
    }

    // üì∫ Watchlist: count new files since last check
    const currentFiles = engine.files || []
    const newFilesCount = getNewFilesCount(engine.infoHash, currentFiles)

    return {
        infoHash: engine.infoHash,
        name: engine.torrent?.name || 'Unknown Torrent',
        progress: progress,
        isReady: isReady,
        downloaded: downloaded,
        totalSize: totalSize,
        downloadSpeed: downloadSpeed,
        uploadSpeed: engine.swarm?.uploadSpeed() || 0,
        numPeers: engine.swarm?.wires?.length || 0,
        eta: eta, // seconds remaining
        newFilesCount: newFilesCount, // üì∫ Watchlist: new episodes since last check
        // üî• Memory fix: only include file count, not full array
        // Full files array available via getTorrent(hash) on demand
        fileCount: engine.files?.length || 0,
        files: engine.files ? engine.files.map((file, index) => ({
            name: file.name,
            length: file.length,
            index: index
            // üî• Removed: path (not needed for UI list)
        })) : []
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Smart Priority: Prioritize specific file for instant playback
// Called when user starts streaming a specific episode
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Internal function (accepts engine directly)
function prioritizeFileInternal(engine, fileIndex, byteOffset = 0) {
    const file = engine.files?.[fileIndex]
    if (!file) {
        console.warn('[Priority] File not found:', fileIndex)
        return false
    }

    const pieceLength = engine.torrent?.pieceLength || 262144 // Default 256KB
    const totalPieces = engine.torrent?.pieces?.length || 0

    if (totalPieces === 0 || pieceLength === 0) {
        console.warn('[Priority] No piece info available')
        return false
    }

    // Calculate piece range for this specific file
    const fileStart = (file.offset || 0) + byteOffset
    const fileEnd = (file.offset || 0) + file.length

    const startPiece = Math.floor(fileStart / pieceLength)
    const endPiece = Math.floor(fileEnd / pieceLength)

    // ‚ö° AGGRESSIVE PRIORITY: 50MB instead of 15MB for 4K content
    const priorityBytes = Math.min(file.length * 0.1, 50 * 1024 * 1024) // 10% or 50MB
    const priorityPieces = Math.max(1, Math.ceil(priorityBytes / pieceLength))
    const priorityEnd = Math.min(startPiece + priorityPieces, endPiece)

    try {
        engine.select(startPiece, priorityEnd, true) // true = high priority
        console.log(`[Priority] File ${fileIndex}: pieces ${startPiece}-${priorityEnd} (${priorityPieces} pieces, ~${Math.round(priorityBytes / 1024 / 1024)}MB)`)
        return true
    } catch (e) {
        console.warn('[Priority] Selection failed:', e.message)
        return false
    }
}

// Public API: prioritize by infoHash
export function prioritizeFile(infoHash, fileIndex) {
    const engine = engines.get(infoHash)
    if (!engine) {
        console.warn('[Priority] Engine not found:', infoHash)
        return false
    }
    return prioritizeFileInternal(engine, fileIndex)
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Readahead: Prioritize chunks ahead of seek position
// Called when player seeks to a new position
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export function readahead(infoHash, fileIndex, byteOffset) {
    const engine = engines.get(infoHash)
    if (!engine) {
        console.warn('[Readahead] Engine not found:', infoHash)
        return false
    }
    console.log(`[Readahead] Seeking to byte ${byteOffset} in file ${fileIndex}`)
    return prioritizeFileInternal(engine, fileIndex, byteOffset)
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üî• Turbo Mode: Boost connections when streaming starts
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export const boostTorrent = (infoHash) => {
    const engine = engines.get(infoHash)

    // Debug: why boost might not work
    if (!engine) {
        console.warn(`[Turbo] Engine not found for: ${infoHash}`)
        return
    }
    if (!engine.swarm) {
        console.warn(`[Turbo] No swarm for: ${infoHash}`)
        return
    }

    const currentMax = engine.swarm.maxConnections || 0
    console.log(`[Turbo] Current connections: ${engine.swarm.wires?.length || 0}/${currentMax}`)

    // If still in Eco Mode (< 65), boost it!
    if (currentMax < 65) {
        console.log(`[Turbo] üöÄ Boosting connections for ${infoHash}: ${currentMax} -> 65`)
        engine.swarm.maxConnections = 65
        if (engine.discover) engine.discover()
        engine.swarm.resume()
    } else {
        console.log(`[Turbo] Already boosted (${currentMax}), skipping`)
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ö° Speed Mode: Eco / Balanced / Turbo
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SPEED_MODES = {
    eco: 20,
    balanced: 40,
    turbo: 65
}

export const setSpeedMode = (mode) => {
    const connections = SPEED_MODES[mode] || SPEED_MODES.balanced
    const uniqueEngines = new Set(engines.values())

    for (const engine of uniqueEngines) {
        if (engine.swarm) {
            engine.swarm.maxConnections = connections
            console.log(`[SpeedMode] Set ${engine.infoHash?.slice(0, 8)} to ${mode} (${connections} connections)`)
        }
    }

    console.log(`[SpeedMode] Applied ${mode} mode to ${uniqueEngines.size} torrents`)
    return { mode, connections, torrentsAffected: uniqueEngines.size }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üõë Graceful Shutdown: Destroy all torrents
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export const destroyAllTorrents = () => {
    // ‚úÖ FIX: –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª –æ—á–∏—Å—Ç–∫–∏ frozen torrents
    stopFrozenCleanup()

    console.log(`[Shutdown] Destroying ${engines.size} active engines...`)

    // Destroy all active engines
    const uniqueEngines = new Set(engines.values())
    for (const engine of uniqueEngines) {
        try {
            engine.destroy()
        } catch (e) {
            console.warn('[Shutdown] Engine destroy failed:', e.message)
        }
    }
    engines.clear()

    // Clear frozen torrents
    console.log(`[Shutdown] Clearing ${frozenTorrents.size} frozen torrents...`)
    for (const [hash, frozen] of frozenTorrents.entries()) {
        try {
            frozen.engine.destroy()
        } catch (e) { }
    }
    frozenTorrents.clear()

    console.log('[Shutdown] All torrents destroyed')
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üìä v2.3: Diagnostics helpers
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export const getActiveTorrentsCount = () => engines.size
export const getFrozenTorrentsCount = () => frozenTorrents.size

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üõ°Ô∏è v2.3.3: Graceful Degradation - Memory pressure handling
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

let isDegradedMode = false

/**
 * Enter degraded mode: reduce memory usage
 * - Pause all frozen torrents (destroy them)
 * - Reduce max connections on active torrents
 * - Disable prefetch buffers
 */
export const enterDegradedMode = () => {
    if (isDegradedMode) return { alreadyDegraded: true }

    isDegradedMode = true
    console.log('[Degradation] Entering degraded mode - reducing memory usage')

    let freedCount = 0

    // 1. Clear all frozen torrents (they're just cache)
    for (const [hash, frozen] of frozenTorrents.entries()) {
        try {
            frozen.engine.destroy()
            freedCount++
        } catch (e) { }
    }
    frozenTorrents.clear()
    console.log(`[Degradation] Freed ${freedCount} frozen torrents`)

    // 2. Reduce connections on active torrents (eco mode)
    const uniqueEngines = new Set(engines.values())
    for (const engine of uniqueEngines) {
        if (engine.swarm) {
            engine.swarm.maxConnections = 30 // Minimal connections
        }
    }
    console.log(`[Degradation] Reduced connections on ${uniqueEngines.size} active torrents`)

    // 3. Force garbage collection if available
    if (global.gc) {
        global.gc()
        console.log('[Degradation] Forced garbage collection')
    }

    return {
        freedFrozen: freedCount,
        reducedConnections: uniqueEngines.size,
        mode: 'degraded'
    }
}

/**
 * Exit degraded mode: restore normal operation
 */
export const exitDegradedMode = () => {
    if (!isDegradedMode) return { alreadyNormal: true }

    isDegradedMode = false
    console.log('[Degradation] Exiting degraded mode - restoring normal operation')

    // Restore normal connections (balanced mode)
    const uniqueEngines = new Set(engines.values())
    for (const engine of uniqueEngines) {
        if (engine.swarm) {
            engine.swarm.maxConnections = 55 // Balanced mode default
        }
    }

    return { restoredConnections: uniqueEngines.size, mode: 'normal' }
}

/**
 * Check if currently in degraded mode
 */
export const isInDegradedMode = () => isDegradedMode

```

---

### server/utils/doh.js

```js
import https from 'https';

// --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
const DOH_PROVIDER = process.env.DOH_PROVIDER || 'https://cloudflare-dns.com/dns-query';
const CACHE_TTL_MS = 1000 * 60 * 10; // 10 –º–∏–Ω—É—Ç
const TIMEOUT_MS = 5000;
const DEBUG = process.env.DOH_DEBUG === 'true';

const dnsCache = new Map();

// –ê–≥–µ–Ω—Ç —Å keepAlive –∏ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ–º SSL (–¥–ª—è —Å–∞–º–æ–ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã—Ö –∑–µ—Ä–∫–∞–ª)
export const insecureAgent = new https.Agent({
    rejectUnauthorized: false,
    keepAlive: true,
    keepAliveMsecs: 10000
});

async function resolveIP(hostname) {
    if (dnsCache.has(hostname)) {
        const cached = dnsCache.get(hostname);
        if (Date.now() < cached.expires) return cached.ip;
        dnsCache.delete(hostname);
    }

    try {
        const url = `${DOH_PROVIDER}?name=${encodeURIComponent(hostname)}&type=A`;

        const response = await fetch(url, {
            method: 'GET',
            headers: { 'Accept': 'application/dns-json' },
            signal: AbortSignal.timeout(TIMEOUT_MS)
        });

        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const data = await response.json();

        if (data.Answer && data.Answer.length > 0) {
            const record = data.Answer.find(r => r.type === 1); // Type A (IPv4)
            if (record) {
                const ip = record.data;
                if (DEBUG) console.log(`[DoH] Resolved ${hostname} -> ${ip}`);
                if (dnsCache.size > 1000) dnsCache.clear();
                dnsCache.set(hostname, { ip, expires: Date.now() + CACHE_TTL_MS });
                return ip;
            }
        }
    } catch (e) {
        if (DEBUG) console.error(`[DoH] Error resolving ${hostname}: ${e.message}`);
    }
    return null;
}

export async function getSmartConfig(urlStr, baseOptions = {}) {
    let targetUrl;
    try { targetUrl = new URL(urlStr); } catch (e) { throw new Error(`Invalid URL: ${urlStr}`); }

    const ip = await resolveIP(targetUrl.hostname);

    // –ú–∏–º–∏–∫—Ä–∏—è –ø–æ–¥ –±—Ä–∞—É–∑–µ—Ä
    const headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        ...(baseOptions.headers || {})
    };

    if (ip) {
        const directUrl = urlStr.replace(targetUrl.hostname, ip);
        headers['Host'] = targetUrl.hostname; // –í–∞–∂–Ω–æ –¥–ª—è Cloudflare

        return {
            url: directUrl,
            headers,
            hostname: targetUrl.hostname // –î–ª—è SNI
        };
    } else {
        return { url: urlStr, headers };
    }
}

// –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π fetch —Å DoH
export async function smartFetch(url, options = {}) {
    const config = await getSmartConfig(url, options);

    const fetchOptions = {
        method: options.method || 'GET',
        headers: config.headers,
        signal: AbortSignal.timeout(options.timeout || 10000)
    };

    const response = await fetch(config.url, fetchOptions);

    // –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å axios-style response
    const isJson = response.headers.get('content-type')?.includes('application/json');
    const isImage = response.headers.get('content-type')?.startsWith('image/');

    let data;
    if (options.responseType === 'arraybuffer' || isImage) {
        data = Buffer.from(await response.arrayBuffer());
    } else if (isJson) {
        data = await response.json();
    } else {
        data = await response.text();
    }

    return {
        data,
        status: response.status,
        headers: Object.fromEntries(response.headers.entries())
    };
}

```

---

### server/utils/lag-monitor.js

```js
/**
 * Event Loop Lag Monitor v2.3
 * Detects when Node.js event loop is blocked
 * 
 * v2.3: Adaptive settings for production (less sensitive, less overhead)
 * 
 * Usage:
 *   import { LagMonitor } from './utils/lag-monitor.js'
 *   const lagMonitor = new LagMonitor()  // Auto-detects prod/dev
 *   lagMonitor.start()
 */

export class LagMonitor {
    constructor(threshold = null) {
        // üî• v2.3: Adaptive settings based on environment
        const isProd = process.env.NODE_ENV === 'production'
        
        // Production: less sensitive (200ms threshold, 1s interval)
        // Development: more sensitive for debugging (50ms threshold, 250ms interval)
        this.threshold = threshold ?? (isProd ? 200 : 50)
        this.checkInterval = isProd ? 1000 : 250
        
        this.lastCheck = Date.now()
        this.lagEvents = []
        this.intervalId = null
        this.isProd = isProd
    }

    start() {
        if (this.intervalId) return // Already running

        this.intervalId = setInterval(() => {
            const now = Date.now()
            // üî• v2.3: expected = interval + 50ms tolerance for I/O delays
            const expected = this.checkInterval + 50
            const lag = now - this.lastCheck - expected

            if (lag > this.threshold) {
                const event = {
                    timestamp: now,
                    lag: lag,
                    memory: Math.round(process.memoryUsage().rss / 1024 / 1024)
                }

                this.lagEvents.push(event)
                
                // üî• v2.3: Only log warnings in dev, or critical lags (>1s) in prod
                if (!this.isProd || lag > 1000) {
                    console.warn(`[LagMonitor] Event loop lag: ${lag}ms, RAM: ${event.memory}MB`)
                }

                // Keep only last 50 events
                if (this.lagEvents.length > 50) {
                    this.lagEvents.shift()
                }
            }

            this.lastCheck = now
        }, this.checkInterval)

        console.log(`[LagMonitor] Started (${this.isProd ? 'prod' : 'dev'} mode: ${this.checkInterval}ms interval, ${this.threshold}ms threshold)`)
    }

    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId)
            this.intervalId = null
            console.log('[LagMonitor] Stopped')
        }
    }

    getStats() {
        const now = Date.now()
        const recentLags = this.lagEvents.filter(e =>
            now - e.timestamp < 60000
        )

        return {
            totalLags: this.lagEvents.length,
            recentLags: recentLags.length,
            avgLag: recentLags.length > 0
                ? Math.round(recentLags.reduce((sum, e) => sum + e.lag, 0) / recentLags.length)
                : 0,
            maxLag: recentLags.length > 0
                ? Math.max(...recentLags.map(e => e.lag))
                : 0
        }
    }
}

```

---

### server/utils/logger.js

```js
/**
 * Simple Structured Logger for PWA-TorServe
 * Zero dependencies - works without npm install!
 * 
 * Features:
 * - Timestamps in ISO format
 * - Log levels (debug/info/warn/error)
 * - Configurable via LOG_LEVEL env variable
 * - Module context support
 * 
 * Usage:
 *   import { logger } from './utils/logger.js'
 *   logger.info('Server started', { port: 3000 })
 *   logger.error('Failed to connect', { error: err.message })
 * 
 * Or with module context:
 *   const log = logger.child('Torrent')
 *   log.info('Added torrent', { hash: '...' })
 */

const LOG_LEVELS = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3
}

const currentLevel = LOG_LEVELS[process.env.LOG_LEVEL || 'info'] || LOG_LEVELS.info

/**
 * Format log message with timestamp and level
 */
const formatMessage = (level, module, message, data) => {
    const timestamp = new Date().toISOString()
    const modulePrefix = module ? `[${module}]` : ''
    const dataStr = data && Object.keys(data).length > 0 
        ? ' ' + JSON.stringify(data) 
        : ''
    
    return `[${timestamp}] [${level.toUpperCase()}]${modulePrefix} ${message}${dataStr}`
}

/**
 * Create logger instance optionally bound to a module name
 * ‚úÖ FIX: –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Ä–æ–≤–Ω–µ–π –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
 */
const createLogger = (moduleName = null) => ({
    debug: (message, data = {}) => {
        if (currentLevel <= LOG_LEVELS.debug) {  // ‚úÖ FIX: –±—ã–ª–æ LOG_LEVELS.debug >= currentLevel
            console.log(formatMessage('debug', moduleName, message, data))
        }
    },

    info: (message, data = {}) => {
        if (currentLevel <= LOG_LEVELS.info) {  // ‚úÖ FIX
            console.log(formatMessage('info', moduleName, message, data))
        }
    },

    warn: (message, data = {}) => {
        if (currentLevel <= LOG_LEVELS.warn) {  // ‚úÖ FIX
            console.warn(formatMessage('warn', moduleName, message, data))
        }
    },

    error: (message, data = {}) => {
        if (currentLevel <= LOG_LEVELS.error) {  // ‚úÖ FIX
            console.error(formatMessage('error', moduleName, message, data))
        }
    },

    /**
     * Create child logger with module context
     * @param {string} module - Module name for log prefix
     * @returns {Object} Logger instance with module context
     */
    child: (module) => createLogger(module)
})

export const logger = createLogger()

```

---

### server/utils/retry.js

```js
/**
 * Retry Utility with Exponential Backoff
 * PWA-TorServe v2.3.3
 *
 * Usage:
 *   const result = await withRetry(() => fetchData(), { maxRetries: 3 })
 */

/**
 * Execute async function with retry logic
 * @param {Function} fn - Async function to execute
 * @param {Object} options - Retry options
 * @param {number} options.maxRetries - Maximum retry attempts (default: 3)
 * @param {number} options.baseDelayMs - Base delay in ms (default: 1000)
 * @param {number} options.maxDelayMs - Maximum delay cap (default: 10000)
 * @param {Function} options.shouldRetry - Custom retry condition (default: always retry)
 * @param {Function} options.onRetry - Callback on each retry (optional)
 * @returns {Promise<any>} Result of the function
 */
export const withRetry = async (fn, options = {}) => {
    const {
        maxRetries = 3,
        baseDelayMs = 1000,
        maxDelayMs = 10000,
        shouldRetry = () => true,
        onRetry = null
    } = options

    let lastError

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
            return await fn(attempt)
        } catch (error) {
            lastError = error

            // Check if we should retry
            if (attempt >= maxRetries || !shouldRetry(error, attempt)) {
                throw error
            }

            // Calculate delay with exponential backoff + jitter
            const exponentialDelay = baseDelayMs * Math.pow(2, attempt)
            const jitter = Math.random() * 200 // 0-200ms jitter
            const delay = Math.min(exponentialDelay + jitter, maxDelayMs)

            if (onRetry) {
                onRetry(error, attempt + 1, delay)
            }

            await sleep(delay)
        }
    }

    throw lastError
}

/**
 * Sleep utility
 */
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms))

/**
 * Common retry predicates
 */
export const retryPredicates = {
    // Retry on network errors
    networkError: (error) => {
        const networkCodes = ['ECONNRESET', 'ETIMEDOUT', 'ECONNREFUSED', 'ENOTFOUND', 'EAI_AGAIN']
        return networkCodes.includes(error.code)
    },

    // Retry on HTTP 5xx errors
    serverError: (error) => {
        return error.statusCode >= 500 && error.statusCode < 600
    },

    // Retry on rate limiting (429)
    rateLimited: (error) => {
        return error.statusCode === 429
    },

    // Combined: network + server errors
    transient: (error) => {
        return retryPredicates.networkError(error) ||
               retryPredicates.serverError(error) ||
               retryPredicates.rateLimited(error)
    }
}

```

---

### server/watchdog.js

```js
/**
 * Watchdog Module - Self-Healing Architecture
 * PWA-TorServe v2.3.3
 *
 * Features:
 * - Non-blocking async monitoring loop
 * - RAM monitoring with hysteresis (30s delay for degraded)
 * - NFS Circuit Breaker (3 failures ‚Üí 5min pause)
 * - Automatic counter reset on recovery
 * - üÜï Graceful Degradation: auto-reduce memory on pressure
 */

import { db, safeWrite } from './db.js'
import fs from 'fs'
import path from 'path'
import { checkRules } from './autodownloader.js'
import { enterDegradedMode, exitDegradedMode } from './torrent.js'

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Configuration Constants
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const CONFIG = {
    CHECK_INTERVAL_MS: 30000,           // Main loop interval: 30s
    RAM_OK_THRESHOLD_MB: 800,           // ‚¨Ü Relaxed for 100GB files
    RAM_DEGRADED_THRESHOLD_MB: 1000,    // ‚¨Ü Limit increased to 1GB
    HYSTERESIS_DELAY_MS: 30000,         // 30s delay before degraded
    STORAGE_CHECK_TIMEOUT_MS: 5000,     // 5s timeout for storage check
    CIRCUIT_BREAKER_THRESHOLD: 3,       // 3 failures ‚Üí circuit open
    CIRCUIT_BREAKER_COOLDOWN_MS: 300000 // 5 minutes cooldown
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// State Variables
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

let degradedSince = null              // Timestamp when RAM first exceeded threshold
let circuitOpenUntil = null           // Timestamp when circuit breaker will retry
let isWatchdogRunning = false
let lastAutoDownloadCheck = 0         // Timestamp of last auto-download check

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Helper Functions
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms))

const getRAMUsageMB = () => {
    const used = process.memoryUsage()
    // Use RSS (Resident Set Size) instead of heapUsed
    // RSS includes buffers, video data, and system resources
    // This is what Android actually sees and may kill the process for
    return Math.round(used.rss / 1024 / 1024)
}

/**
 * Check storage accessibility with timeout
 * Creates directory if it doesn't exist
 * PHYSICAL WRITE TEST: writes .healthcheck file to verify R/W access
 * @returns {Promise<boolean>} true if storage is accessible
 */
const checkStorage = () => {
    return new Promise((resolve) => {
        // Default to ./downloads (relative to app dir) which works on Android Termux
        const downloadPath = process.env.DOWNLOAD_PATH || './downloads'
        const healthFile = path.join(downloadPath, '.healthcheck')

        const timeout = setTimeout(() => {
            console.warn('[Watchdog] Storage check timeout!')
            resolve(false)
        }, CONFIG.STORAGE_CHECK_TIMEOUT_MS)

        // Ensure directory exists first
        fs.mkdir(downloadPath, { recursive: true }, (mkdirErr) => {
            if (mkdirErr && mkdirErr.code !== 'EEXIST') {
                clearTimeout(timeout)
                console.warn(`[Watchdog] Failed to create directory: ${mkdirErr.message}`)
                resolve(false)
                return
            }

            // PHYSICAL WRITE TEST: write timestamp to .healthcheck file
            const testData = `healthcheck:${Date.now()}`
            fs.writeFile(healthFile, testData, (writeErr) => {
                if (writeErr) {
                    clearTimeout(timeout)
                    console.warn(`[Watchdog] Write test failed: ${writeErr.message}`)
                    resolve(false)
                    return
                }

                // Clean up: delete the test file
                fs.unlink(healthFile, (unlinkErr) => {
                    clearTimeout(timeout)
                    if (unlinkErr) {
                        // Non-critical: file was written successfully
                        console.warn(`[Watchdog] Cleanup failed: ${unlinkErr.message}`)
                    }
                    resolve(true)
                })
            })
        })
    })
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// State Machine
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Update server status with persistence
 * @param {string} newStatus - 'ok' | 'degraded' | 'error' | 'circuit_open'
 */
const updateStatus = async (newStatus) => {
    const currentStatus = db.data.serverStatus

    if (currentStatus !== newStatus) {
        console.log(`[Watchdog] Status change: ${currentStatus} ‚Üí ${newStatus}`)
        db.data.serverStatus = newStatus
        db.data.lastStateChange = Date.now()

        // üÜï v2.3.3: Graceful Degradation - auto-reduce memory on pressure
        if (newStatus === 'degraded') {
            const result = enterDegradedMode()
            console.log(`[Watchdog] Degradation applied:`, result)
        }

        // Reset counters on recovery to OK
        if (newStatus === 'ok') {
            db.data.storageFailures = 0
            degradedSince = null

            // üÜï v2.3.3: Exit degraded mode on recovery
            const result = exitDegradedMode()
            console.log(`[Watchdog] Recovery applied:`, result)
            console.log('[Watchdog] Recovery complete, counters reset')
        }

        await safeWrite(db)
    }
}

/**
 * Main watchdog check cycle
 */
const performCheck = async () => {
    const now = Date.now()
    const ramMB = getRAMUsageMB()

    // ‚îÄ‚îÄ‚îÄ Circuit Breaker Check ‚îÄ‚îÄ‚îÄ
    if (circuitOpenUntil) {
        if (now < circuitOpenUntil) {
            // Still in cooldown, skip all checks
            const remainingMs = circuitOpenUntil - now
            console.log(`[Watchdog] Circuit open, retry in ${Math.round(remainingMs / 1000)}s`)
            return
        }

        // Cooldown expired, attempt recovery
        console.log('[Watchdog] Circuit breaker: attempting recovery...')
        const storageOk = await checkStorage()

        if (storageOk) {
            circuitOpenUntil = null
            await updateStatus('ok')
            console.log('[Watchdog] Circuit breaker: recovery successful!')
        } else {
            // Retry failed, extend cooldown
            circuitOpenUntil = now + CONFIG.CIRCUIT_BREAKER_COOLDOWN_MS
            // Update lastStateChange so client shows correct elapsed time
            db.data.lastStateChange = now
            await safeWrite(db)
            console.warn('[Watchdog] Circuit breaker: recovery failed, extending cooldown')
        }
        return
    }

    // ‚îÄ‚îÄ‚îÄ Storage Check ‚îÄ‚îÄ‚îÄ
    const storageOk = await checkStorage()

    if (!storageOk) {
        db.data.storageFailures = (db.data.storageFailures || 0) + 1
        console.warn(`[Watchdog] Storage failure #${db.data.storageFailures}`)

        if (db.data.storageFailures >= CONFIG.CIRCUIT_BREAKER_THRESHOLD) {
            circuitOpenUntil = now + CONFIG.CIRCUIT_BREAKER_COOLDOWN_MS
            await updateStatus('circuit_open')
            console.error('[Watchdog] Circuit breaker OPEN! Pausing checks for 5 minutes.')
            return
        }
    } else {
        // Storage OK, reset failure counter
        if (db.data.storageFailures > 0) {
            db.data.storageFailures = 0
            await safeWrite(db)
        }
    }

    // ‚îÄ‚îÄ‚îÄ RAM Check with Hysteresis ‚îÄ‚îÄ‚îÄ
    if (ramMB > CONFIG.RAM_DEGRADED_THRESHOLD_MB) {
        if (!degradedSince) {
            degradedSince = now
            console.log(`[Watchdog] RAM ${ramMB}MB > threshold, starting hysteresis timer`)
        } else if (now - degradedSince >= CONFIG.HYSTERESIS_DELAY_MS) {
            await updateStatus('degraded')
        }
    } else if (ramMB < CONFIG.RAM_OK_THRESHOLD_MB) {
        // RAM is OK
        if (db.data.serverStatus === 'degraded') {
            await updateStatus('ok')
        }
        degradedSince = null
    }

    // Log current state
    console.log(`[Watchdog] RAM: ${ramMB}MB | Status: ${db.data.serverStatus} | Storage Failures: ${db.data.storageFailures}`)

    // ‚îÄ‚îÄ‚îÄ Auto-Downloader Check ‚îÄ‚îÄ‚îÄ
    await runAutoDownloadCheck()
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üì∫ Auto-Downloader Integration
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const runAutoDownloadCheck = async () => {
    const settings = db.data.autoDownloadSettings || { enabled: false, intervalMinutes: 30 }

    if (!settings.enabled) return

    const intervalMs = (settings.intervalMinutes || 30) * 60 * 1000
    const now = Date.now()

    if (now - lastAutoDownloadCheck < intervalMs) return

    lastAutoDownloadCheck = now

    try {
        console.log('[Watchdog] Running auto-download check...')
        const result = await checkRules()
        if (result.downloaded > 0) {
            console.log(`[Watchdog] Auto-downloaded ${result.downloaded} new episode(s)`)
        }
    } catch (err) {
        console.error('[Watchdog] Auto-download check failed:', err.message)
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Public API
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Start the async watchdog loop
 */
export const startWatchdog = async () => {
    if (isWatchdogRunning) {
        console.warn('[Watchdog] Already running!')
        return
    }

    isWatchdogRunning = true
    console.log('[Watchdog] Starting async monitoring loop...')

    // üî• v2.3.2: Reset circuit_open on startup (it persisted from previous session)
    if (db.data.serverStatus === 'circuit_open') {
        console.log('[Watchdog] Detected persisted circuit_open, checking storage...')
        const storageOk = await checkStorage()
        if (storageOk) {
            db.data.serverStatus = 'ok'
            db.data.storageFailures = 0
            circuitOpenUntil = null
            await safeWrite(db)
            console.log('[Watchdog] Storage OK, reset to normal status')
        } else {
            // Storage still broken, keep circuit open with fresh cooldown
            circuitOpenUntil = Date.now() + CONFIG.CIRCUIT_BREAKER_COOLDOWN_MS
            db.data.lastStateChange = Date.now()
            await safeWrite(db)
            console.warn('[Watchdog] Storage still unavailable, circuit remains open')
        }
    }

    // Initial check
    try {
        await performCheck()
    } catch (err) {
        console.error('[Watchdog] Initial check failed:', err.message)
    }

    // Non-blocking loop with error recovery
    while (isWatchdogRunning) {
        await sleep(CONFIG.CHECK_INTERVAL_MS)
        try {
            await performCheck()
        } catch (err) {
            // Log error but DON'T crash - watchdog must survive
            console.error('[Watchdog] Check failed, will retry:', err.message)
        }
    }
}

/**
 * Stop the watchdog loop
 */
export const stopWatchdog = () => {
    isWatchdogRunning = false
    console.log('[Watchdog] Stopped')
}

/**
 * Get current server state for API responses
 */
export const getServerState = () => {
    return {
        serverStatus: db.data.serverStatus,
        lastStateChange: db.data.lastStateChange,
        storageFailures: db.data.storageFailures
    }
}

```

---

