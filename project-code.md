# PWA-TorServe Project Code

> Auto-generated compilation of source files.


**Total Files:** 111
**Total Lines:** 88224

## Table of Contents

- [Dockerfile](#dockerfile)
- [POSTER_BATTLE_HISTORY.md](#poster-battle-history-md)
- [README.md](#readme-md)
- [client/README.md](#client-readme-md)
- [client/android/app/build.gradle](#client-android-app-build-gradle)
- [client/android/app/capacitor.build.gradle](#client-android-app-capacitor-build-gradle)
- [client/android/app/proguard-rules.pro](#client-android-app-proguard-rules-pro)
- [client/android/app/src/androidTest/java/com/getcapacitor/myapp/ExampleInstrumentedTest.java](#client-android-app-src-androidtest-java-com-getcapacitor-myapp-exampleinstrumentedtest-java)
- [client/android/app/src/main/assets/capacitor.config.json](#client-android-app-src-main-assets-capacitor-config-json)
- [client/android/app/src/main/assets/capacitor.plugins.json](#client-android-app-src-main-assets-capacitor-plugins-json)
- [client/android/app/src/main/assets/public/assets/index-BobWrA1F.js](#client-android-app-src-main-assets-public-assets-index-bobwra1f-js)
- [client/android/app/src/main/assets/public/assets/index-DmDSvY7b.css](#client-android-app-src-main-assets-public-assets-index-dmdsvy7b-css)
- [client/android/app/src/main/assets/public/assets/web-C-YL8JOE.js](#client-android-app-src-main-assets-public-assets-web-c-yl8joe-js)
- [client/android/app/src/main/assets/public/assets/web-Du40huiD.js](#client-android-app-src-main-assets-public-assets-web-du40huid-js)
- [client/android/app/src/main/assets/public/assets/web-uZvVC3Zk.js](#client-android-app-src-main-assets-public-assets-web-uzvvc3zk-js)
- [client/android/app/src/main/assets/public/cordova.js](#client-android-app-src-main-assets-public-cordova-js)
- [client/android/app/src/main/assets/public/cordova_plugins.js](#client-android-app-src-main-assets-public-cordova-plugins-js)
- [client/android/app/src/main/assets/public/index.html](#client-android-app-src-main-assets-public-index-html)
- [client/android/app/src/main/assets/public/manifest.json](#client-android-app-src-main-assets-public-manifest-json)
- [client/android/app/src/main/assets/public/sw.js](#client-android-app-src-main-assets-public-sw-js)
- [client/android/app/src/main/java/com/torserve/pwa/MainActivity.java](#client-android-app-src-main-java-com-torserve-pwa-mainactivity-java)
- [client/android/app/src/main/java/com/torserve/pwa/TVPlayer.java](#client-android-app-src-main-java-com-torserve-pwa-tvplayer-java)
- [client/android/app/src/test/java/com/getcapacitor/myapp/ExampleUnitTest.java](#client-android-app-src-test-java-com-getcapacitor-myapp-exampleunittest-java)
- [client/android/build.gradle](#client-android-build-gradle)
- [client/android/capacitor-cordova-android-plugins/build.gradle](#client-android-capacitor-cordova-android-plugins-build-gradle)
- [client/android/capacitor-cordova-android-plugins/cordova.variables.gradle](#client-android-capacitor-cordova-android-plugins-cordova-variables-gradle)
- [client/android/capacitor.settings.gradle](#client-android-capacitor-settings-gradle)
- [client/android/settings.gradle](#client-android-settings-gradle)
- [client/android/variables.gradle](#client-android-variables-gradle)
- [client/capacitor.config.json](#client-capacitor-config-json)
- [client/eslint.config.js](#client-eslint-config-js)
- [client/index.html](#client-index-html)
- [client/package.json](#client-package-json)
- [client/postcss.config.js](#client-postcss-config-js)
- [client/public/manifest.json](#client-public-manifest-json)
- [client/public/sw.js](#client-public-sw-js)
- [client/src/App.css](#client-src-app-css)
- [client/src/App.jsx](#client-src-app-jsx)
- [client/src/components/AutoDownloadPanel.jsx](#client-src-components-autodownloadpanel-jsx)
- [client/src/components/CategoryPage.jsx](#client-src-components-categorypage-jsx)
- [client/src/components/ErrorBoundary.jsx](#client-src-components-errorboundary-jsx)
- [client/src/components/HomePanel.jsx](#client-src-components-homepanel-jsx)
- [client/src/components/HomeRow.jsx](#client-src-components-homerow-jsx)
- [client/src/components/MovieDetail.jsx](#client-src-components-moviedetail-jsx)
- [client/src/components/PersonDetail.jsx](#client-src-components-persondetail-jsx)
- [client/src/components/Poster.jsx](#client-src-components-poster-jsx)
- [client/src/components/SearchPanel.jsx](#client-src-components-searchpanel-jsx)
- [client/src/components/SearchResultItem.jsx](#client-src-components-searchresultitem-jsx)
- [client/src/components/SettingsPanel.jsx](#client-src-components-settingspanel-jsx)
- [client/src/components/Sidebar.jsx](#client-src-components-sidebar-jsx)
- [client/src/components/StatusBanners.jsx](#client-src-components-statusbanners-jsx)
- [client/src/components/TorrentModal.jsx](#client-src-components-torrentmodal-jsx)
- [client/src/hooks/useDebounce.js](#client-src-hooks-usedebounce-js)
- [client/src/hooks/useSpatialNavigation.js](#client-src-hooks-usespatialnavigation-js)
- [client/src/hooks/useTVNavigation.js](#client-src-hooks-usetvnavigation-js)
- [client/src/index.css](#client-src-index-css)
- [client/src/main.jsx](#client-src-main-jsx)
- [client/src/utils/ContentRowsRegistry.js](#client-src-utils-contentrowsregistry-js)
- [client/src/utils/SpatialNavigation.js](#client-src-utils-spatialnavigation-js)
- [client/src/utils/discover.js](#client-src-utils-discover-js)
- [client/src/utils/discover.test.js](#client-src-utils-discover-test-js)
- [client/src/utils/genres.js](#client-src-utils-genres-js)
- [client/src/utils/helpers.js](#client-src-utils-helpers-js)
- [client/src/utils/helpers.test.js](#client-src-utils-helpers-test-js)
- [client/src/utils/tmdbClient.js](#client-src-utils-tmdbclient-js)
- [client/tailwind.config.js](#client-tailwind-config-js)
- [client/vite.config.js](#client-vite-config-js)
- [client/vitest.config.js](#client-vitest-config-js)
- [db.json](#db-json)
- [docker-compose.synology.yml](#docker-compose-synology-yml)
- [docker-compose.yml](#docker-compose-yml)
- [docs/API_SECURITY.md](#docs-api-security-md)
- [docs/CLOUDFLARE_WORKER_SETUP.md](#docs-cloudflare-worker-setup-md)
- [docs/LAMPAC_FULL_PROJECT_CODE.md](#docs-lampac-full-project-code-md)
- [docs/TMDB_CENSORSHIP_ANALYSIS.md](#docs-tmdb-censorship-analysis-md)
- [docs/claude.md](#docs-claude-md)
- [package.json](#package-json)
- [roadmap.md](#roadmap-md)
- [server/__tests__/logger.test.js](#server-tests-logger-test-js)
- [server/__tests__/run-tests.js](#server-tests-run-tests-js)
- [server/__tests__/test-runner.js](#server-tests-test-runner-js)
- [server/__tests__/torrent.test.js](#server-tests-torrent-test-js)
- [server/__tests__/watchdog.test.js](#server-tests-watchdog-test-js)
- [server/aggregator.js](#server-aggregator-js)
- [server/autodownloader.js](#server-autodownloader-js)
- [server/db.js](#server-db-js)
- [server/dbQueue.js](#server-dbqueue-js)
- [server/index.js](#server-index-js)
- [server/jacred.js](#server-jacred-js)
- [server/providers/BaseProvider.js](#server-providers-baseprovider-js)
- [server/providers/JacredProvider.js](#server-providers-jacredprovider-js)
- [server/providers/ProviderManager.js](#server-providers-providermanager-js)
- [server/providers/RuTrackerProvider.js](#server-providers-rutrackerprovider-js)
- [server/providers/RutorProvider.js](#server-providers-rutorprovider-js)
- [server/providers/TorLookProvider.js](#server-providers-torlookprovider-js)
- [server/providers/index.js](#server-providers-index-js)
- [server/routes/proxy.js](#server-routes-proxy-js)
- [server/rutracker.js](#server-rutracker-js)
- [server/searchCache.js](#server-searchcache-js)
- [server/torrent.js](#server-torrent-js)
- [server/utils/doh.js](#server-utils-doh-js)
- [server/utils/lag-monitor.js](#server-utils-lag-monitor-js)
- [server/utils/logger.js](#server-utils-logger-js)
- [server/utils/retry.js](#server-utils-retry-js)
- [server/watchdog.js](#server-watchdog-js)
- [skills/capacitor-bridge/SKILL.md](#skills-capacitor-bridge-skill-md)
- [skills/capacitor-bridge/references/TVPlayer.java](#skills-capacitor-bridge-references-tvplayer-java)
- [skills/resilience-core/SKILL.md](#skills-resilience-core-skill-md)
- [skills/resilience-core/references/doh_guide.md](#skills-resilience-core-references-doh-guide-md)
- [skills/tv-navigator/SKILL.md](#skills-tv-navigator-skill-md)
- [skills/tv-navigator/assets/FocusableGrid.jsx](#skills-tv-navigator-assets-focusablegrid-jsx)

---

## Dockerfile

```dockerfile
# PWA-TorServe Docker Image
# Multi-stage build: Client + Server

# ‚îÄ‚îÄ‚îÄ Stage 1: Build Client ‚îÄ‚îÄ‚îÄ
# ‚îÄ‚îÄ‚îÄ Stage 1: Client Builder ‚îÄ‚îÄ‚îÄ
FROM node:20-slim AS client-builder
WORKDIR /app/client
COPY client/package*.json ./
RUN npm ci
COPY client/ ./
RUN npm run build

# ‚îÄ‚îÄ‚îÄ Stage 2: Server Dependency Builder ‚îÄ‚îÄ‚îÄ
FROM node:20-slim AS server-builder
WORKDIR /app
# Install build tools for native modules (python3, make, g++)
RUN apt-get update && apt-get install -y python3 make g++ && rm -rf /var/lib/apt/lists/*
COPY package*.json ./
# Install ALL dependencies (including devDependencies if needed for build, but usually --only=production is fine if no build steps)
# We use --only=production to avoid dev deps, but we need build tools.
RUN npm ci --only=production

# ‚îÄ‚îÄ‚îÄ Stage 3: Final Production Image ‚îÄ‚îÄ‚îÄ
FROM node:20-slim

# Install runtime dependencies (ffmpeg only)
RUN apt-get update && \
    apt-get install -y ffmpeg curl && \
    rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy built node_modules from builder
COPY --from=server-builder /app/node_modules ./node_modules
# Copy built client from client-builder
COPY --from=client-builder /app/client/dist ./client/dist
# Copy project files
COPY package*.json ./
COPY server/ ./server/

# Create directories
RUN mkdir -p /app/downloads /app/data && \
    echo '{"serverStatus":"ok","lastStateChange":0,"storageFailures":0,"progress":{}}' > /app/data/db.json

# Expose port
EXPOSE 3000

# Environment defaults
ENV DOWNLOAD_PATH=/app/downloads
ENV DB_PATH=/app/data/db.json
ENV NODE_ENV=production

# Health check (using curl)
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s \
    CMD curl -f http://localhost:3000/api/health || exit 1

# Start server
CMD ["node", "server/index.js"]

```

---

## POSTER_BATTLE_HISTORY.md

```markdown
# ‚öîÔ∏è –•—Ä–æ–Ω–∏–∫–∏ –ë–∏—Ç–≤—ã –∑–∞ –ü–æ—Å—Ç–µ—Ä—ã: TMDB vs ISP

–≠—Ç–æ –¥–µ—Ç–∞–ª—å–Ω—ã–π –ª–æ–≥ –Ω–∞—à–µ–π –≤–æ–π–Ω—ã —Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞–º–∏ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ –∑–∞ –ø—Ä–∞–≤–æ –≤–∏–¥–µ—Ç—å –æ–±–ª–æ–∂–∫–∏ —Ñ–∏–ª—å–º–æ–≤.

## üõë –ü—Ä–æ–ª–æ–≥: –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞
**–ü—Ä–æ–±–ª–µ–º–∞:** –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –Ω–∞ —Ç–µ–ª–µ–≤–∏–∑–æ—Ä–µ (Android TV) –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞–ª–æ –∫–∞—Ä—Ç–∏–Ω–∫–∏.
**–ü—Ä–∏—á–∏–Ω–∞:** –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ `api.themoviedb.org` –∏ `image.tmdb.org` –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–º (–†–ö–ù).
**–ü–µ—Ä–≤–æ–µ —Ä–µ—à–µ–Ω–∏–µ:** –ú—ã —Ä–µ—à–∏–ª–∏ —Å–¥–µ–ª–∞—Ç—å **Server-Side Proxy** –Ω–∞ Node.js (NAS), —á—Ç–æ–±—ã —Ç–µ–ª–µ–≤–∏–∑–æ—Ä –æ–±—Ä–∞—â–∞–ª—Å—è –∫ –ª–æ–∫–∞–ª—å–Ω–æ–º—É —Å–µ—Ä–≤–µ—Ä—É, –∞ —Å–µ—Ä–≤–µ—Ä —É–∂–µ —à–µ–ª –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç.

---

## üé≠ –ê–∫—Ç 1: –ó–µ—Ä–∫–∞–ª—å–Ω—ã–µ –í–æ–π–Ω—ã
–°–µ—Ä–≤–µ—Ä (NAS) —Ç–æ–∂–µ –æ–∫–∞–∑–∞–ª—Å—è –ø–æ–¥ –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞. –ú—ã –Ω–∞—á–∞–ª–∏ –ø–µ—Ä–µ–±–∏—Ä–∞—Ç—å "–ø–∏—Ä–∞—Ç—Å–∫–∏–µ" –∑–µ—Ä–∫–∞–ª–∞.

### –ü–æ–ø—ã—Ç–∫–∞ ‚Ññ1: `apitmdb.cub.watch`
*   **–ò–¥–µ—è:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ–ø—É–ª—è—Ä–Ω–æ–µ –∑–µ—Ä–∫–∞–ª–æ –æ—Ç —Å–µ—Ä–≤–∏—Å–∞ Lampa.
*   **–†–µ–∑—É–ª—å—Ç–∞—Ç:** `JSON Parse Error: <!doctype html>`.
*   **–ê–Ω–∞–ª–∏–∑:** –ó–µ—Ä–∫–∞–ª–æ –∑–∞—â–∏—â–µ–Ω–æ Cloudflare –∏–ª–∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ–π —Å–∏—Å—Ç–µ–º–æ–π ("Checking your browser"), –∫–æ—Ç–æ—Ä–∞—è –æ—Ç–¥–∞–µ—Ç HTML-–∫–∞–ø—á—É –≤–º–µ—Å—Ç–æ JSON-–æ—Ç–≤–µ—Ç–∞ –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–º–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã —Å —Å–µ—Ä–≤–µ—Ä–∞.

### –ü–æ–ø—ã—Ç–∫–∞ ‚Ññ2: `api.tmdb.best`
*   **–ò–¥–µ—è:** –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–µ –∑–µ—Ä–∫–∞–ª–æ.
*   **–†–µ–∑—É–ª—å—Ç–∞—Ç:** –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ. –°–µ—Ä–≤–µ—Ä –ø–æ–ª—É—á–∞–µ—Ç HTML —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å –æ—à–∏–±–∫–æ–π –¥–æ—Å—Ç—É–ø–∞ –∏–ª–∏ –∑–∞–≥–ª—É—à–∫—É —Ö–æ—Å—Ç–∏–Ω–≥–∞.

### –ü–æ–ø—ã—Ç–∫–∞ ‚Ññ3: `api.1080.club`
*   **–ò–¥–µ—è:** "–ñ–µ–ª–µ–∑–æ–±–µ—Ç–æ–Ω–Ω–æ–µ" –∑–µ—Ä–∫–∞–ª–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–µ –º–Ω–æ–≥–∏–º–∏ –±–∞–ª–∞–Ω—Å–µ—Ä–∞–º–∏.
*   **–†–µ–∑—É–ª—å—Ç–∞—Ç:** `fetch failed` / `UDP Timeout`. –ü—Ä–æ–≤–∞–π–¥–µ—Ä –±–ª–æ–∫–∏—Ä—É–µ—Ç IP-–∞–¥—Ä–µ—Å–∞ —ç—Ç–æ–≥–æ –∑–µ—Ä–∫–∞–ª–∞ –Ω–∞ —É—Ä–æ–≤–Ω–µ DNS –∏–ª–∏ DPI.
*   **–•–∞–∫–∏:** –ú—ã –ø—Ä–æ–±–æ–≤–∞–ª–∏ –æ—Ç–∫–ª—é—á–∞—Ç—å SSL-–ø—Ä–æ–≤–µ—Ä–∫—É (`NODE_TLS_REJECT_UNAUTHORIZED = '0'`), –º–µ–Ω—è—Ç—å `User-Agent` –Ω–∞ Chrome/Windows, –¥–æ–±–∞–≤–ª—è—Ç—å `Referer`. –ë–µ—Å–ø–æ–ª–µ–∑–Ω–æ.

---

## üõ† –ê–∫—Ç 2: –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –ò–∑–æ—â—Ä–µ–Ω–∏—è

–ö–æ–≥–¥–∞ –ø—Ä—è–º—ã–µ –∑–µ—Ä–∫–∞–ª–∞ –ø–∞–ª–∏, –º—ã –ø–µ—Ä–µ—à–ª–∏ –∫ "—Ç—É–Ω–Ω–µ–ª–∏—Ä–æ–≤–∞–Ω–∏—é".

### –ü–æ–ø—ã—Ç–∫–∞ ‚Ññ4: Google Translate Hack ü•ã
*   **–ò–¥–µ—è:** –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å —Ç—Ä–∞—Ñ–∏–∫ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫ Google (`api-themoviedb-org.translate.goog`). –¢—Ä–∞—Ñ–∏–∫ –≤—ã–≥–ª—è–¥–∏—Ç –¥–ª—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ –∫–∞–∫ –ª–µ–≥–∞–ª—å–Ω—ã–π –ø–æ—Ö–æ–¥ –≤ Google.
*   **–†–µ–∑—É–ª—å—Ç–∞—Ç:** **–û—à–∏–±–∫–∞ 408 (Timeout)** –∏ HTML —Å —Ç–µ–∫—Å—Ç–æ–º "Can't translate this page".
*   **–ü—Ä–∏—á–∏–Ω–∞:** Google —Ä–∞—Å–ø–æ–∑–Ω–∞–ª, —á—Ç–æ –º—ã –≥–æ–Ω—è–µ–º —á–µ—Ä–µ–∑ –Ω–µ–≥–æ API-–∑–∞–ø—Ä–æ—Å—ã (JSON), –∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª —ç—Ç–æ—Ç —Ç—Ä—é–∫ –¥–ª—è –Ω–∞—à–µ–≥–æ IP.

### –ü–æ–ø—ã—Ç–∫–∞ ‚Ññ5: `corsproxy.io`
*   **–ò–¥–µ—è:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—É–±–ª–∏—á–Ω—ã–π CORS-–ø—Ä–æ–∫—Å–∏.
*   **–†–µ–∑—É–ª—å—Ç–∞—Ç:** `Cloudflare Block`. –°–µ—Ä–≤–∏—Å `corsproxy` —Å–∞–º –ø–æ —Å–µ–±–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –Ω–æ TMDB (—Ü–µ–ª–µ–≤–æ–π —Å–∞–π—Ç) –±–ª–æ–∫–∏—Ä—É–µ—Ç –∑–∞–ø—Ä–æ—Å—ã, –ø—Ä–∏—Ö–æ–¥—è—â–∏–µ –æ—Ç —ç—Ç–æ–≥–æ –ø—Ä–æ–∫—Å–∏, –ª–∏–±–æ –ø—Ä–æ–≤–∞–π–¥–µ—Ä –±–ª–æ–∫–∏—Ä—É–µ—Ç —Å–∞–º –ø—Ä–æ–∫—Å–∏.

### –ü–æ–ø—ã—Ç–∫–∞ ‚Ññ6: –ü—É–±–ª–∏—á–Ω—ã–µ CDN (`allorigins.win` + `wsrv.nl`)
*   **–ò–¥–µ—è:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `allorigins` –¥–ª—è JSON –∏ `wsrv.nl` (Image Proxy) –¥–ª—è –∫–∞—Ä—Ç–∏–Ω–æ–∫.
*   **–†–µ–∑—É–ª—å—Ç–∞—Ç:**
    *   –ü–æ–∏—Å–∫: –ß–∞—Å—Ç–∏—á–Ω–æ —Ä–∞–±–æ—Ç–∞–ª, –Ω–æ –æ—á–µ–Ω—å –º–µ–¥–ª–µ–Ω–Ω–æ.
    *   –ö–∞—Ä—Ç–∏–Ω–∫–∏: –û—à–∏–±–∫–∏ 500.
    *   **–ò—Ç–æ–≥:** –°–µ—Ä–≤–µ—Ä –Ω–∞—á–∞–ª "–∑–∞—Ö–ª–µ–±—ã–≤–∞—Ç—å—Å—è" —Ç–∞–π–º–∞—É—Ç–∞–º–∏, –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –Ω–∞ –¢–í —Å—Ç–∞–ª —Ç–æ—Ä–º–æ–∑–∏—Ç—å (—Ñ—Ä–∏–∑—ã –ø—Ä–∏ –ø—Ä–æ–∫—Ä—É—Ç–∫–µ), —Ç–∞–∫ –∫–∞–∫ –æ–∂–∏–¥–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞ –∑–∞–Ω–∏–º–∞–ª–æ —Å–µ–∫—É–Ω–¥—ã.

---

## üè≥Ô∏è –≠–ø–∏–ª–æ–≥ (–í—Ä–µ–º–µ–Ω–Ω—ã–π): Offline Mode
–ú—ã –ø–æ–Ω—è–ª–∏, —á—Ç–æ –±–µ–∑ VPN –Ω–∞ —É—Ä–æ–≤–Ω–µ —Ä–æ—É—Ç–µ—Ä–∞/NAS –ø—Ä–æ–±–∏—Ç—å —ç—Ç—É —Å—Ç–µ–Ω—É **—Å–µ—Ä–≤–µ—Ä–Ω—ã–º–∏ –º–µ—Ç–æ–¥–∞–º–∏** –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ. –ú—ã –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–∏–ª–∏ –ø—Ä–æ–∫—Å–∏ (404 stubs) –∏ —Å–¥–µ–ª–∞–ª–∏ –∫—Ä–∞—Å–∏–≤—ã–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç—ã, —á—Ç–æ–±—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å "–ª–µ—Ç–∞–ª".

---

## üöÄ –ê–∫—Ç 3: –í–æ–∑—Ä–æ–∂–¥–µ–Ω–∏–µ (Full Client Strategy)

–ü–æ—Å–ª–µ –∞–Ω–∞–ª–∏–∑–∞ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã Lampa –º—ã –ø–æ–Ω—è–ª–∏ –æ—à–∏–±–∫—É: **–º—ã –ø—ã—Ç–∞–ª–∏—Å—å –ø—Ä–æ–∫—Å–∏—Ä–æ–≤–∞—Ç—å —Ç—Ä–∞—Ñ–∏–∫ —á–µ—Ä–µ–∑ –°–µ—Ä–≤–µ—Ä (NAS)**, –∫–æ—Ç–æ—Ä—ã–π –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ç–æ–π –∂–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —Å–µ—Ç–∏, –Ω–æ –º–µ–Ω–µ–µ "–≥–∏–±–æ–∫", —á–µ–º –±—Ä–∞—É–∑–µ—Ä –∫–ª–∏–µ–Ω—Ç–∞.

### –°–º–µ–Ω–∞ –ø–∞—Ä–∞–¥–∏–≥–º—ã:
–ú—ã –ø–µ—Ä–µ–Ω–µ—Å–ª–∏ –í–°–Æ –ª–æ–≥–∏–∫—É –∑–∞–≥—Ä—É–∑–∫–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –Ω–∞ **–ö–ª–∏–µ–Ω—Ç (–¢–í)**, –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏—Å–∫–ª—é—á–∏–≤ –ª–æ–∫–∞–ª—å–Ω—ã–π Node.js —Å–µ—Ä–≤–µ—Ä –∏–∑ —Ü–µ–ø–æ—á–∫–∏ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ—Å—Ç–µ—Ä–æ–≤.

### –ü–æ–±–µ–¥–Ω–∞—è —Å—Ö–µ–º–∞:
1.  **–ü–æ–∏—Å–∫ (Metadata):** –ö–ª–∏–µ–Ω—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `api.allorigins.win` (CORS-Proxy).
    *   *–ó–∞—á–µ–º:* –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å JSON —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Ñ–∏–ª—å–º–µ (title, poster_path).
    *   *–ü–æ—á–µ–º—É —Ä–∞–±–æ—Ç–∞–µ—Ç:* –¢–µ–ª–µ–≤–∏–∑–æ—Ä –∏–¥–µ—Ç –Ω–∞ `allorigins.win` (–∫–æ—Ç–æ—Ä—ã–π –æ–±—ã—á–Ω–æ –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è), –∞ —Ç–æ—Ç —É–∂–µ –∏–¥–µ—Ç –≤ TMDB –∏–∑ "—Å–≤–æ–±–æ–¥–Ω–æ–π –∑–æ–Ω—ã".
2.  **–ö–∞—Ä—Ç–∏–Ω–∫–∞ (Image):** –ö–ª–∏–µ–Ω—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `wsrv.nl` (Image CDN).
    *   *–ó–∞—á–µ–º:* –ü–æ–ª—É—á–∏—Ç—å –±–∏–Ω–∞—Ä–Ω–∏–∫ –∫–∞—Ä—Ç–∏–Ω–∫–∏.
    *   *Warum —Ä–∞–±–æ—Ç–∞–µ—Ç:* –¢—Ä–∞—Ñ–∏–∫ –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ –æ–±—ã—á–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ä—Ç–∏–Ω–∫–∏ —Å–æ —Å—Ç–æ—Ä–æ–Ω–Ω–µ–≥–æ CDN, –∞ –Ω–µ –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ –∑–∞–ø—Ä–µ—â–µ–Ω–Ω–æ–º—É `tmdb.org`.
3.  **Fallback (–°—Ç—Ä–∞—Ö–æ–≤–∫–∞):**
    *   –ï—Å–ª–∏ –¥–∞–∂–µ —ç—Ç–∏ –º–µ—Ç–æ–¥—ã –Ω–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–∏ –æ—Ç–≤–∞–ª–µ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞), –∫–ª–∏–µ–Ω—Ç **–º–≥–Ω–æ–≤–µ–Ω–Ω–æ** —Ä–∏—Å—É–µ—Ç –Ω–∞—à–∏ –∫—Ä–∞—Å–∏–≤—ã–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç—ã.

### –ò—Ç–æ–≥ –ë–∏—Ç–≤—ã: üèÜ WIN
*   **–ü–æ—Å—Ç–µ—Ä—ã:** –ï–°–¢–¨ (–≥—Ä—É–∑—è—Ç—Å—è —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏).
*   **–°–∫–æ—Ä–æ—Å—Ç—å:** –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–ê–Ø (—Å–µ—Ä–≤–µ—Ä –Ω–µ —Ç—É–ø–∏—Ç, –∫–ª–∏–µ–Ω—Ç –≥—Ä—É–∑–∏—Ç –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ).
*   **–°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å:** 100% (Offline Fallback –≤—Å–µ–≥–¥–∞ –Ω–∞ —Å—Ç—Ä–∞–∂–µ).

---

## üîç –ê–∫—Ç 4: –ì–ª—É–±–∏–Ω–Ω–∞—è –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ (–î–µ–∫–∞–±—Ä—å 2024)

### –°–∏–º–ø—Ç–æ–º—ã:
–ü–æ—Å—Ç–µ—Ä—ã –ø–µ—Ä–µ—Å—Ç–∞–ª–∏ –≥—Ä—É–∑–∏—Ç—å—Å—è –¥–∞–∂–µ —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏. –î–æ–±–∞–≤–∏–ª–∏ –∫–Ω–æ–ø–∫—É "üß™ –¢–µ—Å—Ç –∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ—Å—Ç–µ—Ä–æ–≤" –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏.

### –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–∞:
```
üß™ –¢–µ—Å—Ç –ø–æ—Å—Ç–µ—Ä–∞: "The Beekeeper"

1Ô∏è‚É£ CapacitorHttp: ‚ùå –û—à–∏–±–∫–∞: Failed to connect to api.themoviedb.org/127.0.0.1:443
2Ô∏è‚É£ corsproxy.io: ‚ùå HTTP 403
```

### –î–∏–∞–≥–Ω–æ–∑: üö® DNS Poisoning
–ü—Ä–æ–≤–∞–π–¥–µ—Ä –ø–æ–¥–º–µ–Ω—è–µ—Ç DNS ‚Äî `api.themoviedb.org` —Ä–µ–∑–æ–ª–≤–∏—Ç—Å—è –≤ `127.0.0.1` (localhost)!
–≠—Ç–æ –Ω–µ –ø—Ä–æ—Å—Ç–æ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ ‚Äî —ç—Ç–æ **–æ—Ç—Ä–∞–≤–ª–µ–Ω–∏–µ DNS-–∫—ç—à–∞**.

### –ö–∞–∫ Lampa —Ä–µ—à–∞–µ—Ç —ç—Ç—É –ø—Ä–æ–±–ª–µ–º—É:
–ò–∑—É—á–∏–ª–∏ –∏—Å—Ö–æ–¥–Ω–∏–∫–∏ Lampa ‚Äî –æ–Ω–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç **DNS-over-HTTPS (Quad9)**:
```kotlin
val dns = DnsOverHttps.Builder()
    .url("https://dns.quad9.net/dns-query")
    .bootstrapDnsHosts(InetAddress.getByName("9.9.9.9"))
    .build()
```

### –ù–∞—à–∏ —Ä–µ—à–µ–Ω–∏—è:

#### 1Ô∏è‚É£ VPN ‚úÖ
**–†–µ–∑—É–ª—å—Ç–∞—Ç:** –†–∞–±–æ—Ç–∞–µ—Ç! –° VPN —Ç–µ—Å—Ç –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç:
```
1Ô∏è‚É£ CapacitorHttp: ‚úÖ –ù–∞–π–¥–µ–Ω–æ: –ü—á–µ–ª–æ–≤–æ–¥
2Ô∏è‚É£ corsproxy.io: ‚úÖ –ù–∞–π–¥–µ–Ω–æ: –ü—á–µ–ª–æ–≤–æ–¥
```

#### 2Ô∏è‚É£ –°–º–µ–Ω–∞ DNS –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ
–ù–∞—Å—Ç—Ä–æ–∏—Ç—å DNS –Ω–∞ —Ä–æ—É—Ç–µ—Ä–µ –∏–ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ:
- **Cloudflare:** `1.1.1.1`
- **Google:** `8.8.8.8`
- **Quad9:** `9.9.9.9`

#### 3Ô∏è‚É£ –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã–π TMDB Proxy (–∫–∞–∫ –≤ Lampa)
–î–æ–±–∞–≤–∏–ª–∏ –≤ Settings ‚Üí Advanced ‚Üí **TMDB API Proxy**
–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç —É–∫–∞–∑–∞—Ç—å —Å–≤–æ–π –ø—Ä–æ–∫—Å–∏ –¥–ª—è –æ–±—Ö–æ–¥–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏.

---

## üèÜ –ê–∫—Ç 5: –§–∏–Ω–∞–ª—å–Ω–∞—è –ü–æ–±–µ–¥–∞ (–î–µ–∫–∞–±—Ä—å 2024)

### –ò–∑—É—á–µ–Ω–∏–µ –ø–ª–∞–≥–∏–Ω–æ–≤ Lampa
–ù–∞—à–ª–∏ –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏ Lampa –≥–æ—Ç–æ–≤—ã–µ —Ä–µ—à–µ–Ω–∏—è:
- `tmdb_proxy.js` ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `apn-latest.onrender.com`
- `kp_source.js` ‚Äî –ö–∏–Ω–æ–ø–æ–∏—Å–∫ API –∫–∞–∫ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ TMDB
- `cloudflare_worker.js` ‚Äî –∫–æ–¥ –¥–ª—è —Ä–∞–∑–≤—ë—Ä—Ç—ã–≤–∞–Ω–∏—è —Å–≤–æ–µ–≥–æ –ø—Ä–æ–∫—Å–∏

### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Ä–µ—à–µ–Ω–∏–π
1. **Lampa Proxy** (`apn-latest.onrender.com`) ‚Äî –¥–æ–±–∞–≤–ª–µ–Ω –∫–∞–∫ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π fallback
2. **–ö–∏–Ω–æ–ø–æ–∏—Å–∫ API** ‚Äî –¥–æ–±–∞–≤–ª–µ–Ω –∫–∞–∫ –ø–æ—Å–ª–µ–¥–Ω–∏–π fallback –µ—Å–ª–∏ TMDB –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç
3. **–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è Cloudflare Worker** ‚Äî —Å–æ–∑–¥–∞–Ω–∞ –¥–ª—è —Ä–∞–∑–≤—ë—Ä—Ç—ã–≤–∞–Ω–∏—è –ª–∏—á–Ω–æ–≥–æ –ø—Ä–æ–∫—Å–∏

### –§–∏–Ω–∞–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ fetchPoster:
```
1Ô∏è‚É£ –ö–∞—Å—Ç–æ–º–Ω—ã–π –ø—Ä–æ–∫—Å–∏ (–µ—Å–ª–∏ –∑–∞–¥–∞–Ω –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö)
      ‚Üì (fallback)
2Ô∏è‚É£ Lampa Proxy (apn-latest.onrender.com) ‚Üê –†–ê–ë–û–¢–ê–ï–¢ –ë–ï–ó VPN!
      ‚Üì (fallback)
3Ô∏è‚É£ CapacitorHttp –∫ TMDB –Ω–∞–ø—Ä—è–º—É—é (—Ç—Ä–µ–±—É–µ—Ç VPN/DNS)
      ‚Üì (fallback)  
4Ô∏è‚É£ corsproxy.io (CORS –ø—Ä–æ–∫—Å–∏ –¥–ª—è –±—Ä–∞—É–∑–µ—Ä–∞)
      ‚Üì (fallback)
5Ô∏è‚É£ –ö–∏–Ω–æ–ø–æ–∏—Å–∫ API (kinopoiskapiunofficial.tech) ‚Üê –ê–õ–¨–¢–ï–†–ù–ê–¢–ò–í–ê TMDB
      ‚Üì (fallback)
6Ô∏è‚É£ –ö—Ä–∞—Å–∏–≤—ã–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç—ã üé®
```

### –ò—Ç–æ–≥: üèÜ VICTORY!
*   **–ü–æ—Å—Ç–µ—Ä—ã –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –ë–ï–ó VPN** —á–µ—Ä–µ–∑ Lampa Proxy
*   **–ü–æ—Å—Ç–µ—Ä—ã –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –° VPN** –Ω–∞–ø—Ä—è–º—É—é
*   **5-—É—Ä–æ–≤–Ω–µ–≤—ã–π fallback** ‚Äî –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç—å
*   **–ö–∏–Ω–æ–ø–æ–∏—Å–∫ –∫–∞–∫ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞** ‚Äî –µ—Å–ª–∏ TMDB –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–±–ª–æ–∫–∏—Ä—É—é—Ç
*   **–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –¥–ª—è —Å–≤–æ–µ–≥–æ Worker** ‚Äî –Ω–∞ —Å–ª—É—á–∞–π –æ—Ç–∫–ª—é—á–µ–Ω–∏—è —á—É–∂–∏—Ö –ø—Ä–æ–∫—Å–∏

---

## üîê –ê–∫—Ç 6: –°–µ—Ä–≤–µ—Ä–Ω—ã–π DoH (–î–µ–∫–∞–±—Ä—å 2024)

### –ü—Ä–æ–±–ª–µ–º–∞
Lampa Proxy –Ω–∞ Render.com "–∑–∞—Å—ã–ø–∞–µ—Ç" –ø—Ä–∏ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏, –≤—ã–∑—ã–≤–∞—è –∑–∞–¥–µ—Ä–∂–∫–∏ cold start.
–ö–ª–∏–µ–Ω—Ç—Å–∫–∏–π fallback —Ä–∞–±–æ—Ç–∞–ª, –Ω–æ –º—ã —Ä–µ—à–∏–ª–∏ —É—Å–∏–ª–∏—Ç—å —Å–µ—Ä–≤–µ—Ä–Ω—É—é —á–∞—Å—Ç—å.

### –†–µ—à–µ–Ω–∏–µ: DNS-over-HTTPS –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ

–°–æ–∑–¥–∞–Ω –º–æ–¥—É–ª—å `server/utils/doh.js`:

```javascript
// –†–µ–∑–æ–ª–≤–∏–º IP —á–µ—Ä–µ–∑ Cloudflare DoH
const DOH_PROVIDER = 'https://cloudflare-dns.com/dns-query';

async function resolveIP(hostname) {
    const response = await fetch(DOH_PROVIDER, {
        params: { name: hostname, type: 'A' },
        headers: { 'Accept': 'application/dns-json' }
    });
    // –ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ 10 –º–∏–Ω—É—Ç
    return response.Answer.find(r => r.type === 1)?.data;
}

export async function smartFetch(url) {
    const ip = await resolveIP(new URL(url).hostname);
    // –û–±—Ö–æ–¥ DNS poisoning: –∏–¥—ë–º –Ω–∞–ø—Ä—è–º—É—é –Ω–∞ IP —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º Host –∑–∞–≥–æ–ª–æ–≤–∫–æ–º
    return fetch(url.replace(hostname, ip), { headers: { Host: hostname } });
}
```

### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è

–í `server/index.js` TMDB —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã —Ç–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É—é—Ç `smartFetch`:

```javascript
import { smartFetch } from './utils/doh.js'

app.get('/api/tmdb/search', async (req, res) => {
    const response = await smartFetch(`https://api.themoviedb.org/3/search/multi?...`)
    res.json(response.data)
})
```

### –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è

1. **Client Warmup** ‚Äî –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è HEAD –∑–∞–ø—Ä–æ—Å –∫ `apn-latest.onrender.com/ping` –¥–ª—è "–ø—Ä–æ–±—É–∂–¥–µ–Ω–∏—è" –ø—Ä–æ–∫—Å–∏
1.  **Client Warmup** ‚Äî –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è HEAD –∑–∞–ø—Ä–æ—Å –∫ `apn-latest.onrender.com/ping` –¥–ª—è "–ø—Ä–æ–±—É–∂–¥–µ–Ω–∏—è" –ø—Ä–æ–∫—Å–∏

2.  **–ë–µ–∑ –≤–Ω–µ—à–Ω–∏—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π** ‚Äî DoH –º–æ–¥—É–ª—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π Node.js `fetch` (Node 18+), –Ω–µ —Ç—Ä–µ–±—É–µ—Ç axios

### –ò—Ç–æ–≥
- ‚úÖ –°–µ—Ä–≤–µ—Ä –æ–±—Ö–æ–¥–∏—Ç DNS poisoning —á–µ—Ä–µ–∑ Cloudflare DoH
- ‚úÖ –ö–ª–∏–µ–Ω—Ç ¬´–ø—Ä–æ–≥—Ä–µ–≤–∞–µ—Ç¬ª –≤–Ω–µ—à–Ω–∏–µ —Å–µ—Ä–≤–∏—Å—ã
- ‚úÖ –†–∞–±–æ—Ç–∞–µ—Ç –±–µ–∑ VPN –∏ –±–µ–∑ –≤–Ω–µ—à–Ω–∏—Ö npm-–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π

---

## üßπ –ê–∫—Ç 7: –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –∏ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è (–î–µ–∫–∞–±—Ä—å 2024)

### –ü—Ä–æ–±–ª–µ–º–∞
`App.jsx` —Ä–∞–∑—Ä–æ—Å—Å—è –¥–æ **1223 —Å—Ç—Ä–æ–∫** ‚Äî —Å–ª–æ–∂–Ω–æ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å –∏ —Ä–∞—Å—à–∏—Ä—è—Ç—å.

### –†–µ—à–µ–Ω–∏–µ: –ö–æ–º–ø–æ–Ω–µ–Ω—Ç–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

–†–∞–∑–±–∏–ª–∏ –º–æ–Ω–æ–ª–∏—Ç –Ω–∞ –º–æ–¥—É–ª–∏:

```
client/src/
‚îú‚îÄ‚îÄ App.jsx                    (622 —Å—Ç—Ä–æ–∫–∏, –±—ã–ª–æ 1223)
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ Poster.jsx            (226) ‚Äî –∫–∞—Ä—Ç–æ—á–∫–∞ —Å –ø–æ—Å—Ç–µ—Ä–æ–º
‚îÇ   ‚îú‚îÄ‚îÄ SettingsPanel.jsx     (172) ‚Äî –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–ª–µ–µ—Ä–∞ –∏ —Å–µ—Ä–≤–µ—Ä–∞
‚îÇ   ‚îú‚îÄ‚îÄ TorrentModal.jsx      (117) ‚Äî –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ —Ñ–∞–π–ª–æ–≤
‚îÇ   ‚îú‚îÄ‚îÄ StatusBanners.jsx     (108) ‚Äî –±–∞–Ω–Ω–µ—Ä—ã –æ—à–∏–±–æ–∫
‚îÇ   ‚îî‚îÄ‚îÄ SearchPanel.jsx       (83)  ‚Äî –ø–æ–∏—Å–∫ –ø–æ RuTracker
‚îî‚îÄ‚îÄ utils/
    ‚îî‚îÄ‚îÄ helpers.js            (96)  ‚Äî cleanTitle, formatSize, formatSpeed
```

### –†–µ–∑—É–ª—å—Ç–∞—Ç: ‚úÖ –°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –Ω–∞ 49%

---

## ‚ö° –ê–∫—Ç 8: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–∏–º–∏–Ω–≥–∞ (–î–µ–∫–∞–±—Ä—å 2024)

### –¢–∏–ø–æ–≤—ã–µ –ø—Ä–æ–±–ª–µ–º—ã TV-—Å—Ç—Ä–∏–º–∏–Ω–≥–∞
- ‚ùå –î–æ–ª–≥–∏–π —Å—Ç–∞—Ä—Ç (buffering)
- ‚ùå –ó–∞—Ç—ã–∫–∏ –ø—Ä–∏ –ø–µ—Ä–µ–º–æ—Ç–∫–µ
- ‚ùå –°–∫–∞—á–∏–≤–∞–µ—Ç—Å—è ¬´–Ω–µ —Ç–æ—Ç¬ª –∫—É—Å–æ–∫

### –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

#### 1Ô∏è‚É£ –ê–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π Piece Prioritization
```javascript
// –ë—ã–ª–æ: 15MB –∏–ª–∏ 5%
// –°—Ç–∞–ª–æ: 50MB –∏–ª–∏ 10%
const priorityBytes = Math.min(file.length * 0.1, 50 * 1024 * 1024)
```

–ü—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞ **—Å—Ä–∞–∑—É** –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∏–º –ø–µ—Ä–≤—ã–π –≤–∏–¥–µ–æ—Ñ–∞–π–ª:
```javascript
// –ê–≤—Ç–æ-–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –ø–µ—Ä–≤–æ–≥–æ –≤–∏–¥–µ–æ
if (firstVideoIdx >= 0) {
    prioritizeFileInternal(engine, firstVideoIdx)
}
```

#### 2Ô∏è‚É£ Readahead –ø—Ä–∏ –ø–µ—Ä–µ–º–æ—Ç–∫–µ
–ü—Ä–∏ –∫–∞–∂–¥–æ–º Range-–∑–∞–ø—Ä–æ—Å–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∏–º –∫—É—Å–∫–∏ –æ—Ç –ø–æ–∑–∏—Ü–∏–∏ seek:
```javascript
// –í /stream/:infoHash/:fileIndex
readahead(infoHash, parseInt(fileIndex, 10), start)
```

–õ–æ–≥:
```
[Readahead] Seeking to byte 81197027701 in file 0
[Priority] File 0: pieces 19358-19358 (13 pieces, ~50MB)
```

#### 3Ô∏è‚É£ Keep-Alive (Frozen Torrents)
–í–º–µ—Å—Ç–æ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è ‚Äî ¬´–∑–∞–º–æ—Ä–∞–∂–∏–≤–∞–µ–º¬ª —Ç–æ—Ä—Ä–µ–Ω—Ç –Ω–∞ 30 –º–∏–Ω—É—Ç:
```javascript
// –ü—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏
frozenTorrents.set(infoHash, { engine, magnetURI, frozenAt: Date.now() })

// –ü—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–º –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ ‚Äî –º–≥–Ω–æ–≤–µ–Ω–Ω—ã–π —Å—Ç–∞—Ä—Ç!
const frozen = frozenTorrents.get(hash)
engines.set(magnetURI, frozen.engine)
```

### –ò—Ç–æ–≥
- ‚úÖ –°—Ç–∞—Ä—Ç –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è: **< 3 —Å–µ–∫—É–Ω–¥—ã**
- ‚úÖ –ü–µ—Ä–µ–º–æ—Ç–∫–∞: **–º–≥–Ω–æ–≤–µ–Ω–Ω–∞—è** (readahead)
- ‚úÖ –ü–æ–≤—Ç–æ—Ä–Ω–æ–µ –æ—Ç–∫—Ä—ã—Ç–∏–µ: **instant** (keep-alive)

---

## üåê –ê–∫—Ç 9: –õ–∏—á–Ω—ã–π Cloudflare Worker (–î–µ–∫–∞–±—Ä—å 2024)

### –î–µ–ø–ª–æ–π —Å–≤–æ–µ–≥–æ CORS-–ø—Ä–æ–∫—Å–∏
–°–æ–∑–¥–∞–Ω –∏ —Ä–∞–∑–≤—ë—Ä–Ω—É—Ç –ª–∏—á–Ω—ã–π Cloudflare Worker –¥–ª—è –æ–±—Ö–æ–¥–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ TMDB.

**URL:** `https://super-sea-46c7.*.workers.dev`

### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
–î–æ–±–∞–≤–ª–µ–Ω –∫–∞–∫ **–ø–µ—Ä–≤—ã–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç** –≤ fetchPoster:
```javascript
// 1Ô∏è‚É£ Custom Cloudflare Worker (–≤–∞—à –ª–∏—á–Ω—ã–π –ø—Ä–æ–∫—Å–∏)
if (!result && CUSTOM_PROXY) {
    const proxyUrl = `${CUSTOM_PROXY}/api.themoviedb.org/3/search/multi?...`
    // ...
}
```

### –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
```env
# –í .env (–∫–ª–∏–µ–Ω—Ç, –Ω–∞ —ç—Ç–∞–ø–µ —Å–±–æ—Ä–∫–∏)
VITE_TMDB_PROXY_URL=https://your-worker.workers.dev
```

### –ò—Ç–æ–≥
- ‚úÖ –õ–∏—á–Ω—ã–π –ø—Ä–æ–∫—Å–∏ —Å –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å—é
- ‚úÖ –ù–µ –∑–∞–≤–∏—Å–∏–º –æ—Ç —á—É–∂–∏—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
- ‚úÖ 100 000 –∑–∞–ø—Ä–æ—Å–æ–≤/–¥–µ–Ω—å –±–µ—Å–ø–ª–∞—Ç–Ω–æ

---

## üì¶ –ê–∫—Ç 10: –£–ª—É—á—à–µ–Ω–Ω—ã–π Docker Deployment (–î–µ–∫–∞–±—Ä—å 2024)

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –Ω–∞ Synology NAS
```
/volume1/docker/pwa-torserve/
‚îú‚îÄ‚îÄ .env                    # API –∫–ª—é—á–∏ (–º–æ–Ω—Ç–∏—Ä—É–µ—Ç—Å—è –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä)
‚îú‚îÄ‚îÄ server/                 # –°–µ—Ä–≤–µ—Ä–Ω—ã–π –∫–æ–¥ (hot-swap –±–µ–∑ rebuild)
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ torrent.js
‚îÇ   ‚îú‚îÄ‚îÄ jacred.js
‚îÇ   ‚îú‚îÄ‚îÄ watchdog.js
‚îÇ   ‚îú‚îÄ‚îÄ utils/doh.js
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îú‚îÄ‚îÄ data/db.json           # Persistence
‚îî‚îÄ‚îÄ downloads/             # –¢–æ—Ä—Ä–µ–Ω—Ç—ã
```

### docker-compose.synology.yml
```yaml
volumes:
  - ./server:/app/server          # Hot-swap —Å–µ—Ä–≤–µ—Ä–Ω–æ–≥–æ –∫–æ–¥–∞
  - ./server/utils:/app/server/utils
  - ./.env:/app/.env:ro           # –ö–æ–Ω—Ñ–∏–≥ —Å –∫–ª—é—á–∞–º–∏
  - ./data:/app/data
```

### –ò—Ç–æ–≥
- ‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–µ—Ä–≤–µ—Ä–∞ **–±–µ–∑ –ø–µ—Ä–µ—Å–±–æ—Ä–∫–∏ –æ–±—Ä–∞–∑–∞**
- ‚úÖ .env –º–æ–Ω—Ç–∏—Ä—É–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ
- ‚úÖ `docker restart torserve` = –¥–µ–ø–ª–æ–π –∑–∞ 2 —Å–µ–∫—É–Ω–¥—ã

---

## üî¨ –ê–∫—Ç 11: –§–∏–Ω–∞–ª—å–Ω–∞—è –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –∏ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è (14 –î–µ–∫–∞–±—Ä—è 2024)

### –ü—Ä–æ–±–ª–µ–º–∞
–ü–æ—Å—Ç–µ—Ä—ã –Ω–µ –∑–∞–≥—Ä—É–∂–∞–ª–∏—Å—å –Ω–∞ Android TV –±–µ–∑ VPN. –¢–µ—Å—Ç –ø–æ–∫–∞–∑—ã–≤–∞–ª –æ—à–∏–±–∫–∏ –¥–ª—è –≤—Å–µ—Ö –º–µ—Ç–æ–¥–æ–≤.

### –†–∞—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ
–î–æ–±–∞–≤–ª–µ–Ω–∞ **–¥–µ—Ç–∞–ª—å–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞** –≤ Settings ‚Üí "üß™ –¢–µ—Å—Ç":
- –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é (TMDB_KEY, KP_KEY, CUSTOM_PROXY)
- –¢–µ—Å—Ç–∏—Ä—É–µ—Ç –≤—Å–µ 5 –º–µ—Ç–æ–¥–æ–≤ —Å —Ç–∞–π–º–∞—É—Ç–∞–º–∏
- –í—ã–≤–æ–¥–∏—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º
- –ü–æ–∑–≤–æ–ª—è–µ—Ç –≤–≤–µ—Å—Ç–∏ –ª—é–±–æ–π —Ñ–∏–ª—å–º –¥–ª—è —Ç–µ—Å—Ç–∞

### –ù–∞–π–¥–µ–Ω–Ω—ã–µ –±–∞–≥–∏

#### 1Ô∏è‚É£ client/.env –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞–ª
```bash
# –ù–µ –±—ã–ª–æ —Ñ–∞–π–ª–∞ ‚Üí APK —Å–æ–±–∏—Ä–∞–ª—Å—è –±–µ–∑ –∫–ª—é—á–µ–π
VITE_TMDB_API_KEY=  # –ø—É—Å—Ç–æ–π!
```
**–†–µ—à–µ–Ω–∏–µ:** –°–æ–∑–¥–∞–Ω `client/.env` —Å –∫–ª—é—á–∞–º–∏, –ø–µ—Ä–µ—Å–æ–±—Ä–∞–Ω APK.

#### 2Ô∏è‚É£ Custom Worker - –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π URL —Ñ–æ—Ä–º–∞—Ç
```javascript
// –ë—ã–ª–æ: Worker –¥–æ–±–∞–≤–ª—è–ª /3/, –∞ –º—ã —Ç–æ–∂–µ –ø–µ—Ä–µ–¥–∞–≤–∞–ª–∏ /3/
const proxyUrl = `${PROXY}/3/search/multi?...`  // ‚Üí /3/3/search/multi ‚ùå

// –°—Ç–∞–ª–æ:
const proxyUrl = `${PROXY}/search/multi?...`    // Worker –¥–æ–±–∞–≤–∏—Ç /3 ‚úÖ
```

#### 3Ô∏è‚É£ Lampa Proxy - –ª–æ–º–∞–ª—Å—è encodeURIComponent
```javascript
// –ë—ã–ª–æ:
const lampaUrl = proxy + encodeURIComponent(targetUrl)  // –õ–æ–º–∞–µ—Ç URL ‚ùå

// –°—Ç–∞–ª–æ:
const lampaUrl = `https://apn-latest.onrender.com/${targetUrl}`  // ‚úÖ
```

#### 4Ô∏è‚É£ –ö–∏–Ω–æ–ø–æ–∏—Å–∫ - –∫–ª—é—á –Ω–µ –±—ã–ª –¥–æ–±–∞–≤–ª–µ–Ω
```env
# –ë—ã–ª–æ:
VITE_KP_API_KEY=

# –°—Ç–∞–ª–æ:
VITE_KP_API_KEY=2a4a0808-81a3-40ae-b0d3-e11335ede616
```

### Cloudflare Worker Geolocation Block
**–ü—Ä–æ–±–ª–µ–º–∞:** TMDB –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `error 1102` (geolocation not permitted) –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö Cloudflare Edge —Å–µ—Ä–≤–µ—Ä–æ–≤.
- –° Mac (–ï–≤—Ä–æ–ø–∞): ‚úÖ —Ä–∞–±–æ—Ç–∞–µ—Ç
- –° Android TV (–†–æ—Å—Å–∏—è): ‚ùå 403

**–ü—Ä–∏—á–∏–Ω–∞:** Cloudflare Workers –∏—Å–ø–æ–ª—å–∑—É—é—Ç IP –±–ª–∏–∂–∞–π—à–µ–≥–æ edge-—Å–µ—Ä–≤–µ—Ä–∞. TMDB –±–ª–æ–∫–∏—Ä—É–µ—Ç –∑–∞–ø—Ä–æ—Å—ã –∏–∑ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã—Ö —Ä–µ–≥–∏–æ–Ω–æ–≤.

### –§–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç

| # | –ú–µ—Ç–æ–¥ | –°—Ç–∞—Ç—É—Å | –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π |
|---|-------|--------|-------------|
| 1Ô∏è‚É£ | Custom Worker | ‚ùå | TMDB –≥–µ–æ–±–ª–æ–∫ –¥–ª—è RU edge |
| 2Ô∏è‚É£ | **Lampa Proxy** | ‚úÖ | –†–∞–±–æ—Ç–∞–µ—Ç! |
| 3Ô∏è‚É£ | CapacitorHttp | üö´ | DNS Poisoning –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–º |
| 4Ô∏è‚É£ | **corsproxy.io** | ‚úÖ | –†–∞–±–æ—Ç–∞–µ—Ç! |
| 5Ô∏è‚É£ | **–ö–∏–Ω–æ–ø–æ–∏—Å–∫** | ‚úÖ | –†–∞–±–æ—Ç–∞–µ—Ç! |

### –ö–æ–¥ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
```javascript
const handleTestPoster = async () => {
    const userInput = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∏–ª—å–º–∞:', 'Gladiator 2')
    // ...—Ç–µ—Å—Ç–∏—Ä—É–µ—Ç 5 –º–µ—Ç–æ–¥–æ–≤ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ —Å —Ç–∞–π–º–∞—É—Ç–∞–º–∏...
    // ...–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏...
}
```

### –ò—Ç–æ–≥
- ‚úÖ **3 —Ä–∞–±–æ—á–∏—Ö –º–µ—Ç–æ–¥–∞** –±–µ–∑ VPN (Lampa, corsproxy, –ö–∏–Ω–æ–ø–æ–∏—Å–∫)
- ‚úÖ Fallback-—Å–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç—Å—è –Ω–∞ —Ä–∞–±–æ—á–∏–π –º–µ—Ç–æ–¥
- ‚úÖ –î–µ—Ç–∞–ª—å–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –¥–ª—è troubleshooting
- ‚úÖ APK v2.7 —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º–∏

---

## üìä –ò—Ç–æ–≥–æ–≤–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ—Å—Ç–µ—Ä–æ–≤

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      Poster.jsx                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  1. Custom Worker ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [–ë–ª–æ–∫ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏ RU]              ‚îÇ
‚îÇ         ‚îÇ                                                    ‚îÇ
‚îÇ         ‚ñº                                                    ‚îÇ
‚îÇ  2. Lampa Proxy ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ apn-latest.onrender.com ‚îÄ‚îÄ‚îÄ‚ñ∫ TMDB ‚îÇ
‚îÇ         ‚îÇ                        ‚úÖ                          ‚îÇ
‚îÇ         ‚ñº                                                    ‚îÇ
‚îÇ  3. CapacitorHttp ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [DNS Poisoning 127.0.0.1]         ‚îÇ
‚îÇ         ‚îÇ                                                    ‚îÇ
‚îÇ         ‚ñº                                                    ‚îÇ
‚îÇ  4. corsproxy.io ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ corsproxy.io ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ TMDB  ‚îÇ
‚îÇ         ‚îÇ                        ‚úÖ                          ‚îÇ
‚îÇ         ‚ñº                                                    ‚îÇ
‚îÇ  5. –ö–∏–Ω–æ–ø–æ–∏—Å–∫ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ kinopoiskapiunofficial ‚îÄ‚îÄ‚îÄ‚ñ∫ KP    ‚îÇ
‚îÇ         ‚îÇ                        ‚úÖ                          ‚îÇ
‚îÇ         ‚ñº                                                    ‚îÇ
‚îÇ  6. Gradient Fallback ‚îÄ‚îÄ‚ñ∫ –ö—Ä–∞—Å–∏–≤—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### üèÜ –ü–æ–±–µ–¥–∞ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞!
–ü–æ—Å—Ç–µ—Ä—ã –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –Ω–∞ Android TV –±–µ–∑ VPN —á–µ—Ä–µ–∑ –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—É—é —Å–∏—Å—Ç–µ–º—É fallback.

---

## üñºÔ∏è –ê–∫—Ç 12: –ë–∏—Ç–≤–∞ –∑–∞ –ö–∞—Ä—Ç–∏–Ω–∫–∏ –∏ –ù–∞–≤–∏–≥–∞—Ü–∏—é (–Ø–Ω–≤–∞—Ä—å 2026)

### –ü—Ä–æ–±–ª–µ–º–∞ ‚Ññ1: –ö–∞—Ä—Ç–∏–Ω–∫–∏ (HTTP 404)
–ù–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —É—Å–ø–µ—Ö —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ (JSON), —Å–∞–º–∏ –ø–æ—Å—Ç–µ—Ä—ã (`.jpg`) –ø–µ—Ä–µ—Å—Ç–∞–ª–∏ –≥—Ä—É–∑–∏—Ç—å—Å—è.
- **–ó–µ—Ä–∫–∞–ª–∞ Lampa** (`imagetmdb.com`) –Ω–∞—á–∞–ª–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å—Å—è –∏–ª–∏ –≤—ã–¥–∞–≤–∞—Ç—å –æ—à–∏–±–∫–∏.
- **–ü—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–µ—Ä–∫–∞–ª–∞** —á–µ—Ä–µ–∑ `wsrv.nl` –Ω–µ –ø–æ–º–æ–≥–∞–ª–æ (—Ç.–∫. —Å–∞–º–æ –∑–µ—Ä–∫–∞–ª–æ –ª–µ–∂–∞–ª–æ).

### –†–µ—à–µ–Ω–∏–µ: –í–æ–∑–≤—Ä–∞—Ç –∫ –ò—Å—Ç–æ–∫–∞–º ("Old Scheme") üõ°Ô∏è
–ú—ã –≤—Å–ø–æ–º–Ω–∏–ª–∏ —É—Å–ø–µ—à–Ω—ã–π –æ–ø—ã—Ç "–ê–∫—Ç–∞ 3". `wsrv.nl` ‚Äî —ç—Ç–æ –º–æ—â–Ω—ã–π –µ–≤—Ä–æ–ø–µ–π—Å–∫–∏–π –ø—Ä–æ–∫—Å–∏, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –≤–∏–¥–µ—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π TMDB.
–í–º–µ—Å—Ç–æ —Ç–æ–≥–æ —á—Ç–æ–±—ã –ø—Ä–æ–∫—Å–∏—Ä–æ–≤–∞—Ç—å *–ø–∏—Ä–∞—Ç—Å–∫–æ–µ –∑–µ—Ä–∫–∞–ª–æ*, –º—ã –Ω–∞—Å—Ç—Ä–æ–∏–ª–∏ –ø—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ **–æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ `image.tmdb.org`**.

**–ê–ª–≥–æ—Ä–∏—Ç–º (`tmdbClient.js`):**
1. –ü—ã—Ç–∞–µ–º—Å—è –≥—Ä—É–∑–∏—Ç—å —Å –∑–µ—Ä–∫–∞–ª Lampa (–±—ã—Å—Ç—Ä–æ).
2. –ï—Å–ª–∏ –∑–µ—Ä–∫–∞–ª–æ –≤—ã–¥–∞–µ—Ç –æ—à–∏–±–∫–∏ (20 –æ—à–∏–±–æ–∫ –∑–∞ 10 —Å–µ–∫) -> **BAN**.
3. –í–∫–ª—é—á–∞–µ—Ç—Å—è **Proxy Mode**:
   - URL –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤: `https://wsrv.nl/?url=https://image.tmdb.org/t/p/w500/...`
   - `wsrv.nl` (–ï–≤—Ä–æ–ø–∞) –∑–∞–±–∏—Ä–∞–µ—Ç –∫–∞—Ä—Ç–∏–Ω–∫—É —É `tmdb.org` (–°–®–ê) –∏ –æ—Ç–¥–∞–µ—Ç –Ω–∞–º (–†–§).
   - **–†–µ–∑—É–ª—å—Ç–∞—Ç:** 100% –∑–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –±–µ–∑ VPN.

### –ü—Ä–æ–±–ª–µ–º–∞ ‚Ññ2: TV –ù–∞–≤–∏–≥–∞—Ü–∏—è üéÆ
1. **"–û–±—Ä–µ–∑–∞–Ω–Ω—ã–π –≤–µ—Ä—Ö":** –ü—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ –Ω–∞ –≤–µ—Ä—Ö–Ω–∏–π —Ä—è–¥ (–¢—Ä–µ–Ω–¥—ã) –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Ñ–∏–ª—å–º–∞ –æ–±—Ä–µ–∑–∞–ª—Å—è, —Ç–∞–∫ –∫–∞–∫ –±—Ä–∞—É–∑–µ—Ä —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–ª —Ä—è–¥ (`block: 'center'`).
2. **"–î—Ä–æ–∂–∞–Ω–∏–µ":** –ü–ª–∞–≤–Ω—ã–π —Å–∫—Ä–æ–ª–ª (`behavior: 'smooth'`) –≤—ã–∑—ã–≤–∞–ª –ª–∞–≥–∏ –Ω–∞ –¢–í –ø—Ä–∏ –±—ã—Å—Ç—Ä–æ–º –ø–µ—Ä–µ–ª–∏—Å—Ç—ã–≤–∞–Ω–∏–∏.
3. **–ö–Ω–æ–ø–∫–∞ "–ï—â—ë":** –ù–µ–¥–æ—Å—Ç—É–ø–Ω–∞ —Å –ø—É–ª—å—Ç–∞.

### –†–µ—à–µ–Ω–∏—è –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞:
1. **Smart Top Scroll:** –ï—Å–ª–∏ —Ñ–æ–∫—É—Å –Ω–∞ **–ø–µ—Ä–≤–æ–º —Ä—è–¥—É**, –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —Å–∫—Ä–æ–ª–ª–∏–º —Å—Ç—Ä–∞–Ω–∏—Ü—É –≤ `0px` (`window.scrollTo({ top: 0 })`) –∏ –æ—Ç–∫–ª—é—á–∞–µ–º —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä—è–¥–∞ (`block: 'nearest'`). –®–∞–ø–∫–∞ –≤—Å–µ–≥–¥–∞ –≤–∏–¥–Ω–∞ –∏–¥–µ–∞–ª—å–Ω–æ.
2. **Instant Scroll:** –í–∫–ª—é—á–µ–Ω —Ä–µ–∂–∏–º `behavior: 'auto'` ‚Äî –º–≥–Ω–æ–≤–µ–Ω–Ω–∞—è —Ä–µ–∞–∫—Ü–∏—è –Ω–∞ –Ω–∞–∂–∞—Ç–∏—è.
3. **Focus Logic:** –ö–Ω–æ–ø–∫–∞ "–ï—â—ë" —Ç–µ–ø–µ—Ä—å –¥–æ—Å—Ç—É–ø–Ω–∞ –Ω–∞–∂–∞—Ç–∏–µ–º –í–ü–†–ê–í–û —Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞.

### –ò—Ç–æ–≥ –Ø–Ω–≤–∞—Ä—è 2026: üèÜ –ü–û–õ–ù–ê–Ø –ü–û–ë–ï–î–ê
*   **–ö–∞—Ä—Ç–∏–Ω–∫–∏:** –ì—Ä—É–∑—è—Ç—Å—è –≤—Å–µ–≥–¥–∞ (Direct Mirror -> Auto-Ban -> WSRV Proxy).
*   **–ù–∞–≤–∏–≥–∞—Ü–∏—è:** –ò–¥–µ–∞–ª—å–Ω–æ –ø–ª–∞–≤–Ω–∞—è, –Ω–∏—á–µ–≥–æ –Ω–µ –æ–±—Ä–µ–∑–∞–µ—Ç—Å—è.
*   **VPN:** –ù–µ –Ω—É–∂–µ–Ω.

---

## üíÖ –ê–∫—Ç 13: –§–∏–Ω–∞–ª—å–Ω—ã–π –®–ª–∏—Ñ –∏ APK (–Ø–Ω–≤–∞—Ä—å 2026)

### –ü—Ä–æ–±–ª–µ–º—ã UI –Ω–∞ —Ä–µ–∞–ª—å–Ω–æ–º –¢–í (Feedback Round 2)
–ü–æ—Å–ª–µ —Ç–µ—Å—Ç–æ–≤ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ –≤—ã—è–≤–ª–µ–Ω —Ä—è–¥ UX-–±–∞–≥–æ–≤, –º–µ—à–∞—é—â–∏—Ö "–ø—Ä–µ–º–∏–∞–ª—å–Ω–æ–º—É" –æ—â—É—â–µ–Ω–∏—é:
1.  **Navbar Trap:** –° –≥–ª–∞–≤–Ω–æ–≥–æ —ç–∫—Ä–∞–Ω–∞ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–æ–ø–∞—Å—Ç—å –≤ –≤–µ—Ä—Ö–Ω–µ–µ –º–µ–Ω—é (Settings/Search), —Ñ–æ–∫—É—Å –∑–∞—Å—Ç—Ä–µ–≤–∞–ª –Ω–∞ –ø–æ—Å—Ç–µ—Ä–∞—Ö.
2.  **Back Button Chaos:** –ö–Ω–æ–ø–∫–∞ "–ù–∞–∑–∞–¥" –Ω–∞ –ø—É–ª—å—Ç–µ –≤—ã–∫–∏–¥—ã–≤–∞–ª–∞ –∏–∑ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –≤–º–µ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—Ç–∞ –∫ —Å–ø–∏—Å–∫—É, –∞ –≤ –¥–µ—Ç–∞–ª—è—Ö —Ñ–∏–ª—å–º–∞ ‚Äî —Ç—Ä–∏–≥–≥–µ—Ä–∏–ª–∞ –ø–æ–∏—Å–∫.
3.  **Scroll Jitter:** –ü—Ä–∏ –∑–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–∫–∏ –Ω–∞ –ø—É–ª—å—Ç–µ —Å–∫—Ä–æ–ª–ª "–¥–µ—Ä–≥–∞–ª—Å—è", –≤—ã–∑—ã–≤–∞—è —É–∫–∞—á–∏–≤–∞–Ω–∏–µ.
4.  **Clipped Focus:** –°–∏–Ω—è—è —Ä–∞–º–∫–∞ —Ñ–æ–∫—É—Å–∞ –æ–±—Ä–µ–∑–∞–ª–∞—Å—å —Å–≤–µ—Ä—Ö—É/—Å–Ω–∏–∑—É –∏–∑-–∑–∞ `overflow: hidden`.

### –†–µ—à–µ–Ω–∏—è (Polish Batch)
1.  **Escape from Home:** –í `HomePanel.jsx` –ø–µ—Ä–µ–ø–∏—Å–∞–ª–∏ –ª–æ–≥–∏–∫—É `ArrowUp`. –ï—Å–ª–∏ –º—ã –Ω–∞ –ø–µ—Ä–≤–æ–º —Ä—è–¥—É ‚Äî —Å–æ–±—ã—Ç–∏–µ "–≤—Å–ø–ª—ã–≤–∞–µ—Ç" (bubble) –Ω–∞–≤–µ—Ä—Ö –∫ –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω–æ–º—É –±–∞—Ä—É.
2.  **Intelligent Back Navigation:**
    *   **Global (`App.jsx`):** –ï—Å–ª–∏ `activeView === 'home'`, –∫–Ω–æ–ø–∫–∞ "–ù–∞–∑–∞–¥" –ø–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç –Ω–∞ `'list'`, –∞ –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–µ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.
    *   **Contextual (`MovieDetail.jsx`):** –î–æ–±–∞–≤–ª–µ–Ω–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏—è —Å—Ç—Ä–µ–ª–∫–∞–º–∏ –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ –º–µ–∂–¥—É –∫–Ω–æ–ø–∫–∞–º–∏ "–ü–æ–∏—Å–∫" –∏ "–ù–∞–∑–∞–¥".
3.  **Smooth Operator:** –£–≤–µ–ª–∏—á–∏–ª–∏ debounce —Å–∫—Ä–æ–ª–ª–∞ –¥–æ **100ms**. –¢–µ–ø–µ—Ä—å –ø—Ä–∏ –∑–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–∫–∏ —Å–∫—Ä–æ–ª–ª –∏–¥–µ—Ç –ø–ª–∞–≤–Ω–æ, –±–µ–∑ —Ä—ã–≤–∫–æ–≤.
4.  **Padding Update:** –£–≤–µ–ª–∏—á–∏–ª–∏ –æ—Ç—Å—Ç—É–ø—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ `HomeRow` –¥–æ `16px`. –§–æ–∫—É—Å–Ω–æ–µ –∫–æ–ª—å—Ü–æ —Ç–µ–ø–µ—Ä—å –≤–∏–¥–Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é.

### –ò—Ç–æ–≥ –ë–∏—Ç–≤—ã (v2.8)
–°–æ–±—Ä–∞–Ω —Ñ–∏–Ω–∞–ª—å–Ω—ã–π `app-debug.apk`. –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –æ—â—É—â–∞–µ—Ç—Å—è –Ω–∞—Ç–∏–≤–Ω—ã–º, —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å –ø—É–ª—å—Ç–∞ –∏–Ω—Ç—É–∏—Ç–∏–≤–Ω–æ–µ. –í—Å–µ –æ—Å–Ω–æ–≤–Ω—ã–µ –±–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∑–∞–∫—Ä—ã—Ç—ã.

---

## üõ°Ô∏è –ê–∫—Ç 14: –°–µ—Ä–≤–µ—Ä–Ω—ã–π –©–∏—Ç (Server-Side Resilience)

**–ó–∞–¥–∞—á–∞:** –û–±–µ—Å–ø–µ—á–∏—Ç—å –≤—ã–∂–∏–≤–∞–µ–º–æ—Å—Ç—å —Å–µ—Ä–≤–µ—Ä–Ω–æ–π —á–∞—Å—Ç–∏ (proxy) –ø—Ä–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–µ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ DNS –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–º.

### –†–µ—à–µ–Ω–∏–µ: Intelligent DoH Cluster (`server/utils/doh.js`)
–í–º–µ—Å—Ç–æ –∂–µ—Å—Ç–∫–æ–π –ø—Ä–∏–≤—è–∑–∫–∏ –∫ –æ–¥–Ω–æ–º—É DNS (–∫–∞–∫ –±—ã–ª–æ —Ä–∞–Ω—å—à–µ —Å Cloudflare), –º—ã —Ä–µ–∞–ª–∏–∑–æ–≤–∞–ª–∏ **—É–º–Ω—ã–π –∫–ª–∞—Å—Ç–µ—Ä DoH (DNS-over-HTTPS)** —Å —Ä–æ—Ç–∞—Ü–∏–µ–π –∏ –∑–∞—â–∏—Ç–æ–π –æ—Ç —Å–±–æ–µ–≤.

### 1. Multi-Provider Race Strategy üèéÔ∏è
–°–µ—Ä–≤–µ—Ä –Ω–µ –∂–¥–µ—Ç –æ—Ç–≤–µ—Ç–∞ –æ—Ç –æ–¥–Ω–æ–≥–æ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞. –û–Ω –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∑–∞–ø—Ä–æ—Å **–æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ** —Ç—Ä–µ–º –≥–∏–≥–∞–Ω—Ç–∞–º, –∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –æ—Ç–≤–µ—Ç —Ç–æ–≥–æ, –∫—Ç–æ –æ—Ç–≤–µ—Ç–∏–ª –ø–µ—Ä–≤—ã–º (Race):
*   **Google DNS** (`dns.google`)
*   **Cloudflare** (`cloudflare-dns.com`)
*   **Quad9** (`dns.quad9.net` ‚Äî –®–≤–µ–π—Ü–∞—Ä–∏—è, –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π)

**–†–µ–∑—É–ª—å—Ç–∞—Ç:** –°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è —Ä–µ–∑–æ–ª–≤–∞ —Å–Ω–∏–∑–∏–ª–æ—Å—å —Å 150–º—Å –¥–æ **30-50–º—Å**. –ï—Å–ª–∏ –†–ö–ù –±–ª–æ–∫–∏—Ä—É–µ—Ç Cloudflare, –∑–∞–ø—Ä–æ—Å –º–æ–ª–Ω–∏–µ–Ω–æ—Å–Ω–æ –ø—Ä–æ—Ö–æ–¥–∏—Ç —á–µ—Ä–µ–∑ Quad9.

### 2. Circuit Breaker (–ü—Ä–µ–¥–æ—Ö—Ä–∞–Ω–∏—Ç–µ–ª—å) ‚ö°
–ï—Å–ª–∏ –æ–¥–∏–Ω –∏–∑ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤ –Ω–∞—á–∏–Ω–∞–µ—Ç "—Ç—É–ø–∏—Ç—å" (3 –æ—à–∏–±–∫–∏ –ø–æ–¥—Ä—è–¥):
1.  –°–∏—Å—Ç–µ–º–∞ **–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏—Å–∫–ª—é—á–∞–µ—Ç** –µ–≥–æ –∏–∑ –ø—É–ª–∞ ("–†–∞–∑–º—ã–∫–∞–µ—Ç —Ü–µ–ø—å").
2.  –°–µ—Ä–≤–µ—Ä –ø–µ—Ä–µ—Å—Ç–∞–µ—Ç —Å–ª–∞—Ç—å —Ç—É–¥–∞ –∑–∞–ø—Ä–æ—Å—ã, —ç–∫–æ–Ω–æ–º—è —Ä–µ—Å—É—Ä—Å—ã.
3.  –ß–µ—Ä–µ–∑ 60 —Å–µ–∫—É–Ω–¥ (Cooldown) —Å–∏—Å—Ç–µ–º–∞ –¥–µ–ª–∞–µ—Ç **–ø–æ–ø—ã—Ç–∫—É –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è** (Half-Open). –ï—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ ‚Äî –ø—Ä–æ–≤–∞–π–¥–µ—Ä –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ —Å—Ç—Ä–æ–π.

### 3. Smart Config & Impersonation üé≠
–î–ª—è –æ–±—Ö–æ–¥–∞ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫ –ø–æ SNI (Server Name Indication):
*   –ú—ã —Ä–µ–∑–æ–ª–≤–∏–º —Ä–µ–∞–ª—å–Ω—ã–π IP (`1.2.3.4`).
*   –ò–¥–µ–º –Ω–∞–ø—Ä—è–º—É—é –ø–æ IP: `https://1.2.3.4/path...`.
*   –ß–µ—Å—Ç–Ω–æ –ø–æ–¥—Å—Ç–∞–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ `Host: api.themoviedb.org`.
*   –ü—Ä–∏—Ç–≤–æ—Ä—è–µ–º—Å—è –æ–±—ã—á–Ω—ã–º –±—Ä–∞—É–∑–µ—Ä–æ–º (`User-Agent: Chrome 120`).

**–ò—Ç–æ–≥:** –°–µ—Ä–≤–µ—Ä–Ω—ã–π –ø—Ä–æ–∫—Å–∏ —Å—Ç–∞–ª –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –Ω–µ—É–±–∏–≤–∞–µ–º—ã–º. –î–∞–∂–µ –ø–æ–ª–Ω–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –æ–¥–Ω–æ–≥–æ –∏–∑ DNS-–ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤ –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å —Å–∏—Å—Ç–µ–º—ã.

---

## üíé –ê–∫—Ç 15: –û–ø–µ—Ä–∞—Ü–∏—è "ARC-01" (–Ø–Ω–≤–∞—Ä—å 2026 - –§–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è)

### –ü—Ä–æ–±–ª–µ–º–∞: "–ü–æ—Å–ª–µ–¥–Ω—è—è –º–∏–ª—è" –Ω–∞ Android TV
–ù–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —Ä–∞–±–æ—á–∏–π —Å–µ—Ä–≤–µ—Ä–Ω—ã–π –ø—Ä–æ–∫—Å–∏, –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã—Ö –¢–í-–ø—Ä–∏—Å—Ç–∞–≤–∫–∞—Ö –ø–æ—Å—Ç–µ—Ä—ã –≤—Å—ë —Ä–∞–≤–Ω–æ –∏–Ω–æ–≥–¥–∞ "–º–æ—Ä–≥–∞–ª–∏" –∏–ª–∏ –Ω–µ –ø—Ä–æ–≥—Ä—É–∂–∞–ª–∏—Å—å.
1.  **Mixed Content:** –ë—Ä–∞—É–∑–µ—Ä—ã –Ω–∞ –¢–í –±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏ –∫–∞—Ä—Ç–∏–Ω–∫–∏, –µ—Å–ª–∏ –ø—Ä–æ–∫—Å–∏-—Å—Å—ã–ª–∫–∞ –∫–∞–∑–∞–ª–∞—Å—å –∏–º –Ω–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ–π.
2.  **DPI Inspection:** –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã –Ω–∞—É—á–∏–ª–∏—Å—å –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å `wsrv.nl`, –µ—Å–ª–∏ –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–µ `?url=` –ø–µ—Ä–µ–¥–∞–≤–∞–ª—Å—è –æ—Ç–∫—Ä—ã—Ç—ã–π —Ç–µ–∫—Å—Ç `http://image.tmdb.org`.

### –†–µ—à–µ–Ω–∏–µ: –ü—Ä–æ—Ç–æ–∫–æ–ª ARC-01 (Advanced Resilience Cascade)

–ú—ã –≤–Ω–µ–¥—Ä–∏–ª–∏ –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—É—é –ª–æ–≥–∏–∫—É –≤ `tmdbClient.js` –∏ `Poster.jsx` / `HomeRow.jsx`:

#### 1. –£–º–Ω—ã–π –ø—Ä–µ—Ñ–∏–∫—Å `ssl:` –¥–ª—è wsrv.nl üõ°Ô∏è
–î–ª—è –æ–±—Ö–æ–¥–∞ DPI –º—ã –Ω–∞—á–∞–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫—É—é —Ñ–∏—á—É –ø—Ä–æ–∫—Å–∏ `wsrv.nl`:
*   **–ë—ã–ª–æ:** `https://wsrv.nl/?url=image.tmdb.org/...`
*   **–°—Ç–∞–ª–æ:** `https://wsrv.nl/?url=ssl:image.tmdb.org/...&output=webp`
*   **–≠—Ñ—Ñ–µ–∫—Ç:** –ü—Ä–µ—Ñ–∏–∫—Å `ssl:` –∑–∞—Å—Ç–∞–≤–ª—è–µ—Ç –ø—Ä–æ–∫—Å–∏-—Å–µ—Ä–≤–µ—Ä —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º, —Å–∫—Ä—ã–≤–∞—è –¥–µ—Ç–∞–ª–∏ –∑–∞–ø—Ä–æ—Å–∞ –æ—Ç –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ DPI –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞.

#### 2. –î–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞—Ü–∏—è –ø–ª–∞—Ç—Ñ–æ—Ä–º üì± vs üåê
*   **–í –ë—Ä–∞—É–∑–µ—Ä–µ (PWA):** –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –æ—Ç–¥–∞–µ—Ç—Å—è **Server Proxy** (–Ω–∞—à–µ–º—É NAS). –≠—Ç–æ –±—ã—Å—Ç—Ä–æ –∏ –Ω–∞–¥–µ–∂–Ω–æ –≤ –ª–æ–∫–∞–ª—å–Ω–æ–π —Å–µ—Ç–∏.
*   **–í APK (Android TV):** –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω –Ω–∞ **Global Cloud Mirrors** (`wsrv.nl` —Å WebP —Å–∂–∞—Ç–∏–µ–º). –≠—Ç–æ —Å–Ω–∏–º–∞–µ—Ç –Ω–∞–≥—Ä—É–∑–∫—É —Å –¥–æ–º–∞—à–Ω–µ–≥–æ –∫–∞–Ω–∞–ª–∞ –∏ –æ–±—Ö–æ–¥–∏—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö WebView.

#### 3. –°–∏—Å—Ç–µ–º–∞ "–ñ–∏–≤–æ–≥–æ –ë–∞–Ω–∞" (Lampa Mirror System) üß®
–ú—ã –≤–Ω–µ–¥—Ä–∏–ª–∏ –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π –º–µ—Ö–∞–Ω–∏–∑–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –æ—à–∏–±–æ–∫ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏:
*   –ö–∞–∂–¥—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç (`HomeRow`, `Poster`) —Ç–µ–ø–µ—Ä—å –∏–º–µ–µ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ `onError`.
*   –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–∏–≥–Ω–∞–ª –≤ `reportBrokenImage`.
*   –ï—Å–ª–∏ –∑–µ—Ä–∫–∞–ª–æ –≤—ã–¥–∞–µ—Ç **20 –æ—à–∏–±–æ–∫ –∑–∞ 10 —Å–µ–∫—É–Ω–¥**, —Å–∏—Å—Ç–µ–º–∞ –ø–æ–º–µ—á–∞–µ—Ç –µ–≥–æ –∫–∞–∫ "Banned" –∏ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç –≤—Å—ë –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –Ω–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –∫–∞–Ω–∞–ª –∏–ª–∏ –ø—Ä–æ–∫—Å–∏-—Ä–µ–∂–∏–º.

### –ò—Ç–æ–≥: üèÜ –¢–ï–†–ú–ò–ù–ê–õ–¨–ù–ê–Ø –ü–û–ë–ï–î–ê
–°–µ–≥–æ–¥–Ω—è—à–Ω—è—è —Ä–∞–±–æ—Ç–∞ –ø–æ–∑–≤–æ–ª–∏–ª–∞ –¥–æ–±–∏—Ç—å—Å—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏, —Å—Ä–∞–≤–Ω–∏–º–æ–π —Å –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–º–∏ –∫–ª–∏–µ–Ω—Ç–∞–º–∏ (Netflix/YouTube):
*   ‚úÖ **WebP –Ω–∞ –ª–µ—Ç—É:** –ö–∞—Ä—Ç–∏–Ω–∫–∏ —Å—Ç–∞–ª–∏ –≤–µ—Å–∏—Ç—å –≤ 3 —Ä–∞–∑–∞ –º–µ–Ω—å—à–µ, —á—Ç–æ —É—Å–∫–æ—Ä–∏–ª–æ —Å–∫—Ä–æ–ª–ª –Ω–∞ —Å–ª–∞–±–æ–º –∂–µ–ª–µ–∑–µ –¢–í.
*   ‚úÖ **–ù–µ—É–±–∏–≤–∞–µ–º–æ—Å—Ç—å:** –ï—Å–ª–∏ –ª—è–∂–µ—Ç –∑–µ—Ä–∫–∞–ª–æ ‚Äî –ø–æ–¥—Ö–≤–∞—Ç–∏—Ç –ø—Ä–æ–∫—Å–∏. –ï—Å–ª–∏ –ª—è–∂–µ—Ç –ø—Ä–æ–∫—Å–∏ ‚Äî –ø–æ–¥—Ö–≤–∞—Ç–∏—Ç —Å–µ—Ä–≤–µ—Ä. –ï—Å–ª–∏ –ª—è–∂–µ—Ç –≤—Å—ë ‚Äî –ö–∏–Ω–æ–ø–æ–∏—Å–∫.
*   ‚úÖ **–ë–µ–∑ VPN:** –°–∏—Å—Ç–µ–º–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∞–≤—Ç–æ–Ω–æ–º–Ω–∞ –∏ –æ–±—Ö–æ–¥–∏—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –Ω–∞ —É—Ä–æ–≤–Ω–µ –ª–æ–≥–∏–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.


---

## üîß –ê–∫—Ç 16: –†–∞–±–æ—Ç–∞ –Ω–∞–¥ –æ—à–∏–±–∫–∞–º–∏ (–Ø–Ω–≤–∞—Ä—å 2026 - Hotfix)

### –ü—Ä–æ–±–ª–µ–º–∞: –ü—Ä–æ–ø–∞–≤—à–∏–π Custom Worker –∏ 401 Lampa
–ü–æ—Å–ª–µ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ (`SettingsPanel.jsx`) –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–º–µ—Ç–∏–ª –ø—Ä–æ–ø–∞–∂—É **Custom Worker** –∏–∑ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –∏ –æ—à–∏–±–∫—É **HTTP 401** –Ω–∞ –ø—Ä–æ–∫—Å–∏ Lampa.

### –ü—Ä–∏—á–∏–Ω–∞
1.  **Custom Worker:** –í `App.jsx` –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ `tmdbProxyUrl` –±—Ä–∞–ª–æ—Å—å —Ç–æ–ª—å–∫–æ –∏–∑ `localStorage`, –∏–≥–Ω–æ—Ä–∏—Ä—É—è –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è `VITE_TMDB_PROXY_URL` –∏–∑ `.env`.
2.  **Lampa Proxy:** –í `SettingsPanel.jsx` –±—ã–ª –∑–∞—Ö–∞—Ä–¥–∫–æ–∂–µ–Ω —É—Å—Ç–∞—Ä–µ–≤—à–∏–π/–Ω–µ—Ä–∞–±–æ—á–∏–π API Key `f862...`, –≤–º–µ—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∫–ª—é—á–∞ –∏–∑ `.env`.

### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
1.  **App.jsx:**
    ```javascript
    useState(localStorage.getItem('tmdbProxyUrl') || import.meta.env.VITE_TMDB_PROXY_URL || '')
    ```
2.  **SettingsPanel.jsx:**
    ```javascript
    const TMDB_API_KEY = import.meta.env.VITE_TMDB_API_KEY || "..."
    ```

### –ò—Ç–æ–≥
- ‚úÖ Custom Worker –≤–µ—Ä–Ω—É–ª—Å—è –≤ —Å—Ç—Ä–æ–π.

---

## üé® –ê–∫—Ç 17: –§–∏–Ω–∞–ª—å–Ω–∞—è –ø–æ–ª–∏—Ä–æ–≤–∫–∞ UI –∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞–¥–µ–Ω–∏–π (–Ø–Ω–≤–∞—Ä—å 2026)

### –ü—Ä–æ–±–ª–µ–º–∞: "–ü–∞–Ω–µ–ª—å –≤ —É–≥–ª—É" –∏ ReferenceError
–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–∂–∞–ª–æ–≤–∞–ª—Å—è –Ω–∞:
1.  –ù–µ—É–¥–æ–±–Ω–æ–µ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –ø–∞–Ω–µ–ª–µ–π (–°–∞–π–¥–±–∞—Ä—ã —Å–ø—Ä–∞–≤–∞, –ø–ª–æ—Ö–æ –≤–∏–¥–Ω–æ –Ω–∞ –¢–í).
2.  –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –±–∞–≥ `handleClearCache is not defined` –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –æ—Ç–∫—Ä—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ (–∏–∑-–∑–∞ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ–≥–æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ –≤ –ê–∫—Ç–µ 16).

### –†–µ—à–µ–Ω–∏–µ
1.  **Redesign:** –ü–æ–ª–Ω—ã–π —Ä–µ–¥–∏–∑–∞–π–Ω `SettingsPanel.jsx` –∏ `DiagnosticsPanel.jsx`. –¢–µ–ø–µ—Ä—å —ç—Ç–æ **—Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞** —Å backdrop-blur —ç—Ñ—Ñ–µ–∫—Ç–æ–º.
2.  **Crash Fix:** –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–ª–∏ —Å–ª—É—á–∞–π–Ω–æ —É–¥–∞–ª–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ `handleClearCache` –∏ —Å—Å—ã–ª–∫–∏ `useSpatialItem` –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏.
3.  **Spatial Navigation:** –Ø–≤–Ω–æ –ø—Ä–æ–ø–∏—Å–∞–ª–∏ `tabIndex="0"` –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–ª–∏ refs –¥–ª—è –≤—Å–µ—Ö –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –º–æ–¥–∞–ª–∫–∞—Ö.

### –ò—Ç–æ–≥
- ‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ —Ç–µ–ø–µ—Ä—å –ø–æ —Ü–µ–Ω—Ç—Ä—É —ç–∫—Ä–∞–Ω–∞.
- ‚úÖ –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –Ω–µ –ø–∞–¥–∞–µ—Ç.
- ‚úÖ –ù–∞–≤–∏–≥–∞—Ü–∏—è —Å –ø—É–ª—å—Ç–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –≤–Ω—É—Ç—Ä–∏ –º–æ–¥–∞–ª—å–Ω—ã—Ö –æ–∫–æ–Ω.

```

---

## README.md

```markdown
# üçø PWA-TorServe v4.0
**The Ultimate Self-Hosted Streaming Gateway**

> *Turns your NAS into a private Netflix-class streaming service.*

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT) [![React](https://img.shields.io/badge/React-19-blue)](https://react.dev) [![Status](https://img.shields.io/badge/Status-Stable-green)](https://github.com/bobmark/pwa-torserve)

PWA-TorServe is a **middleware** that bridges the gap between torrent networks and your TV. It aggregates search results, bypasses censorship, and streams content directly to your favorite player (Vimu, MX Player, VLC) with a **premium cinematic interface**.

---

## ‚ú® What's New in v4.0?

üöÄ **Cinematic Experience**
- **Infinite Scroll**: Endless feed of movies and TV shows.
- **Season Selector**: Dedicated UI for browsing TV show seasons.
- **Transform Scrolling**: Silky smooth 60fps navigation on low-end TV boxes.
- **Deep Integration**: Two-way sync with Vimu/MX Player (Auto-play next episode, Resume playback).

üõ°Ô∏è **Operation "Unstoppable"**
- **5-Level Anti-Censorship Cascade**:
  1. Custom Worker
  2. Public Proxy
  3. **Client-Side DoH** (Bypasses DNS poisoning)
  4. Corsproxy.io
  5. Kinopoisk Fallback

---

## üöÄ Key Features

### üì∫ The Interface
- **Remote Control First**: Fully navigable with a standard D-Pad remote.
- **Focus Centering**: Apple TV-style scrolling keeps the active item centered.
- **Dynamic Backdrops**: Background changes instantly as you browse.
- **Smart Metadata**: 4K/HDR/HEVC badges, ratings, and cast info.

### ‚ö° The Engine
- **Aggregator**: Searches Jacred, RuTracker, Rutor, and TorLook in parallel.
- **Torrent Stream**: Starts playing in 5-10 seconds without waiting for download.
- **Auto-Boost**: Prioritizes sequential chunks for instant playback.
- **Self-Healing**: Built-in Circuit Breaker and Watchdog prevent crashes.

### üì≤ The Client (APK)
- **Native Android TV App**: Built with Capacitor 6.
- **Voice Search**: Integrated with Android Speech Recognition.
- **No Backend Dependency**: Metadata fetching happens entirely on the client (Zero-Cost Architecture).

---

## üõ† Tech Stack

- **Frontend**: React 19, Vite 7, TailwindCSS 4, Framer Motion
- **Mobile/TV**: Capacitor 6 (Native Java Plugins for Player Integration)
- **Backend**: Node.js, Express, torrent-stream
- **DevOps**: Docker, Docker Compose

---

## üì¶ Installation

### Option 1: Docker (Recommended)
Run on your Synology NAS, Raspberry Pi, or VPS.

```bash
# 1. Create directory
mkdir -p pwa-torserve/downloads
cd pwa-torserve

# 2. Download docker-compose.yml
curl -o docker-compose.yml https://raw.githubusercontent.com/bobmark/pwa-torserve/main/docker-compose.yml

# 3. Start
docker-compose up -d
```

Access at: `http://your-nas-ip:3000`

### Option 2: Android TV Client (APK)
To get the full experience (Voice Search, Deep Player Integration), install the APK.

1. **Build it yourself**:
   ```bash
   cd client
   npm install && npm run build
   npx cap sync
   cd android && ./gradlew assembleDebug
   ```
2. **Install**: Copy `app-debug.apk` to your TV and install.

---

## üéÆ Usage Guide

1. **Home Screen**: Browse "Trending", "Popular", or "Top Rated".
2. **Search**: Use the onscreen keyboard or **Voice Search** button.
3. **Select**: Click a movie card.
   - For TV Shows: Select a Season first.
4. **Resilience**: If a provider fails (e.g., Rutor), the system auto-switches to others.
5. **Playback**: Click **"–ù–∞–π—Ç–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç—ã"** -> Select a release -> **Play**.
   - *Pro Tip:* If you have Vimu installed, it will auto-mark watched episodes.

---

## üõ°Ô∏è Privacy & Security
- **No Tracking**: We don't collect logs.
- **Client-Side Processing**: All metadata requests go directly from your device to TMDB/Proxy.
- **Clean Traffic**: DoH ensures your ISP can't snoop on your DNS requests.

---

## üìÑ License
MIT License. Free forever.

Made with ‚ù§Ô∏è for the Home Cinema community.
```

---

## client/README.md

```markdown
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.

```

---

## client/android/app/build.gradle

```gradle
apply plugin: 'com.android.application'

android {
    namespace "com.torserve.pwa"
    compileSdk rootProject.ext.compileSdkVersion
    defaultConfig {
        applicationId "com.torserve.pwa"
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        aaptOptions {
             // Files and dirs to omit from the packaged assets dir, modified to accommodate modern web apps.
             // Default: https://android.googlesource.com/platform/frameworks/base/+/282e181b58cf72b6ca770dc7ca5f91f135444502/tools/aapt/AaptAssets.cpp#61
            ignoreAssetsPattern '!.svn:!.git:!.ds_store:!*.scc:.*:!CVS:!thumbs.db:!picasa.ini:!*~'
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

repositories {
    flatDir{
        dirs '../capacitor-cordova-android-plugins/src/main/libs', 'libs'
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation "androidx.appcompat:appcompat:$androidxAppCompatVersion"
    implementation "androidx.coordinatorlayout:coordinatorlayout:$androidxCoordinatorLayoutVersion"
    implementation "androidx.core:core-splashscreen:$coreSplashScreenVersion"
    implementation project(':capacitor-android')
    testImplementation "junit:junit:$junitVersion"
    androidTestImplementation "androidx.test.ext:junit:$androidxJunitVersion"
    androidTestImplementation "androidx.test.espresso:espresso-core:$androidxEspressoCoreVersion"
    implementation project(':capacitor-cordova-android-plugins')
}

apply from: 'capacitor.build.gradle'

try {
    def servicesJSON = file('google-services.json')
    if (servicesJSON.text) {
        apply plugin: 'com.google.gms.google-services'
    }
} catch(Exception e) {
    logger.info("google-services.json not found, google-services plugin not applied. Push Notifications won't work")
}

```

---

## client/android/app/capacitor.build.gradle

```gradle
// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN

android {
  compileOptions {
      sourceCompatibility JavaVersion.VERSION_17
      targetCompatibility JavaVersion.VERSION_17
  }
}

apply from: "../capacitor-cordova-android-plugins/cordova.variables.gradle"
dependencies {
    implementation project(':capacitor-community-speech-recognition')
    implementation project(':capacitor-app')
    implementation project(':capacitor-browser')
    implementation project(':capacitor-preferences')

}


if (hasProperty('postBuildExtras')) {
  postBuildExtras()
}

```

---

## client/android/app/proguard-rules.pro

```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile

```

---

## client/android/app/src/androidTest/java/com/getcapacitor/myapp/ExampleInstrumentedTest.java

```java
package com.getcapacitor.myapp;

import static org.junit.Assert.*;

import android.content.Context;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {

    @Test
    public void useAppContext() throws Exception {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();

        assertEquals("com.getcapacitor.app", appContext.getPackageName());
    }
}

```

---

## client/android/app/src/main/assets/capacitor.config.json

```json
{
	"appId": "com.torserve.pwa",
	"appName": "MediaBox",
	"webDir": "dist",
	"server": {
		"androidScheme": "https",
		"cleartext": true,
		"allowNavigation": [
			"192.168.1.70",
			"192.168.1.*",
			"*"
		]
	},
	"android": {
		"allowMixedContent": true
	}
}

```

---

## client/android/app/src/main/assets/capacitor.plugins.json

```json
[
	{
		"pkg": "@capacitor-community/speech-recognition",
		"classpath": "com.getcapacitor.community.speechrecognition.SpeechRecognition"
	},
	{
		"pkg": "@capacitor/app",
		"classpath": "com.capacitorjs.plugins.app.AppPlugin"
	},
	{
		"pkg": "@capacitor/browser",
		"classpath": "com.capacitorjs.plugins.browser.BrowserPlugin"
	},
	{
		"pkg": "@capacitor/preferences",
		"classpath": "com.capacitorjs.plugins.preferences.PreferencesPlugin"
	}
]

```

---

## client/android/app/src/main/assets/public/assets/index-BobWrA1F.js

```javascript
(function(){const r=document.createElement("link").relList;if(r&&r.supports&&r.supports("modulepreload"))return;for(const g of document.querySelectorAll('link[rel="modulepreload"]'))o(g);new MutationObserver(g=>{for(const y of g)if(y.type==="childList")for(const x of y.addedNodes)x.tagName==="LINK"&&x.rel==="modulepreload"&&o(x)}).observe(document,{childList:!0,subtree:!0});function d(g){const y={};return g.integrity&&(y.integrity=g.integrity),g.referrerPolicy&&(y.referrerPolicy=g.referrerPolicy),g.crossOrigin==="use-credentials"?y.credentials="include":g.crossOrigin==="anonymous"?y.credentials="omit":y.credentials="same-origin",y}function o(g){if(g.ep)return;g.ep=!0;const y=d(g);fetch(g.href,y)}})();function Lh(c){return c&&c.__esModule&&Object.prototype.hasOwnProperty.call(c,"default")?c.default:c}var Qs={exports:{}},eu={};var Pd;function Yh(){if(Pd)return eu;Pd=1;var c=Symbol.for("react.transitional.element"),r=Symbol.for("react.fragment");function d(o,g,y){var x=null;if(y!==void 0&&(x=""+y),g.key!==void 0&&(x=""+g.key),"key"in g){y={};for(var N in g)N!=="key"&&(y[N]=g[N])}else y=g;return g=y.ref,{$$typeof:c,type:o,key:x,ref:g!==void 0?g:null,props:y}}return eu.Fragment=r,eu.jsx=d,eu.jsxs=d,eu}var e0;function Gh(){return e0||(e0=1,Qs.exports=Yh()),Qs.exports}var s=Gh(),Zs={exports:{}},oe={};var t0;function Xh(){if(t0)return oe;t0=1;var c=Symbol.for("react.transitional.element"),r=Symbol.for("react.portal"),d=Symbol.for("react.fragment"),o=Symbol.for("react.strict_mode"),g=Symbol.for("react.profiler"),y=Symbol.for("react.consumer"),x=Symbol.for("react.context"),N=Symbol.for("react.forward_ref"),A=Symbol.for("react.suspense"),b=Symbol.for("react.memo"),H=Symbol.for("react.lazy"),U=Symbol.for("react.activity"),L=Symbol.iterator;function J(m){return m===null||typeof m!="object"?null:(m=L&&m[L]||m["@@iterator"],typeof m=="function"?m:null)}var se={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},ue=Object.assign,re={};function ce(m,_,C){this.props=m,this.context=_,this.refs=re,this.updater=C||se}ce.prototype.isReactComponent={},ce.prototype.setState=function(m,_){if(typeof m!="object"&&typeof m!="function"&&m!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,m,_,"setState")},ce.prototype.forceUpdate=function(m){this.updater.enqueueForceUpdate(this,m,"forceUpdate")};function ie(){}ie.prototype=ce.prototype;function I(m,_,C){this.props=m,this.context=_,this.refs=re,this.updater=C||se}var de=I.prototype=new ie;de.constructor=I,ue(de,ce.prototype),de.isPureReactComponent=!0;var ge=Array.isArray;function ae(){}var X={H:null,A:null,T:null,S:null},F=Object.prototype.hasOwnProperty;function Ee(m,_,C){var G=C.ref;return{$$typeof:c,type:m,key:_,ref:G!==void 0?G:null,props:C}}function je(m,_){return Ee(m.type,_,m.props)}function Ne(m){return typeof m=="object"&&m!==null&&m.$$typeof===c}function k(m){var _={"=":"=0",":":"=2"};return"$"+m.replace(/[=:]/g,function(C){return _[C]})}var he=/\/+/g;function w(m,_){return typeof m=="object"&&m!==null&&m.key!=null?k(""+m.key):_.toString(36)}function Q(m){switch(m.status){case"fulfilled":return m.value;case"rejected":throw m.reason;default:switch(typeof m.status=="string"?m.then(ae,ae):(m.status="pending",m.then(function(_){m.status==="pending"&&(m.status="fulfilled",m.value=_)},function(_){m.status==="pending"&&(m.status="rejected",m.reason=_)})),m.status){case"fulfilled":return m.value;case"rejected":throw m.reason}}throw m}function S(m,_,C,G,K){var le=typeof m;(le==="undefined"||le==="boolean")&&(m=null);var P=!1;if(m===null)P=!0;else switch(le){case"bigint":case"string":case"number":P=!0;break;case"object":switch(m.$$typeof){case c:case r:P=!0;break;case H:return P=m._init,S(P(m._payload),_,C,G,K)}}if(P)return K=K(m),P=G===""?"."+w(m,0):G,ge(K)?(C="",P!=null&&(C=P.replace(he,"$&/")+"/"),S(K,_,C,"",function(Je){return Je})):K!=null&&(Ne(K)&&(K=je(K,C+(K.key==null||m&&m.key===K.key?"":(""+K.key).replace(he,"$&/")+"/")+P)),_.push(K)),1;P=0;var Re=G===""?".":G+":";if(ge(m))for(var Ae=0;Ae<m.length;Ae++)G=m[Ae],le=Re+w(G,Ae),P+=S(G,_,C,le,K);else if(Ae=J(m),typeof Ae=="function")for(m=Ae.call(m),Ae=0;!(G=m.next()).done;)G=G.value,le=Re+w(G,Ae++),P+=S(G,_,C,le,K);else if(le==="object"){if(typeof m.then=="function")return S(Q(m),_,C,G,K);throw _=String(m),Error("Objects are not valid as a React child (found: "+(_==="[object Object]"?"object with keys {"+Object.keys(m).join(", ")+"}":_)+"). If you meant to render a collection of children, use an array instead.")}return P}function O(m,_,C){if(m==null)return m;var G=[],K=0;return S(m,G,"","",function(le){return _.call(C,le,K++)}),G}function V(m){if(m._status===-1){var _=m._result;_=_(),_.then(function(C){(m._status===0||m._status===-1)&&(m._status=1,m._result=C)},function(C){(m._status===0||m._status===-1)&&(m._status=2,m._result=C)}),m._status===-1&&(m._status=0,m._result=_)}if(m._status===1)return m._result.default;throw m._result}var q=typeof reportError=="function"?reportError:function(m){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var _=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof m=="object"&&m!==null&&typeof m.message=="string"?String(m.message):String(m),error:m});if(!window.dispatchEvent(_))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",m);return}console.error(m)},Y={map:O,forEach:function(m,_,C){O(m,function(){_.apply(this,arguments)},C)},count:function(m){var _=0;return O(m,function(){_++}),_},toArray:function(m){return O(m,function(_){return _})||[]},only:function(m){if(!Ne(m))throw Error("React.Children.only expected to receive a single React element child.");return m}};return oe.Activity=U,oe.Children=Y,oe.Component=ce,oe.Fragment=d,oe.Profiler=g,oe.PureComponent=I,oe.StrictMode=o,oe.Suspense=A,oe.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=X,oe.__COMPILER_RUNTIME={__proto__:null,c:function(m){return X.H.useMemoCache(m)}},oe.cache=function(m){return function(){return m.apply(null,arguments)}},oe.cacheSignal=function(){return null},oe.cloneElement=function(m,_,C){if(m==null)throw Error("The argument must be a React element, but you passed "+m+".");var G=ue({},m.props),K=m.key;if(_!=null)for(le in _.key!==void 0&&(K=""+_.key),_)!F.call(_,le)||le==="key"||le==="__self"||le==="__source"||le==="ref"&&_.ref===void 0||(G[le]=_[le]);var le=arguments.length-2;if(le===1)G.children=C;else if(1<le){for(var P=Array(le),Re=0;Re<le;Re++)P[Re]=arguments[Re+2];G.children=P}return Ee(m.type,K,G)},oe.createContext=function(m){return m={$$typeof:x,_currentValue:m,_currentValue2:m,_threadCount:0,Provider:null,Consumer:null},m.Provider=m,m.Consumer={$$typeof:y,_context:m},m},oe.createElement=function(m,_,C){var G,K={},le=null;if(_!=null)for(G in _.key!==void 0&&(le=""+_.key),_)F.call(_,G)&&G!=="key"&&G!=="__self"&&G!=="__source"&&(K[G]=_[G]);var P=arguments.length-2;if(P===1)K.children=C;else if(1<P){for(var Re=Array(P),Ae=0;Ae<P;Ae++)Re[Ae]=arguments[Ae+2];K.children=Re}if(m&&m.defaultProps)for(G in P=m.defaultProps,P)K[G]===void 0&&(K[G]=P[G]);return Ee(m,le,K)},oe.createRef=function(){return{current:null}},oe.forwardRef=function(m){return{$$typeof:N,render:m}},oe.isValidElement=Ne,oe.lazy=function(m){return{$$typeof:H,_payload:{_status:-1,_result:m},_init:V}},oe.memo=function(m,_){return{$$typeof:b,type:m,compare:_===void 0?null:_}},oe.startTransition=function(m){var _=X.T,C={};X.T=C;try{var G=m(),K=X.S;K!==null&&K(C,G),typeof G=="object"&&G!==null&&typeof G.then=="function"&&G.then(ae,q)}catch(le){q(le)}finally{_!==null&&C.types!==null&&(_.types=C.types),X.T=_}},oe.unstable_useCacheRefresh=function(){return X.H.useCacheRefresh()},oe.use=function(m){return X.H.use(m)},oe.useActionState=function(m,_,C){return X.H.useActionState(m,_,C)},oe.useCallback=function(m,_){return X.H.useCallback(m,_)},oe.useContext=function(m){return X.H.useContext(m)},oe.useDebugValue=function(){},oe.useDeferredValue=function(m,_){return X.H.useDeferredValue(m,_)},oe.useEffect=function(m,_){return X.H.useEffect(m,_)},oe.useEffectEvent=function(m){return X.H.useEffectEvent(m)},oe.useId=function(){return X.H.useId()},oe.useImperativeHandle=function(m,_,C){return X.H.useImperativeHandle(m,_,C)},oe.useInsertionEffect=function(m,_){return X.H.useInsertionEffect(m,_)},oe.useLayoutEffect=function(m,_){return X.H.useLayoutEffect(m,_)},oe.useMemo=function(m,_){return X.H.useMemo(m,_)},oe.useOptimistic=function(m,_){return X.H.useOptimistic(m,_)},oe.useReducer=function(m,_,C){return X.H.useReducer(m,_,C)},oe.useRef=function(m){return X.H.useRef(m)},oe.useState=function(m){return X.H.useState(m)},oe.useSyncExternalStore=function(m,_,C){return X.H.useSyncExternalStore(m,_,C)},oe.useTransition=function(){return X.H.useTransition()},oe.version="19.2.0",oe}var l0;function Ps(){return l0||(l0=1,Zs.exports=Xh()),Zs.exports}var M=Ps();const Qh=Lh(M);var Vs={exports:{}},tu={},Ks={exports:{}},ks={};var a0;function Zh(){return a0||(a0=1,(function(c){function r(S,O){var V=S.length;S.push(O);e:for(;0<V;){var q=V-1>>>1,Y=S[q];if(0<g(Y,O))S[q]=O,S[V]=Y,V=q;else break e}}function d(S){return S.length===0?null:S[0]}function o(S){if(S.length===0)return null;var O=S[0],V=S.pop();if(V!==O){S[0]=V;e:for(var q=0,Y=S.length,m=Y>>>1;q<m;){var _=2*(q+1)-1,C=S[_],G=_+1,K=S[G];if(0>g(C,V))G<Y&&0>g(K,C)?(S[q]=K,S[G]=V,q=G):(S[q]=C,S[_]=V,q=_);else if(G<Y&&0>g(K,V))S[q]=K,S[G]=V,q=G;else break e}}return O}function g(S,O){var V=S.sortIndex-O.sortIndex;return V!==0?V:S.id-O.id}if(c.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var y=performance;c.unstable_now=function(){return y.now()}}else{var x=Date,N=x.now();c.unstable_now=function(){return x.now()-N}}var A=[],b=[],H=1,U=null,L=3,J=!1,se=!1,ue=!1,re=!1,ce=typeof setTimeout=="function"?setTimeout:null,ie=typeof clearTimeout=="function"?clearTimeout:null,I=typeof setImmediate<"u"?setImmediate:null;function de(S){for(var O=d(b);O!==null;){if(O.callback===null)o(b);else if(O.startTime<=S)o(b),O.sortIndex=O.expirationTime,r(A,O);else break;O=d(b)}}function ge(S){if(ue=!1,de(S),!se)if(d(A)!==null)se=!0,ae||(ae=!0,k());else{var O=d(b);O!==null&&Q(ge,O.startTime-S)}}var ae=!1,X=-1,F=5,Ee=-1;function je(){return re?!0:!(c.unstable_now()-Ee<F)}function Ne(){if(re=!1,ae){var S=c.unstable_now();Ee=S;var O=!0;try{e:{se=!1,ue&&(ue=!1,ie(X),X=-1),J=!0;var V=L;try{t:{for(de(S),U=d(A);U!==null&&!(U.expirationTime>S&&je());){var q=U.callback;if(typeof q=="function"){U.callback=null,L=U.priorityLevel;var Y=q(U.expirationTime<=S);if(S=c.unstable_now(),typeof Y=="function"){U.callback=Y,de(S),O=!0;break t}U===d(A)&&o(A),de(S)}else o(A);U=d(A)}if(U!==null)O=!0;else{var m=d(b);m!==null&&Q(ge,m.startTime-S),O=!1}}break e}finally{U=null,L=V,J=!1}O=void 0}}finally{O?k():ae=!1}}}var k;if(typeof I=="function")k=function(){I(Ne)};else if(typeof MessageChannel<"u"){var he=new MessageChannel,w=he.port2;he.port1.onmessage=Ne,k=function(){w.postMessage(null)}}else k=function(){ce(Ne,0)};function Q(S,O){X=ce(function(){S(c.unstable_now())},O)}c.unstable_IdlePriority=5,c.unstable_ImmediatePriority=1,c.unstable_LowPriority=4,c.unstable_NormalPriority=3,c.unstable_Profiling=null,c.unstable_UserBlockingPriority=2,c.unstable_cancelCallback=function(S){S.callback=null},c.unstable_forceFrameRate=function(S){0>S||125<S?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):F=0<S?Math.floor(1e3/S):5},c.unstable_getCurrentPriorityLevel=function(){return L},c.unstable_next=function(S){switch(L){case 1:case 2:case 3:var O=3;break;default:O=L}var V=L;L=O;try{return S()}finally{L=V}},c.unstable_requestPaint=function(){re=!0},c.unstable_runWithPriority=function(S,O){switch(S){case 1:case 2:case 3:case 4:case 5:break;default:S=3}var V=L;L=S;try{return O()}finally{L=V}},c.unstable_scheduleCallback=function(S,O,V){var q=c.unstable_now();switch(typeof V=="object"&&V!==null?(V=V.delay,V=typeof V=="number"&&0<V?q+V:q):V=q,S){case 1:var Y=-1;break;case 2:Y=250;break;case 5:Y=1073741823;break;case 4:Y=1e4;break;default:Y=5e3}return Y=V+Y,S={id:H++,callback:O,priorityLevel:S,startTime:V,expirationTime:Y,sortIndex:-1},V>q?(S.sortIndex=V,r(b,S),d(A)===null&&S===d(b)&&(ue?(ie(X),X=-1):ue=!0,Q(ge,V-q))):(S.sortIndex=Y,r(A,S),se||J||(se=!0,ae||(ae=!0,k()))),S},c.unstable_shouldYield=je,c.unstable_wrapCallback=function(S){var O=L;return function(){var V=L;L=O;try{return S.apply(this,arguments)}finally{L=V}}}})(ks)),ks}var n0;function Vh(){return n0||(n0=1,Ks.exports=Zh()),Ks.exports}var Js={exports:{}},ut={};var u0;function Kh(){if(u0)return ut;u0=1;var c=Ps();function r(A){var b="https://react.dev/errors/"+A;if(1<arguments.length){b+="?args[]="+encodeURIComponent(arguments[1]);for(var H=2;H<arguments.length;H++)b+="&args[]="+encodeURIComponent(arguments[H])}return"Minified React error #"+A+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function d(){}var o={d:{f:d,r:function(){throw Error(r(522))},D:d,C:d,L:d,m:d,X:d,S:d,M:d},p:0,findDOMNode:null},g=Symbol.for("react.portal");function y(A,b,H){var U=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:g,key:U==null?null:""+U,children:A,containerInfo:b,implementation:H}}var x=c.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function N(A,b){if(A==="font")return"";if(typeof b=="string")return b==="use-credentials"?b:""}return ut.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=o,ut.createPortal=function(A,b){var H=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!b||b.nodeType!==1&&b.nodeType!==9&&b.nodeType!==11)throw Error(r(299));return y(A,b,null,H)},ut.flushSync=function(A){var b=x.T,H=o.p;try{if(x.T=null,o.p=2,A)return A()}finally{x.T=b,o.p=H,o.d.f()}},ut.preconnect=function(A,b){typeof A=="string"&&(b?(b=b.crossOrigin,b=typeof b=="string"?b==="use-credentials"?b:"":void 0):b=null,o.d.C(A,b))},ut.prefetchDNS=function(A){typeof A=="string"&&o.d.D(A)},ut.preinit=function(A,b){if(typeof A=="string"&&b&&typeof b.as=="string"){var H=b.as,U=N(H,b.crossOrigin),L=typeof b.integrity=="string"?b.integrity:void 0,J=typeof b.fetchPriority=="string"?b.fetchPriority:void 0;H==="style"?o.d.S(A,typeof b.precedence=="string"?b.precedence:void 0,{crossOrigin:U,integrity:L,fetchPriority:J}):H==="script"&&o.d.X(A,{crossOrigin:U,integrity:L,fetchPriority:J,nonce:typeof b.nonce=="string"?b.nonce:void 0})}},ut.preinitModule=function(A,b){if(typeof A=="string")if(typeof b=="object"&&b!==null){if(b.as==null||b.as==="script"){var H=N(b.as,b.crossOrigin);o.d.M(A,{crossOrigin:H,integrity:typeof b.integrity=="string"?b.integrity:void 0,nonce:typeof b.nonce=="string"?b.nonce:void 0})}}else b==null&&o.d.M(A)},ut.preload=function(A,b){if(typeof A=="string"&&typeof b=="object"&&b!==null&&typeof b.as=="string"){var H=b.as,U=N(H,b.crossOrigin);o.d.L(A,H,{crossOrigin:U,integrity:typeof b.integrity=="string"?b.integrity:void 0,nonce:typeof b.nonce=="string"?b.nonce:void 0,type:typeof b.type=="string"?b.type:void 0,fetchPriority:typeof b.fetchPriority=="string"?b.fetchPriority:void 0,referrerPolicy:typeof b.referrerPolicy=="string"?b.referrerPolicy:void 0,imageSrcSet:typeof b.imageSrcSet=="string"?b.imageSrcSet:void 0,imageSizes:typeof b.imageSizes=="string"?b.imageSizes:void 0,media:typeof b.media=="string"?b.media:void 0})}},ut.preloadModule=function(A,b){if(typeof A=="string")if(b){var H=N(b.as,b.crossOrigin);o.d.m(A,{as:typeof b.as=="string"&&b.as!=="script"?b.as:void 0,crossOrigin:H,integrity:typeof b.integrity=="string"?b.integrity:void 0})}else o.d.m(A)},ut.requestFormReset=function(A){o.d.r(A)},ut.unstable_batchedUpdates=function(A,b){return A(b)},ut.useFormState=function(A,b,H){return x.H.useFormState(A,b,H)},ut.useFormStatus=function(){return x.H.useHostTransitionStatus()},ut.version="19.2.0",ut}var c0;function kh(){if(c0)return Js.exports;c0=1;function c(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(c)}catch(r){console.error(r)}}return c(),Js.exports=Kh(),Js.exports}var i0;function Jh(){if(i0)return tu;i0=1;var c=Vh(),r=Ps(),d=kh();function o(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var l=2;l<arguments.length;l++)t+="&args[]="+encodeURIComponent(arguments[l])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function g(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function y(e){var t=e,l=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,(t.flags&4098)!==0&&(l=t.return),e=t.return;while(e)}return t.tag===3?l:null}function x(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function N(e){if(e.tag===31){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function A(e){if(y(e)!==e)throw Error(o(188))}function b(e){var t=e.alternate;if(!t){if(t=y(e),t===null)throw Error(o(188));return t!==e?null:e}for(var l=e,a=t;;){var n=l.return;if(n===null)break;var u=n.alternate;if(u===null){if(a=n.return,a!==null){l=a;continue}break}if(n.child===u.child){for(u=n.child;u;){if(u===l)return A(n),e;if(u===a)return A(n),t;u=u.sibling}throw Error(o(188))}if(l.return!==a.return)l=n,a=u;else{for(var i=!1,f=n.child;f;){if(f===l){i=!0,l=n,a=u;break}if(f===a){i=!0,a=n,l=u;break}f=f.sibling}if(!i){for(f=u.child;f;){if(f===l){i=!0,l=u,a=n;break}if(f===a){i=!0,a=u,l=n;break}f=f.sibling}if(!i)throw Error(o(189))}}if(l.alternate!==a)throw Error(o(190))}if(l.tag!==3)throw Error(o(188));return l.stateNode.current===l?e:t}function H(e){var t=e.tag;if(t===5||t===26||t===27||t===6)return e;for(e=e.child;e!==null;){if(t=H(e),t!==null)return t;e=e.sibling}return null}var U=Object.assign,L=Symbol.for("react.element"),J=Symbol.for("react.transitional.element"),se=Symbol.for("react.portal"),ue=Symbol.for("react.fragment"),re=Symbol.for("react.strict_mode"),ce=Symbol.for("react.profiler"),ie=Symbol.for("react.consumer"),I=Symbol.for("react.context"),de=Symbol.for("react.forward_ref"),ge=Symbol.for("react.suspense"),ae=Symbol.for("react.suspense_list"),X=Symbol.for("react.memo"),F=Symbol.for("react.lazy"),Ee=Symbol.for("react.activity"),je=Symbol.for("react.memo_cache_sentinel"),Ne=Symbol.iterator;function k(e){return e===null||typeof e!="object"?null:(e=Ne&&e[Ne]||e["@@iterator"],typeof e=="function"?e:null)}var he=Symbol.for("react.client.reference");function w(e){if(e==null)return null;if(typeof e=="function")return e.$$typeof===he?null:e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case ue:return"Fragment";case ce:return"Profiler";case re:return"StrictMode";case ge:return"Suspense";case ae:return"SuspenseList";case Ee:return"Activity"}if(typeof e=="object")switch(e.$$typeof){case se:return"Portal";case I:return e.displayName||"Context";case ie:return(e._context.displayName||"Context")+".Consumer";case de:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case X:return t=e.displayName||null,t!==null?t:w(e.type)||"Memo";case F:t=e._payload,e=e._init;try{return w(e(t))}catch{}}return null}var Q=Array.isArray,S=r.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,O=d.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,V={pending:!1,data:null,method:null,action:null},q=[],Y=-1;function m(e){return{current:e}}function _(e){0>Y||(e.current=q[Y],q[Y]=null,Y--)}function C(e,t){Y++,q[Y]=e.current,e.current=t}var G=m(null),K=m(null),le=m(null),P=m(null);function Re(e,t){switch(C(le,t),C(K,e),C(G,null),t.nodeType){case 9:case 11:e=(e=t.documentElement)&&(e=e.namespaceURI)?Ed(e):0;break;default:if(e=t.tagName,t=t.namespaceURI)t=Ed(t),e=jd(t,e);else switch(e){case"svg":e=1;break;case"math":e=2;break;default:e=0}}_(G),C(G,e)}function Ae(){_(G),_(K),_(le)}function Je(e){e.memoizedState!==null&&C(P,e);var t=G.current,l=jd(t,e.type);t!==l&&(C(K,e),C(G,l))}function pt(e){K.current===e&&(_(G),_(K)),P.current===e&&(_(P),Wn._currentValue=V)}var ot,vl;function Fe(e){if(ot===void 0)try{throw Error()}catch(l){var t=l.stack.trim().match(/\n( *(at )?)/);ot=t&&t[1]||"",vl=-1<l.stack.indexOf(`
    at`)?" (<anonymous>)":-1<l.stack.indexOf("@")?"@unknown:0:0":""}return`
`+ot+e+vl}var Ql=!1;function Zt(e,t){if(!e||Ql)return"";Ql=!0;var l=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var a={DetermineComponentFrameRoot:function(){try{if(t){var B=function(){throw Error()};if(Object.defineProperty(B.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(B,[])}catch(z){var T=z}Reflect.construct(e,[],B)}else{try{B.call()}catch(z){T=z}e.call(B.prototype)}}else{try{throw Error()}catch(z){T=z}(B=e())&&typeof B.catch=="function"&&B.catch(function(){})}}catch(z){if(z&&T&&typeof z.stack=="string")return[z.stack,T.stack]}return[null,null]}};a.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var n=Object.getOwnPropertyDescriptor(a.DetermineComponentFrameRoot,"name");n&&n.configurable&&Object.defineProperty(a.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var u=a.DetermineComponentFrameRoot(),i=u[0],f=u[1];if(i&&f){var h=i.split(`
`),j=f.split(`
`);for(n=a=0;a<h.length&&!h[a].includes("DetermineComponentFrameRoot");)a++;for(;n<j.length&&!j[n].includes("DetermineComponentFrameRoot");)n++;if(a===h.length||n===j.length)for(a=h.length-1,n=j.length-1;1<=a&&0<=n&&h[a]!==j[n];)n--;for(;1<=a&&0<=n;a--,n--)if(h[a]!==j[n]){if(a!==1||n!==1)do if(a--,n--,0>n||h[a]!==j[n]){var D=`
`+h[a].replace(" at new "," at ");return e.displayName&&D.includes("<anonymous>")&&(D=D.replace("<anonymous>",e.displayName)),D}while(1<=a&&0<=n);break}}}finally{Ql=!1,Error.prepareStackTrace=l}return(l=e?e.displayName||e.name:"")?Fe(l):""}function rn(e,t){switch(e.tag){case 26:case 27:case 5:return Fe(e.type);case 16:return Fe("Lazy");case 13:return e.child!==t&&t!==null?Fe("Suspense Fallback"):Fe("Suspense");case 19:return Fe("SuspenseList");case 0:case 15:return Zt(e.type,!1);case 11:return Zt(e.type.render,!1);case 1:return Zt(e.type,!0);case 31:return Fe("Activity");default:return""}}function bl(e){try{var t="",l=null;do t+=rn(e,l),l=e,e=e.return;while(e);return t}catch(a){return`
Error generating stack: `+a.message+`
`+a.stack}}var ma=Object.prototype.hasOwnProperty,on=c.unstable_scheduleCallback,ft=c.unstable_cancelCallback,jc=c.unstable_shouldYield,Nc=c.unstable_requestPaint,ct=c.unstable_now,Tc=c.unstable_getCurrentPriorityLevel,cu=c.unstable_ImmediatePriority,iu=c.unstable_UserBlockingPriority,ha=c.unstable_NormalPriority,Wt=c.unstable_LowPriority,su=c.unstable_IdlePriority,wc=c.log,ga=c.unstable_setDisableYieldValue,Zl=null,it=null;function Lt(e){if(typeof wc=="function"&&ga(e),it&&typeof it.setStrictMode=="function")try{it.setStrictMode(Zl,e)}catch{}}var st=Math.clz32?Math.clz32:zc,_c=Math.log,Ac=Math.LN2;function zc(e){return e>>>=0,e===0?32:31-(_c(e)/Ac|0)|0}var ya=256,Vl=262144,Kl=4194304;function Z(e){var t=e&42;if(t!==0)return t;switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return e&261888;case 262144:case 524288:case 1048576:case 2097152:return e&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return e&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return e}}function ye(e,t,l){var a=e.pendingLanes;if(a===0)return 0;var n=0,u=e.suspendedLanes,i=e.pingedLanes;e=e.warmLanes;var f=a&134217727;return f!==0?(a=f&~u,a!==0?n=Z(a):(i&=f,i!==0?n=Z(i):l||(l=f&~e,l!==0&&(n=Z(l))))):(f=a&~u,f!==0?n=Z(f):i!==0?n=Z(i):l||(l=a&~e,l!==0&&(n=Z(l)))),n===0?0:t!==0&&t!==n&&(t&u)===0&&(u=n&-n,l=t&-t,u>=l||u===32&&(l&4194048)!==0)?t:n}function Be(e,t){return(e.pendingLanes&~(e.suspendedLanes&~e.pingedLanes)&t)===0}function Yt(e,t){switch(e){case 1:case 2:case 4:case 8:case 64:return t+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function kl(){var e=Kl;return Kl<<=1,(Kl&62914560)===0&&(Kl=4194304),e}function Vt(e){for(var t=[],l=0;31>l;l++)t.push(e);return t}function _t(e,t){e.pendingLanes|=t,t!==268435456&&(e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0)}function Mc(e,t,l,a,n,u){var i=e.pendingLanes;e.pendingLanes=l,e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0,e.expiredLanes&=l,e.entangledLanes&=l,e.errorRecoveryDisabledLanes&=l,e.shellSuspendCounter=0;var f=e.entanglements,h=e.expirationTimes,j=e.hiddenUpdates;for(l=i&~l;0<l;){var D=31-st(l),B=1<<D;f[D]=0,h[D]=-1;var T=j[D];if(T!==null)for(j[D]=null,D=0;D<T.length;D++){var z=T[D];z!==null&&(z.lane&=-536870913)}l&=~B}a!==0&&Dc(e,a,0),u!==0&&n===0&&e.tag!==0&&(e.suspendedLanes|=u&~(i&~t))}function Dc(e,t,l){e.pendingLanes|=t,e.suspendedLanes&=~t;var a=31-st(t);e.entangledLanes|=t,e.entanglements[a]=e.entanglements[a]|1073741824|l&261930}function ar(e,t){var l=e.entangledLanes|=t;for(e=e.entanglements;l;){var a=31-st(l),n=1<<a;n&t|e[a]&t&&(e[a]|=t),l&=~n}}function nr(e,t){var l=t&-t;return l=(l&42)!==0?1:Cc(l),(l&(e.suspendedLanes|t))!==0?0:l}function Cc(e){switch(e){case 2:e=1;break;case 8:e=4;break;case 32:e=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:e=128;break;case 268435456:e=134217728;break;default:e=0}return e}function Oc(e){return e&=-e,2<e?8<e?(e&134217727)!==0?32:268435456:8:2}function ur(){var e=O.p;return e!==0?e:(e=window.event,e===void 0?32:Kd(e.type))}function cr(e,t){var l=O.p;try{return O.p=e,t()}finally{O.p=l}}var pl=Math.random().toString(36).slice(2),et="__reactFiber$"+pl,dt="__reactProps$"+pl,va="__reactContainer$"+pl,Rc="__reactEvents$"+pl,A0="__reactListeners$"+pl,z0="__reactHandles$"+pl,ir="__reactResources$"+pl,fn="__reactMarker$"+pl;function Uc(e){delete e[et],delete e[dt],delete e[Rc],delete e[A0],delete e[z0]}function ba(e){var t=e[et];if(t)return t;for(var l=e.parentNode;l;){if(t=l[va]||l[et]){if(l=t.alternate,t.child!==null||l!==null&&l.child!==null)for(e=Md(e);e!==null;){if(l=e[et])return l;e=Md(e)}return t}e=l,l=e.parentNode}return null}function pa(e){if(e=e[et]||e[va]){var t=e.tag;if(t===5||t===6||t===13||t===31||t===26||t===27||t===3)return e}return null}function dn(e){var t=e.tag;if(t===5||t===26||t===27||t===6)return e.stateNode;throw Error(o(33))}function xa(e){var t=e[ir];return t||(t=e[ir]={hoistableStyles:new Map,hoistableScripts:new Map}),t}function Ie(e){e[fn]=!0}var sr=new Set,rr={};function Jl(e,t){Sa(e,t),Sa(e+"Capture",t)}function Sa(e,t){for(rr[e]=t,e=0;e<t.length;e++)sr.add(t[e])}var M0=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),or={},fr={};function D0(e){return ma.call(fr,e)?!0:ma.call(or,e)?!1:M0.test(e)?fr[e]=!0:(or[e]=!0,!1)}function ru(e,t,l){if(D0(t))if(l===null)e.removeAttribute(t);else{switch(typeof l){case"undefined":case"function":case"symbol":e.removeAttribute(t);return;case"boolean":var a=t.toLowerCase().slice(0,5);if(a!=="data-"&&a!=="aria-"){e.removeAttribute(t);return}}e.setAttribute(t,""+l)}}function ou(e,t,l){if(l===null)e.removeAttribute(t);else{switch(typeof l){case"undefined":case"function":case"symbol":case"boolean":e.removeAttribute(t);return}e.setAttribute(t,""+l)}}function Ft(e,t,l,a){if(a===null)e.removeAttribute(l);else{switch(typeof a){case"undefined":case"function":case"symbol":case"boolean":e.removeAttribute(l);return}e.setAttributeNS(t,l,""+a)}}function At(e){switch(typeof e){case"bigint":case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function dr(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function C0(e,t,l){var a=Object.getOwnPropertyDescriptor(e.constructor.prototype,t);if(!e.hasOwnProperty(t)&&typeof a<"u"&&typeof a.get=="function"&&typeof a.set=="function"){var n=a.get,u=a.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return n.call(this)},set:function(i){l=""+i,u.call(this,i)}}),Object.defineProperty(e,t,{enumerable:a.enumerable}),{getValue:function(){return l},setValue:function(i){l=""+i},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function Bc(e){if(!e._valueTracker){var t=dr(e)?"checked":"value";e._valueTracker=C0(e,t,""+e[t])}}function mr(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var l=t.getValue(),a="";return e&&(a=dr(e)?e.checked?"true":"false":e.value),e=a,e!==l?(t.setValue(e),!0):!1}function fu(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}var O0=/[\n"\\]/g;function zt(e){return e.replace(O0,function(t){return"\\"+t.charCodeAt(0).toString(16)+" "})}function Hc(e,t,l,a,n,u,i,f){e.name="",i!=null&&typeof i!="function"&&typeof i!="symbol"&&typeof i!="boolean"?e.type=i:e.removeAttribute("type"),t!=null?i==="number"?(t===0&&e.value===""||e.value!=t)&&(e.value=""+At(t)):e.value!==""+At(t)&&(e.value=""+At(t)):i!=="submit"&&i!=="reset"||e.removeAttribute("value"),t!=null?qc(e,i,At(t)):l!=null?qc(e,i,At(l)):a!=null&&e.removeAttribute("value"),n==null&&u!=null&&(e.defaultChecked=!!u),n!=null&&(e.checked=n&&typeof n!="function"&&typeof n!="symbol"),f!=null&&typeof f!="function"&&typeof f!="symbol"&&typeof f!="boolean"?e.name=""+At(f):e.removeAttribute("name")}function hr(e,t,l,a,n,u,i,f){if(u!=null&&typeof u!="function"&&typeof u!="symbol"&&typeof u!="boolean"&&(e.type=u),t!=null||l!=null){if(!(u!=="submit"&&u!=="reset"||t!=null)){Bc(e);return}l=l!=null?""+At(l):"",t=t!=null?""+At(t):l,f||t===e.value||(e.value=t),e.defaultValue=t}a=a??n,a=typeof a!="function"&&typeof a!="symbol"&&!!a,e.checked=f?e.checked:!!a,e.defaultChecked=!!a,i!=null&&typeof i!="function"&&typeof i!="symbol"&&typeof i!="boolean"&&(e.name=i),Bc(e)}function qc(e,t,l){t==="number"&&fu(e.ownerDocument)===e||e.defaultValue===""+l||(e.defaultValue=""+l)}function Ea(e,t,l,a){if(e=e.options,t){t={};for(var n=0;n<l.length;n++)t["$"+l[n]]=!0;for(l=0;l<e.length;l++)n=t.hasOwnProperty("$"+e[l].value),e[l].selected!==n&&(e[l].selected=n),n&&a&&(e[l].defaultSelected=!0)}else{for(l=""+At(l),t=null,n=0;n<e.length;n++){if(e[n].value===l){e[n].selected=!0,a&&(e[n].defaultSelected=!0);return}t!==null||e[n].disabled||(t=e[n])}t!==null&&(t.selected=!0)}}function gr(e,t,l){if(t!=null&&(t=""+At(t),t!==e.value&&(e.value=t),l==null)){e.defaultValue!==t&&(e.defaultValue=t);return}e.defaultValue=l!=null?""+At(l):""}function yr(e,t,l,a){if(t==null){if(a!=null){if(l!=null)throw Error(o(92));if(Q(a)){if(1<a.length)throw Error(o(93));a=a[0]}l=a}l==null&&(l=""),t=l}l=At(t),e.defaultValue=l,a=e.textContent,a===l&&a!==""&&a!==null&&(e.value=a),Bc(e)}function ja(e,t){if(t){var l=e.firstChild;if(l&&l===e.lastChild&&l.nodeType===3){l.nodeValue=t;return}}e.textContent=t}var R0=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function vr(e,t,l){var a=t.indexOf("--")===0;l==null||typeof l=="boolean"||l===""?a?e.setProperty(t,""):t==="float"?e.cssFloat="":e[t]="":a?e.setProperty(t,l):typeof l!="number"||l===0||R0.has(t)?t==="float"?e.cssFloat=l:e[t]=(""+l).trim():e[t]=l+"px"}function br(e,t,l){if(t!=null&&typeof t!="object")throw Error(o(62));if(e=e.style,l!=null){for(var a in l)!l.hasOwnProperty(a)||t!=null&&t.hasOwnProperty(a)||(a.indexOf("--")===0?e.setProperty(a,""):a==="float"?e.cssFloat="":e[a]="");for(var n in t)a=t[n],t.hasOwnProperty(n)&&l[n]!==a&&vr(e,n,a)}else for(var u in t)t.hasOwnProperty(u)&&vr(e,u,t[u])}function Lc(e){if(e.indexOf("-")===-1)return!1;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var U0=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),B0=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function du(e){return B0.test(""+e)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":e}function It(){}var Yc=null;function Gc(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var Na=null,Ta=null;function pr(e){var t=pa(e);if(t&&(e=t.stateNode)){var l=e[dt]||null;e:switch(e=t.stateNode,t.type){case"input":if(Hc(e,l.value,l.defaultValue,l.defaultValue,l.checked,l.defaultChecked,l.type,l.name),t=l.name,l.type==="radio"&&t!=null){for(l=e;l.parentNode;)l=l.parentNode;for(l=l.querySelectorAll('input[name="'+zt(""+t)+'"][type="radio"]'),t=0;t<l.length;t++){var a=l[t];if(a!==e&&a.form===e.form){var n=a[dt]||null;if(!n)throw Error(o(90));Hc(a,n.value,n.defaultValue,n.defaultValue,n.checked,n.defaultChecked,n.type,n.name)}}for(t=0;t<l.length;t++)a=l[t],a.form===e.form&&mr(a)}break e;case"textarea":gr(e,l.value,l.defaultValue);break e;case"select":t=l.value,t!=null&&Ea(e,!!l.multiple,t,!1)}}}var Xc=!1;function xr(e,t,l){if(Xc)return e(t,l);Xc=!0;try{var a=e(t);return a}finally{if(Xc=!1,(Na!==null||Ta!==null)&&(Pu(),Na&&(t=Na,e=Ta,Ta=Na=null,pr(t),e)))for(t=0;t<e.length;t++)pr(e[t])}}function mn(e,t){var l=e.stateNode;if(l===null)return null;var a=l[dt]||null;if(a===null)return null;l=a[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(e=e.type,a=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!a;break e;default:e=!1}if(e)return null;if(l&&typeof l!="function")throw Error(o(231,t,typeof l));return l}var Pt=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Qc=!1;if(Pt)try{var hn={};Object.defineProperty(hn,"passive",{get:function(){Qc=!0}}),window.addEventListener("test",hn,hn),window.removeEventListener("test",hn,hn)}catch{Qc=!1}var xl=null,Zc=null,mu=null;function Sr(){if(mu)return mu;var e,t=Zc,l=t.length,a,n="value"in xl?xl.value:xl.textContent,u=n.length;for(e=0;e<l&&t[e]===n[e];e++);var i=l-e;for(a=1;a<=i&&t[l-a]===n[u-a];a++);return mu=n.slice(e,1<a?1-a:void 0)}function hu(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function gu(){return!0}function Er(){return!1}function mt(e){function t(l,a,n,u,i){this._reactName=l,this._targetInst=n,this.type=a,this.nativeEvent=u,this.target=i,this.currentTarget=null;for(var f in e)e.hasOwnProperty(f)&&(l=e[f],this[f]=l?l(u):u[f]);return this.isDefaultPrevented=(u.defaultPrevented!=null?u.defaultPrevented:u.returnValue===!1)?gu:Er,this.isPropagationStopped=Er,this}return U(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var l=this.nativeEvent;l&&(l.preventDefault?l.preventDefault():typeof l.returnValue!="unknown"&&(l.returnValue=!1),this.isDefaultPrevented=gu)},stopPropagation:function(){var l=this.nativeEvent;l&&(l.stopPropagation?l.stopPropagation():typeof l.cancelBubble!="unknown"&&(l.cancelBubble=!0),this.isPropagationStopped=gu)},persist:function(){},isPersistent:gu}),t}var $l={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},yu=mt($l),gn=U({},$l,{view:0,detail:0}),H0=mt(gn),Vc,Kc,yn,vu=U({},gn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Jc,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==yn&&(yn&&e.type==="mousemove"?(Vc=e.screenX-yn.screenX,Kc=e.screenY-yn.screenY):Kc=Vc=0,yn=e),Vc)},movementY:function(e){return"movementY"in e?e.movementY:Kc}}),jr=mt(vu),q0=U({},vu,{dataTransfer:0}),L0=mt(q0),Y0=U({},gn,{relatedTarget:0}),kc=mt(Y0),G0=U({},$l,{animationName:0,elapsedTime:0,pseudoElement:0}),X0=mt(G0),Q0=U({},$l,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),Z0=mt(Q0),V0=U({},$l,{data:0}),Nr=mt(V0),K0={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},k0={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},J0={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function $0(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=J0[e])?!!t[e]:!1}function Jc(){return $0}var W0=U({},gn,{key:function(e){if(e.key){var t=K0[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=hu(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?k0[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Jc,charCode:function(e){return e.type==="keypress"?hu(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?hu(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),F0=mt(W0),I0=U({},vu,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Tr=mt(I0),P0=U({},gn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Jc}),em=mt(P0),tm=U({},$l,{propertyName:0,elapsedTime:0,pseudoElement:0}),lm=mt(tm),am=U({},vu,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),nm=mt(am),um=U({},$l,{newState:0,oldState:0}),cm=mt(um),im=[9,13,27,32],$c=Pt&&"CompositionEvent"in window,vn=null;Pt&&"documentMode"in document&&(vn=document.documentMode);var sm=Pt&&"TextEvent"in window&&!vn,wr=Pt&&(!$c||vn&&8<vn&&11>=vn),_r=" ",Ar=!1;function zr(e,t){switch(e){case"keyup":return im.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Mr(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var wa=!1;function rm(e,t){switch(e){case"compositionend":return Mr(t);case"keypress":return t.which!==32?null:(Ar=!0,_r);case"textInput":return e=t.data,e===_r&&Ar?null:e;default:return null}}function om(e,t){if(wa)return e==="compositionend"||!$c&&zr(e,t)?(e=Sr(),mu=Zc=xl=null,wa=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return wr&&t.locale!=="ko"?null:t.data;default:return null}}var fm={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Dr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!fm[e.type]:t==="textarea"}function Cr(e,t,l,a){Na?Ta?Ta.push(a):Ta=[a]:Na=a,t=cc(t,"onChange"),0<t.length&&(l=new yu("onChange","change",null,l,a),e.push({event:l,listeners:t}))}var bn=null,pn=null;function dm(e){yd(e,0)}function bu(e){var t=dn(e);if(mr(t))return e}function Or(e,t){if(e==="change")return t}var Rr=!1;if(Pt){var Wc;if(Pt){var Fc="oninput"in document;if(!Fc){var Ur=document.createElement("div");Ur.setAttribute("oninput","return;"),Fc=typeof Ur.oninput=="function"}Wc=Fc}else Wc=!1;Rr=Wc&&(!document.documentMode||9<document.documentMode)}function Br(){bn&&(bn.detachEvent("onpropertychange",Hr),pn=bn=null)}function Hr(e){if(e.propertyName==="value"&&bu(pn)){var t=[];Cr(t,pn,e,Gc(e)),xr(dm,t)}}function mm(e,t,l){e==="focusin"?(Br(),bn=t,pn=l,bn.attachEvent("onpropertychange",Hr)):e==="focusout"&&Br()}function hm(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return bu(pn)}function gm(e,t){if(e==="click")return bu(t)}function ym(e,t){if(e==="input"||e==="change")return bu(t)}function vm(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var xt=typeof Object.is=="function"?Object.is:vm;function xn(e,t){if(xt(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var l=Object.keys(e),a=Object.keys(t);if(l.length!==a.length)return!1;for(a=0;a<l.length;a++){var n=l[a];if(!ma.call(t,n)||!xt(e[n],t[n]))return!1}return!0}function qr(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function Lr(e,t){var l=qr(e);e=0;for(var a;l;){if(l.nodeType===3){if(a=e+l.textContent.length,e<=t&&a>=t)return{node:l,offset:t-e};e=a}e:{for(;l;){if(l.nextSibling){l=l.nextSibling;break e}l=l.parentNode}l=void 0}l=qr(l)}}function Yr(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?Yr(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function Gr(e){e=e!=null&&e.ownerDocument!=null&&e.ownerDocument.defaultView!=null?e.ownerDocument.defaultView:window;for(var t=fu(e.document);t instanceof e.HTMLIFrameElement;){try{var l=typeof t.contentWindow.location.href=="string"}catch{l=!1}if(l)e=t.contentWindow;else break;t=fu(e.document)}return t}function Ic(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}var bm=Pt&&"documentMode"in document&&11>=document.documentMode,_a=null,Pc=null,Sn=null,ei=!1;function Xr(e,t,l){var a=l.window===l?l.document:l.nodeType===9?l:l.ownerDocument;ei||_a==null||_a!==fu(a)||(a=_a,"selectionStart"in a&&Ic(a)?a={start:a.selectionStart,end:a.selectionEnd}:(a=(a.ownerDocument&&a.ownerDocument.defaultView||window).getSelection(),a={anchorNode:a.anchorNode,anchorOffset:a.anchorOffset,focusNode:a.focusNode,focusOffset:a.focusOffset}),Sn&&xn(Sn,a)||(Sn=a,a=cc(Pc,"onSelect"),0<a.length&&(t=new yu("onSelect","select",null,t,l),e.push({event:t,listeners:a}),t.target=_a)))}function Wl(e,t){var l={};return l[e.toLowerCase()]=t.toLowerCase(),l["Webkit"+e]="webkit"+t,l["Moz"+e]="moz"+t,l}var Aa={animationend:Wl("Animation","AnimationEnd"),animationiteration:Wl("Animation","AnimationIteration"),animationstart:Wl("Animation","AnimationStart"),transitionrun:Wl("Transition","TransitionRun"),transitionstart:Wl("Transition","TransitionStart"),transitioncancel:Wl("Transition","TransitionCancel"),transitionend:Wl("Transition","TransitionEnd")},ti={},Qr={};Pt&&(Qr=document.createElement("div").style,"AnimationEvent"in window||(delete Aa.animationend.animation,delete Aa.animationiteration.animation,delete Aa.animationstart.animation),"TransitionEvent"in window||delete Aa.transitionend.transition);function Fl(e){if(ti[e])return ti[e];if(!Aa[e])return e;var t=Aa[e],l;for(l in t)if(t.hasOwnProperty(l)&&l in Qr)return ti[e]=t[l];return e}var Zr=Fl("animationend"),Vr=Fl("animationiteration"),Kr=Fl("animationstart"),pm=Fl("transitionrun"),xm=Fl("transitionstart"),Sm=Fl("transitioncancel"),kr=Fl("transitionend"),Jr=new Map,li="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");li.push("scrollEnd");function Gt(e,t){Jr.set(e,t),Jl(t,[e])}var pu=typeof reportError=="function"?reportError:function(e){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof e=="object"&&e!==null&&typeof e.message=="string"?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",e);return}console.error(e)},Mt=[],za=0,ai=0;function xu(){for(var e=za,t=ai=za=0;t<e;){var l=Mt[t];Mt[t++]=null;var a=Mt[t];Mt[t++]=null;var n=Mt[t];Mt[t++]=null;var u=Mt[t];if(Mt[t++]=null,a!==null&&n!==null){var i=a.pending;i===null?n.next=n:(n.next=i.next,i.next=n),a.pending=n}u!==0&&$r(l,n,u)}}function Su(e,t,l,a){Mt[za++]=e,Mt[za++]=t,Mt[za++]=l,Mt[za++]=a,ai|=a,e.lanes|=a,e=e.alternate,e!==null&&(e.lanes|=a)}function ni(e,t,l,a){return Su(e,t,l,a),Eu(e)}function Il(e,t){return Su(e,null,null,t),Eu(e)}function $r(e,t,l){e.lanes|=l;var a=e.alternate;a!==null&&(a.lanes|=l);for(var n=!1,u=e.return;u!==null;)u.childLanes|=l,a=u.alternate,a!==null&&(a.childLanes|=l),u.tag===22&&(e=u.stateNode,e===null||e._visibility&1||(n=!0)),e=u,u=u.return;return e.tag===3?(u=e.stateNode,n&&t!==null&&(n=31-st(l),e=u.hiddenUpdates,a=e[n],a===null?e[n]=[t]:a.push(t),t.lane=l|536870912),u):null}function Eu(e){if(50<Qn)throw Qn=0,ms=null,Error(o(185));for(var t=e.return;t!==null;)e=t,t=e.return;return e.tag===3?e.stateNode:null}var Ma={};function Em(e,t,l,a){this.tag=e,this.key=l,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function St(e,t,l,a){return new Em(e,t,l,a)}function ui(e){return e=e.prototype,!(!e||!e.isReactComponent)}function el(e,t){var l=e.alternate;return l===null?(l=St(e.tag,t,e.key,e.mode),l.elementType=e.elementType,l.type=e.type,l.stateNode=e.stateNode,l.alternate=e,e.alternate=l):(l.pendingProps=t,l.type=e.type,l.flags=0,l.subtreeFlags=0,l.deletions=null),l.flags=e.flags&65011712,l.childLanes=e.childLanes,l.lanes=e.lanes,l.child=e.child,l.memoizedProps=e.memoizedProps,l.memoizedState=e.memoizedState,l.updateQueue=e.updateQueue,t=e.dependencies,l.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},l.sibling=e.sibling,l.index=e.index,l.ref=e.ref,l.refCleanup=e.refCleanup,l}function Wr(e,t){e.flags&=65011714;var l=e.alternate;return l===null?(e.childLanes=0,e.lanes=t,e.child=null,e.subtreeFlags=0,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null,e.stateNode=null):(e.childLanes=l.childLanes,e.lanes=l.lanes,e.child=l.child,e.subtreeFlags=0,e.deletions=null,e.memoizedProps=l.memoizedProps,e.memoizedState=l.memoizedState,e.updateQueue=l.updateQueue,e.type=l.type,t=l.dependencies,e.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext}),e}function ju(e,t,l,a,n,u){var i=0;if(a=e,typeof e=="function")ui(e)&&(i=1);else if(typeof e=="string")i=_h(e,l,G.current)?26:e==="html"||e==="head"||e==="body"?27:5;else e:switch(e){case Ee:return e=St(31,l,t,n),e.elementType=Ee,e.lanes=u,e;case ue:return Pl(l.children,n,u,t);case re:i=8,n|=24;break;case ce:return e=St(12,l,t,n|2),e.elementType=ce,e.lanes=u,e;case ge:return e=St(13,l,t,n),e.elementType=ge,e.lanes=u,e;case ae:return e=St(19,l,t,n),e.elementType=ae,e.lanes=u,e;default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case I:i=10;break e;case ie:i=9;break e;case de:i=11;break e;case X:i=14;break e;case F:i=16,a=null;break e}i=29,l=Error(o(130,e===null?"null":typeof e,"")),a=null}return t=St(i,l,t,n),t.elementType=e,t.type=a,t.lanes=u,t}function Pl(e,t,l,a){return e=St(7,e,a,t),e.lanes=l,e}function ci(e,t,l){return e=St(6,e,null,t),e.lanes=l,e}function Fr(e){var t=St(18,null,null,0);return t.stateNode=e,t}function ii(e,t,l){return t=St(4,e.children!==null?e.children:[],e.key,t),t.lanes=l,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}var Ir=new WeakMap;function Dt(e,t){if(typeof e=="object"&&e!==null){var l=Ir.get(e);return l!==void 0?l:(t={value:e,source:t,stack:bl(t)},Ir.set(e,t),t)}return{value:e,source:t,stack:bl(t)}}var Da=[],Ca=0,Nu=null,En=0,Ct=[],Ot=0,Sl=null,Kt=1,kt="";function tl(e,t){Da[Ca++]=En,Da[Ca++]=Nu,Nu=e,En=t}function Pr(e,t,l){Ct[Ot++]=Kt,Ct[Ot++]=kt,Ct[Ot++]=Sl,Sl=e;var a=Kt;e=kt;var n=32-st(a)-1;a&=~(1<<n),l+=1;var u=32-st(t)+n;if(30<u){var i=n-n%5;u=(a&(1<<i)-1).toString(32),a>>=i,n-=i,Kt=1<<32-st(t)+n|l<<n|a,kt=u+e}else Kt=1<<u|l<<n|a,kt=e}function si(e){e.return!==null&&(tl(e,1),Pr(e,1,0))}function ri(e){for(;e===Nu;)Nu=Da[--Ca],Da[Ca]=null,En=Da[--Ca],Da[Ca]=null;for(;e===Sl;)Sl=Ct[--Ot],Ct[Ot]=null,kt=Ct[--Ot],Ct[Ot]=null,Kt=Ct[--Ot],Ct[Ot]=null}function eo(e,t){Ct[Ot++]=Kt,Ct[Ot++]=kt,Ct[Ot++]=Sl,Kt=t.id,kt=t.overflow,Sl=e}var tt=null,He=null,Se=!1,El=null,Rt=!1,oi=Error(o(519));function jl(e){var t=Error(o(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw jn(Dt(t,e)),oi}function to(e){var t=e.stateNode,l=e.type,a=e.memoizedProps;switch(t[et]=e,t[dt]=a,l){case"dialog":be("cancel",t),be("close",t);break;case"iframe":case"object":case"embed":be("load",t);break;case"video":case"audio":for(l=0;l<Vn.length;l++)be(Vn[l],t);break;case"source":be("error",t);break;case"img":case"image":case"link":be("error",t),be("load",t);break;case"details":be("toggle",t);break;case"input":be("invalid",t),hr(t,a.value,a.defaultValue,a.checked,a.defaultChecked,a.type,a.name,!0);break;case"select":be("invalid",t);break;case"textarea":be("invalid",t),yr(t,a.value,a.defaultValue,a.children)}l=a.children,typeof l!="string"&&typeof l!="number"&&typeof l!="bigint"||t.textContent===""+l||a.suppressHydrationWarning===!0||xd(t.textContent,l)?(a.popover!=null&&(be("beforetoggle",t),be("toggle",t)),a.onScroll!=null&&be("scroll",t),a.onScrollEnd!=null&&be("scrollend",t),a.onClick!=null&&(t.onclick=It),t=!0):t=!1,t||jl(e,!0)}function lo(e){for(tt=e.return;tt;)switch(tt.tag){case 5:case 31:case 13:Rt=!1;return;case 27:case 3:Rt=!0;return;default:tt=tt.return}}function Oa(e){if(e!==tt)return!1;if(!Se)return lo(e),Se=!0,!1;var t=e.tag,l;if((l=t!==3&&t!==27)&&((l=t===5)&&(l=e.type,l=!(l!=="form"&&l!=="button")||As(e.type,e.memoizedProps)),l=!l),l&&He&&jl(e),lo(e),t===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(o(317));He=zd(e)}else if(t===31){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(o(317));He=zd(e)}else t===27?(t=He,Hl(e.type)?(e=Os,Os=null,He=e):He=t):He=tt?Bt(e.stateNode.nextSibling):null;return!0}function ea(){He=tt=null,Se=!1}function fi(){var e=El;return e!==null&&(vt===null?vt=e:vt.push.apply(vt,e),El=null),e}function jn(e){El===null?El=[e]:El.push(e)}var di=m(null),ta=null,ll=null;function Nl(e,t,l){C(di,t._currentValue),t._currentValue=l}function al(e){e._currentValue=di.current,_(di)}function mi(e,t,l){for(;e!==null;){var a=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,a!==null&&(a.childLanes|=t)):a!==null&&(a.childLanes&t)!==t&&(a.childLanes|=t),e===l)break;e=e.return}}function hi(e,t,l,a){var n=e.child;for(n!==null&&(n.return=e);n!==null;){var u=n.dependencies;if(u!==null){var i=n.child;u=u.firstContext;e:for(;u!==null;){var f=u;u=n;for(var h=0;h<t.length;h++)if(f.context===t[h]){u.lanes|=l,f=u.alternate,f!==null&&(f.lanes|=l),mi(u.return,l,e),a||(i=null);break e}u=f.next}}else if(n.tag===18){if(i=n.return,i===null)throw Error(o(341));i.lanes|=l,u=i.alternate,u!==null&&(u.lanes|=l),mi(i,l,e),i=null}else i=n.child;if(i!==null)i.return=n;else for(i=n;i!==null;){if(i===e){i=null;break}if(n=i.sibling,n!==null){n.return=i.return,i=n;break}i=i.return}n=i}}function Ra(e,t,l,a){e=null;for(var n=t,u=!1;n!==null;){if(!u){if((n.flags&524288)!==0)u=!0;else if((n.flags&262144)!==0)break}if(n.tag===10){var i=n.alternate;if(i===null)throw Error(o(387));if(i=i.memoizedProps,i!==null){var f=n.type;xt(n.pendingProps.value,i.value)||(e!==null?e.push(f):e=[f])}}else if(n===P.current){if(i=n.alternate,i===null)throw Error(o(387));i.memoizedState.memoizedState!==n.memoizedState.memoizedState&&(e!==null?e.push(Wn):e=[Wn])}n=n.return}e!==null&&hi(t,e,l,a),t.flags|=262144}function Tu(e){for(e=e.firstContext;e!==null;){if(!xt(e.context._currentValue,e.memoizedValue))return!0;e=e.next}return!1}function la(e){ta=e,ll=null,e=e.dependencies,e!==null&&(e.firstContext=null)}function lt(e){return ao(ta,e)}function wu(e,t){return ta===null&&la(e),ao(e,t)}function ao(e,t){var l=t._currentValue;if(t={context:t,memoizedValue:l,next:null},ll===null){if(e===null)throw Error(o(308));ll=t,e.dependencies={lanes:0,firstContext:t},e.flags|=524288}else ll=ll.next=t;return l}var jm=typeof AbortController<"u"?AbortController:function(){var e=[],t=this.signal={aborted:!1,addEventListener:function(l,a){e.push(a)}};this.abort=function(){t.aborted=!0,e.forEach(function(l){return l()})}},Nm=c.unstable_scheduleCallback,Tm=c.unstable_NormalPriority,Ze={$$typeof:I,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function gi(){return{controller:new jm,data:new Map,refCount:0}}function Nn(e){e.refCount--,e.refCount===0&&Nm(Tm,function(){e.controller.abort()})}var Tn=null,yi=0,Ua=0,Ba=null;function wm(e,t){if(Tn===null){var l=Tn=[];yi=0,Ua=ps(),Ba={status:"pending",value:void 0,then:function(a){l.push(a)}}}return yi++,t.then(no,no),t}function no(){if(--yi===0&&Tn!==null){Ba!==null&&(Ba.status="fulfilled");var e=Tn;Tn=null,Ua=0,Ba=null;for(var t=0;t<e.length;t++)(0,e[t])()}}function _m(e,t){var l=[],a={status:"pending",value:null,reason:null,then:function(n){l.push(n)}};return e.then(function(){a.status="fulfilled",a.value=t;for(var n=0;n<l.length;n++)(0,l[n])(t)},function(n){for(a.status="rejected",a.reason=n,n=0;n<l.length;n++)(0,l[n])(void 0)}),a}var uo=S.S;S.S=function(e,t){Zf=ct(),typeof t=="object"&&t!==null&&typeof t.then=="function"&&wm(e,t),uo!==null&&uo(e,t)};var aa=m(null);function vi(){var e=aa.current;return e!==null?e:Ue.pooledCache}function _u(e,t){t===null?C(aa,aa.current):C(aa,t.pool)}function co(){var e=vi();return e===null?null:{parent:Ze._currentValue,pool:e}}var Ha=Error(o(460)),bi=Error(o(474)),Au=Error(o(542)),zu={then:function(){}};function io(e){return e=e.status,e==="fulfilled"||e==="rejected"}function so(e,t,l){switch(l=e[l],l===void 0?e.push(t):l!==t&&(t.then(It,It),t=l),t.status){case"fulfilled":return t.value;case"rejected":throw e=t.reason,oo(e),e;default:if(typeof t.status=="string")t.then(It,It);else{if(e=Ue,e!==null&&100<e.shellSuspendCounter)throw Error(o(482));e=t,e.status="pending",e.then(function(a){if(t.status==="pending"){var n=t;n.status="fulfilled",n.value=a}},function(a){if(t.status==="pending"){var n=t;n.status="rejected",n.reason=a}})}switch(t.status){case"fulfilled":return t.value;case"rejected":throw e=t.reason,oo(e),e}throw ua=t,Ha}}function na(e){try{var t=e._init;return t(e._payload)}catch(l){throw l!==null&&typeof l=="object"&&typeof l.then=="function"?(ua=l,Ha):l}}var ua=null;function ro(){if(ua===null)throw Error(o(459));var e=ua;return ua=null,e}function oo(e){if(e===Ha||e===Au)throw Error(o(483))}var qa=null,wn=0;function Mu(e){var t=wn;return wn+=1,qa===null&&(qa=[]),so(qa,e,t)}function _n(e,t){t=t.props.ref,e.ref=t!==void 0?t:null}function Du(e,t){throw t.$$typeof===L?Error(o(525)):(e=Object.prototype.toString.call(t),Error(o(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e)))}function fo(e){function t(p,v){if(e){var E=p.deletions;E===null?(p.deletions=[v],p.flags|=16):E.push(v)}}function l(p,v){if(!e)return null;for(;v!==null;)t(p,v),v=v.sibling;return null}function a(p){for(var v=new Map;p!==null;)p.key!==null?v.set(p.key,p):v.set(p.index,p),p=p.sibling;return v}function n(p,v){return p=el(p,v),p.index=0,p.sibling=null,p}function u(p,v,E){return p.index=E,e?(E=p.alternate,E!==null?(E=E.index,E<v?(p.flags|=67108866,v):E):(p.flags|=67108866,v)):(p.flags|=1048576,v)}function i(p){return e&&p.alternate===null&&(p.flags|=67108866),p}function f(p,v,E,R){return v===null||v.tag!==6?(v=ci(E,p.mode,R),v.return=p,v):(v=n(v,E),v.return=p,v)}function h(p,v,E,R){var ee=E.type;return ee===ue?D(p,v,E.props.children,R,E.key):v!==null&&(v.elementType===ee||typeof ee=="object"&&ee!==null&&ee.$$typeof===F&&na(ee)===v.type)?(v=n(v,E.props),_n(v,E),v.return=p,v):(v=ju(E.type,E.key,E.props,null,p.mode,R),_n(v,E),v.return=p,v)}function j(p,v,E,R){return v===null||v.tag!==4||v.stateNode.containerInfo!==E.containerInfo||v.stateNode.implementation!==E.implementation?(v=ii(E,p.mode,R),v.return=p,v):(v=n(v,E.children||[]),v.return=p,v)}function D(p,v,E,R,ee){return v===null||v.tag!==7?(v=Pl(E,p.mode,R,ee),v.return=p,v):(v=n(v,E),v.return=p,v)}function B(p,v,E){if(typeof v=="string"&&v!==""||typeof v=="number"||typeof v=="bigint")return v=ci(""+v,p.mode,E),v.return=p,v;if(typeof v=="object"&&v!==null){switch(v.$$typeof){case J:return E=ju(v.type,v.key,v.props,null,p.mode,E),_n(E,v),E.return=p,E;case se:return v=ii(v,p.mode,E),v.return=p,v;case F:return v=na(v),B(p,v,E)}if(Q(v)||k(v))return v=Pl(v,p.mode,E,null),v.return=p,v;if(typeof v.then=="function")return B(p,Mu(v),E);if(v.$$typeof===I)return B(p,wu(p,v),E);Du(p,v)}return null}function T(p,v,E,R){var ee=v!==null?v.key:null;if(typeof E=="string"&&E!==""||typeof E=="number"||typeof E=="bigint")return ee!==null?null:f(p,v,""+E,R);if(typeof E=="object"&&E!==null){switch(E.$$typeof){case J:return E.key===ee?h(p,v,E,R):null;case se:return E.key===ee?j(p,v,E,R):null;case F:return E=na(E),T(p,v,E,R)}if(Q(E)||k(E))return ee!==null?null:D(p,v,E,R,null);if(typeof E.then=="function")return T(p,v,Mu(E),R);if(E.$$typeof===I)return T(p,v,wu(p,E),R);Du(p,E)}return null}function z(p,v,E,R,ee){if(typeof R=="string"&&R!==""||typeof R=="number"||typeof R=="bigint")return p=p.get(E)||null,f(v,p,""+R,ee);if(typeof R=="object"&&R!==null){switch(R.$$typeof){case J:return p=p.get(R.key===null?E:R.key)||null,h(v,p,R,ee);case se:return p=p.get(R.key===null?E:R.key)||null,j(v,p,R,ee);case F:return R=na(R),z(p,v,E,R,ee)}if(Q(R)||k(R))return p=p.get(E)||null,D(v,p,R,ee,null);if(typeof R.then=="function")return z(p,v,E,Mu(R),ee);if(R.$$typeof===I)return z(p,v,E,wu(v,R),ee);Du(v,R)}return null}function $(p,v,E,R){for(var ee=null,Te=null,W=v,me=v=0,xe=null;W!==null&&me<E.length;me++){W.index>me?(xe=W,W=null):xe=W.sibling;var we=T(p,W,E[me],R);if(we===null){W===null&&(W=xe);break}e&&W&&we.alternate===null&&t(p,W),v=u(we,v,me),Te===null?ee=we:Te.sibling=we,Te=we,W=xe}if(me===E.length)return l(p,W),Se&&tl(p,me),ee;if(W===null){for(;me<E.length;me++)W=B(p,E[me],R),W!==null&&(v=u(W,v,me),Te===null?ee=W:Te.sibling=W,Te=W);return Se&&tl(p,me),ee}for(W=a(W);me<E.length;me++)xe=z(W,p,me,E[me],R),xe!==null&&(e&&xe.alternate!==null&&W.delete(xe.key===null?me:xe.key),v=u(xe,v,me),Te===null?ee=xe:Te.sibling=xe,Te=xe);return e&&W.forEach(function(Xl){return t(p,Xl)}),Se&&tl(p,me),ee}function ne(p,v,E,R){if(E==null)throw Error(o(151));for(var ee=null,Te=null,W=v,me=v=0,xe=null,we=E.next();W!==null&&!we.done;me++,we=E.next()){W.index>me?(xe=W,W=null):xe=W.sibling;var Xl=T(p,W,we.value,R);if(Xl===null){W===null&&(W=xe);break}e&&W&&Xl.alternate===null&&t(p,W),v=u(Xl,v,me),Te===null?ee=Xl:Te.sibling=Xl,Te=Xl,W=xe}if(we.done)return l(p,W),Se&&tl(p,me),ee;if(W===null){for(;!we.done;me++,we=E.next())we=B(p,we.value,R),we!==null&&(v=u(we,v,me),Te===null?ee=we:Te.sibling=we,Te=we);return Se&&tl(p,me),ee}for(W=a(W);!we.done;me++,we=E.next())we=z(W,p,me,we.value,R),we!==null&&(e&&we.alternate!==null&&W.delete(we.key===null?me:we.key),v=u(we,v,me),Te===null?ee=we:Te.sibling=we,Te=we);return e&&W.forEach(function(qh){return t(p,qh)}),Se&&tl(p,me),ee}function Oe(p,v,E,R){if(typeof E=="object"&&E!==null&&E.type===ue&&E.key===null&&(E=E.props.children),typeof E=="object"&&E!==null){switch(E.$$typeof){case J:e:{for(var ee=E.key;v!==null;){if(v.key===ee){if(ee=E.type,ee===ue){if(v.tag===7){l(p,v.sibling),R=n(v,E.props.children),R.return=p,p=R;break e}}else if(v.elementType===ee||typeof ee=="object"&&ee!==null&&ee.$$typeof===F&&na(ee)===v.type){l(p,v.sibling),R=n(v,E.props),_n(R,E),R.return=p,p=R;break e}l(p,v);break}else t(p,v);v=v.sibling}E.type===ue?(R=Pl(E.props.children,p.mode,R,E.key),R.return=p,p=R):(R=ju(E.type,E.key,E.props,null,p.mode,R),_n(R,E),R.return=p,p=R)}return i(p);case se:e:{for(ee=E.key;v!==null;){if(v.key===ee)if(v.tag===4&&v.stateNode.containerInfo===E.containerInfo&&v.stateNode.implementation===E.implementation){l(p,v.sibling),R=n(v,E.children||[]),R.return=p,p=R;break e}else{l(p,v);break}else t(p,v);v=v.sibling}R=ii(E,p.mode,R),R.return=p,p=R}return i(p);case F:return E=na(E),Oe(p,v,E,R)}if(Q(E))return $(p,v,E,R);if(k(E)){if(ee=k(E),typeof ee!="function")throw Error(o(150));return E=ee.call(E),ne(p,v,E,R)}if(typeof E.then=="function")return Oe(p,v,Mu(E),R);if(E.$$typeof===I)return Oe(p,v,wu(p,E),R);Du(p,E)}return typeof E=="string"&&E!==""||typeof E=="number"||typeof E=="bigint"?(E=""+E,v!==null&&v.tag===6?(l(p,v.sibling),R=n(v,E),R.return=p,p=R):(l(p,v),R=ci(E,p.mode,R),R.return=p,p=R),i(p)):l(p,v)}return function(p,v,E,R){try{wn=0;var ee=Oe(p,v,E,R);return qa=null,ee}catch(W){if(W===Ha||W===Au)throw W;var Te=St(29,W,null,p.mode);return Te.lanes=R,Te.return=p,Te}finally{}}}var ca=fo(!0),mo=fo(!1),Tl=!1;function pi(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function xi(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,callbacks:null})}function wl(e){return{lane:e,tag:0,payload:null,callback:null,next:null}}function _l(e,t,l){var a=e.updateQueue;if(a===null)return null;if(a=a.shared,(_e&2)!==0){var n=a.pending;return n===null?t.next=t:(t.next=n.next,n.next=t),a.pending=t,t=Eu(e),$r(e,null,l),t}return Su(e,a,t,l),Eu(e)}function An(e,t,l){if(t=t.updateQueue,t!==null&&(t=t.shared,(l&4194048)!==0)){var a=t.lanes;a&=e.pendingLanes,l|=a,t.lanes=l,ar(e,l)}}function Si(e,t){var l=e.updateQueue,a=e.alternate;if(a!==null&&(a=a.updateQueue,l===a)){var n=null,u=null;if(l=l.firstBaseUpdate,l!==null){do{var i={lane:l.lane,tag:l.tag,payload:l.payload,callback:null,next:null};u===null?n=u=i:u=u.next=i,l=l.next}while(l!==null);u===null?n=u=t:u=u.next=t}else n=u=t;l={baseState:a.baseState,firstBaseUpdate:n,lastBaseUpdate:u,shared:a.shared,callbacks:a.callbacks},e.updateQueue=l;return}e=l.lastBaseUpdate,e===null?l.firstBaseUpdate=t:e.next=t,l.lastBaseUpdate=t}var Ei=!1;function zn(){if(Ei){var e=Ba;if(e!==null)throw e}}function Mn(e,t,l,a){Ei=!1;var n=e.updateQueue;Tl=!1;var u=n.firstBaseUpdate,i=n.lastBaseUpdate,f=n.shared.pending;if(f!==null){n.shared.pending=null;var h=f,j=h.next;h.next=null,i===null?u=j:i.next=j,i=h;var D=e.alternate;D!==null&&(D=D.updateQueue,f=D.lastBaseUpdate,f!==i&&(f===null?D.firstBaseUpdate=j:f.next=j,D.lastBaseUpdate=h))}if(u!==null){var B=n.baseState;i=0,D=j=h=null,f=u;do{var T=f.lane&-536870913,z=T!==f.lane;if(z?(pe&T)===T:(a&T)===T){T!==0&&T===Ua&&(Ei=!0),D!==null&&(D=D.next={lane:0,tag:f.tag,payload:f.payload,callback:null,next:null});e:{var $=e,ne=f;T=t;var Oe=l;switch(ne.tag){case 1:if($=ne.payload,typeof $=="function"){B=$.call(Oe,B,T);break e}B=$;break e;case 3:$.flags=$.flags&-65537|128;case 0:if($=ne.payload,T=typeof $=="function"?$.call(Oe,B,T):$,T==null)break e;B=U({},B,T);break e;case 2:Tl=!0}}T=f.callback,T!==null&&(e.flags|=64,z&&(e.flags|=8192),z=n.callbacks,z===null?n.callbacks=[T]:z.push(T))}else z={lane:T,tag:f.tag,payload:f.payload,callback:f.callback,next:null},D===null?(j=D=z,h=B):D=D.next=z,i|=T;if(f=f.next,f===null){if(f=n.shared.pending,f===null)break;z=f,f=z.next,z.next=null,n.lastBaseUpdate=z,n.shared.pending=null}}while(!0);D===null&&(h=B),n.baseState=h,n.firstBaseUpdate=j,n.lastBaseUpdate=D,u===null&&(n.shared.lanes=0),Cl|=i,e.lanes=i,e.memoizedState=B}}function ho(e,t){if(typeof e!="function")throw Error(o(191,e));e.call(t)}function go(e,t){var l=e.callbacks;if(l!==null)for(e.callbacks=null,e=0;e<l.length;e++)ho(l[e],t)}var La=m(null),Cu=m(0);function yo(e,t){e=dl,C(Cu,e),C(La,t),dl=e|t.baseLanes}function ji(){C(Cu,dl),C(La,La.current)}function Ni(){dl=Cu.current,_(La),_(Cu)}var Et=m(null),Ut=null;function Al(e){var t=e.alternate;C(Xe,Xe.current&1),C(Et,e),Ut===null&&(t===null||La.current!==null||t.memoizedState!==null)&&(Ut=e)}function Ti(e){C(Xe,Xe.current),C(Et,e),Ut===null&&(Ut=e)}function vo(e){e.tag===22?(C(Xe,Xe.current),C(Et,e),Ut===null&&(Ut=e)):zl()}function zl(){C(Xe,Xe.current),C(Et,Et.current)}function jt(e){_(Et),Ut===e&&(Ut=null),_(Xe)}var Xe=m(0);function Ou(e){for(var t=e;t!==null;){if(t.tag===13){var l=t.memoizedState;if(l!==null&&(l=l.dehydrated,l===null||Ds(l)||Cs(l)))return t}else if(t.tag===19&&(t.memoizedProps.revealOrder==="forwards"||t.memoizedProps.revealOrder==="backwards"||t.memoizedProps.revealOrder==="unstable_legacy-backwards"||t.memoizedProps.revealOrder==="together")){if((t.flags&128)!==0)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var nl=0,fe=null,De=null,Ve=null,Ru=!1,Ya=!1,ia=!1,Uu=0,Dn=0,Ga=null,Am=0;function Ye(){throw Error(o(321))}function wi(e,t){if(t===null)return!1;for(var l=0;l<t.length&&l<e.length;l++)if(!xt(e[l],t[l]))return!1;return!0}function _i(e,t,l,a,n,u){return nl=u,fe=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,S.H=e===null||e.memoizedState===null?ef:Xi,ia=!1,u=l(a,n),ia=!1,Ya&&(u=po(t,l,a,n)),bo(e),u}function bo(e){S.H=Rn;var t=De!==null&&De.next!==null;if(nl=0,Ve=De=fe=null,Ru=!1,Dn=0,Ga=null,t)throw Error(o(300));e===null||Ke||(e=e.dependencies,e!==null&&Tu(e)&&(Ke=!0))}function po(e,t,l,a){fe=e;var n=0;do{if(Ya&&(Ga=null),Dn=0,Ya=!1,25<=n)throw Error(o(301));if(n+=1,Ve=De=null,e.updateQueue!=null){var u=e.updateQueue;u.lastEffect=null,u.events=null,u.stores=null,u.memoCache!=null&&(u.memoCache.index=0)}S.H=tf,u=t(l,a)}while(Ya);return u}function zm(){var e=S.H,t=e.useState()[0];return t=typeof t.then=="function"?Cn(t):t,e=e.useState()[0],(De!==null?De.memoizedState:null)!==e&&(fe.flags|=1024),t}function Ai(){var e=Uu!==0;return Uu=0,e}function zi(e,t,l){t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~l}function Mi(e){if(Ru){for(e=e.memoizedState;e!==null;){var t=e.queue;t!==null&&(t.pending=null),e=e.next}Ru=!1}nl=0,Ve=De=fe=null,Ya=!1,Dn=Uu=0,Ga=null}function rt(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Ve===null?fe.memoizedState=Ve=e:Ve=Ve.next=e,Ve}function Qe(){if(De===null){var e=fe.alternate;e=e!==null?e.memoizedState:null}else e=De.next;var t=Ve===null?fe.memoizedState:Ve.next;if(t!==null)Ve=t,De=e;else{if(e===null)throw fe.alternate===null?Error(o(467)):Error(o(310));De=e,e={memoizedState:De.memoizedState,baseState:De.baseState,baseQueue:De.baseQueue,queue:De.queue,next:null},Ve===null?fe.memoizedState=Ve=e:Ve=Ve.next=e}return Ve}function Bu(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Cn(e){var t=Dn;return Dn+=1,Ga===null&&(Ga=[]),e=so(Ga,e,t),t=fe,(Ve===null?t.memoizedState:Ve.next)===null&&(t=t.alternate,S.H=t===null||t.memoizedState===null?ef:Xi),e}function Hu(e){if(e!==null&&typeof e=="object"){if(typeof e.then=="function")return Cn(e);if(e.$$typeof===I)return lt(e)}throw Error(o(438,String(e)))}function Di(e){var t=null,l=fe.updateQueue;if(l!==null&&(t=l.memoCache),t==null){var a=fe.alternate;a!==null&&(a=a.updateQueue,a!==null&&(a=a.memoCache,a!=null&&(t={data:a.data.map(function(n){return n.slice()}),index:0})))}if(t==null&&(t={data:[],index:0}),l===null&&(l=Bu(),fe.updateQueue=l),l.memoCache=t,l=t.data[t.index],l===void 0)for(l=t.data[t.index]=Array(e),a=0;a<e;a++)l[a]=je;return t.index++,l}function ul(e,t){return typeof t=="function"?t(e):t}function qu(e){var t=Qe();return Ci(t,De,e)}function Ci(e,t,l){var a=e.queue;if(a===null)throw Error(o(311));a.lastRenderedReducer=l;var n=e.baseQueue,u=a.pending;if(u!==null){if(n!==null){var i=n.next;n.next=u.next,u.next=i}t.baseQueue=n=u,a.pending=null}if(u=e.baseState,n===null)e.memoizedState=u;else{t=n.next;var f=i=null,h=null,j=t,D=!1;do{var B=j.lane&-536870913;if(B!==j.lane?(pe&B)===B:(nl&B)===B){var T=j.revertLane;if(T===0)h!==null&&(h=h.next={lane:0,revertLane:0,gesture:null,action:j.action,hasEagerState:j.hasEagerState,eagerState:j.eagerState,next:null}),B===Ua&&(D=!0);else if((nl&T)===T){j=j.next,T===Ua&&(D=!0);continue}else B={lane:0,revertLane:j.revertLane,gesture:null,action:j.action,hasEagerState:j.hasEagerState,eagerState:j.eagerState,next:null},h===null?(f=h=B,i=u):h=h.next=B,fe.lanes|=T,Cl|=T;B=j.action,ia&&l(u,B),u=j.hasEagerState?j.eagerState:l(u,B)}else T={lane:B,revertLane:j.revertLane,gesture:j.gesture,action:j.action,hasEagerState:j.hasEagerState,eagerState:j.eagerState,next:null},h===null?(f=h=T,i=u):h=h.next=T,fe.lanes|=B,Cl|=B;j=j.next}while(j!==null&&j!==t);if(h===null?i=u:h.next=f,!xt(u,e.memoizedState)&&(Ke=!0,D&&(l=Ba,l!==null)))throw l;e.memoizedState=u,e.baseState=i,e.baseQueue=h,a.lastRenderedState=u}return n===null&&(a.lanes=0),[e.memoizedState,a.dispatch]}function Oi(e){var t=Qe(),l=t.queue;if(l===null)throw Error(o(311));l.lastRenderedReducer=e;var a=l.dispatch,n=l.pending,u=t.memoizedState;if(n!==null){l.pending=null;var i=n=n.next;do u=e(u,i.action),i=i.next;while(i!==n);xt(u,t.memoizedState)||(Ke=!0),t.memoizedState=u,t.baseQueue===null&&(t.baseState=u),l.lastRenderedState=u}return[u,a]}function xo(e,t,l){var a=fe,n=Qe(),u=Se;if(u){if(l===void 0)throw Error(o(407));l=l()}else l=t();var i=!xt((De||n).memoizedState,l);if(i&&(n.memoizedState=l,Ke=!0),n=n.queue,Bi(jo.bind(null,a,n,e),[e]),n.getSnapshot!==t||i||Ve!==null&&Ve.memoizedState.tag&1){if(a.flags|=2048,Xa(9,{destroy:void 0},Eo.bind(null,a,n,l,t),null),Ue===null)throw Error(o(349));u||(nl&127)!==0||So(a,t,l)}return l}function So(e,t,l){e.flags|=16384,e={getSnapshot:t,value:l},t=fe.updateQueue,t===null?(t=Bu(),fe.updateQueue=t,t.stores=[e]):(l=t.stores,l===null?t.stores=[e]:l.push(e))}function Eo(e,t,l,a){t.value=l,t.getSnapshot=a,No(t)&&To(e)}function jo(e,t,l){return l(function(){No(t)&&To(e)})}function No(e){var t=e.getSnapshot;e=e.value;try{var l=t();return!xt(e,l)}catch{return!0}}function To(e){var t=Il(e,2);t!==null&&bt(t,e,2)}function Ri(e){var t=rt();if(typeof e=="function"){var l=e;if(e=l(),ia){Lt(!0);try{l()}finally{Lt(!1)}}}return t.memoizedState=t.baseState=e,t.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:ul,lastRenderedState:e},t}function wo(e,t,l,a){return e.baseState=l,Ci(e,De,typeof a=="function"?a:ul)}function Mm(e,t,l,a,n){if(Gu(e))throw Error(o(485));if(e=t.action,e!==null){var u={payload:n,action:e,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(i){u.listeners.push(i)}};S.T!==null?l(!0):u.isTransition=!1,a(u),l=t.pending,l===null?(u.next=t.pending=u,_o(t,u)):(u.next=l.next,t.pending=l.next=u)}}function _o(e,t){var l=t.action,a=t.payload,n=e.state;if(t.isTransition){var u=S.T,i={};S.T=i;try{var f=l(n,a),h=S.S;h!==null&&h(i,f),Ao(e,t,f)}catch(j){Ui(e,t,j)}finally{u!==null&&i.types!==null&&(u.types=i.types),S.T=u}}else try{u=l(n,a),Ao(e,t,u)}catch(j){Ui(e,t,j)}}function Ao(e,t,l){l!==null&&typeof l=="object"&&typeof l.then=="function"?l.then(function(a){zo(e,t,a)},function(a){return Ui(e,t,a)}):zo(e,t,l)}function zo(e,t,l){t.status="fulfilled",t.value=l,Mo(t),e.state=l,t=e.pending,t!==null&&(l=t.next,l===t?e.pending=null:(l=l.next,t.next=l,_o(e,l)))}function Ui(e,t,l){var a=e.pending;if(e.pending=null,a!==null){a=a.next;do t.status="rejected",t.reason=l,Mo(t),t=t.next;while(t!==a)}e.action=null}function Mo(e){e=e.listeners;for(var t=0;t<e.length;t++)(0,e[t])()}function Do(e,t){return t}function Co(e,t){if(Se){var l=Ue.formState;if(l!==null){e:{var a=fe;if(Se){if(He){t:{for(var n=He,u=Rt;n.nodeType!==8;){if(!u){n=null;break t}if(n=Bt(n.nextSibling),n===null){n=null;break t}}u=n.data,n=u==="F!"||u==="F"?n:null}if(n){He=Bt(n.nextSibling),a=n.data==="F!";break e}}jl(a)}a=!1}a&&(t=l[0])}}return l=rt(),l.memoizedState=l.baseState=t,a={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Do,lastRenderedState:t},l.queue=a,l=Fo.bind(null,fe,a),a.dispatch=l,a=Ri(!1),u=Gi.bind(null,fe,!1,a.queue),a=rt(),n={state:t,dispatch:null,action:e,pending:null},a.queue=n,l=Mm.bind(null,fe,n,u,l),n.dispatch=l,a.memoizedState=e,[t,l,!1]}function Oo(e){var t=Qe();return Ro(t,De,e)}function Ro(e,t,l){if(t=Ci(e,t,Do)[0],e=qu(ul)[0],typeof t=="object"&&t!==null&&typeof t.then=="function")try{var a=Cn(t)}catch(i){throw i===Ha?Au:i}else a=t;t=Qe();var n=t.queue,u=n.dispatch;return l!==t.memoizedState&&(fe.flags|=2048,Xa(9,{destroy:void 0},Dm.bind(null,n,l),null)),[a,u,e]}function Dm(e,t){e.action=t}function Uo(e){var t=Qe(),l=De;if(l!==null)return Ro(t,l,e);Qe(),t=t.memoizedState,l=Qe();var a=l.queue.dispatch;return l.memoizedState=e,[t,a,!1]}function Xa(e,t,l,a){return e={tag:e,create:l,deps:a,inst:t,next:null},t=fe.updateQueue,t===null&&(t=Bu(),fe.updateQueue=t),l=t.lastEffect,l===null?t.lastEffect=e.next=e:(a=l.next,l.next=e,e.next=a,t.lastEffect=e),e}function Bo(){return Qe().memoizedState}function Lu(e,t,l,a){var n=rt();fe.flags|=e,n.memoizedState=Xa(1|t,{destroy:void 0},l,a===void 0?null:a)}function Yu(e,t,l,a){var n=Qe();a=a===void 0?null:a;var u=n.memoizedState.inst;De!==null&&a!==null&&wi(a,De.memoizedState.deps)?n.memoizedState=Xa(t,u,l,a):(fe.flags|=e,n.memoizedState=Xa(1|t,u,l,a))}function Ho(e,t){Lu(8390656,8,e,t)}function Bi(e,t){Yu(2048,8,e,t)}function Cm(e){fe.flags|=4;var t=fe.updateQueue;if(t===null)t=Bu(),fe.updateQueue=t,t.events=[e];else{var l=t.events;l===null?t.events=[e]:l.push(e)}}function qo(e){var t=Qe().memoizedState;return Cm({ref:t,nextImpl:e}),function(){if((_e&2)!==0)throw Error(o(440));return t.impl.apply(void 0,arguments)}}function Lo(e,t){return Yu(4,2,e,t)}function Yo(e,t){return Yu(4,4,e,t)}function Go(e,t){if(typeof t=="function"){e=e();var l=t(e);return function(){typeof l=="function"?l():t(null)}}if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function Xo(e,t,l){l=l!=null?l.concat([e]):null,Yu(4,4,Go.bind(null,t,e),l)}function Hi(){}function Qo(e,t){var l=Qe();t=t===void 0?null:t;var a=l.memoizedState;return t!==null&&wi(t,a[1])?a[0]:(l.memoizedState=[e,t],e)}function Zo(e,t){var l=Qe();t=t===void 0?null:t;var a=l.memoizedState;if(t!==null&&wi(t,a[1]))return a[0];if(a=e(),ia){Lt(!0);try{e()}finally{Lt(!1)}}return l.memoizedState=[a,t],a}function qi(e,t,l){return l===void 0||(nl&1073741824)!==0&&(pe&261930)===0?e.memoizedState=t:(e.memoizedState=l,e=Kf(),fe.lanes|=e,Cl|=e,l)}function Vo(e,t,l,a){return xt(l,t)?l:La.current!==null?(e=qi(e,l,a),xt(e,t)||(Ke=!0),e):(nl&42)===0||(nl&1073741824)!==0&&(pe&261930)===0?(Ke=!0,e.memoizedState=l):(e=Kf(),fe.lanes|=e,Cl|=e,t)}function Ko(e,t,l,a,n){var u=O.p;O.p=u!==0&&8>u?u:8;var i=S.T,f={};S.T=f,Gi(e,!1,t,l);try{var h=n(),j=S.S;if(j!==null&&j(f,h),h!==null&&typeof h=="object"&&typeof h.then=="function"){var D=_m(h,a);On(e,t,D,wt(e))}else On(e,t,a,wt(e))}catch(B){On(e,t,{then:function(){},status:"rejected",reason:B},wt())}finally{O.p=u,i!==null&&f.types!==null&&(i.types=f.types),S.T=i}}function Om(){}function Li(e,t,l,a){if(e.tag!==5)throw Error(o(476));var n=ko(e).queue;Ko(e,n,t,V,l===null?Om:function(){return Jo(e),l(a)})}function ko(e){var t=e.memoizedState;if(t!==null)return t;t={memoizedState:V,baseState:V,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ul,lastRenderedState:V},next:null};var l={};return t.next={memoizedState:l,baseState:l,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ul,lastRenderedState:l},next:null},e.memoizedState=t,e=e.alternate,e!==null&&(e.memoizedState=t),t}function Jo(e){var t=ko(e);t.next===null&&(t=e.alternate.memoizedState),On(e,t.next.queue,{},wt())}function Yi(){return lt(Wn)}function $o(){return Qe().memoizedState}function Wo(){return Qe().memoizedState}function Rm(e){for(var t=e.return;t!==null;){switch(t.tag){case 24:case 3:var l=wt();e=wl(l);var a=_l(t,e,l);a!==null&&(bt(a,t,l),An(a,t,l)),t={cache:gi()},e.payload=t;return}t=t.return}}function Um(e,t,l){var a=wt();l={lane:a,revertLane:0,gesture:null,action:l,hasEagerState:!1,eagerState:null,next:null},Gu(e)?Io(t,l):(l=ni(e,t,l,a),l!==null&&(bt(l,e,a),Po(l,t,a)))}function Fo(e,t,l){var a=wt();On(e,t,l,a)}function On(e,t,l,a){var n={lane:a,revertLane:0,gesture:null,action:l,hasEagerState:!1,eagerState:null,next:null};if(Gu(e))Io(t,n);else{var u=e.alternate;if(e.lanes===0&&(u===null||u.lanes===0)&&(u=t.lastRenderedReducer,u!==null))try{var i=t.lastRenderedState,f=u(i,l);if(n.hasEagerState=!0,n.eagerState=f,xt(f,i))return Su(e,t,n,0),Ue===null&&xu(),!1}catch{}finally{}if(l=ni(e,t,n,a),l!==null)return bt(l,e,a),Po(l,t,a),!0}return!1}function Gi(e,t,l,a){if(a={lane:2,revertLane:ps(),gesture:null,action:a,hasEagerState:!1,eagerState:null,next:null},Gu(e)){if(t)throw Error(o(479))}else t=ni(e,l,a,2),t!==null&&bt(t,e,2)}function Gu(e){var t=e.alternate;return e===fe||t!==null&&t===fe}function Io(e,t){Ya=Ru=!0;var l=e.pending;l===null?t.next=t:(t.next=l.next,l.next=t),e.pending=t}function Po(e,t,l){if((l&4194048)!==0){var a=t.lanes;a&=e.pendingLanes,l|=a,t.lanes=l,ar(e,l)}}var Rn={readContext:lt,use:Hu,useCallback:Ye,useContext:Ye,useEffect:Ye,useImperativeHandle:Ye,useLayoutEffect:Ye,useInsertionEffect:Ye,useMemo:Ye,useReducer:Ye,useRef:Ye,useState:Ye,useDebugValue:Ye,useDeferredValue:Ye,useTransition:Ye,useSyncExternalStore:Ye,useId:Ye,useHostTransitionStatus:Ye,useFormState:Ye,useActionState:Ye,useOptimistic:Ye,useMemoCache:Ye,useCacheRefresh:Ye};Rn.useEffectEvent=Ye;var ef={readContext:lt,use:Hu,useCallback:function(e,t){return rt().memoizedState=[e,t===void 0?null:t],e},useContext:lt,useEffect:Ho,useImperativeHandle:function(e,t,l){l=l!=null?l.concat([e]):null,Lu(4194308,4,Go.bind(null,t,e),l)},useLayoutEffect:function(e,t){return Lu(4194308,4,e,t)},useInsertionEffect:function(e,t){Lu(4,2,e,t)},useMemo:function(e,t){var l=rt();t=t===void 0?null:t;var a=e();if(ia){Lt(!0);try{e()}finally{Lt(!1)}}return l.memoizedState=[a,t],a},useReducer:function(e,t,l){var a=rt();if(l!==void 0){var n=l(t);if(ia){Lt(!0);try{l(t)}finally{Lt(!1)}}}else n=t;return a.memoizedState=a.baseState=n,e={pending:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:n},a.queue=e,e=e.dispatch=Um.bind(null,fe,e),[a.memoizedState,e]},useRef:function(e){var t=rt();return e={current:e},t.memoizedState=e},useState:function(e){e=Ri(e);var t=e.queue,l=Fo.bind(null,fe,t);return t.dispatch=l,[e.memoizedState,l]},useDebugValue:Hi,useDeferredValue:function(e,t){var l=rt();return qi(l,e,t)},useTransition:function(){var e=Ri(!1);return e=Ko.bind(null,fe,e.queue,!0,!1),rt().memoizedState=e,[!1,e]},useSyncExternalStore:function(e,t,l){var a=fe,n=rt();if(Se){if(l===void 0)throw Error(o(407));l=l()}else{if(l=t(),Ue===null)throw Error(o(349));(pe&127)!==0||So(a,t,l)}n.memoizedState=l;var u={value:l,getSnapshot:t};return n.queue=u,Ho(jo.bind(null,a,u,e),[e]),a.flags|=2048,Xa(9,{destroy:void 0},Eo.bind(null,a,u,l,t),null),l},useId:function(){var e=rt(),t=Ue.identifierPrefix;if(Se){var l=kt,a=Kt;l=(a&~(1<<32-st(a)-1)).toString(32)+l,t="_"+t+"R_"+l,l=Uu++,0<l&&(t+="H"+l.toString(32)),t+="_"}else l=Am++,t="_"+t+"r_"+l.toString(32)+"_";return e.memoizedState=t},useHostTransitionStatus:Yi,useFormState:Co,useActionState:Co,useOptimistic:function(e){var t=rt();t.memoizedState=t.baseState=e;var l={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return t.queue=l,t=Gi.bind(null,fe,!0,l),l.dispatch=t,[e,t]},useMemoCache:Di,useCacheRefresh:function(){return rt().memoizedState=Rm.bind(null,fe)},useEffectEvent:function(e){var t=rt(),l={impl:e};return t.memoizedState=l,function(){if((_e&2)!==0)throw Error(o(440));return l.impl.apply(void 0,arguments)}}},Xi={readContext:lt,use:Hu,useCallback:Qo,useContext:lt,useEffect:Bi,useImperativeHandle:Xo,useInsertionEffect:Lo,useLayoutEffect:Yo,useMemo:Zo,useReducer:qu,useRef:Bo,useState:function(){return qu(ul)},useDebugValue:Hi,useDeferredValue:function(e,t){var l=Qe();return Vo(l,De.memoizedState,e,t)},useTransition:function(){var e=qu(ul)[0],t=Qe().memoizedState;return[typeof e=="boolean"?e:Cn(e),t]},useSyncExternalStore:xo,useId:$o,useHostTransitionStatus:Yi,useFormState:Oo,useActionState:Oo,useOptimistic:function(e,t){var l=Qe();return wo(l,De,e,t)},useMemoCache:Di,useCacheRefresh:Wo};Xi.useEffectEvent=qo;var tf={readContext:lt,use:Hu,useCallback:Qo,useContext:lt,useEffect:Bi,useImperativeHandle:Xo,useInsertionEffect:Lo,useLayoutEffect:Yo,useMemo:Zo,useReducer:Oi,useRef:Bo,useState:function(){return Oi(ul)},useDebugValue:Hi,useDeferredValue:function(e,t){var l=Qe();return De===null?qi(l,e,t):Vo(l,De.memoizedState,e,t)},useTransition:function(){var e=Oi(ul)[0],t=Qe().memoizedState;return[typeof e=="boolean"?e:Cn(e),t]},useSyncExternalStore:xo,useId:$o,useHostTransitionStatus:Yi,useFormState:Uo,useActionState:Uo,useOptimistic:function(e,t){var l=Qe();return De!==null?wo(l,De,e,t):(l.baseState=e,[e,l.queue.dispatch])},useMemoCache:Di,useCacheRefresh:Wo};tf.useEffectEvent=qo;function Qi(e,t,l,a){t=e.memoizedState,l=l(a,t),l=l==null?t:U({},t,l),e.memoizedState=l,e.lanes===0&&(e.updateQueue.baseState=l)}var Zi={enqueueSetState:function(e,t,l){e=e._reactInternals;var a=wt(),n=wl(a);n.payload=t,l!=null&&(n.callback=l),t=_l(e,n,a),t!==null&&(bt(t,e,a),An(t,e,a))},enqueueReplaceState:function(e,t,l){e=e._reactInternals;var a=wt(),n=wl(a);n.tag=1,n.payload=t,l!=null&&(n.callback=l),t=_l(e,n,a),t!==null&&(bt(t,e,a),An(t,e,a))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var l=wt(),a=wl(l);a.tag=2,t!=null&&(a.callback=t),t=_l(e,a,l),t!==null&&(bt(t,e,l),An(t,e,l))}};function lf(e,t,l,a,n,u,i){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(a,u,i):t.prototype&&t.prototype.isPureReactComponent?!xn(l,a)||!xn(n,u):!0}function af(e,t,l,a){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(l,a),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(l,a),t.state!==e&&Zi.enqueueReplaceState(t,t.state,null)}function sa(e,t){var l=t;if("ref"in t){l={};for(var a in t)a!=="ref"&&(l[a]=t[a])}if(e=e.defaultProps){l===t&&(l=U({},l));for(var n in e)l[n]===void 0&&(l[n]=e[n])}return l}function nf(e){pu(e)}function uf(e){console.error(e)}function cf(e){pu(e)}function Xu(e,t){try{var l=e.onUncaughtError;l(t.value,{componentStack:t.stack})}catch(a){setTimeout(function(){throw a})}}function sf(e,t,l){try{var a=e.onCaughtError;a(l.value,{componentStack:l.stack,errorBoundary:t.tag===1?t.stateNode:null})}catch(n){setTimeout(function(){throw n})}}function Vi(e,t,l){return l=wl(l),l.tag=3,l.payload={element:null},l.callback=function(){Xu(e,t)},l}function rf(e){return e=wl(e),e.tag=3,e}function of(e,t,l,a){var n=l.type.getDerivedStateFromError;if(typeof n=="function"){var u=a.value;e.payload=function(){return n(u)},e.callback=function(){sf(t,l,a)}}var i=l.stateNode;i!==null&&typeof i.componentDidCatch=="function"&&(e.callback=function(){sf(t,l,a),typeof n!="function"&&(Ol===null?Ol=new Set([this]):Ol.add(this));var f=a.stack;this.componentDidCatch(a.value,{componentStack:f!==null?f:""})})}function Bm(e,t,l,a,n){if(l.flags|=32768,a!==null&&typeof a=="object"&&typeof a.then=="function"){if(t=l.alternate,t!==null&&Ra(t,l,n,!0),l=Et.current,l!==null){switch(l.tag){case 31:case 13:return Ut===null?ec():l.alternate===null&&Ge===0&&(Ge=3),l.flags&=-257,l.flags|=65536,l.lanes=n,a===zu?l.flags|=16384:(t=l.updateQueue,t===null?l.updateQueue=new Set([a]):t.add(a),ys(e,a,n)),!1;case 22:return l.flags|=65536,a===zu?l.flags|=16384:(t=l.updateQueue,t===null?(t={transitions:null,markerInstances:null,retryQueue:new Set([a])},l.updateQueue=t):(l=t.retryQueue,l===null?t.retryQueue=new Set([a]):l.add(a)),ys(e,a,n)),!1}throw Error(o(435,l.tag))}return ys(e,a,n),ec(),!1}if(Se)return t=Et.current,t!==null?((t.flags&65536)===0&&(t.flags|=256),t.flags|=65536,t.lanes=n,a!==oi&&(e=Error(o(422),{cause:a}),jn(Dt(e,l)))):(a!==oi&&(t=Error(o(423),{cause:a}),jn(Dt(t,l))),e=e.current.alternate,e.flags|=65536,n&=-n,e.lanes|=n,a=Dt(a,l),n=Vi(e.stateNode,a,n),Si(e,n),Ge!==4&&(Ge=2)),!1;var u=Error(o(520),{cause:a});if(u=Dt(u,l),Xn===null?Xn=[u]:Xn.push(u),Ge!==4&&(Ge=2),t===null)return!0;a=Dt(a,l),l=t;do{switch(l.tag){case 3:return l.flags|=65536,e=n&-n,l.lanes|=e,e=Vi(l.stateNode,a,e),Si(l,e),!1;case 1:if(t=l.type,u=l.stateNode,(l.flags&128)===0&&(typeof t.getDerivedStateFromError=="function"||u!==null&&typeof u.componentDidCatch=="function"&&(Ol===null||!Ol.has(u))))return l.flags|=65536,n&=-n,l.lanes|=n,n=rf(n),of(n,e,l,a),Si(l,n),!1}l=l.return}while(l!==null);return!1}var Ki=Error(o(461)),Ke=!1;function at(e,t,l,a){t.child=e===null?mo(t,null,l,a):ca(t,e.child,l,a)}function ff(e,t,l,a,n){l=l.render;var u=t.ref;if("ref"in a){var i={};for(var f in a)f!=="ref"&&(i[f]=a[f])}else i=a;return la(t),a=_i(e,t,l,i,u,n),f=Ai(),e!==null&&!Ke?(zi(e,t,n),cl(e,t,n)):(Se&&f&&si(t),t.flags|=1,at(e,t,a,n),t.child)}function df(e,t,l,a,n){if(e===null){var u=l.type;return typeof u=="function"&&!ui(u)&&u.defaultProps===void 0&&l.compare===null?(t.tag=15,t.type=u,mf(e,t,u,a,n)):(e=ju(l.type,null,a,t,t.mode,n),e.ref=t.ref,e.return=t,t.child=e)}if(u=e.child,!es(e,n)){var i=u.memoizedProps;if(l=l.compare,l=l!==null?l:xn,l(i,a)&&e.ref===t.ref)return cl(e,t,n)}return t.flags|=1,e=el(u,a),e.ref=t.ref,e.return=t,t.child=e}function mf(e,t,l,a,n){if(e!==null){var u=e.memoizedProps;if(xn(u,a)&&e.ref===t.ref)if(Ke=!1,t.pendingProps=a=u,es(e,n))(e.flags&131072)!==0&&(Ke=!0);else return t.lanes=e.lanes,cl(e,t,n)}return ki(e,t,l,a,n)}function hf(e,t,l,a){var n=a.children,u=e!==null?e.memoizedState:null;if(e===null&&t.stateNode===null&&(t.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),a.mode==="hidden"){if((t.flags&128)!==0){if(u=u!==null?u.baseLanes|l:l,e!==null){for(a=t.child=e.child,n=0;a!==null;)n=n|a.lanes|a.childLanes,a=a.sibling;a=n&~u}else a=0,t.child=null;return gf(e,t,u,l,a)}if((l&536870912)!==0)t.memoizedState={baseLanes:0,cachePool:null},e!==null&&_u(t,u!==null?u.cachePool:null),u!==null?yo(t,u):ji(),vo(t);else return a=t.lanes=536870912,gf(e,t,u!==null?u.baseLanes|l:l,l,a)}else u!==null?(_u(t,u.cachePool),yo(t,u),zl(),t.memoizedState=null):(e!==null&&_u(t,null),ji(),zl());return at(e,t,n,l),t.child}function Un(e,t){return e!==null&&e.tag===22||t.stateNode!==null||(t.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),t.sibling}function gf(e,t,l,a,n){var u=vi();return u=u===null?null:{parent:Ze._currentValue,pool:u},t.memoizedState={baseLanes:l,cachePool:u},e!==null&&_u(t,null),ji(),vo(t),e!==null&&Ra(e,t,a,!0),t.childLanes=n,null}function Qu(e,t){return t=Vu({mode:t.mode,children:t.children},e.mode),t.ref=e.ref,e.child=t,t.return=e,t}function yf(e,t,l){return ca(t,e.child,null,l),e=Qu(t,t.pendingProps),e.flags|=2,jt(t),t.memoizedState=null,e}function Hm(e,t,l){var a=t.pendingProps,n=(t.flags&128)!==0;if(t.flags&=-129,e===null){if(Se){if(a.mode==="hidden")return e=Qu(t,a),t.lanes=536870912,Un(null,e);if(Ti(t),(e=He)?(e=Ad(e,Rt),e=e!==null&&e.data==="&"?e:null,e!==null&&(t.memoizedState={dehydrated:e,treeContext:Sl!==null?{id:Kt,overflow:kt}:null,retryLane:536870912,hydrationErrors:null},l=Fr(e),l.return=t,t.child=l,tt=t,He=null)):e=null,e===null)throw jl(t);return t.lanes=536870912,null}return Qu(t,a)}var u=e.memoizedState;if(u!==null){var i=u.dehydrated;if(Ti(t),n)if(t.flags&256)t.flags&=-257,t=yf(e,t,l);else if(t.memoizedState!==null)t.child=e.child,t.flags|=128,t=null;else throw Error(o(558));else if(Ke||Ra(e,t,l,!1),n=(l&e.childLanes)!==0,Ke||n){if(a=Ue,a!==null&&(i=nr(a,l),i!==0&&i!==u.retryLane))throw u.retryLane=i,Il(e,i),bt(a,e,i),Ki;ec(),t=yf(e,t,l)}else e=u.treeContext,He=Bt(i.nextSibling),tt=t,Se=!0,El=null,Rt=!1,e!==null&&eo(t,e),t=Qu(t,a),t.flags|=4096;return t}return e=el(e.child,{mode:a.mode,children:a.children}),e.ref=t.ref,t.child=e,e.return=t,e}function Zu(e,t){var l=t.ref;if(l===null)e!==null&&e.ref!==null&&(t.flags|=4194816);else{if(typeof l!="function"&&typeof l!="object")throw Error(o(284));(e===null||e.ref!==l)&&(t.flags|=4194816)}}function ki(e,t,l,a,n){return la(t),l=_i(e,t,l,a,void 0,n),a=Ai(),e!==null&&!Ke?(zi(e,t,n),cl(e,t,n)):(Se&&a&&si(t),t.flags|=1,at(e,t,l,n),t.child)}function vf(e,t,l,a,n,u){return la(t),t.updateQueue=null,l=po(t,a,l,n),bo(e),a=Ai(),e!==null&&!Ke?(zi(e,t,u),cl(e,t,u)):(Se&&a&&si(t),t.flags|=1,at(e,t,l,u),t.child)}function bf(e,t,l,a,n){if(la(t),t.stateNode===null){var u=Ma,i=l.contextType;typeof i=="object"&&i!==null&&(u=lt(i)),u=new l(a,u),t.memoizedState=u.state!==null&&u.state!==void 0?u.state:null,u.updater=Zi,t.stateNode=u,u._reactInternals=t,u=t.stateNode,u.props=a,u.state=t.memoizedState,u.refs={},pi(t),i=l.contextType,u.context=typeof i=="object"&&i!==null?lt(i):Ma,u.state=t.memoizedState,i=l.getDerivedStateFromProps,typeof i=="function"&&(Qi(t,l,i,a),u.state=t.memoizedState),typeof l.getDerivedStateFromProps=="function"||typeof u.getSnapshotBeforeUpdate=="function"||typeof u.UNSAFE_componentWillMount!="function"&&typeof u.componentWillMount!="function"||(i=u.state,typeof u.componentWillMount=="function"&&u.componentWillMount(),typeof u.UNSAFE_componentWillMount=="function"&&u.UNSAFE_componentWillMount(),i!==u.state&&Zi.enqueueReplaceState(u,u.state,null),Mn(t,a,u,n),zn(),u.state=t.memoizedState),typeof u.componentDidMount=="function"&&(t.flags|=4194308),a=!0}else if(e===null){u=t.stateNode;var f=t.memoizedProps,h=sa(l,f);u.props=h;var j=u.context,D=l.contextType;i=Ma,typeof D=="object"&&D!==null&&(i=lt(D));var B=l.getDerivedStateFromProps;D=typeof B=="function"||typeof u.getSnapshotBeforeUpdate=="function",f=t.pendingProps!==f,D||typeof u.UNSAFE_componentWillReceiveProps!="function"&&typeof u.componentWillReceiveProps!="function"||(f||j!==i)&&af(t,u,a,i),Tl=!1;var T=t.memoizedState;u.state=T,Mn(t,a,u,n),zn(),j=t.memoizedState,f||T!==j||Tl?(typeof B=="function"&&(Qi(t,l,B,a),j=t.memoizedState),(h=Tl||lf(t,l,h,a,T,j,i))?(D||typeof u.UNSAFE_componentWillMount!="function"&&typeof u.componentWillMount!="function"||(typeof u.componentWillMount=="function"&&u.componentWillMount(),typeof u.UNSAFE_componentWillMount=="function"&&u.UNSAFE_componentWillMount()),typeof u.componentDidMount=="function"&&(t.flags|=4194308)):(typeof u.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=a,t.memoizedState=j),u.props=a,u.state=j,u.context=i,a=h):(typeof u.componentDidMount=="function"&&(t.flags|=4194308),a=!1)}else{u=t.stateNode,xi(e,t),i=t.memoizedProps,D=sa(l,i),u.props=D,B=t.pendingProps,T=u.context,j=l.contextType,h=Ma,typeof j=="object"&&j!==null&&(h=lt(j)),f=l.getDerivedStateFromProps,(j=typeof f=="function"||typeof u.getSnapshotBeforeUpdate=="function")||typeof u.UNSAFE_componentWillReceiveProps!="function"&&typeof u.componentWillReceiveProps!="function"||(i!==B||T!==h)&&af(t,u,a,h),Tl=!1,T=t.memoizedState,u.state=T,Mn(t,a,u,n),zn();var z=t.memoizedState;i!==B||T!==z||Tl||e!==null&&e.dependencies!==null&&Tu(e.dependencies)?(typeof f=="function"&&(Qi(t,l,f,a),z=t.memoizedState),(D=Tl||lf(t,l,D,a,T,z,h)||e!==null&&e.dependencies!==null&&Tu(e.dependencies))?(j||typeof u.UNSAFE_componentWillUpdate!="function"&&typeof u.componentWillUpdate!="function"||(typeof u.componentWillUpdate=="function"&&u.componentWillUpdate(a,z,h),typeof u.UNSAFE_componentWillUpdate=="function"&&u.UNSAFE_componentWillUpdate(a,z,h)),typeof u.componentDidUpdate=="function"&&(t.flags|=4),typeof u.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof u.componentDidUpdate!="function"||i===e.memoizedProps&&T===e.memoizedState||(t.flags|=4),typeof u.getSnapshotBeforeUpdate!="function"||i===e.memoizedProps&&T===e.memoizedState||(t.flags|=1024),t.memoizedProps=a,t.memoizedState=z),u.props=a,u.state=z,u.context=h,a=D):(typeof u.componentDidUpdate!="function"||i===e.memoizedProps&&T===e.memoizedState||(t.flags|=4),typeof u.getSnapshotBeforeUpdate!="function"||i===e.memoizedProps&&T===e.memoizedState||(t.flags|=1024),a=!1)}return u=a,Zu(e,t),a=(t.flags&128)!==0,u||a?(u=t.stateNode,l=a&&typeof l.getDerivedStateFromError!="function"?null:u.render(),t.flags|=1,e!==null&&a?(t.child=ca(t,e.child,null,n),t.child=ca(t,null,l,n)):at(e,t,l,n),t.memoizedState=u.state,e=t.child):e=cl(e,t,n),e}function pf(e,t,l,a){return ea(),t.flags|=256,at(e,t,l,a),t.child}var Ji={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function $i(e){return{baseLanes:e,cachePool:co()}}function Wi(e,t,l){return e=e!==null?e.childLanes&~l:0,t&&(e|=Tt),e}function xf(e,t,l){var a=t.pendingProps,n=!1,u=(t.flags&128)!==0,i;if((i=u)||(i=e!==null&&e.memoizedState===null?!1:(Xe.current&2)!==0),i&&(n=!0,t.flags&=-129),i=(t.flags&32)!==0,t.flags&=-33,e===null){if(Se){if(n?Al(t):zl(),(e=He)?(e=Ad(e,Rt),e=e!==null&&e.data!=="&"?e:null,e!==null&&(t.memoizedState={dehydrated:e,treeContext:Sl!==null?{id:Kt,overflow:kt}:null,retryLane:536870912,hydrationErrors:null},l=Fr(e),l.return=t,t.child=l,tt=t,He=null)):e=null,e===null)throw jl(t);return Cs(e)?t.lanes=32:t.lanes=536870912,null}var f=a.children;return a=a.fallback,n?(zl(),n=t.mode,f=Vu({mode:"hidden",children:f},n),a=Pl(a,n,l,null),f.return=t,a.return=t,f.sibling=a,t.child=f,a=t.child,a.memoizedState=$i(l),a.childLanes=Wi(e,i,l),t.memoizedState=Ji,Un(null,a)):(Al(t),Fi(t,f))}var h=e.memoizedState;if(h!==null&&(f=h.dehydrated,f!==null)){if(u)t.flags&256?(Al(t),t.flags&=-257,t=Ii(e,t,l)):t.memoizedState!==null?(zl(),t.child=e.child,t.flags|=128,t=null):(zl(),f=a.fallback,n=t.mode,a=Vu({mode:"visible",children:a.children},n),f=Pl(f,n,l,null),f.flags|=2,a.return=t,f.return=t,a.sibling=f,t.child=a,ca(t,e.child,null,l),a=t.child,a.memoizedState=$i(l),a.childLanes=Wi(e,i,l),t.memoizedState=Ji,t=Un(null,a));else if(Al(t),Cs(f)){if(i=f.nextSibling&&f.nextSibling.dataset,i)var j=i.dgst;i=j,a=Error(o(419)),a.stack="",a.digest=i,jn({value:a,source:null,stack:null}),t=Ii(e,t,l)}else if(Ke||Ra(e,t,l,!1),i=(l&e.childLanes)!==0,Ke||i){if(i=Ue,i!==null&&(a=nr(i,l),a!==0&&a!==h.retryLane))throw h.retryLane=a,Il(e,a),bt(i,e,a),Ki;Ds(f)||ec(),t=Ii(e,t,l)}else Ds(f)?(t.flags|=192,t.child=e.child,t=null):(e=h.treeContext,He=Bt(f.nextSibling),tt=t,Se=!0,El=null,Rt=!1,e!==null&&eo(t,e),t=Fi(t,a.children),t.flags|=4096);return t}return n?(zl(),f=a.fallback,n=t.mode,h=e.child,j=h.sibling,a=el(h,{mode:"hidden",children:a.children}),a.subtreeFlags=h.subtreeFlags&65011712,j!==null?f=el(j,f):(f=Pl(f,n,l,null),f.flags|=2),f.return=t,a.return=t,a.sibling=f,t.child=a,Un(null,a),a=t.child,f=e.child.memoizedState,f===null?f=$i(l):(n=f.cachePool,n!==null?(h=Ze._currentValue,n=n.parent!==h?{parent:h,pool:h}:n):n=co(),f={baseLanes:f.baseLanes|l,cachePool:n}),a.memoizedState=f,a.childLanes=Wi(e,i,l),t.memoizedState=Ji,Un(e.child,a)):(Al(t),l=e.child,e=l.sibling,l=el(l,{mode:"visible",children:a.children}),l.return=t,l.sibling=null,e!==null&&(i=t.deletions,i===null?(t.deletions=[e],t.flags|=16):i.push(e)),t.child=l,t.memoizedState=null,l)}function Fi(e,t){return t=Vu({mode:"visible",children:t},e.mode),t.return=e,e.child=t}function Vu(e,t){return e=St(22,e,null,t),e.lanes=0,e}function Ii(e,t,l){return ca(t,e.child,null,l),e=Fi(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function Sf(e,t,l){e.lanes|=t;var a=e.alternate;a!==null&&(a.lanes|=t),mi(e.return,t,l)}function Pi(e,t,l,a,n,u){var i=e.memoizedState;i===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:a,tail:l,tailMode:n,treeForkCount:u}:(i.isBackwards=t,i.rendering=null,i.renderingStartTime=0,i.last=a,i.tail=l,i.tailMode=n,i.treeForkCount=u)}function Ef(e,t,l){var a=t.pendingProps,n=a.revealOrder,u=a.tail;a=a.children;var i=Xe.current,f=(i&2)!==0;if(f?(i=i&1|2,t.flags|=128):i&=1,C(Xe,i),at(e,t,a,l),a=Se?En:0,!f&&e!==null&&(e.flags&128)!==0)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&Sf(e,l,t);else if(e.tag===19)Sf(e,l,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}switch(n){case"forwards":for(l=t.child,n=null;l!==null;)e=l.alternate,e!==null&&Ou(e)===null&&(n=l),l=l.sibling;l=n,l===null?(n=t.child,t.child=null):(n=l.sibling,l.sibling=null),Pi(t,!1,n,l,u,a);break;case"backwards":case"unstable_legacy-backwards":for(l=null,n=t.child,t.child=null;n!==null;){if(e=n.alternate,e!==null&&Ou(e)===null){t.child=n;break}e=n.sibling,n.sibling=l,l=n,n=e}Pi(t,!0,l,null,u,a);break;case"together":Pi(t,!1,null,null,void 0,a);break;default:t.memoizedState=null}return t.child}function cl(e,t,l){if(e!==null&&(t.dependencies=e.dependencies),Cl|=t.lanes,(l&t.childLanes)===0)if(e!==null){if(Ra(e,t,l,!1),(l&t.childLanes)===0)return null}else return null;if(e!==null&&t.child!==e.child)throw Error(o(153));if(t.child!==null){for(e=t.child,l=el(e,e.pendingProps),t.child=l,l.return=t;e.sibling!==null;)e=e.sibling,l=l.sibling=el(e,e.pendingProps),l.return=t;l.sibling=null}return t.child}function es(e,t){return(e.lanes&t)!==0?!0:(e=e.dependencies,!!(e!==null&&Tu(e)))}function qm(e,t,l){switch(t.tag){case 3:Re(t,t.stateNode.containerInfo),Nl(t,Ze,e.memoizedState.cache),ea();break;case 27:case 5:Je(t);break;case 4:Re(t,t.stateNode.containerInfo);break;case 10:Nl(t,t.type,t.memoizedProps.value);break;case 31:if(t.memoizedState!==null)return t.flags|=128,Ti(t),null;break;case 13:var a=t.memoizedState;if(a!==null)return a.dehydrated!==null?(Al(t),t.flags|=128,null):(l&t.child.childLanes)!==0?xf(e,t,l):(Al(t),e=cl(e,t,l),e!==null?e.sibling:null);Al(t);break;case 19:var n=(e.flags&128)!==0;if(a=(l&t.childLanes)!==0,a||(Ra(e,t,l,!1),a=(l&t.childLanes)!==0),n){if(a)return Ef(e,t,l);t.flags|=128}if(n=t.memoizedState,n!==null&&(n.rendering=null,n.tail=null,n.lastEffect=null),C(Xe,Xe.current),a)break;return null;case 22:return t.lanes=0,hf(e,t,l,t.pendingProps);case 24:Nl(t,Ze,e.memoizedState.cache)}return cl(e,t,l)}function jf(e,t,l){if(e!==null)if(e.memoizedProps!==t.pendingProps)Ke=!0;else{if(!es(e,l)&&(t.flags&128)===0)return Ke=!1,qm(e,t,l);Ke=(e.flags&131072)!==0}else Ke=!1,Se&&(t.flags&1048576)!==0&&Pr(t,En,t.index);switch(t.lanes=0,t.tag){case 16:e:{var a=t.pendingProps;if(e=na(t.elementType),t.type=e,typeof e=="function")ui(e)?(a=sa(e,a),t.tag=1,t=bf(null,t,e,a,l)):(t.tag=0,t=ki(null,t,e,a,l));else{if(e!=null){var n=e.$$typeof;if(n===de){t.tag=11,t=ff(null,t,e,a,l);break e}else if(n===X){t.tag=14,t=df(null,t,e,a,l);break e}}throw t=w(e)||e,Error(o(306,t,""))}}return t;case 0:return ki(e,t,t.type,t.pendingProps,l);case 1:return a=t.type,n=sa(a,t.pendingProps),bf(e,t,a,n,l);case 3:e:{if(Re(t,t.stateNode.containerInfo),e===null)throw Error(o(387));a=t.pendingProps;var u=t.memoizedState;n=u.element,xi(e,t),Mn(t,a,null,l);var i=t.memoizedState;if(a=i.cache,Nl(t,Ze,a),a!==u.cache&&hi(t,[Ze],l,!0),zn(),a=i.element,u.isDehydrated)if(u={element:a,isDehydrated:!1,cache:i.cache},t.updateQueue.baseState=u,t.memoizedState=u,t.flags&256){t=pf(e,t,a,l);break e}else if(a!==n){n=Dt(Error(o(424)),t),jn(n),t=pf(e,t,a,l);break e}else{switch(e=t.stateNode.containerInfo,e.nodeType){case 9:e=e.body;break;default:e=e.nodeName==="HTML"?e.ownerDocument.body:e}for(He=Bt(e.firstChild),tt=t,Se=!0,El=null,Rt=!0,l=mo(t,null,a,l),t.child=l;l;)l.flags=l.flags&-3|4096,l=l.sibling}else{if(ea(),a===n){t=cl(e,t,l);break e}at(e,t,a,l)}t=t.child}return t;case 26:return Zu(e,t),e===null?(l=Rd(t.type,null,t.pendingProps,null))?t.memoizedState=l:Se||(l=t.type,e=t.pendingProps,a=ic(le.current).createElement(l),a[et]=t,a[dt]=e,nt(a,l,e),Ie(a),t.stateNode=a):t.memoizedState=Rd(t.type,e.memoizedProps,t.pendingProps,e.memoizedState),null;case 27:return Je(t),e===null&&Se&&(a=t.stateNode=Dd(t.type,t.pendingProps,le.current),tt=t,Rt=!0,n=He,Hl(t.type)?(Os=n,He=Bt(a.firstChild)):He=n),at(e,t,t.pendingProps.children,l),Zu(e,t),e===null&&(t.flags|=4194304),t.child;case 5:return e===null&&Se&&((n=a=He)&&(a=hh(a,t.type,t.pendingProps,Rt),a!==null?(t.stateNode=a,tt=t,He=Bt(a.firstChild),Rt=!1,n=!0):n=!1),n||jl(t)),Je(t),n=t.type,u=t.pendingProps,i=e!==null?e.memoizedProps:null,a=u.children,As(n,u)?a=null:i!==null&&As(n,i)&&(t.flags|=32),t.memoizedState!==null&&(n=_i(e,t,zm,null,null,l),Wn._currentValue=n),Zu(e,t),at(e,t,a,l),t.child;case 6:return e===null&&Se&&((e=l=He)&&(l=gh(l,t.pendingProps,Rt),l!==null?(t.stateNode=l,tt=t,He=null,e=!0):e=!1),e||jl(t)),null;case 13:return xf(e,t,l);case 4:return Re(t,t.stateNode.containerInfo),a=t.pendingProps,e===null?t.child=ca(t,null,a,l):at(e,t,a,l),t.child;case 11:return ff(e,t,t.type,t.pendingProps,l);case 7:return at(e,t,t.pendingProps,l),t.child;case 8:return at(e,t,t.pendingProps.children,l),t.child;case 12:return at(e,t,t.pendingProps.children,l),t.child;case 10:return a=t.pendingProps,Nl(t,t.type,a.value),at(e,t,a.children,l),t.child;case 9:return n=t.type._context,a=t.pendingProps.children,la(t),n=lt(n),a=a(n),t.flags|=1,at(e,t,a,l),t.child;case 14:return df(e,t,t.type,t.pendingProps,l);case 15:return mf(e,t,t.type,t.pendingProps,l);case 19:return Ef(e,t,l);case 31:return Hm(e,t,l);case 22:return hf(e,t,l,t.pendingProps);case 24:return la(t),a=lt(Ze),e===null?(n=vi(),n===null&&(n=Ue,u=gi(),n.pooledCache=u,u.refCount++,u!==null&&(n.pooledCacheLanes|=l),n=u),t.memoizedState={parent:a,cache:n},pi(t),Nl(t,Ze,n)):((e.lanes&l)!==0&&(xi(e,t),Mn(t,null,null,l),zn()),n=e.memoizedState,u=t.memoizedState,n.parent!==a?(n={parent:a,cache:a},t.memoizedState=n,t.lanes===0&&(t.memoizedState=t.updateQueue.baseState=n),Nl(t,Ze,a)):(a=u.cache,Nl(t,Ze,a),a!==n.cache&&hi(t,[Ze],l,!0))),at(e,t,t.pendingProps.children,l),t.child;case 29:throw t.pendingProps}throw Error(o(156,t.tag))}function il(e){e.flags|=4}function ts(e,t,l,a,n){if((t=(e.mode&32)!==0)&&(t=!1),t){if(e.flags|=16777216,(n&335544128)===n)if(e.stateNode.complete)e.flags|=8192;else if(Wf())e.flags|=8192;else throw ua=zu,bi}else e.flags&=-16777217}function Nf(e,t){if(t.type!=="stylesheet"||(t.state.loading&4)!==0)e.flags&=-16777217;else if(e.flags|=16777216,!Ld(t))if(Wf())e.flags|=8192;else throw ua=zu,bi}function Ku(e,t){t!==null&&(e.flags|=4),e.flags&16384&&(t=e.tag!==22?kl():536870912,e.lanes|=t,Ka|=t)}function Bn(e,t){if(!Se)switch(e.tailMode){case"hidden":t=e.tail;for(var l=null;t!==null;)t.alternate!==null&&(l=t),t=t.sibling;l===null?e.tail=null:l.sibling=null;break;case"collapsed":l=e.tail;for(var a=null;l!==null;)l.alternate!==null&&(a=l),l=l.sibling;a===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:a.sibling=null}}function qe(e){var t=e.alternate!==null&&e.alternate.child===e.child,l=0,a=0;if(t)for(var n=e.child;n!==null;)l|=n.lanes|n.childLanes,a|=n.subtreeFlags&65011712,a|=n.flags&65011712,n.return=e,n=n.sibling;else for(n=e.child;n!==null;)l|=n.lanes|n.childLanes,a|=n.subtreeFlags,a|=n.flags,n.return=e,n=n.sibling;return e.subtreeFlags|=a,e.childLanes=l,t}function Lm(e,t,l){var a=t.pendingProps;switch(ri(t),t.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return qe(t),null;case 1:return qe(t),null;case 3:return l=t.stateNode,a=null,e!==null&&(a=e.memoizedState.cache),t.memoizedState.cache!==a&&(t.flags|=2048),al(Ze),Ae(),l.pendingContext&&(l.context=l.pendingContext,l.pendingContext=null),(e===null||e.child===null)&&(Oa(t)?il(t):e===null||e.memoizedState.isDehydrated&&(t.flags&256)===0||(t.flags|=1024,fi())),qe(t),null;case 26:var n=t.type,u=t.memoizedState;return e===null?(il(t),u!==null?(qe(t),Nf(t,u)):(qe(t),ts(t,n,null,a,l))):u?u!==e.memoizedState?(il(t),qe(t),Nf(t,u)):(qe(t),t.flags&=-16777217):(e=e.memoizedProps,e!==a&&il(t),qe(t),ts(t,n,e,a,l)),null;case 27:if(pt(t),l=le.current,n=t.type,e!==null&&t.stateNode!=null)e.memoizedProps!==a&&il(t);else{if(!a){if(t.stateNode===null)throw Error(o(166));return qe(t),null}e=G.current,Oa(t)?to(t):(e=Dd(n,a,l),t.stateNode=e,il(t))}return qe(t),null;case 5:if(pt(t),n=t.type,e!==null&&t.stateNode!=null)e.memoizedProps!==a&&il(t);else{if(!a){if(t.stateNode===null)throw Error(o(166));return qe(t),null}if(u=G.current,Oa(t))to(t);else{var i=ic(le.current);switch(u){case 1:u=i.createElementNS("http://www.w3.org/2000/svg",n);break;case 2:u=i.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;default:switch(n){case"svg":u=i.createElementNS("http://www.w3.org/2000/svg",n);break;case"math":u=i.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;case"script":u=i.createElement("div"),u.innerHTML="<script><\/script>",u=u.removeChild(u.firstChild);break;case"select":u=typeof a.is=="string"?i.createElement("select",{is:a.is}):i.createElement("select"),a.multiple?u.multiple=!0:a.size&&(u.size=a.size);break;default:u=typeof a.is=="string"?i.createElement(n,{is:a.is}):i.createElement(n)}}u[et]=t,u[dt]=a;e:for(i=t.child;i!==null;){if(i.tag===5||i.tag===6)u.appendChild(i.stateNode);else if(i.tag!==4&&i.tag!==27&&i.child!==null){i.child.return=i,i=i.child;continue}if(i===t)break e;for(;i.sibling===null;){if(i.return===null||i.return===t)break e;i=i.return}i.sibling.return=i.return,i=i.sibling}t.stateNode=u;e:switch(nt(u,n,a),n){case"button":case"input":case"select":case"textarea":a=!!a.autoFocus;break e;case"img":a=!0;break e;default:a=!1}a&&il(t)}}return qe(t),ts(t,t.type,e===null?null:e.memoizedProps,t.pendingProps,l),null;case 6:if(e&&t.stateNode!=null)e.memoizedProps!==a&&il(t);else{if(typeof a!="string"&&t.stateNode===null)throw Error(o(166));if(e=le.current,Oa(t)){if(e=t.stateNode,l=t.memoizedProps,a=null,n=tt,n!==null)switch(n.tag){case 27:case 5:a=n.memoizedProps}e[et]=t,e=!!(e.nodeValue===l||a!==null&&a.suppressHydrationWarning===!0||xd(e.nodeValue,l)),e||jl(t,!0)}else e=ic(e).createTextNode(a),e[et]=t,t.stateNode=e}return qe(t),null;case 31:if(l=t.memoizedState,e===null||e.memoizedState!==null){if(a=Oa(t),l!==null){if(e===null){if(!a)throw Error(o(318));if(e=t.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(o(557));e[et]=t}else ea(),(t.flags&128)===0&&(t.memoizedState=null),t.flags|=4;qe(t),e=!1}else l=fi(),e!==null&&e.memoizedState!==null&&(e.memoizedState.hydrationErrors=l),e=!0;if(!e)return t.flags&256?(jt(t),t):(jt(t),null);if((t.flags&128)!==0)throw Error(o(558))}return qe(t),null;case 13:if(a=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(n=Oa(t),a!==null&&a.dehydrated!==null){if(e===null){if(!n)throw Error(o(318));if(n=t.memoizedState,n=n!==null?n.dehydrated:null,!n)throw Error(o(317));n[et]=t}else ea(),(t.flags&128)===0&&(t.memoizedState=null),t.flags|=4;qe(t),n=!1}else n=fi(),e!==null&&e.memoizedState!==null&&(e.memoizedState.hydrationErrors=n),n=!0;if(!n)return t.flags&256?(jt(t),t):(jt(t),null)}return jt(t),(t.flags&128)!==0?(t.lanes=l,t):(l=a!==null,e=e!==null&&e.memoizedState!==null,l&&(a=t.child,n=null,a.alternate!==null&&a.alternate.memoizedState!==null&&a.alternate.memoizedState.cachePool!==null&&(n=a.alternate.memoizedState.cachePool.pool),u=null,a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(u=a.memoizedState.cachePool.pool),u!==n&&(a.flags|=2048)),l!==e&&l&&(t.child.flags|=8192),Ku(t,t.updateQueue),qe(t),null);case 4:return Ae(),e===null&&js(t.stateNode.containerInfo),qe(t),null;case 10:return al(t.type),qe(t),null;case 19:if(_(Xe),a=t.memoizedState,a===null)return qe(t),null;if(n=(t.flags&128)!==0,u=a.rendering,u===null)if(n)Bn(a,!1);else{if(Ge!==0||e!==null&&(e.flags&128)!==0)for(e=t.child;e!==null;){if(u=Ou(e),u!==null){for(t.flags|=128,Bn(a,!1),e=u.updateQueue,t.updateQueue=e,Ku(t,e),t.subtreeFlags=0,e=l,l=t.child;l!==null;)Wr(l,e),l=l.sibling;return C(Xe,Xe.current&1|2),Se&&tl(t,a.treeForkCount),t.child}e=e.sibling}a.tail!==null&&ct()>Fu&&(t.flags|=128,n=!0,Bn(a,!1),t.lanes=4194304)}else{if(!n)if(e=Ou(u),e!==null){if(t.flags|=128,n=!0,e=e.updateQueue,t.updateQueue=e,Ku(t,e),Bn(a,!0),a.tail===null&&a.tailMode==="hidden"&&!u.alternate&&!Se)return qe(t),null}else 2*ct()-a.renderingStartTime>Fu&&l!==536870912&&(t.flags|=128,n=!0,Bn(a,!1),t.lanes=4194304);a.isBackwards?(u.sibling=t.child,t.child=u):(e=a.last,e!==null?e.sibling=u:t.child=u,a.last=u)}return a.tail!==null?(e=a.tail,a.rendering=e,a.tail=e.sibling,a.renderingStartTime=ct(),e.sibling=null,l=Xe.current,C(Xe,n?l&1|2:l&1),Se&&tl(t,a.treeForkCount),e):(qe(t),null);case 22:case 23:return jt(t),Ni(),a=t.memoizedState!==null,e!==null?e.memoizedState!==null!==a&&(t.flags|=8192):a&&(t.flags|=8192),a?(l&536870912)!==0&&(t.flags&128)===0&&(qe(t),t.subtreeFlags&6&&(t.flags|=8192)):qe(t),l=t.updateQueue,l!==null&&Ku(t,l.retryQueue),l=null,e!==null&&e.memoizedState!==null&&e.memoizedState.cachePool!==null&&(l=e.memoizedState.cachePool.pool),a=null,t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(a=t.memoizedState.cachePool.pool),a!==l&&(t.flags|=2048),e!==null&&_(aa),null;case 24:return l=null,e!==null&&(l=e.memoizedState.cache),t.memoizedState.cache!==l&&(t.flags|=2048),al(Ze),qe(t),null;case 25:return null;case 30:return null}throw Error(o(156,t.tag))}function Ym(e,t){switch(ri(t),t.tag){case 1:return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return al(Ze),Ae(),e=t.flags,(e&65536)!==0&&(e&128)===0?(t.flags=e&-65537|128,t):null;case 26:case 27:case 5:return pt(t),null;case 31:if(t.memoizedState!==null){if(jt(t),t.alternate===null)throw Error(o(340));ea()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 13:if(jt(t),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(o(340));ea()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return _(Xe),null;case 4:return Ae(),null;case 10:return al(t.type),null;case 22:case 23:return jt(t),Ni(),e!==null&&_(aa),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 24:return al(Ze),null;case 25:return null;default:return null}}function Tf(e,t){switch(ri(t),t.tag){case 3:al(Ze),Ae();break;case 26:case 27:case 5:pt(t);break;case 4:Ae();break;case 31:t.memoizedState!==null&&jt(t);break;case 13:jt(t);break;case 19:_(Xe);break;case 10:al(t.type);break;case 22:case 23:jt(t),Ni(),e!==null&&_(aa);break;case 24:al(Ze)}}function Hn(e,t){try{var l=t.updateQueue,a=l!==null?l.lastEffect:null;if(a!==null){var n=a.next;l=n;do{if((l.tag&e)===e){a=void 0;var u=l.create,i=l.inst;a=u(),i.destroy=a}l=l.next}while(l!==n)}}catch(f){Me(t,t.return,f)}}function Ml(e,t,l){try{var a=t.updateQueue,n=a!==null?a.lastEffect:null;if(n!==null){var u=n.next;a=u;do{if((a.tag&e)===e){var i=a.inst,f=i.destroy;if(f!==void 0){i.destroy=void 0,n=t;var h=l,j=f;try{j()}catch(D){Me(n,h,D)}}}a=a.next}while(a!==u)}}catch(D){Me(t,t.return,D)}}function wf(e){var t=e.updateQueue;if(t!==null){var l=e.stateNode;try{go(t,l)}catch(a){Me(e,e.return,a)}}}function _f(e,t,l){l.props=sa(e.type,e.memoizedProps),l.state=e.memoizedState;try{l.componentWillUnmount()}catch(a){Me(e,t,a)}}function qn(e,t){try{var l=e.ref;if(l!==null){switch(e.tag){case 26:case 27:case 5:var a=e.stateNode;break;case 30:a=e.stateNode;break;default:a=e.stateNode}typeof l=="function"?e.refCleanup=l(a):l.current=a}}catch(n){Me(e,t,n)}}function Jt(e,t){var l=e.ref,a=e.refCleanup;if(l!==null)if(typeof a=="function")try{a()}catch(n){Me(e,t,n)}finally{e.refCleanup=null,e=e.alternate,e!=null&&(e.refCleanup=null)}else if(typeof l=="function")try{l(null)}catch(n){Me(e,t,n)}else l.current=null}function Af(e){var t=e.type,l=e.memoizedProps,a=e.stateNode;try{e:switch(t){case"button":case"input":case"select":case"textarea":l.autoFocus&&a.focus();break e;case"img":l.src?a.src=l.src:l.srcSet&&(a.srcset=l.srcSet)}}catch(n){Me(e,e.return,n)}}function ls(e,t,l){try{var a=e.stateNode;sh(a,e.type,l,t),a[dt]=t}catch(n){Me(e,e.return,n)}}function zf(e){return e.tag===5||e.tag===3||e.tag===26||e.tag===27&&Hl(e.type)||e.tag===4}function as(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||zf(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.tag===27&&Hl(e.type)||e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function ns(e,t,l){var a=e.tag;if(a===5||a===6)e=e.stateNode,t?(l.nodeType===9?l.body:l.nodeName==="HTML"?l.ownerDocument.body:l).insertBefore(e,t):(t=l.nodeType===9?l.body:l.nodeName==="HTML"?l.ownerDocument.body:l,t.appendChild(e),l=l._reactRootContainer,l!=null||t.onclick!==null||(t.onclick=It));else if(a!==4&&(a===27&&Hl(e.type)&&(l=e.stateNode,t=null),e=e.child,e!==null))for(ns(e,t,l),e=e.sibling;e!==null;)ns(e,t,l),e=e.sibling}function ku(e,t,l){var a=e.tag;if(a===5||a===6)e=e.stateNode,t?l.insertBefore(e,t):l.appendChild(e);else if(a!==4&&(a===27&&Hl(e.type)&&(l=e.stateNode),e=e.child,e!==null))for(ku(e,t,l),e=e.sibling;e!==null;)ku(e,t,l),e=e.sibling}function Mf(e){var t=e.stateNode,l=e.memoizedProps;try{for(var a=e.type,n=t.attributes;n.length;)t.removeAttributeNode(n[0]);nt(t,a,l),t[et]=e,t[dt]=l}catch(u){Me(e,e.return,u)}}var sl=!1,ke=!1,us=!1,Df=typeof WeakSet=="function"?WeakSet:Set,Pe=null;function Gm(e,t){if(e=e.containerInfo,ws=hc,e=Gr(e),Ic(e)){if("selectionStart"in e)var l={start:e.selectionStart,end:e.selectionEnd};else e:{l=(l=e.ownerDocument)&&l.defaultView||window;var a=l.getSelection&&l.getSelection();if(a&&a.rangeCount!==0){l=a.anchorNode;var n=a.anchorOffset,u=a.focusNode;a=a.focusOffset;try{l.nodeType,u.nodeType}catch{l=null;break e}var i=0,f=-1,h=-1,j=0,D=0,B=e,T=null;t:for(;;){for(var z;B!==l||n!==0&&B.nodeType!==3||(f=i+n),B!==u||a!==0&&B.nodeType!==3||(h=i+a),B.nodeType===3&&(i+=B.nodeValue.length),(z=B.firstChild)!==null;)T=B,B=z;for(;;){if(B===e)break t;if(T===l&&++j===n&&(f=i),T===u&&++D===a&&(h=i),(z=B.nextSibling)!==null)break;B=T,T=B.parentNode}B=z}l=f===-1||h===-1?null:{start:f,end:h}}else l=null}l=l||{start:0,end:0}}else l=null;for(_s={focusedElem:e,selectionRange:l},hc=!1,Pe=t;Pe!==null;)if(t=Pe,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,Pe=e;else for(;Pe!==null;){switch(t=Pe,u=t.alternate,e=t.flags,t.tag){case 0:if((e&4)!==0&&(e=t.updateQueue,e=e!==null?e.events:null,e!==null))for(l=0;l<e.length;l++)n=e[l],n.ref.impl=n.nextImpl;break;case 11:case 15:break;case 1:if((e&1024)!==0&&u!==null){e=void 0,l=t,n=u.memoizedProps,u=u.memoizedState,a=l.stateNode;try{var $=sa(l.type,n);e=a.getSnapshotBeforeUpdate($,u),a.__reactInternalSnapshotBeforeUpdate=e}catch(ne){Me(l,l.return,ne)}}break;case 3:if((e&1024)!==0){if(e=t.stateNode.containerInfo,l=e.nodeType,l===9)Ms(e);else if(l===1)switch(e.nodeName){case"HEAD":case"HTML":case"BODY":Ms(e);break;default:e.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((e&1024)!==0)throw Error(o(163))}if(e=t.sibling,e!==null){e.return=t.return,Pe=e;break}Pe=t.return}}function Cf(e,t,l){var a=l.flags;switch(l.tag){case 0:case 11:case 15:ol(e,l),a&4&&Hn(5,l);break;case 1:if(ol(e,l),a&4)if(e=l.stateNode,t===null)try{e.componentDidMount()}catch(i){Me(l,l.return,i)}else{var n=sa(l.type,t.memoizedProps);t=t.memoizedState;try{e.componentDidUpdate(n,t,e.__reactInternalSnapshotBeforeUpdate)}catch(i){Me(l,l.return,i)}}a&64&&wf(l),a&512&&qn(l,l.return);break;case 3:if(ol(e,l),a&64&&(e=l.updateQueue,e!==null)){if(t=null,l.child!==null)switch(l.child.tag){case 27:case 5:t=l.child.stateNode;break;case 1:t=l.child.stateNode}try{go(e,t)}catch(i){Me(l,l.return,i)}}break;case 27:t===null&&a&4&&Mf(l);case 26:case 5:ol(e,l),t===null&&a&4&&Af(l),a&512&&qn(l,l.return);break;case 12:ol(e,l);break;case 31:ol(e,l),a&4&&Uf(e,l);break;case 13:ol(e,l),a&4&&Bf(e,l),a&64&&(e=l.memoizedState,e!==null&&(e=e.dehydrated,e!==null&&(l=Wm.bind(null,l),yh(e,l))));break;case 22:if(a=l.memoizedState!==null||sl,!a){t=t!==null&&t.memoizedState!==null||ke,n=sl;var u=ke;sl=a,(ke=t)&&!u?fl(e,l,(l.subtreeFlags&8772)!==0):ol(e,l),sl=n,ke=u}break;case 30:break;default:ol(e,l)}}function Of(e){var t=e.alternate;t!==null&&(e.alternate=null,Of(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&Uc(t)),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}var Le=null,ht=!1;function rl(e,t,l){for(l=l.child;l!==null;)Rf(e,t,l),l=l.sibling}function Rf(e,t,l){if(it&&typeof it.onCommitFiberUnmount=="function")try{it.onCommitFiberUnmount(Zl,l)}catch{}switch(l.tag){case 26:ke||Jt(l,t),rl(e,t,l),l.memoizedState?l.memoizedState.count--:l.stateNode&&(l=l.stateNode,l.parentNode.removeChild(l));break;case 27:ke||Jt(l,t);var a=Le,n=ht;Hl(l.type)&&(Le=l.stateNode,ht=!1),rl(e,t,l),kn(l.stateNode),Le=a,ht=n;break;case 5:ke||Jt(l,t);case 6:if(a=Le,n=ht,Le=null,rl(e,t,l),Le=a,ht=n,Le!==null)if(ht)try{(Le.nodeType===9?Le.body:Le.nodeName==="HTML"?Le.ownerDocument.body:Le).removeChild(l.stateNode)}catch(u){Me(l,t,u)}else try{Le.removeChild(l.stateNode)}catch(u){Me(l,t,u)}break;case 18:Le!==null&&(ht?(e=Le,wd(e.nodeType===9?e.body:e.nodeName==="HTML"?e.ownerDocument.body:e,l.stateNode),en(e)):wd(Le,l.stateNode));break;case 4:a=Le,n=ht,Le=l.stateNode.containerInfo,ht=!0,rl(e,t,l),Le=a,ht=n;break;case 0:case 11:case 14:case 15:Ml(2,l,t),ke||Ml(4,l,t),rl(e,t,l);break;case 1:ke||(Jt(l,t),a=l.stateNode,typeof a.componentWillUnmount=="function"&&_f(l,t,a)),rl(e,t,l);break;case 21:rl(e,t,l);break;case 22:ke=(a=ke)||l.memoizedState!==null,rl(e,t,l),ke=a;break;default:rl(e,t,l)}}function Uf(e,t){if(t.memoizedState===null&&(e=t.alternate,e!==null&&(e=e.memoizedState,e!==null))){e=e.dehydrated;try{en(e)}catch(l){Me(t,t.return,l)}}}function Bf(e,t){if(t.memoizedState===null&&(e=t.alternate,e!==null&&(e=e.memoizedState,e!==null&&(e=e.dehydrated,e!==null))))try{en(e)}catch(l){Me(t,t.return,l)}}function Xm(e){switch(e.tag){case 31:case 13:case 19:var t=e.stateNode;return t===null&&(t=e.stateNode=new Df),t;case 22:return e=e.stateNode,t=e._retryCache,t===null&&(t=e._retryCache=new Df),t;default:throw Error(o(435,e.tag))}}function Ju(e,t){var l=Xm(e);t.forEach(function(a){if(!l.has(a)){l.add(a);var n=Fm.bind(null,e,a);a.then(n,n)}})}function gt(e,t){var l=t.deletions;if(l!==null)for(var a=0;a<l.length;a++){var n=l[a],u=e,i=t,f=i;e:for(;f!==null;){switch(f.tag){case 27:if(Hl(f.type)){Le=f.stateNode,ht=!1;break e}break;case 5:Le=f.stateNode,ht=!1;break e;case 3:case 4:Le=f.stateNode.containerInfo,ht=!0;break e}f=f.return}if(Le===null)throw Error(o(160));Rf(u,i,n),Le=null,ht=!1,u=n.alternate,u!==null&&(u.return=null),n.return=null}if(t.subtreeFlags&13886)for(t=t.child;t!==null;)Hf(t,e),t=t.sibling}var Xt=null;function Hf(e,t){var l=e.alternate,a=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:gt(t,e),yt(e),a&4&&(Ml(3,e,e.return),Hn(3,e),Ml(5,e,e.return));break;case 1:gt(t,e),yt(e),a&512&&(ke||l===null||Jt(l,l.return)),a&64&&sl&&(e=e.updateQueue,e!==null&&(a=e.callbacks,a!==null&&(l=e.shared.hiddenCallbacks,e.shared.hiddenCallbacks=l===null?a:l.concat(a))));break;case 26:var n=Xt;if(gt(t,e),yt(e),a&512&&(ke||l===null||Jt(l,l.return)),a&4){var u=l!==null?l.memoizedState:null;if(a=e.memoizedState,l===null)if(a===null)if(e.stateNode===null){e:{a=e.type,l=e.memoizedProps,n=n.ownerDocument||n;t:switch(a){case"title":u=n.getElementsByTagName("title")[0],(!u||u[fn]||u[et]||u.namespaceURI==="http://www.w3.org/2000/svg"||u.hasAttribute("itemprop"))&&(u=n.createElement(a),n.head.insertBefore(u,n.querySelector("head > title"))),nt(u,a,l),u[et]=e,Ie(u),a=u;break e;case"link":var i=Hd("link","href",n).get(a+(l.href||""));if(i){for(var f=0;f<i.length;f++)if(u=i[f],u.getAttribute("href")===(l.href==null||l.href===""?null:l.href)&&u.getAttribute("rel")===(l.rel==null?null:l.rel)&&u.getAttribute("title")===(l.title==null?null:l.title)&&u.getAttribute("crossorigin")===(l.crossOrigin==null?null:l.crossOrigin)){i.splice(f,1);break t}}u=n.createElement(a),nt(u,a,l),n.head.appendChild(u);break;case"meta":if(i=Hd("meta","content",n).get(a+(l.content||""))){for(f=0;f<i.length;f++)if(u=i[f],u.getAttribute("content")===(l.content==null?null:""+l.content)&&u.getAttribute("name")===(l.name==null?null:l.name)&&u.getAttribute("property")===(l.property==null?null:l.property)&&u.getAttribute("http-equiv")===(l.httpEquiv==null?null:l.httpEquiv)&&u.getAttribute("charset")===(l.charSet==null?null:l.charSet)){i.splice(f,1);break t}}u=n.createElement(a),nt(u,a,l),n.head.appendChild(u);break;default:throw Error(o(468,a))}u[et]=e,Ie(u),a=u}e.stateNode=a}else qd(n,e.type,e.stateNode);else e.stateNode=Bd(n,a,e.memoizedProps);else u!==a?(u===null?l.stateNode!==null&&(l=l.stateNode,l.parentNode.removeChild(l)):u.count--,a===null?qd(n,e.type,e.stateNode):Bd(n,a,e.memoizedProps)):a===null&&e.stateNode!==null&&ls(e,e.memoizedProps,l.memoizedProps)}break;case 27:gt(t,e),yt(e),a&512&&(ke||l===null||Jt(l,l.return)),l!==null&&a&4&&ls(e,e.memoizedProps,l.memoizedProps);break;case 5:if(gt(t,e),yt(e),a&512&&(ke||l===null||Jt(l,l.return)),e.flags&32){n=e.stateNode;try{ja(n,"")}catch($){Me(e,e.return,$)}}a&4&&e.stateNode!=null&&(n=e.memoizedProps,ls(e,n,l!==null?l.memoizedProps:n)),a&1024&&(us=!0);break;case 6:if(gt(t,e),yt(e),a&4){if(e.stateNode===null)throw Error(o(162));a=e.memoizedProps,l=e.stateNode;try{l.nodeValue=a}catch($){Me(e,e.return,$)}}break;case 3:if(oc=null,n=Xt,Xt=sc(t.containerInfo),gt(t,e),Xt=n,yt(e),a&4&&l!==null&&l.memoizedState.isDehydrated)try{en(t.containerInfo)}catch($){Me(e,e.return,$)}us&&(us=!1,qf(e));break;case 4:a=Xt,Xt=sc(e.stateNode.containerInfo),gt(t,e),yt(e),Xt=a;break;case 12:gt(t,e),yt(e);break;case 31:gt(t,e),yt(e),a&4&&(a=e.updateQueue,a!==null&&(e.updateQueue=null,Ju(e,a)));break;case 13:gt(t,e),yt(e),e.child.flags&8192&&e.memoizedState!==null!=(l!==null&&l.memoizedState!==null)&&(Wu=ct()),a&4&&(a=e.updateQueue,a!==null&&(e.updateQueue=null,Ju(e,a)));break;case 22:n=e.memoizedState!==null;var h=l!==null&&l.memoizedState!==null,j=sl,D=ke;if(sl=j||n,ke=D||h,gt(t,e),ke=D,sl=j,yt(e),a&8192)e:for(t=e.stateNode,t._visibility=n?t._visibility&-2:t._visibility|1,n&&(l===null||h||sl||ke||ra(e)),l=null,t=e;;){if(t.tag===5||t.tag===26){if(l===null){h=l=t;try{if(u=h.stateNode,n)i=u.style,typeof i.setProperty=="function"?i.setProperty("display","none","important"):i.display="none";else{f=h.stateNode;var B=h.memoizedProps.style,T=B!=null&&B.hasOwnProperty("display")?B.display:null;f.style.display=T==null||typeof T=="boolean"?"":(""+T).trim()}}catch($){Me(h,h.return,$)}}}else if(t.tag===6){if(l===null){h=t;try{h.stateNode.nodeValue=n?"":h.memoizedProps}catch($){Me(h,h.return,$)}}}else if(t.tag===18){if(l===null){h=t;try{var z=h.stateNode;n?_d(z,!0):_d(h.stateNode,!1)}catch($){Me(h,h.return,$)}}}else if((t.tag!==22&&t.tag!==23||t.memoizedState===null||t===e)&&t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break e;for(;t.sibling===null;){if(t.return===null||t.return===e)break e;l===t&&(l=null),t=t.return}l===t&&(l=null),t.sibling.return=t.return,t=t.sibling}a&4&&(a=e.updateQueue,a!==null&&(l=a.retryQueue,l!==null&&(a.retryQueue=null,Ju(e,l))));break;case 19:gt(t,e),yt(e),a&4&&(a=e.updateQueue,a!==null&&(e.updateQueue=null,Ju(e,a)));break;case 30:break;case 21:break;default:gt(t,e),yt(e)}}function yt(e){var t=e.flags;if(t&2){try{for(var l,a=e.return;a!==null;){if(zf(a)){l=a;break}a=a.return}if(l==null)throw Error(o(160));switch(l.tag){case 27:var n=l.stateNode,u=as(e);ku(e,u,n);break;case 5:var i=l.stateNode;l.flags&32&&(ja(i,""),l.flags&=-33);var f=as(e);ku(e,f,i);break;case 3:case 4:var h=l.stateNode.containerInfo,j=as(e);ns(e,j,h);break;default:throw Error(o(161))}}catch(D){Me(e,e.return,D)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function qf(e){if(e.subtreeFlags&1024)for(e=e.child;e!==null;){var t=e;qf(t),t.tag===5&&t.flags&1024&&t.stateNode.reset(),e=e.sibling}}function ol(e,t){if(t.subtreeFlags&8772)for(t=t.child;t!==null;)Cf(e,t.alternate,t),t=t.sibling}function ra(e){for(e=e.child;e!==null;){var t=e;switch(t.tag){case 0:case 11:case 14:case 15:Ml(4,t,t.return),ra(t);break;case 1:Jt(t,t.return);var l=t.stateNode;typeof l.componentWillUnmount=="function"&&_f(t,t.return,l),ra(t);break;case 27:kn(t.stateNode);case 26:case 5:Jt(t,t.return),ra(t);break;case 22:t.memoizedState===null&&ra(t);break;case 30:ra(t);break;default:ra(t)}e=e.sibling}}function fl(e,t,l){for(l=l&&(t.subtreeFlags&8772)!==0,t=t.child;t!==null;){var a=t.alternate,n=e,u=t,i=u.flags;switch(u.tag){case 0:case 11:case 15:fl(n,u,l),Hn(4,u);break;case 1:if(fl(n,u,l),a=u,n=a.stateNode,typeof n.componentDidMount=="function")try{n.componentDidMount()}catch(j){Me(a,a.return,j)}if(a=u,n=a.updateQueue,n!==null){var f=a.stateNode;try{var h=n.shared.hiddenCallbacks;if(h!==null)for(n.shared.hiddenCallbacks=null,n=0;n<h.length;n++)ho(h[n],f)}catch(j){Me(a,a.return,j)}}l&&i&64&&wf(u),qn(u,u.return);break;case 27:Mf(u);case 26:case 5:fl(n,u,l),l&&a===null&&i&4&&Af(u),qn(u,u.return);break;case 12:fl(n,u,l);break;case 31:fl(n,u,l),l&&i&4&&Uf(n,u);break;case 13:fl(n,u,l),l&&i&4&&Bf(n,u);break;case 22:u.memoizedState===null&&fl(n,u,l),qn(u,u.return);break;case 30:break;default:fl(n,u,l)}t=t.sibling}}function cs(e,t){var l=null;e!==null&&e.memoizedState!==null&&e.memoizedState.cachePool!==null&&(l=e.memoizedState.cachePool.pool),e=null,t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(e=t.memoizedState.cachePool.pool),e!==l&&(e!=null&&e.refCount++,l!=null&&Nn(l))}function is(e,t){e=null,t.alternate!==null&&(e=t.alternate.memoizedState.cache),t=t.memoizedState.cache,t!==e&&(t.refCount++,e!=null&&Nn(e))}function Qt(e,t,l,a){if(t.subtreeFlags&10256)for(t=t.child;t!==null;)Lf(e,t,l,a),t=t.sibling}function Lf(e,t,l,a){var n=t.flags;switch(t.tag){case 0:case 11:case 15:Qt(e,t,l,a),n&2048&&Hn(9,t);break;case 1:Qt(e,t,l,a);break;case 3:Qt(e,t,l,a),n&2048&&(e=null,t.alternate!==null&&(e=t.alternate.memoizedState.cache),t=t.memoizedState.cache,t!==e&&(t.refCount++,e!=null&&Nn(e)));break;case 12:if(n&2048){Qt(e,t,l,a),e=t.stateNode;try{var u=t.memoizedProps,i=u.id,f=u.onPostCommit;typeof f=="function"&&f(i,t.alternate===null?"mount":"update",e.passiveEffectDuration,-0)}catch(h){Me(t,t.return,h)}}else Qt(e,t,l,a);break;case 31:Qt(e,t,l,a);break;case 13:Qt(e,t,l,a);break;case 23:break;case 22:u=t.stateNode,i=t.alternate,t.memoizedState!==null?u._visibility&2?Qt(e,t,l,a):Ln(e,t):u._visibility&2?Qt(e,t,l,a):(u._visibility|=2,Qa(e,t,l,a,(t.subtreeFlags&10256)!==0||!1)),n&2048&&cs(i,t);break;case 24:Qt(e,t,l,a),n&2048&&is(t.alternate,t);break;default:Qt(e,t,l,a)}}function Qa(e,t,l,a,n){for(n=n&&((t.subtreeFlags&10256)!==0||!1),t=t.child;t!==null;){var u=e,i=t,f=l,h=a,j=i.flags;switch(i.tag){case 0:case 11:case 15:Qa(u,i,f,h,n),Hn(8,i);break;case 23:break;case 22:var D=i.stateNode;i.memoizedState!==null?D._visibility&2?Qa(u,i,f,h,n):Ln(u,i):(D._visibility|=2,Qa(u,i,f,h,n)),n&&j&2048&&cs(i.alternate,i);break;case 24:Qa(u,i,f,h,n),n&&j&2048&&is(i.alternate,i);break;default:Qa(u,i,f,h,n)}t=t.sibling}}function Ln(e,t){if(t.subtreeFlags&10256)for(t=t.child;t!==null;){var l=e,a=t,n=a.flags;switch(a.tag){case 22:Ln(l,a),n&2048&&cs(a.alternate,a);break;case 24:Ln(l,a),n&2048&&is(a.alternate,a);break;default:Ln(l,a)}t=t.sibling}}var Yn=8192;function Za(e,t,l){if(e.subtreeFlags&Yn)for(e=e.child;e!==null;)Yf(e,t,l),e=e.sibling}function Yf(e,t,l){switch(e.tag){case 26:Za(e,t,l),e.flags&Yn&&e.memoizedState!==null&&Ah(l,Xt,e.memoizedState,e.memoizedProps);break;case 5:Za(e,t,l);break;case 3:case 4:var a=Xt;Xt=sc(e.stateNode.containerInfo),Za(e,t,l),Xt=a;break;case 22:e.memoizedState===null&&(a=e.alternate,a!==null&&a.memoizedState!==null?(a=Yn,Yn=16777216,Za(e,t,l),Yn=a):Za(e,t,l));break;default:Za(e,t,l)}}function Gf(e){var t=e.alternate;if(t!==null&&(e=t.child,e!==null)){t.child=null;do t=e.sibling,e.sibling=null,e=t;while(e!==null)}}function Gn(e){var t=e.deletions;if((e.flags&16)!==0){if(t!==null)for(var l=0;l<t.length;l++){var a=t[l];Pe=a,Qf(a,e)}Gf(e)}if(e.subtreeFlags&10256)for(e=e.child;e!==null;)Xf(e),e=e.sibling}function Xf(e){switch(e.tag){case 0:case 11:case 15:Gn(e),e.flags&2048&&Ml(9,e,e.return);break;case 3:Gn(e);break;case 12:Gn(e);break;case 22:var t=e.stateNode;e.memoizedState!==null&&t._visibility&2&&(e.return===null||e.return.tag!==13)?(t._visibility&=-3,$u(e)):Gn(e);break;default:Gn(e)}}function $u(e){var t=e.deletions;if((e.flags&16)!==0){if(t!==null)for(var l=0;l<t.length;l++){var a=t[l];Pe=a,Qf(a,e)}Gf(e)}for(e=e.child;e!==null;){switch(t=e,t.tag){case 0:case 11:case 15:Ml(8,t,t.return),$u(t);break;case 22:l=t.stateNode,l._visibility&2&&(l._visibility&=-3,$u(t));break;default:$u(t)}e=e.sibling}}function Qf(e,t){for(;Pe!==null;){var l=Pe;switch(l.tag){case 0:case 11:case 15:Ml(8,l,t);break;case 23:case 22:if(l.memoizedState!==null&&l.memoizedState.cachePool!==null){var a=l.memoizedState.cachePool.pool;a!=null&&a.refCount++}break;case 24:Nn(l.memoizedState.cache)}if(a=l.child,a!==null)a.return=l,Pe=a;else e:for(l=e;Pe!==null;){a=Pe;var n=a.sibling,u=a.return;if(Of(a),a===l){Pe=null;break e}if(n!==null){n.return=u,Pe=n;break e}Pe=u}}}var Qm={getCacheForType:function(e){var t=lt(Ze),l=t.data.get(e);return l===void 0&&(l=e(),t.data.set(e,l)),l},cacheSignal:function(){return lt(Ze).controller.signal}},Zm=typeof WeakMap=="function"?WeakMap:Map,_e=0,Ue=null,ve=null,pe=0,ze=0,Nt=null,Dl=!1,Va=!1,ss=!1,dl=0,Ge=0,Cl=0,oa=0,rs=0,Tt=0,Ka=0,Xn=null,vt=null,os=!1,Wu=0,Zf=0,Fu=1/0,Iu=null,Ol=null,$e=0,Rl=null,ka=null,ml=0,fs=0,ds=null,Vf=null,Qn=0,ms=null;function wt(){return(_e&2)!==0&&pe!==0?pe&-pe:S.T!==null?ps():ur()}function Kf(){if(Tt===0)if((pe&536870912)===0||Se){var e=Vl;Vl<<=1,(Vl&3932160)===0&&(Vl=262144),Tt=e}else Tt=536870912;return e=Et.current,e!==null&&(e.flags|=32),Tt}function bt(e,t,l){(e===Ue&&(ze===2||ze===9)||e.cancelPendingCommit!==null)&&(Ja(e,0),Ul(e,pe,Tt,!1)),_t(e,l),((_e&2)===0||e!==Ue)&&(e===Ue&&((_e&2)===0&&(oa|=l),Ge===4&&Ul(e,pe,Tt,!1)),$t(e))}function kf(e,t,l){if((_e&6)!==0)throw Error(o(327));var a=!l&&(t&127)===0&&(t&e.expiredLanes)===0||Be(e,t),n=a?km(e,t):gs(e,t,!0),u=a;do{if(n===0){Va&&!a&&Ul(e,t,0,!1);break}else{if(l=e.current.alternate,u&&!Vm(l)){n=gs(e,t,!1),u=!1;continue}if(n===2){if(u=t,e.errorRecoveryDisabledLanes&u)var i=0;else i=e.pendingLanes&-536870913,i=i!==0?i:i&536870912?536870912:0;if(i!==0){t=i;e:{var f=e;n=Xn;var h=f.current.memoizedState.isDehydrated;if(h&&(Ja(f,i).flags|=256),i=gs(f,i,!1),i!==2){if(ss&&!h){f.errorRecoveryDisabledLanes|=u,oa|=u,n=4;break e}u=vt,vt=n,u!==null&&(vt===null?vt=u:vt.push.apply(vt,u))}n=i}if(u=!1,n!==2)continue}}if(n===1){Ja(e,0),Ul(e,t,0,!0);break}e:{switch(a=e,u=n,u){case 0:case 1:throw Error(o(345));case 4:if((t&4194048)!==t)break;case 6:Ul(a,t,Tt,!Dl);break e;case 2:vt=null;break;case 3:case 5:break;default:throw Error(o(329))}if((t&62914560)===t&&(n=Wu+300-ct(),10<n)){if(Ul(a,t,Tt,!Dl),ye(a,0,!0)!==0)break e;ml=t,a.timeoutHandle=Nd(Jf.bind(null,a,l,vt,Iu,os,t,Tt,oa,Ka,Dl,u,"Throttled",-0,0),n);break e}Jf(a,l,vt,Iu,os,t,Tt,oa,Ka,Dl,u,null,-0,0)}}break}while(!0);$t(e)}function Jf(e,t,l,a,n,u,i,f,h,j,D,B,T,z){if(e.timeoutHandle=-1,B=t.subtreeFlags,B&8192||(B&16785408)===16785408){B={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:It},Yf(t,u,B);var $=(u&62914560)===u?Wu-ct():(u&4194048)===u?Zf-ct():0;if($=zh(B,$),$!==null){ml=u,e.cancelPendingCommit=$(ld.bind(null,e,t,u,l,a,n,i,f,h,D,B,null,T,z)),Ul(e,u,i,!j);return}}ld(e,t,u,l,a,n,i,f,h)}function Vm(e){for(var t=e;;){var l=t.tag;if((l===0||l===11||l===15)&&t.flags&16384&&(l=t.updateQueue,l!==null&&(l=l.stores,l!==null)))for(var a=0;a<l.length;a++){var n=l[a],u=n.getSnapshot;n=n.value;try{if(!xt(u(),n))return!1}catch{return!1}}if(l=t.child,t.subtreeFlags&16384&&l!==null)l.return=t,t=l;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Ul(e,t,l,a){t&=~rs,t&=~oa,e.suspendedLanes|=t,e.pingedLanes&=~t,a&&(e.warmLanes|=t),a=e.expirationTimes;for(var n=t;0<n;){var u=31-st(n),i=1<<u;a[u]=-1,n&=~i}l!==0&&Dc(e,l,t)}function Pu(){return(_e&6)===0?(Zn(0),!1):!0}function hs(){if(ve!==null){if(ze===0)var e=ve.return;else e=ve,ll=ta=null,Mi(e),qa=null,wn=0,e=ve;for(;e!==null;)Tf(e.alternate,e),e=e.return;ve=null}}function Ja(e,t){var l=e.timeoutHandle;l!==-1&&(e.timeoutHandle=-1,fh(l)),l=e.cancelPendingCommit,l!==null&&(e.cancelPendingCommit=null,l()),ml=0,hs(),Ue=e,ve=l=el(e.current,null),pe=t,ze=0,Nt=null,Dl=!1,Va=Be(e,t),ss=!1,Ka=Tt=rs=oa=Cl=Ge=0,vt=Xn=null,os=!1,(t&8)!==0&&(t|=t&32);var a=e.entangledLanes;if(a!==0)for(e=e.entanglements,a&=t;0<a;){var n=31-st(a),u=1<<n;t|=e[n],a&=~u}return dl=t,xu(),l}function $f(e,t){fe=null,S.H=Rn,t===Ha||t===Au?(t=ro(),ze=3):t===bi?(t=ro(),ze=4):ze=t===Ki?8:t!==null&&typeof t=="object"&&typeof t.then=="function"?6:1,Nt=t,ve===null&&(Ge=1,Xu(e,Dt(t,e.current)))}function Wf(){var e=Et.current;return e===null?!0:(pe&4194048)===pe?Ut===null:(pe&62914560)===pe||(pe&536870912)!==0?e===Ut:!1}function Ff(){var e=S.H;return S.H=Rn,e===null?Rn:e}function If(){var e=S.A;return S.A=Qm,e}function ec(){Ge=4,Dl||(pe&4194048)!==pe&&Et.current!==null||(Va=!0),(Cl&134217727)===0&&(oa&134217727)===0||Ue===null||Ul(Ue,pe,Tt,!1)}function gs(e,t,l){var a=_e;_e|=2;var n=Ff(),u=If();(Ue!==e||pe!==t)&&(Iu=null,Ja(e,t)),t=!1;var i=Ge;e:do try{if(ze!==0&&ve!==null){var f=ve,h=Nt;switch(ze){case 8:hs(),i=6;break e;case 3:case 2:case 9:case 6:Et.current===null&&(t=!0);var j=ze;if(ze=0,Nt=null,$a(e,f,h,j),l&&Va){i=0;break e}break;default:j=ze,ze=0,Nt=null,$a(e,f,h,j)}}Km(),i=Ge;break}catch(D){$f(e,D)}while(!0);return t&&e.shellSuspendCounter++,ll=ta=null,_e=a,S.H=n,S.A=u,ve===null&&(Ue=null,pe=0,xu()),i}function Km(){for(;ve!==null;)Pf(ve)}function km(e,t){var l=_e;_e|=2;var a=Ff(),n=If();Ue!==e||pe!==t?(Iu=null,Fu=ct()+500,Ja(e,t)):Va=Be(e,t);e:do try{if(ze!==0&&ve!==null){t=ve;var u=Nt;t:switch(ze){case 1:ze=0,Nt=null,$a(e,t,u,1);break;case 2:case 9:if(io(u)){ze=0,Nt=null,ed(t);break}t=function(){ze!==2&&ze!==9||Ue!==e||(ze=7),$t(e)},u.then(t,t);break e;case 3:ze=7;break e;case 4:ze=5;break e;case 7:io(u)?(ze=0,Nt=null,ed(t)):(ze=0,Nt=null,$a(e,t,u,7));break;case 5:var i=null;switch(ve.tag){case 26:i=ve.memoizedState;case 5:case 27:var f=ve;if(i?Ld(i):f.stateNode.complete){ze=0,Nt=null;var h=f.sibling;if(h!==null)ve=h;else{var j=f.return;j!==null?(ve=j,tc(j)):ve=null}break t}}ze=0,Nt=null,$a(e,t,u,5);break;case 6:ze=0,Nt=null,$a(e,t,u,6);break;case 8:hs(),Ge=6;break e;default:throw Error(o(462))}}Jm();break}catch(D){$f(e,D)}while(!0);return ll=ta=null,S.H=a,S.A=n,_e=l,ve!==null?0:(Ue=null,pe=0,xu(),Ge)}function Jm(){for(;ve!==null&&!jc();)Pf(ve)}function Pf(e){var t=jf(e.alternate,e,dl);e.memoizedProps=e.pendingProps,t===null?tc(e):ve=t}function ed(e){var t=e,l=t.alternate;switch(t.tag){case 15:case 0:t=vf(l,t,t.pendingProps,t.type,void 0,pe);break;case 11:t=vf(l,t,t.pendingProps,t.type.render,t.ref,pe);break;case 5:Mi(t);default:Tf(l,t),t=ve=Wr(t,dl),t=jf(l,t,dl)}e.memoizedProps=e.pendingProps,t===null?tc(e):ve=t}function $a(e,t,l,a){ll=ta=null,Mi(t),qa=null,wn=0;var n=t.return;try{if(Bm(e,n,t,l,pe)){Ge=1,Xu(e,Dt(l,e.current)),ve=null;return}}catch(u){if(n!==null)throw ve=n,u;Ge=1,Xu(e,Dt(l,e.current)),ve=null;return}t.flags&32768?(Se||a===1?e=!0:Va||(pe&536870912)!==0?e=!1:(Dl=e=!0,(a===2||a===9||a===3||a===6)&&(a=Et.current,a!==null&&a.tag===13&&(a.flags|=16384))),td(t,e)):tc(t)}function tc(e){var t=e;do{if((t.flags&32768)!==0){td(t,Dl);return}e=t.return;var l=Lm(t.alternate,t,dl);if(l!==null){ve=l;return}if(t=t.sibling,t!==null){ve=t;return}ve=t=e}while(t!==null);Ge===0&&(Ge=5)}function td(e,t){do{var l=Ym(e.alternate,e);if(l!==null){l.flags&=32767,ve=l;return}if(l=e.return,l!==null&&(l.flags|=32768,l.subtreeFlags=0,l.deletions=null),!t&&(e=e.sibling,e!==null)){ve=e;return}ve=e=l}while(e!==null);Ge=6,ve=null}function ld(e,t,l,a,n,u,i,f,h){e.cancelPendingCommit=null;do lc();while($e!==0);if((_e&6)!==0)throw Error(o(327));if(t!==null){if(t===e.current)throw Error(o(177));if(u=t.lanes|t.childLanes,u|=ai,Mc(e,l,u,i,f,h),e===Ue&&(ve=Ue=null,pe=0),ka=t,Rl=e,ml=l,fs=u,ds=n,Vf=a,(t.subtreeFlags&10256)!==0||(t.flags&10256)!==0?(e.callbackNode=null,e.callbackPriority=0,Im(ha,function(){return id(),null})):(e.callbackNode=null,e.callbackPriority=0),a=(t.flags&13878)!==0,(t.subtreeFlags&13878)!==0||a){a=S.T,S.T=null,n=O.p,O.p=2,i=_e,_e|=4;try{Gm(e,t,l)}finally{_e=i,O.p=n,S.T=a}}$e=1,ad(),nd(),ud()}}function ad(){if($e===1){$e=0;var e=Rl,t=ka,l=(t.flags&13878)!==0;if((t.subtreeFlags&13878)!==0||l){l=S.T,S.T=null;var a=O.p;O.p=2;var n=_e;_e|=4;try{Hf(t,e);var u=_s,i=Gr(e.containerInfo),f=u.focusedElem,h=u.selectionRange;if(i!==f&&f&&f.ownerDocument&&Yr(f.ownerDocument.documentElement,f)){if(h!==null&&Ic(f)){var j=h.start,D=h.end;if(D===void 0&&(D=j),"selectionStart"in f)f.selectionStart=j,f.selectionEnd=Math.min(D,f.value.length);else{var B=f.ownerDocument||document,T=B&&B.defaultView||window;if(T.getSelection){var z=T.getSelection(),$=f.textContent.length,ne=Math.min(h.start,$),Oe=h.end===void 0?ne:Math.min(h.end,$);!z.extend&&ne>Oe&&(i=Oe,Oe=ne,ne=i);var p=Lr(f,ne),v=Lr(f,Oe);if(p&&v&&(z.rangeCount!==1||z.anchorNode!==p.node||z.anchorOffset!==p.offset||z.focusNode!==v.node||z.focusOffset!==v.offset)){var E=B.createRange();E.setStart(p.node,p.offset),z.removeAllRanges(),ne>Oe?(z.addRange(E),z.extend(v.node,v.offset)):(E.setEnd(v.node,v.offset),z.addRange(E))}}}}for(B=[],z=f;z=z.parentNode;)z.nodeType===1&&B.push({element:z,left:z.scrollLeft,top:z.scrollTop});for(typeof f.focus=="function"&&f.focus(),f=0;f<B.length;f++){var R=B[f];R.element.scrollLeft=R.left,R.element.scrollTop=R.top}}hc=!!ws,_s=ws=null}finally{_e=n,O.p=a,S.T=l}}e.current=t,$e=2}}function nd(){if($e===2){$e=0;var e=Rl,t=ka,l=(t.flags&8772)!==0;if((t.subtreeFlags&8772)!==0||l){l=S.T,S.T=null;var a=O.p;O.p=2;var n=_e;_e|=4;try{Cf(e,t.alternate,t)}finally{_e=n,O.p=a,S.T=l}}$e=3}}function ud(){if($e===4||$e===3){$e=0,Nc();var e=Rl,t=ka,l=ml,a=Vf;(t.subtreeFlags&10256)!==0||(t.flags&10256)!==0?$e=5:($e=0,ka=Rl=null,cd(e,e.pendingLanes));var n=e.pendingLanes;if(n===0&&(Ol=null),Oc(l),t=t.stateNode,it&&typeof it.onCommitFiberRoot=="function")try{it.onCommitFiberRoot(Zl,t,void 0,(t.current.flags&128)===128)}catch{}if(a!==null){t=S.T,n=O.p,O.p=2,S.T=null;try{for(var u=e.onRecoverableError,i=0;i<a.length;i++){var f=a[i];u(f.value,{componentStack:f.stack})}}finally{S.T=t,O.p=n}}(ml&3)!==0&&lc(),$t(e),n=e.pendingLanes,(l&261930)!==0&&(n&42)!==0?e===ms?Qn++:(Qn=0,ms=e):Qn=0,Zn(0)}}function cd(e,t){(e.pooledCacheLanes&=t)===0&&(t=e.pooledCache,t!=null&&(e.pooledCache=null,Nn(t)))}function lc(){return ad(),nd(),ud(),id()}function id(){if($e!==5)return!1;var e=Rl,t=fs;fs=0;var l=Oc(ml),a=S.T,n=O.p;try{O.p=32>l?32:l,S.T=null,l=ds,ds=null;var u=Rl,i=ml;if($e=0,ka=Rl=null,ml=0,(_e&6)!==0)throw Error(o(331));var f=_e;if(_e|=4,Xf(u.current),Lf(u,u.current,i,l),_e=f,Zn(0,!1),it&&typeof it.onPostCommitFiberRoot=="function")try{it.onPostCommitFiberRoot(Zl,u)}catch{}return!0}finally{O.p=n,S.T=a,cd(e,t)}}function sd(e,t,l){t=Dt(l,t),t=Vi(e.stateNode,t,2),e=_l(e,t,2),e!==null&&(_t(e,2),$t(e))}function Me(e,t,l){if(e.tag===3)sd(e,e,l);else for(;t!==null;){if(t.tag===3){sd(t,e,l);break}else if(t.tag===1){var a=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof a.componentDidCatch=="function"&&(Ol===null||!Ol.has(a))){e=Dt(l,e),l=rf(2),a=_l(t,l,2),a!==null&&(of(l,a,t,e),_t(a,2),$t(a));break}}t=t.return}}function ys(e,t,l){var a=e.pingCache;if(a===null){a=e.pingCache=new Zm;var n=new Set;a.set(t,n)}else n=a.get(t),n===void 0&&(n=new Set,a.set(t,n));n.has(l)||(ss=!0,n.add(l),e=$m.bind(null,e,t,l),t.then(e,e))}function $m(e,t,l){var a=e.pingCache;a!==null&&a.delete(t),e.pingedLanes|=e.suspendedLanes&l,e.warmLanes&=~l,Ue===e&&(pe&l)===l&&(Ge===4||Ge===3&&(pe&62914560)===pe&&300>ct()-Wu?(_e&2)===0&&Ja(e,0):rs|=l,Ka===pe&&(Ka=0)),$t(e)}function rd(e,t){t===0&&(t=kl()),e=Il(e,t),e!==null&&(_t(e,t),$t(e))}function Wm(e){var t=e.memoizedState,l=0;t!==null&&(l=t.retryLane),rd(e,l)}function Fm(e,t){var l=0;switch(e.tag){case 31:case 13:var a=e.stateNode,n=e.memoizedState;n!==null&&(l=n.retryLane);break;case 19:a=e.stateNode;break;case 22:a=e.stateNode._retryCache;break;default:throw Error(o(314))}a!==null&&a.delete(t),rd(e,l)}function Im(e,t){return on(e,t)}var ac=null,Wa=null,vs=!1,nc=!1,bs=!1,Bl=0;function $t(e){e!==Wa&&e.next===null&&(Wa===null?ac=Wa=e:Wa=Wa.next=e),nc=!0,vs||(vs=!0,eh())}function Zn(e,t){if(!bs&&nc){bs=!0;do for(var l=!1,a=ac;a!==null;){if(e!==0){var n=a.pendingLanes;if(n===0)var u=0;else{var i=a.suspendedLanes,f=a.pingedLanes;u=(1<<31-st(42|e)+1)-1,u&=n&~(i&~f),u=u&201326741?u&201326741|1:u?u|2:0}u!==0&&(l=!0,md(a,u))}else u=pe,u=ye(a,a===Ue?u:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),(u&3)===0||Be(a,u)||(l=!0,md(a,u));a=a.next}while(l);bs=!1}}function Pm(){od()}function od(){nc=vs=!1;var e=0;Bl!==0&&oh()&&(e=Bl);for(var t=ct(),l=null,a=ac;a!==null;){var n=a.next,u=fd(a,t);u===0?(a.next=null,l===null?ac=n:l.next=n,n===null&&(Wa=l)):(l=a,(e!==0||(u&3)!==0)&&(nc=!0)),a=n}$e!==0&&$e!==5||Zn(e),Bl!==0&&(Bl=0)}function fd(e,t){for(var l=e.suspendedLanes,a=e.pingedLanes,n=e.expirationTimes,u=e.pendingLanes&-62914561;0<u;){var i=31-st(u),f=1<<i,h=n[i];h===-1?((f&l)===0||(f&a)!==0)&&(n[i]=Yt(f,t)):h<=t&&(e.expiredLanes|=f),u&=~f}if(t=Ue,l=pe,l=ye(e,e===t?l:0,e.cancelPendingCommit!==null||e.timeoutHandle!==-1),a=e.callbackNode,l===0||e===t&&(ze===2||ze===9)||e.cancelPendingCommit!==null)return a!==null&&a!==null&&ft(a),e.callbackNode=null,e.callbackPriority=0;if((l&3)===0||Be(e,l)){if(t=l&-l,t===e.callbackPriority)return t;switch(a!==null&&ft(a),Oc(l)){case 2:case 8:l=iu;break;case 32:l=ha;break;case 268435456:l=su;break;default:l=ha}return a=dd.bind(null,e),l=on(l,a),e.callbackPriority=t,e.callbackNode=l,t}return a!==null&&a!==null&&ft(a),e.callbackPriority=2,e.callbackNode=null,2}function dd(e,t){if($e!==0&&$e!==5)return e.callbackNode=null,e.callbackPriority=0,null;var l=e.callbackNode;if(lc()&&e.callbackNode!==l)return null;var a=pe;return a=ye(e,e===Ue?a:0,e.cancelPendingCommit!==null||e.timeoutHandle!==-1),a===0?null:(kf(e,a,t),fd(e,ct()),e.callbackNode!=null&&e.callbackNode===l?dd.bind(null,e):null)}function md(e,t){if(lc())return null;kf(e,t,!0)}function eh(){dh(function(){(_e&6)!==0?on(cu,Pm):od()})}function ps(){if(Bl===0){var e=Ua;e===0&&(e=ya,ya<<=1,(ya&261888)===0&&(ya=256)),Bl=e}return Bl}function hd(e){return e==null||typeof e=="symbol"||typeof e=="boolean"?null:typeof e=="function"?e:du(""+e)}function gd(e,t){var l=t.ownerDocument.createElement("input");return l.name=t.name,l.value=t.value,e.id&&l.setAttribute("form",e.id),t.parentNode.insertBefore(l,t),e=new FormData(e),l.parentNode.removeChild(l),e}function th(e,t,l,a,n){if(t==="submit"&&l&&l.stateNode===n){var u=hd((n[dt]||null).action),i=a.submitter;i&&(t=(t=i[dt]||null)?hd(t.formAction):i.getAttribute("formAction"),t!==null&&(u=t,i=null));var f=new yu("action","action",null,a,n);e.push({event:f,listeners:[{instance:null,listener:function(){if(a.defaultPrevented){if(Bl!==0){var h=i?gd(n,i):new FormData(n);Li(l,{pending:!0,data:h,method:n.method,action:u},null,h)}}else typeof u=="function"&&(f.preventDefault(),h=i?gd(n,i):new FormData(n),Li(l,{pending:!0,data:h,method:n.method,action:u},u,h))},currentTarget:n}]})}}for(var xs=0;xs<li.length;xs++){var Ss=li[xs],lh=Ss.toLowerCase(),ah=Ss[0].toUpperCase()+Ss.slice(1);Gt(lh,"on"+ah)}Gt(Zr,"onAnimationEnd"),Gt(Vr,"onAnimationIteration"),Gt(Kr,"onAnimationStart"),Gt("dblclick","onDoubleClick"),Gt("focusin","onFocus"),Gt("focusout","onBlur"),Gt(pm,"onTransitionRun"),Gt(xm,"onTransitionStart"),Gt(Sm,"onTransitionCancel"),Gt(kr,"onTransitionEnd"),Sa("onMouseEnter",["mouseout","mouseover"]),Sa("onMouseLeave",["mouseout","mouseover"]),Sa("onPointerEnter",["pointerout","pointerover"]),Sa("onPointerLeave",["pointerout","pointerover"]),Jl("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Jl("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Jl("onBeforeInput",["compositionend","keypress","textInput","paste"]),Jl("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Jl("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Jl("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Vn="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),nh=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Vn));function yd(e,t){t=(t&4)!==0;for(var l=0;l<e.length;l++){var a=e[l],n=a.event;a=a.listeners;e:{var u=void 0;if(t)for(var i=a.length-1;0<=i;i--){var f=a[i],h=f.instance,j=f.currentTarget;if(f=f.listener,h!==u&&n.isPropagationStopped())break e;u=f,n.currentTarget=j;try{u(n)}catch(D){pu(D)}n.currentTarget=null,u=h}else for(i=0;i<a.length;i++){if(f=a[i],h=f.instance,j=f.currentTarget,f=f.listener,h!==u&&n.isPropagationStopped())break e;u=f,n.currentTarget=j;try{u(n)}catch(D){pu(D)}n.currentTarget=null,u=h}}}}function be(e,t){var l=t[Rc];l===void 0&&(l=t[Rc]=new Set);var a=e+"__bubble";l.has(a)||(vd(t,e,2,!1),l.add(a))}function Es(e,t,l){var a=0;t&&(a|=4),vd(l,e,a,t)}var uc="_reactListening"+Math.random().toString(36).slice(2);function js(e){if(!e[uc]){e[uc]=!0,sr.forEach(function(l){l!=="selectionchange"&&(nh.has(l)||Es(l,!1,e),Es(l,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[uc]||(t[uc]=!0,Es("selectionchange",!1,t))}}function vd(e,t,l,a){switch(Kd(t)){case 2:var n=Ch;break;case 8:n=Oh;break;default:n=qs}l=n.bind(null,t,l,e),n=void 0,!Qc||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(n=!0),a?n!==void 0?e.addEventListener(t,l,{capture:!0,passive:n}):e.addEventListener(t,l,!0):n!==void 0?e.addEventListener(t,l,{passive:n}):e.addEventListener(t,l,!1)}function Ns(e,t,l,a,n){var u=a;if((t&1)===0&&(t&2)===0&&a!==null)e:for(;;){if(a===null)return;var i=a.tag;if(i===3||i===4){var f=a.stateNode.containerInfo;if(f===n)break;if(i===4)for(i=a.return;i!==null;){var h=i.tag;if((h===3||h===4)&&i.stateNode.containerInfo===n)return;i=i.return}for(;f!==null;){if(i=ba(f),i===null)return;if(h=i.tag,h===5||h===6||h===26||h===27){a=u=i;continue e}f=f.parentNode}}a=a.return}xr(function(){var j=u,D=Gc(l),B=[];e:{var T=Jr.get(e);if(T!==void 0){var z=yu,$=e;switch(e){case"keypress":if(hu(l)===0)break e;case"keydown":case"keyup":z=F0;break;case"focusin":$="focus",z=kc;break;case"focusout":$="blur",z=kc;break;case"beforeblur":case"afterblur":z=kc;break;case"click":if(l.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":z=jr;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":z=L0;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":z=em;break;case Zr:case Vr:case Kr:z=X0;break;case kr:z=lm;break;case"scroll":case"scrollend":z=H0;break;case"wheel":z=nm;break;case"copy":case"cut":case"paste":z=Z0;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":z=Tr;break;case"toggle":case"beforetoggle":z=cm}var ne=(t&4)!==0,Oe=!ne&&(e==="scroll"||e==="scrollend"),p=ne?T!==null?T+"Capture":null:T;ne=[];for(var v=j,E;v!==null;){var R=v;if(E=R.stateNode,R=R.tag,R!==5&&R!==26&&R!==27||E===null||p===null||(R=mn(v,p),R!=null&&ne.push(Kn(v,R,E))),Oe)break;v=v.return}0<ne.length&&(T=new z(T,$,null,l,D),B.push({event:T,listeners:ne}))}}if((t&7)===0){e:{if(T=e==="mouseover"||e==="pointerover",z=e==="mouseout"||e==="pointerout",T&&l!==Yc&&($=l.relatedTarget||l.fromElement)&&(ba($)||$[va]))break e;if((z||T)&&(T=D.window===D?D:(T=D.ownerDocument)?T.defaultView||T.parentWindow:window,z?($=l.relatedTarget||l.toElement,z=j,$=$?ba($):null,$!==null&&(Oe=y($),ne=$.tag,$!==Oe||ne!==5&&ne!==27&&ne!==6)&&($=null)):(z=null,$=j),z!==$)){if(ne=jr,R="onMouseLeave",p="onMouseEnter",v="mouse",(e==="pointerout"||e==="pointerover")&&(ne=Tr,R="onPointerLeave",p="onPointerEnter",v="pointer"),Oe=z==null?T:dn(z),E=$==null?T:dn($),T=new ne(R,v+"leave",z,l,D),T.target=Oe,T.relatedTarget=E,R=null,ba(D)===j&&(ne=new ne(p,v+"enter",$,l,D),ne.target=E,ne.relatedTarget=Oe,R=ne),Oe=R,z&&$)t:{for(ne=uh,p=z,v=$,E=0,R=p;R;R=ne(R))E++;R=0;for(var ee=v;ee;ee=ne(ee))R++;for(;0<E-R;)p=ne(p),E--;for(;0<R-E;)v=ne(v),R--;for(;E--;){if(p===v||v!==null&&p===v.alternate){ne=p;break t}p=ne(p),v=ne(v)}ne=null}else ne=null;z!==null&&bd(B,T,z,ne,!1),$!==null&&Oe!==null&&bd(B,Oe,$,ne,!0)}}e:{if(T=j?dn(j):window,z=T.nodeName&&T.nodeName.toLowerCase(),z==="select"||z==="input"&&T.type==="file")var Te=Or;else if(Dr(T))if(Rr)Te=ym;else{Te=hm;var W=mm}else z=T.nodeName,!z||z.toLowerCase()!=="input"||T.type!=="checkbox"&&T.type!=="radio"?j&&Lc(j.elementType)&&(Te=Or):Te=gm;if(Te&&(Te=Te(e,j))){Cr(B,Te,l,D);break e}W&&W(e,T,j),e==="focusout"&&j&&T.type==="number"&&j.memoizedProps.value!=null&&qc(T,"number",T.value)}switch(W=j?dn(j):window,e){case"focusin":(Dr(W)||W.contentEditable==="true")&&(_a=W,Pc=j,Sn=null);break;case"focusout":Sn=Pc=_a=null;break;case"mousedown":ei=!0;break;case"contextmenu":case"mouseup":case"dragend":ei=!1,Xr(B,l,D);break;case"selectionchange":if(bm)break;case"keydown":case"keyup":Xr(B,l,D)}var me;if($c)e:{switch(e){case"compositionstart":var xe="onCompositionStart";break e;case"compositionend":xe="onCompositionEnd";break e;case"compositionupdate":xe="onCompositionUpdate";break e}xe=void 0}else wa?zr(e,l)&&(xe="onCompositionEnd"):e==="keydown"&&l.keyCode===229&&(xe="onCompositionStart");xe&&(wr&&l.locale!=="ko"&&(wa||xe!=="onCompositionStart"?xe==="onCompositionEnd"&&wa&&(me=Sr()):(xl=D,Zc="value"in xl?xl.value:xl.textContent,wa=!0)),W=cc(j,xe),0<W.length&&(xe=new Nr(xe,e,null,l,D),B.push({event:xe,listeners:W}),me?xe.data=me:(me=Mr(l),me!==null&&(xe.data=me)))),(me=sm?rm(e,l):om(e,l))&&(xe=cc(j,"onBeforeInput"),0<xe.length&&(W=new Nr("onBeforeInput","beforeinput",null,l,D),B.push({event:W,listeners:xe}),W.data=me)),th(B,e,j,l,D)}yd(B,t)})}function Kn(e,t,l){return{instance:e,listener:t,currentTarget:l}}function cc(e,t){for(var l=t+"Capture",a=[];e!==null;){var n=e,u=n.stateNode;if(n=n.tag,n!==5&&n!==26&&n!==27||u===null||(n=mn(e,l),n!=null&&a.unshift(Kn(e,n,u)),n=mn(e,t),n!=null&&a.push(Kn(e,n,u))),e.tag===3)return a;e=e.return}return[]}function uh(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5&&e.tag!==27);return e||null}function bd(e,t,l,a,n){for(var u=t._reactName,i=[];l!==null&&l!==a;){var f=l,h=f.alternate,j=f.stateNode;if(f=f.tag,h!==null&&h===a)break;f!==5&&f!==26&&f!==27||j===null||(h=j,n?(j=mn(l,u),j!=null&&i.unshift(Kn(l,j,h))):n||(j=mn(l,u),j!=null&&i.push(Kn(l,j,h)))),l=l.return}i.length!==0&&e.push({event:t,listeners:i})}var ch=/\r\n?/g,ih=/\u0000|\uFFFD/g;function pd(e){return(typeof e=="string"?e:""+e).replace(ch,`
`).replace(ih,"")}function xd(e,t){return t=pd(t),pd(e)===t}function Ce(e,t,l,a,n,u){switch(l){case"children":typeof a=="string"?t==="body"||t==="textarea"&&a===""||ja(e,a):(typeof a=="number"||typeof a=="bigint")&&t!=="body"&&ja(e,""+a);break;case"className":ou(e,"class",a);break;case"tabIndex":ou(e,"tabindex",a);break;case"dir":case"role":case"viewBox":case"width":case"height":ou(e,l,a);break;case"style":br(e,a,u);break;case"data":if(t!=="object"){ou(e,"data",a);break}case"src":case"href":if(a===""&&(t!=="a"||l!=="href")){e.removeAttribute(l);break}if(a==null||typeof a=="function"||typeof a=="symbol"||typeof a=="boolean"){e.removeAttribute(l);break}a=du(""+a),e.setAttribute(l,a);break;case"action":case"formAction":if(typeof a=="function"){e.setAttribute(l,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof u=="function"&&(l==="formAction"?(t!=="input"&&Ce(e,t,"name",n.name,n,null),Ce(e,t,"formEncType",n.formEncType,n,null),Ce(e,t,"formMethod",n.formMethod,n,null),Ce(e,t,"formTarget",n.formTarget,n,null)):(Ce(e,t,"encType",n.encType,n,null),Ce(e,t,"method",n.method,n,null),Ce(e,t,"target",n.target,n,null)));if(a==null||typeof a=="symbol"||typeof a=="boolean"){e.removeAttribute(l);break}a=du(""+a),e.setAttribute(l,a);break;case"onClick":a!=null&&(e.onclick=It);break;case"onScroll":a!=null&&be("scroll",e);break;case"onScrollEnd":a!=null&&be("scrollend",e);break;case"dangerouslySetInnerHTML":if(a!=null){if(typeof a!="object"||!("__html"in a))throw Error(o(61));if(l=a.__html,l!=null){if(n.children!=null)throw Error(o(60));e.innerHTML=l}}break;case"multiple":e.multiple=a&&typeof a!="function"&&typeof a!="symbol";break;case"muted":e.muted=a&&typeof a!="function"&&typeof a!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(a==null||typeof a=="function"||typeof a=="boolean"||typeof a=="symbol"){e.removeAttribute("xlink:href");break}l=du(""+a),e.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",l);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":a!=null&&typeof a!="function"&&typeof a!="symbol"?e.setAttribute(l,""+a):e.removeAttribute(l);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":a&&typeof a!="function"&&typeof a!="symbol"?e.setAttribute(l,""):e.removeAttribute(l);break;case"capture":case"download":a===!0?e.setAttribute(l,""):a!==!1&&a!=null&&typeof a!="function"&&typeof a!="symbol"?e.setAttribute(l,a):e.removeAttribute(l);break;case"cols":case"rows":case"size":case"span":a!=null&&typeof a!="function"&&typeof a!="symbol"&&!isNaN(a)&&1<=a?e.setAttribute(l,a):e.removeAttribute(l);break;case"rowSpan":case"start":a==null||typeof a=="function"||typeof a=="symbol"||isNaN(a)?e.removeAttribute(l):e.setAttribute(l,a);break;case"popover":be("beforetoggle",e),be("toggle",e),ru(e,"popover",a);break;case"xlinkActuate":Ft(e,"http://www.w3.org/1999/xlink","xlink:actuate",a);break;case"xlinkArcrole":Ft(e,"http://www.w3.org/1999/xlink","xlink:arcrole",a);break;case"xlinkRole":Ft(e,"http://www.w3.org/1999/xlink","xlink:role",a);break;case"xlinkShow":Ft(e,"http://www.w3.org/1999/xlink","xlink:show",a);break;case"xlinkTitle":Ft(e,"http://www.w3.org/1999/xlink","xlink:title",a);break;case"xlinkType":Ft(e,"http://www.w3.org/1999/xlink","xlink:type",a);break;case"xmlBase":Ft(e,"http://www.w3.org/XML/1998/namespace","xml:base",a);break;case"xmlLang":Ft(e,"http://www.w3.org/XML/1998/namespace","xml:lang",a);break;case"xmlSpace":Ft(e,"http://www.w3.org/XML/1998/namespace","xml:space",a);break;case"is":ru(e,"is",a);break;case"innerText":case"textContent":break;default:(!(2<l.length)||l[0]!=="o"&&l[0]!=="O"||l[1]!=="n"&&l[1]!=="N")&&(l=U0.get(l)||l,ru(e,l,a))}}function Ts(e,t,l,a,n,u){switch(l){case"style":br(e,a,u);break;case"dangerouslySetInnerHTML":if(a!=null){if(typeof a!="object"||!("__html"in a))throw Error(o(61));if(l=a.__html,l!=null){if(n.children!=null)throw Error(o(60));e.innerHTML=l}}break;case"children":typeof a=="string"?ja(e,a):(typeof a=="number"||typeof a=="bigint")&&ja(e,""+a);break;case"onScroll":a!=null&&be("scroll",e);break;case"onScrollEnd":a!=null&&be("scrollend",e);break;case"onClick":a!=null&&(e.onclick=It);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!rr.hasOwnProperty(l))e:{if(l[0]==="o"&&l[1]==="n"&&(n=l.endsWith("Capture"),t=l.slice(2,n?l.length-7:void 0),u=e[dt]||null,u=u!=null?u[l]:null,typeof u=="function"&&e.removeEventListener(t,u,n),typeof a=="function")){typeof u!="function"&&u!==null&&(l in e?e[l]=null:e.hasAttribute(l)&&e.removeAttribute(l)),e.addEventListener(t,a,n);break e}l in e?e[l]=a:a===!0?e.setAttribute(l,""):ru(e,l,a)}}}function nt(e,t,l){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":be("error",e),be("load",e);var a=!1,n=!1,u;for(u in l)if(l.hasOwnProperty(u)){var i=l[u];if(i!=null)switch(u){case"src":a=!0;break;case"srcSet":n=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(o(137,t));default:Ce(e,t,u,i,l,null)}}n&&Ce(e,t,"srcSet",l.srcSet,l,null),a&&Ce(e,t,"src",l.src,l,null);return;case"input":be("invalid",e);var f=u=i=n=null,h=null,j=null;for(a in l)if(l.hasOwnProperty(a)){var D=l[a];if(D!=null)switch(a){case"name":n=D;break;case"type":i=D;break;case"checked":h=D;break;case"defaultChecked":j=D;break;case"value":u=D;break;case"defaultValue":f=D;break;case"children":case"dangerouslySetInnerHTML":if(D!=null)throw Error(o(137,t));break;default:Ce(e,t,a,D,l,null)}}hr(e,u,f,h,j,i,n,!1);return;case"select":be("invalid",e),a=i=u=null;for(n in l)if(l.hasOwnProperty(n)&&(f=l[n],f!=null))switch(n){case"value":u=f;break;case"defaultValue":i=f;break;case"multiple":a=f;default:Ce(e,t,n,f,l,null)}t=u,l=i,e.multiple=!!a,t!=null?Ea(e,!!a,t,!1):l!=null&&Ea(e,!!a,l,!0);return;case"textarea":be("invalid",e),u=n=a=null;for(i in l)if(l.hasOwnProperty(i)&&(f=l[i],f!=null))switch(i){case"value":a=f;break;case"defaultValue":n=f;break;case"children":u=f;break;case"dangerouslySetInnerHTML":if(f!=null)throw Error(o(91));break;default:Ce(e,t,i,f,l,null)}yr(e,a,n,u);return;case"option":for(h in l)if(l.hasOwnProperty(h)&&(a=l[h],a!=null))switch(h){case"selected":e.selected=a&&typeof a!="function"&&typeof a!="symbol";break;default:Ce(e,t,h,a,l,null)}return;case"dialog":be("beforetoggle",e),be("toggle",e),be("cancel",e),be("close",e);break;case"iframe":case"object":be("load",e);break;case"video":case"audio":for(a=0;a<Vn.length;a++)be(Vn[a],e);break;case"image":be("error",e),be("load",e);break;case"details":be("toggle",e);break;case"embed":case"source":case"link":be("error",e),be("load",e);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(j in l)if(l.hasOwnProperty(j)&&(a=l[j],a!=null))switch(j){case"children":case"dangerouslySetInnerHTML":throw Error(o(137,t));default:Ce(e,t,j,a,l,null)}return;default:if(Lc(t)){for(D in l)l.hasOwnProperty(D)&&(a=l[D],a!==void 0&&Ts(e,t,D,a,l,void 0));return}}for(f in l)l.hasOwnProperty(f)&&(a=l[f],a!=null&&Ce(e,t,f,a,l,null))}function sh(e,t,l,a){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var n=null,u=null,i=null,f=null,h=null,j=null,D=null;for(z in l){var B=l[z];if(l.hasOwnProperty(z)&&B!=null)switch(z){case"checked":break;case"value":break;case"defaultValue":h=B;default:a.hasOwnProperty(z)||Ce(e,t,z,null,a,B)}}for(var T in a){var z=a[T];if(B=l[T],a.hasOwnProperty(T)&&(z!=null||B!=null))switch(T){case"type":u=z;break;case"name":n=z;break;case"checked":j=z;break;case"defaultChecked":D=z;break;case"value":i=z;break;case"defaultValue":f=z;break;case"children":case"dangerouslySetInnerHTML":if(z!=null)throw Error(o(137,t));break;default:z!==B&&Ce(e,t,T,z,a,B)}}Hc(e,i,f,h,j,D,u,n);return;case"select":z=i=f=T=null;for(u in l)if(h=l[u],l.hasOwnProperty(u)&&h!=null)switch(u){case"value":break;case"multiple":z=h;default:a.hasOwnProperty(u)||Ce(e,t,u,null,a,h)}for(n in a)if(u=a[n],h=l[n],a.hasOwnProperty(n)&&(u!=null||h!=null))switch(n){case"value":T=u;break;case"defaultValue":f=u;break;case"multiple":i=u;default:u!==h&&Ce(e,t,n,u,a,h)}t=f,l=i,a=z,T!=null?Ea(e,!!l,T,!1):!!a!=!!l&&(t!=null?Ea(e,!!l,t,!0):Ea(e,!!l,l?[]:"",!1));return;case"textarea":z=T=null;for(f in l)if(n=l[f],l.hasOwnProperty(f)&&n!=null&&!a.hasOwnProperty(f))switch(f){case"value":break;case"children":break;default:Ce(e,t,f,null,a,n)}for(i in a)if(n=a[i],u=l[i],a.hasOwnProperty(i)&&(n!=null||u!=null))switch(i){case"value":T=n;break;case"defaultValue":z=n;break;case"children":break;case"dangerouslySetInnerHTML":if(n!=null)throw Error(o(91));break;default:n!==u&&Ce(e,t,i,n,a,u)}gr(e,T,z);return;case"option":for(var $ in l)if(T=l[$],l.hasOwnProperty($)&&T!=null&&!a.hasOwnProperty($))switch($){case"selected":e.selected=!1;break;default:Ce(e,t,$,null,a,T)}for(h in a)if(T=a[h],z=l[h],a.hasOwnProperty(h)&&T!==z&&(T!=null||z!=null))switch(h){case"selected":e.selected=T&&typeof T!="function"&&typeof T!="symbol";break;default:Ce(e,t,h,T,a,z)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var ne in l)T=l[ne],l.hasOwnProperty(ne)&&T!=null&&!a.hasOwnProperty(ne)&&Ce(e,t,ne,null,a,T);for(j in a)if(T=a[j],z=l[j],a.hasOwnProperty(j)&&T!==z&&(T!=null||z!=null))switch(j){case"children":case"dangerouslySetInnerHTML":if(T!=null)throw Error(o(137,t));break;default:Ce(e,t,j,T,a,z)}return;default:if(Lc(t)){for(var Oe in l)T=l[Oe],l.hasOwnProperty(Oe)&&T!==void 0&&!a.hasOwnProperty(Oe)&&Ts(e,t,Oe,void 0,a,T);for(D in a)T=a[D],z=l[D],!a.hasOwnProperty(D)||T===z||T===void 0&&z===void 0||Ts(e,t,D,T,a,z);return}}for(var p in l)T=l[p],l.hasOwnProperty(p)&&T!=null&&!a.hasOwnProperty(p)&&Ce(e,t,p,null,a,T);for(B in a)T=a[B],z=l[B],!a.hasOwnProperty(B)||T===z||T==null&&z==null||Ce(e,t,B,T,a,z)}function Sd(e){switch(e){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function rh(){if(typeof performance.getEntriesByType=="function"){for(var e=0,t=0,l=performance.getEntriesByType("resource"),a=0;a<l.length;a++){var n=l[a],u=n.transferSize,i=n.initiatorType,f=n.duration;if(u&&f&&Sd(i)){for(i=0,f=n.responseEnd,a+=1;a<l.length;a++){var h=l[a],j=h.startTime;if(j>f)break;var D=h.transferSize,B=h.initiatorType;D&&Sd(B)&&(h=h.responseEnd,i+=D*(h<f?1:(f-j)/(h-j)))}if(--a,t+=8*(u+i)/(n.duration/1e3),e++,10<e)break}}if(0<e)return t/e/1e6}return navigator.connection&&(e=navigator.connection.downlink,typeof e=="number")?e:5}var ws=null,_s=null;function ic(e){return e.nodeType===9?e:e.ownerDocument}function Ed(e){switch(e){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function jd(e,t){if(e===0)switch(t){case"svg":return 1;case"math":return 2;default:return 0}return e===1&&t==="foreignObject"?0:e}function As(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.children=="bigint"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var zs=null;function oh(){var e=window.event;return e&&e.type==="popstate"?e===zs?!1:(zs=e,!0):(zs=null,!1)}var Nd=typeof setTimeout=="function"?setTimeout:void 0,fh=typeof clearTimeout=="function"?clearTimeout:void 0,Td=typeof Promise=="function"?Promise:void 0,dh=typeof queueMicrotask=="function"?queueMicrotask:typeof Td<"u"?function(e){return Td.resolve(null).then(e).catch(mh)}:Nd;function mh(e){setTimeout(function(){throw e})}function Hl(e){return e==="head"}function wd(e,t){var l=t,a=0;do{var n=l.nextSibling;if(e.removeChild(l),n&&n.nodeType===8)if(l=n.data,l==="/$"||l==="/&"){if(a===0){e.removeChild(n),en(t);return}a--}else if(l==="$"||l==="$?"||l==="$~"||l==="$!"||l==="&")a++;else if(l==="html")kn(e.ownerDocument.documentElement);else if(l==="head"){l=e.ownerDocument.head,kn(l);for(var u=l.firstChild;u;){var i=u.nextSibling,f=u.nodeName;u[fn]||f==="SCRIPT"||f==="STYLE"||f==="LINK"&&u.rel.toLowerCase()==="stylesheet"||l.removeChild(u),u=i}}else l==="body"&&kn(e.ownerDocument.body);l=n}while(l);en(t)}function _d(e,t){var l=e;e=0;do{var a=l.nextSibling;if(l.nodeType===1?t?(l._stashedDisplay=l.style.display,l.style.display="none"):(l.style.display=l._stashedDisplay||"",l.getAttribute("style")===""&&l.removeAttribute("style")):l.nodeType===3&&(t?(l._stashedText=l.nodeValue,l.nodeValue=""):l.nodeValue=l._stashedText||""),a&&a.nodeType===8)if(l=a.data,l==="/$"){if(e===0)break;e--}else l!=="$"&&l!=="$?"&&l!=="$~"&&l!=="$!"||e++;l=a}while(l)}function Ms(e){var t=e.firstChild;for(t&&t.nodeType===10&&(t=t.nextSibling);t;){var l=t;switch(t=t.nextSibling,l.nodeName){case"HTML":case"HEAD":case"BODY":Ms(l),Uc(l);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(l.rel.toLowerCase()==="stylesheet")continue}e.removeChild(l)}}function hh(e,t,l,a){for(;e.nodeType===1;){var n=l;if(e.nodeName.toLowerCase()!==t.toLowerCase()){if(!a&&(e.nodeName!=="INPUT"||e.type!=="hidden"))break}else if(a){if(!e[fn])switch(t){case"meta":if(!e.hasAttribute("itemprop"))break;return e;case"link":if(u=e.getAttribute("rel"),u==="stylesheet"&&e.hasAttribute("data-precedence"))break;if(u!==n.rel||e.getAttribute("href")!==(n.href==null||n.href===""?null:n.href)||e.getAttribute("crossorigin")!==(n.crossOrigin==null?null:n.crossOrigin)||e.getAttribute("title")!==(n.title==null?null:n.title))break;return e;case"style":if(e.hasAttribute("data-precedence"))break;return e;case"script":if(u=e.getAttribute("src"),(u!==(n.src==null?null:n.src)||e.getAttribute("type")!==(n.type==null?null:n.type)||e.getAttribute("crossorigin")!==(n.crossOrigin==null?null:n.crossOrigin))&&u&&e.hasAttribute("async")&&!e.hasAttribute("itemprop"))break;return e;default:return e}}else if(t==="input"&&e.type==="hidden"){var u=n.name==null?null:""+n.name;if(n.type==="hidden"&&e.getAttribute("name")===u)return e}else return e;if(e=Bt(e.nextSibling),e===null)break}return null}function gh(e,t,l){if(t==="")return null;for(;e.nodeType!==3;)if((e.nodeType!==1||e.nodeName!=="INPUT"||e.type!=="hidden")&&!l||(e=Bt(e.nextSibling),e===null))return null;return e}function Ad(e,t){for(;e.nodeType!==8;)if((e.nodeType!==1||e.nodeName!=="INPUT"||e.type!=="hidden")&&!t||(e=Bt(e.nextSibling),e===null))return null;return e}function Ds(e){return e.data==="$?"||e.data==="$~"}function Cs(e){return e.data==="$!"||e.data==="$?"&&e.ownerDocument.readyState!=="loading"}function yh(e,t){var l=e.ownerDocument;if(e.data==="$~")e._reactRetry=t;else if(e.data!=="$?"||l.readyState!=="loading")t();else{var a=function(){t(),l.removeEventListener("DOMContentLoaded",a)};l.addEventListener("DOMContentLoaded",a),e._reactRetry=a}}function Bt(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?"||t==="$~"||t==="&"||t==="F!"||t==="F")break;if(t==="/$"||t==="/&")return null}}return e}var Os=null;function zd(e){e=e.nextSibling;for(var t=0;e;){if(e.nodeType===8){var l=e.data;if(l==="/$"||l==="/&"){if(t===0)return Bt(e.nextSibling);t--}else l!=="$"&&l!=="$!"&&l!=="$?"&&l!=="$~"&&l!=="&"||t++}e=e.nextSibling}return null}function Md(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var l=e.data;if(l==="$"||l==="$!"||l==="$?"||l==="$~"||l==="&"){if(t===0)return e;t--}else l!=="/$"&&l!=="/&"||t++}e=e.previousSibling}return null}function Dd(e,t,l){switch(t=ic(l),e){case"html":if(e=t.documentElement,!e)throw Error(o(452));return e;case"head":if(e=t.head,!e)throw Error(o(453));return e;case"body":if(e=t.body,!e)throw Error(o(454));return e;default:throw Error(o(451))}}function kn(e){for(var t=e.attributes;t.length;)e.removeAttributeNode(t[0]);Uc(e)}var Ht=new Map,Cd=new Set;function sc(e){return typeof e.getRootNode=="function"?e.getRootNode():e.nodeType===9?e:e.ownerDocument}var hl=O.d;O.d={f:vh,r:bh,D:ph,C:xh,L:Sh,m:Eh,X:Nh,S:jh,M:Th};function vh(){var e=hl.f(),t=Pu();return e||t}function bh(e){var t=pa(e);t!==null&&t.tag===5&&t.type==="form"?Jo(t):hl.r(e)}var Fa=typeof document>"u"?null:document;function Od(e,t,l){var a=Fa;if(a&&typeof t=="string"&&t){var n=zt(t);n='link[rel="'+e+'"][href="'+n+'"]',typeof l=="string"&&(n+='[crossorigin="'+l+'"]'),Cd.has(n)||(Cd.add(n),e={rel:e,crossOrigin:l,href:t},a.querySelector(n)===null&&(t=a.createElement("link"),nt(t,"link",e),Ie(t),a.head.appendChild(t)))}}function ph(e){hl.D(e),Od("dns-prefetch",e,null)}function xh(e,t){hl.C(e,t),Od("preconnect",e,t)}function Sh(e,t,l){hl.L(e,t,l);var a=Fa;if(a&&e&&t){var n='link[rel="preload"][as="'+zt(t)+'"]';t==="image"&&l&&l.imageSrcSet?(n+='[imagesrcset="'+zt(l.imageSrcSet)+'"]',typeof l.imageSizes=="string"&&(n+='[imagesizes="'+zt(l.imageSizes)+'"]')):n+='[href="'+zt(e)+'"]';var u=n;switch(t){case"style":u=Ia(e);break;case"script":u=Pa(e)}Ht.has(u)||(e=U({rel:"preload",href:t==="image"&&l&&l.imageSrcSet?void 0:e,as:t},l),Ht.set(u,e),a.querySelector(n)!==null||t==="style"&&a.querySelector(Jn(u))||t==="script"&&a.querySelector($n(u))||(t=a.createElement("link"),nt(t,"link",e),Ie(t),a.head.appendChild(t)))}}function Eh(e,t){hl.m(e,t);var l=Fa;if(l&&e){var a=t&&typeof t.as=="string"?t.as:"script",n='link[rel="modulepreload"][as="'+zt(a)+'"][href="'+zt(e)+'"]',u=n;switch(a){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":u=Pa(e)}if(!Ht.has(u)&&(e=U({rel:"modulepreload",href:e},t),Ht.set(u,e),l.querySelector(n)===null)){switch(a){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(l.querySelector($n(u)))return}a=l.createElement("link"),nt(a,"link",e),Ie(a),l.head.appendChild(a)}}}function jh(e,t,l){hl.S(e,t,l);var a=Fa;if(a&&e){var n=xa(a).hoistableStyles,u=Ia(e);t=t||"default";var i=n.get(u);if(!i){var f={loading:0,preload:null};if(i=a.querySelector(Jn(u)))f.loading=5;else{e=U({rel:"stylesheet",href:e,"data-precedence":t},l),(l=Ht.get(u))&&Rs(e,l);var h=i=a.createElement("link");Ie(h),nt(h,"link",e),h._p=new Promise(function(j,D){h.onload=j,h.onerror=D}),h.addEventListener("load",function(){f.loading|=1}),h.addEventListener("error",function(){f.loading|=2}),f.loading|=4,rc(i,t,a)}i={type:"stylesheet",instance:i,count:1,state:f},n.set(u,i)}}}function Nh(e,t){hl.X(e,t);var l=Fa;if(l&&e){var a=xa(l).hoistableScripts,n=Pa(e),u=a.get(n);u||(u=l.querySelector($n(n)),u||(e=U({src:e,async:!0},t),(t=Ht.get(n))&&Us(e,t),u=l.createElement("script"),Ie(u),nt(u,"link",e),l.head.appendChild(u)),u={type:"script",instance:u,count:1,state:null},a.set(n,u))}}function Th(e,t){hl.M(e,t);var l=Fa;if(l&&e){var a=xa(l).hoistableScripts,n=Pa(e),u=a.get(n);u||(u=l.querySelector($n(n)),u||(e=U({src:e,async:!0,type:"module"},t),(t=Ht.get(n))&&Us(e,t),u=l.createElement("script"),Ie(u),nt(u,"link",e),l.head.appendChild(u)),u={type:"script",instance:u,count:1,state:null},a.set(n,u))}}function Rd(e,t,l,a){var n=(n=le.current)?sc(n):null;if(!n)throw Error(o(446));switch(e){case"meta":case"title":return null;case"style":return typeof l.precedence=="string"&&typeof l.href=="string"?(t=Ia(l.href),l=xa(n).hoistableStyles,a=l.get(t),a||(a={type:"style",instance:null,count:0,state:null},l.set(t,a)),a):{type:"void",instance:null,count:0,state:null};case"link":if(l.rel==="stylesheet"&&typeof l.href=="string"&&typeof l.precedence=="string"){e=Ia(l.href);var u=xa(n).hoistableStyles,i=u.get(e);if(i||(n=n.ownerDocument||n,i={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},u.set(e,i),(u=n.querySelector(Jn(e)))&&!u._p&&(i.instance=u,i.state.loading=5),Ht.has(e)||(l={rel:"preload",as:"style",href:l.href,crossOrigin:l.crossOrigin,integrity:l.integrity,media:l.media,hrefLang:l.hrefLang,referrerPolicy:l.referrerPolicy},Ht.set(e,l),u||wh(n,e,l,i.state))),t&&a===null)throw Error(o(528,""));return i}if(t&&a!==null)throw Error(o(529,""));return null;case"script":return t=l.async,l=l.src,typeof l=="string"&&t&&typeof t!="function"&&typeof t!="symbol"?(t=Pa(l),l=xa(n).hoistableScripts,a=l.get(t),a||(a={type:"script",instance:null,count:0,state:null},l.set(t,a)),a):{type:"void",instance:null,count:0,state:null};default:throw Error(o(444,e))}}function Ia(e){return'href="'+zt(e)+'"'}function Jn(e){return'link[rel="stylesheet"]['+e+"]"}function Ud(e){return U({},e,{"data-precedence":e.precedence,precedence:null})}function wh(e,t,l,a){e.querySelector('link[rel="preload"][as="style"]['+t+"]")?a.loading=1:(t=e.createElement("link"),a.preload=t,t.addEventListener("load",function(){return a.loading|=1}),t.addEventListener("error",function(){return a.loading|=2}),nt(t,"link",l),Ie(t),e.head.appendChild(t))}function Pa(e){return'[src="'+zt(e)+'"]'}function $n(e){return"script[async]"+e}function Bd(e,t,l){if(t.count++,t.instance===null)switch(t.type){case"style":var a=e.querySelector('style[data-href~="'+zt(l.href)+'"]');if(a)return t.instance=a,Ie(a),a;var n=U({},l,{"data-href":l.href,"data-precedence":l.precedence,href:null,precedence:null});return a=(e.ownerDocument||e).createElement("style"),Ie(a),nt(a,"style",n),rc(a,l.precedence,e),t.instance=a;case"stylesheet":n=Ia(l.href);var u=e.querySelector(Jn(n));if(u)return t.state.loading|=4,t.instance=u,Ie(u),u;a=Ud(l),(n=Ht.get(n))&&Rs(a,n),u=(e.ownerDocument||e).createElement("link"),Ie(u);var i=u;return i._p=new Promise(function(f,h){i.onload=f,i.onerror=h}),nt(u,"link",a),t.state.loading|=4,rc(u,l.precedence,e),t.instance=u;case"script":return u=Pa(l.src),(n=e.querySelector($n(u)))?(t.instance=n,Ie(n),n):(a=l,(n=Ht.get(u))&&(a=U({},l),Us(a,n)),e=e.ownerDocument||e,n=e.createElement("script"),Ie(n),nt(n,"link",a),e.head.appendChild(n),t.instance=n);case"void":return null;default:throw Error(o(443,t.type))}else t.type==="stylesheet"&&(t.state.loading&4)===0&&(a=t.instance,t.state.loading|=4,rc(a,l.precedence,e));return t.instance}function rc(e,t,l){for(var a=l.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),n=a.length?a[a.length-1]:null,u=n,i=0;i<a.length;i++){var f=a[i];if(f.dataset.precedence===t)u=f;else if(u!==n)break}u?u.parentNode.insertBefore(e,u.nextSibling):(t=l.nodeType===9?l.head:l,t.insertBefore(e,t.firstChild))}function Rs(e,t){e.crossOrigin==null&&(e.crossOrigin=t.crossOrigin),e.referrerPolicy==null&&(e.referrerPolicy=t.referrerPolicy),e.title==null&&(e.title=t.title)}function Us(e,t){e.crossOrigin==null&&(e.crossOrigin=t.crossOrigin),e.referrerPolicy==null&&(e.referrerPolicy=t.referrerPolicy),e.integrity==null&&(e.integrity=t.integrity)}var oc=null;function Hd(e,t,l){if(oc===null){var a=new Map,n=oc=new Map;n.set(l,a)}else n=oc,a=n.get(l),a||(a=new Map,n.set(l,a));if(a.has(e))return a;for(a.set(e,null),l=l.getElementsByTagName(e),n=0;n<l.length;n++){var u=l[n];if(!(u[fn]||u[et]||e==="link"&&u.getAttribute("rel")==="stylesheet")&&u.namespaceURI!=="http://www.w3.org/2000/svg"){var i=u.getAttribute(t)||"";i=e+i;var f=a.get(i);f?f.push(u):a.set(i,[u])}}return a}function qd(e,t,l){e=e.ownerDocument||e,e.head.insertBefore(l,t==="title"?e.querySelector("head > title"):null)}function _h(e,t,l){if(l===1||t.itemProp!=null)return!1;switch(e){case"meta":case"title":return!0;case"style":if(typeof t.precedence!="string"||typeof t.href!="string"||t.href==="")break;return!0;case"link":if(typeof t.rel!="string"||typeof t.href!="string"||t.href===""||t.onLoad||t.onError)break;switch(t.rel){case"stylesheet":return e=t.disabled,typeof t.precedence=="string"&&e==null;default:return!0}case"script":if(t.async&&typeof t.async!="function"&&typeof t.async!="symbol"&&!t.onLoad&&!t.onError&&t.src&&typeof t.src=="string")return!0}return!1}function Ld(e){return!(e.type==="stylesheet"&&(e.state.loading&3)===0)}function Ah(e,t,l,a){if(l.type==="stylesheet"&&(typeof a.media!="string"||matchMedia(a.media).matches!==!1)&&(l.state.loading&4)===0){if(l.instance===null){var n=Ia(a.href),u=t.querySelector(Jn(n));if(u){t=u._p,t!==null&&typeof t=="object"&&typeof t.then=="function"&&(e.count++,e=fc.bind(e),t.then(e,e)),l.state.loading|=4,l.instance=u,Ie(u);return}u=t.ownerDocument||t,a=Ud(a),(n=Ht.get(n))&&Rs(a,n),u=u.createElement("link"),Ie(u);var i=u;i._p=new Promise(function(f,h){i.onload=f,i.onerror=h}),nt(u,"link",a),l.instance=u}e.stylesheets===null&&(e.stylesheets=new Map),e.stylesheets.set(l,t),(t=l.state.preload)&&(l.state.loading&3)===0&&(e.count++,l=fc.bind(e),t.addEventListener("load",l),t.addEventListener("error",l))}}var Bs=0;function zh(e,t){return e.stylesheets&&e.count===0&&mc(e,e.stylesheets),0<e.count||0<e.imgCount?function(l){var a=setTimeout(function(){if(e.stylesheets&&mc(e,e.stylesheets),e.unsuspend){var u=e.unsuspend;e.unsuspend=null,u()}},6e4+t);0<e.imgBytes&&Bs===0&&(Bs=62500*rh());var n=setTimeout(function(){if(e.waitingForImages=!1,e.count===0&&(e.stylesheets&&mc(e,e.stylesheets),e.unsuspend)){var u=e.unsuspend;e.unsuspend=null,u()}},(e.imgBytes>Bs?50:800)+t);return e.unsuspend=l,function(){e.unsuspend=null,clearTimeout(a),clearTimeout(n)}}:null}function fc(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)mc(this,this.stylesheets);else if(this.unsuspend){var e=this.unsuspend;this.unsuspend=null,e()}}}var dc=null;function mc(e,t){e.stylesheets=null,e.unsuspend!==null&&(e.count++,dc=new Map,t.forEach(Mh,e),dc=null,fc.call(e))}function Mh(e,t){if(!(t.state.loading&4)){var l=dc.get(e);if(l)var a=l.get(null);else{l=new Map,dc.set(e,l);for(var n=e.querySelectorAll("link[data-precedence],style[data-precedence]"),u=0;u<n.length;u++){var i=n[u];(i.nodeName==="LINK"||i.getAttribute("media")!=="not all")&&(l.set(i.dataset.precedence,i),a=i)}a&&l.set(null,a)}n=t.instance,i=n.getAttribute("data-precedence"),u=l.get(i)||a,u===a&&l.set(null,n),l.set(i,n),this.count++,a=fc.bind(this),n.addEventListener("load",a),n.addEventListener("error",a),u?u.parentNode.insertBefore(n,u.nextSibling):(e=e.nodeType===9?e.head:e,e.insertBefore(n,e.firstChild)),t.state.loading|=4}}var Wn={$$typeof:I,Provider:null,Consumer:null,_currentValue:V,_currentValue2:V,_threadCount:0};function Dh(e,t,l,a,n,u,i,f,h){this.tag=1,this.containerInfo=e,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Vt(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Vt(0),this.hiddenUpdates=Vt(null),this.identifierPrefix=a,this.onUncaughtError=n,this.onCaughtError=u,this.onRecoverableError=i,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=h,this.incompleteTransitions=new Map}function Yd(e,t,l,a,n,u,i,f,h,j,D,B){return e=new Dh(e,t,l,i,h,j,D,B,f),t=1,u===!0&&(t|=24),u=St(3,null,null,t),e.current=u,u.stateNode=e,t=gi(),t.refCount++,e.pooledCache=t,t.refCount++,u.memoizedState={element:a,isDehydrated:l,cache:t},pi(u),e}function Gd(e){return e?(e=Ma,e):Ma}function Xd(e,t,l,a,n,u){n=Gd(n),a.context===null?a.context=n:a.pendingContext=n,a=wl(t),a.payload={element:l},u=u===void 0?null:u,u!==null&&(a.callback=u),l=_l(e,a,t),l!==null&&(bt(l,e,t),An(l,e,t))}function Qd(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var l=e.retryLane;e.retryLane=l!==0&&l<t?l:t}}function Hs(e,t){Qd(e,t),(e=e.alternate)&&Qd(e,t)}function Zd(e){if(e.tag===13||e.tag===31){var t=Il(e,67108864);t!==null&&bt(t,e,67108864),Hs(e,67108864)}}function Vd(e){if(e.tag===13||e.tag===31){var t=wt();t=Cc(t);var l=Il(e,t);l!==null&&bt(l,e,t),Hs(e,t)}}var hc=!0;function Ch(e,t,l,a){var n=S.T;S.T=null;var u=O.p;try{O.p=2,qs(e,t,l,a)}finally{O.p=u,S.T=n}}function Oh(e,t,l,a){var n=S.T;S.T=null;var u=O.p;try{O.p=8,qs(e,t,l,a)}finally{O.p=u,S.T=n}}function qs(e,t,l,a){if(hc){var n=Ls(a);if(n===null)Ns(e,t,a,gc,l),kd(e,a);else if(Uh(n,e,t,l,a))a.stopPropagation();else if(kd(e,a),t&4&&-1<Rh.indexOf(e)){for(;n!==null;){var u=pa(n);if(u!==null)switch(u.tag){case 3:if(u=u.stateNode,u.current.memoizedState.isDehydrated){var i=Z(u.pendingLanes);if(i!==0){var f=u;for(f.pendingLanes|=2,f.entangledLanes|=2;i;){var h=1<<31-st(i);f.entanglements[1]|=h,i&=~h}$t(u),(_e&6)===0&&(Fu=ct()+500,Zn(0))}}break;case 31:case 13:f=Il(u,2),f!==null&&bt(f,u,2),Pu(),Hs(u,2)}if(u=Ls(a),u===null&&Ns(e,t,a,gc,l),u===n)break;n=u}n!==null&&a.stopPropagation()}else Ns(e,t,a,null,l)}}function Ls(e){return e=Gc(e),Ys(e)}var gc=null;function Ys(e){if(gc=null,e=ba(e),e!==null){var t=y(e);if(t===null)e=null;else{var l=t.tag;if(l===13){if(e=x(t),e!==null)return e;e=null}else if(l===31){if(e=N(t),e!==null)return e;e=null}else if(l===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null)}}return gc=e,null}function Kd(e){switch(e){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Tc()){case cu:return 2;case iu:return 8;case ha:case Wt:return 32;case su:return 268435456;default:return 32}default:return 32}}var Gs=!1,ql=null,Ll=null,Yl=null,Fn=new Map,In=new Map,Gl=[],Rh="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function kd(e,t){switch(e){case"focusin":case"focusout":ql=null;break;case"dragenter":case"dragleave":Ll=null;break;case"mouseover":case"mouseout":Yl=null;break;case"pointerover":case"pointerout":Fn.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":In.delete(t.pointerId)}}function Pn(e,t,l,a,n,u){return e===null||e.nativeEvent!==u?(e={blockedOn:t,domEventName:l,eventSystemFlags:a,nativeEvent:u,targetContainers:[n]},t!==null&&(t=pa(t),t!==null&&Zd(t)),e):(e.eventSystemFlags|=a,t=e.targetContainers,n!==null&&t.indexOf(n)===-1&&t.push(n),e)}function Uh(e,t,l,a,n){switch(t){case"focusin":return ql=Pn(ql,e,t,l,a,n),!0;case"dragenter":return Ll=Pn(Ll,e,t,l,a,n),!0;case"mouseover":return Yl=Pn(Yl,e,t,l,a,n),!0;case"pointerover":var u=n.pointerId;return Fn.set(u,Pn(Fn.get(u)||null,e,t,l,a,n)),!0;case"gotpointercapture":return u=n.pointerId,In.set(u,Pn(In.get(u)||null,e,t,l,a,n)),!0}return!1}function Jd(e){var t=ba(e.target);if(t!==null){var l=y(t);if(l!==null){if(t=l.tag,t===13){if(t=x(l),t!==null){e.blockedOn=t,cr(e.priority,function(){Vd(l)});return}}else if(t===31){if(t=N(l),t!==null){e.blockedOn=t,cr(e.priority,function(){Vd(l)});return}}else if(t===3&&l.stateNode.current.memoizedState.isDehydrated){e.blockedOn=l.tag===3?l.stateNode.containerInfo:null;return}}}e.blockedOn=null}function yc(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var l=Ls(e.nativeEvent);if(l===null){l=e.nativeEvent;var a=new l.constructor(l.type,l);Yc=a,l.target.dispatchEvent(a),Yc=null}else return t=pa(l),t!==null&&Zd(t),e.blockedOn=l,!1;t.shift()}return!0}function $d(e,t,l){yc(e)&&l.delete(t)}function Bh(){Gs=!1,ql!==null&&yc(ql)&&(ql=null),Ll!==null&&yc(Ll)&&(Ll=null),Yl!==null&&yc(Yl)&&(Yl=null),Fn.forEach($d),In.forEach($d)}function vc(e,t){e.blockedOn===t&&(e.blockedOn=null,Gs||(Gs=!0,c.unstable_scheduleCallback(c.unstable_NormalPriority,Bh)))}var bc=null;function Wd(e){bc!==e&&(bc=e,c.unstable_scheduleCallback(c.unstable_NormalPriority,function(){bc===e&&(bc=null);for(var t=0;t<e.length;t+=3){var l=e[t],a=e[t+1],n=e[t+2];if(typeof a!="function"){if(Ys(a||l)===null)continue;break}var u=pa(l);u!==null&&(e.splice(t,3),t-=3,Li(u,{pending:!0,data:n,method:l.method,action:a},a,n))}}))}function en(e){function t(h){return vc(h,e)}ql!==null&&vc(ql,e),Ll!==null&&vc(Ll,e),Yl!==null&&vc(Yl,e),Fn.forEach(t),In.forEach(t);for(var l=0;l<Gl.length;l++){var a=Gl[l];a.blockedOn===e&&(a.blockedOn=null)}for(;0<Gl.length&&(l=Gl[0],l.blockedOn===null);)Jd(l),l.blockedOn===null&&Gl.shift();if(l=(e.ownerDocument||e).$$reactFormReplay,l!=null)for(a=0;a<l.length;a+=3){var n=l[a],u=l[a+1],i=n[dt]||null;if(typeof u=="function")i||Wd(l);else if(i){var f=null;if(u&&u.hasAttribute("formAction")){if(n=u,i=u[dt]||null)f=i.formAction;else if(Ys(n)!==null)continue}else f=i.action;typeof f=="function"?l[a+1]=f:(l.splice(a,3),a-=3),Wd(l)}}}function Fd(){function e(u){u.canIntercept&&u.info==="react-transition"&&u.intercept({handler:function(){return new Promise(function(i){return n=i})},focusReset:"manual",scroll:"manual"})}function t(){n!==null&&(n(),n=null),a||setTimeout(l,20)}function l(){if(!a&&!navigation.transition){var u=navigation.currentEntry;u&&u.url!=null&&navigation.navigate(u.url,{state:u.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var a=!1,n=null;return navigation.addEventListener("navigate",e),navigation.addEventListener("navigatesuccess",t),navigation.addEventListener("navigateerror",t),setTimeout(l,100),function(){a=!0,navigation.removeEventListener("navigate",e),navigation.removeEventListener("navigatesuccess",t),navigation.removeEventListener("navigateerror",t),n!==null&&(n(),n=null)}}}function Xs(e){this._internalRoot=e}pc.prototype.render=Xs.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(o(409));var l=t.current,a=wt();Xd(l,a,e,t,null,null)},pc.prototype.unmount=Xs.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;Xd(e.current,2,null,e,null,null),Pu(),t[va]=null}};function pc(e){this._internalRoot=e}pc.prototype.unstable_scheduleHydration=function(e){if(e){var t=ur();e={blockedOn:null,target:e,priority:t};for(var l=0;l<Gl.length&&t!==0&&t<Gl[l].priority;l++);Gl.splice(l,0,e),l===0&&Jd(e)}};var Id=r.version;if(Id!=="19.2.0")throw Error(o(527,Id,"19.2.0"));O.findDOMNode=function(e){var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(o(188)):(e=Object.keys(e).join(","),Error(o(268,e)));return e=b(t),e=e!==null?H(e):null,e=e===null?null:e.stateNode,e};var Hh={bundleType:0,version:"19.2.0",rendererPackageName:"react-dom",currentDispatcherRef:S,reconcilerVersion:"19.2.0"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var xc=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!xc.isDisabled&&xc.supportsFiber)try{Zl=xc.inject(Hh),it=xc}catch{}}return tu.createRoot=function(e,t){if(!g(e))throw Error(o(299));var l=!1,a="",n=nf,u=uf,i=cf;return t!=null&&(t.unstable_strictMode===!0&&(l=!0),t.identifierPrefix!==void 0&&(a=t.identifierPrefix),t.onUncaughtError!==void 0&&(n=t.onUncaughtError),t.onCaughtError!==void 0&&(u=t.onCaughtError),t.onRecoverableError!==void 0&&(i=t.onRecoverableError)),t=Yd(e,1,!1,null,null,l,a,null,n,u,i,Fd),e[va]=t.current,js(e),new Xs(t)},tu.hydrateRoot=function(e,t,l){if(!g(e))throw Error(o(299));var a=!1,n="",u=nf,i=uf,f=cf,h=null;return l!=null&&(l.unstable_strictMode===!0&&(a=!0),l.identifierPrefix!==void 0&&(n=l.identifierPrefix),l.onUncaughtError!==void 0&&(u=l.onUncaughtError),l.onCaughtError!==void 0&&(i=l.onCaughtError),l.onRecoverableError!==void 0&&(f=l.onRecoverableError),l.formState!==void 0&&(h=l.formState)),t=Yd(e,1,!0,t,l??null,a,n,h,u,i,f,Fd),t.context=Gd(null),l=t.current,a=wt(),a=Cc(a),n=wl(a),n.callback=null,_l(l,n,a),l=a,t.current.lanes=l,_t(t,l),$t(t),e[va]=t.current,js(e),new pc(t)},tu.version="19.2.0",tu}var s0;function $h(){if(s0)return Vs.exports;s0=1;function c(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(c)}catch(r){console.error(r)}}return c(),Vs.exports=Jh(),Vs.exports}var Wh=$h();const Fh=c=>{const r=new Map;r.set("web",{name:"web"});const d=c.CapacitorPlatforms||{currentPlatform:{name:"web"},platforms:r},o=(y,x)=>{d.platforms.set(y,x)},g=y=>{d.platforms.has(y)&&(d.currentPlatform=d.platforms.get(y))};return d.addPlatform=o,d.setPlatform=g,d},Ih=c=>c.CapacitorPlatforms=Fh(c),b0=Ih(typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});b0.addPlatform;b0.setPlatform;var an;(function(c){c.Unimplemented="UNIMPLEMENTED",c.Unavailable="UNAVAILABLE"})(an||(an={}));class $s extends Error{constructor(r,d,o){super(r),this.message=r,this.code=d,this.data=o}}const Ph=c=>{var r,d;return c?.androidBridge?"android":!((d=(r=c?.webkit)===null||r===void 0?void 0:r.messageHandlers)===null||d===void 0)&&d.bridge?"ios":"web"},eg=c=>{var r,d,o,g,y;const x=c.CapacitorCustomPlatform||null,N=c.Capacitor||{},A=N.Plugins=N.Plugins||{},b=c.CapacitorPlatforms,H=()=>x!==null?x.name:Ph(c),U=((r=b?.currentPlatform)===null||r===void 0?void 0:r.getPlatform)||H,L=()=>U()!=="web",J=((d=b?.currentPlatform)===null||d===void 0?void 0:d.isNativePlatform)||L,se=X=>{const F=de.get(X);return!!(F?.platforms.has(U())||ce(X))},ue=((o=b?.currentPlatform)===null||o===void 0?void 0:o.isPluginAvailable)||se,re=X=>{var F;return(F=N.PluginHeaders)===null||F===void 0?void 0:F.find(Ee=>Ee.name===X)},ce=((g=b?.currentPlatform)===null||g===void 0?void 0:g.getPluginHeader)||re,ie=X=>c.console.error(X),I=(X,F,Ee)=>Promise.reject(`${Ee} does not have an implementation of "${F}".`),de=new Map,ge=(X,F={})=>{const Ee=de.get(X);if(Ee)return console.warn(`Capacitor plugin "${X}" already registered. Cannot register plugins twice.`),Ee.proxy;const je=U(),Ne=ce(X);let k;const he=async()=>(!k&&je in F?k=typeof F[je]=="function"?k=await F[je]():k=F[je]:x!==null&&!k&&"web"in F&&(k=typeof F.web=="function"?k=await F.web():k=F.web),k),w=(Y,m)=>{var _,C;if(Ne){const G=Ne?.methods.find(K=>m===K.name);if(G)return G.rtype==="promise"?K=>N.nativePromise(X,m.toString(),K):(K,le)=>N.nativeCallback(X,m.toString(),K,le);if(Y)return(_=Y[m])===null||_===void 0?void 0:_.bind(Y)}else{if(Y)return(C=Y[m])===null||C===void 0?void 0:C.bind(Y);throw new $s(`"${X}" plugin is not implemented on ${je}`,an.Unimplemented)}},Q=Y=>{let m;const _=(...C)=>{const G=he().then(K=>{const le=w(K,Y);if(le){const P=le(...C);return m=P?.remove,P}else throw new $s(`"${X}.${Y}()" is not implemented on ${je}`,an.Unimplemented)});return Y==="addListener"&&(G.remove=async()=>m()),G};return _.toString=()=>`${Y.toString()}() { [capacitor code] }`,Object.defineProperty(_,"name",{value:Y,writable:!1,configurable:!1}),_},S=Q("addListener"),O=Q("removeListener"),V=(Y,m)=>{const _=S({eventName:Y},m),C=async()=>{const K=await _;O({eventName:Y,callbackId:K},m)},G=new Promise(K=>_.then(()=>K({remove:C})));return G.remove=async()=>{console.warn("Using addListener() without 'await' is deprecated."),await C()},G},q=new Proxy({},{get(Y,m){switch(m){case"$$typeof":return;case"toJSON":return()=>({});case"addListener":return Ne?V:S;case"removeListener":return O;default:return Q(m)}}});return A[X]=q,de.set(X,{name:X,proxy:q,platforms:new Set([...Object.keys(F),...Ne?[je]:[]])}),q},ae=((y=b?.currentPlatform)===null||y===void 0?void 0:y.registerPlugin)||ge;return N.convertFileSrc||(N.convertFileSrc=X=>X),N.getPlatform=U,N.handleError=ie,N.isNativePlatform=J,N.isPluginAvailable=ue,N.pluginMethodNoop=I,N.registerPlugin=ae,N.Exception=$s,N.DEBUG=!!N.DEBUG,N.isLoggingEnabled=!!N.isLoggingEnabled,N.platform=N.getPlatform(),N.isNative=N.isNativePlatform(),N},tg=c=>c.Capacitor=eg(c),yl=tg(typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{}),cn=yl.registerPlugin;yl.Plugins;class p0{constructor(r){this.listeners={},this.retainedEventArguments={},this.windowListeners={},r&&(console.warn(`Capacitor WebPlugin "${r.name}" config object was deprecated in v3 and will be removed in v4.`),this.config=r)}addListener(r,d){let o=!1;this.listeners[r]||(this.listeners[r]=[],o=!0),this.listeners[r].push(d);const y=this.windowListeners[r];y&&!y.registered&&this.addWindowListener(y),o&&this.sendRetainedArgumentsForEvent(r);const x=async()=>this.removeListener(r,d);return Promise.resolve({remove:x})}async removeAllListeners(){this.listeners={};for(const r in this.windowListeners)this.removeWindowListener(this.windowListeners[r]);this.windowListeners={}}notifyListeners(r,d,o){const g=this.listeners[r];if(!g){if(o){let y=this.retainedEventArguments[r];y||(y=[]),y.push(d),this.retainedEventArguments[r]=y}return}g.forEach(y=>y(d))}hasListeners(r){return!!this.listeners[r].length}registerWindowListener(r,d){this.windowListeners[d]={registered:!1,windowEventName:r,pluginEventName:d,handler:o=>{this.notifyListeners(d,o)}}}unimplemented(r="not implemented"){return new yl.Exception(r,an.Unimplemented)}unavailable(r="not available"){return new yl.Exception(r,an.Unavailable)}async removeListener(r,d){const o=this.listeners[r];if(!o)return;const g=o.indexOf(d);this.listeners[r].splice(g,1),this.listeners[r].length||this.removeWindowListener(this.windowListeners[r])}addWindowListener(r){window.addEventListener(r.windowEventName,r.handler),r.registered=!0}removeWindowListener(r){r&&(window.removeEventListener(r.windowEventName,r.handler),r.registered=!1)}sendRetainedArgumentsForEvent(r){const d=this.retainedEventArguments[r];d&&(delete this.retainedEventArguments[r],d.forEach(o=>{this.notifyListeners(r,o)}))}}const r0=c=>encodeURIComponent(c).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape),o0=c=>c.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent);class lg extends p0{async getCookies(){const r=document.cookie,d={};return r.split(";").forEach(o=>{if(o.length<=0)return;let[g,y]=o.replace(/=/,"CAP_COOKIE").split("CAP_COOKIE");g=o0(g).trim(),y=o0(y).trim(),d[g]=y}),d}async setCookie(r){try{const d=r0(r.key),o=r0(r.value),g=`; expires=${(r.expires||"").replace("expires=","")}`,y=(r.path||"/").replace("path=",""),x=r.url!=null&&r.url.length>0?`domain=${r.url}`:"";document.cookie=`${d}=${o||""}${g}; path=${y}; ${x};`}catch(d){return Promise.reject(d)}}async deleteCookie(r){try{document.cookie=`${r.key}=; Max-Age=0`}catch(d){return Promise.reject(d)}}async clearCookies(){try{const r=document.cookie.split(";")||[];for(const d of r)document.cookie=d.replace(/^ +/,"").replace(/=.*/,`=;expires=${new Date().toUTCString()};path=/`)}catch(r){return Promise.reject(r)}}async clearAllCookies(){try{await this.clearCookies()}catch(r){return Promise.reject(r)}}}cn("CapacitorCookies",{web:()=>new lg});const ag=async c=>new Promise((r,d)=>{const o=new FileReader;o.onload=()=>{const g=o.result;r(g.indexOf(",")>=0?g.split(",")[1]:g)},o.onerror=g=>d(g),o.readAsDataURL(c)}),ng=(c={})=>{const r=Object.keys(c);return Object.keys(c).map(g=>g.toLocaleLowerCase()).reduce((g,y,x)=>(g[y]=c[r[x]],g),{})},ug=(c,r=!0)=>c?Object.entries(c).reduce((o,g)=>{const[y,x]=g;let N,A;return Array.isArray(x)?(A="",x.forEach(b=>{N=r?encodeURIComponent(b):b,A+=`${y}=${N}&`}),A.slice(0,-1)):(N=r?encodeURIComponent(x):x,A=`${y}=${N}`),`${o}&${A}`},"").substr(1):null,cg=(c,r={})=>{const d=Object.assign({method:c.method||"GET",headers:c.headers},r),g=ng(c.headers)["content-type"]||"";if(typeof c.data=="string")d.body=c.data;else if(g.includes("application/x-www-form-urlencoded")){const y=new URLSearchParams;for(const[x,N]of Object.entries(c.data||{}))y.set(x,N);d.body=y.toString()}else if(g.includes("multipart/form-data")||c.data instanceof FormData){const y=new FormData;if(c.data instanceof FormData)c.data.forEach((N,A)=>{y.append(A,N)});else for(const N of Object.keys(c.data))y.append(N,c.data[N]);d.body=y;const x=new Headers(d.headers);x.delete("content-type"),d.headers=x}else(g.includes("application/json")||typeof c.data=="object")&&(d.body=JSON.stringify(c.data));return d};class ig extends p0{async request(r){const d=cg(r,r.webFetchExtra),o=ug(r.params,r.shouldEncodeUrlParams),g=o?`${r.url}?${o}`:r.url,y=await fetch(g,d),x=y.headers.get("content-type")||"";let{responseType:N="text"}=y.ok?r:{};x.includes("application/json")&&(N="json");let A,b;switch(N){case"arraybuffer":case"blob":b=await y.blob(),A=await ag(b);break;case"json":A=await y.json();break;case"document":case"text":default:A=await y.text()}const H={};return y.headers.forEach((U,L)=>{H[L]=U}),{data:A,headers:H,status:y.status,url:y.url}}async get(r){return this.request(Object.assign(Object.assign({},r),{method:"GET"}))}async post(r){return this.request(Object.assign(Object.assign({},r),{method:"POST"}))}async put(r){return this.request(Object.assign(Object.assign({},r),{method:"PUT"}))}async patch(r){return this.request(Object.assign(Object.assign({},r),{method:"PATCH"}))}async delete(r){return this.request(Object.assign(Object.assign({},r),{method:"DELETE"}))}}const sg=cn("CapacitorHttp",{web:()=>new ig}),rg="modulepreload",og=function(c){return"/"+c},f0={},er=function(r,d,o){let g=Promise.resolve();if(d&&d.length>0){let A=function(b){return Promise.all(b.map(H=>Promise.resolve(H).then(U=>({status:"fulfilled",value:U}),U=>({status:"rejected",reason:U}))))};document.getElementsByTagName("link");const x=document.querySelector("meta[property=csp-nonce]"),N=x?.nonce||x?.getAttribute("nonce");g=A(d.map(b=>{if(b=og(b),b in f0)return;f0[b]=!0;const H=b.endsWith(".css"),U=H?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${b}"]${U}`))return;const L=document.createElement("link");if(L.rel=H?"stylesheet":rg,H||(L.as="script"),L.crossOrigin="",L.href=b,N&&L.setAttribute("nonce",N),document.head.appendChild(L),H)return new Promise((J,se)=>{L.addEventListener("load",J),L.addEventListener("error",()=>se(new Error(`Unable to preload CSS for ${b}`)))})}))}function y(x){const N=new Event("vite:preloadError",{cancelable:!0});if(N.payload=x,window.dispatchEvent(N),!N.defaultPrevented)throw x}return g.then(x=>{for(const N of x||[])N.status==="rejected"&&y(N.reason);return r().catch(y)})},tr=cn("App",{web:()=>er(()=>import("./web-uZvVC3Zk.js"),[]).then(c=>new c.AppWeb)}),fa=c=>{if(!c)return"";let r=c.replace(/\./g," ").replace(/_/g," ").replace(/\[.*?\]/g,"").replace(/\(.*?\)/g,"").trim();const d=r.match(/\b(S\d{2}|s\d{2})\b/i);if(d){const y=r.indexOf(d[0]);r=r.substring(0,y)}const o=r.match(/\b(19\d{2}|20\d{2})\b/);if(o){const y=r.indexOf(o[0]);r=r.substring(0,y)}return["1080p","720p","2160p","4k","WEB-DL","WEBRip","BluRay","HDR","H.264","H264","x264","x265","HEVC","AAC","AC3","DTS","HDTV","DV","DoVi","SDR","BDRemux","Remux","TYMBLER","AKTEP","SOFCJ","CHDRip","HDRip","DVDRip","BDRip","CAMRip","TS","TC","DD5","DD51","DD","Atmos","v2","v3","v4","mkv","avi","mp4","rus","eng","torrent","stream","dub","sub","extended","HMAX","ATVP","AMZN","NF","DSNP","HULU","OKKO","OM"].forEach(y=>{const x=new RegExp(`\\b${y}\\b`,"gi");r=r.replace(x,"")}),r.replace(/[^\w\s\u0400-\u04FF:\-]/g,"").replace(/\s+/g," ").trim()},Ec=c=>{if(!c)return"";const r=["B","KB","MB","GB","TB"];let d=0,o=c;for(;o>=1024&&d<r.length-1;)o/=1024,d++;return`${o.toFixed(1)} ${r[d]}`},fg=c=>{if(!c||c<1024)return"";const r=c/1024;return r<1024?`${r.toFixed(0)} KB/s`:`${(r/1024).toFixed(1)} MB/s`},dg=c=>{if(!c||c<=0)return"";if(c<60)return`${c}—Å`;if(c<3600)return`${Math.floor(c/60)}–º`;const r=Math.floor(c/3600),d=Math.floor(c%3600/60);return`${r}—á ${d}–º`},mg=c=>{let r=0;for(let g=0;g<c.length;g++)r=c.charCodeAt(g)+((r<<5)-r);const d=Math.abs(r%360),o=Math.abs(r*13%360);return`linear-gradient(135deg, hsl(${d}, 70%, 20%), hsl(${o}, 80%, 15%))`},hg=c=>{if(!c||c.length===0)return{episodes:[],extras:[]};const r=[],d=[],o=/(?:s|season|^)?\s*(\d{1,2})\s*(?:e|x|episode|^)\s*(\d{1,2})/i,g=/(?:e|ep|episode)\s*(\d{1,3})/i,y=["sample","trailer","promo","featurette","extra","bonus","interview","behind the scenes"];return c.forEach(x=>{const N=x.name.toLowerCase();if(y.some(b=>N.includes(b))){d.push(x);return}const A=x.name.match(o);if(A){const b=parseInt(A[1],10),H=parseInt(A[2],10);r.push({...x,season:b,episode:H,sortKey:b*1e3+H})}else{const b=x.name.match(g);if(b){const H=parseInt(b[1],10);r.push({...x,season:1,episode:H,sortKey:1e3+H})}else d.push(x)}}),r.length===0&&d.length>0?{episodes:d.sort((x,N)=>x.name.localeCompare(N.name)),extras:[]}:(r.sort((x,N)=>x.sortKey!==N.sortKey?x.sortKey-N.sortKey:x.name.localeCompare(N.name)),d.sort((x,N)=>x.name.localeCompare(N.name)),{episodes:r,extras:d})},au=c=>{try{if(AbortSignal.timeout)return AbortSignal.timeout(c)}catch{}const r=new AbortController;return setTimeout(()=>r.abort(),c),r.signal},nn="c3bec60e67fabf42dd2202281dcbc9a7",gg="2a4a0808-81a3-40ae-b0d3-e11335ede616",yg="https://super-sea-46c7.wakiseliguluseli17713.workers.dev",vg="https://apn-latest.onrender.com",bg="https://cors.kp556.workers.dev:8443",x0="tmdb_cache_v1_",Fs="metadata_v1_",d0=300,S0=300*1e3,qt=600*1e3,ln=["imagetmdb.com","nl.imagetmdb.com","de.imagetmdb.com","pl.imagetmdb.com","lampa.byskaz.ru/tmdb/img"],E0="tmdb_image_proxy_enabled";function j0(){if(typeof window>"u")return"";const c=localStorage.getItem("serverUrl");if(c&&c.includes("://")){const r=new URL(c);if(!(yl.isNativePlatform()&&(r.hostname==="localhost"||r.hostname==="127.0.0.1")))return c.replace(/\/$/,"")}return window.location.protocol.startsWith("http")&&!yl.isNativePlatform()?window.location.origin:""}const lu={};ln.forEach(c=>{lu[c]={errors:[],banned:!1}});function pg(){const c=ln.filter(d=>!lu[d].banned),r=localStorage.getItem("tmdb_img_mirror")||"";return c.includes(r)?r:c.length>0?(localStorage.setItem("tmdb_img_mirror",c[0]),c[0]):(ln.forEach(d=>{lu[d].banned=!1}),ln[0])}function xg(c){ln.forEach(r=>{if(c&&c.includes(r)){const d=Date.now(),o=lu[r];o.errors.push(d),o.errors=o.errors.filter(g=>d-g<1e4),console.log(`[ImageMirror] ${r} errors: ${o.errors.length}`),o.errors.length>=20&&(o.banned=!0,o.errors=[],console.warn(`[ImageMirror] BANNED: ${r}`),localStorage.removeItem("tmdb_img_mirror"),ln.every(y=>lu[y].banned)&&(console.warn("[ImageMirror] üö® ALL MIRRORS BANNED! Switching to WSRV.NL Proxy Mode."),localStorage.setItem(E0,"true")))}})}function da(c,r="w342"){if(!c)return"";if(c.startsWith("http"))return c;const d=`https://image.tmdb.org/t/p/${r}${c}`,o=j0();return!yl.isNativePlatform()&&o?`${o}/api/proxy?url=${encodeURIComponent(d)}`:localStorage.getItem(E0)==="true"?`https://wsrv.nl/?url=ssl:image.tmdb.org/t/p/${r}${c}&output=webp`:`https://${pg()}/t/p/${r}${c}`}const m0=new Map;async function Sg(c){const r=m0.get(c);if(r&&Date.now()-r.timestamp<600*1e3)return r.ip;try{const d=await fetch(`https://dns.google/resolve?name=${c}&type=A`,{headers:{Accept:"application/dns-json"}});if(d.ok){const g=(await d.json()).Answer?.find(y=>y.type===1)?.data;if(g&&g!=="127.0.0.1")return m0.set(c,{ip:g,timestamp:Date.now()}),console.log(`[DoH] Resolved ${c} ‚Üí ${g}`),g}}catch(d){console.warn("[DoH] Resolution failed:",d.message)}return null}function Eg(c){const r=x0+c;try{const d=localStorage.getItem(r);if(d){const{data:o,timestamp:g,ttl:y}=JSON.parse(d);if(Date.now()-g<y)return o;localStorage.removeItem(r)}}catch{}return null}function tn(c,r,d=S0){const o=x0+c;try{localStorage.setItem(o,JSON.stringify({data:r,timestamp:Date.now(),ttl:d}))}catch(g){console.warn("[Cache] Failed to save:",g.message)}}const jg=(c,r)=>{if(!c||!r)return;const d=Fs+c.toLowerCase().trim(),o={...r,timestamp:Date.now()};try{if(localStorage.setItem(d,JSON.stringify(o)),Math.random()<.1){const g=Object.keys(localStorage).filter(y=>y.startsWith(Fs));if(g.length>d0){const y=g.map(N=>{try{const A=JSON.parse(localStorage.getItem(N));return{key:N,timestamp:A?.timestamp||0}}catch{return{key:N,timestamp:0}}});y.sort((N,A)=>N.timestamp-A.timestamp);const x=Math.ceil(d0*.2);y.slice(0,x).forEach(N=>localStorage.removeItem(N.key)),console.log(`[Metadata] LRU eviction: removed ${x} entries`)}}}catch(g){console.warn("[Metadata] Failed to save:",g)}},lr=c=>{if(!c)return null;const r=Fs+c.toLowerCase().trim();try{const d=localStorage.getItem(r);if(d)return JSON.parse(d)}catch{}return null},Ng=async c=>{if(!c)return null;const r=c.replace(/[\._]/g," ").trim(),d=lr(r);if(d)return d;try{const o=encodeURIComponent(r),g=await We(`/search/multi?query=${o}`,{searchQuery:r}),y=g.results?.find(x=>x.poster_path||x._kp_data?.posterUrlPreview);if(y){const x=g.source==="kinopoisk",N=y.poster_path||y._kp_data?.posterUrlPreview,A=y.backdrop_path,b=x?`https://wsrv.nl/?url=${encodeURIComponent(N)}&output=webp`:da(N,"w500"),H=!x&&A?da(A,"w1280"):null,U={poster:b,backdrop:H,overview:y.overview||null,rating:y.vote_average||null,year:(y.release_date||y.first_air_date||"").substring(0,4)||null,title:y.title||y.name||r,source:g.source,id:y.id};return jg(r,U),U}}catch(o){console.warn("[metadata] Resolve failed:",o)}return null},nu=c=>c.includes("?")?"&":"?";async function Tg(c){try{const r=nu(c),d=`${yg}${c}${r}api_key=${nn}&language=ru-RU`;console.log("[TMDB] Trying Custom Worker...");const o=await fetch(d,{signal:au(5e3)})}catch{}return null}async function wg(c){try{const r=nu(c),d=`https://api.themoviedb.org/3${c}${r}api_key=${nn}&language=ru-RU`,o=`${vg}/${d}`;console.log("[TMDB] Trying Lampa Proxy...");const g=await fetch(o,{signal:au(8e3)});if(g.ok){const y=await g.json();return console.log("[TMDB] ‚úÖ Lampa Proxy success"),{...y,source:"tmdb",method:"lampa_proxy"}}}catch(r){console.warn("[TMDB] Lampa Proxy failed:",r.message)}return null}async function _g(c){try{const r=nu(c),d=`https://api.themoviedb.org/3${c}${r}api_key=${nn}&language=ru-RU`,g=`${j0()}/api/proxy?url=${encodeURIComponent(d)}`;console.log("[TMDB] Trying Server Proxy:",g);const y=await fetch(g,{signal:au(8e3)});if(y.ok){const x=await y.json();return console.log("[TMDB] ‚úÖ Server Proxy success"),{...x,source:"tmdb",method:"server_proxy"}}}catch(r){console.warn("[TMDB] Server Proxy failed:",r.message)}return null}async function Ag(c){if(!yl.isNativePlatform())return null;try{const r="api.themoviedb.org",d=await Sg(r),o=nu(c);let g,y={};d?(g=`https://${d}/3${c}${o}api_key=${nn}&language=ru-RU`,y={Host:r},console.log("[TMDB] Trying CapacitorHttp + DoH...")):(g=`https://${r}/3${c}${o}api_key=${nn}&language=ru-RU`,console.log("[TMDB] Trying CapacitorHttp direct..."));const x=await sg.get({url:g,headers:y,connectTimeout:5e3,readTimeout:5e3});if(x.data)return console.log("[TMDB] ‚úÖ CapacitorHttp success"),{...x.data,source:"tmdb",method:d?"capacitor_doh":"capacitor_direct"}}catch(r){console.warn("[TMDB] CapacitorHttp failed:",r.message)}return null}async function zg(c){try{const r=nu(c),d=`https://api.themoviedb.org/3${c}${r}api_key=${nn}&language=ru-RU`,o=`https://corsproxy.io/?${encodeURIComponent(d)}`;console.log("[TMDB] Trying corsproxy.io...");const g=await fetch(o,{signal:au(6e3)});if(g.ok){const y=await g.json();return console.log("[TMDB] ‚úÖ corsproxy.io success"),{...y,source:"tmdb",method:"corsproxy"}}}catch(r){console.warn("[TMDB] corsproxy.io failed:",r.message)}return null}async function Mg(c){if(!c)return null;try{const r=`${bg}/https://kinopoiskapiunofficial.tech/api/v2.1/films/search-by-keyword?keyword=${encodeURIComponent(c)}`;console.log("[TMDB] Trying Kinopoisk fallback...");const d=await fetch(r,{headers:{"X-API-KEY":gg},signal:au(6e3)});if(d.ok){const g=((await d.json()).films||[]).map(y=>({id:y.filmId,title:y.nameRu||y.nameEn,name:y.nameRu||y.nameEn,original_title:y.nameEn,poster_path:y.posterUrlPreview,backdrop_path:null,overview:y.description||"",vote_average:y.rating||y.ratingKinopoisk,release_date:y.year?`${y.year}-01-01`:null,first_air_date:y.year?`${y.year}-01-01`:null,media_type:y.type==="TV_SERIES"?"tv":"movie",genre_ids:[],_kp_data:y}));return console.log("[TMDB] ‚úÖ Kinopoisk success"),{results:g,source:"kinopoisk",method:"kinopoisk"}}}catch(r){console.warn("[TMDB] Kinopoisk failed:",r.message)}return null}async function We(c,r={}){const{useCache:d=!0,cacheTTL:o=S0,searchQuery:g=null}=r;if(d){const N=Eg(c);if(N)return console.log("[TMDB] Cache hit for:",c.slice(0,50)),N}const y=N=>N&&(N.results?.length||N.cast?.length||N.crew?.length||N.id);let x=null;return x=await Tg(c),y(x)||(x=await wg(c),y(x))||(x=await _g(c),y(x))||(x=await Ag(c),y(x))||(x=await zg(c),y(x))||g&&(x=await Mg(g),y(x))?(d&&tn(c,x,o),x):(console.warn("[TMDB] All strategies failed for:",c),{results:[],source:"none",method:"failed"})}async function Dg(c="week",r=1){const d=`/trending/all/${c}?page=${r}`;return We(d,{cacheTTL:qt})}async function Cg(c=1){const r=`/movie/popular?page=${c}`;return We(r,{cacheTTL:qt})}async function Og(c=1){const r=`/tv/popular?page=${c}`;return We(r,{cacheTTL:qt})}async function Rg(c=1){const r=`/movie/top_rated?page=${c}`;return We(r,{cacheTTL:qt})}async function Ug(c,r="movie"){const d=`/${r}/${c}/credits?`;try{const o=await We(d,{cacheTTL:qt});return console.log("[tmdbClient] getCredits result:",o),{cast:o.cast||o.results?.cast||[],crew:o.crew||o.results?.crew||[],source:o.source,method:o.method}}catch(o){return console.error("[tmdbClient] getCredits error:",o),{cast:[],crew:[]}}}async function Bg(c,r="movie"){const d=`/${r}/${c}/videos?`;return We(d,{cacheTTL:qt})}async function Hg(c,r="movie"){const d=`/${r}/${c}/recommendations?`;return We(d,{cacheTTL:qt})}async function qg(c,r="movie"){const d=`/${r}/${c}?append_to_response=external_ids`;return We(d,{cacheTTL:qt})}async function Lg(c,r){const d=`/tv/${c}/season/${r}?`;return We(d,{cacheTTL:qt})}async function Yg(c){return We(`/person/${c}`,{cacheTTL:qt})}async function Gg(c){const r=await We(`/person/${c}/combined_credits`,{cacheTTL:qt});return r.cast&&(r.cast=r.cast.filter(d=>d.poster_path).sort((d,o)=>(o.popularity||0)-(d.popularity||0))),r}async function h0(c,r="movie",d=1){const o=`/discover/${r}?with_genres=${c}&page=${d}&sort_by=popularity.desc`;return We(o,{cacheTTL:qt})}function Is(c){return c.filter(r=>r.media_type!=="person"&&(r.poster_path||r._kp_data?.posterUrlPreview))}const un={zones:{},activeZone:"main",idMap:{},register(c,r,d=null){this.zones[c]||(this.zones[c]=new Set),this.zones[c].add(r),d&&(this.idMap[c]||(this.idMap[c]={}),this.idMap[c][d]=r)},unregister(c,r){if(this.zones[c]&&this.zones[c].delete(r),this.idMap[c]){for(const[d,o]of Object.entries(this.idMap[c]))if(o===r){delete this.idMap[c][d];break}}},focusId(c,r){if(this.idMap[c]&&this.idMap[c][r]){const d=this.idMap[c][r];if(d.offsetParent!==null&&!d.disabled)return console.log(`[SpatialNav] Focusing element with ID '${r}' in zone '${c}'`),this.activeZone=c,d.focus(),d.scrollIntoView({behavior:"smooth",block:"center"}),!0;console.warn(`[SpatialNav] Element with ID '${r}' in zone '${c}' is not visible or disabled.`)}else console.warn(`[SpatialNav] Element with ID '${r}' not found in zone '${c}'.`);return!1},setActiveZone(c){console.log(`[SpatialNav] Active Zone: ${this.activeZone} -> ${c}`),[this.activeZone,c].forEach(r=>{if(this.zones[r]){const d=this.zones[r].size;this.zones[r]=new Set(Array.from(this.zones[r]).filter(g=>document.body.contains(g)));const o=this.zones[r].size;d!==o&&console.log(`[SpatialNav] Cleaned ${d-o} stale refs from zone '${r}'`)}}),this.activeZone=c},move(c){const r=document.activeElement,d=Array.from(this.zones[this.activeZone]||[]).filter(g=>document.body.contains(g)&&g.offsetParent!==null);if(!d.length)return;if(!d.includes(r)){d[0].focus();return}const o=this.findNearest(r,d,c);o?(o.focus(),o.scrollIntoView({behavior:"smooth",block:"center"})):console.warn(`[SpatialNav] Edge reached for ${c} in zone ${this.activeZone}`)},findNearest(c,r,d){const o=c.getBoundingClientRect();let g=null,y=1/0;return r.forEach(x=>{if(x===c)return;const N=x.getBoundingClientRect();let A=!1;switch(d){case"ArrowUp":A=N.bottom<=o.top+5;break;case"ArrowDown":A=N.top>=o.bottom-5;break;case"ArrowLeft":A=N.right<=o.left+5;break;case"ArrowRight":A=N.left>=o.right-5;break}if(!A)return;const b=Math.abs(o.left+o.width/2-(N.left+N.width/2)),H=Math.abs(o.top+o.height/2-(N.top+N.height/2)),U=d==="ArrowLeft"||d==="ArrowRight"?b+H*2:H+b*2;U<y&&(y=U,g=x)}),g},recoverFocus(c,r=5){const d=c||this.activeZone,o=()=>{const g=Array.from(this.zones[d]||[]).filter(y=>document.body.contains(y)&&y.offsetParent!==null&&!y.disabled);return g.length>0?(console.log(`[SpatialNav] Recovering focus in ${d}`),this.activeZone=d,g[0].focus(),g[0].scrollIntoView({behavior:"smooth",block:"center"}),!0):(r>0&&(r--,setTimeout(o,100)),!1)};o()}},te=(c="main",r=null)=>{const d=M.useRef(null);return M.useCallback(g=>{d.current&&d.current!==g&&un.unregister(c,d.current),g&&un.register(c,g,r),d.current=g},[c,r])},Xg=c=>(M.useEffect(()=>{const r=d=>{const o=["INPUT","TEXTAREA"].includes(document.activeElement.tagName);if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(d.key)){if(o&&(d.key==="ArrowLeft"||d.key==="ArrowRight"))return;d.preventDefault(),un.move(d.key)}if(d.key==="Enter"||d.key===" "){if(o)return;d.preventDefault();const g=document.activeElement;g&&g.classList.contains("focusable")&&g.click()}if(d.key==="Escape"||d.key==="Backspace"){if(o&&d.key==="Backspace")return;c&&c()}};return window.addEventListener("keydown",r),()=>window.removeEventListener("keydown",r)},[c]),{setActiveZone:r=>un.setActiveZone(r)}),Qg=({name:c,onClick:r,progress:d,peers:o,isReady:g,size:y,downloadSpeed:x,downloaded:N,eta:A,newFilesCount:b})=>{const H=te("main"),[U,L]=M.useState(null),J=fa(c);return M.useEffect(()=>{if(!J)return;let se=!0;const ue=lr(J);return ue?.poster&&L(ue.poster),(async()=>{try{const ce=await Ng(J);se&&ce?.poster&&L(ce.poster)}catch(ce){console.warn("[Poster] Load failed:",J,ce)}})(),()=>{se=!1}},[J]),s.jsxs("button",{ref:H,onClick:r,className:`
          focusable relative group aspect-[2/3] rounded-xl overflow-hidden shadow-xl
          transition-all duration-300
          focus:scale-105 focus:ring-4 focus:ring-blue-500 focus:z-20 outline-none
          hover:scale-105
          bg-gray-800
        `,style:{background:U?void 0:mg(c),boxSizing:"border-box"},children:[U?s.jsx("img",{src:U,alt:c,className:"w-full h-full object-cover transition-opacity duration-500",loading:"lazy",decoding:"async",onError:()=>L(null)}):s.jsxs(s.Fragment,{children:[s.jsx("div",{className:"absolute -top-10 -right-10 w-32 h-32 bg-white/5 rounded-full blur-2xl pointer-events-none"}),s.jsx("div",{className:"absolute bottom-10 -left-10 w-24 h-24 bg-black/20 rounded-full blur-xl pointer-events-none"}),s.jsx("div",{className:"absolute inset-0 flex items-center justify-center p-4 text-center",children:s.jsx("h3",{className:"text-gray-100 font-bold text-lg leading-snug drop-shadow-lg line-clamp-4 font-sans tracking-wide",children:J||c})})]}),s.jsxs("div",{className:"absolute inset-0 bg-gradient-to-t from-black/90 via-transparent to-black/10 flex flex-col justify-end p-3 text-left",children:[s.jsxs("div",{className:"absolute top-2 right-2 flex gap-1",children:[b>0&&s.jsxs("span",{className:"bg-purple-500 text-white text-[10px] font-black tracking-wider px-2 py-0.5 rounded shadow-sm animate-pulse",children:["üÜï ",b," NEW"]}),g?s.jsx("span",{className:"bg-green-500 text-white text-[10px] font-black tracking-wider px-2 py-0.5 rounded shadow-sm",children:"READY"}):s.jsxs("span",{className:"bg-yellow-500 text-black text-[10px] font-black tracking-wider px-2 py-0.5 rounded shadow-sm",children:[Math.round(d*100),"%"]})]}),s.jsxs("div",{className:"text-xs text-gray-400 flex flex-col gap-1 mt-auto",children:[!g&&N>0&&s.jsxs("div",{className:"flex items-center justify-between gap-2",children:[s.jsxs("span",{className:"text-blue-400",children:[Ec(N)," / ",Ec(y)]}),A>0&&s.jsxs("span",{className:"text-yellow-400",children:["‚è± ",dg(A)]})]}),s.jsxs("div",{className:"flex items-center gap-2",children:[s.jsxs("span",{className:"flex items-center gap-1",children:[s.jsx("svg",{className:"w-3 h-3",fill:"currentColor",viewBox:"0 0 20 20",children:s.jsx("path",{d:"M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3zM6 8a2 2 0 11-4 0 2 2 0 014 0zM16 18v-3a5.972 5.972 0 00-.75-2.906A3.005 3.005 0 0119 15v3h-3zM4.75 12.094A5.973 5.973 0 004 15v3H1v-3a3 3 0 013.75-2.906z"})}),o]}),g&&y>0&&s.jsx("span",{className:"text-gray-500",children:Ec(y)}),!g&&x>0&&s.jsxs("span",{className:"text-green-400",children:["‚Üì",fg(x)]})]}),!g&&d>0&&s.jsx("div",{className:"w-full h-1.5 bg-gray-700 rounded-full overflow-hidden",children:s.jsx("div",{style:{width:`${d*100}%`},className:"h-full bg-gradient-to-r from-blue-500 to-green-500 transition-all duration-300"})})]})]})]})},Zg=({lastStateChange:c})=>{const[r,d]=M.useState(0);M.useEffect(()=>{if(!c)return;const g=setInterval(()=>{d(Math.floor((Date.now()-c)/1e3))},1e3);return()=>clearInterval(g)},[c]);const o=g=>{const y=Math.floor(g/60),x=g%60;return y>0?`${y}m ${x}s`:`${x}s`};return s.jsx("div",{className:"bg-yellow-600/90 text-yellow-100 p-4 rounded-lg mb-6 border border-yellow-500 animate-pulse mx-4",children:s.jsxs("div",{className:"flex items-center gap-3",children:[s.jsx("span",{className:"text-2xl",children:"‚ùÑÔ∏è"}),s.jsxs("div",{children:[s.jsx("div",{className:"font-bold text-lg",children:"Cooling Down"}),s.jsxs("div",{className:"text-sm opacity-90",children:["High memory usage detected. Service may be slower.",s.jsx("span",{className:"ml-2 font-mono",children:o(r)})]})]})]})})},Vg=({status:c,retryAfter:r,onRetry:d})=>{const[o,g]=M.useState(r||300);M.useEffect(()=>{if(o<=0){d();return}const b=setTimeout(()=>g(H=>H-1),1e3);return()=>clearTimeout(b)},[o,d]);const y=c==="circuit_open",x=y?"üîå":"‚ö†Ô∏è",N=y?"Storage Unavailable":"Server Error",A=y?"NFS/Storage is not responding. The server will retry automatically.":"A critical error occurred. Please wait for recovery.";return s.jsx("div",{className:"min-h-screen bg-gray-900 flex items-center justify-center p-6",children:s.jsxs("div",{className:"bg-red-900/30 border border-red-700 rounded-2xl p-8 max-w-md text-center",children:[s.jsx("div",{className:"text-6xl mb-4",children:x}),s.jsx("h1",{className:"text-2xl font-bold text-red-400 mb-2",children:N}),s.jsx("p",{className:"text-gray-300 mb-6",children:A}),s.jsx("button",{onClick:d,className:"mt-6 bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg font-bold transition-colors",children:"Retry Now"})]})})},Kg=Qh.forwardRef(({status:c,onDiagnosticsClick:r},d)=>{const g=(()=>{switch(c){case"ok":return{icon:"üü¢",text:"Server OK",color:"bg-green-900/50 border-green-700 text-green-300"};case"degraded":return{icon:"üü°",text:"High RAM",color:"bg-yellow-900/50 border-yellow-700 text-yellow-300"};case"circuit_open":return{icon:"üî¥",text:"Storage Error",color:"bg-red-900/50 border-red-700 text-red-300"};case"error":return{icon:"üî¥",text:"Server Error",color:"bg-red-900/50 border-red-700 text-red-300"};default:return{icon:"‚ö™",text:"Connecting...",color:"bg-gray-800/50 border-gray-600 text-gray-400"}}})();return s.jsxs("button",{ref:d,tabIndex:"0",onClick:r,className:`focusable px-3 py-1.5 rounded-lg border text-xs font-medium flex items-center gap-2 transition-colors hover:opacity-80 focus:bg-blue-600 focus:text-white ${g.color}`,onKeyDown:y=>{y.key==="Enter"&&r()},children:[s.jsx("span",{children:g.icon}),s.jsx("span",{children:g.text})]})}),kg=({mode:c,active:r,disabled:d,onClick:o})=>{const g=te("settings");return s.jsxs("button",{ref:g,disabled:d,onClick:o,className:`focusable flex-1 p-2 rounded-lg border text-center transition-all disabled:opacity-50 ${r?"bg-green-600 border-green-500 text-white shadow-lg":"bg-gray-800 border-gray-700 text-gray-400"}`,children:[s.jsx("div",{className:"font-bold text-xs",children:c.name}),s.jsx("div",{className:"text-[10px] opacity-70",children:c.desc})]})},Jg=({torrent:c,onClick:r})=>{const d=te("settings"),o=fa(c.name)||c.name;return s.jsxs("button",{ref:d,tabIndex:"0",onClick:()=>r(o),className:"focusable w-full text-left p-2.5 bg-gray-800 hover:bg-gray-750 rounded text-xs truncate border border-gray-700 mb-1 focus:bg-blue-600 focus:text-white transition-colors",children:["üé¨ ",o]})},$g=({serverUrl:c,onServerUrlChange:r,tmdbProxyUrl:d,onTmdbProxyUrlChange:o,torrents:g=[],onClose:y,initialTab:x="general"})=>{const[N,A]=M.useState(x),[b,H]=M.useState(localStorage.getItem("speedMode")||"balanced"),[U,L]=M.useState(!1),[J,se]=M.useState(null),[ue,re]=M.useState(!1),[ce,ie]=M.useState(null),[I,de]=M.useState(!1);M.useEffect(()=>{A(x)},[x]),M.useEffect(()=>{N==="status"&&Q()},[N]);const ge=te("settings"),ae=te("settings"),X=te("settings"),F=te("settings"),Ee=te("settings"),je=te("settings"),Ne=te("settings"),k=te("settings"),he=te("settings"),w=()=>{const q=Object.keys(localStorage).filter(Y=>Y.startsWith("tmdb_cache_")||Y.startsWith("metadata_"));q.forEach(Y=>localStorage.removeItem(Y)),alert(`–û—á–∏—â–µ–Ω–æ ${q.length} –∑–∞–ø–∏—Å–µ–π –∫—ç—à–∞. –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.`),window.location.reload()},Q=async()=>{re(!0);try{const[q,Y]=await Promise.all([fetch(`${c}/api/status`).catch(C=>({ok:!1})),fetch(`${c}/api/lag-stats`).catch(C=>({ok:!1}))]),m=q.ok?await q.json():{},_=Y.ok?await Y.json():{};se({server:m.serverStatus||"N/A",ram:_.server?.ram?.rss||"N/A",uptime:_.server?.uptime||0,lags:_.totalLags||0,active:_.server?.torrents?.active||0,frozen:_.server?.torrents?.frozen||0})}catch(q){console.error(q)}finally{re(!1)}},S=async q=>{de(!0),ie(null);const Y=encodeURIComponent(q),m="c3bec60e67fabf42dd2202281dcbc9a7",_=d||"https://super-sea-46c7.wakiseliguluseli17713.workers.dev",C="https://cors.kp556.workers.dev:8443",G=["imagetmdb.com","nl.imagetmdb.com","lampa.byskaz.ru/tmdb/img"];let K=[];const le=async(P,Re,Ae)=>{try{const Je=new AbortController,pt=setTimeout(()=>Je.abort(),1e4),ot=await fetch(Re,{signal:Je.signal});if(clearTimeout(pt),ot.ok){const vl=await ot.json(),Fe=Ae?Ae(vl):!0;K.push({name:P,status:Fe?"‚úÖ":"‚ö†Ô∏è",detail:typeof Fe=="string"?Fe:"Online"})}else K.push({name:P,status:"‚ùå",detail:`HTTP ${ot.status}`})}catch(Je){K.push({name:P,status:"‚ùå",detail:Je.name==="AbortError"?"Timeout":Je.message})}};try{await le("TMDB API (Direct)",`https://api.themoviedb.org/3/search/movie?api_key=${m}&query=${Y}`,P=>P.total_results>0),_&&await le("Custom Proxy",`${_}/3/search/movie?api_key=${m}&query=${Y}`,P=>P.total_results>0);for(const P of G)await le(`Img: ${P}`,`https://${P}/t/p/w92/8uO0gUM8aNqYLs1OsTBQiXu0fEv.jpg`,()=>!0);await le("Kinopoisk Proxy",`${C}/api/v2.1/films/search-by-keyword?keyword=${Y}`,P=>P.films?.length>0)}catch(P){K.push({name:"Critical",status:"‚ùå",detail:P.message})}finally{ie({name:q,results:K}),de(!1)}},O=q=>{const Y=Math.floor(q/3600),m=Math.floor(q%3600/60);return`${Y}h ${m}m`},V=Object.keys(localStorage).filter(q=>q.startsWith("tmdb_cache_")||q.startsWith("metadata_")).length;return s.jsx("div",{className:"fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 animate-in fade-in duration-200",children:s.jsxs("div",{className:"bg-[#1a1a1a] border border-gray-700 rounded-2xl w-full max-w-lg shadow-2xl overflow-hidden flex flex-col max-h-[85vh]",children:[s.jsxs("div",{className:"bg-gradient-to-r from-gray-800 to-gray-900 p-4 flex items-center justify-between border-b border-white/10",children:[s.jsxs("div",{className:"flex gap-2 overflow-x-auto",children:[s.jsx("button",{ref:Ee,onClick:()=>A("general"),className:`focusable text-sm font-bold px-3 py-1.5 rounded-full transition-all ${N==="general"?"bg-white/10 text-white":"text-white/50 hover:bg-white/5"}`,children:"‚öôÔ∏è –û—Å–Ω–æ–≤–Ω—ã–µ"}),s.jsx("button",{ref:je,onClick:()=>A("search"),className:`focusable text-sm font-bold px-3 py-1.5 rounded-full transition-all ${N==="search"?"bg-white/10 text-white":"text-white/50 hover:bg-white/5"}`,children:"üßπ –ü–æ–∏—Å–∫"}),s.jsx("button",{ref:Ne,onClick:()=>A("status"),className:`focusable text-sm font-bold px-3 py-1.5 rounded-full transition-all ${N==="status"?"bg-white/10 text-white":"text-white/50 hover:bg-white/5"}`,children:"üìä –°—Ç–∞—Ç—É—Å"}),s.jsx("button",{ref:k,onClick:()=>A("posters"),className:`focusable text-sm font-bold px-3 py-1.5 rounded-full transition-all ${N==="posters"?"bg-white/10 text-white":"text-white/50 hover:bg-white/5"}`,children:"üñºÔ∏è –ü–æ—Å—Ç–µ—Ä—ã"})]}),s.jsx("button",{ref:ge,onClick:y,className:"focusable text-gray-400 hover:text-white px-2 text-xl ml-2",children:"‚úï"})]}),s.jsxs("div",{className:"flex-1 overflow-y-auto p-6 custom-scrollbar pb-10",children:[N==="general"&&s.jsx("div",{className:"space-y-6 animate-fade-in",children:s.jsxs("section",{children:[s.jsx("label",{className:"text-xs font-bold text-gray-500 uppercase tracking-widest mb-3 block",children:"‚ö° –°–∫–æ—Ä–æ—Å—Ç—å –∑–∞–≥—Ä—É–∑–∫–∏"}),s.jsx("div",{className:"flex gap-2",children:[{id:"eco",name:"üå± Eco",desc:"20 peers"},{id:"balanced",name:"‚öñÔ∏è Balance",desc:"40 peers"},{id:"turbo",name:"üöÄ Turbo",desc:"65 peers"}].map(q=>s.jsx(kg,{mode:q,active:b===q.id,disabled:U,onClick:async()=>{L(!0);try{(await fetch(`${c||""}/api/speed-mode`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({mode:q.id})})).ok&&(H(q.id),localStorage.setItem("speedMode",q.id))}catch(Y){console.error(Y)}finally{L(!1)}}},q.id))})]})}),N==="search"&&s.jsxs("div",{className:"space-y-6 animate-fade-in",children:[s.jsxs("section",{children:[s.jsx("label",{className:"text-xs font-bold text-gray-500 uppercase tracking-widest mb-2 block",children:"üõ°Ô∏è TMDB Proxy"}),s.jsx("input",{ref:X,tabIndex:"0",value:d,onChange:q=>o(q.target.value,!1),onBlur:q=>o(q.target.value,!0),className:"focusable w-full bg-gray-800 text-sm text-white px-4 py-3 rounded-lg border border-gray-700 focus:border-purple-500 outline-none transition-colors",placeholder:"–ü—É—Å—Ç–æ –¥–ª—è –∞–≤—Ç–æ-–≤—ã–±–æ—Ä–∞"}),s.jsx("p",{className:"text-[10px] text-gray-500 mt-2 italic",children:"–î–ª—è –æ–±—Ö–æ–¥–∞ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫ –∑–∞–≥—Ä—É–∑–∫–∏ –æ–±–ª–æ–∂–µ–∫."})]}),s.jsx("section",{className:"pt-4 border-t border-white/5",children:s.jsxs("button",{ref:F,onClick:w,className:"focusable w-full bg-red-900/10 text-red-400 p-4 rounded-xl border border-red-900/30 text-sm flex items-center justify-center gap-3 hover:bg-red-900/20 transition-all font-bold",children:[s.jsx("span",{children:"üóëÔ∏è"})," –û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à (",V,")"]})})]}),N==="status"&&s.jsxs("div",{className:"space-y-6 animate-fade-in",children:[s.jsxs("section",{children:[s.jsx("label",{className:"text-xs font-bold text-gray-500 uppercase tracking-widest mb-2 block",children:"üñ•Ô∏è –ê–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞"}),s.jsx("input",{ref:ae,tabIndex:"0",value:c,onChange:q=>r(q.target.value,!1),onBlur:q=>r(q.target.value,!0),className:"focusable w-full bg-gray-800 text-sm text-white px-4 py-3 rounded-lg border border-gray-700 focus:border-blue-500 outline-none transition-colors",placeholder:"http://192.168.x.x:3000"})]}),s.jsxs("div",{className:"pt-4 border-t border-white/10 pb-4",children:[ue?s.jsx("div",{className:"text-center animate-pulse text-gray-500 py-4",children:"–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö..."}):s.jsxs("div",{className:"grid grid-cols-2 gap-3",children:[s.jsxs("div",{className:"bg-white/5 p-3 rounded-xl border border-white/5",children:[s.jsx("div",{className:"text-[10px] text-gray-500 font-bold uppercase",children:"Status"}),s.jsx("div",{className:`text-xl font-mono ${J?.server==="ok"?"text-green-400":"text-yellow-400"}`,children:J?.server?.toUpperCase()})]}),s.jsxs("div",{className:"bg-white/5 p-3 rounded-xl border border-white/5",children:[s.jsx("div",{className:"text-[10px] text-gray-500 font-bold uppercase",children:"RAM"}),s.jsxs("div",{className:"text-xl font-mono",children:[J?.ram," MB"]})]}),s.jsxs("div",{className:"bg-white/5 p-3 rounded-xl border border-white/5",children:[s.jsx("div",{className:"text-[10px] text-gray-500 font-bold uppercase",children:"Uptime"}),s.jsx("div",{className:"text-xl font-mono",children:O(J?.uptime)})]}),s.jsxs("div",{className:"bg-white/5 p-3 rounded-xl border border-white/5",children:[s.jsx("div",{className:"text-[10px] text-gray-500 font-bold uppercase",children:"Lags"}),s.jsx("div",{className:`text-xl font-mono ${J?.lags>0?"text-red-400":"text-green-400"}`,children:J?.lags})]}),s.jsxs("div",{className:"bg-white/5 p-3 rounded-xl border border-white/5",children:[s.jsx("div",{className:"text-[10px] text-gray-500 font-bold uppercase",children:"Active"}),s.jsx("div",{className:"text-xl font-mono text-blue-400",children:J?.active})]}),s.jsxs("div",{className:"bg-white/5 p-3 rounded-xl border border-white/5",children:[s.jsx("div",{className:"text-[10px] text-gray-500 font-bold uppercase",children:"Frozen"}),s.jsx("div",{className:"text-xl font-mono text-purple-400",children:J?.frozen})]})]}),s.jsx("button",{ref:he,onClick:Q,className:"focusable w-full mt-4 py-3 bg-blue-600/20 text-blue-400 rounded-xl font-bold text-sm border border-blue-500/30 hover:bg-blue-600/30 transition-colors",children:"–û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å"})]})]}),N==="posters"&&s.jsxs("div",{className:"space-y-4 animate-fade-in pb-10",children:[s.jsxs("div",{className:"max-h-40 overflow-y-auto border border-white/10 rounded-xl bg-black/20 p-2 custom-scrollbar",children:[g.map(q=>s.jsx(Jg,{torrent:q,onClick:S},q.infoHash)),g.length===0&&s.jsx("div",{className:"text-center text-xs text-gray-500 py-10",children:"–ù–µ—Ç —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤ –¥–ª—è —Ç–µ—Å—Ç–∞"})]}),I&&s.jsx("div",{className:"text-center text-xs text-blue-400 animate-pulse",children:"–¢–µ—Å—Ç–∏—Ä—É–µ–º –∑–∞–≥—Ä—É–∑–∫—É –ø–æ—Å—Ç–µ—Ä–æ–≤..."}),ce&&s.jsxs("div",{className:"bg-black/40 rounded-xl border border-white/10 p-3 text-[11px] space-y-1",children:[s.jsx("div",{className:"font-bold text-gray-300 border-b border-white/10 pb-1 mb-1",children:ce.name}),ce.results.map((q,Y)=>s.jsxs("div",{className:"flex justify-between items-center",children:[s.jsxs("span",{className:`${q.status==="‚úÖ"?"text-green-400":"text-red-400"}`,children:[q.status," ",q.name]}),s.jsx("span",{className:"text-gray-500 truncate max-w-[120px]",children:q.detail})]},Y))]})]})]})]})})},Ws=cn("SpeechRecognition",{web:()=>er(()=>import("./web-Du40huiD.js"),[]).then(c=>new c.SpeechRecognitionWeb)});function Wg(c,r=300){const[d,o]=M.useState(c);return M.useEffect(()=>{const g=setTimeout(()=>{o(c)},r);return()=>{clearTimeout(g)}},[c,r]),d}const Fg=c=>{if(!c)return null;const d=Date.now()-c,o=Math.floor(d/6e4),g=Math.floor(d/36e5),y=Math.floor(d/864e5);return o<1?"—Ç–æ–ª—å–∫–æ —á—Ç–æ":o<60?`${o} –º–∏–Ω`:g<24?`${g} —á`:y<7?`${y} –¥–Ω`:new Date(c).toLocaleDateString("ru-RU",{day:"numeric",month:"short"})},Ig=c=>{switch(c){case"excellent":return"üü¢";case"good":return"üü°";case"poor":return"üü†";default:return"üî¥"}},Pg=({item:c,index:r,onAdd:d})=>{const o=te("search");return s.jsxs("div",{ref:o,className:"focusable flex items-start justify-between p-3 bg-gray-800 rounded-lg cursor-pointer focus:bg-purple-700 focus:ring-2 focus:ring-purple-500 group transition-colors",onClick:()=>d(c.magnet||c.id,c.title),children:[s.jsxs("div",{className:"flex-1 min-w-0",children:[s.jsx("div",{className:"text-sm font-medium text-white truncate",children:c.title}),s.jsxs("div",{className:"text-xs text-gray-400 flex flex-wrap gap-x-3 mt-1",children:[s.jsxs("span",{children:["üì¶ ",c.size]}),s.jsxs("span",{className:"text-green-400",children:[Ig(c.health)," ",c.seeders]}),c.tracker&&s.jsx("span",{className:"text-purple-400",children:c.tracker}),c.dateTs&&s.jsx("span",{className:"text-gray-500",children:Fg(c.dateTs)})]})]}),s.jsx("span",{className:"ml-2 text-gray-500 group-focus:text-green-400 text-lg transition-colors",children:"‚ûï"})]})},ey=({tag:c,active:r,onClick:d})=>{const o=te("search");return s.jsx("button",{ref:o,onClick:d,className:`focusable px-2.5 py-1 rounded-full text-xs border ${r?"bg-purple-600 border-purple-400":"bg-gray-800 text-gray-400"}`,children:c.toUpperCase()})},ty=({opt:c,active:r,onClick:d})=>{const o=te("search");return s.jsx("button",{ref:o,onClick:d,className:`focusable px-2.5 py-1 rounded text-xs ${r?"bg-purple-600 text-white":"bg-gray-800 text-gray-400"}`,children:c==="seeders"?"‚¨Ü":c==="size"?"üì¶":"üìÖ"})},ly=(c,r)=>{if(r>0)return{icon:"‚úÖ",style:"bg-green-900/40 text-green-400 border-green-500/40",label:"OK"};switch(c){case"ok":return{icon:"‚úÖ",style:"bg-green-900/30 text-green-400 border-green-500/30",label:"OK"};case"timeout":return{icon:"‚è±Ô∏è",style:"bg-yellow-900/40 text-yellow-400 border-yellow-500/40",label:"Timeout"};case"circuit_open":return{icon:"üîí",style:"bg-gray-800/50 text-gray-500 border-gray-600/30",label:"Disabled"};case"error":return{icon:"‚ùå",style:"bg-red-900/40 text-red-400 border-red-500/40",label:"Error"};default:return{icon:"‚óã",style:"bg-gray-800/30 text-gray-400 border-gray-600/30",label:"Unknown"}}},ay=({searchQuery:c,onSearchQueryChange:r,onSearch:d,onClose:o,onAddTorrent:g,searchResults:y,searchLoading:x,providers:N={}})=>{const[A,b]=M.useState([]),[H,U]=M.useState("seeders"),[L,J]=M.useState(!1),[se,ue]=M.useState(!1),[re,ce]=M.useState(null);M.useEffect(()=>{un.setActiveZone("search")},[]);const ie=te("search"),I=te("search"),de=te("search"),ge=te("search"),ae=Wg(A,150),X=M.useMemo(()=>y.filter(w=>ae.length===0?!0:ae.every(Q=>(w.tags||[]).includes(Q))),[y,ae]),F=M.useMemo(()=>[...X].sort((w,Q)=>{switch(H){case"seeders":return(Q.seeders||0)-(w.seeders||0);case"size":return(Q.sizeBytes||0)-(w.sizeBytes||0);case"date":return(Q.dateTs||0)-(w.dateTs||0);default:return 0}}),[X,H]),Ee=M.useMemo(()=>[...new Set(y.flatMap(w=>w.tags||[]))],[y]),je=["2160p","1080p","720p","hevc","hdr"].filter(w=>Ee.includes(w)),Ne=Object.entries(N);M.useEffect(()=>{(async()=>{try{const{available:Q}=await Ws.available();ue(Q),Q&&await Ws.requestPermissions()}catch{ue(!1)}})()},[]);const k=async()=>{if(!se){const w=prompt("üé§ –í–≤–µ–¥–∏—Ç–µ –∑–∞–ø—Ä–æ—Å:");w?.trim()&&(r(w.trim()),setTimeout(()=>d(),200));return}try{J(!0);const w=await Ws.start({language:"ru-RU",maxResults:1,prompt:"–ü—Ä–æ–∏–∑–Ω–µ—Å–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ",partialResults:!1,popup:!0});if(J(!1),w.matches?.[0]){const Q=w.matches[0].trim();Q&&(r(Q),setTimeout(()=>d(),300))}}catch{J(!1)}},he=w=>{b(Q=>Q.includes(w)?Q.filter(S=>S!==w):[...Q,w])};return s.jsxs("div",{className:"mb-6 p-4 bg-gray-900 rounded-xl border border-purple-600/50",children:[s.jsxs("div",{className:"flex gap-2 mb-4",children:[s.jsx("input",{ref:ie,value:c,onChange:w=>r(w.target.value),onKeyDown:w=>{w.key==="Enter"&&(w.preventDefault(),d())},placeholder:"–ü–æ–∏—Å–∫ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤...",className:"focusable flex-1 bg-gray-800 border border-gray-700 rounded-lg px-4 py-3 focus:ring-2 focus:ring-purple-500 outline-none",autoFocus:!0}),s.jsx("button",{ref:I,onClick:k,tabIndex:"0",className:`focusable px-4 py-3 rounded-lg font-bold ${L?"bg-red-600 animate-pulse":"bg-gray-700"}`,children:"üé§"}),s.jsx("button",{ref:de,onClick:()=>d(c),disabled:x,tabIndex:"0",className:"focusable bg-purple-600 px-6 py-3 rounded-lg font-bold disabled:opacity-50",children:x?"...":"üîç"}),s.jsx("button",{ref:ge,onClick:o,tabIndex:"0",className:"focusable bg-gray-800 px-4 rounded-lg",children:"‚úï"})]}),Ne.length>0&&s.jsx("div",{className:"flex flex-wrap gap-2 mb-4 text-xs",children:Ne.map(([w,Q])=>{const S=ly(Q.status,Q.count||0),O=Q.status==="error"||Q.status==="timeout";return s.jsxs("button",{onClick:()=>O&&ce(re===w?null:w),className:`px-2 py-1 rounded-full border ${S.style} ${O?"cursor-pointer":"cursor-default"}`,children:[S.icon," ",w,Q.count>0&&s.jsxs("span",{className:"ml-1",children:["(",Q.count,")"]})]},w)})}),y.length>0&&s.jsxs("div",{className:"flex flex-wrap items-center gap-2 mb-3",children:[je.map(w=>s.jsx(ey,{tag:w,active:A.includes(w),onClick:()=>he(w)},w)),s.jsx("div",{className:"flex-1"}),["seeders","size","date"].map(w=>s.jsx(ty,{opt:w,active:H===w,onClick:()=>U(w)},w))]}),F.length>0&&s.jsx("div",{className:"max-h-[50vh] overflow-y-auto space-y-2 pr-1 custom-scrollbar",children:F.map((w,Q)=>s.jsx(Pg,{item:w,onAdd:g},w.id||Q))}),x&&s.jsxs("div",{className:"text-center text-gray-400 py-6",children:[s.jsx("div",{className:"text-3xl mb-2 animate-bounce",children:"üîç"}),s.jsx("span",{className:"animate-pulse",children:"–ü–æ–∏—Å–∫..."})]})]})},ny=({rating:c})=>{if(!c||c===0)return null;const r=c>=7?"bg-green-600":c>=5?"bg-yellow-600":"bg-red-600";return s.jsxs("span",{className:`${r} text-white text-sm font-bold px-2 py-0.5 rounded`,children:["‚≠ê ",typeof c=="number"?c.toFixed(1):c]})},g0=({file:c,idx:r,onClick:d})=>{const o=te("modal");return s.jsxs("button",{ref:o,onClick:d,className:"focusable w-full px-3 py-2 text-left border-t border-gray-800 focus:bg-blue-600 focus:text-white flex items-center gap-2 text-sm",children:[r!==void 0&&s.jsx("span",{className:"text-blue-400 font-mono text-xs w-5",children:r+1}),s.jsx("span",{className:"flex-1 text-gray-300 truncate",children:fa(c.name)||c.name}),s.jsx("span",{className:"text-xs text-gray-500",children:Ec(c.length)})]})},uy=({torrent:c,onClose:r,onPlay:d,onPlayAll:o,onCopyUrl:g,onDelete:y})=>{const[x,N]=M.useState(!1),[A,b]=M.useState(null),[H,U]=M.useState(!1),[L,J]=M.useState(!1),se=te("modal"),ue=te("modal"),re=te("modal"),ce=te("modal"),ie=te("modal"),I=te("modal"),de=te("modal");if(M.useEffect(()=>{const S=setTimeout(()=>J(!0),500),O=document.activeElement;re.current?re.current.focus():se.current&&se.current.focus();let V;return(async()=>{V=await tr.addListener("backButton",()=>{r()})})(),()=>{clearTimeout(S),V&&V.remove(),O&&typeof O.focus=="function"&&O.focus()}},[]),M.useEffect(()=>{if(c?.name){const S=lr(fa(c.name));S&&b(S)}},[c?.name]),!c)return null;const ge=c.files?.filter(S=>/\.(mp4|mkv|avi|mov|webm)$/i.test(S.name))||[],{episodes:ae,extras:X}=hg(ge),F=ae.length>0?ae:ae.concat(X),Ee=ae.length>0?X:[],je=F[0]||c.files?.[0],Ne=fa(c.name),k=A?.backdrop?{backgroundImage:`url(${A.backdrop})`,backgroundSize:"cover",backgroundPosition:"center"}:{background:"linear-gradient(135deg, #1e3a8a 0%, #1f2937 100%)"},he=8,w=H?F:F.slice(0,he),Q=F.length>he&&!H;return s.jsx("div",{className:"fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur-sm",onClick:r,children:s.jsxs("div",{className:"bg-[#181818] rounded-2xl w-full max-w-lg max-h-[85vh] shadow-2xl flex flex-col overflow-hidden",onClick:S=>S.stopPropagation(),children:[s.jsxs("div",{className:"h-32 shrink-0 relative flex items-end overflow-hidden",style:k,children:[s.jsx("div",{className:"absolute inset-0 bg-gradient-to-t from-black via-black/50 to-transparent"}),s.jsx("button",{ref:se,onClick:r,className:"focusable absolute top-3 right-3 bg-black/50 rounded-full w-8 h-8 text-white focus:bg-white focus:text-black",children:"‚úï"}),s.jsxs("div",{className:"relative z-10 p-4 w-full",children:[s.jsxs("div",{className:"flex gap-2 mb-1",children:[s.jsx(ny,{rating:A?.rating}),A?.year&&s.jsx("span",{className:"bg-gray-700 text-gray-300 text-xs px-2 py-0.5 rounded",children:A.year})]}),s.jsx("h2",{className:"text-lg font-bold text-white drop-shadow-lg line-clamp-2",children:A?.title||Ne})]})]}),s.jsxs("div",{className:"flex-1 overflow-y-auto p-4 min-h-0 custom-scrollbar",children:[A?.overview&&s.jsxs("div",{className:"mb-3",children:[s.jsx("p",{className:`text-xs text-gray-400 ${x?"":"line-clamp-2"}`,children:A.overview}),A.overview.length>80&&s.jsx("button",{ref:ue,onClick:()=>N(!x),className:"focusable text-purple-400 text-xs p-1 rounded hover:bg-white/5",children:x?"‚Üê –°–≤–µ—Ä–Ω—É—Ç—å":"–ï—â—ë ‚Üí"})]}),s.jsx("button",{ref:re,onClick:()=>L&&je&&d(c.infoHash,je.index,je.name),className:`focusable w-full bg-white text-black py-3 rounded font-bold focus:bg-yellow-400 mb-2 ${L?"":"opacity-50"}`,children:"‚ñ∂ Play"}),F.length>1&&s.jsxs("button",{ref:ce,onClick:()=>L&&o(c),className:"focusable w-full bg-blue-600 text-white py-2 rounded font-bold focus:bg-blue-500 mb-2",children:["üì∫ Play All (",F.length,")"]}),ge.length>1&&s.jsxs("div",{className:"bg-gray-900 rounded-lg overflow-hidden mb-2",children:[s.jsx("div",{className:"px-3 py-2 bg-gray-800 text-gray-400 text-sm flex items-center justify-between",children:s.jsxs("span",{children:["üìã –°–µ—Ä–∏–∏ (",F.length,")"]})}),s.jsxs("div",{className:"max-h-[28vh] overflow-y-auto custom-scrollbar",children:[w.map((S,O)=>s.jsx(g0,{idx:O,file:S,onClick:()=>d(c.infoHash,S.index,S.name)},S.index)),Q&&s.jsxs("button",{ref:ie,onClick:()=>U(!0),className:"focusable w-full px-3 py-2 text-center text-purple-400 text-sm border-t border-gray-800 focus:bg-purple-900 focus:text-white",children:["‚ñº –ï—â—ë ",F.length-he," —Å–µ—Ä–∏–π"]}),Ee.length>0&&s.jsxs("div",{className:"border-t border-gray-800",children:[s.jsx("div",{className:"px-3 py-2 text-gray-500 text-xs uppercase tracking-wider bg-black/20",children:"üéÅ –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ"}),Ee.map(S=>s.jsx(g0,{file:S,onClick:()=>d(c.infoHash,S.index,S.name)},S.index))]})]})]})]}),s.jsxs("div",{className:"shrink-0 p-4 pt-2 flex gap-2 border-t border-gray-800 bg-black/20",children:[s.jsx("button",{ref:I,onClick:()=>je&&g(c.infoHash,je.index),className:"focusable flex-1 bg-gray-800 text-gray-300 py-2.5 rounded font-medium focus:bg-white focus:text-black text-sm",children:"üìã Copy"}),s.jsx("button",{ref:de,onClick:()=>y(c.infoHash),className:"focusable flex-1 bg-red-900/50 text-red-500 py-2.5 rounded font-medium focus:bg-red-600 focus:text-white text-sm",children:"üóë Delete"})]})]})})};function gl({onClick:c,disabled:r,className:d,children:o,autoFocus:g,tabIndex:y=0}){return s.jsx("button",{onClick:c,disabled:r,autoFocus:g,tabIndex:r?-1:y,className:`
                focus:ring-4 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900
                focus:outline-none focus:scale-105 transition-all
                ${d}
            `,children:o})}function cy({serverUrl:c,torrents:r=[],onClose:d}){const[o,g]=M.useState({enabled:!1,intervalMinutes:720}),[y,x]=M.useState([]),[N,A]=M.useState(!1),[b,H]=M.useState(!1),[U,L]=M.useState(null),[J,se]=M.useState(!1),[ue,re]=M.useState({query:"",resolution:"2160",group:"",lastEpisode:0}),ce=M.useRef(null),ie=M.useRef(null),I=w=>c?`${c}${w}`:w,ge=r.filter(w=>(w.files?.filter(S=>/\.(mp4|mkv|avi|webm|mov)$/i.test(S.name))||[]).length>1).map(w=>{const Q=w.files?.filter(q=>/\.(mp4|mkv|avi|webm|mov)$/i.test(q.name))||[];let S=0;Q.forEach(q=>{const Y=q.name.match(/[ES](\d{1,3})|[-‚Äì]\s*(\d{1,3})(?:\s|$|\[|\()/i);if(Y){const m=parseInt(Y[1]||Y[2],10);m>S&&(S=m)}});const O=w.name.match(/\b(2160p?|1080p?|720p?)\b/i),V=O?O[1].replace("p",""):"";return{name:w.name,episodeCount:Q.length,lastEpisode:S,resolution:V}});M.useEffect(()=>{const w=window.getComputedStyle(document.body).overflow;return document.body.style.overflow="hidden",document.documentElement.style.overflow="hidden",()=>{document.body.style.overflow=w,document.documentElement.style.overflow=""}},[]),M.useEffect(()=>{const w=()=>Array.from(ce.current?.querySelectorAll('button:not([disabled]), input:not([disabled]), select:not([disabled]), [tabindex="0"]')||[]),Q=O=>{const V=O.key,q=O.keyCode;if(V==="Escape"||V==="Backspace"||q===10009){O.preventDefault(),O.stopPropagation(),J?se(!1):d();return}if(V==="ArrowUp"||V==="ArrowDown"||q===38||q===40){O.preventDefault(),O.stopPropagation();const Y=w();if(!Y.length)return;const m=Y.indexOf(document.activeElement);let _;V==="ArrowDown"||q===40?_=m<Y.length-1?m+1:0:_=m>0?m-1:Y.length-1,Y[_]?.focus(),Y[_]?.scrollIntoView({block:"nearest",behavior:"smooth"});return}if(V==="ArrowLeft"||V==="ArrowRight"||q===37||q===39){if(document.activeElement?.tagName==="INPUT")return;O.preventDefault(),O.stopPropagation()}if(V==="Tab"){O.preventDefault(),O.stopPropagation();const Y=w();if(!Y.length)return;const m=Y.indexOf(document.activeElement);let _;O.shiftKey?_=m>0?m-1:Y.length-1:_=m<Y.length-1?m+1:0,Y[_]?.focus()}},S=O=>{O.preventDefault(),O.stopPropagation()};return window.addEventListener("keydown",Q,!0),document.addEventListener("scroll",S,!0),setTimeout(()=>{ie.current?.focus()},50),()=>{window.removeEventListener("keydown",Q,!0),document.removeEventListener("scroll",S,!0)}},[J,d]);const ae=async()=>{A(!0);try{const Q=await(await fetch(I("/api/autodownload/rules"))).json();g(Q.settings||{enabled:!1,intervalMinutes:720}),x(Q.rules||[])}catch(w){console.error("[AutoDownload] Fetch error:",w)}finally{A(!1)}};M.useEffect(()=>{ae()},[c]);const X=async()=>{try{const Q=await(await fetch(I("/api/autodownload/settings"),{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify({enabled:!o.enabled})})).json();g(Q)}catch(w){console.error("[AutoDownload] Toggle error:",w)}},F=async w=>{try{const S=await(await fetch(I("/api/autodownload/settings"),{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify({intervalMinutes:parseInt(w,10)})})).json();g(S)}catch(Q){console.error("[AutoDownload] Interval error:",Q)}},Ee=async()=>{if(ue.query.trim())try{await(await fetch(I("/api/autodownload/rules"),{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(ue)})).json(),re({query:"",resolution:"2160",group:"",lastEpisode:0}),ae()}catch(w){console.error("[AutoDownload] Add rule error:",w)}},je=w=>{re({query:w.name.replace(/\./g," ").split(/[-\[\(]/)[0].trim(),resolution:w.resolution||"2160",group:"",lastEpisode:w.lastEpisode}),se(!1)},Ne=async w=>{if(confirm("–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ –ø—Ä–∞–≤–∏–ª–æ?"))try{await fetch(I(`/api/autodownload/rules/${w}`),{method:"DELETE"}),ae()}catch(Q){console.error("[AutoDownload] Delete error:",Q)}},k=async w=>{try{await fetch(I(`/api/autodownload/rules/${w.id}`),{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify({enabled:!w.enabled})}),ae()}catch(Q){console.error("[AutoDownload] Toggle rule error:",Q)}},he=async()=>{H(!0),L(null);try{const Q=await(await fetch(I("/api/autodownload/check"),{method:"POST"})).json();L(Q),ae()}catch(w){console.error("[AutoDownload] Check error:",w),L({error:w.message})}finally{H(!1)}};return s.jsx("div",{className:"fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4",onClick:w=>w.target===w.currentTarget&&d(),children:s.jsxs("div",{ref:ce,className:"bg-gray-900 rounded-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col",onClick:w=>w.stopPropagation(),children:[s.jsxs("div",{className:"flex justify-between items-center p-4 border-b border-gray-800",children:[s.jsx("h2",{className:"text-xl font-bold text-white flex items-center gap-2",children:"üì∫ –ê–≤—Ç–æ-–∑–∞–≥—Ä—É–∑–∫–∞ —Å–µ—Ä–∏–∞–ª–æ–≤"}),s.jsx(gl,{onClick:d,className:"text-gray-400 hover:text-white text-2xl p-2 rounded-lg",tabIndex:0,children:"‚úï"})]}),s.jsxs("div",{className:"flex-1 overflow-y-auto p-4 space-y-4",children:[s.jsxs("div",{className:"bg-gray-800/50 rounded-xl p-4",children:[s.jsxs("div",{className:"flex items-center justify-between mb-3",children:[s.jsxs("div",{children:[s.jsx("div",{className:"font-bold text-white",children:"–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞"}),s.jsxs("div",{className:"text-sm text-gray-400",children:["–ü–æ–∏—Å–∫ –Ω–æ–≤—ã—Ö —Å–µ—Ä–∏–π –∫–∞–∂–¥—ã–µ ",o.intervalMinutes>=60?`${Math.round(o.intervalMinutes/60)} —á`:`${o.intervalMinutes} –º–∏–Ω`]})]}),s.jsx(gl,{ref:ie,onClick:X,className:`w-14 h-8 rounded-full transition-colors relative ${o.enabled?"bg-green-600":"bg-gray-600"}`,tabIndex:0,children:s.jsx("div",{className:`absolute w-6 h-6 bg-white rounded-full top-1 transition-all ${o.enabled?"left-7":"left-1"}`})})]}),s.jsxs("div",{className:"flex items-center gap-2 text-sm flex-wrap",children:[s.jsx("span",{className:"text-gray-400",children:"–ò–Ω—Ç–µ—Ä–≤–∞–ª:"}),[{value:360,label:"6 —á"},{value:720,label:"12 —á"},{value:1440,label:"24 —á"}].map(w=>s.jsx(gl,{onClick:()=>F(w.value),className:`px-3 py-1 rounded ${o.intervalMinutes===w.value?"bg-blue-600 text-white":"bg-gray-700 text-gray-300 hover:bg-gray-600"}`,tabIndex:0,children:w.label},w.value))]})]}),s.jsx(gl,{onClick:he,disabled:b,className:"w-full bg-purple-600 hover:bg-purple-500 disabled:opacity-50 text-white font-bold py-3 rounded-xl flex items-center justify-center gap-2",tabIndex:0,children:b?s.jsxs(s.Fragment,{children:[s.jsx("span",{className:"animate-spin",children:"‚è≥"}),"–ü—Ä–æ–≤–µ—Ä—è–µ–º..."]}):s.jsx(s.Fragment,{children:"üîç –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–µ–π—á–∞—Å"})}),U&&s.jsx("div",{className:`rounded-xl p-3 text-sm ${U.downloaded>0?"bg-green-900/50 text-green-300":U.error?"bg-red-900/50 text-red-300":"bg-gray-800 text-gray-400"}`,children:U.error?`‚ùå –û—à–∏–±–∫–∞: ${U.error}`:U.downloaded>0?`‚úÖ –ù–∞–π–¥–µ–Ω–æ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–æ: ${U.downloaded} —Å–µ—Ä–∏–π`:"‚úì –ù–æ–≤—ã—Ö —Å–µ—Ä–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ"}),s.jsxs("div",{className:"bg-gray-800/50 rounded-xl p-4",children:[s.jsxs("div",{className:"flex items-center justify-between mb-3",children:[s.jsx("h3",{className:"font-bold text-white",children:"‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–µ—Ä–∏–∞–ª"}),ge.length>0&&s.jsxs(gl,{onClick:()=>se(!J),className:"bg-purple-600/30 hover:bg-purple-600/50 text-purple-300 px-3 py-1 rounded-lg text-sm",tabIndex:0,children:["üìã –í—ã–±—Ä–∞—Ç—å (",ge.length,")"]})]}),J&&s.jsxs("div",{className:"mb-4 bg-gray-700/50 rounded-xl p-3 max-h-48 overflow-y-auto space-y-2",children:[s.jsx("div",{className:"text-sm text-gray-400 mb-2",children:"–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–∏–∞–ª:"}),ge.map((w,Q)=>s.jsxs(gl,{onClick:()=>je(w),className:"w-full text-left bg-gray-800 hover:bg-gray-700 rounded-lg p-3",tabIndex:0,autoFocus:Q===0,children:[s.jsx("div",{className:"font-medium text-white truncate",children:w.name}),s.jsxs("div",{className:"text-xs text-gray-400",children:[w.episodeCount," —Å–µ—Ä–∏–π ‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω—è—è: ",w.lastEpisode,w.resolution&&` ‚Ä¢ ${w.resolution}p`]})]},Q))]}),s.jsxs("div",{className:"grid grid-cols-2 gap-3",children:[s.jsx("input",{value:ue.query,onChange:w=>re({...ue,query:w.target.value}),placeholder:"–ù–∞–∑–≤–∞–Ω–∏–µ —Å–µ—Ä–∏–∞–ª–∞...",tabIndex:0,className:"col-span-2 bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white placeholder-gray-500 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 outline-none"}),s.jsxs("select",{value:ue.resolution,onChange:w=>re({...ue,resolution:w.target.value}),tabIndex:0,className:"bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:border-blue-500 focus:ring-2 focus:ring-blue-500 outline-none",children:[s.jsx("option",{value:"",children:"–õ—é–±–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ"}),s.jsx("option",{value:"2160",children:"4K (2160p)"}),s.jsx("option",{value:"1080",children:"1080p"}),s.jsx("option",{value:"720",children:"720p"})]}),s.jsx("input",{type:"number",min:"0",value:ue.lastEpisode,onChange:w=>re({...ue,lastEpisode:parseInt(w.target.value,10)||0}),placeholder:"–ü–æ—Å–ª–µ–¥–Ω—è—è —Å–µ—Ä–∏—è",tabIndex:0,className:"bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:border-blue-500 focus:ring-2 focus:ring-blue-500 outline-none"})]}),s.jsx(gl,{onClick:Ee,disabled:!ue.query.trim(),className:"mt-3 w-full bg-blue-600 hover:bg-blue-500 disabled:opacity-50 text-white font-bold py-2 rounded-lg",tabIndex:0,children:"–î–æ–±–∞–≤–∏—Ç—å"})]}),s.jsxs("div",{className:"space-y-2",children:[s.jsxs("h3",{className:"font-bold text-white",children:["üìã –ú–æ–∏ —Å–µ—Ä–∏–∞–ª—ã (",y.length,")"]}),N?s.jsx("div",{className:"text-center text-gray-500 py-8",children:"–ó–∞–≥—Ä—É–∑–∫–∞..."}):y.length===0?s.jsx("div",{className:"text-center text-gray-500 py-8",children:"–î–æ–±–∞–≤—å—Ç–µ —Å–µ—Ä–∏–∞–ª –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è"}):y.map(w=>s.jsxs("div",{className:`bg-gray-800 rounded-xl p-3 flex items-center gap-3 ${w.enabled?"":"opacity-50"}`,children:[s.jsx(gl,{onClick:()=>k(w),className:`w-10 h-10 rounded-full flex items-center justify-center text-lg ${w.enabled?"bg-green-600":"bg-gray-600"}`,tabIndex:0,children:w.enabled?"‚úì":"‚óã"}),s.jsxs("div",{className:"flex-1 min-w-0",children:[s.jsx("div",{className:"font-medium text-white truncate",children:w.query}),s.jsxs("div",{className:"text-xs text-gray-400",children:[w.resolution&&`${w.resolution}p ‚Ä¢ `,"–°–µ—Ä–∏—è: ",w.lastEpisode]})]}),s.jsx(gl,{onClick:()=>Ne(w.id),className:"text-red-500 hover:text-red-400 p-2 text-xl",tabIndex:0,children:"üóëÔ∏è"})]},w.id))]})]})]})})}const iy=(c=1)=>We(`/movie/now_playing?page=${c}`,{cacheTTL:600*1e3}),sy=(c=1)=>We(`/trending/movie/day?page=${c}`,{cacheTTL:600*1e3}),ry=(c=1)=>We(`/movie/upcoming?page=${c}`,{cacheTTL:600*1e3}),oy=(c=1)=>We(`/tv/top_rated?page=${c}`,{cacheTTL:600*1e3}),Sc=(c,r=1)=>We(`/discover/movie?with_genres=${c}&sort_by=popularity.desc&language=ru-RU&page=${r}`,{cacheTTL:3600*1e3}),N0=[{id:"now_playing",name:"–°–µ–π—á–∞—Å —Å–º–æ—Ç—Ä—è—Ç",icon:"üé¨",fetcher:iy},{id:"trending_day",name:"–¢—Ä–µ–Ω–¥—ã –¥–Ω—è",icon:"üìà",fetcher:sy},{id:"genre_28",name:"–ë–æ–µ–≤–∏–∫–∏",icon:"üëä",fetcher:c=>Sc(28,c)},{id:"trending",name:"–¢—Ä–µ–Ω–¥—ã –Ω–µ–¥–µ–ª–∏",icon:"üî•",fetcher:c=>Dg("week",c)},{id:"genre_35",name:"–ö–æ–º–µ–¥–∏–∏",icon:"üòÇ",fetcher:c=>Sc(35,c)},{id:"upcoming",name:"–°–∫–æ—Ä–æ –≤ –∫–∏–Ω–æ",icon:"üìÖ",fetcher:ry},{id:"movies",name:"–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ñ–∏–ª—å–º—ã",icon:"‚≠ê",fetcher:Cg},{id:"genre_878",name:"–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞",icon:"üëΩ",fetcher:c=>Sc(878,c)},{id:"tv",name:"–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Å–µ—Ä–∏–∞–ª—ã",icon:"üì∫",fetcher:Og},{id:"genre_16",name:"–ú—É–ª—å—Ç—Ñ–∏–ª—å–º—ã",icon:"üé®",fetcher:c=>Sc(16,c)},{id:"top",name:"–¢–æ–ø —Ñ–∏–ª—å–º–æ–≤",icon:"üèÜ",fetcher:Rg},{id:"top_tv",name:"–¢–æ–ø —Å–µ—Ä–∏–∞–ª–æ–≤",icon:"üèÜ",fetcher:oy}];async function fy(){const c={},r=new Set,d=await Promise.all(N0.map(async o=>{try{let g=1,y=await o.fetcher(g),x=Is(y.results||[]);const N=y.source,A=y.method;for(;x.length<20&&g<4;)try{g++;const b=await o.fetcher(g),H=Is(b.results||[]),U=new Set(x.map(J=>J.id)),L=H.filter(J=>!U.has(J.id));if(L.length===0)break;x=[...x,...L]}catch(b){console.warn(`[Discovery] Page ${g} fetch failed for ${o.id}`,b);break}return x=x.slice(0,20),{category:o,items:x,source:N,method:A}}catch(g){return console.error(`[Discovery] Failed to fetch ${o.id}:`,g),{category:o,items:[],error:g.message}}}));for(const{category:o,items:g,source:y,method:x,error:N}of d){const A=g.filter(b=>r.has(b.id)?!1:(r.add(b.id),!0));c[o.id]={...o,items:A,fetcher:o.fetcher,source:y,method:x,error:N}}return c}function sn(c,r="w342"){return c?c._kp_data?.posterUrlPreview?`https://wsrv.nl/?url=${encodeURIComponent(c._kp_data.posterUrlPreview)}&output=webp`:c.poster_path?(`${r}${c.poster_path}`,da(c.poster_path,r)):null:null}function T0(c,r="w1280"){return c&&c.backdrop_path?(`${r}${c.backdrop_path}`,da(c.backdrop_path,r)):null}function uu(c){return c?.title||c?.name||c?.original_title||"–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"}function w0(c){const r=c?.release_date||c?.first_air_date;return r?r.substring(0,4):null}function dy(c){const r=uu(c);return w0(c),c?.media_type==="tv"?`${r} S01`:r}const my=({item:c,onItemClick:r,onFocus:d,imageErrors:o,setImageErrors:g})=>{const y=te("main"),x=sn(c),N=uu(c);return s.jsxs("button",{ref:y,className:"focusable tv-card snap-item w-[130px] aspect-[2/3] rounded-lg bg-gray-800 border border-transparent overflow-hidden",onClick:()=>r?.(c),onFocus:d,children:[x&&!o.has(x)?s.jsx("img",{src:x,alt:N,className:"w-full h-full object-cover",loading:"lazy",onError:()=>{xg?.(x),g(A=>new Set(A).add(x))}}):s.jsx("div",{className:"w-full h-full flex items-center justify-center p-2 text-center text-xs text-white",children:N}),c.vote_average>0&&s.jsx("div",{className:`absolute top-1 right-1 text-[10px] font-bold px-1.5 py-0.5 rounded text-white ${c.vote_average>=7?"bg-green-500":c.vote_average>=5?"bg-yellow-500 text-black":"bg-red-500"}`,children:c.vote_average.toFixed(1)})]})},_0=M.forwardRef(({title:c,icon:r,items:d=[],categoryId:o,onItemClick:g,onFocusChange:y,onMoreClick:x},N)=>{const[A,b]=M.useState(new Set),H=te("main");return d.length===0?null:s.jsxs("div",{className:"home-row mb-6",children:[s.jsx("div",{className:"flex items-center justify-between px-8 mb-3",children:s.jsxs("h2",{className:"text-xl font-bold text-white flex items-center gap-2 drop-shadow-lg",children:[s.jsx("span",{className:"text-2xl",children:r}),c,s.jsxs("span",{className:"text-gray-500 text-sm font-normal",children:["(",d.length,")"]})]})}),s.jsxs("div",{className:"snap-container px-8 gap-4 overflow-x-auto scroll-smooth scrollbar-hide py-6 -my-4",children:[d.map((U,L)=>s.jsx(my,{item:U,onItemClick:g,onFocus:()=>y?.(U),imageErrors:A,setImageErrors:b},U.id||L)),x&&s.jsxs("button",{onClick:()=>x(o),className:"focusable snap-item w-[130px] aspect-[2/3] rounded-lg bg-gray-800/60 border-2 border-gray-600 flex flex-col items-center justify-center gap-2",ref:H,children:[s.jsx("span",{className:"text-5xl text-gray-300",children:"‚Üí"}),s.jsx("span",{className:"text-gray-300 text-sm font-semibold",children:"–ï—â—ë"})]})]})]})});_0.displayName="HomeRow";const hy=({categoryId:c,customCategory:r,items:d=[],onItemClick:o})=>{const[g,y]=M.useState(d),[x,N]=M.useState(d.length>0?1:0),[A,b]=M.useState(!1),[H,U]=M.useState(!0),[L,J]=M.useState(new Set),se=M.useRef(null),ue=te("category"),re=r||N0.find(I=>I.id===c);M.useEffect(()=>{y(d),N(d.length>0?1:0),U(!0),J(new Set),ie.current=!1},[c,r?.name]);const ce=M.useCallback(async()=>{if(!(A||!H||!re?.fetcher)){b(!0);try{const I=x+1,de=await re.fetcher(I);if(de&&de.results&&de.results.length>0){const ge=Is(de.results);ge.length>0&&y(ae=>[...ae,...ge]),N(I),de.results.length<20&&U(!1)}else U(!1)}catch(I){console.error(I),U(!1)}finally{b(!1)}}},[A,H,x,re]),ie=M.useRef(!1);return M.useEffect(()=>{x===0&&!ie.current&&re&&(ie.current=!0,ce())},[re]),M.useEffect(()=>{const I=new IntersectionObserver(ae=>{ae[0].isIntersecting&&ce()},{threshold:0,rootMargin:"500px"});se.current&&I.observe(se.current);const de=ae=>{const{scrollTop:X,scrollHeight:F,clientHeight:Ee}=ae.target;F-X<=Ee+1e3&&ce()},ge=document.querySelector(".category-page");return ge&&ge.addEventListener("scroll",de),()=>{I.disconnect(),ge&&ge.removeEventListener("scroll",de)}},[ce]),re?s.jsxs("div",{className:"category-page h-full w-full bg-[#141414] p-6 overflow-y-auto custom-scrollbar",children:[s.jsxs("div",{className:"flex items-center gap-4 mb-6",children:[s.jsx("button",{ref:ue,className:"focusable text-white hover:text-blue-400 p-2 rounded-lg focus:ring-4 focus:ring-blue-500",onClick:()=>window.dispatchEvent(new KeyboardEvent("keydown",{key:"Backspace"})),children:s.jsx("span",{className:"text-2xl",children:"‚Üê"})}),s.jsxs("h1",{className:"text-2xl font-bold text-white flex items-center gap-3",children:[s.jsx("span",{className:"text-3xl",children:re.icon}),re.name,s.jsxs("span",{className:"text-gray-500 text-lg font-normal",children:["(",g.length,")"]})]})]}),s.jsx("div",{className:"grid grid-cols-2 md:grid-cols-5 gap-4",children:g.map((I,de)=>s.jsx(gy,{item:I,onClick:()=>o(I)},`${I.id}-${de}`))}),H&&s.jsx("div",{ref:se,className:"h-20 flex items-center justify-center mt-8",children:A&&s.jsx("div",{className:"w-8 h-8 border-4 border-blue-500/30 border-t-blue-500 rounded-full animate-spin"})})]}):null},gy=({item:c,onClick:r})=>{const d=te("category"),[o,g]=M.useState(!1),y=sn(c),x=uu(c);return s.jsxs("button",{ref:d,onClick:r,className:"focusable rounded-lg transition-all duration-200 relative overflow-hidden focus:outline-none focus:ring-4 focus:ring-blue-500 focus:scale-105 focus:z-10 aspect-[2/3]",children:[y&&!o?s.jsx("img",{src:y,className:"w-full h-full object-cover",onError:()=>g(!0)}):s.jsx("div",{className:"w-full h-full bg-gray-800 flex items-center justify-center p-2 text-white text-xs text-center",children:x}),c.vote_average>0&&s.jsx("div",{className:"absolute top-2 right-2 bg-black/60 px-2 py-1 rounded text-xs font-bold text-white",children:c.vote_average.toFixed(1)})]})},yy=cn("Browser",{web:()=>er(()=>import("./web-C-YL8JOE.js"),[]).then(c=>new c.BrowserWeb)}),vy={28:"–ë–æ–µ–≤–∏–∫",12:"–ü—Ä–∏–∫–ª—é—á–µ–Ω–∏—è",16:"–ú—É–ª—å—Ç—Ñ–∏–ª—å–º",35:"–ö–æ–º–µ–¥–∏—è",80:"–ö—Ä–∏–º–∏–Ω–∞–ª",99:"–î–æ–∫—É–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π",18:"–î—Ä–∞–º–∞",10751:"–°–µ–º–µ–π–Ω—ã–π",14:"–§—ç–Ω—Ç–µ–∑–∏",36:"–ò—Å—Ç–æ—Ä–∏—è",27:"–£–∂–∞—Å—ã",10402:"–ú—É–∑—ã–∫–∞",9648:"–î–µ—Ç–µ–∫—Ç–∏–≤",10749:"–ú–µ–ª–æ–¥—Ä–∞–º–∞",878:"–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞",10770:"–¢–µ–ª–µ—Ñ–∏–ª—å–º",53:"–¢—Ä–∏–ª–ª–µ—Ä",10752:"–í–æ–µ–Ω–Ω—ã–π",37:"–í–µ—Å—Ç–µ—Ä–Ω"},by={10759:"–≠–∫—à–Ω –∏ –ü—Ä–∏–∫–ª—é—á–µ–Ω–∏—è",16:"–ú—É–ª—å—Ç—Ñ–∏–ª—å–º",35:"–ö–æ–º–µ–¥–∏—è",80:"–ö—Ä–∏–º–∏–Ω–∞–ª",99:"–î–æ–∫—É–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π",18:"–î—Ä–∞–º–∞",10751:"–°–µ–º–µ–π–Ω—ã–π",10762:"–î–µ—Ç—Å–∫–∏–π",9648:"–î–µ—Ç–µ–∫—Ç–∏–≤",10763:"–ù–æ–≤–æ—Å—Ç–∏",10764:"–†–µ–∞–ª–∏—Ç–∏",10765:"–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞ –∏ –§—ç–Ω—Ç–µ–∑–∏",10766:"–ú—ã–ª—å–Ω–∞—è –æ–ø–µ—Ä–∞",10767:"–¢–æ–∫-—à–æ—É",10768:"–í–æ–π–Ω–∞ –∏ –ü–æ–ª–∏—Ç–∏–∫–∞",37:"–í–µ—Å—Ç–µ—Ä–Ω"},y0={...by,...vy},py=c=>c?c.genre_ids&&Array.isArray(c.genre_ids)?c.genre_ids.map(r=>({id:r,name:y0[r]})).filter(r=>r.name):c.genres&&Array.isArray(c.genres)?c.genres.map(r=>({id:r.id,name:r.name||y0[r.id]})).filter(r=>r.name):[]:[],xy=({genre:c,onClick:r})=>{const d=te("detail");return s.jsx("button",{ref:d,onClick:()=>r?.(c),className:"focusable px-3 py-1 bg-gray-800/60 focus:bg-blue-600 focus:text-white rounded-full text-sm text-gray-300",children:c.name})},Sy=({actor:c,onClick:r})=>{const d=te("detail");return s.jsxs("button",{ref:d,onClick:()=>r?.(c),className:"focusable relative flex-shrink-0 w-24 h-36 bg-gray-800 rounded-lg overflow-hidden focus:ring-4 focus:ring-blue-500 shadow-xl",children:[s.jsx("img",{src:da(c.profile_path,"w185"),className:"w-full h-full object-cover"}),s.jsx("div",{className:"absolute bottom-0 inset-x-0 bg-black/60 p-1",children:s.jsx("p",{className:"text-[10px] text-white font-bold truncate",children:c.name})})]})},Ey=({season:c,active:r,onClick:d,posterUrl:o})=>{const g=te("detail");return s.jsxs("button",{ref:g,onClick:()=>d?.(c),className:`focusable relative flex-shrink-0 w-32 aspect-[2/3] rounded-xl overflow-hidden focus:ring-4 focus:ring-blue-500 transition-all ${r?"ring-2 ring-green-500":""}`,children:[s.jsx("img",{src:sn(c,"w342")||o,className:"w-full h-full object-cover"}),s.jsxs("div",{className:"absolute bottom-0 inset-x-0 bg-black/80 p-2 text-xs text-white font-bold",children:["–°–µ–∑–æ–Ω ",c.season_number]})]})},jy=({ep:c,onClick:r})=>{const d=te("detail");return s.jsxs("button",{ref:d,onClick:()=>r?.(c),className:"focusable w-full flex items-center gap-4 p-3 bg-gray-800/40 focus:bg-blue-600 text-left rounded-xl transition-all",children:[s.jsx("div",{className:"w-24 aspect-video bg-black rounded overflow-hidden flex-shrink-0",children:s.jsx("img",{src:da(c.still_path,"w300"),className:"w-full h-full object-cover"})}),s.jsxs("div",{className:"flex-1",children:[s.jsxs("div",{className:"text-sm font-bold text-white",children:["E",c.episode_number,". ",c.name]}),s.jsx("div",{className:"text-xs text-gray-400 line-clamp-1",children:c.overview})]})]})},Ny=({rec:c,onClick:r})=>{const d=te("detail");return s.jsx("button",{ref:d,onClick:()=>r?.(c),className:"focusable relative flex-shrink-0 w-32 aspect-[2/3] rounded-xl shadow-lg focus:ring-4 focus:ring-blue-500 transition-all overflow-hidden",children:s.jsx("img",{src:sn(c,"w342"),className:"w-full h-full object-cover"})})},Ty=({item:c,onSearch:r,onBack:d,onSelect:o,onSelectPerson:g,onSelectGenre:y})=>{const[x,N]=M.useState([]),[A,b]=M.useState([]),[H,U]=M.useState([]),[L,J]=M.useState(null),[se,ue]=M.useState([]),[re,ce]=M.useState([]),[ie,I]=M.useState(null),[de,ge]=M.useState(!0),[ae,X]=M.useState(!1),F=te("detail"),Ee=te("detail"),je=te("detail");if(M.useEffect(()=>{const C=setTimeout(()=>X(!0),500);return()=>clearTimeout(C)},[]),!c)return null;const Ne=T0(c,"w1280"),k=sn(c,"w500"),he=uu(c),w=w0(c),Q=c.vote_average?.toFixed(1),S=c.overview||"–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç",O=c.media_type==="tv"||c.name?"tv":"movie",V=O==="tv"?"–°–µ—Ä–∏–∞–ª":"–§–∏–ª—å–º",q=py(c),Y=async C=>{try{const G=await Lg(c.id,C);ue(G.episodes||[])}catch(G){console.error(G)}},m=C=>{J(C),Y(C.season_number)},_=C=>{const G=C.season_number.toString().padStart(2,"0"),K=C.episode_number.toString().padStart(2,"0");r?.(`${he} S${G}E${K}`)};return M.useEffect(()=>{if(!c?.id)return;const C=new AbortController;return(async()=>{ge(!0);try{const K=await qg(c.id,O);K&&O==="tv"&&U(K.seasons||[]);const le=await Ug(c.id,O);N(le.crew?.filter(Ae=>Ae.job==="Director")||[]),b(le.cast?.slice(0,8)||[]);const P=await Bg(c.id,O);I(P.results?.find(Ae=>Ae.type==="Trailer")||P.results?.[0]);const Re=await Hg(c.id,O);ce(Re.results||[])}catch(K){console.warn(K)}finally{C.signal.aborted||ge(!1)}})(),()=>C.abort()},[c?.id]),s.jsxs("div",{className:"movie-detail fixed inset-0 z-50 bg-gray-900 overflow-hidden",children:[s.jsx("div",{className:"absolute inset-0 transition-opacity duration-500",style:{background:Ne?`linear-gradient(to right, rgba(17,24,39,1) 0%, rgba(17,24,39,0.8) 50%, rgba(17,24,39,0.4) 100%), url(${Ne}) center/cover no-repeat`:"linear-gradient(to bottom, #1f2937, #111827)"}}),s.jsx("div",{className:"relative z-10 h-full overflow-y-auto custom-scrollbar p-6 md:p-10",children:s.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-[220px_1fr] gap-10 max-w-7xl mx-auto",children:[s.jsx("div",{className:"hidden md:block",children:s.jsx("img",{src:k,className:"w-[220px] aspect-[2/3] rounded-xl shadow-2xl object-cover border border-gray-700"})}),s.jsxs("div",{className:"flex flex-col gap-6 min-w-0",children:[s.jsx("h1",{className:"text-4xl font-bold text-white drop-shadow-lg",children:he}),s.jsxs("div",{className:"flex flex-wrap gap-4 items-center",children:[Q>0&&s.jsxs("span",{className:"px-3 py-1 bg-green-600 rounded-lg font-bold text-white",children:["‚òÖ ",Q]}),w&&s.jsx("span",{className:"px-3 py-1 bg-gray-800 rounded-lg text-gray-200",children:w}),s.jsx("span",{className:"px-3 py-1 bg-blue-600 rounded-lg text-white font-medium",children:V})]}),s.jsxs("div",{className:"flex flex-wrap gap-4",children:[s.jsx("button",{ref:F,onClick:()=>ae&&r?.(dy(c)),className:`focusable px-8 py-3 bg-blue-600 focus:bg-yellow-400 focus:text-black focus:ring-4 focus:ring-yellow-400 text-white font-bold rounded-xl transition-all ${ae?"":"opacity-50"}`,children:"üîç –ù–∞–π—Ç–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç—ã"}),s.jsx("button",{ref:Ee,onClick:d,className:"focusable px-8 py-3 bg-gray-800 focus:bg-white focus:text-black focus:ring-4 focus:ring-white text-white font-bold rounded-xl transition-all",children:"‚¨ÖÔ∏è –ù–∞–∑–∞–¥"}),ie&&s.jsx("button",{ref:je,onClick:()=>ae&&yy.open({url:`https://www.youtube.com/watch?v=${ie.key}`}),className:"focusable px-6 py-3 bg-red-600 focus:bg-red-400 focus:ring-4 focus:ring-red-300 text-white font-bold rounded-xl transition-all",children:"‚ñ∂Ô∏è –¢—Ä–µ–π–ª–µ—Ä"})]}),s.jsx("div",{className:"flex flex-wrap gap-2",children:q.map(C=>s.jsx(xy,{genre:C,onClick:y},C.id))}),s.jsx("div",{className:"bg-black/40 p-5 rounded-2xl backdrop-blur-sm max-w-3xl",children:s.jsx("p",{className:"text-gray-200 leading-relaxed",children:S})}),A.length>0&&s.jsxs("div",{className:"mt-4",children:[s.jsx("h3",{className:"text-xl font-bold text-white mb-4",children:"üé≠ –í —Ä–æ–ª—è—Ö"}),s.jsx("div",{className:"flex gap-4 overflow-x-auto py-4 custom-scrollbar px-2 -my-2",children:A.map(C=>s.jsx(Sy,{actor:C,onClick:g},C.id))})]}),H.length>0&&s.jsxs("div",{className:"mt-4",children:[s.jsx("h3",{className:"text-xl font-bold text-white mb-4",children:"üì∫ –°–µ–∑–æ–Ω—ã"}),s.jsx("div",{className:"flex gap-4 overflow-x-auto pb-4 custom-scrollbar px-2",children:H.filter(C=>C.season_number>0).map(C=>s.jsx(Ey,{season:C,active:L?.id===C.id,onClick:m,posterUrl:k},C.id))})]}),se.length>0&&s.jsxs("div",{className:"mt-6 bg-black/20 p-4 rounded-2xl",children:[s.jsxs("h3",{className:"text-xl font-bold text-white mb-4",children:["üé¨ –≠–ø–∏–∑–æ–¥—ã (",L?.name,")"]}),s.jsx("div",{className:"space-y-2",children:se.map(C=>s.jsx(jy,{ep:C,onClick:_},C.id))})]}),re.length>0&&s.jsxs("div",{className:"mt-8",children:[s.jsx("h3",{className:"text-xl font-bold text-white mb-4",children:"‚ú® –ü–æ—Ö–æ–∂–µ–µ"}),s.jsx("div",{className:"flex gap-4 overflow-x-auto pt-4 pb-12 custom-scrollbar px-2 -my-4",children:re.slice(0,10).map(C=>s.jsx(Ny,{rec:C,onClick:o},C.id))})]})]})]})})]})},wy=({item:c,onClick:r})=>{const d=te("person");return s.jsxs("button",{ref:d,onClick:r,className:"focusable relative aspect-[2/3] bg-gray-800 rounded-xl overflow-hidden cursor-pointer transition-all duration-200 focus:ring-4 focus:ring-blue-500 scale-100 focus:scale-105 z-10 shadow-xl",children:[c.poster_path?s.jsx("img",{src:sn(c),loading:"lazy",className:"w-full h-full object-cover"}):s.jsx("div",{className:"w-full h-full flex items-center justify-center",children:"?"}),c.vote_average>0&&s.jsxs("div",{className:"absolute top-2 right-2 bg-black/70 px-2 py-1 rounded text-xs font-bold text-white",children:["‚òÖ ",c.vote_average.toFixed(1)]}),s.jsxs("div",{className:"absolute bottom-0 inset-x-0 bg-gradient-to-t from-black via-black/80 to-transparent p-3 pt-8 text-left",children:[s.jsx("div",{className:"text-white font-bold text-sm truncate",children:c.title||c.name}),s.jsx("div",{className:"text-gray-400 text-xs truncate",children:c.character?`–∫–∞–∫ ${c.character}`:c.job||"–ê–∫—Ç—ë—Ä"})]})]})},_y=({personId:c,onBack:r,onSelectMovie:d})=>{const[o,g]=M.useState(null),[y,x]=M.useState([]),[N,A]=M.useState(!0),{ref:b}=te("person-detail"),H=te("person");return M.useEffect(()=>{const U=async()=>{r()},L=tr.addListener("backButton",U);return()=>{L.then(J=>J.remove())}},[r]),M.useEffect(()=>{if(!c)return;(async()=>{A(!0);try{const L=typeof c=="object"?c.id:c,[J,se]=await Promise.all([Yg(L),Gg(L)]);g(J),x(se.cast||[])}catch(L){console.error("Failed to load person details:",L)}finally{A(!1)}})()},[c]),N?s.jsx("div",{className:"fixed inset-0 z-50 bg-[#141414] flex items-center justify-center",children:s.jsx("div",{className:"w-12 h-12 border-4 border-blue-500/30 border-t-blue-500 rounded-full animate-spin"})}):o?s.jsx("div",{ref:b,className:"fixed inset-0 z-50 bg-[#141414] animate-fade-in overflow-y-auto custom-scrollbar",children:s.jsxs("div",{className:"min-h-full relative p-8",children:[s.jsx("div",{className:"pb-8 z-[60] relative",children:s.jsxs("button",{ref:H,onClick:r,className:"focusable px-6 py-3 bg-gray-800 hover:bg-gray-700 text-white font-bold rounded-xl flex items-center gap-2 transition-all focus:ring-4 focus:ring-blue-500 scale-100 focus:scale-105 shadow-xl",autoFocus:!0,children:[s.jsx("span",{className:"text-xl",children:"‚Üê"}),"–ù–∞–∑–∞–¥"]})}),s.jsxs("div",{className:"flex flex-col md:flex-row gap-8 pt-4",children:[s.jsx("div",{className:"flex-shrink-0 mx-auto md:mx-0",children:s.jsx("div",{className:"w-64 h-96 rounded-xl overflow-hidden shadow-2xl bg-gray-800",children:o.profile_path?s.jsx("img",{src:da(o.profile_path,"h632"),className:"w-full h-full object-cover"}):s.jsx("div",{className:"w-full h-full flex items-center justify-center text-6xl",children:"üë§"})})}),s.jsxs("div",{className:"flex-1 text-white",children:[s.jsx("h1",{className:"text-4xl font-bold mb-2",children:o.name}),s.jsxs("div",{className:"text-gray-400 mb-6 flex gap-4",children:[o.birthday&&s.jsxs("span",{children:["üéÇ ",o.birthday]}),o.place_of_birth&&s.jsxs("span",{children:["üìç ",o.place_of_birth]})]}),s.jsx("h3",{className:"text-xl font-bold mb-2",children:"–ë–∏–æ–≥—Ä–∞—Ñ–∏—è"}),s.jsx("p",{className:"text-gray-300 leading-relaxed max-w-3xl text-sm md:text-base",children:o.biography||"–ë–∏–æ–≥—Ä–∞—Ñ–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç."})]})]}),s.jsxs("div",{className:"mt-12 pb-20",children:[s.jsxs("h2",{className:"text-2xl font-bold text-white mb-6",children:["–§–∏–ª—å–º–æ–≥—Ä–∞—Ñ–∏—è (",y.length,")"]}),s.jsx("div",{className:"grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 gap-6",onKeyDown:U=>{if(U.key==="ArrowUp"){const L=document.activeElement,J=Array.from(U.currentTarget.querySelectorAll("button.focusable"));if(J.indexOf(L)===-1)return;const ue=L.getBoundingClientRect();J.some(ce=>ce.getBoundingClientRect().bottom<=ue.top+10)||(U.preventDefault(),U.stopPropagation(),H.current?.focus())}},children:y.map((U,L)=>s.jsx(wy,{item:U,onClick:()=>d(U)},`${U.id}-${L}`))})]})]})}):null},Ay=({onSelect:c,isOpen:r=!1,onClose:d})=>{const o=Array.from({length:47},(H,U)=>2026-U),g=[{id:"close",icon:"‚ùå",label:"–ó–∞–∫—Ä—ã—Ç—å"},{id:"search",icon:"üîç",label:"–ü–æ–∏—Å–∫"},{id:"filter_year_2025",icon:"üé¨",label:"–ù–æ–≤—ã–µ —Ñ–∏–ª—å–º—ã 2025",type:"year",year:2025},{id:"tv_new",icon:"üì∫",label:"–ù–æ–≤—ã–µ —Å–µ—Ä–∏–∞–ª—ã",categoryId:"tv"},{id:"cartoons",icon:"üé®",label:"–ú—É–ª—å—Ç—Ñ–∏–ª—å–º—ã",categoryId:"genre_16"},{id:"anime",icon:"üç•",label:"–ê–Ω–∏–º–µ",categoryId:"genre_16"},{id:"top_rated",icon:"‚≠ê",label:"–õ—É—á—à–∏–µ —Ñ–∏–ª—å–º—ã",categoryId:"top"},{id:"favorites",icon:"‚ù§Ô∏è",label:"–ò–∑–±—Ä–∞–Ω–Ω–æ–µ"},{id:"history",icon:"üïí",label:"–ò—Å—Ç–æ—Ä–∏—è"},{id:"ai_picks",icon:"ü§ñ",label:"–ü–æ–¥–±–æ—Ä–∫–∏ AI"}],y=M.useRef(null),[x,N]=M.useState(!1),A=()=>N(!0),b=H=>{y.current?.contains(H.relatedTarget)||N(!1)};return s.jsxs("div",{ref:y,className:`
                fixed left-0 top-0 bottom-0 z-40 bg-black/95 border-r border-white/10
                transition-all duration-300 ease-out flex flex-col py-6
                ${r?"w-64 translate-x-0 shadow-2xl":"w-0 -translate-x-full overflow-hidden"}
            `,onFocus:A,onBlur:b,onMouseEnter:()=>N(!0),onMouseLeave:()=>N(!1),children:[s.jsx("div",{className:"mb-6 px-0 flex justify-center sticky top-0 bg-black z-10 w-full",children:s.jsx("span",{className:"text-2xl",children:"üåÄ"})}),s.jsxs("div",{className:"flex-1 overflow-y-auto overflow-x-hidden scrollbar-hide px-2",children:[g.map(H=>s.jsx(v0,{item:H,expanded:x,onClick:()=>{H.id==="close"?d?.():c(H)}},H.id)),s.jsx("div",{className:"h-px bg-white/10 my-4 mx-2"}),o.map(H=>s.jsx(v0,{item:{id:H,icon:"üìÖ",label:H},expanded:x,onClick:()=>c({id:`year_${H}`,type:"year",year:H,label:`${H} –≥–æ–¥`})},H))]})]})},v0=({item:c,expanded:r,onClick:d})=>{const o=te("sidebar");return s.jsxs("button",{ref:o,className:"focusable flex items-center rounded-lg mb-2 p-3 w-full text-left transition-all duration-200 text-gray-400 hover:text-white focus:bg-white focus:text-black focus:scale-105",onClick:d,children:[s.jsx("span",{className:"text-xl min-w-[24px] text-center",children:c.icon}),s.jsx("span",{className:`
                ml-4 font-medium whitespace-nowrap overflow-hidden transition-opacity duration-200
                ${r?"opacity-100":"opacity-0 w-0"}
            `,children:c.label})]})},zy=({activeMovie:c,setActiveMovie:r,activePerson:d,setActivePerson:o,activeCategory:g,setActiveCategory:y,showSidebar:x,setShowSidebar:N,onSearch:A,onClose:b})=>{const[H,U]=M.useState({}),[L,J]=M.useState(!0),[se,ue]=M.useState(null),[re,ce]=M.useState(null),[ie,I]=M.useState(null),[de,ge]=M.useState([]),ae=te("main");M.useEffect(()=>{(async()=>{try{J(!0);const he=await fy();U(he);const w=Object.values(he).filter(Q=>Q.items?.length>0);ge(w),w[0]?.items?.[0]&&I(w[0].items[0])}catch(he){console.error(he),ue(he.message||"Failed to load content")}finally{J(!1)}})()},[]),M.useEffect(()=>{!c&&!d&&!g&&ie&&ce(T0(ie))},[ie,c,d,g]);const X=k=>r(k),F=k=>{r(null),o(k)},Ee=(k,he="movie")=>{r(null),y({id:`genre-${k.id}`,name:k.name,icon:"üè∑Ô∏è",fetcher:w=>h0(k.id,he,w)})},je=k=>{const he=H[k];he&&y(he)},Ne=k=>{if(k.id==="search")A?.("");else if(k.type==="year")y({id:`year_${k.year}`,name:`${k.year} –≥–æ–¥`,icon:"üìÖ",fetcher:he=>We(`/discover/movie?primary_release_year=${k.year}&sort_by=popularity.desc&include_adult=false&language=ru-RU&page=${he}`)});else if(k.categoryId?.startsWith("genre_")){const he=parseInt(k.categoryId.split("_")[1]);y({id:he,name:k.label,type:"movie",fetcher:w=>h0(he,"movie",w)})}else k.categoryId&&je(k.categoryId);N(!1)};return c?s.jsx(Ty,{item:c,onBack:()=>r(null),onSearch:A,onSelect:r,onSelectPerson:F,onSelectGenre:Ee}):d?s.jsx(_y,{personId:d.id||d,onBack:()=>o(null),onSelectMovie:r}):g?s.jsx(hy,{customCategory:g,onBack:()=>y(null),onItemClick:r,onFocusChange:I}):s.jsxs("div",{className:"flex h-full w-full bg-[#141414] overflow-hidden",children:[s.jsx(Ay,{isOpen:x,onSelect:Ne,onClose:()=>N(!1)}),s.jsxs("div",{className:`flex-1 relative transition-all duration-300 ${x?"opacity-50 blur-sm":""}`,children:[s.jsx("div",{className:"absolute inset-0 bg-gradient-to-b from-gray-900 via-[#141414] to-[#141414]"}),s.jsxs("div",{className:"relative z-10 pt-4 pb-20 px-8 h-full overflow-y-auto custom-scrollbar",children:[ie&&!L&&s.jsxs("div",{className:"px-4 mb-10 max-w-2xl",children:[s.jsx("h1",{className:"text-4xl font-bold text-white mb-2 drop-shadow-lg",children:uu(ie)}),s.jsxs("div",{className:"flex items-center gap-4 mb-4",children:[ie.vote_average>0&&s.jsxs("span",{className:"bg-green-600 px-2 py-0.5 rounded font-bold text-xs text-white",children:["‚òÖ ",ie.vote_average.toFixed(1)]}),ie.release_date&&s.jsx("span",{className:"text-gray-300",children:(ie.release_date||ie.first_air_date)?.substring(0,4)})]}),s.jsx("p",{className:"text-gray-300 line-clamp-3 text-lg leading-relaxed",children:ie.overview})]}),!L&&de.map(k=>s.jsx(_0,{title:k.name,items:k.items,categoryId:k.id,onItemClick:X,onFocusChange:I,onMoreClick:je},k.id))]}),!x&&s.jsx("button",{ref:ae,onClick:()=>N(!0),className:"focusable fixed top-4 left-4 z-50 p-3 bg-gray-800 focus:bg-blue-600 rounded-full text-white shadow-xl transition-all",children:"‚ò∞"})]})]})},My=cn("TVPlayer"),Dy=[{id:"all",name:"–í—Å–µ",icon:"üìö"},{id:"movie",name:"–§–∏–ª—å–º—ã",icon:"üé¨"},{id:"series",name:"–°–µ—Ä–∏–∞–ª—ã",icon:"üì∫"},{id:"music",name:"–ú—É–∑—ã–∫–∞",icon:"üéµ"},{id:"other",name:"–î—Ä—É–≥–æ–µ",icon:"üìÅ"}],Cy=({cat:c,active:r,onClick:d})=>{const o=te("main");return s.jsxs("button",{ref:o,onClick:d,className:`
        focusable px-4 py-2 rounded-full text-sm font-medium whitespace-nowrap transition-all
        focus:ring-2 focus:ring-blue-400 focus:ring-offset-2 focus:ring-offset-[#141414] focus:outline-none
        ${r?"bg-blue-600 text-white":"bg-gray-800 text-gray-400 hover:bg-gray-700"}
      `,children:[c.icon," ",c.name]})},Oy=({sort:c,active:r,onClick:d})=>{const o=te("main");return s.jsx("button",{ref:o,onClick:d,className:`
        focusable px-3 py-1 rounded transition-all
        focus:ring-2 focus:ring-blue-400 focus:outline-none
        ${r?"bg-gray-700 text-white":"bg-gray-800/50 text-gray-500 hover:text-white"}
      `,children:c.label})};function Ry(){const[c,r]=M.useState(()=>yl.isNativePlatform()?localStorage.getItem("serverUrl")||"http://192.168.1.70:3000":""),[d,o]=M.useState(localStorage.getItem("tmdbProxyUrl")||"https://super-sea-46c7.wakiseliguluseli17713.workers.dev"),[g,y]=M.useState([]),[x,N]=M.useState(""),[A,b]=M.useState(!1),[H,U]=M.useState(null),[L,J]=M.useState(!1),[se,ue]=M.useState("general"),[re,ce]=M.useState(!1),[ie,I]=M.useState(null),[de,ge]=M.useState(null);M.useRef(!1);const[ae,X]=M.useState("ok"),[F,Ee]=M.useState(null),[je,Ne]=M.useState(null),[k,he]=M.useState(localStorage.getItem("sortBy")||"name"),[w,Q]=M.useState("all"),[S,O]=M.useState(!1),[V,q]=M.useState(""),[Y,m]=M.useState([]),[_,C]=M.useState({}),[G,K]=M.useState(!1),[le,P]=M.useState(!1),[Re,Ae]=M.useState(()=>{try{return JSON.parse(localStorage.getItem("lastPlayed"))||null}catch{return null}}),[Je,pt]=M.useState("home"),[ot,vl]=M.useState(null),[Fe,Ql]=M.useState(null),[Zt,rn]=M.useState(null),[bl,ma]=M.useState(!1),on=M.useCallback(()=>{ie?I(null):L?J(!1):S?(O(!1),m([]),C({})):bl?ma(!1):ot?vl(null):Fe?Ql(null):Zt?rn(null):Je==="home"?pt("list"):tr.exitApp()},[ie,L,S,bl,ot,Fe,Zt,Je]),{setActiveZone:ft}=Xg(on),jc=te("main"),Nc=te("main"),ct=te("main");te("main"),te("main");const Tc=te("main"),cu=te("main"),iu=te("main","list-search-btn"),ha=te("main");M.useEffect(()=>{ft(L?"settings":ie?"modal":S?"search":le?"auto-download":bl?"sidebar":ot?"detail":Fe?"person":Zt?"category":"main")},[L,ie,S,le,ot,Fe,Zt,bl,ft]);const Wt=M.useCallback(async()=>{const Z=c||"";try{if(!Z)return;const ye=await fetch(`${Z}/api/status`);if(ye.ok){const Be=await ye.json();y(Be.torrents||[]),X("ok")}else X("degraded")}catch{X("error")}},[c]);M.useEffect(()=>{Wt();const Z=setInterval(Wt,5e3);return()=>clearInterval(Z)},[Wt]);const su=async Z=>{if(Z.preventDefault(),!!x)try{(await fetch(`${c}/api/add`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({magnet:x})})).ok?(N(""),ce(!1),Wt()):alert("Error adding torrent")}catch{alert("Network error")}finally{b(!1)}},wc=async Z=>{if(confirm("–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç —Ç–æ—Ä—Ä–µ–Ω—Ç –∏ —Ñ–∞–π–ª—ã?"))try{(await fetch(`${c}/api/delete/${Z}`,{method:"DELETE"})).ok&&(I(null),Wt())}catch{alert("Error deleting")}},ga=M.useCallback(async(Z,ye,Be)=>{try{let Yt="";try{const _t=c.trim(),Mc=_t.includes("://")?_t:`http://${_t}`;Yt=new URL(Mc).host}catch{Yt=c}const Vt=`${c.replace(/\/$/,"")}/stream/${Z}/${ye}`;console.log("[DEBUG] Final Play URL:",Vt),localStorage.setItem("lastPlayed",JSON.stringify({infoHash:Z,torrentName:g.find(_t=>_t.infoHash===Z)?.name,fileIndex:ye,fileName:Be})),await My.play({url:Vt,title:Be})}catch(Yt){console.error("Play error:",Yt),alert("Error starting playback")}},[c,g]),Zl=M.useCallback(async Z=>{const ye=Z.files?.filter(Be=>/\.(mp4|mkv|avi|mov|webm)$/i.test(Be.name))||[];ye.length!==0&&ga(Z.infoHash,ye[0].index,ye[0].name)},[ga]),it=(Z,ye)=>{const Yt=`${c.replace(/\/$/,"")}/stream/${Z}/${ye}`;navigator.clipboard.writeText(Yt).then(()=>alert("URL copied"))},Lt=async Z=>{if(!(!Z||!Z.trim())){K(!0),m([]),C({});try{const ye=await fetch(`${c}/api/v2/search?query=${encodeURIComponent(Z)}&limit=100`);if(ye.ok){const Be=await ye.json();m(Be.items||[]),C(Be.meta?.providers||{})}}catch(ye){console.error("Search error:",ye)}finally{K(!1)}}},st=async(Z,ye)=>{b(!0);try{(await fetch(`${c}/api/add`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({magnet:Z})})).ok&&(m([]),C({}),O(!1),pt("list"),Wt(),setTimeout(()=>un.recoverFocus("main"),100))}catch(Be){console.error(Be)}finally{b(!1)}},_c=Z=>{he(Z),localStorage.setItem("sortBy",Z)},Ac=(Z,ye)=>{r(Z),ye&&localStorage.setItem("serverUrl",Z)},zc=(Z,ye)=>{o(Z),ye&&localStorage.setItem("tmdbProxyUrl",Z)},ya=Z=>{const Be=(Z.files||[]).filter(Yt=>/\.(mp4|mkv|avi|webm|mov)$/i.test(Yt.name));return Be.length>5?"series":Be.length>0?"movie":"other"},Vl=M.useMemo(()=>w==="all"?g:g.filter(Z=>ya(Z)===w),[g,w]),Kl=M.useMemo(()=>[...Vl].sort((Z,ye)=>{if(k==="name")return(Z.name||"").localeCompare(ye.name||"");if(k==="size"){const Be=Z.files?.reduce((kl,Vt)=>kl+(Vt.length||0),0)||0;return(ye.files?.reduce((kl,Vt)=>kl+(Vt.length||0),0)||0)-Be}return k==="peers"?(ye.numPeers||0)-(Z.numPeers||0):0}),[Vl,k]);return ae==="circuit_open"||ae==="error"?s.jsx(Vg,{status:ae,retryAfter:je,onRetry:Wt}):s.jsxs("div",{className:"h-screen w-screen bg-[#141414] text-white font-sans selection:bg-red-500 selection:text-white flex flex-col overflow-hidden",children:[s.jsxs("div",{className:`flex-shrink-0 bg-[#141414]/90 backdrop-blur-md px-6 py-4 flex justify-between items-center shadow-lg border-b border-gray-800 transition-all duration-300 ${Je==="home"&&!ot&&!Fe&&!Zt?"ml-20":""}`,children:[s.jsx("h1",{className:"text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-500 to-purple-500",children:"PWA-TorServe"}),s.jsxs("div",{className:"flex gap-3 items-center",children:[s.jsxs("div",{className:"flex bg-gray-800 rounded-full p-1",children:[s.jsx("button",{ref:jc,tabIndex:"0",onClick:()=>{pt("home"),vl(null),Ql(null),rn(null)},className:`focusable px-3 py-1.5 rounded-full text-sm font-medium transition-all ${Je==="home"?"bg-blue-600 text-white":"text-gray-400 hover:text-white"}`,children:"üè†"}),s.jsx("button",{ref:Nc,tabIndex:"0",onClick:()=>{pt("list"),O(!1)},className:`focusable px-3 py-1.5 rounded-full text-sm font-medium transition-all ${Je==="list"?"bg-blue-600 text-white":"text-gray-400 hover:text-white"}`,children:"üìö"})]}),s.jsx(Kg,{ref:Tc,status:ae,onDiagnosticsClick:()=>{ue("status"),J(!0)}}),s.jsx("button",{ref:ct,tabIndex:"0",onClick:()=>P(!0),className:"focusable p-2 hover:bg-gray-800 rounded-full transition-colors",title:"–ê–≤—Ç–æ-–∑–∞–≥—Ä—É–∑–∫–∞",children:"üì∫"})]})]}),le&&s.jsx(cy,{serverUrl:c,torrents:g,onClose:()=>P(!1)}),ae==="degraded"&&s.jsx(Zg,{lastStateChange:F}),L&&s.jsx($g,{serverUrl:c,onServerUrlChange:Ac,tmdbProxyUrl:d,onTmdbProxyUrlChange:zc,torrents:g,initialTab:se,onClose:()=>J(!1)}),s.jsxs("div",{className:"flex-1 overflow-hidden relative",children:[Je==="home"&&s.jsx(zy,{activeMovie:ot,setActiveMovie:vl,activePerson:Fe,setActivePerson:Ql,activeCategory:Zt,setActiveCategory:rn,showSidebar:bl,setShowSidebar:ma,onSearch:Z=>{const ye=Z||V;q(ye),pt("list"),O(!0),Lt(ye)},onClose:()=>pt("list")}),Je==="list"&&s.jsxs("div",{className:"h-full overflow-y-auto px-6 py-4 custom-scrollbar",children:[Re?.torrentName&&g.find(Z=>Z.infoHash===Re.infoHash)&&s.jsx("div",{className:"mb-6 bg-gradient-to-r from-purple-900/50 to-blue-900/50 border border-purple-500/30 rounded-xl p-4",children:s.jsxs("div",{className:"flex items-center justify-between",children:[s.jsxs("div",{className:"flex-1 min-w-0",children:[s.jsx("div",{className:"text-xs text-purple-300 uppercase tracking-wide mb-1",children:"‚ñ∂ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –ø—Ä–æ—Å–º–æ—Ç—Ä"}),s.jsx("div",{className:"text-white font-bold truncate",children:fa(Re.torrentName)}),s.jsx("div",{className:"text-gray-400 text-sm truncate",children:fa(Re.fileName)})]}),s.jsx("button",{ref:cu,tabIndex:"0",onClick:()=>ga(Re.infoHash,Re.fileIndex,Re.fileName),className:"focusable ml-4 bg-purple-600 hover:bg-purple-500 px-5 py-3 rounded-lg font-bold text-white flex items-center gap-2 transition-colors focus:ring-4 focus:ring-purple-400",children:"‚ñ∂ Play"})]})}),s.jsxs("div",{className:"flex justify-between items-center mb-4",children:[s.jsx("h2",{className:"text-xl font-semibold text-gray-200",children:"–ú–æ–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç—ã"}),s.jsxs("div",{className:"flex gap-2",children:[s.jsx("button",{ref:iu,tabIndex:"0",onClick:()=>O(!S),className:"focusable bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded-full text-sm font-bold transition-transform hover:scale-105 focus:ring-4 focus:ring-purple-400",children:"üîç –ü–æ–∏—Å–∫"}),!re&&s.jsx("button",{ref:ha,tabIndex:"0",onClick:()=>ce(!0),className:"focusable bg-gray-800 hover:bg-gray-700 px-4 py-2 rounded-full text-sm font-bold border border-gray-600 transition-transform hover:scale-105 focus:ring-4 focus:ring-gray-400",children:"+ Magnet"})]})]}),S&&s.jsx(ay,{searchQuery:V,onSearchQueryChange:q,onSearch:Lt,onClose:()=>{O(!1),m([]),C({})},onAddTorrent:st,searchResults:Y,searchLoading:G,providers:_}),re&&s.jsx("form",{onSubmit:su,className:"mb-6",children:s.jsxs("div",{className:"flex gap-2",children:[s.jsx("input",{value:x,onChange:Z=>N(Z.target.value),placeholder:"–í—Å—Ç–∞–≤—å—Ç–µ Magnet-—Å—Å—ã–ª–∫—É...",className:"flex-1 bg-gray-800 border border-gray-700 rounded-lg px-4 py-3 focus:ring-2 focus:ring-blue-500 outline-none"}),s.jsx("button",{type:"submit",disabled:A||!x,className:"bg-blue-600 px-6 py-3 rounded-lg font-bold hover:bg-blue-700 disabled:opacity-50",children:A?"...":"Add"}),s.jsx("button",{type:"button",onClick:()=>ce(!1),className:"bg-gray-800 px-4 rounded-lg",children:"‚úï"})]})}),H&&s.jsx("div",{className:"bg-red-900/30 border border-red-700 text-red-400 px-4 py-3 rounded-lg mb-4",children:H}),s.jsx("div",{className:"flex gap-2 mb-4 overflow-x-auto pb-3 pt-1 px-1 -mx-1",children:Dy.map(Z=>s.jsx(Cy,{cat:Z,active:w===Z.id,onClick:()=>Q(Z.id)},Z.id))}),s.jsxs("div",{className:"flex gap-2 mb-6 text-xs px-1 -mx-1",children:[s.jsx("span",{className:"text-gray-500 self-center",children:"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞:"}),[{id:"name",label:"–ò–º—è"},{id:"size",label:"–†–∞–∑–º–µ—Ä"},{id:"peers",label:"–ü–∏—Ä—ã"}].map(Z=>s.jsx(Oy,{sort:Z,active:k===Z.id,onClick:()=>_c(Z.id)},Z.id))]}),s.jsxs("div",{className:"grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4",children:[Kl.map(Z=>s.jsx(Qg,{name:Z.name,progress:Z.progress||0,peers:Z.numPeers||0,isReady:Z.isReady,size:Z.files?.reduce((ye,Be)=>ye+(Be.length||0),0)||0,downloadSpeed:Z.downloadSpeed||0,downloaded:Z.downloaded||0,eta:Z.eta||0,newFilesCount:Z.newFilesCount||0,onClick:()=>I(Z)},Z.infoHash)),Kl.length===0&&!A&&s.jsx("div",{className:"col-span-full py-20 text-center text-gray-600",children:"–í–∞—à —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç"})]})]}),ie&&s.jsx(uy,{torrent:ie,onClose:()=>I(null),onPlay:ga,onPlayAll:Zl,onCopyUrl:it,onDelete:wc}),de&&s.jsx("div",{className:"fixed inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur-sm",children:s.jsxs("div",{className:"text-center",children:[s.jsx("div",{className:"text-6xl mb-4 animate-pulse",children:"‚è≥"}),s.jsx("h2",{className:"text-xl font-bold text-white mb-2",children:"–ë—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è..."}),s.jsx("p",{className:"text-gray-400",children:de.name}),s.jsx("button",{onClick:()=>ge(null),className:"mt-6 text-gray-500",children:"–û—Ç–º–µ–Ω–∞"})]})})]})]})}class Uy extends M.Component{constructor(r){super(r),this.state={hasError:!1,error:null,errorInfo:null}}static getDerivedStateFromError(r){return{hasError:!0,error:r}}componentDidCatch(r,d){console.error("[ErrorBoundary] Caught error:",r),console.error("[ErrorBoundary] Component stack:",d?.componentStack),this.setState({errorInfo:d})}handleReload=()=>{window.location.reload()};handleReset=()=>{this.setState({hasError:!1,error:null,errorInfo:null})};render(){return this.state.hasError?s.jsx("div",{className:"min-h-screen bg-gray-900 flex items-center justify-center p-8",children:s.jsxs("div",{className:"max-w-lg w-full text-center",children:[s.jsx("div",{className:"text-8xl mb-6",children:"‚ö†Ô∏è"}),s.jsx("h1",{className:"text-3xl font-bold text-white mb-4",children:"–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫"}),s.jsxs("p",{className:"text-gray-400 text-lg mb-8",children:["–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞.",s.jsx("br",{}),"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ."]}),this.state.error&&s.jsxs("details",{className:"mb-8 text-left bg-gray-800 rounded-lg p-4",children:[s.jsx("summary",{className:"text-gray-500 cursor-pointer focus:outline-none focus:text-white",children:"–ü–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏ –æ—à–∏–±–∫–∏"}),s.jsxs("pre",{className:"mt-3 text-xs text-red-400 overflow-auto max-h-32",children:[this.state.error.toString(),this.state.errorInfo?.componentStack&&s.jsx("span",{className:"text-gray-500",children:this.state.errorInfo.componentStack})]})]}),s.jsxs("div",{className:"flex flex-col gap-4",children:[s.jsx("button",{onClick:this.handleReload,autoFocus:!0,className:`w-full bg-purple-600 text-white py-4 px-8 rounded-xl text-xl font-bold
                                           hover:bg-purple-500 transition-colors
                                           focus:ring-4 focus:ring-purple-400 focus:outline-none focus:scale-105`,children:"üîÑ –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å"}),s.jsx("button",{onClick:this.handleReset,className:`w-full bg-gray-700 text-gray-300 py-3 px-6 rounded-xl text-lg
                                           hover:bg-gray-600 transition-colors
                                           focus:ring-4 focus:ring-gray-400 focus:outline-none focus:scale-105`,children:"‚Ü©Ô∏è –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞"})]}),s.jsx("p",{className:"text-gray-600 text-sm mt-8",children:"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø—É–ª—å—Ç –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏"})]})}):this.props.children}}Wh.createRoot(document.getElementById("root")).render(s.jsx(M.StrictMode,{children:s.jsx(Uy,{children:s.jsx(Ry,{})})}));export{p0 as W};

```

---

## client/android/app/src/main/assets/public/assets/index-DmDSvY7b.css

```css
@layer properties{@supports ((-webkit-hyphens:none) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-scale-x:1;--tw-scale-y:1;--tw-scale-z:1;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-space-y-reverse:0;--tw-border-style:solid;--tw-gradient-position:initial;--tw-gradient-from:#0000;--tw-gradient-via:#0000;--tw-gradient-to:#0000;--tw-gradient-stops:initial;--tw-gradient-via-stops:initial;--tw-gradient-from-position:0%;--tw-gradient-via-position:50%;--tw-gradient-to-position:100%;--tw-leading:initial;--tw-font-weight:initial;--tw-tracking:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial;--tw-duration:initial;--tw-ease:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-red-300:oklch(80.8% .114 19.571);--color-red-400:oklch(70.4% .191 22.216);--color-red-500:oklch(63.7% .237 25.331);--color-red-600:oklch(57.7% .245 27.325);--color-red-700:oklch(50.5% .213 27.518);--color-red-900:oklch(39.6% .141 25.723);--color-yellow-100:oklch(97.3% .071 103.193);--color-yellow-300:oklch(90.5% .182 98.111);--color-yellow-400:oklch(85.2% .199 91.936);--color-yellow-500:oklch(79.5% .184 86.047);--color-yellow-600:oklch(68.1% .162 75.834);--color-yellow-700:oklch(55.4% .135 66.442);--color-yellow-900:oklch(42.1% .095 57.708);--color-green-300:oklch(87.1% .15 154.449);--color-green-400:oklch(79.2% .209 151.711);--color-green-500:oklch(72.3% .219 149.579);--color-green-600:oklch(62.7% .194 149.214);--color-green-700:oklch(52.7% .154 150.069);--color-green-900:oklch(39.3% .095 152.535);--color-blue-200:oklch(88.2% .059 254.128);--color-blue-300:oklch(80.9% .105 251.813);--color-blue-400:oklch(70.7% .165 254.624);--color-blue-500:oklch(62.3% .214 259.815);--color-blue-600:oklch(54.6% .245 262.881);--color-blue-700:oklch(48.8% .243 264.376);--color-blue-900:oklch(37.9% .146 265.522);--color-purple-300:oklch(82.7% .119 306.383);--color-purple-400:oklch(71.4% .203 305.504);--color-purple-500:oklch(62.7% .265 303.9);--color-purple-600:oklch(55.8% .288 302.321);--color-purple-700:oklch(49.6% .265 301.924);--color-purple-900:oklch(38.1% .176 304.987);--color-pink-300:oklch(82.3% .12 346.018);--color-pink-500:oklch(65.6% .241 354.308);--color-pink-900:oklch(40.8% .153 2.432);--color-gray-100:oklch(96.7% .003 264.542);--color-gray-200:oklch(92.8% .006 264.531);--color-gray-300:oklch(87.2% .01 258.338);--color-gray-400:oklch(70.7% .022 261.325);--color-gray-500:oklch(55.1% .027 264.364);--color-gray-600:oklch(44.6% .03 256.802);--color-gray-700:oklch(37.3% .034 259.733);--color-gray-800:oklch(27.8% .033 256.848);--color-gray-900:oklch(21% .034 264.665);--color-black:#000;--color-white:#fff;--spacing:.25rem;--container-md:28rem;--container-lg:32rem;--container-2xl:42rem;--container-3xl:48rem;--container-7xl:80rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-base:1rem;--text-base--line-height: 1.5 ;--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--text-xl:1.25rem;--text-xl--line-height:calc(1.75/1.25);--text-2xl:1.5rem;--text-2xl--line-height:calc(2/1.5);--text-3xl:1.875rem;--text-3xl--line-height: 1.2 ;--text-4xl:2.25rem;--text-4xl--line-height:calc(2.5/2.25);--text-5xl:3rem;--text-5xl--line-height:1;--text-6xl:3.75rem;--text-6xl--line-height:1;--text-8xl:6rem;--text-8xl--line-height:1;--font-weight-normal:400;--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;--font-weight-black:900;--tracking-wide:.025em;--tracking-wider:.05em;--tracking-widest:.1em;--leading-snug:1.375;--leading-relaxed:1.625;--radius-lg:.5rem;--radius-xl:.75rem;--radius-2xl:1rem;--drop-shadow-lg:0 4px 4px #00000026;--ease-out:cubic-bezier(0,0,.2,1);--animate-spin:spin 1s linear infinite;--animate-pulse:pulse 2s cubic-bezier(.4,0,.6,1)infinite;--animate-bounce:bounce 1s infinite;--blur-sm:8px;--blur-md:12px;--blur-xl:24px;--blur-2xl:40px;--aspect-video:16/9;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::-moz-placeholder{opacity:1}::placeholder{opacity:1}@supports (not (-webkit-appearance:-apple-pay-button)) or (contain-intrinsic-size:1px){::-moz-placeholder{color:currentColor}::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::-moz-placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){-webkit-appearance:button;-moz-appearance:button;appearance:button}::file-selector-button{-webkit-appearance:button;-moz-appearance:button;appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}}@layer components;@layer utilities{.pointer-events-none{pointer-events:none}.visible{visibility:visible}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.static{position:static}.sticky{position:sticky}.inset-0{inset:calc(var(--spacing)*0)}.inset-x-0{inset-inline:calc(var(--spacing)*0)}.-top-10{top:calc(var(--spacing)*-10)}.top-0{top:calc(var(--spacing)*0)}.top-1{top:calc(var(--spacing)*1)}.top-2{top:calc(var(--spacing)*2)}.top-3{top:calc(var(--spacing)*3)}.top-4{top:calc(var(--spacing)*4)}.top-16{top:calc(var(--spacing)*16)}.-right-10{right:calc(var(--spacing)*-10)}.right-0{right:calc(var(--spacing)*0)}.right-1{right:calc(var(--spacing)*1)}.right-2{right:calc(var(--spacing)*2)}.right-3{right:calc(var(--spacing)*3)}.bottom-0{bottom:calc(var(--spacing)*0)}.bottom-10{bottom:calc(var(--spacing)*10)}.-left-10{left:calc(var(--spacing)*-10)}.left-0{left:calc(var(--spacing)*0)}.left-1{left:calc(var(--spacing)*1)}.left-4{left:calc(var(--spacing)*4)}.left-7{left:calc(var(--spacing)*7)}.z-10{z-index:10}.z-40{z-index:40}.z-50{z-index:50}.z-\[60\]{z-index:60}.col-span-2{grid-column:span 2/span 2}.col-span-full{grid-column:1/-1}.container{width:100%}@media(min-width:40rem){.container{max-width:40rem}}@media(min-width:48rem){.container{max-width:48rem}}@media(min-width:64rem){.container{max-width:64rem}}@media(min-width:80rem){.container{max-width:80rem}}@media(min-width:96rem){.container{max-width:96rem}}.-mx-1{margin-inline:calc(var(--spacing)*-1)}.mx-2{margin-inline:calc(var(--spacing)*2)}.mx-4{margin-inline:calc(var(--spacing)*4)}.mx-auto{margin-inline:auto}.-my-2{margin-block:calc(var(--spacing)*-2)}.-my-4{margin-block:calc(var(--spacing)*-4)}.my-4{margin-block:calc(var(--spacing)*4)}.mt-1{margin-top:calc(var(--spacing)*1)}.mt-1\.5{margin-top:calc(var(--spacing)*1.5)}.mt-2{margin-top:calc(var(--spacing)*2)}.mt-3{margin-top:calc(var(--spacing)*3)}.mt-4{margin-top:calc(var(--spacing)*4)}.mt-6{margin-top:calc(var(--spacing)*6)}.mt-8{margin-top:calc(var(--spacing)*8)}.mt-12{margin-top:calc(var(--spacing)*12)}.mt-auto{margin-top:auto}.mb-1{margin-bottom:calc(var(--spacing)*1)}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-3{margin-bottom:calc(var(--spacing)*3)}.mb-4{margin-bottom:calc(var(--spacing)*4)}.mb-6{margin-bottom:calc(var(--spacing)*6)}.mb-8{margin-bottom:calc(var(--spacing)*8)}.mb-10{margin-bottom:calc(var(--spacing)*10)}.ml-1{margin-left:calc(var(--spacing)*1)}.ml-2{margin-left:calc(var(--spacing)*2)}.ml-4{margin-left:calc(var(--spacing)*4)}.ml-20{margin-left:calc(var(--spacing)*20)}.line-clamp-1{-webkit-line-clamp:1;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}.line-clamp-2{-webkit-line-clamp:2;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}.line-clamp-3{-webkit-line-clamp:3;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}.line-clamp-4{-webkit-line-clamp:4;-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}.block{display:block}.flex{display:flex}.grid{display:grid}.hidden{display:none}.aspect-\[2\/3\]{aspect-ratio:2/3}.aspect-video{aspect-ratio:var(--aspect-video)}.h-1\.5{height:calc(var(--spacing)*1.5)}.h-3{height:calc(var(--spacing)*3)}.h-6{height:calc(var(--spacing)*6)}.h-8{height:calc(var(--spacing)*8)}.h-10{height:calc(var(--spacing)*10)}.h-12{height:calc(var(--spacing)*12)}.h-20{height:calc(var(--spacing)*20)}.h-24{height:calc(var(--spacing)*24)}.h-32{height:calc(var(--spacing)*32)}.h-36{height:calc(var(--spacing)*36)}.h-96{height:calc(var(--spacing)*96)}.h-full{height:100%}.h-px{height:1px}.h-screen{height:100vh}.max-h-32{max-height:calc(var(--spacing)*32)}.max-h-40{max-height:calc(var(--spacing)*40)}.max-h-48{max-height:calc(var(--spacing)*48)}.max-h-\[28vh\]{max-height:28vh}.max-h-\[50vh\]{max-height:50vh}.max-h-\[85vh\]{max-height:85vh}.max-h-\[90vh\]{max-height:90vh}.min-h-0{min-height:calc(var(--spacing)*0)}.min-h-full{min-height:100%}.min-h-screen{min-height:100vh}.w-0{width:calc(var(--spacing)*0)}.w-3{width:calc(var(--spacing)*3)}.w-5{width:calc(var(--spacing)*5)}.w-6{width:calc(var(--spacing)*6)}.w-8{width:calc(var(--spacing)*8)}.w-10{width:calc(var(--spacing)*10)}.w-12{width:calc(var(--spacing)*12)}.w-14{width:calc(var(--spacing)*14)}.w-24{width:calc(var(--spacing)*24)}.w-32{width:calc(var(--spacing)*32)}.w-64{width:calc(var(--spacing)*64)}.w-\[130px\]{width:130px}.w-\[220px\]{width:220px}.w-full{width:100%}.w-screen{width:100vw}.max-w-2xl{max-width:var(--container-2xl)}.max-w-3xl{max-width:var(--container-3xl)}.max-w-7xl{max-width:var(--container-7xl)}.max-w-\[120px\]{max-width:120px}.max-w-lg{max-width:var(--container-lg)}.max-w-md{max-width:var(--container-md)}.min-w-0{min-width:calc(var(--spacing)*0)}.min-w-\[24px\]{min-width:24px}.flex-1{flex:1}.flex-shrink-0,.shrink-0{flex-shrink:0}.-translate-x-full{--tw-translate-x:-100%;translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-x-0{--tw-translate-x:calc(var(--spacing)*0);translate:var(--tw-translate-x)var(--tw-translate-y)}.scale-100{--tw-scale-x:100%;--tw-scale-y:100%;--tw-scale-z:100%;scale:var(--tw-scale-x)var(--tw-scale-y)}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.animate-bounce{animation:var(--animate-bounce)}.animate-pulse{animation:var(--animate-pulse)}.animate-spin{animation:var(--animate-spin)}.cursor-default{cursor:default}.cursor-pointer{cursor:pointer}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.flex-col{flex-direction:column}.flex-wrap{flex-wrap:wrap}.items-center{align-items:center}.items-end{align-items:flex-end}.items-start{align-items:flex-start}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.justify-end{justify-content:flex-end}.gap-1{gap:calc(var(--spacing)*1)}.gap-2{gap:calc(var(--spacing)*2)}.gap-3{gap:calc(var(--spacing)*3)}.gap-4{gap:calc(var(--spacing)*4)}.gap-6{gap:calc(var(--spacing)*6)}.gap-8{gap:calc(var(--spacing)*8)}.gap-10{gap:calc(var(--spacing)*10)}:where(.space-y-1>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*1)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*1)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-2>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*2)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*2)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-4>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*4)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*4)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-6>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*6)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*6)*calc(1 - var(--tw-space-y-reverse)))}.gap-x-3{-moz-column-gap:calc(var(--spacing)*3);column-gap:calc(var(--spacing)*3)}.self-center{align-self:center}.truncate{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.overflow-x-auto{overflow-x:auto}.overflow-x-hidden{overflow-x:hidden}.overflow-y-auto{overflow-y:auto}.scroll-smooth{scroll-behavior:smooth}.rounded{border-radius:.25rem}.rounded-2xl{border-radius:var(--radius-2xl)}.rounded-full{border-radius:3.40282e38px}.rounded-lg{border-radius:var(--radius-lg)}.rounded-xl{border-radius:var(--radius-xl)}.border{border-style:var(--tw-border-style);border-width:1px}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-4{border-style:var(--tw-border-style);border-width:4px}.border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.border-r{border-right-style:var(--tw-border-style);border-right-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-blue-500{border-color:var(--color-blue-500)}.border-blue-500\/30{border-color:#3080ff4d}@supports (color:color-mix(in lab,red,red)){.border-blue-500\/30{border-color:color-mix(in oklab,var(--color-blue-500)30%,transparent)}}.border-gray-500\/30{border-color:#6a72824d}@supports (color:color-mix(in lab,red,red)){.border-gray-500\/30{border-color:color-mix(in oklab,var(--color-gray-500)30%,transparent)}}.border-gray-600{border-color:var(--color-gray-600)}.border-gray-600\/30{border-color:#4a55654d}@supports (color:color-mix(in lab,red,red)){.border-gray-600\/30{border-color:color-mix(in oklab,var(--color-gray-600)30%,transparent)}}.border-gray-700{border-color:var(--color-gray-700)}.border-gray-800{border-color:var(--color-gray-800)}.border-green-500{border-color:var(--color-green-500)}.border-green-500\/30{border-color:#00c7584d}@supports (color:color-mix(in lab,red,red)){.border-green-500\/30{border-color:color-mix(in oklab,var(--color-green-500)30%,transparent)}}.border-green-500\/40{border-color:#00c75866}@supports (color:color-mix(in lab,red,red)){.border-green-500\/40{border-color:color-mix(in oklab,var(--color-green-500)40%,transparent)}}.border-green-700{border-color:var(--color-green-700)}.border-pink-500\/30{border-color:#f6339a4d}@supports (color:color-mix(in lab,red,red)){.border-pink-500\/30{border-color:color-mix(in oklab,var(--color-pink-500)30%,transparent)}}.border-purple-400{border-color:var(--color-purple-400)}.border-purple-500\/30{border-color:#ac4bff4d}@supports (color:color-mix(in lab,red,red)){.border-purple-500\/30{border-color:color-mix(in oklab,var(--color-purple-500)30%,transparent)}}.border-purple-600\/50{border-color:#9810fa80}@supports (color:color-mix(in lab,red,red)){.border-purple-600\/50{border-color:color-mix(in oklab,var(--color-purple-600)50%,transparent)}}.border-red-500\/30{border-color:#fb2c364d}@supports (color:color-mix(in lab,red,red)){.border-red-500\/30{border-color:color-mix(in oklab,var(--color-red-500)30%,transparent)}}.border-red-500\/40{border-color:#fb2c3666}@supports (color:color-mix(in lab,red,red)){.border-red-500\/40{border-color:color-mix(in oklab,var(--color-red-500)40%,transparent)}}.border-red-700{border-color:var(--color-red-700)}.border-red-900\/30{border-color:#82181a4d}@supports (color:color-mix(in lab,red,red)){.border-red-900\/30{border-color:color-mix(in oklab,var(--color-red-900)30%,transparent)}}.border-transparent{border-color:#0000}.border-white\/5{border-color:#ffffff0d}@supports (color:color-mix(in lab,red,red)){.border-white\/5{border-color:color-mix(in oklab,var(--color-white)5%,transparent)}}.border-white\/10{border-color:#ffffff1a}@supports (color:color-mix(in lab,red,red)){.border-white\/10{border-color:color-mix(in oklab,var(--color-white)10%,transparent)}}.border-yellow-500{border-color:var(--color-yellow-500)}.border-yellow-500\/30{border-color:#edb2004d}@supports (color:color-mix(in lab,red,red)){.border-yellow-500\/30{border-color:color-mix(in oklab,var(--color-yellow-500)30%,transparent)}}.border-yellow-500\/40{border-color:#edb20066}@supports (color:color-mix(in lab,red,red)){.border-yellow-500\/40{border-color:color-mix(in oklab,var(--color-yellow-500)40%,transparent)}}.border-yellow-700{border-color:var(--color-yellow-700)}.border-t-blue-500{border-top-color:var(--color-blue-500)}.bg-\[\#1a1a1a\]{background-color:#1a1a1a}.bg-\[\#141414\]{background-color:#141414}.bg-\[\#141414\]\/90{background-color:#141414e6}.bg-\[\#181818\]{background-color:#181818}.bg-black{background-color:var(--color-black)}.bg-black\/20{background-color:#0003}@supports (color:color-mix(in lab,red,red)){.bg-black\/20{background-color:color-mix(in oklab,var(--color-black)20%,transparent)}}.bg-black\/40{background-color:#0006}@supports (color:color-mix(in lab,red,red)){.bg-black\/40{background-color:color-mix(in oklab,var(--color-black)40%,transparent)}}.bg-black\/50{background-color:#00000080}@supports (color:color-mix(in lab,red,red)){.bg-black\/50{background-color:color-mix(in oklab,var(--color-black)50%,transparent)}}.bg-black\/60{background-color:#0009}@supports (color:color-mix(in lab,red,red)){.bg-black\/60{background-color:color-mix(in oklab,var(--color-black)60%,transparent)}}.bg-black\/70{background-color:#000000b3}@supports (color:color-mix(in lab,red,red)){.bg-black\/70{background-color:color-mix(in oklab,var(--color-black)70%,transparent)}}.bg-black\/80{background-color:#000c}@supports (color:color-mix(in lab,red,red)){.bg-black\/80{background-color:color-mix(in oklab,var(--color-black)80%,transparent)}}.bg-black\/90{background-color:#000000e6}@supports (color:color-mix(in lab,red,red)){.bg-black\/90{background-color:color-mix(in oklab,var(--color-black)90%,transparent)}}.bg-black\/95{background-color:#000000f2}@supports (color:color-mix(in lab,red,red)){.bg-black\/95{background-color:color-mix(in oklab,var(--color-black)95%,transparent)}}.bg-blue-600{background-color:var(--color-blue-600)}.bg-blue-600\/20{background-color:#155dfc33}@supports (color:color-mix(in lab,red,red)){.bg-blue-600\/20{background-color:color-mix(in oklab,var(--color-blue-600)20%,transparent)}}.bg-blue-900\/50{background-color:#1c398e80}@supports (color:color-mix(in lab,red,red)){.bg-blue-900\/50{background-color:color-mix(in oklab,var(--color-blue-900)50%,transparent)}}.bg-blue-900\/95{background-color:#1c398ef2}@supports (color:color-mix(in lab,red,red)){.bg-blue-900\/95{background-color:color-mix(in oklab,var(--color-blue-900)95%,transparent)}}.bg-gray-600{background-color:var(--color-gray-600)}.bg-gray-700{background-color:var(--color-gray-700)}.bg-gray-700\/50{background-color:#36415380}@supports (color:color-mix(in lab,red,red)){.bg-gray-700\/50{background-color:color-mix(in oklab,var(--color-gray-700)50%,transparent)}}.bg-gray-800{background-color:var(--color-gray-800)}.bg-gray-800\/30{background-color:#1e29394d}@supports (color:color-mix(in lab,red,red)){.bg-gray-800\/30{background-color:color-mix(in oklab,var(--color-gray-800)30%,transparent)}}.bg-gray-800\/40{background-color:#1e293966}@supports (color:color-mix(in lab,red,red)){.bg-gray-800\/40{background-color:color-mix(in oklab,var(--color-gray-800)40%,transparent)}}.bg-gray-800\/50{background-color:#1e293980}@supports (color:color-mix(in lab,red,red)){.bg-gray-800\/50{background-color:color-mix(in oklab,var(--color-gray-800)50%,transparent)}}.bg-gray-800\/60{background-color:#1e293999}@supports (color:color-mix(in lab,red,red)){.bg-gray-800\/60{background-color:color-mix(in oklab,var(--color-gray-800)60%,transparent)}}.bg-gray-900{background-color:var(--color-gray-900)}.bg-green-500{background-color:var(--color-green-500)}.bg-green-600{background-color:var(--color-green-600)}.bg-green-900\/30{background-color:#0d542b4d}@supports (color:color-mix(in lab,red,red)){.bg-green-900\/30{background-color:color-mix(in oklab,var(--color-green-900)30%,transparent)}}.bg-green-900\/40{background-color:#0d542b66}@supports (color:color-mix(in lab,red,red)){.bg-green-900\/40{background-color:color-mix(in oklab,var(--color-green-900)40%,transparent)}}.bg-green-900\/50{background-color:#0d542b80}@supports (color:color-mix(in lab,red,red)){.bg-green-900\/50{background-color:color-mix(in oklab,var(--color-green-900)50%,transparent)}}.bg-pink-900\/50{background-color:#86104380}@supports (color:color-mix(in lab,red,red)){.bg-pink-900\/50{background-color:color-mix(in oklab,var(--color-pink-900)50%,transparent)}}.bg-purple-500{background-color:var(--color-purple-500)}.bg-purple-600{background-color:var(--color-purple-600)}.bg-purple-600\/30{background-color:#9810fa4d}@supports (color:color-mix(in lab,red,red)){.bg-purple-600\/30{background-color:color-mix(in oklab,var(--color-purple-600)30%,transparent)}}.bg-purple-900\/50{background-color:#59168b80}@supports (color:color-mix(in lab,red,red)){.bg-purple-900\/50{background-color:color-mix(in oklab,var(--color-purple-900)50%,transparent)}}.bg-red-500{background-color:var(--color-red-500)}.bg-red-600{background-color:var(--color-red-600)}.bg-red-900\/10{background-color:#82181a1a}@supports (color:color-mix(in lab,red,red)){.bg-red-900\/10{background-color:color-mix(in oklab,var(--color-red-900)10%,transparent)}}.bg-red-900\/30{background-color:#82181a4d}@supports (color:color-mix(in lab,red,red)){.bg-red-900\/30{background-color:color-mix(in oklab,var(--color-red-900)30%,transparent)}}.bg-red-900\/40{background-color:#82181a66}@supports (color:color-mix(in lab,red,red)){.bg-red-900\/40{background-color:color-mix(in oklab,var(--color-red-900)40%,transparent)}}.bg-red-900\/50{background-color:#82181a80}@supports (color:color-mix(in lab,red,red)){.bg-red-900\/50{background-color:color-mix(in oklab,var(--color-red-900)50%,transparent)}}.bg-white{background-color:var(--color-white)}.bg-white\/5{background-color:#ffffff0d}@supports (color:color-mix(in lab,red,red)){.bg-white\/5{background-color:color-mix(in oklab,var(--color-white)5%,transparent)}}.bg-white\/10{background-color:#ffffff1a}@supports (color:color-mix(in lab,red,red)){.bg-white\/10{background-color:color-mix(in oklab,var(--color-white)10%,transparent)}}.bg-yellow-500{background-color:var(--color-yellow-500)}.bg-yellow-600{background-color:var(--color-yellow-600)}.bg-yellow-600\/90{background-color:#cd8900e6}@supports (color:color-mix(in lab,red,red)){.bg-yellow-600\/90{background-color:color-mix(in oklab,var(--color-yellow-600)90%,transparent)}}.bg-yellow-900\/40{background-color:#733e0a66}@supports (color:color-mix(in lab,red,red)){.bg-yellow-900\/40{background-color:color-mix(in oklab,var(--color-yellow-900)40%,transparent)}}.bg-yellow-900\/50{background-color:#733e0a80}@supports (color:color-mix(in lab,red,red)){.bg-yellow-900\/50{background-color:color-mix(in oklab,var(--color-yellow-900)50%,transparent)}}.bg-gradient-to-b{--tw-gradient-position:to bottom in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.bg-gradient-to-r{--tw-gradient-position:to right in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.bg-gradient-to-t{--tw-gradient-position:to top in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.from-black{--tw-gradient-from:var(--color-black);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-black\/90{--tw-gradient-from:#000000e6}@supports (color:color-mix(in lab,red,red)){.from-black\/90{--tw-gradient-from:color-mix(in oklab,var(--color-black)90%,transparent)}}.from-black\/90{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-blue-500{--tw-gradient-from:var(--color-blue-500);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-gray-800{--tw-gradient-from:var(--color-gray-800);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-gray-900{--tw-gradient-from:var(--color-gray-900);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-purple-900\/50{--tw-gradient-from:#59168b80}@supports (color:color-mix(in lab,red,red)){.from-purple-900\/50{--tw-gradient-from:color-mix(in oklab,var(--color-purple-900)50%,transparent)}}.from-purple-900\/50{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.via-\[\#141414\]{--tw-gradient-via:#141414;--tw-gradient-via-stops:var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-via)var(--tw-gradient-via-position),var(--tw-gradient-to)var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-via-stops)}.via-black\/50{--tw-gradient-via:#00000080}@supports (color:color-mix(in lab,red,red)){.via-black\/50{--tw-gradient-via:color-mix(in oklab,var(--color-black)50%,transparent)}}.via-black\/50{--tw-gradient-via-stops:var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-via)var(--tw-gradient-via-position),var(--tw-gradient-to)var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-via-stops)}.via-black\/80{--tw-gradient-via:#000c}@supports (color:color-mix(in lab,red,red)){.via-black\/80{--tw-gradient-via:color-mix(in oklab,var(--color-black)80%,transparent)}}.via-black\/80{--tw-gradient-via-stops:var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-via)var(--tw-gradient-via-position),var(--tw-gradient-to)var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-via-stops)}.via-transparent{--tw-gradient-via:transparent;--tw-gradient-via-stops:var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-via)var(--tw-gradient-via-position),var(--tw-gradient-to)var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-via-stops)}.to-\[\#141414\]{--tw-gradient-to:#141414;--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-black\/10{--tw-gradient-to:#0000001a}@supports (color:color-mix(in lab,red,red)){.to-black\/10{--tw-gradient-to:color-mix(in oklab,var(--color-black)10%,transparent)}}.to-black\/10{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-blue-900\/50{--tw-gradient-to:#1c398e80}@supports (color:color-mix(in lab,red,red)){.to-blue-900\/50{--tw-gradient-to:color-mix(in oklab,var(--color-blue-900)50%,transparent)}}.to-blue-900\/50{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-gray-900{--tw-gradient-to:var(--color-gray-900);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-green-500{--tw-gradient-to:var(--color-green-500);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-purple-500{--tw-gradient-to:var(--color-purple-500);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-transparent{--tw-gradient-to:transparent;--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.bg-clip-text{-webkit-background-clip:text;background-clip:text}.object-cover{-o-object-fit:cover;object-fit:cover}.p-1{padding:calc(var(--spacing)*1)}.p-2{padding:calc(var(--spacing)*2)}.p-2\.5{padding:calc(var(--spacing)*2.5)}.p-3{padding:calc(var(--spacing)*3)}.p-4{padding:calc(var(--spacing)*4)}.p-5{padding:calc(var(--spacing)*5)}.p-6{padding:calc(var(--spacing)*6)}.p-8{padding:calc(var(--spacing)*8)}.px-0{padding-inline:calc(var(--spacing)*0)}.px-1{padding-inline:calc(var(--spacing)*1)}.px-1\.5{padding-inline:calc(var(--spacing)*1.5)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-2\.5{padding-inline:calc(var(--spacing)*2.5)}.px-3{padding-inline:calc(var(--spacing)*3)}.px-4{padding-inline:calc(var(--spacing)*4)}.px-5{padding-inline:calc(var(--spacing)*5)}.px-6{padding-inline:calc(var(--spacing)*6)}.px-8{padding-inline:calc(var(--spacing)*8)}.py-0\.5{padding-block:calc(var(--spacing)*.5)}.py-1{padding-block:calc(var(--spacing)*1)}.py-1\.5{padding-block:calc(var(--spacing)*1.5)}.py-2{padding-block:calc(var(--spacing)*2)}.py-2\.5{padding-block:calc(var(--spacing)*2.5)}.py-3{padding-block:calc(var(--spacing)*3)}.py-4{padding-block:calc(var(--spacing)*4)}.py-6{padding-block:calc(var(--spacing)*6)}.py-8{padding-block:calc(var(--spacing)*8)}.py-10{padding-block:calc(var(--spacing)*10)}.py-20{padding-block:calc(var(--spacing)*20)}.pt-1{padding-top:calc(var(--spacing)*1)}.pt-2{padding-top:calc(var(--spacing)*2)}.pt-4{padding-top:calc(var(--spacing)*4)}.pt-8{padding-top:calc(var(--spacing)*8)}.pr-1{padding-right:calc(var(--spacing)*1)}.pb-1{padding-bottom:calc(var(--spacing)*1)}.pb-3{padding-bottom:calc(var(--spacing)*3)}.pb-4{padding-bottom:calc(var(--spacing)*4)}.pb-8{padding-bottom:calc(var(--spacing)*8)}.pb-10{padding-bottom:calc(var(--spacing)*10)}.pb-12{padding-bottom:calc(var(--spacing)*12)}.pb-20{padding-bottom:calc(var(--spacing)*20)}.text-center{text-align:center}.text-left{text-align:left}.font-mono{font-family:var(--font-mono)}.font-sans{font-family:var(--font-sans)}.text-2xl{font-size:var(--text-2xl);line-height:var(--tw-leading,var(--text-2xl--line-height))}.text-3xl{font-size:var(--text-3xl);line-height:var(--tw-leading,var(--text-3xl--line-height))}.text-4xl{font-size:var(--text-4xl);line-height:var(--tw-leading,var(--text-4xl--line-height))}.text-5xl{font-size:var(--text-5xl);line-height:var(--tw-leading,var(--text-5xl--line-height))}.text-6xl{font-size:var(--text-6xl);line-height:var(--tw-leading,var(--text-6xl--line-height))}.text-8xl{font-size:var(--text-8xl);line-height:var(--tw-leading,var(--text-8xl--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xl{font-size:var(--text-xl);line-height:var(--tw-leading,var(--text-xl--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.text-\[10px\]{font-size:10px}.text-\[11px\]{font-size:11px}.leading-relaxed{--tw-leading:var(--leading-relaxed);line-height:var(--leading-relaxed)}.leading-snug{--tw-leading:var(--leading-snug);line-height:var(--leading-snug)}.font-black{--tw-font-weight:var(--font-weight-black);font-weight:var(--font-weight-black)}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-normal{--tw-font-weight:var(--font-weight-normal);font-weight:var(--font-weight-normal)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.tracking-wide{--tw-tracking:var(--tracking-wide);letter-spacing:var(--tracking-wide)}.tracking-wider{--tw-tracking:var(--tracking-wider);letter-spacing:var(--tracking-wider)}.tracking-widest{--tw-tracking:var(--tracking-widest);letter-spacing:var(--tracking-widest)}.whitespace-nowrap{white-space:nowrap}.text-black{color:var(--color-black)}.text-blue-200{color:var(--color-blue-200)}.text-blue-300{color:var(--color-blue-300)}.text-blue-400{color:var(--color-blue-400)}.text-gray-100{color:var(--color-gray-100)}.text-gray-200{color:var(--color-gray-200)}.text-gray-300{color:var(--color-gray-300)}.text-gray-400{color:var(--color-gray-400)}.text-gray-500{color:var(--color-gray-500)}.text-gray-600{color:var(--color-gray-600)}.text-green-300{color:var(--color-green-300)}.text-green-400{color:var(--color-green-400)}.text-pink-300{color:var(--color-pink-300)}.text-purple-300{color:var(--color-purple-300)}.text-purple-400{color:var(--color-purple-400)}.text-red-300{color:var(--color-red-300)}.text-red-400{color:var(--color-red-400)}.text-red-500{color:var(--color-red-500)}.text-transparent{color:#0000}.text-white{color:var(--color-white)}.text-white\/50{color:#ffffff80}@supports (color:color-mix(in lab,red,red)){.text-white\/50{color:color-mix(in oklab,var(--color-white)50%,transparent)}}.text-yellow-100{color:var(--color-yellow-100)}.text-yellow-300{color:var(--color-yellow-300)}.text-yellow-400{color:var(--color-yellow-400)}.uppercase{text-transform:uppercase}.italic{font-style:italic}.placeholder-gray-500::-moz-placeholder{color:var(--color-gray-500)}.placeholder-gray-500::placeholder{color:var(--color-gray-500)}.opacity-0{opacity:0}.opacity-25{opacity:.25}.opacity-50{opacity:.5}.opacity-70{opacity:.7}.opacity-75{opacity:.75}.opacity-90{opacity:.9}.opacity-100{opacity:1}.shadow-2xl{--tw-shadow:0 25px 50px -12px var(--tw-shadow-color,#00000040);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-sm{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-xl{--tw-shadow:0 20px 25px -5px var(--tw-shadow-color,#0000001a),0 8px 10px -6px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-2{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-green-500{--tw-ring-color:var(--color-green-500)}.ring-purple-500{--tw-ring-color:var(--color-purple-500)}.blur-2xl{--tw-blur:blur(var(--blur-2xl));filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.blur-sm{--tw-blur:blur(var(--blur-sm));filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.blur-xl{--tw-blur:blur(var(--blur-xl));filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.drop-shadow-lg{--tw-drop-shadow-size:drop-shadow(0 4px 4px var(--tw-drop-shadow-color,#00000026));--tw-drop-shadow:drop-shadow(var(--drop-shadow-lg));filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.backdrop-blur-md{--tw-backdrop-blur:blur(var(--blur-md));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-blur-sm{--tw-backdrop-blur:blur(var(--blur-sm));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-colors{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-opacity{transition-property:opacity;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-transform{transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.duration-200{--tw-duration:.2s;transition-duration:.2s}.duration-300{--tw-duration:.3s;transition-duration:.3s}.duration-500{--tw-duration:.5s;transition-duration:.5s}.ease-out{--tw-ease:var(--ease-out);transition-timing-function:var(--ease-out)}.outline-none{--tw-outline-style:none;outline-style:none}.group-focus\:text-green-400:is(:where(.group):focus *){color:var(--color-green-400)}.selection\:bg-red-500 ::-moz-selection{background-color:var(--color-red-500)}.selection\:bg-red-500 ::selection{background-color:var(--color-red-500)}.selection\:bg-red-500::-moz-selection{background-color:var(--color-red-500)}.selection\:bg-red-500::selection{background-color:var(--color-red-500)}.selection\:text-white ::-moz-selection{color:var(--color-white)}.selection\:text-white ::selection{color:var(--color-white)}.selection\:text-white::-moz-selection{color:var(--color-white)}.selection\:text-white::selection{color:var(--color-white)}@media(hover:hover){.hover\:scale-105:hover{--tw-scale-x:105%;--tw-scale-y:105%;--tw-scale-z:105%;scale:var(--tw-scale-x)var(--tw-scale-y)}.hover\:bg-blue-500:hover{background-color:var(--color-blue-500)}.hover\:bg-blue-600\/30:hover{background-color:#155dfc4d}@supports (color:color-mix(in lab,red,red)){.hover\:bg-blue-600\/30:hover{background-color:color-mix(in oklab,var(--color-blue-600)30%,transparent)}}.hover\:bg-blue-700:hover{background-color:var(--color-blue-700)}.hover\:bg-gray-600:hover{background-color:var(--color-gray-600)}.hover\:bg-gray-700:hover{background-color:var(--color-gray-700)}.hover\:bg-gray-800:hover{background-color:var(--color-gray-800)}.hover\:bg-purple-500:hover{background-color:var(--color-purple-500)}.hover\:bg-purple-600\/50:hover{background-color:#9810fa80}@supports (color:color-mix(in lab,red,red)){.hover\:bg-purple-600\/50:hover{background-color:color-mix(in oklab,var(--color-purple-600)50%,transparent)}}.hover\:bg-purple-700:hover{background-color:var(--color-purple-700)}.hover\:bg-red-700:hover{background-color:var(--color-red-700)}.hover\:bg-red-900\/20:hover{background-color:#82181a33}@supports (color:color-mix(in lab,red,red)){.hover\:bg-red-900\/20:hover{background-color:color-mix(in oklab,var(--color-red-900)20%,transparent)}}.hover\:bg-white\/5:hover{background-color:#ffffff0d}@supports (color:color-mix(in lab,red,red)){.hover\:bg-white\/5:hover{background-color:color-mix(in oklab,var(--color-white)5%,transparent)}}.hover\:text-blue-400:hover{color:var(--color-blue-400)}.hover\:text-red-400:hover{color:var(--color-red-400)}.hover\:text-white:hover{color:var(--color-white)}.hover\:opacity-80:hover{opacity:.8}.hover\:opacity-100:hover{opacity:1}}.focus\:z-10:focus{z-index:10}.focus\:z-20:focus{z-index:20}.focus\:scale-105:focus{--tw-scale-x:105%;--tw-scale-y:105%;--tw-scale-z:105%;scale:var(--tw-scale-x)var(--tw-scale-y)}.focus\:border-blue-500:focus{border-color:var(--color-blue-500)}.focus\:border-purple-500:focus{border-color:var(--color-purple-500)}.focus\:bg-blue-500:focus{background-color:var(--color-blue-500)}.focus\:bg-blue-600:focus{background-color:var(--color-blue-600)}.focus\:bg-gray-700:focus{background-color:var(--color-gray-700)}.focus\:bg-purple-700:focus{background-color:var(--color-purple-700)}.focus\:bg-purple-900:focus{background-color:var(--color-purple-900)}.focus\:bg-red-400:focus{background-color:var(--color-red-400)}.focus\:bg-red-600:focus{background-color:var(--color-red-600)}.focus\:bg-white:focus{background-color:var(--color-white)}.focus\:bg-yellow-400:focus{background-color:var(--color-yellow-400)}.focus\:text-black:focus{color:var(--color-black)}.focus\:text-white:focus{color:var(--color-white)}.focus\:ring-2:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\:ring-4:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(4px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\:ring-blue-400:focus{--tw-ring-color:var(--color-blue-400)}.focus\:ring-blue-500:focus{--tw-ring-color:var(--color-blue-500)}.focus\:ring-gray-400:focus{--tw-ring-color:var(--color-gray-400)}.focus\:ring-purple-400:focus{--tw-ring-color:var(--color-purple-400)}.focus\:ring-purple-500:focus{--tw-ring-color:var(--color-purple-500)}.focus\:ring-red-300:focus{--tw-ring-color:var(--color-red-300)}.focus\:ring-white:focus{--tw-ring-color:var(--color-white)}.focus\:ring-yellow-400:focus{--tw-ring-color:var(--color-yellow-400)}.focus\:ring-offset-2:focus{--tw-ring-offset-width:2px;--tw-ring-offset-shadow:var(--tw-ring-inset,)0 0 0 var(--tw-ring-offset-width)var(--tw-ring-offset-color)}.focus\:ring-offset-\[\#141414\]:focus{--tw-ring-offset-color:#141414}.focus\:ring-offset-gray-900:focus{--tw-ring-offset-color:var(--color-gray-900)}.focus\:outline-none:focus{--tw-outline-style:none;outline-style:none}.disabled\:opacity-50:disabled{opacity:.5}@media(min-width:40rem){.sm\:grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}}@media(min-width:48rem){.md\:mx-0{margin-inline:calc(var(--spacing)*0)}.md\:block{display:block}.md\:grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}.md\:grid-cols-5{grid-template-columns:repeat(5,minmax(0,1fr))}.md\:grid-cols-\[220px_1fr\]{grid-template-columns:220px 1fr}.md\:flex-row{flex-direction:row}.md\:p-10{padding:calc(var(--spacing)*10)}.md\:text-base{font-size:var(--text-base);line-height:var(--tw-leading,var(--text-base--line-height))}}@media(min-width:64rem){.lg\:grid-cols-5{grid-template-columns:repeat(5,minmax(0,1fr))}}@media(min-width:80rem){.xl\:grid-cols-6{grid-template-columns:repeat(6,minmax(0,1fr))}}}html,body{overscroll-behavior:none;width:100vw;height:100vh;margin:0;padding:0;overflow:hidden}#root{flex-direction:column;width:100vw;height:100vh;display:flex;position:fixed;inset:0;overflow:hidden}:focus{outline:none}.focusable{outline:none;scroll-margin:120px;transition:all .2s cubic-bezier(.4,0,.2,1)}.focusable:focus{z-index:50;scale:1.05;box-shadow:0 0 0 4px #3b82f6cc,0 10px 30px #00000080}.focusable:focus:not(.absolute):not(.fixed){position:relative}.snap-container{scroll-snap-type:x mandatory;scroll-behavior:smooth;-ms-overflow-style:none;scrollbar-width:none;display:flex;overflow-x:auto}.snap-container::-webkit-scrollbar{display:none}.snap-item{scroll-snap-align:center;flex-shrink:0}.tv-card{cursor:pointer;transition:all .2s ease-out}.tv-card:focus{z-index:10;position:relative;transform:scale(1.08);box-shadow:0 0 0 4px #fff,0 8px 30px #00000080}.tv-card:hover{transform:scale(1.05)}.tv-btn-primary:focus{transform:scale(1.05);box-shadow:0 0 0 4px #22c55ecc,0 4px 20px #22c55e66}.tv-btn-danger:focus{box-shadow:0 0 0 4px #ef4444cc}.netflix-grid{grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:1.5rem;padding:1rem;display:grid}@media(min-width:1280px){.netflix-grid{grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:2rem;padding:2rem}}.home-row .overflow-x-auto{scroll-behavior:smooth;-webkit-overflow-scrolling:touch;will-change:scroll-position}.scrollbar-hide::-webkit-scrollbar{display:none}.scrollbar-hide{-ms-overflow-style:none;scrollbar-width:none}.season-card{cursor:pointer;border-radius:.5rem;transition:all .2s ease-out;position:relative;overflow:hidden;box-shadow:0 4px 6px -1px #0000001a,0 2px 4px -1px #0000000f}.season-card:focus{z-index:20;outline:none;transform:scale(1.05);box-shadow:0 0 0 4px #3b82f6cc,0 10px 15px -3px #0000001a}.season-card:focus img{opacity:1!important}.torrent-card{aspect-ratio:16/10;background:linear-gradient(135deg,#1e293b,#0f172a);border:2px solid #0000;border-radius:12px;flex-direction:column;justify-content:space-between;padding:1.25rem;display:flex;position:relative;overflow:hidden}.torrent-card:before{content:"";opacity:0;background:linear-gradient(90deg,#3b82f6,#8b5cf6);height:4px;transition:opacity .2s;position:absolute;top:0;left:0;right:0}.torrent-card:focus:before,.torrent-card:hover:before{opacity:1}.torrent-card-title{-webkit-line-clamp:2;line-clamp:2;-webkit-box-orient:vertical;font-size:1.25rem;font-weight:600;line-height:1.3;display:-webkit-box;overflow:hidden}.torrent-card-status{color:#94a3b8;align-items:center;gap:.75rem;font-size:.875rem;display:flex}.torrent-card-progress{background:#334155;border-radius:3px;height:6px;margin-top:.5rem;overflow:hidden}.torrent-card-progress-bar{background:linear-gradient(90deg,#3b82f6,#22c55e);border-radius:3px;height:100%;transition:width .3s}.torrent-card.ready{border-color:#22c55e}.torrent-card.ready:before{opacity:1;background:#22c55e}.details-overlay{-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);z-index:100;background:#000000e6;justify-content:center;align-items:center;animation:.2s ease-out fadeIn;display:flex;position:fixed;inset:0}.details-modal{text-align:center;background:linear-gradient(#1e293b,#0f172a);border:1px solid #334155;border-radius:24px;width:90%;max-width:700px;padding:3rem}.details-title{margin-bottom:1rem;font-size:2.5rem;font-weight:700;line-height:1.2}.details-progress-container{margin:2rem 0}.details-progress-bar{background:#334155;border-radius:6px;height:12px;overflow:hidden}.details-progress-fill{background:linear-gradient(90deg,#3b82f6,#22c55e);border-radius:6px;height:100%;transition:width .3s}.details-status{margin-top:.75rem;font-size:1.25rem}.details-status.ready{color:#22c55e}.details-status.loading{color:#fbbf24}.details-buttons{flex-direction:column;gap:1rem;margin-top:2.5rem;display:flex}.details-btn-watch{color:#fff;cursor:pointer;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:16px;padding:1.25rem 2rem;font-size:1.5rem;font-weight:700;transition:all .2s}.details-btn-watch:focus{transform:scale(1.05);box-shadow:0 0 0 4px #22c55e99,0 8px 30px #22c55e4d}.details-btn-delete{color:#ef4444;cursor:pointer;background:0 0;border:2px solid #ef4444;border-radius:12px;padding:.75rem 1.5rem;font-size:1rem;transition:all .2s}.details-btn-delete:focus{color:#fff;background:#ef4444;box-shadow:0 0 0 4px #ef444480}.details-back{color:#64748b;margin-top:2rem;font-size:.875rem}@media(max-width:640px){.netflix-grid{grid-template-columns:1fr;gap:1rem;padding:.75rem}.torrent-card{aspect-ratio:auto;padding:1rem}.details-modal{border:2px solid #475569;border-radius:24px;max-width:95%;padding:2.5rem}.details-title{margin-bottom:2rem;font-size:2rem}.details-progress-bar{height:20px}.details-btn-watch{width:100%;margin-bottom:1rem;padding:1.5rem 3rem;font-size:1.75rem}.details-btn-delete{width:100%;padding:1.25rem;font-size:1.25rem}.details-back{opacity:.8;margin-top:2rem;font-size:1.25rem}}@keyframes fadeIn{0%{opacity:0;transform:translateY(-8px)}to{opacity:1;transform:translateY(0)}}@keyframes slideInRight{0%{transform:translate(100%)}to{transform:translate(0)}}.animate-slide-in-right{animation:.3s cubic-bezier(.16,1,.3,1) slideInRight}.custom-scrollbar::-webkit-scrollbar{width:4px}.custom-scrollbar::-webkit-scrollbar-track{background:0 0}.custom-scrollbar::-webkit-scrollbar-thumb{background:#333;border-radius:10px}.custom-scrollbar::-webkit-scrollbar-thumb:hover{background:#444}.header-btn:focus{color:#fff;transform:scale(1.2)}.settings-panel{max-width:500px;margin:0 auto 2rem}@property --tw-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-z{syntax:"*";inherits:false;initial-value:0}@property --tw-scale-x{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-y{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-z{syntax:"*";inherits:false;initial-value:1}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-space-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-gradient-position{syntax:"*";inherits:false}@property --tw-gradient-from{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-via{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-to{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-stops{syntax:"*";inherits:false}@property --tw-gradient-via-stops{syntax:"*";inherits:false}@property --tw-gradient-from-position{syntax:"<length-percentage>";inherits:false;initial-value:0%}@property --tw-gradient-via-position{syntax:"<length-percentage>";inherits:false;initial-value:50%}@property --tw-gradient-to-position{syntax:"<length-percentage>";inherits:false;initial-value:100%}@property --tw-leading{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-tracking{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@property --tw-backdrop-blur{syntax:"*";inherits:false}@property --tw-backdrop-brightness{syntax:"*";inherits:false}@property --tw-backdrop-contrast{syntax:"*";inherits:false}@property --tw-backdrop-grayscale{syntax:"*";inherits:false}@property --tw-backdrop-hue-rotate{syntax:"*";inherits:false}@property --tw-backdrop-invert{syntax:"*";inherits:false}@property --tw-backdrop-opacity{syntax:"*";inherits:false}@property --tw-backdrop-saturate{syntax:"*";inherits:false}@property --tw-backdrop-sepia{syntax:"*";inherits:false}@property --tw-duration{syntax:"*";inherits:false}@property --tw-ease{syntax:"*";inherits:false}@keyframes spin{to{transform:rotate(360deg)}}@keyframes pulse{50%{opacity:.5}}@keyframes bounce{0%,to{animation-timing-function:cubic-bezier(.8,0,1,1);transform:translateY(-25%)}50%{animation-timing-function:cubic-bezier(0,0,.2,1);transform:none}}

```

---

## client/android/app/src/main/assets/public/assets/web-C-YL8JOE.js

```javascript
import{W as o}from"./index-BobWrA1F.js";class e extends o{constructor(){super(),this._lastWindow=null}async open(s){this._lastWindow=window.open(s.url,s.windowName||"_blank")}async close(){return new Promise((s,n)=>{this._lastWindow!=null?(this._lastWindow.close(),this._lastWindow=null,s()):n("No active window to close!")})}}const i=new e;export{i as Browser,e as BrowserWeb};

```

---

## client/android/app/src/main/assets/public/assets/web-Du40huiD.js

```javascript
import{W as e}from"./index-BobWrA1F.js";class t extends e{available(){throw this.unimplemented("Method not implemented on web.")}start(o){throw this.unimplemented("Method not implemented on web.")}stop(){throw this.unimplemented("Method not implemented on web.")}getSupportedLanguages(){throw this.unimplemented("Method not implemented on web.")}hasPermission(){throw this.unimplemented("Method not implemented on web.")}isListening(){throw this.unimplemented("Method not implemented on web.")}requestPermission(){throw this.unimplemented("Method not implemented on web.")}checkPermissions(){throw this.unimplemented("Method not implemented on web.")}requestPermissions(){throw this.unimplemented("Method not implemented on web.")}}const m=new t;export{m as SpeechRecognition,t as SpeechRecognitionWeb};

```

---

## client/android/app/src/main/assets/public/assets/web-uZvVC3Zk.js

```javascript
import{W as t}from"./index-BobWrA1F.js";class s extends t{constructor(){super(),this.handleVisibilityChange=()=>{const e={isActive:document.hidden!==!0};this.notifyListeners("appStateChange",e),document.hidden?this.notifyListeners("pause",null):this.notifyListeners("resume",null)},document.addEventListener("visibilitychange",this.handleVisibilityChange,!1)}exitApp(){throw this.unimplemented("Not implemented on web.")}async getInfo(){throw this.unimplemented("Not implemented on web.")}async getLaunchUrl(){return{url:""}}async getState(){return{isActive:document.hidden!==!0}}async minimizeApp(){throw this.unimplemented("Not implemented on web.")}}export{s as AppWeb};

```

---

## client/android/app/src/main/assets/public/cordova.js

```javascript

```

---

## client/android/app/src/main/assets/public/cordova_plugins.js

```javascript

```

---

## client/android/app/src/main/assets/public/index.html

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>client</title>
    <script type="module" crossorigin src="/assets/index-BobWrA1F.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-DmDSvY7b.css">
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>

```

---

## client/android/app/src/main/assets/public/manifest.json

```json
{
    "name": "MediaBox",
    "short_name": "MediaBox",
    "description": "Home Media Streaming Server",
    "start_url": "/",
    "display": "standalone",
    "background_color": "#141E30",
    "theme_color": "#00c6ff",
    "icons": [
        {
            "src": "/icon-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "any maskable"
        },
        {
            "src": "/icon-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "any maskable"
        }
    ]
}
```

---

## client/android/app/src/main/assets/public/sw.js

```javascript
const CACHE_NAME = 'torserve-v3-fix';

// Install event - force activation
self.addEventListener('install', (event) => {
    console.log('[SW] Installing new fix version...');
    self.skipWaiting();
});

// Activate event - take control and clean old caches
self.addEventListener('activate', (event) => {
    console.log('[SW] Activating & Cleaning old caches...');
    event.waitUntil(
        Promise.all([
            clients.claim(),
            caches.keys().then((cacheNames) => {
                return Promise.all(
                    cacheNames.map((cacheName) => {
                        if (cacheName !== CACHE_NAME) {
                            console.log('[SW] Deleting old cache:', cacheName);
                            return caches.delete(cacheName);
                        }
                    })
                );
            })
        ])
    );
});

// Fetch event - FIX for "Request method 'POST' is unsupported"
self.addEventListener('fetch', (event) => {
    // Ignore non-GET requests (like POST search queries)
    if (event.request.method !== 'GET') {
        return;
    }

    // For now, use Network First strategy for safety
    // keeping it simple to ensure stability
    event.respondWith(
        fetch(event.request)
            .then((response) => {
                // Optional: Cache successful GET requests if needed
                // For now, avoiding aggressive caching to prevent "stale UI" issues
                return response;
            })
            .catch(() => {
                // Fallback or offline logic could go here
                return caches.match(event.request);
            })
    );
});

```

---

## client/android/app/src/main/java/com/torserve/pwa/MainActivity.java

```java
package com.torserve.pwa;

import android.os.Bundle;
import com.getcapacitor.BridgeActivity;

public class MainActivity extends BridgeActivity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        registerPlugin(TVPlayer.class);
        super.onCreate(savedInstanceState);
    }
}

```

---

## client/android/app/src/main/java/com/torserve/pwa/TVPlayer.java

```java
package com.torserve.pwa;

import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import androidx.activity.result.ActivityResult;
import com.getcapacitor.Plugin;
import com.getcapacitor.PluginCall;
import com.getcapacitor.PluginMethod;
import com.getcapacitor.annotation.ActivityCallback;
import com.getcapacitor.annotation.CapacitorPlugin;
import com.getcapacitor.JSObject;
import java.util.ArrayList;
import org.json.JSONArray;

@CapacitorPlugin(name = "TVPlayer")
public class TVPlayer extends Plugin {

    /**
     * Check if a package (player app) is installed
     */
    @PluginMethod
    public void isPackageInstalled(PluginCall call) {
        String packageName = call.getString("package");
        if (packageName == null) {
            call.reject("Package name required");
            return;
        }
        try {
            getContext().getPackageManager().getPackageInfo(packageName, 0);
            JSObject result = new JSObject();
            result.put("installed", true);
            call.resolve(result);
        } catch (PackageManager.NameNotFoundException e) {
            JSObject result = new JSObject();
            result.put("installed", false);
            call.resolve(result);
        }
    }

    /**
     * Play a single video file with player-specific extras
     * Based on MatriX Vimu.kt and MX.kt implementations
     */
    @PluginMethod
    public void play(PluginCall call) {
        String url = call.getString("url");
        String packageName = call.getString("package");
        String title = call.getString("title", "Video");
        int position = call.getInt("position", 0); // Resume position

        if (url == null) {
            call.reject("URL is required");
            return;
        }

        try {
            Intent intent = new Intent(Intent.ACTION_VIEW);
            intent.setDataAndType(Uri.parse(url), "video/*");
            // AND-01: Prevent double chooser and activity stacking
            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
            intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);

            if (packageName != null && !packageName.isEmpty()) {
                intent.setPackage(packageName);

                // Common extras for result
                intent.putExtra("return_result", true);

                // Vimu Player extras (net.gtvbox.videoplayer)
                if (packageName.contains("gtvbox")) {
                    intent.putExtra("forcename", title); // Show title instead of URL
                    intent.putExtra("forcedirect", true); // Direct access without buffering
                    if (position > 0)
                        intent.putExtra("startfrom", position); // Resume Vimu
                }

                // MX Player extras (com.mxtech.videoplayer)
                if (packageName.contains("mxtech")) {
                    intent.putExtra("title", title);
                    intent.putExtra("sticky", false);
                    if (position > 0)
                        intent.putExtra("position", position); // Resume MX
                }

                // VLC extras
                if (packageName.contains("videolan")) {
                    intent.putExtra("title", title);
                    if (position > 0)
                        intent.putExtra("from_start", false); // VLC specific?
                    // VLC doesn't support standard position extra well, depends on version
                }
            }

            startActivityForResult(call, intent, "playerResult");
        } catch (Exception e) {
            call.reject("Error launching player: " + e.getMessage());
        }
    }

    /**
     * Play a playlist of video files (for series/multi-file torrents)
     * Vimu uses: asusfilelist, asusnamelist, startindex
     * MX uses: video_list, video_list.name
     */
    @PluginMethod
    public void playList(PluginCall call) {
        String packageName = call.getString("package");
        String title = call.getString("title", "Playlist");
        JSONArray urlsJson = call.getArray("urls");
        JSONArray namesJson = call.getArray("names");
        int startIndex = call.getInt("startIndex", 0);
        int position = call.getInt("position", 0);

        if (urlsJson == null || urlsJson.length() == 0) {
            call.reject("URLs array is required");
            return;
        }

        try {
            ArrayList<String> urls = new ArrayList<>();
            ArrayList<String> names = new ArrayList<>();

            for (int i = 0; i < urlsJson.length(); i++) {
                urls.add(urlsJson.getString(i));
                names.add(namesJson != null && i < namesJson.length()
                        ? namesJson.getString(i)
                        : "File " + (i + 1));
            }

            Intent intent = new Intent(Intent.ACTION_VIEW);
            // AND-01: Prevent double chooser
            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
            intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
            intent.putExtra("return_result", true); // Request result

            if (packageName != null && packageName.contains("gtvbox")) {
                // Vimu playlist format (from Vimu.kt)
                intent.setPackage(packageName);
                intent.setDataAndType(Uri.parse(urls.get(startIndex)),
                        "application/vnd.gtvbox.filelist");
                intent.putExtra("forcename", title);
                intent.putStringArrayListExtra("asusfilelist", urls);
                intent.putStringArrayListExtra("asusnamelist", names);
                intent.putExtra("startindex", startIndex);
                if (position > 0 && startIndex >= 0)
                    intent.putExtra("startfrom", position);
            } else if (packageName != null && packageName.contains("mxtech")) {
                // MX Player playlist format (from MX.kt)
                intent.setPackage(packageName);
                intent.setDataAndType(Uri.parse(urls.get(startIndex)), "video/*");
                intent.putExtra("title", title);
                Uri[] uriArray = new Uri[urls.size()];
                for (int i = 0; i < urls.size(); i++) {
                    uriArray[i] = Uri.parse(urls.get(i));
                }
                intent.putExtra("video_list", uriArray);
                intent.putExtra("video_list.name", names.toArray(new String[0]));
                intent.putExtra("video_list.filename", names.toArray(new String[0]));
                intent.putExtra("video_list_is_explicit", true);
                if (position > 0)
                    intent.putExtra("position", position);
            } else {
                // Fallback: play single file from startIndex
                intent.setDataAndType(Uri.parse(urls.get(startIndex)), "video/*");
                if (packageName != null) {
                    intent.setPackage(packageName);
                }
            }

            startActivityForResult(call, intent, "playerResult");
        } catch (Exception e) {
            call.reject("Error launching playlist: " + e.getMessage());
        }
    }

    @ActivityCallback
    private void playerResult(PluginCall call, ActivityResult result) {
        if (call == null)
            return;

        Intent data = result.getData();
        JSObject ret = new JSObject();

        if (data != null) {
            // MX Player / Vimu standard return keys
            int position = data.getIntExtra("position", -1);
            int duration = data.getIntExtra("duration", -1);
            String endBy = data.getStringExtra("end_by"); // user, playback_completion

            // Try distinct known keys if standard fail
            if (position == -1)
                position = data.getIntExtra("current_position", -1);

            ret.put("position", position);
            ret.put("duration", duration);
            ret.put("endBy", endBy);

            // Mark as finished if endBy is completion OR position is near duration (95%)
            boolean finished = "playback_completion".equals(endBy);
            if (!finished && duration > 0 && position > duration * 0.95) {
                finished = true;
            }
            ret.put("finished", finished);
        } else {
            ret.put("position", -1);
            ret.put("message", "No data returned");
        }

        call.resolve(ret);
    }
}

```

---

## client/android/app/src/test/java/com/getcapacitor/myapp/ExampleUnitTest.java

```java
package com.getcapacitor.myapp;

import static org.junit.Assert.*;

import org.junit.Test;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {

    @Test
    public void addition_isCorrect() throws Exception {
        assertEquals(4, 2 + 2);
    }
}

```

---

## client/android/build.gradle

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.2.1'
        classpath 'com.google.gms:google-services:4.4.0'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

apply from: "variables.gradle"

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

```

---

## client/android/capacitor-cordova-android-plugins/build.gradle

```gradle
ext {
    androidxAppCompatVersion = project.hasProperty('androidxAppCompatVersion') ? rootProject.ext.androidxAppCompatVersion : '1.6.1'
    cordovaAndroidVersion = project.hasProperty('cordovaAndroidVersion') ? rootProject.ext.cordovaAndroidVersion : '10.1.1'
}

buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.2.1'
    }
}

apply plugin: 'com.android.library'

android {
    namespace "capacitor.cordova.android.plugins"
    compileSdk project.hasProperty('compileSdkVersion') ? rootProject.ext.compileSdkVersion : 34
    defaultConfig {
        minSdkVersion project.hasProperty('minSdkVersion') ? rootProject.ext.minSdkVersion : 22
        targetSdkVersion project.hasProperty('targetSdkVersion') ? rootProject.ext.targetSdkVersion : 34
        versionCode 1
        versionName "1.0"
    }
    lintOptions {
        abortOnError false
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
}

repositories {
    google()
    mavenCentral()
    flatDir{
        dirs 'src/main/libs', 'libs'
    }
}

dependencies {
    implementation fileTree(dir: 'src/main/libs', include: ['*.jar'])
    implementation "androidx.appcompat:appcompat:$androidxAppCompatVersion"
    implementation "org.apache.cordova:framework:$cordovaAndroidVersion"
    // SUB-PROJECT DEPENDENCIES START

    // SUB-PROJECT DEPENDENCIES END
}

// PLUGIN GRADLE EXTENSIONS START
apply from: "cordova.variables.gradle"
// PLUGIN GRADLE EXTENSIONS END

for (def func : cdvPluginPostBuildExtras) {
    func()
}
```

---

## client/android/capacitor-cordova-android-plugins/cordova.variables.gradle

```gradle
// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN
ext {
  cdvMinSdkVersion = project.hasProperty('minSdkVersion') ? rootProject.ext.minSdkVersion : 22
  // Plugin gradle extensions can append to this to have code run at the end.
  cdvPluginPostBuildExtras = []
  cordovaConfig = [:]
}
```

---

## client/android/capacitor.settings.gradle

```gradle
// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN
include ':capacitor-android'
project(':capacitor-android').projectDir = new File('../node_modules/@capacitor/android/capacitor')

include ':capacitor-community-speech-recognition'
project(':capacitor-community-speech-recognition').projectDir = new File('../node_modules/@capacitor-community/speech-recognition/android')

include ':capacitor-app'
project(':capacitor-app').projectDir = new File('../node_modules/@capacitor/app/android')

include ':capacitor-browser'
project(':capacitor-browser').projectDir = new File('../node_modules/@capacitor/browser/android')

include ':capacitor-preferences'
project(':capacitor-preferences').projectDir = new File('../node_modules/@capacitor/preferences/android')

```

---

## client/android/settings.gradle

```gradle
include ':app'
include ':capacitor-cordova-android-plugins'
project(':capacitor-cordova-android-plugins').projectDir = new File('./capacitor-cordova-android-plugins/')

apply from: 'capacitor.settings.gradle'
```

---

## client/android/variables.gradle

```gradle
ext {
    minSdkVersion = 22
    compileSdkVersion = 34
    targetSdkVersion = 34
    androidxActivityVersion = '1.8.0'
    androidxAppCompatVersion = '1.6.1'
    androidxCoordinatorLayoutVersion = '1.2.0'
    androidxCoreVersion = '1.12.0'
    androidxFragmentVersion = '1.6.2'
    coreSplashScreenVersion = '1.0.1'
    androidxWebkitVersion = '1.9.0'
    junitVersion = '4.13.2'
    androidxJunitVersion = '1.1.5'
    androidxEspressoCoreVersion = '3.5.1'
    cordovaAndroidVersion = '10.1.1'
}
```

---

## client/capacitor.config.json

```json
{
    "appId": "com.torserve.pwa",
    "appName": "MediaBox",
    "webDir": "dist",
    "server": {
        "androidScheme": "https",
        "cleartext": true,
        "allowNavigation": [
            "192.168.1.70",
            "192.168.1.*",
            "*"
        ]
    },
    "android": {
        "allowMixedContent": true
    }
}
```

---

## client/eslint.config.js

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

```

---

## client/index.html

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>client</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

---

## client/package.json

```json
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest",
    "test:run": "vitest run"
  },
  "dependencies": {
    "@capacitor-community/speech-recognition": "^6.0.1",
    "@capacitor/app": "^6.0.3",
    "@capacitor/browser": "^6.0.6",
    "@capacitor/core": "^6.2.1",
    "@capacitor/preferences": "^6.0.3",
    "react": "^19.2.0",
    "react-dom": "^19.2.0"
  },
  "devDependencies": {
    "@capacitor/android": "^6.2.1",
    "@capacitor/cli": "^6.2.1",
    "@eslint/js": "^9.39.1",
    "@tailwindcss/postcss": "^4.1.17",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.22",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.17",
    "vite": "^7.2.4",
    "vitest": "^3.0.0",
    "happy-dom": "^18.0.0",
    "@testing-library/react": "^16.0.0"
  }
}
```

---

## client/postcss.config.js

```javascript
export default {
    plugins: {
        '@tailwindcss/postcss': {},
        autoprefixer: {},
    },
}

```

---

## client/public/manifest.json

```json
{
    "name": "MediaBox",
    "short_name": "MediaBox",
    "description": "Home Media Streaming Server",
    "start_url": "/",
    "display": "standalone",
    "background_color": "#141E30",
    "theme_color": "#00c6ff",
    "icons": [
        {
            "src": "/icon-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "any maskable"
        },
        {
            "src": "/icon-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "any maskable"
        }
    ]
}
```

---

## client/public/sw.js

```javascript
const CACHE_NAME = 'torserve-v3-fix';

// Install event - force activation
self.addEventListener('install', (event) => {
    console.log('[SW] Installing new fix version...');
    self.skipWaiting();
});

// Activate event - take control and clean old caches
self.addEventListener('activate', (event) => {
    console.log('[SW] Activating & Cleaning old caches...');
    event.waitUntil(
        Promise.all([
            clients.claim(),
            caches.keys().then((cacheNames) => {
                return Promise.all(
                    cacheNames.map((cacheName) => {
                        if (cacheName !== CACHE_NAME) {
                            console.log('[SW] Deleting old cache:', cacheName);
                            return caches.delete(cacheName);
                        }
                    })
                );
            })
        ])
    );
});

// Fetch event - FIX for "Request method 'POST' is unsupported"
self.addEventListener('fetch', (event) => {
    // Ignore non-GET requests (like POST search queries)
    if (event.request.method !== 'GET') {
        return;
    }

    // For now, use Network First strategy for safety
    // keeping it simple to ensure stability
    event.respondWith(
        fetch(event.request)
            .then((response) => {
                // Optional: Cache successful GET requests if needed
                // For now, avoiding aggressive caching to prevent "stale UI" issues
                return response;
            })
            .catch(() => {
                // Fallback or offline logic could go here
                return caches.match(event.request);
            })
    );
});

```

---

## client/src/App.css

```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

---

## client/src/App.jsx

```javascript
// NavigationProvider removed as per V3.7 architecture (using useTVNavigation)
import { useState, useEffect, useCallback, useRef, useMemo } from 'react'
import { registerPlugin } from '@capacitor/core'
import { App as CapacitorApp } from '@capacitor/app'
import { Capacitor } from '@capacitor/core'

// Components
import Poster from './components/Poster'
import { DegradedBanner, ErrorScreen, BufferingBanner, ServerStatusBar } from './components/StatusBanners'
import SettingsPanel from './components/SettingsPanel'
import SearchPanel from './components/SearchPanel'
import TorrentModal from './components/TorrentModal'
import AutoDownloadPanel from './components/AutoDownloadPanel'
import HomePanel from './components/HomePanel'

// Hooks
import SpatialEngine, { useSpatialArbiter, useSpatialItem } from './hooks/useSpatialNavigation'

// Helpers
import { cleanTitle } from './utils/helpers'

// Register Custom Java Bridge
const TVPlayer = registerPlugin('TVPlayer')

const CATEGORIES = [
  { id: 'all', name: '–í—Å–µ', icon: 'üìö' },
  { id: 'movie', name: '–§–∏–ª—å–º—ã', icon: 'üé¨' },
  { id: 'series', name: '–°–µ—Ä–∏–∞–ª—ã', icon: 'üì∫' },
  { id: 'music', name: '–ú—É–∑—ã–∫–∞', icon: 'üéµ' },
  { id: 'other', name: '–î—Ä—É–≥–æ–µ', icon: 'üìÅ' }
]

// ‚îÄ‚îÄ‚îÄ Sub-Components for App ‚îÄ‚îÄ‚îÄ

const ListCategoryButton = ({ cat, active, onClick }) => {
  const spatialRef = useSpatialItem('main')
  return (
    <button
      ref={spatialRef}
      onClick={onClick}
      className={`
        focusable px-4 py-2 rounded-full text-sm font-medium whitespace-nowrap transition-all
        focus:ring-2 focus:ring-blue-400 focus:ring-offset-2 focus:ring-offset-[#141414] focus:outline-none
        ${active ? 'bg-blue-600 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}
      `}
    >
      {cat.icon} {cat.name}
    </button>
  )
}

const ListSortButton = ({ sort, active, onClick }) => {
  const spatialRef = useSpatialItem('main')
  return (
    <button
      ref={spatialRef}
      onClick={onClick}
      className={`
        focusable px-3 py-1 rounded transition-all
        focus:ring-2 focus:ring-blue-400 focus:outline-none
        ${active ? 'bg-gray-700 text-white' : 'bg-gray-800/50 text-gray-500 hover:text-white'}
      `}
    >
      {sort.label}
    </button>
  )
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Main App
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function App() {
  // State: Server & Settings
  const [serverUrl, setServerUrl] = useState(() => {
    if (Capacitor.isNativePlatform()) {
      return localStorage.getItem('serverUrl') || 'http://192.168.1.70:3000'
    }
    return ''
  })
  const [tmdbProxyUrl, setTmdbProxyUrl] = useState(localStorage.getItem('tmdbProxyUrl') || import.meta.env.VITE_TMDB_PROXY_URL || '')

  // State: Torrents
  const [torrents, setTorrents] = useState([])
  const [magnet, setMagnet] = useState('')
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)

  // State: UI
  const [showSettings, setShowSettings] = useState(false)
  const [settingsTab, setSettingsTab] = useState('general')
  const [showServerInput, setShowServerInput] = useState(false)
  const [selectedTorrent, setSelectedTorrent] = useState(null)
  const [buffering, setBuffering] = useState(null)
  const isPlayingRef = useRef(false)

  // State: Server Health
  const [serverStatus, setServerStatus] = useState('ok')
  const [lastStateChange, setLastStateChange] = useState(null)
  const [retryAfter, setRetryAfter] = useState(null)

  // State: Sorting & Filtering
  const [sortBy, setSortBy] = useState(localStorage.getItem('sortBy') || 'name')
  const [categoryFilter, setCategoryFilter] = useState('all')

  // State: Search
  const [showSearch, setShowSearch] = useState(false)
  const [searchQuery, setSearchQuery] = useState('')
  const [searchResults, setSearchResults] = useState([])
  const [searchProviders, setSearchProviders] = useState({})
  const [searchLoading, setSearchLoading] = useState(false)

  // State: Auto-Download
  const [showAutoDownload, setShowAutoDownload] = useState(false)

  // State: Last Played
  const [lastPlayed, setLastPlayed] = useState(() => {
    try { return JSON.parse(localStorage.getItem('lastPlayed')) || null } catch { return null }
  })

  // State: Discovery Views
  const [activeView, setActiveView] = useState('home')
  const [activeMovie, setActiveMovie] = useState(null)
  const [activePerson, setActivePerson] = useState(null)
  const [activeCategory, setActiveCategory] = useState(null)
  const [showSidebar, setShowSidebar] = useState(false)

  // ‚îÄ‚îÄ‚îÄ Spatial Registry ‚îÄ‚îÄ‚îÄ
  const handleBack = useCallback(() => {
    if (selectedTorrent) setSelectedTorrent(null)
    else if (showSettings) setShowSettings(false)
    else if (showSearch) { setShowSearch(false); setSearchResults([]); setSearchProviders({}) }
    else if (showSidebar) setShowSidebar(false)
    else if (activeMovie) setActiveMovie(null)
    else if (activePerson) setActivePerson(null)
    else if (activeCategory) setActiveCategory(null)
    else if (activeView === 'home') setActiveView('list')
    else CapacitorApp.exitApp()
  }, [selectedTorrent, showSettings, showSearch, showSidebar, activeMovie, activePerson, activeCategory, activeView])

  const { setActiveZone } = useSpatialArbiter(handleBack)

  // Navbar Refs
  // Navbar Refs
  const homeTabRef = useSpatialItem('main')
  const listTabRef = useSpatialItem('main')
  const autoDownloadRef = useSpatialItem('main')
  const refreshRef = useSpatialItem('main')
  const settingsBtnRef = useSpatialItem('main')
  // Diagnostics Button Ref -> Now opens Settings (Status Tab)
  const diagnosticsRef = useSpatialItem('main')

  // My List View Refs
  const continuePlayRef = useSpatialItem('main')
  const mainSearchBtnRef = useSpatialItem('main', 'list-search-btn')
  const addMagnetBtnRef = useSpatialItem('main')
  // We need dynamic refs for list items, but `useSpatialItem` is a hook.
  // For lists/categories, we should use a sub-component with useSpatialItem OR the spatial navigation library's auto-detection if configured.
  // The current codebase uses `ListCategoryButton` sub-component at lines 26-38. But in the render loop at 487, it uses a plain <button>.
  // I should replace the plain button loop with `ListCategoryButton`.

  // ‚îÄ‚îÄ‚îÄ Effects ‚îÄ‚îÄ‚îÄ
  // 1. Zone Management (Passive)
  useEffect(() => {
    if (showSettings) setActiveZone('settings')
    else if (selectedTorrent) setActiveZone('modal')
    else if (showSearch) setActiveZone('search')
    else if (showAutoDownload) setActiveZone('auto-download')
    else if (showSidebar) setActiveZone('sidebar')
    else if (activeMovie) setActiveZone('detail')
    else if (activePerson) setActiveZone('person')
    else if (activeCategory) setActiveZone('category')
    else setActiveZone('main')
  }, [showSettings, selectedTorrent, showSearch, showAutoDownload, activeMovie, activePerson, activeCategory, showSidebar, setActiveZone])

  const fetchStatus = useCallback(async () => {
    const baseUrl = serverUrl || ''
    try {
      if (!baseUrl) return
      const res = await fetch(`${baseUrl}/api/status`)
      if (res.ok) {
        const data = await res.json()
        setTorrents(data.torrents || [])
        setServerStatus('ok')
      } else { setServerStatus('degraded') }
    } catch { setServerStatus('error') }
  }, [serverUrl])

  useEffect(() => {
    fetchStatus()
    const timer = setInterval(fetchStatus, 5000)
    return () => clearInterval(timer)
  }, [fetchStatus])

  const addTorrent = async (e) => {
    e.preventDefault()
    if (!magnet) return
    try {
      const res = await fetch(`${serverUrl}/api/add`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ magnet })
      })
      if (res.ok) {
        setMagnet('')
        setShowServerInput(false)
        fetchStatus()
      } else { alert('Error adding torrent') }
    } catch { alert('Network error') }
    finally { setLoading(false) }
  }

  const deleteTorrent = async (hash) => {
    if (!confirm('–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç —Ç–æ—Ä—Ä–µ–Ω—Ç –∏ —Ñ–∞–π–ª—ã?')) return
    try {
      const res = await fetch(`${serverUrl}/api/delete/${hash}`, { method: 'DELETE' })
      if (res.ok) { setSelectedTorrent(null); fetchStatus() }
    } catch { alert('Error deleting') }
  }

  const handlePlay = useCallback(async (hash, index, fileName) => {
    try {
      // 1. Get host from serverUrl for substitution
      let host = '';
      try {
        const cleanSrv = serverUrl.trim();
        const urlToParse = cleanSrv.includes('://') ? cleanSrv : `http://${cleanSrv}`;
        const parsed = new URL(urlToParse);
        // If port is special (not 3000/80/443), we might need it, but usually serverUrl already has it.
        // The most robust way is to replace 'localhost:3000' or 'localhost' with the actual serverUrl host:port.
        host = parsed.host; // host includes port if present
      } catch (e) { host = serverUrl; }

      // 2. Construct Stream URL (Server uses /stream/:hash/:idx)
      const base = serverUrl.replace(/\/$/, '');
      const streamUrl = `${base}/stream/${hash}/${index}`;

      console.log('[DEBUG] Final Play URL:', streamUrl);

      // 3. Mark last played
      localStorage.setItem('lastPlayed', JSON.stringify({
        infoHash: hash,
        torrentName: torrents.find(t => t.infoHash === hash)?.name,
        fileIndex: index,
        fileName: fileName
      }));

      // 4. Start playback via Custom Plugin
      await TVPlayer.play({ url: streamUrl, title: fileName })
    } catch (e) {
      console.error('Play error:', e)
      alert('Error starting playback')
    }
  }, [serverUrl, torrents])

  const handlePlayAll = useCallback(async (torrent) => {
    const videoFiles = torrent.files?.filter(f => /\.(mp4|mkv|avi|mov|webm)$/i.test(f.name)) || []
    if (videoFiles.length === 0) return

    // Play first file, let TVPlayer handle queue if implemented, or just play first
    handlePlay(torrent.infoHash, videoFiles[0].index, videoFiles[0].name)
  }, [handlePlay])

  const copyUrl = (hash, index) => {
    const base = serverUrl.replace(/\/$/, '');
    const url = `${base}/stream/${hash}/${index}`;
    navigator.clipboard.writeText(url).then(() => alert('URL copied'))
  }

  const searchRuTracker = async (query) => {
    if (!query || !query.trim()) return;
    setSearchLoading(true)
    setSearchResults([])
    setSearchProviders({})
    try {
      const res = await fetch(`${serverUrl}/api/v2/search?query=${encodeURIComponent(query)}&limit=100`)
      if (res.ok) {
        const data = await res.json()
        setSearchResults(data.items || [])
        setSearchProviders(data.meta?.providers || {})
      }
    } catch (e) { console.error('Search error:', e) }
    finally { setSearchLoading(false) }
  }

  const addFromSearch = async (magnet, title) => {
    setLoading(true)
    try {
      const res = await fetch(`${serverUrl}/api/add`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ magnet })
      })
      if (res.ok) {
        // Clear search state FIRST to unmount SearchResultItem components
        setSearchResults([])
        setSearchProviders({})
        setShowSearch(false)
        setActiveView('list')
        fetchStatus()
        // Use recoverFocus with retry logic instead of focusId
        setTimeout(() => SpatialEngine.recoverFocus('main'), 100)
      }
    } catch (e) { console.error(e) }
    finally { setLoading(false) }
  }

  const saveSortBy = (val) => {
    setSortBy(val)
    localStorage.setItem('sortBy', val)
  }

  const handleServerUrlChange = (val, save) => {
    setServerUrl(val)
    if (save) localStorage.setItem('serverUrl', val)
  }

  const handleTmdbProxyUrlChange = (val, save) => {
    setTmdbProxyUrl(val)
    if (save) localStorage.setItem('tmdbProxyUrl', val)
  }

  const getCategory = (torrent) => {
    const files = torrent.files || []
    const videos = files.filter(f => /\.(mp4|mkv|avi|webm|mov)$/i.test(f.name))
    if (videos.length > 5) return 'series'
    if (videos.length > 0) return 'movie'
    return 'other'
  }

  const filteredTorrents = useMemo(() => {
    if (categoryFilter === 'all') return torrents
    return torrents.filter(t => getCategory(t) === categoryFilter)
  }, [torrents, categoryFilter])

  const displayTorrents = useMemo(() => {
    return [...filteredTorrents].sort((a, b) => {
      if (sortBy === 'name') return (a.name || '').localeCompare(b.name || '')
      if (sortBy === 'size') {
        const sizeA = a.files?.reduce((s, f) => s + (f.length || 0), 0) || 0
        const sizeB = b.files?.reduce((s, f) => s + (f.length || 0), 0) || 0
        return sizeB - sizeA
      }
      if (sortBy === 'peers') return (b.numPeers || 0) - (a.numPeers || 0)
      return 0
    })
  }, [filteredTorrents, sortBy])

  if (serverStatus === 'circuit_open' || serverStatus === 'error') {
    return <ErrorScreen status={serverStatus} retryAfter={retryAfter} onRetry={fetchStatus} />
  }

  return (
    <div className="h-screen w-screen bg-[#141414] text-white font-sans selection:bg-red-500 selection:text-white flex flex-col overflow-hidden">



      {/* Navbar */}
      <div className={`flex-shrink-0 bg-[#141414]/90 backdrop-blur-md px-6 py-4 flex justify-between items-center shadow-lg border-b border-gray-800 transition-all duration-300 ${activeView === 'home' && !activeMovie && !activePerson && !activeCategory ? 'ml-20' : ''}`}>
        <h1 className="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-500 to-purple-500">PWA-TorServe</h1>
        <div className="flex gap-3 items-center">
          <div className="flex bg-gray-800 rounded-full p-1">
            <button ref={homeTabRef} tabIndex="0" onClick={() => { setActiveView('home'); setActiveMovie(null); setActivePerson(null); setActiveCategory(null); }} className={`focusable px-3 py-1.5 rounded-full text-sm font-medium transition-all ${activeView === 'home' ? 'bg-blue-600 text-white' : 'text-gray-400 hover:text-white'}`}>üè†</button>
            <button ref={listTabRef} tabIndex="0" onClick={() => { setActiveView('list'); setShowSearch(false); }} className={`focusable px-3 py-1.5 rounded-full text-sm font-medium transition-all ${activeView === 'list' ? 'bg-blue-600 text-white' : 'text-gray-400 hover:text-white'}`}>üìö</button>
          </div>
          <ServerStatusBar ref={diagnosticsRef} status={serverStatus} onDiagnosticsClick={() => { setSettingsTab('status'); setShowSettings(true); }} />
          <button ref={autoDownloadRef} tabIndex="0" onClick={() => setShowAutoDownload(true)} className="focusable p-2 hover:bg-gray-800 rounded-full transition-colors" title="–ê–≤—Ç–æ-–∑–∞–≥—Ä—É–∑–∫–∞">üì∫</button>
        </div>
      </div>

      {showAutoDownload && <AutoDownloadPanel serverUrl={serverUrl} torrents={torrents} onClose={() => setShowAutoDownload(false)} />}
      {serverStatus === 'degraded' && <DegradedBanner lastStateChange={lastStateChange} />}
      {showSettings && (
        <SettingsPanel
          serverUrl={serverUrl}
          onServerUrlChange={handleServerUrlChange}
          tmdbProxyUrl={tmdbProxyUrl}
          onTmdbProxyUrlChange={handleTmdbProxyUrlChange}
          torrents={torrents}
          initialTab={settingsTab}
          onClose={() => setShowSettings(false)}
        />
      )}

      <div className="flex-1 overflow-hidden relative">
        {activeView === 'home' && (
          <HomePanel
            activeMovie={activeMovie} setActiveMovie={setActiveMovie}
            activePerson={activePerson} setActivePerson={setActivePerson}
            activeCategory={activeCategory} setActiveCategory={setActiveCategory}
            showSidebar={showSidebar} setShowSidebar={setShowSidebar}
            onSearch={(q) => {
              const query = q || searchQuery;
              setSearchQuery(query);
              setActiveView('list');
              setShowSearch(true);
              searchRuTracker(query);
            }}
            onClose={() => setActiveView('list')}
          />
        )}

        {activeView === 'list' && (
          <div className="h-full overflow-y-auto px-6 py-4 custom-scrollbar">
            {/* Continue Watching Banner (cc51200 style) */}
            {lastPlayed?.torrentName && torrents.find(t => t.infoHash === lastPlayed.infoHash) && (
              <div className="mb-6 bg-gradient-to-r from-purple-900/50 to-blue-900/50 border border-purple-500/30 rounded-xl p-4">
                <div className="flex items-center justify-between">
                  <div className="flex-1 min-w-0">
                    <div className="text-xs text-purple-300 uppercase tracking-wide mb-1">‚ñ∂ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –ø—Ä–æ—Å–º–æ—Ç—Ä</div>
                    <div className="text-white font-bold truncate">{cleanTitle(lastPlayed.torrentName)}</div>
                    <div className="text-gray-400 text-sm truncate">{cleanTitle(lastPlayed.fileName)}</div>
                  </div>
                  <button
                    ref={continuePlayRef}
                    tabIndex="0"
                    onClick={() => handlePlay(lastPlayed.infoHash, lastPlayed.fileIndex, lastPlayed.fileName)}
                    className="focusable ml-4 bg-purple-600 hover:bg-purple-500 px-5 py-3 rounded-lg font-bold text-white flex items-center gap-2 transition-colors focus:ring-4 focus:ring-purple-400"
                  >
                    ‚ñ∂ Play
                  </button>
                </div>
              </div>
            )}

            {/* Header (cc51200 style) */}
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-semibold text-gray-200">–ú–æ–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç—ã</h2>
              <div className="flex gap-2">
                <button
                  ref={mainSearchBtnRef}
                  tabIndex="0"
                  onClick={() => setShowSearch(!showSearch)}
                  className="focusable bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded-full text-sm font-bold transition-transform hover:scale-105 focus:ring-4 focus:ring-purple-400"
                >
                  üîç –ü–æ–∏—Å–∫
                </button>
                {!showServerInput && (
                  <button
                    ref={addMagnetBtnRef}
                    tabIndex="0"
                    onClick={() => setShowServerInput(true)}
                    className="focusable bg-gray-800 hover:bg-gray-700 px-4 py-2 rounded-full text-sm font-bold border border-gray-600 transition-transform hover:scale-105 focus:ring-4 focus:ring-gray-400"
                  >
                    + Magnet
                  </button>
                )}
              </div>
            </div>

            {/* Search Panel */}
            {showSearch && (
              <SearchPanel
                searchQuery={searchQuery}
                onSearchQueryChange={setSearchQuery}
                onSearch={searchRuTracker}
                onClose={() => { setShowSearch(false); setSearchResults([]); setSearchProviders({}) }}
                onAddTorrent={addFromSearch}
                searchResults={searchResults}
                searchLoading={searchLoading}
                providers={searchProviders}
              />
            )}

            {/* Magnet Input */}
            {showServerInput && (
              <form onSubmit={addTorrent} className="mb-6">
                <div className="flex gap-2">
                  <input
                    value={magnet}
                    onChange={(e) => setMagnet(e.target.value)}
                    placeholder="–í—Å—Ç–∞–≤—å—Ç–µ Magnet-—Å—Å—ã–ª–∫—É..."
                    className="flex-1 bg-gray-800 border border-gray-700 rounded-lg px-4 py-3 focus:ring-2 focus:ring-blue-500 outline-none"
                  />
                  <button
                    type="submit"
                    disabled={loading || !magnet}
                    className="bg-blue-600 px-6 py-3 rounded-lg font-bold hover:bg-blue-700 disabled:opacity-50"
                  >
                    {loading ? '...' : 'Add'}
                  </button>
                  <button
                    type="button"
                    onClick={() => setShowServerInput(false)}
                    className="bg-gray-800 px-4 rounded-lg"
                  >
                    ‚úï
                  </button>
                </div>
              </form>
            )}

            {/* Error */}
            {error && (
              <div className="bg-red-900/30 border border-red-700 text-red-400 px-4 py-3 rounded-lg mb-4">
                {error}
              </div>
            )}

            {/* Category Tabs */}
            <div className="flex gap-2 mb-4 overflow-x-auto pb-3 pt-1 px-1 -mx-1">
              {CATEGORIES.map(cat => (
                <ListCategoryButton
                  key={cat.id}
                  cat={cat}
                  active={categoryFilter === cat.id}
                  onClick={() => setCategoryFilter(cat.id)}
                />
              ))}
            </div>

            {/* Sort Buttons (cc51200 style) */}
            <div className="flex gap-2 mb-6 text-xs px-1 -mx-1">
              <span className="text-gray-500 self-center">–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞:</span>
              {[{ id: 'name', label: '–ò–º—è' }, { id: 'size', label: '–†–∞–∑–º–µ—Ä' }, { id: 'peers', label: '–ü–∏—Ä—ã' }].map(s => (
                <ListSortButton
                  key={s.id}
                  sort={s}
                  active={sortBy === s.id}
                  onClick={() => saveSortBy(s.id)}
                />
              ))}
            </div>

            {/* Torrent Grid */}
            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">
              {displayTorrents.map(t => (
                <Poster
                  key={t.infoHash} name={t.name} progress={t.progress || 0} peers={t.numPeers || 0}
                  isReady={t.isReady} size={t.files?.reduce((sum, f) => sum + (f.length || 0), 0) || 0}
                  downloadSpeed={t.downloadSpeed || 0} downloaded={t.downloaded || 0} eta={t.eta || 0}
                  newFilesCount={t.newFilesCount || 0} onClick={() => setSelectedTorrent(t)}
                />
              ))}
              {displayTorrents.length === 0 && !loading && <div className="col-span-full py-20 text-center text-gray-600">–í–∞—à —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç</div>}
            </div>
          </div>
        )}

        {selectedTorrent && (
          <TorrentModal torrent={selectedTorrent} onClose={() => setSelectedTorrent(null)} onPlay={handlePlay} onPlayAll={handlePlayAll} onCopyUrl={copyUrl} onDelete={deleteTorrent} />
        )}

        {buffering && (
          <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur-sm">
            <div className="text-center">
              <div className="text-6xl mb-4 animate-pulse">‚è≥</div>
              <h2 className="text-xl font-bold text-white mb-2">–ë—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è...</h2>
              <p className="text-gray-400">{buffering.name}</p>
              <button onClick={() => setBuffering(null)} className="mt-6 text-gray-500">–û—Ç–º–µ–Ω–∞</button>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}

export default App

```

---

## client/src/components/AutoDownloadPanel.jsx

```javascript
/**
 * Auto-Download Panel v3
 * UI for managing auto-download rules (series tracking)
 * 
 * Features:
 * - Pick from loaded torrents
 * - TV remote (D-pad) full navigation support
 * - Focus trap to prevent background scrolling
 * - Proper tabIndex on all interactive elements
 */

import { useState, useEffect, useRef } from 'react'

// TV Remote focusable button component with tabIndex
function FocusableButton({ onClick, disabled, className, children, autoFocus, tabIndex = 0 }) {
    return (
        <button
            onClick={onClick}
            disabled={disabled}
            autoFocus={autoFocus}
            tabIndex={disabled ? -1 : tabIndex}
            className={`
                focus:ring-4 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900
                focus:outline-none focus:scale-105 transition-all
                ${className}
            `}
        >
            {children}
        </button>
    )
}

export default function AutoDownloadPanel({ serverUrl, torrents = [], onClose }) {
    const [settings, setSettings] = useState({ enabled: false, intervalMinutes: 720 })
    const [rules, setRules] = useState([])
    const [loading, setLoading] = useState(false)
    const [checking, setChecking] = useState(false)
    const [lastResult, setLastResult] = useState(null)
    const [showPicker, setShowPicker] = useState(false)

    // Form state for new rule
    const [newRule, setNewRule] = useState({
        query: '',
        resolution: '2160',
        group: '',
        lastEpisode: 0
    })

    // Refs for focus management
    const panelRef = useRef(null)
    const firstFocusableRef = useRef(null)

    const getApiUrl = (path) => serverUrl ? `${serverUrl}${path}` : path

    // Extract series from loaded torrents
    const getSeriesFromTorrents = () => {
        return torrents
            .filter(t => {
                const videos = t.files?.filter(f => /\.(mp4|mkv|avi|webm|mov)$/i.test(f.name)) || []
                return videos.length > 1
            })
            .map(t => {
                const videos = t.files?.filter(f => /\.(mp4|mkv|avi|webm|mov)$/i.test(f.name)) || []
                let maxEpisode = 0

                videos.forEach(f => {
                    const match = f.name.match(/[ES](\d{1,3})|[-‚Äì]\s*(\d{1,3})(?:\s|$|\[|\()/i)
                    if (match) {
                        const ep = parseInt(match[1] || match[2], 10)
                        if (ep > maxEpisode) maxEpisode = ep
                    }
                })

                const resMatch = t.name.match(/\b(2160p?|1080p?|720p?)\b/i)
                const resolution = resMatch ? resMatch[1].replace('p', '') : ''

                return {
                    name: t.name,
                    episodeCount: videos.length,
                    lastEpisode: maxEpisode,
                    resolution
                }
            })
    }

    const seriesList = getSeriesFromTorrents()

    // Prevent background scrolling when panel is open
    useEffect(() => {
        // Lock body scroll
        const originalStyle = window.getComputedStyle(document.body).overflow
        document.body.style.overflow = 'hidden'
        document.documentElement.style.overflow = 'hidden'

        return () => {
            document.body.style.overflow = originalStyle
            document.documentElement.style.overflow = ''
        }
    }, [])

    // D-pad / Arrow key navigation handler
    useEffect(() => {
        const getFocusableElements = () => {
            return Array.from(panelRef.current?.querySelectorAll(
                'button:not([disabled]), input:not([disabled]), select:not([disabled]), [tabindex="0"]'
            ) || [])
        }

        const handleKeyDown = (e) => {
            const key = e.key
            const keyCode = e.keyCode

            // ESC or Back button to close
            if (key === 'Escape' || key === 'Backspace' || keyCode === 10009) {
                e.preventDefault()
                e.stopPropagation()
                if (showPicker) {
                    setShowPicker(false)
                } else {
                    onClose()
                }
                return
            }

            // Arrow keys / D-pad navigation
            if (key === 'ArrowUp' || key === 'ArrowDown' || keyCode === 38 || keyCode === 40) {
                e.preventDefault()
                e.stopPropagation()

                const focusable = getFocusableElements()
                if (!focusable.length) return

                const currentIndex = focusable.indexOf(document.activeElement)
                let nextIndex

                if (key === 'ArrowDown' || keyCode === 40) {
                    nextIndex = currentIndex < focusable.length - 1 ? currentIndex + 1 : 0
                } else {
                    nextIndex = currentIndex > 0 ? currentIndex - 1 : focusable.length - 1
                }

                focusable[nextIndex]?.focus()
                focusable[nextIndex]?.scrollIntoView({ block: 'nearest', behavior: 'smooth' })
                return
            }

            // Left/Right for horizontal navigation
            if (key === 'ArrowLeft' || key === 'ArrowRight' || keyCode === 37 || keyCode === 39) {
                // Allow default behavior for inputs
                if (document.activeElement?.tagName === 'INPUT') {
                    return
                }
                e.preventDefault()
                e.stopPropagation()
            }

            // Tab key - focus trap
            if (key === 'Tab') {
                e.preventDefault()
                e.stopPropagation()

                const focusable = getFocusableElements()
                if (!focusable.length) return

                const currentIndex = focusable.indexOf(document.activeElement)
                let nextIndex

                if (e.shiftKey) {
                    nextIndex = currentIndex > 0 ? currentIndex - 1 : focusable.length - 1
                } else {
                    nextIndex = currentIndex < focusable.length - 1 ? currentIndex + 1 : 0
                }

                focusable[nextIndex]?.focus()
            }
        }

        // Block ALL scroll events from reaching background
        const blockScroll = (e) => {
            e.preventDefault()
            e.stopPropagation()
        }

        // Capture phase to intercept before anything else
        window.addEventListener('keydown', handleKeyDown, true)
        document.addEventListener('scroll', blockScroll, true)

        // Focus first element
        setTimeout(() => {
            firstFocusableRef.current?.focus()
        }, 50)

        return () => {
            window.removeEventListener('keydown', handleKeyDown, true)
            document.removeEventListener('scroll', blockScroll, true)
        }
    }, [showPicker, onClose])

    // Fetch rules and settings
    const fetchRules = async () => {
        setLoading(true)
        try {
            const res = await fetch(getApiUrl('/api/autodownload/rules'))
            const data = await res.json()
            setSettings(data.settings || { enabled: false, intervalMinutes: 720 })
            setRules(data.rules || [])
        } catch (err) {
            console.error('[AutoDownload] Fetch error:', err)
        } finally {
            setLoading(false)
        }
    }

    useEffect(() => {
        fetchRules()
    }, [serverUrl])

    // Toggle global enable/disable
    const toggleEnabled = async () => {
        try {
            const res = await fetch(getApiUrl('/api/autodownload/settings'), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: !settings.enabled })
            })
            const data = await res.json()
            setSettings(data)
        } catch (err) {
            console.error('[AutoDownload] Toggle error:', err)
        }
    }

    // Update interval
    const updateInterval = async (minutes) => {
        try {
            const res = await fetch(getApiUrl('/api/autodownload/settings'), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ intervalMinutes: parseInt(minutes, 10) })
            })
            const data = await res.json()
            setSettings(data)
        } catch (err) {
            console.error('[AutoDownload] Interval error:', err)
        }
    }

    // Add new rule
    const addRule = async () => {
        if (!newRule.query.trim()) return
        try {
            const res = await fetch(getApiUrl('/api/autodownload/rules'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(newRule)
            })
            await res.json()
            setNewRule({ query: '', resolution: '2160', group: '', lastEpisode: 0 })
            fetchRules()
        } catch (err) {
            console.error('[AutoDownload] Add rule error:', err)
        }
    }

    // Add rule from torrent picker
    const addFromTorrent = (series) => {
        setNewRule({
            query: series.name.replace(/\./g, ' ').split(/[-\[\(]/)[0].trim(),
            resolution: series.resolution || '2160',
            group: '',
            lastEpisode: series.lastEpisode
        })
        setShowPicker(false)
    }

    // Delete rule
    const deleteRule = async (id) => {
        if (!confirm('–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ –ø—Ä–∞–≤–∏–ª–æ?')) return
        try {
            await fetch(getApiUrl(`/api/autodownload/rules/${id}`), { method: 'DELETE' })
            fetchRules()
        } catch (err) {
            console.error('[AutoDownload] Delete error:', err)
        }
    }

    // Toggle rule enabled
    const toggleRule = async (rule) => {
        try {
            await fetch(getApiUrl(`/api/autodownload/rules/${rule.id}`), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: !rule.enabled })
            })
            fetchRules()
        } catch (err) {
            console.error('[AutoDownload] Toggle rule error:', err)
        }
    }

    // Manual check
    const runCheck = async () => {
        setChecking(true)
        setLastResult(null)
        try {
            const res = await fetch(getApiUrl('/api/autodownload/check'), { method: 'POST' })
            const data = await res.json()
            setLastResult(data)
            fetchRules()
        } catch (err) {
            console.error('[AutoDownload] Check error:', err)
            setLastResult({ error: err.message })
        } finally {
            setChecking(false)
        }
    }

    return (
        <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4"
            onClick={(e) => e.target === e.currentTarget && onClose()}
        >
            <div
                ref={panelRef}
                className="bg-gray-900 rounded-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col"
                onClick={(e) => e.stopPropagation()}
            >
                {/* Header */}
                <div className="flex justify-between items-center p-4 border-b border-gray-800">
                    <h2 className="text-xl font-bold text-white flex items-center gap-2">
                        üì∫ –ê–≤—Ç–æ-–∑–∞–≥—Ä—É–∑–∫–∞ —Å–µ—Ä–∏–∞–ª–æ–≤
                    </h2>
                    <FocusableButton
                        onClick={onClose}
                        className="text-gray-400 hover:text-white text-2xl p-2 rounded-lg"
                        tabIndex={0}
                    >
                        ‚úï
                    </FocusableButton>
                </div>

                {/* Content - scrollable */}
                <div className="flex-1 overflow-y-auto p-4 space-y-4">
                    {/* Global Settings */}
                    <div className="bg-gray-800/50 rounded-xl p-4">
                        <div className="flex items-center justify-between mb-3">
                            <div>
                                <div className="font-bold text-white">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞</div>
                                <div className="text-sm text-gray-400">
                                    –ü–æ–∏—Å–∫ –Ω–æ–≤—ã—Ö —Å–µ—Ä–∏–π –∫–∞–∂–¥—ã–µ {settings.intervalMinutes >= 60
                                        ? `${Math.round(settings.intervalMinutes / 60)} —á`
                                        : `${settings.intervalMinutes} –º–∏–Ω`}
                                </div>
                            </div>
                            <FocusableButton
                                ref={firstFocusableRef}
                                onClick={toggleEnabled}
                                className={`w-14 h-8 rounded-full transition-colors relative ${settings.enabled ? 'bg-green-600' : 'bg-gray-600'
                                    }`}
                                tabIndex={0}
                            >
                                <div className={`absolute w-6 h-6 bg-white rounded-full top-1 transition-all ${settings.enabled ? 'left-7' : 'left-1'
                                    }`} />
                            </FocusableButton>
                        </div>

                        {/* Interval Selector */}
                        <div className="flex items-center gap-2 text-sm flex-wrap">
                            <span className="text-gray-400">–ò–Ω—Ç–µ—Ä–≤–∞–ª:</span>
                            {[
                                { value: 360, label: '6 —á' },
                                { value: 720, label: '12 —á' },
                                { value: 1440, label: '24 —á' }
                            ].map(opt => (
                                <FocusableButton
                                    key={opt.value}
                                    onClick={() => updateInterval(opt.value)}
                                    className={`px-3 py-1 rounded ${settings.intervalMinutes === opt.value
                                        ? 'bg-blue-600 text-white'
                                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                        }`}
                                    tabIndex={0}
                                >
                                    {opt.label}
                                </FocusableButton>
                            ))}
                        </div>
                    </div>

                    {/* Manual Check Button */}
                    <FocusableButton
                        onClick={runCheck}
                        disabled={checking}
                        className="w-full bg-purple-600 hover:bg-purple-500 disabled:opacity-50 text-white font-bold py-3 rounded-xl flex items-center justify-center gap-2"
                        tabIndex={0}
                    >
                        {checking ? (
                            <>
                                <span className="animate-spin">‚è≥</span>
                                –ü—Ä–æ–≤–µ—Ä—è–µ–º...
                            </>
                        ) : (
                            <>üîç –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–µ–π—á–∞—Å</>
                        )}
                    </FocusableButton>

                    {/* Last Result */}
                    {lastResult && (
                        <div className={`rounded-xl p-3 text-sm ${lastResult.downloaded > 0
                            ? 'bg-green-900/50 text-green-300'
                            : lastResult.error
                                ? 'bg-red-900/50 text-red-300'
                                : 'bg-gray-800 text-gray-400'
                            }`}>
                            {lastResult.error
                                ? `‚ùå –û—à–∏–±–∫–∞: ${lastResult.error}`
                                : lastResult.downloaded > 0
                                    ? `‚úÖ –ù–∞–π–¥–µ–Ω–æ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–æ: ${lastResult.downloaded} —Å–µ—Ä–∏–π`
                                    : '‚úì –ù–æ–≤—ã—Ö —Å–µ—Ä–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ'
                            }
                        </div>
                    )}

                    {/* Add New Rule */}
                    <div className="bg-gray-800/50 rounded-xl p-4">
                        <div className="flex items-center justify-between mb-3">
                            <h3 className="font-bold text-white">‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–µ—Ä–∏–∞–ª</h3>
                            {seriesList.length > 0 && (
                                <FocusableButton
                                    onClick={() => setShowPicker(!showPicker)}
                                    className="bg-purple-600/30 hover:bg-purple-600/50 text-purple-300 px-3 py-1 rounded-lg text-sm"
                                    tabIndex={0}
                                >
                                    üìã –í—ã–±—Ä–∞—Ç—å ({seriesList.length})
                                </FocusableButton>
                            )}
                        </div>

                        {/* Picker Modal */}
                        {showPicker && (
                            <div className="mb-4 bg-gray-700/50 rounded-xl p-3 max-h-48 overflow-y-auto space-y-2">
                                <div className="text-sm text-gray-400 mb-2">–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–∏–∞–ª:</div>
                                {seriesList.map((series, idx) => (
                                    <FocusableButton
                                        key={idx}
                                        onClick={() => addFromTorrent(series)}
                                        className="w-full text-left bg-gray-800 hover:bg-gray-700 rounded-lg p-3"
                                        tabIndex={0}
                                        autoFocus={idx === 0}
                                    >
                                        <div className="font-medium text-white truncate">{series.name}</div>
                                        <div className="text-xs text-gray-400">
                                            {series.episodeCount} —Å–µ—Ä–∏–π ‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω—è—è: {series.lastEpisode}
                                            {series.resolution && ` ‚Ä¢ ${series.resolution}p`}
                                        </div>
                                    </FocusableButton>
                                ))}
                            </div>
                        )}

                        <div className="grid grid-cols-2 gap-3">
                            <input
                                value={newRule.query}
                                onChange={(e) => setNewRule({ ...newRule, query: e.target.value })}
                                placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ —Å–µ—Ä–∏–∞–ª–∞..."
                                tabIndex={0}
                                className="col-span-2 bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white placeholder-gray-500 focus:border-blue-500 focus:ring-2 focus:ring-blue-500 outline-none"
                            />
                            <select
                                value={newRule.resolution}
                                onChange={(e) => setNewRule({ ...newRule, resolution: e.target.value })}
                                tabIndex={0}
                                className="bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:border-blue-500 focus:ring-2 focus:ring-blue-500 outline-none"
                            >
                                <option value="">–õ—é–±–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ</option>
                                <option value="2160">4K (2160p)</option>
                                <option value="1080">1080p</option>
                                <option value="720">720p</option>
                            </select>
                            <input
                                type="number"
                                min="0"
                                value={newRule.lastEpisode}
                                onChange={(e) => setNewRule({ ...newRule, lastEpisode: parseInt(e.target.value, 10) || 0 })}
                                placeholder="–ü–æ—Å–ª–µ–¥–Ω—è—è —Å–µ—Ä–∏—è"
                                tabIndex={0}
                                className="bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:border-blue-500 focus:ring-2 focus:ring-blue-500 outline-none"
                            />
                        </div>
                        <FocusableButton
                            onClick={addRule}
                            disabled={!newRule.query.trim()}
                            className="mt-3 w-full bg-blue-600 hover:bg-blue-500 disabled:opacity-50 text-white font-bold py-2 rounded-lg"
                            tabIndex={0}
                        >
                            –î–æ–±–∞–≤–∏—Ç—å
                        </FocusableButton>
                    </div>

                    {/* Rules List */}
                    <div className="space-y-2">
                        <h3 className="font-bold text-white">üìã –ú–æ–∏ —Å–µ—Ä–∏–∞–ª—ã ({rules.length})</h3>
                        {loading ? (
                            <div className="text-center text-gray-500 py-8">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
                        ) : rules.length === 0 ? (
                            <div className="text-center text-gray-500 py-8">
                                –î–æ–±–∞–≤—å—Ç–µ —Å–µ—Ä–∏–∞–ª –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
                            </div>
                        ) : (
                            rules.map((rule) => (
                                <div
                                    key={rule.id}
                                    className={`bg-gray-800 rounded-xl p-3 flex items-center gap-3 ${!rule.enabled ? 'opacity-50' : ''
                                        }`}
                                >
                                    <FocusableButton
                                        onClick={() => toggleRule(rule)}
                                        className={`w-10 h-10 rounded-full flex items-center justify-center text-lg ${rule.enabled ? 'bg-green-600' : 'bg-gray-600'
                                            }`}
                                        tabIndex={0}
                                    >
                                        {rule.enabled ? '‚úì' : '‚óã'}
                                    </FocusableButton>
                                    <div className="flex-1 min-w-0">
                                        <div className="font-medium text-white truncate">{rule.query}</div>
                                        <div className="text-xs text-gray-400">
                                            {rule.resolution && `${rule.resolution}p ‚Ä¢ `}
                                            –°–µ—Ä–∏—è: {rule.lastEpisode}
                                        </div>
                                    </div>
                                    <FocusableButton
                                        onClick={() => deleteRule(rule.id)}
                                        className="text-red-500 hover:text-red-400 p-2 text-xl"
                                        tabIndex={0}
                                    >
                                        üóëÔ∏è
                                    </FocusableButton>
                                </div>
                            ))
                        )}
                    </div>
                </div>
            </div>
        </div>
    )
}

```

---

## client/src/components/CategoryPage.jsx

```javascript
import { useRef, useCallback, useEffect, useState } from 'react'
import { getPosterUrl, getTitle, getYear, DISCOVERY_CATEGORIES } from '../utils/discover'
import { reportBrokenImage, filterDiscoveryResults } from '../utils/tmdbClient'
import { useSpatialItem } from '../hooks/useSpatialNavigation'

const CategoryPage = ({
    categoryId,
    customCategory,
    items: initialItems = [],
    onItemClick
}) => {
    const [displayedItems, setDisplayedItems] = useState(initialItems)
    const [page, setPage] = useState(initialItems.length > 0 ? 1 : 0)
    const [loading, setLoading] = useState(false)
    const [hasMore, setHasMore] = useState(true)
    const [imageErrors, setImageErrors] = useState(new Set())
    const observerTarget = useRef(null)
    const backRef = useSpatialItem('category')

    const category = customCategory || DISCOVERY_CATEGORIES.find(c => c.id === categoryId)

    useEffect(() => {
        setDisplayedItems(initialItems)
        setPage(initialItems.length > 0 ? 1 : 0)
        setHasMore(true)
        setImageErrors(new Set())
        hasInitiallyLoaded.current = false
    }, [categoryId, customCategory?.name])

    const loadMore = useCallback(async () => {
        if (loading || !hasMore || !category?.fetcher) return
        setLoading(true)
        try {
            const nextPage = page + 1
            const response = await category.fetcher(nextPage)
            if (response && response.results && response.results.length > 0) {
                const newItems = filterDiscoveryResults(response.results)
                if (newItems.length > 0) {
                    setDisplayedItems(prev => [...prev, ...newItems])
                }
                setPage(nextPage)
                if (response.results.length < 20) setHasMore(false)
            } else { setHasMore(false) }
        } catch (e) {
            console.error(e)
            setHasMore(false)
        } finally { setLoading(false) }
    }, [loading, hasMore, page, category])

    const hasInitiallyLoaded = useRef(false)
    useEffect(() => {
        if (page === 0 && !hasInitiallyLoaded.current && category) {
            hasInitiallyLoaded.current = true
            loadMore()
        }
    }, [category])

    // Use both IntersectionObserver and Scroll Listener for maximum robustness on TV
    useEffect(() => {
        const observer = new IntersectionObserver(
            entries => { if (entries[0].isIntersecting) loadMore() },
            { threshold: 0, rootMargin: '500px' }
        )
        if (observerTarget.current) observer.observe(observerTarget.current)

        // Fallback: Scroll listener in case Observer fails on older WebViews
        const handleScroll = (e) => {
            const { scrollTop, scrollHeight, clientHeight } = e.target
            if (scrollHeight - scrollTop <= clientHeight + 1000) {
                loadMore()
            }
        }

        const container = document.querySelector('.category-page')
        if (container) container.addEventListener('scroll', handleScroll)

        return () => {
            observer.disconnect()
            if (container) container.removeEventListener('scroll', handleScroll)
        }
    }, [loadMore])

    if (!category) return null

    return (
        <div className="category-page h-full w-full bg-[#141414] p-6 overflow-y-auto custom-scrollbar">
            {/* Header */}
            <div className="flex items-center gap-4 mb-6">
                <button
                    ref={backRef}
                    className="focusable text-white hover:text-blue-400 p-2 rounded-lg focus:ring-4 focus:ring-blue-500"
                    onClick={() => window.dispatchEvent(new KeyboardEvent('keydown', { key: 'Backspace' }))}
                >
                    <span className="text-2xl">‚Üê</span>
                </button>
                <h1 className="text-2xl font-bold text-white flex items-center gap-3">
                    <span className="text-3xl">{category.icon}</span>
                    {category.name}
                    <span className="text-gray-500 text-lg font-normal">({displayedItems.length})</span>
                </h1>
            </div>

            {/* Grid */}
            <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
                {displayedItems.map((item, index) => (
                    <CategoryItem
                        key={`${item.id}-${index}`}
                        item={item}
                        onClick={() => onItemClick(item)}
                    />
                ))}
            </div>

            {/* sentinel */}
            {hasMore && (
                <div ref={observerTarget} className="h-20 flex items-center justify-center mt-8">
                    {loading && <div className="w-8 h-8 border-4 border-blue-500/30 border-t-blue-500 rounded-full animate-spin" />}
                </div>
            )}
        </div>
    )
}

const CategoryItem = ({ item, onClick }) => {
    const spatialRef = useSpatialItem('category')
    const [imgErr, setImgErr] = useState(false)
    const posterUrl = getPosterUrl(item)
    const title = getTitle(item)

    return (
        <button
            ref={spatialRef}
            onClick={onClick}
            className="focusable rounded-lg transition-all duration-200 relative overflow-hidden focus:outline-none focus:ring-4 focus:ring-blue-500 focus:scale-105 focus:z-10 aspect-[2/3]"
        >
            {posterUrl && !imgErr ? (
                <img
                    src={posterUrl}
                    className="w-full h-full object-cover"
                    onError={() => setImgErr(true)}
                />
            ) : (
                <div className="w-full h-full bg-gray-800 flex items-center justify-center p-2 text-white text-xs text-center">{title}</div>
            )}
            {item.vote_average > 0 && (
                <div className="absolute top-2 right-2 bg-black/60 px-2 py-1 rounded text-xs font-bold text-white">
                    {item.vote_average.toFixed(1)}
                </div>
            )}
        </button>
    )
}

export default CategoryPage

```

---

## client/src/components/ErrorBoundary.jsx

```javascript
/**
 * ErrorBoundary Component - Global error handler for TV interface
 * SEC-01: Prevents white screen of death on navigation/render crashes
 *
 * Features:
 * - Catches React render errors
 * - Shows TV-friendly error UI with restart button
 * - Logs errors for debugging
 * - D-pad friendly (focusable buttons)
 */
import { Component } from 'react'

class ErrorBoundary extends Component {
    constructor(props) {
        super(props)
        this.state = {
            hasError: false,
            error: null,
            errorInfo: null
        }
    }

    static getDerivedStateFromError(error) {
        // Update state so next render shows fallback UI
        return { hasError: true, error }
    }

    componentDidCatch(error, errorInfo) {
        // Log error for debugging
        console.error('[ErrorBoundary] Caught error:', error)
        console.error('[ErrorBoundary] Component stack:', errorInfo?.componentStack)

        this.setState({ errorInfo })

        // Optional: Send to error tracking service
        // reportErrorToService(error, errorInfo)
    }

    handleReload = () => {
        window.location.reload()
    }

    handleReset = () => {
        this.setState({
            hasError: false,
            error: null,
            errorInfo: null
        })
    }

    render() {
        if (this.state.hasError) {
            // TV-friendly error UI
            return (
                <div className="min-h-screen bg-gray-900 flex items-center justify-center p-8">
                    <div className="max-w-lg w-full text-center">
                        {/* Error Icon */}
                        <div className="text-8xl mb-6">‚ö†Ô∏è</div>

                        {/* Title */}
                        <h1 className="text-3xl font-bold text-white mb-4">
                            –ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫
                        </h1>

                        {/* Description */}
                        <p className="text-gray-400 text-lg mb-8">
                            –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞.
                            <br />
                            –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.
                        </p>

                        {/* Error details (collapsed by default) */}
                        {this.state.error && (
                            <details className="mb-8 text-left bg-gray-800 rounded-lg p-4">
                                <summary className="text-gray-500 cursor-pointer focus:outline-none focus:text-white">
                                    –ü–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏ –æ—à–∏–±–∫–∏
                                </summary>
                                <pre className="mt-3 text-xs text-red-400 overflow-auto max-h-32">
                                    {this.state.error.toString()}
                                    {this.state.errorInfo?.componentStack && (
                                        <span className="text-gray-500">
                                            {this.state.errorInfo.componentStack}
                                        </span>
                                    )}
                                </pre>
                            </details>
                        )}

                        {/* Action Buttons - TV Friendly */}
                        <div className="flex flex-col gap-4">
                            <button
                                onClick={this.handleReload}
                                autoFocus
                                className="w-full bg-purple-600 text-white py-4 px-8 rounded-xl text-xl font-bold
                                           hover:bg-purple-500 transition-colors
                                           focus:ring-4 focus:ring-purple-400 focus:outline-none focus:scale-105"
                            >
                                üîÑ –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å
                            </button>

                            <button
                                onClick={this.handleReset}
                                className="w-full bg-gray-700 text-gray-300 py-3 px-6 rounded-xl text-lg
                                           hover:bg-gray-600 transition-colors
                                           focus:ring-4 focus:ring-gray-400 focus:outline-none focus:scale-105"
                            >
                                ‚Ü©Ô∏è –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞
                            </button>
                        </div>

                        {/* Hint for TV users */}
                        <p className="text-gray-600 text-sm mt-8">
                            –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø—É–ª—å—Ç –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
                        </p>
                    </div>
                </div>
            )
        }

        return this.props.children
    }
}

export default ErrorBoundary

```

---

## client/src/components/HomePanel.jsx

```javascript
/**
 * HomePanel.jsx ‚Äì FIXED TV Navigation
 * 
 * Key fixes:
 * - Proper ref passing to HomeRow
 * - Clean ArrowUp/Down handling
 * - No double event processing
 */

import React, { useState, useEffect, useCallback, useRef } from 'react'
import HomeRow from './HomeRow'
import CategoryPage from './CategoryPage'
import MovieDetail from './MovieDetail'
import PersonDetail from './PersonDetail'
import Sidebar from './Sidebar'
import { fetchAllDiscovery, getBackdropUrl, getTitle } from '../utils/discover'
import tmdbClient, { getDiscoverByGenre } from '../utils/tmdbClient'
import { useSpatialItem } from '../hooks/useSpatialNavigation'

const HomePanel = ({
    activeMovie, setActiveMovie,
    activePerson, setActivePerson,
    activeCategory, setActiveCategory,
    showSidebar, setShowSidebar,
    onSearch, onClose
}) => {
    const [categories, setCategories] = useState({})
    const [loading, setLoading] = useState(true)
    const [error, setError] = useState(null)
    const [backdrop, setBackdrop] = useState(null)
    const [focusedItem, setFocusedItem] = useState(null)
    const [visibleRows, setVisibleRows] = useState([])

    const sidebarTriggerRef = useSpatialItem('main')

    // Data Loading
    useEffect(() => {
        const loadData = async () => {
            try {
                setLoading(true)
                const results = await fetchAllDiscovery()
                setCategories(results)
                const nonEmptyRows = Object.values(results).filter(row => row.items?.length > 0)
                setVisibleRows(nonEmptyRows)
                if (nonEmptyRows[0]?.items?.[0]) setFocusedItem(nonEmptyRows[0].items[0])
            } catch (err) {
                console.error(err)
                setError(err.message || 'Failed to load content')
            } finally {
                setLoading(false)
            }
        }
        loadData()
    }, [])

    // Update backdrop
    useEffect(() => {
        if (!activeMovie && !activePerson && !activeCategory && focusedItem) {
            setBackdrop(getBackdropUrl(focusedItem))
        }
    }, [focusedItem, activeMovie, activePerson, activeCategory])

    // Handlers
    const handleItemClick = (item) => setActiveMovie(item)

    const handlePersonClick = (person) => {
        setActiveMovie(null)
        setActivePerson(person)
    }

    const handleGenreClick = (genre, type = 'movie') => {
        setActiveMovie(null)
        setActiveCategory({
            id: `genre-${genre.id}`,
            name: genre.name,
            icon: 'üè∑Ô∏è',
            fetcher: (page) => getDiscoverByGenre(genre.id, type, page)
        })
    }
    const handleMoreClick = (categoryId) => {
        const cat = categories[categoryId]
        if (cat) setActiveCategory(cat)
    }

    const handleSidebarSelect = (item) => {
        if (item.id === 'search') {
            onSearch?.('')
        } else if (item.type === 'year') {
            setActiveCategory({
                id: `year_${item.year}`,
                name: `${item.year} –≥–æ–¥`,
                icon: 'üìÖ',
                fetcher: (page) => tmdbClient(`/discover/movie?primary_release_year=${item.year}&sort_by=popularity.desc&include_adult=false&language=ru-RU&page=${page}`)
            })
        } else if (item.categoryId?.startsWith('genre_')) {
            const genreId = parseInt(item.categoryId.split('_')[1])
            setActiveCategory({ id: genreId, name: item.label, type: 'movie', fetcher: (page) => getDiscoverByGenre(genreId, 'movie', page) })
        } else if (item.categoryId) {
            handleMoreClick(item.categoryId)
        }
        setShowSidebar(false)
    }

    // Render Sub-Views
    if (activeMovie) return (
        <MovieDetail
            item={activeMovie}
            onBack={() => setActiveMovie(null)}
            onSearch={onSearch}
            onSelect={setActiveMovie}
            onSelectPerson={handlePersonClick}
            onSelectGenre={handleGenreClick}
        />
    )

    if (activePerson) return (
        <PersonDetail
            personId={activePerson.id || activePerson}
            onBack={() => setActivePerson(null)}
            onSelectMovie={setActiveMovie}
        />
    )

    if (activeCategory) return (
        <CategoryPage
            customCategory={activeCategory}
            onBack={() => setActiveCategory(null)}
            onItemClick={setActiveMovie}
            onFocusChange={setFocusedItem}
        />
    )

    return (
        <div className="flex h-full w-full bg-[#141414] overflow-hidden">
            <Sidebar
                isOpen={showSidebar}
                onSelect={handleSidebarSelect}
                onClose={() => setShowSidebar(false)}
            />

            <div className={`flex-1 relative transition-all duration-300 ${showSidebar ? 'opacity-50 blur-sm' : ''}`}>
                <div className="absolute inset-0 bg-gradient-to-b from-gray-900 via-[#141414] to-[#141414]" />

                <div className="relative z-10 pt-4 pb-20 px-8 h-full overflow-y-auto custom-scrollbar">
                    {/* Header */}
                    {focusedItem && !loading && (
                        <div className="px-4 mb-10 max-w-2xl">
                            <h1 className="text-4xl font-bold text-white mb-2 drop-shadow-lg">{getTitle(focusedItem)}</h1>
                            <div className="flex items-center gap-4 mb-4">
                                {focusedItem.vote_average > 0 && <span className="bg-green-600 px-2 py-0.5 rounded font-bold text-xs text-white">‚òÖ {focusedItem.vote_average.toFixed(1)}</span>}
                                {focusedItem.release_date && <span className="text-gray-300">{(focusedItem.release_date || focusedItem.first_air_date)?.substring(0, 4)}</span>}
                            </div>
                            <p className="text-gray-300 line-clamp-3 text-lg leading-relaxed">{focusedItem.overview}</p>
                        </div>
                    )}

                    {!loading && visibleRows.map((row) => (
                        <HomeRow
                            key={row.id}
                            title={row.name}
                            items={row.items}
                            categoryId={row.id}
                            onItemClick={handleItemClick}
                            onFocusChange={setFocusedItem}
                            onMoreClick={handleMoreClick}
                        />
                    ))}
                </div>

                {/* Menu / Sidebar Trigger */}
                {!showSidebar && (
                    <button
                        ref={sidebarTriggerRef}
                        onClick={() => setShowSidebar(true)}
                        className="focusable fixed top-4 left-4 z-50 p-3 bg-gray-800 focus:bg-blue-600 rounded-full text-white shadow-xl transition-all"
                    >‚ò∞</button>
                )}
            </div>
        </div>
    )
}

export default HomePanel
```

---

## client/src/components/HomeRow.jsx

```javascript
import React, { useRef, useState, forwardRef } from 'react'
import { getPosterUrl, getTitle } from '../utils/discover'
import { reportBrokenImage } from '../utils/tmdbClient'
import { useSpatialItem } from '../hooks/useSpatialNavigation'

const MovieCard = ({ item, onItemClick, onFocus, imageErrors, setImageErrors }) => {
    const spatialRef = useSpatialItem('main')
    const posterUrl = getPosterUrl(item)
    const title = getTitle(item)

    return (
        <button
            ref={spatialRef}
            className="focusable tv-card snap-item w-[130px] aspect-[2/3] rounded-lg bg-gray-800 border border-transparent overflow-hidden"
            onClick={() => onItemClick?.(item)}
            onFocus={onFocus}
        >
            {posterUrl && !imageErrors.has(posterUrl) ? (
                <img
                    src={posterUrl}
                    alt={title}
                    className="w-full h-full object-cover"
                    loading="lazy"
                    onError={() => {
                        reportBrokenImage?.(posterUrl)
                        setImageErrors(prev => new Set(prev).add(posterUrl))
                    }}
                />
            ) : (
                <div className="w-full h-full flex items-center justify-center p-2 text-center text-xs text-white">
                    {title}
                </div>
            )}

            {/* Rating Badge */}
            {item.vote_average > 0 && (
                <div className={`absolute top-1 right-1 text-[10px] font-bold px-1.5 py-0.5 rounded text-white ${item.vote_average >= 7 ? 'bg-green-500' :
                    item.vote_average >= 5 ? 'bg-yellow-500 text-black' : 'bg-red-500'
                    }`}>
                    {item.vote_average.toFixed(1)}
                </div>
            )}
        </button>
    )
}

const HomeRow = forwardRef(({
    title,
    icon,
    items = [],
    categoryId,
    onItemClick,
    onFocusChange,
    onMoreClick
}, ref) => {
    const [imageErrors, setImageErrors] = useState(new Set())
    const moreRef = useSpatialItem('main')

    if (items.length === 0) return null

    return (
        <div className="home-row mb-6">
            {/* Row Title */}
            <div className="flex items-center justify-between px-8 mb-3">
                <h2 className="text-xl font-bold text-white flex items-center gap-2 drop-shadow-lg">
                    <span className="text-2xl">{icon}</span>
                    {title}
                    <span className="text-gray-500 text-sm font-normal">({items.length})</span>
                </h2>
            </div>

            {/* Snap Container (Pure CSS Scroll) */}
            <div className="snap-container px-8 gap-4 overflow-x-auto scroll-smooth scrollbar-hide py-6 -my-4">
                {items.map((item, index) => (
                    <MovieCard
                        key={item.id || index}
                        item={item}
                        onItemClick={onItemClick}
                        onFocus={() => onFocusChange?.(item)}
                        imageErrors={imageErrors}
                        setImageErrors={setImageErrors}
                    />
                ))}

                {/* "More" Card */}
                {onMoreClick && (
                    <button
                        onClick={() => onMoreClick(categoryId)}
                        className="focusable snap-item w-[130px] aspect-[2/3] rounded-lg bg-gray-800/60 border-2 border-gray-600 flex flex-col items-center justify-center gap-2"
                        ref={moreRef}
                    >
                        <span className="text-5xl text-gray-300">‚Üí</span>
                        <span className="text-gray-300 text-sm font-semibold">–ï—â—ë</span>
                    </button>
                )}
            </div>
        </div>
    )
})

HomeRow.displayName = 'HomeRow'

export default HomeRow
```

---

## client/src/components/MovieDetail.jsx

```javascript
import { useRef, useEffect, useState } from 'react'
import { App as CapacitorApp } from '@capacitor/app'
import { Browser } from '@capacitor/browser'
import { getBackdropUrl, getPosterUrl, getTitle, getYear, getSearchQuery, getImageUrl } from '../utils/discover'
import { getGenreObjectsForItem } from '../utils/genres'
import { reportBrokenImage, getCredits, getVideos, getDetails, getSeasonDetails, getRecommendations } from '../utils/tmdbClient'
import { useSpatialItem } from '../hooks/useSpatialNavigation'

// ‚îÄ‚îÄ‚îÄ Sub-Components ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const GenreButton = ({ genre, onClick }) => {
    const spatialRef = useSpatialItem('detail')
    return (
        <button
            ref={spatialRef}
            onClick={() => onClick?.(genre)}
            className="focusable px-3 py-1 bg-gray-800/60 focus:bg-blue-600 focus:text-white rounded-full text-sm text-gray-300"
        >{genre.name}</button>
    )
}

const CastButton = ({ actor, onClick }) => {
    const spatialRef = useSpatialItem('detail')
    return (
        <button
            ref={spatialRef}
            onClick={() => onClick?.(actor)}
            className="focusable relative flex-shrink-0 w-24 h-36 bg-gray-800 rounded-lg overflow-hidden focus:ring-4 focus:ring-blue-500 shadow-xl"
        >
            <img src={getImageUrl(actor.profile_path, 'w185')} className="w-full h-full object-cover" />
            <div className="absolute bottom-0 inset-x-0 bg-black/60 p-1">
                <p className="text-[10px] text-white font-bold truncate">{actor.name}</p>
            </div>
        </button>
    )
}

const SeasonButton = ({ season, active, onClick, posterUrl }) => {
    const spatialRef = useSpatialItem('detail')
    return (
        <button
            ref={spatialRef}
            onClick={() => onClick?.(season)}
            className={`focusable relative flex-shrink-0 w-32 aspect-[2/3] rounded-xl overflow-hidden focus:ring-4 focus:ring-blue-500 transition-all ${active ? 'ring-2 ring-green-500' : ''}`}
        >
            <img src={getPosterUrl(season, 'w342') || posterUrl} className="w-full h-full object-cover" />
            <div className="absolute bottom-0 inset-x-0 bg-black/80 p-2 text-xs text-white font-bold">
                –°–µ–∑–æ–Ω {season.season_number}
            </div>
        </button>
    )
}

const EpisodeRow = ({ ep, onClick }) => {
    const spatialRef = useSpatialItem('detail')
    return (
        <button
            ref={spatialRef}
            onClick={() => onClick?.(ep)}
            className="focusable w-full flex items-center gap-4 p-3 bg-gray-800/40 focus:bg-blue-600 text-left rounded-xl transition-all"
        >
            <div className="w-24 aspect-video bg-black rounded overflow-hidden flex-shrink-0">
                <img src={getImageUrl(ep.still_path, 'w300')} className="w-full h-full object-cover" />
            </div>
            <div className="flex-1">
                <div className="text-sm font-bold text-white">E{ep.episode_number}. {ep.name}</div>
                <div className="text-xs text-gray-400 line-clamp-1">{ep.overview}</div>
            </div>
        </button>
    )
}

const RecButton = ({ rec, onClick }) => {
    const spatialRef = useSpatialItem('detail')
    return (
        <button
            ref={spatialRef}
            onClick={() => onClick?.(rec)}
            className="focusable relative flex-shrink-0 w-32 aspect-[2/3] rounded-xl shadow-lg focus:ring-4 focus:ring-blue-500 transition-all overflow-hidden"
        >
            <img src={getPosterUrl(rec, 'w342')} className="w-full h-full object-cover" />
        </button>
    )
}

// ‚îÄ‚îÄ‚îÄ Main Component ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const MovieDetail = ({
    item,
    onSearch,
    onBack,
    onSelect,
    onSelectPerson,
    onSelectGenre,
}) => {
    const [directors, setDirectors] = useState([])
    const [cast, setCast] = useState([])
    const [seasons, setSeasons] = useState([])
    const [selectedSeason, setSelectedSeason] = useState(null)
    const [episodes, setEpisodes] = useState([])
    const [recommendations, setRecommendations] = useState([])
    const [trailer, setTrailer] = useState(null)
    const [loadingExtra, setLoadingExtra] = useState(true)
    const [allowInteraction, setAllowInteraction] = useState(false)

    // Spatial Refs
    const searchBtnRef = useSpatialItem('detail')
    const backBtnRef = useSpatialItem('detail')
    const trailerBtnRef = useSpatialItem('detail')

    useEffect(() => {
        // Prevent phantom clicks from previous screen (common on TV)
        const timer = setTimeout(() => setAllowInteraction(true), 500)
        return () => clearTimeout(timer)
    }, [])

    if (!item) return null

    const backdropUrl = getBackdropUrl(item, 'w1280')
    const posterUrl = getPosterUrl(item, 'w500')
    const title = getTitle(item)
    const year = getYear(item)
    const rating = item.vote_average?.toFixed(1)
    const overview = item.overview || '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç'
    const mediaType = item.media_type === 'tv' || item.name ? 'tv' : 'movie'
    const mediaTypeLabel = mediaType === 'tv' ? '–°–µ—Ä–∏–∞–ª' : '–§–∏–ª—å–º'
    const itemGenres = getGenreObjectsForItem(item)

    const fetchEpisodes = async (seasonNumber) => {
        try {
            const data = await getSeasonDetails(item.id, seasonNumber)
            setEpisodes(data.episodes || [])
        } catch (err) {
            console.error(err)
        }
    }

    const handleSeasonSelect = (season) => {
        setSelectedSeason(season)
        fetchEpisodes(season.season_number)
    }

    const handleEpisodeClick = (episode) => {
        const s = episode.season_number.toString().padStart(2, '0')
        const e = episode.episode_number.toString().padStart(2, '0')
        onSearch?.(`${title} S${s}E${e}`)
    }

    useEffect(() => {
        if (!item?.id) return
        const controller = new AbortController()
        const load = async () => {
            setLoadingExtra(true)
            try {
                const details = await getDetails(item.id, mediaType)
                if (details && mediaType === 'tv') setSeasons(details.seasons || [])
                const creditsData = await getCredits(item.id, mediaType)
                setDirectors(creditsData.crew?.filter(p => p.job === 'Director') || [])
                setCast(creditsData.cast?.slice(0, 8) || [])
                const videosData = await getVideos(item.id, mediaType)
                setTrailer(videosData.results?.find(v => v.type === 'Trailer') || videosData.results?.[0])
                const recData = await getRecommendations(item.id, mediaType)
                setRecommendations(recData.results || [])
            } catch (err) { console.warn(err) }
            finally { if (!controller.signal.aborted) setLoadingExtra(false) }
        }
        load()
        return () => controller.abort()
    }, [item?.id])

    return (
        <div className="movie-detail fixed inset-0 z-50 bg-gray-900 overflow-hidden">
            <div
                className="absolute inset-0 transition-opacity duration-500"
                style={{
                    background: backdropUrl
                        ? `linear-gradient(to right, rgba(17,24,39,1) 0%, rgba(17,24,39,0.8) 50%, rgba(17,24,39,0.4) 100%), url(${backdropUrl}) center/cover no-repeat`
                        : 'linear-gradient(to bottom, #1f2937, #111827)'
                }}
            />

            <div className="relative z-10 h-full overflow-y-auto custom-scrollbar p-6 md:p-10">
                <div className="grid grid-cols-1 md:grid-cols-[220px_1fr] gap-10 max-w-7xl mx-auto">
                    {/* Poster */}
                    <div className="hidden md:block">
                        <img src={posterUrl} className="w-[220px] aspect-[2/3] rounded-xl shadow-2xl object-cover border border-gray-700" />
                    </div>

                    {/* Info */}
                    <div className="flex flex-col gap-6 min-w-0">
                        <h1 className="text-4xl font-bold text-white drop-shadow-lg">{title}</h1>

                        <div className="flex flex-wrap gap-4 items-center">
                            {rating > 0 && <span className="px-3 py-1 bg-green-600 rounded-lg font-bold text-white">‚òÖ {rating}</span>}
                            {year && <span className="px-3 py-1 bg-gray-800 rounded-lg text-gray-200">{year}</span>}
                            <span className="px-3 py-1 bg-blue-600 rounded-lg text-white font-medium">{mediaTypeLabel}</span>
                        </div>

                        {/* Actions */}
                        <div className="flex flex-wrap gap-4">
                            <button
                                ref={searchBtnRef}
                                onClick={() => allowInteraction && onSearch?.(getSearchQuery(item))}
                                className={`focusable px-8 py-3 bg-blue-600 focus:bg-yellow-400 focus:text-black focus:ring-4 focus:ring-yellow-400 text-white font-bold rounded-xl transition-all ${!allowInteraction ? 'opacity-50' : ''}`}
                            >üîç –ù–∞–π—Ç–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç—ã</button>
                            <button
                                ref={backBtnRef}
                                onClick={onBack}
                                className="focusable px-8 py-3 bg-gray-800 focus:bg-white focus:text-black focus:ring-4 focus:ring-white text-white font-bold rounded-xl transition-all"
                            >‚¨ÖÔ∏è –ù–∞–∑–∞–¥</button>
                            {trailer && (
                                <button
                                    ref={trailerBtnRef}
                                    onClick={() => allowInteraction && Browser.open({ url: `https://www.youtube.com/watch?v=${trailer.key}` })}
                                    className="focusable px-6 py-3 bg-red-600 focus:bg-red-400 focus:ring-4 focus:ring-red-300 text-white font-bold rounded-xl transition-all"
                                >‚ñ∂Ô∏è –¢—Ä–µ–π–ª–µ—Ä</button>
                            )}
                        </div>

                        {/* Genres */}
                        <div className="flex flex-wrap gap-2">
                            {itemGenres.map((genre) => (
                                <GenreButton key={genre.id} genre={genre} onClick={onSelectGenre} />
                            ))}
                        </div>

                        {/* Description */}
                        <div className="bg-black/40 p-5 rounded-2xl backdrop-blur-sm max-w-3xl">
                            <p className="text-gray-200 leading-relaxed">{overview}</p>
                        </div>

                        {/* Cast */}
                        {cast.length > 0 && (
                            <div className="mt-4">
                                <h3 className="text-xl font-bold text-white mb-4">üé≠ –í —Ä–æ–ª—è—Ö</h3>
                                <div className="flex gap-4 overflow-x-auto py-4 custom-scrollbar px-2 -my-2">
                                    {cast.map((actor) => (
                                        <CastButton key={actor.id} actor={actor} onClick={onSelectPerson} />
                                    ))}
                                </div>
                            </div>
                        )}

                        {/* Seasons */}
                        {seasons.length > 0 && (
                            <div className="mt-4">
                                <h3 className="text-xl font-bold text-white mb-4">üì∫ –°–µ–∑–æ–Ω—ã</h3>
                                <div className="flex gap-4 overflow-x-auto pb-4 custom-scrollbar px-2">
                                    {seasons.filter(s => s.season_number > 0).map((season) => (
                                        <SeasonButton
                                            key={season.id}
                                            season={season}
                                            active={selectedSeason?.id === season.id}
                                            onClick={handleSeasonSelect}
                                            posterUrl={posterUrl}
                                        />
                                    ))}
                                </div>
                            </div>
                        )}

                        {/* Episodes */}
                        {episodes.length > 0 && (
                            <div className="mt-6 bg-black/20 p-4 rounded-2xl">
                                <h3 className="text-xl font-bold text-white mb-4">üé¨ –≠–ø–∏–∑–æ–¥—ã ({selectedSeason?.name})</h3>
                                <div className="space-y-2">
                                    {episodes.map((ep) => (
                                        <EpisodeRow key={ep.id} ep={ep} onClick={handleEpisodeClick} />
                                    ))}
                                </div>
                            </div>
                        )}

                        {/* Recommendations */}
                        {recommendations.length > 0 && (
                            <div className="mt-8">
                                <h3 className="text-xl font-bold text-white mb-4">‚ú® –ü–æ—Ö–æ–∂–µ–µ</h3>
                                <div className="flex gap-4 overflow-x-auto pt-4 pb-12 custom-scrollbar px-2 -my-4">
                                    {recommendations.slice(0, 10).map((rec) => (
                                        <RecButton key={rec.id} rec={rec} onClick={onSelect} />
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </div>
    )
}

export default MovieDetail

```

---

## client/src/components/PersonDetail.jsx

```javascript
import { useEffect, useState } from 'react'
import { App as CapacitorApp } from '@capacitor/app'
import { getImageUrl, getPersonDetails, getPersonCredits } from '../utils/tmdbClient'
import { getPosterUrl } from '../utils/discover'
import { useSpatialItem } from '../hooks/useSpatialNavigation'

const FilmItem = ({ item, onClick }) => {
    const spatialRef = useSpatialItem('person')
    return (
        <button
            ref={spatialRef}
            onClick={onClick}
            className="focusable relative aspect-[2/3] bg-gray-800 rounded-xl overflow-hidden cursor-pointer transition-all duration-200 focus:ring-4 focus:ring-blue-500 scale-100 focus:scale-105 z-10 shadow-xl"
        >
            {item.poster_path ? (
                <img
                    src={getPosterUrl(item)}
                    loading="lazy"
                    className="w-full h-full object-cover"
                />
            ) : (
                <div className="w-full h-full flex items-center justify-center">?</div>
            )}

            {item.vote_average > 0 && (
                <div className="absolute top-2 right-2 bg-black/70 px-2 py-1 rounded text-xs font-bold text-white">
                    ‚òÖ {item.vote_average.toFixed(1)}
                </div>
            )}

            <div className="absolute bottom-0 inset-x-0 bg-gradient-to-t from-black via-black/80 to-transparent p-3 pt-8 text-left">
                <div className="text-white font-bold text-sm truncate">{item.title || item.name}</div>
                <div className="text-gray-400 text-xs truncate">
                    {item.character ? `–∫–∞–∫ ${item.character}` : (item.job || '–ê–∫—Ç—ë—Ä')}
                </div>
            </div>
        </button>
    )
}

const PersonDetail = ({
    personId,
    onBack,
    onSelectMovie
}) => {
    const [person, setPerson] = useState(null)
    const [credits, setCredits] = useState([])
    const [loading, setLoading] = useState(true)

    // Spatial Refs
    const { ref: sectionRef } = useSpatialItem('person-detail')
    const backBtnRef = useSpatialItem('person')

    // Handle Hardware Back Button
    useEffect(() => {
        const handleHardwareBack = async () => {
            onBack()
        }

        const listener = CapacitorApp.addListener('backButton', handleHardwareBack)
        return () => { listener.then(h => h.remove()) }
    }, [onBack])

    // Load Data
    useEffect(() => {
        if (!personId) return

        const loadData = async () => {
            setLoading(true)
            try {
                // Determine if personId is an object (already loaded) or ID
                const id = typeof personId === 'object' ? personId.id : personId

                const [details, creditsData] = await Promise.all([
                    getPersonDetails(id),
                    getPersonCredits(id)
                ])

                setPerson(details)
                setCredits(creditsData.cast || [])
            } catch (err) {
                console.error('Failed to load person details:', err)
            } finally {
                setLoading(false)
            }
        }

        loadData()
    }, [personId])

    if (loading) {
        return (
            <div className="fixed inset-0 z-50 bg-[#141414] flex items-center justify-center">
                <div className="w-12 h-12 border-4 border-blue-500/30 border-t-blue-500 rounded-full animate-spin" />
            </div>
        )
    }

    if (!person) return null

    return (
        <div
            ref={sectionRef}
            className="fixed inset-0 z-50 bg-[#141414] animate-fade-in overflow-y-auto custom-scrollbar"
        >
            <div className="min-h-full relative p-8">
                {/* Back Button - Standard Flow */}
                <div className="pb-8 z-[60] relative">
                    <button
                        ref={backBtnRef}
                        onClick={onBack}
                        className="focusable px-6 py-3 bg-gray-800 hover:bg-gray-700 text-white font-bold rounded-xl flex items-center gap-2 transition-all focus:ring-4 focus:ring-blue-500 scale-100 focus:scale-105 shadow-xl"
                        autoFocus
                    >
                        <span className="text-xl">‚Üê</span>
                        –ù–∞–∑–∞–¥
                    </button>
                </div>

                <div className="flex flex-col md:flex-row gap-8 pt-4">
                    {/* Photo */}
                    <div className="flex-shrink-0 mx-auto md:mx-0">
                        <div className="w-64 h-96 rounded-xl overflow-hidden shadow-2xl bg-gray-800">
                            {person.profile_path ? (
                                <img
                                    src={getImageUrl(person.profile_path, 'h632')}
                                    className="w-full h-full object-cover"
                                />
                            ) : (
                                <div className="w-full h-full flex items-center justify-center text-6xl">üë§</div>
                            )}
                        </div>
                    </div>

                    {/* Bio */}
                    <div className="flex-1 text-white">
                        <h1 className="text-4xl font-bold mb-2">{person.name}</h1>
                        <div className="text-gray-400 mb-6 flex gap-4">
                            {person.birthday && <span>üéÇ {person.birthday}</span>}
                            {person.place_of_birth && <span>üìç {person.place_of_birth}</span>}
                        </div>

                        <h3 className="text-xl font-bold mb-2">–ë–∏–æ–≥—Ä–∞—Ñ–∏—è</h3>
                        <p className="text-gray-300 leading-relaxed max-w-3xl text-sm md:text-base">
                            {person.biography || "–ë–∏–æ–≥—Ä–∞—Ñ–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç."}
                        </p>
                    </div>
                </div>

                {/* Filmography Grid */}
                <div className="mt-12 pb-20">
                    <h2 className="text-2xl font-bold text-white mb-6">–§–∏–ª—å–º–æ–≥—Ä–∞—Ñ–∏—è ({credits.length})</h2>

                    <div
                        className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 gap-6"
                        onKeyDown={(e) => {
                            if (e.key === 'ArrowUp') {
                                const current = document.activeElement
                                const items = Array.from(e.currentTarget.querySelectorAll('button.focusable'))
                                const currentIndex = items.indexOf(current)
                                if (currentIndex === -1) return

                                // Check if there are any items physically above the current one in the grid
                                const currentRect = current.getBoundingClientRect()
                                const hasItemAbove = items.some(item => {
                                    const rect = item.getBoundingClientRect()
                                    // Item is considered "above" if its center is significantly higher
                                    return rect.bottom <= currentRect.top + 10 // 10px tolerance
                                })

                                // If no items above (Top Row), manually jump to Back Button
                                if (!hasItemAbove) {
                                    e.preventDefault()
                                    e.stopPropagation()
                                    backBtnRef.current?.focus()
                                }
                            }
                        }}
                    >
                        {credits.map((item, idx) => (
                            <FilmItem
                                key={`${item.id}-${idx}`}
                                item={item}
                                onClick={() => onSelectMovie(item)}
                            />
                        ))}
                    </div>
                </div>
            </div>
        </div>
    )
}

export default PersonDetail

```

---

## client/src/components/Poster.jsx

```javascript
import { useState, useEffect } from 'react'
import { cleanTitle, formatSize, formatSpeed, formatEta, getGradient } from '../utils/helpers'
import { getMetadata, resolveMetadata } from '../utils/tmdbClient'
import { useSpatialItem } from '../hooks/useSpatialNavigation'

const Poster = ({ name, onClick, progress, peers, isReady, size, downloadSpeed, downloaded, eta, newFilesCount }) => {
    const spatialRef = useSpatialItem('main')
    const [bgImage, setBgImage] = useState(null)
    const cleanedName = cleanTitle(name)

    useEffect(() => {
        if (!cleanedName) return

        let isMounted = true

        const cached = getMetadata(cleanedName)
        if (cached?.poster) {
            setBgImage(cached.poster)
        }

        const fetchImage = async () => {
            try {
                const metadata = await resolveMetadata(cleanedName)
                if (isMounted && metadata?.poster) {
                    setBgImage(metadata.poster)
                }
            } catch (err) {
                console.warn('[Poster] Load failed:', cleanedName, err)
            }
        }

        fetchImage()

        return () => { isMounted = false }
    }, [cleanedName])

    return (
        <button
            ref={spatialRef}
            onClick={onClick}
            className={`
          focusable relative group aspect-[2/3] rounded-xl overflow-hidden shadow-xl
          transition-all duration-300
          focus:scale-105 focus:ring-4 focus:ring-blue-500 focus:z-20 outline-none
          hover:scale-105
          bg-gray-800
        `}
            style={{
                background: !bgImage ? getGradient(name) : undefined,
                boxSizing: 'border-box'
            }}
        >
            {bgImage ? (
                <img
                    src={bgImage}
                    alt={name}
                    className="w-full h-full object-cover transition-opacity duration-500"
                    loading="lazy"
                    decoding="async"
                    onError={() => setBgImage(null)}
                />
            ) : (
                <>
                    <div className="absolute -top-10 -right-10 w-32 h-32 bg-white/5 rounded-full blur-2xl pointer-events-none" />
                    <div className="absolute bottom-10 -left-10 w-24 h-24 bg-black/20 rounded-full blur-xl pointer-events-none" />
                    <div className="absolute inset-0 flex items-center justify-center p-4 text-center">
                        <h3 className="text-gray-100 font-bold text-lg leading-snug drop-shadow-lg line-clamp-4 font-sans tracking-wide">
                            {cleanedName || name}
                        </h3>
                    </div>
                </>
            )}

            <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-transparent to-black/10 flex flex-col justify-end p-3 text-left">
                <div className="absolute top-2 right-2 flex gap-1">
                    {newFilesCount > 0 && (
                        <span className="bg-purple-500 text-white text-[10px] font-black tracking-wider px-2 py-0.5 rounded shadow-sm animate-pulse">
                            üÜï {newFilesCount} NEW
                        </span>
                    )}
                    {isReady ? (
                        <span className="bg-green-500 text-white text-[10px] font-black tracking-wider px-2 py-0.5 rounded shadow-sm">READY</span>
                    ) : (
                        <span className="bg-yellow-500 text-black text-[10px] font-black tracking-wider px-2 py-0.5 rounded shadow-sm">{Math.round(progress * 100)}%</span>
                    )}
                </div>

                <div className="text-xs text-gray-400 flex flex-col gap-1 mt-auto">
                    {!isReady && downloaded > 0 && (
                        <div className="flex items-center justify-between gap-2">
                            <span className="text-blue-400">
                                {formatSize(downloaded)} / {formatSize(size)}
                            </span>
                            {eta > 0 && (
                                <span className="text-yellow-400">‚è± {formatEta(eta)}</span>
                            )}
                        </div>
                    )}

                    <div className="flex items-center gap-2">
                        <span className="flex items-center gap-1">
                            <svg className="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3zM6 8a2 2 0 11-4 0 2 2 0 014 0zM16 18v-3a5.972 5.972 0 00-.75-2.906A3.005 3.005 0 0119 15v3h-3zM4.75 12.094A5.973 5.973 0 004 15v3H1v-3a3 3 0 013.75-2.906z"></path></svg>
                            {peers}
                        </span>
                        {isReady && size > 0 && (
                            <span className="text-gray-500">{formatSize(size)}</span>
                        )}
                        {!isReady && downloadSpeed > 0 && (
                            <span className="text-green-400">‚Üì{formatSpeed(downloadSpeed)}</span>
                        )}
                    </div>

                    {!isReady && progress > 0 && (
                        <div className="w-full h-1.5 bg-gray-700 rounded-full overflow-hidden">
                            <div style={{ width: `${progress * 100}%` }} className="h-full bg-gradient-to-r from-blue-500 to-green-500 transition-all duration-300" />
                        </div>
                    )}
                </div>
            </div>
        </button>
    )
}

export default Poster

```

---

## client/src/components/SearchPanel.jsx

```javascript
import { useState, useEffect, useMemo, useRef } from 'react'
import { SpeechRecognition } from '@capacitor-community/speech-recognition'
import { useDebounce } from '../hooks/useDebounce'
import SpatialEngine, { useSpatialItem } from '../hooks/useSpatialNavigation'

// ‚îÄ‚îÄ‚îÄ Sub-Components ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const formatRelativeDate = (timestamp) => {
    if (!timestamp) return null
    const now = Date.now()
    const diff = now - timestamp
    const minutes = Math.floor(diff / 60000)
    const hours = Math.floor(diff / 3600000)
    const days = Math.floor(diff / 86400000)
    if (minutes < 1) return '—Ç–æ–ª—å–∫–æ —á—Ç–æ'
    if (minutes < 60) return `${minutes} –º–∏–Ω`
    if (hours < 24) return `${hours} —á`
    if (days < 7) return `${days} –¥–Ω`
    return new Date(timestamp).toLocaleDateString('ru-RU', { day: 'numeric', month: 'short' })
}

const getHealthIcon = (health) => {
    switch (health) {
        case 'excellent': return 'üü¢'
        case 'good': return 'üü°'
        case 'poor': return 'üü†'
        default: return 'üî¥'
    }
}

const SearchResultItem = ({ item, index, onAdd }) => {
    const rowRef = useSpatialItem('search')

    return (
        <div
            ref={rowRef}
            className="focusable flex items-start justify-between p-3 bg-gray-800 rounded-lg cursor-pointer focus:bg-purple-700 focus:ring-2 focus:ring-purple-500 group transition-colors"
            onClick={() => onAdd(item.magnet || item.id, item.title)}
        >
            <div className="flex-1 min-w-0">
                <div className="text-sm font-medium text-white truncate">{item.title}</div>
                <div className="text-xs text-gray-400 flex flex-wrap gap-x-3 mt-1">
                    <span>üì¶ {item.size}</span>
                    <span className="text-green-400">{getHealthIcon(item.health)} {item.seeders}</span>
                    {item.tracker && <span className="text-purple-400">{item.tracker}</span>}
                    {item.dateTs && <span className="text-gray-500">{formatRelativeDate(item.dateTs)}</span>}
                </div>
            </div>
            {/* Visual hint that Enter/OK will add */}
            <span className="ml-2 text-gray-500 group-focus:text-green-400 text-lg transition-colors">‚ûï</span>
        </div>
    )
}

const SearchFilter = ({ tag, active, onClick }) => {
    const spatialRef = useSpatialItem('search')
    return (
        <button
            ref={spatialRef}
            onClick={onClick}
            className={`focusable px-2.5 py-1 rounded-full text-xs border ${active ? 'bg-purple-600 border-purple-400' : 'bg-gray-800 text-gray-400'}`}
        >{tag.toUpperCase()}</button>
    )
}

const SearchSort = ({ opt, active, onClick }) => {
    const spatialRef = useSpatialItem('search')
    return (
        <button
            ref={spatialRef}
            onClick={onClick}
            className={`focusable px-2.5 py-1 rounded text-xs ${active ? 'bg-purple-600 text-white' : 'bg-gray-800 text-gray-400'}`}
        >{opt === 'seeders' ? '‚¨Ü' : opt === 'size' ? 'üì¶' : 'üìÖ'}</button>
    )
}

const getProviderInfo = (status, count) => {
    if (count > 0) return { icon: '‚úÖ', style: 'bg-green-900/40 text-green-400 border-green-500/40', label: 'OK' }
    switch (status) {
        case 'ok': return { icon: '‚úÖ', style: 'bg-green-900/30 text-green-400 border-green-500/30', label: 'OK' }
        case 'timeout': return { icon: '‚è±Ô∏è', style: 'bg-yellow-900/40 text-yellow-400 border-yellow-500/40', label: 'Timeout' }
        case 'circuit_open': return { icon: 'üîí', style: 'bg-gray-800/50 text-gray-500 border-gray-600/30', label: 'Disabled' }
        case 'error': return { icon: '‚ùå', style: 'bg-red-900/40 text-red-400 border-red-500/40', label: 'Error' }
        default: return { icon: '‚óã', style: 'bg-gray-800/30 text-gray-400 border-gray-600/30', label: 'Unknown' }
    }
}

// ‚îÄ‚îÄ‚îÄ Main Component ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const SearchPanel = ({
    searchQuery,
    onSearchQueryChange,
    onSearch,
    onClose,
    onAddTorrent,
    searchResults,
    searchLoading,
    providers = {}
}) => {
    const [activeFilters, setActiveFilters] = useState([])
    const [sortBy, setSortBy] = useState('seeders')
    const [isListening, setIsListening] = useState(false)
    const [voiceAvailable, setVoiceAvailable] = useState(false)
    const [providerTooltip, setProviderTooltip] = useState(null)

    // Activate 'search' zone on mount
    // NOTE: Zone cleanup is handled by App.jsx's zone management useEffect
    useEffect(() => {
        SpatialEngine.setActiveZone('search')
    }, [])

    // Spatial Refs
    const inputRef = useSpatialItem('search')
    const micRef = useSpatialItem('search')
    const searchRef = useSpatialItem('search')
    const closeRef = useSpatialItem('search')

    const debouncedFilters = useDebounce(activeFilters, 150)

    const filteredResults = useMemo(() => {
        return searchResults.filter(r => {
            if (debouncedFilters.length === 0) return true
            return debouncedFilters.every(filter => (r.tags || []).includes(filter))
        })
    }, [searchResults, debouncedFilters])

    const sortedResults = useMemo(() => {
        return [...filteredResults].sort((a, b) => {
            switch (sortBy) {
                case 'seeders': return (b.seeders || 0) - (a.seeders || 0)
                case 'size': return (b.sizeBytes || 0) - (a.sizeBytes || 0)
                case 'date': return (b.dateTs || 0) - (a.dateTs || 0)
                default: return 0
            }
        })
    }, [filteredResults, sortBy])

    const availableTags = useMemo(() =>
        [...new Set(searchResults.flatMap(r => r.tags || []))]
        , [searchResults])
    const filterOptions = ['2160p', '1080p', '720p', 'hevc', 'hdr'].filter(t => availableTags.includes(t))

    const providerEntries = Object.entries(providers)

    useEffect(() => {
        const checkVoice = async () => {
            try {
                const { available } = await SpeechRecognition.available()
                setVoiceAvailable(available)
                if (available) await SpeechRecognition.requestPermissions()
            } catch { setVoiceAvailable(false) }
        }
        checkVoice()
    }, [])

    const startVoiceSearch = async () => {
        if (!voiceAvailable) {
            const query = prompt('üé§ –í–≤–µ–¥–∏—Ç–µ –∑–∞–ø—Ä–æ—Å:')
            if (query?.trim()) {
                onSearchQueryChange(query.trim())
                setTimeout(() => onSearch(), 200)
            }
            return
        }

        try {
            setIsListening(true)
            const result = await SpeechRecognition.start({
                language: 'ru-RU', maxResults: 1,
                prompt: '–ü—Ä–æ–∏–∑–Ω–µ—Å–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ', partialResults: false, popup: true
            })
            setIsListening(false)

            if (result.matches?.[0]) {
                const transcript = result.matches[0].trim()
                if (transcript) {
                    onSearchQueryChange(transcript)
                    setTimeout(() => onSearch(), 300)
                }
            }
        } catch { setIsListening(false) }
    }

    const toggleFilter = (filter) => {
        setActiveFilters(prev => prev.includes(filter) ? prev.filter(f => f !== filter) : [...prev, filter])
    }

    return (
        <div className="mb-6 p-4 bg-gray-900 rounded-xl border border-purple-600/50">
            {/* Search Row */}
            <div className="flex gap-2 mb-4">
                <input
                    ref={inputRef}
                    value={searchQuery}
                    onChange={(e) => onSearchQueryChange(e.target.value)}
                    onKeyDown={(e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault()
                            onSearch()
                        }
                    }}
                    placeholder="–ü–æ–∏—Å–∫ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤..."
                    className="focusable flex-1 bg-gray-800 border border-gray-700 rounded-lg px-4 py-3 focus:ring-2 focus:ring-purple-500 outline-none"
                    autoFocus
                />
                <button
                    ref={micRef}
                    onClick={startVoiceSearch}
                    tabIndex="0"
                    className={`focusable px-4 py-3 rounded-lg font-bold ${isListening ? 'bg-red-600 animate-pulse' : 'bg-gray-700'}`}
                >üé§</button>
                <button
                    ref={searchRef}
                    onClick={() => onSearch(searchQuery)}
                    disabled={searchLoading}
                    tabIndex="0"
                    className="focusable bg-purple-600 px-6 py-3 rounded-lg font-bold disabled:opacity-50"
                >{searchLoading ? '...' : 'üîç'}</button>
                <button
                    ref={closeRef}
                    onClick={onClose}
                    tabIndex="0"
                    className="focusable bg-gray-800 px-4 rounded-lg"
                >‚úï</button>
            </div>

            {/* Provider Status */}
            {providerEntries.length > 0 && (
                <div className="flex flex-wrap gap-2 mb-4 text-xs">
                    {providerEntries.map(([name, data]) => {
                        const info = getProviderInfo(data.status, data.count || 0)
                        const hasError = data.status === 'error' || data.status === 'timeout'

                        return (
                            <button
                                key={name}
                                onClick={() => hasError && setProviderTooltip(providerTooltip === name ? null : name)}
                                className={`px-2 py-1 rounded-full border ${info.style} ${hasError ? 'cursor-pointer' : 'cursor-default'}`}
                            >
                                {info.icon} {name}
                                {data.count > 0 && <span className="ml-1">({data.count})</span>}
                            </button>
                        )
                    })}
                </div>
            )}

            {/* Filters & Sort */}
            {searchResults.length > 0 && (
                <div className="flex flex-wrap items-center gap-2 mb-3">
                    {filterOptions.map(tag => (
                        <SearchFilter
                            key={tag}
                            tag={tag}
                            active={activeFilters.includes(tag)}
                            onClick={() => toggleFilter(tag)}
                        />
                    ))}
                    <div className="flex-1" />
                    {['seeders', 'size', 'date'].map(opt => (
                        <SearchSort
                            key={opt}
                            opt={opt}
                            active={sortBy === opt}
                            onClick={() => setSortBy(opt)}
                        />
                    ))}
                </div>
            )}

            {/* Results */}
            {sortedResults.length > 0 && (
                <div className="max-h-[50vh] overflow-y-auto space-y-2 pr-1 custom-scrollbar">
                    {sortedResults.map((r, i) => (
                        <SearchResultItem
                            key={r.id || i}
                            item={r}
                            onAdd={onAddTorrent}
                        />
                    ))}
                </div>
            )}

            {searchLoading && (
                <div className="text-center text-gray-400 py-6">
                    <div className="text-3xl mb-2 animate-bounce">üîç</div>
                    <span className="animate-pulse">–ü–æ–∏—Å–∫...</span>
                </div>
            )}
        </div>
    )
}

export default SearchPanel

```

---

## client/src/components/SearchResultItem.jsx

```javascript
/**
 * SearchResultItem - Memoized search result component
 * UX-01: Prevents unnecessary re-renders of individual items
 */
import { memo, forwardRef } from 'react'

const getTagStyle = (tag) => {
    const styles = {
        '2160p': 'bg-purple-900/50 text-purple-300 border-purple-500/30',
        '1080p': 'bg-blue-900/50 text-blue-300 border-blue-500/30',
        '720p': 'bg-gray-700/50 text-gray-300 border-gray-500/30',
        'hevc': 'bg-green-900/50 text-green-300 border-green-500/30',
        'hdr': 'bg-yellow-900/50 text-yellow-300 border-yellow-500/30',
        'dv': 'bg-pink-900/50 text-pink-300 border-pink-500/30',
        'cam': 'bg-red-900/50 text-red-300 border-red-500/30'
    }
    return styles[tag] || 'bg-gray-700/50 text-gray-400 border-gray-500/30'
}

const formatRelativeDate = (timestamp) => {
    if (!timestamp) return null
    const now = Date.now()
    const diff = now - timestamp
    const minutes = Math.floor(diff / 60000)
    const hours = Math.floor(diff / 3600000)
    const days = Math.floor(diff / 86400000)
    if (minutes < 1) return '—Ç–æ–ª—å–∫–æ —á—Ç–æ'
    if (minutes < 60) return `${minutes} –º–∏–Ω`
    if (hours < 24) return `${hours} —á`
    if (days < 7) return `${days} –¥–Ω`
    return new Date(timestamp).toLocaleDateString('ru-RU', { day: 'numeric', month: 'short' })
}

const SearchResultItem = memo(forwardRef(({
    result,
    index,
    isFocused,
    onSelect
}, ref) => {
    const { id, title, size, seeders, tracker, dateTs, tags } = result

    return (
        <div
            ref={ref}
            tabIndex={0}
            className={`flex items-start justify-between p-3 bg-gray-800 rounded-lg cursor-pointer
                       focus:bg-gray-700 focus:ring-2 focus:ring-purple-500 focus:outline-none
                       ${isFocused ? 'ring-2 ring-purple-500 bg-gray-700' : ''}`}
            onClick={() => onSelect(result)}
            role="button"
            aria-label={`${title}, ${size}, ${seeders} —Å–∏–¥–æ–≤`}
        >
            <div className="flex-1 min-w-0">
                <div className="text-sm font-medium text-white truncate">{title}</div>
                <div className="text-xs text-gray-400 flex flex-wrap gap-x-3 mt-1">
                    <span>üìÄ {size}</span>
                    <span className="text-green-400">‚¨Ü {seeders}</span>
                    {tracker && <span className="text-purple-400">{tracker}</span>}
                    {dateTs && <span className="text-gray-500">{formatRelativeDate(dateTs)}</span>}
                </div>
                {tags?.length > 0 && (
                    <div className="flex flex-wrap gap-1 mt-1.5">
                        {tags.map(tag => (
                            <span
                                key={tag}
                                className={`px-1.5 py-0.5 rounded text-[10px] border ${getTagStyle(tag)}`}
                            >
                                {tag.toUpperCase()}
                            </span>
                        ))}
                    </div>
                )}
            </div>
            <button
                onClick={(e) => { e.stopPropagation(); onSelect(result) }}
                className="ml-2 bg-green-600 px-2.5 py-1 rounded text-xs font-bold opacity-70 hover:opacity-100"
                tabIndex={-1}
                aria-label={`–î–æ–±–∞–≤–∏—Ç—å ${title}`}
            >+</button>
        </div>
    )
}))

SearchResultItem.displayName = 'SearchResultItem'

export default SearchResultItem

```

---

## client/src/components/SettingsPanel.jsx

```javascript
import { useState, useEffect, useRef } from 'react'
import { App } from '@capacitor/app'
import { useSpatialItem } from '../hooks/useSpatialNavigation'
import { cleanTitle } from '../utils/helpers'

const TABS = [
    { id: 'general', name: '–û—Å–Ω–æ–≤–Ω—ã–µ', icon: '‚öôÔ∏è' },
    { id: 'search', name: '–ü–æ–∏—Å–∫ –∏ –∫—ç—à', icon: 'üßπ' },
    { id: 'status', name: '–°–µ—Ä–≤–µ—Ä', icon: 'üìä' },
    { id: 'posters', name: '–ü–æ—Å—Ç–µ—Ä—ã', icon: 'üñºÔ∏è' }
]

const SpeedButton = ({ mode, active, disabled, onClick }) => {
    const spatialRef = useSpatialItem('settings')
    return (
        <button
            ref={spatialRef}
            disabled={disabled}
            onClick={onClick}
            className={`focusable flex-1 p-2 rounded-lg border text-center transition-all disabled:opacity-50 ${active ? 'bg-green-600 border-green-500 text-white shadow-lg' : 'bg-gray-800 border-gray-700 text-gray-400'
                }`}
        >
            <div className="font-bold text-xs">{mode.name}</div>
            <div className="text-[10px] opacity-70">{mode.desc}</div>
        </button>
    )
}

const PosterTestItem = ({ torrent, onClick }) => {
    const spatialRef = useSpatialItem('settings')
    const title = cleanTitle(torrent.name) || torrent.name
    return (
        <button
            ref={spatialRef}
            tabIndex="0"
            onClick={() => onClick(title)}
            className="focusable w-full text-left p-2.5 bg-gray-800 hover:bg-gray-750 rounded text-xs truncate border border-gray-700 mb-1 focus:bg-blue-600 focus:text-white transition-colors"
        >
            üé¨ {title}
        </button>
    )
}

const SettingsPanel = ({
    serverUrl,
    onServerUrlChange,
    tmdbProxyUrl,
    onTmdbProxyUrlChange,
    torrents = [],
    onClose,
    initialTab = 'general'
}) => {
    const [activeTab, setActiveTab] = useState(initialTab)

    // General State
    const [speedMode, setSpeedModeState] = useState(localStorage.getItem('speedMode') || 'balanced')
    const [speedLoading, setSpeedLoading] = useState(false)

    // Status State
    const [statusData, setStatusData] = useState(null)
    const [statusLoading, setStatusLoading] = useState(false)

    // Poster Test State
    const [testResult, setTestResult] = useState(null)
    const [testLoading, setTestLoading] = useState(false)

    useEffect(() => {
        setActiveTab(initialTab)
    }, [initialTab])

    // Fetch Status when entering Status tab
    useEffect(() => {
        if (activeTab === 'status') fetchStatus()
    }, [activeTab])

    // Spatial Refs
    const closeBtnRef = useSpatialItem('settings')
    const serverInputRef = useSpatialItem('settings')
    const proxyInputRef = useSpatialItem('settings')
    const clearCacheRef = useSpatialItem('settings')

    // Tabs
    const generalTabRef = useSpatialItem('settings')
    const searchTabRef = useSpatialItem('settings')
    const statusTabRef = useSpatialItem('settings')
    const postersTabRef = useSpatialItem('settings')
    const refreshStatusRef = useSpatialItem('settings')

    // --- Actions ---

    const handleClearCache = () => {
        const keys = Object.keys(localStorage).filter(k => k.startsWith('tmdb_cache_') || k.startsWith('metadata_'))
        keys.forEach(k => localStorage.removeItem(k))
        alert(`–û—á–∏—â–µ–Ω–æ ${keys.length} –∑–∞–ø–∏—Å–µ–π –∫—ç—à–∞. –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.`)
        window.location.reload()
    }

    const fetchStatus = async () => {
        setStatusLoading(true)
        try {
            const [sRes, lRes] = await Promise.all([
                fetch(`${serverUrl}/api/status`).catch(e => ({ ok: false })),
                fetch(`${serverUrl}/api/lag-stats`).catch(e => ({ ok: false }))
            ])
            const sData = sRes.ok ? await sRes.json() : {}
            const lData = lRes.ok ? await lRes.json() : {}
            setStatusData({
                server: sData.serverStatus || 'N/A',
                ram: lData.server?.ram?.rss || 'N/A',
                uptime: lData.server?.uptime || 0,
                lags: lData.totalLags || 0,
                active: lData.server?.torrents?.active || 0,
                frozen: lData.server?.torrents?.frozen || 0
            })
        } catch (e) { console.error(e) }
        finally { setStatusLoading(false) }
    }

    const runPosterTest = async (testName) => {
        setTestLoading(true)
        setTestResult(null)

        const query = encodeURIComponent(testName)
        const TMDB_API_KEY = import.meta.env.VITE_TMDB_API_KEY || "c3bec60e67fabf42dd2202281dcbc9a7"
        const CUSTOM_PROXY = tmdbProxyUrl || import.meta.env.VITE_TMDB_PROXY_URL || ''
        const KP_PROXY = 'https://cors.kp556.workers.dev:8443'
        const IMAGE_MIRRORS = ['imagetmdb.com', 'nl.imagetmdb.com', 'lampa.byskaz.ru/tmdb/img']

        let results = []
        const check = async (name, url, parser) => {
            try {
                const controller = new AbortController()
                const timeoutId = setTimeout(() => controller.abort(), 10000)
                const res = await fetch(url, { signal: controller.signal })
                clearTimeout(timeoutId)

                if (res.ok) {
                    const d = await res.json()
                    const found = parser ? parser(d) : true
                    results.push({ name, status: found ? '‚úÖ' : '‚ö†Ô∏è', detail: typeof found === 'string' ? found : 'Online' })
                } else {
                    results.push({ name, status: '‚ùå', detail: `HTTP ${res.status}` })
                }
            } catch (e) {
                results.push({ name, status: '‚ùå', detail: e.name === 'AbortError' ? 'Timeout' : e.message })
            }
        }

        try {
            await check('TMDB API (Direct)', `https://api.themoviedb.org/3/search/movie?api_key=${TMDB_API_KEY}&query=${query}`, d => d.total_results > 0)
            if (CUSTOM_PROXY) await check('Custom Proxy', `${CUSTOM_PROXY}/3/search/movie?api_key=${TMDB_API_KEY}&query=${query}`, d => d.total_results > 0)
            for (const mirror of IMAGE_MIRRORS) await check(`Img: ${mirror}`, `https://${mirror}/t/p/w92/8uO0gUM8aNqYLs1OsTBQiXu0fEv.jpg`, () => true)
            await check('Kinopoisk Proxy', `${KP_PROXY}/api/v2.1/films/search-by-keyword?keyword=${query}`, d => d.films?.length > 0)
        } catch (err) {
            results.push({ name: 'Critical', status: '‚ùå', detail: err.message })
        } finally {
            setTestResult({ name: testName, results })
            setTestLoading(false)
        }
    }

    const formatUptime = (s) => {
        const h = Math.floor(s / 3600), m = Math.floor((s % 3600) / 60)
        return `${h}h ${m}m`
    }

    const cacheCount = Object.keys(localStorage).filter(k => k.startsWith('tmdb_cache_') || k.startsWith('metadata_')).length

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 animate-in fade-in duration-200">
            <div className="bg-[#1a1a1a] border border-gray-700 rounded-2xl w-full max-w-lg shadow-2xl overflow-hidden flex flex-col max-h-[85vh]">
                {/* Header */}
                <div className="bg-gradient-to-r from-gray-800 to-gray-900 p-4 flex items-center justify-between border-b border-white/10">
                    <div className="flex gap-2 overflow-x-auto">
                        <button ref={generalTabRef} onClick={() => setActiveTab('general')} className={`focusable text-sm font-bold px-3 py-1.5 rounded-full transition-all ${activeTab === 'general' ? 'bg-white/10 text-white' : 'text-white/50 hover:bg-white/5'}`}>‚öôÔ∏è –û—Å–Ω–æ–≤–Ω—ã–µ</button>
                        <button ref={searchTabRef} onClick={() => setActiveTab('search')} className={`focusable text-sm font-bold px-3 py-1.5 rounded-full transition-all ${activeTab === 'search' ? 'bg-white/10 text-white' : 'text-white/50 hover:bg-white/5'}`}>üßπ –ü–æ–∏—Å–∫</button>
                        <button ref={statusTabRef} onClick={() => setActiveTab('status')} className={`focusable text-sm font-bold px-3 py-1.5 rounded-full transition-all ${activeTab === 'status' ? 'bg-white/10 text-white' : 'text-white/50 hover:bg-white/5'}`}>üìä –°—Ç–∞—Ç—É—Å</button>
                        <button ref={postersTabRef} onClick={() => setActiveTab('posters')} className={`focusable text-sm font-bold px-3 py-1.5 rounded-full transition-all ${activeTab === 'posters' ? 'bg-white/10 text-white' : 'text-white/50 hover:bg-white/5'}`}>üñºÔ∏è –ü–æ—Å—Ç–µ—Ä—ã</button>
                    </div>
                    <button ref={closeBtnRef} onClick={onClose} className="focusable text-gray-400 hover:text-white px-2 text-xl ml-2">‚úï</button>
                </div>

                {/* Content Area */}
                <div className="flex-1 overflow-y-auto p-6 custom-scrollbar pb-10">
                    {/* --- GENERAL TAB --- */}
                    {activeTab === 'general' && (
                        <div className="space-y-6 animate-fade-in">
                            <section>
                                <label className="text-xs font-bold text-gray-500 uppercase tracking-widest mb-3 block">‚ö° –°–∫–æ—Ä–æ—Å—Ç—å –∑–∞–≥—Ä—É–∑–∫–∏</label>
                                <div className="flex gap-2">
                                    {[{ id: 'eco', name: 'üå± Eco', desc: '20 peers' }, { id: 'balanced', name: '‚öñÔ∏è Balance', desc: '40 peers' }, { id: 'turbo', name: 'üöÄ Turbo', desc: '65 peers' }].map(m => (
                                        <SpeedButton
                                            key={m.id}
                                            mode={m}
                                            active={speedMode === m.id}
                                            disabled={speedLoading}
                                            onClick={async () => {
                                                setSpeedLoading(true)
                                                try {
                                                    const res = await fetch(`${serverUrl || ''}/api/speed-mode`, {
                                                        method: 'POST',
                                                        headers: { 'Content-Type': 'application/json' },
                                                        body: JSON.stringify({ mode: m.id })
                                                    })
                                                    if (res.ok) {
                                                        setSpeedModeState(m.id)
                                                        localStorage.setItem('speedMode', m.id)
                                                    }
                                                } catch (e) { console.error(e) } finally { setSpeedLoading(false) }
                                            }}
                                        />
                                    ))}
                                </div>
                            </section>
                        </div>
                    )}

                    {/* --- SEARCH & CACHE TAB --- */}
                    {activeTab === 'search' && (
                        <div className="space-y-6 animate-fade-in">
                            <section>
                                <label className="text-xs font-bold text-gray-500 uppercase tracking-widest mb-2 block">üõ°Ô∏è TMDB Proxy</label>
                                <input
                                    ref={proxyInputRef}
                                    tabIndex="0"
                                    value={tmdbProxyUrl}
                                    onChange={e => onTmdbProxyUrlChange(e.target.value, false)}
                                    onBlur={e => onTmdbProxyUrlChange(e.target.value, true)}
                                    className="focusable w-full bg-gray-800 text-sm text-white px-4 py-3 rounded-lg border border-gray-700 focus:border-purple-500 outline-none transition-colors"
                                    placeholder="–ü—É—Å—Ç–æ –¥–ª—è –∞–≤—Ç–æ-–≤—ã–±–æ—Ä–∞"
                                />
                                <p className="text-[10px] text-gray-500 mt-2 italic">–î–ª—è –æ–±—Ö–æ–¥–∞ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫ –∑–∞–≥—Ä—É–∑–∫–∏ –æ–±–ª–æ–∂–µ–∫.</p>
                            </section>

                            <section className="pt-4 border-t border-white/5">
                                <button
                                    ref={clearCacheRef}
                                    onClick={handleClearCache}
                                    className="focusable w-full bg-red-900/10 text-red-400 p-4 rounded-xl border border-red-900/30 text-sm flex items-center justify-center gap-3 hover:bg-red-900/20 transition-all font-bold"
                                >
                                    <span>üóëÔ∏è</span> –û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à ({cacheCount})
                                </button>
                            </section>
                        </div>
                    )}

                    {/* --- STATUS TAB --- */}
                    {activeTab === 'status' && (
                        <div className="space-y-6 animate-fade-in">
                            <section>
                                <label className="text-xs font-bold text-gray-500 uppercase tracking-widest mb-2 block">üñ•Ô∏è –ê–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞</label>
                                <input
                                    ref={serverInputRef}
                                    tabIndex="0"
                                    value={serverUrl}
                                    onChange={e => onServerUrlChange(e.target.value, false)}
                                    onBlur={e => onServerUrlChange(e.target.value, true)}
                                    className="focusable w-full bg-gray-800 text-sm text-white px-4 py-3 rounded-lg border border-gray-700 focus:border-blue-500 outline-none transition-colors"
                                    placeholder="http://192.168.x.x:3000"
                                />
                            </section>

                            <div className="pt-4 border-t border-white/10 pb-4">
                                {statusLoading ? <div className="text-center animate-pulse text-gray-500 py-4">–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...</div> : (
                                    <div className="grid grid-cols-2 gap-3">
                                        <div className="bg-white/5 p-3 rounded-xl border border-white/5"><div className="text-[10px] text-gray-500 font-bold uppercase">Status</div><div className={`text-xl font-mono ${statusData?.server === 'ok' ? 'text-green-400' : 'text-yellow-400'}`}>{statusData?.server?.toUpperCase()}</div></div>
                                        <div className="bg-white/5 p-3 rounded-xl border border-white/5"><div className="text-[10px] text-gray-500 font-bold uppercase">RAM</div><div className="text-xl font-mono">{statusData?.ram} MB</div></div>
                                        <div className="bg-white/5 p-3 rounded-xl border border-white/5"><div className="text-[10px] text-gray-500 font-bold uppercase">Uptime</div><div className="text-xl font-mono">{formatUptime(statusData?.uptime)}</div></div>
                                        <div className="bg-white/5 p-3 rounded-xl border border-white/5"><div className="text-[10px] text-gray-500 font-bold uppercase">Lags</div><div className={`text-xl font-mono ${statusData?.lags > 0 ? 'text-red-400' : 'text-green-400'}`}>{statusData?.lags}</div></div>
                                        <div className="bg-white/5 p-3 rounded-xl border border-white/5"><div className="text-[10px] text-gray-500 font-bold uppercase">Active</div><div className="text-xl font-mono text-blue-400">{statusData?.active}</div></div>
                                        <div className="bg-white/5 p-3 rounded-xl border border-white/5"><div className="text-[10px] text-gray-500 font-bold uppercase">Frozen</div><div className="text-xl font-mono text-purple-400">{statusData?.frozen}</div></div>
                                    </div>
                                )}
                                <button
                                    ref={refreshStatusRef}
                                    onClick={fetchStatus}
                                    className="focusable w-full mt-4 py-3 bg-blue-600/20 text-blue-400 rounded-xl font-bold text-sm border border-blue-500/30 hover:bg-blue-600/30 transition-colors"
                                >
                                    –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å
                                </button>
                            </div>
                        </div>
                    )}

                    {/* --- POSTERS TAB --- */}
                    {activeTab === 'posters' && (
                        <div className="space-y-4 animate-fade-in pb-10">
                            <div className="max-h-40 overflow-y-auto border border-white/10 rounded-xl bg-black/20 p-2 custom-scrollbar">
                                {torrents.map(t => <PosterTestItem key={t.infoHash} torrent={t} onClick={runPosterTest} />)}
                                {torrents.length === 0 && <div className="text-center text-xs text-gray-500 py-10">–ù–µ—Ç —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤ –¥–ª—è —Ç–µ—Å—Ç–∞</div>}
                            </div>

                            {testLoading && <div className="text-center text-xs text-blue-400 animate-pulse">–¢–µ—Å—Ç–∏—Ä—É–µ–º –∑–∞–≥—Ä—É–∑–∫—É –ø–æ—Å—Ç–µ—Ä–æ–≤...</div>}

                            {testResult && (
                                <div className="bg-black/40 rounded-xl border border-white/10 p-3 text-[11px] space-y-1">
                                    <div className="font-bold text-gray-300 border-b border-white/10 pb-1 mb-1">{testResult.name}</div>
                                    {testResult.results.map((r, i) => (
                                        <div key={i} className="flex justify-between items-center">
                                            <span className={`${r.status === '‚úÖ' ? 'text-green-400' : 'text-red-400'}`}>{r.status} {r.name}</span>
                                            <span className="text-gray-500 truncate max-w-[120px]">{r.detail}</span>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    )}
                </div>
            </div>
        </div>
    )
}

export default SettingsPanel

```

---

## client/src/components/Sidebar.jsx

```javascript
import React, { useState, useRef } from 'react'
import { useSpatialItem } from '../hooks/useSpatialNavigation'

const Sidebar = ({ onSelect, isOpen = false, onClose }) => {
    // Generate years from 2026 down to 1980
    const years = Array.from({ length: 2026 - 1980 + 1 }, (_, i) => 2026 - i)

    const menuItems = [
        { id: 'close', icon: '‚ùå', label: '–ó–∞–∫—Ä—ã—Ç—å' },
        { id: 'search', icon: 'üîç', label: '–ü–æ–∏—Å–∫' },
        { id: 'filter_year_2025', icon: 'üé¨', label: '–ù–æ–≤—ã–µ —Ñ–∏–ª—å–º—ã 2025', type: 'year', year: 2025 },
        { id: 'tv_new', icon: 'üì∫', label: '–ù–æ–≤—ã–µ —Å–µ—Ä–∏–∞–ª—ã', categoryId: 'tv' },
        { id: 'cartoons', icon: 'üé®', label: '–ú—É–ª—å—Ç—Ñ–∏–ª—å–º—ã', categoryId: 'genre_16' },
        { id: 'anime', icon: 'üç•', label: '–ê–Ω–∏–º–µ', categoryId: 'genre_16' },
        { id: 'top_rated', icon: '‚≠ê', label: '–õ—É—á—à–∏–µ —Ñ–∏–ª—å–º—ã', categoryId: 'top' },
        { id: 'favorites', icon: '‚ù§Ô∏è', label: '–ò–∑–±—Ä–∞–Ω–Ω–æ–µ' },
        { id: 'history', icon: 'üïí', label: '–ò—Å—Ç–æ—Ä–∏—è' },
        { id: 'ai_picks', icon: 'ü§ñ', label: '–ü–æ–¥–±–æ—Ä–∫–∏ AI' },
    ]

    const sidebarRef = useRef(null)
    const [expanded, setExpanded] = useState(false)

    // Handle Focus Expansion
    const handleFocus = () => setExpanded(true)
    const handleBlur = (e) => {
        if (!sidebarRef.current?.contains(e.relatedTarget)) {
            setExpanded(false)
        }
    }

    return (
        <div
            ref={sidebarRef}
            className={`
                fixed left-0 top-0 bottom-0 z-40 bg-black/95 border-r border-white/10
                transition-all duration-300 ease-out flex flex-col py-6
                ${isOpen ? 'w-64 translate-x-0 shadow-2xl' : 'w-0 -translate-x-full overflow-hidden'}
            `}
            onFocus={handleFocus}
            onBlur={handleBlur}
            onMouseEnter={() => setExpanded(true)}
            onMouseLeave={() => setExpanded(false)}
        >
            {/* Logo */}
            <div className="mb-6 px-0 flex justify-center sticky top-0 bg-black z-10 w-full">
                <span className="text-2xl">üåÄ</span>
            </div>

            <div className="flex-1 overflow-y-auto overflow-x-hidden scrollbar-hide px-2">
                {/* Main Menu */}
                {menuItems.map((item) => (
                    <SidebarItem
                        key={item.id}
                        item={item}
                        expanded={expanded}
                        onClick={() => {
                            if (item.id === 'close') onClose?.()
                            else onSelect(item)
                        }}
                    />
                ))}

                {/* Separator */}
                <div className="h-px bg-white/10 my-4 mx-2" />

                {/* Years Grid */}
                {years.map((year) => (
                    <SidebarItem
                        key={year}
                        item={{ id: year, icon: 'üìÖ', label: year }}
                        expanded={expanded}
                        onClick={() => onSelect({ id: `year_${year}`, type: 'year', year, label: `${year} –≥–æ–¥` })}
                    />
                ))}
            </div>
        </div>
    )
}

const SidebarItem = ({ item, expanded, onClick }) => {
    const spatialRef = useSpatialItem('sidebar')

    return (
        <button
            ref={spatialRef}
            className="focusable flex items-center rounded-lg mb-2 p-3 w-full text-left transition-all duration-200 text-gray-400 hover:text-white focus:bg-white focus:text-black focus:scale-105"
            onClick={onClick}
        >
            <span className="text-xl min-w-[24px] text-center">{item.icon}</span>
            <span className={`
                ml-4 font-medium whitespace-nowrap overflow-hidden transition-opacity duration-200
                ${expanded ? 'opacity-100' : 'opacity-0 w-0'}
            `}>
                {item.label}
            </span>
        </button>
    )
}

export default Sidebar

```

---

## client/src/components/StatusBanners.jsx

```javascript
/**
 * Status Banner Components - Error states and loading indicators
 */
import React, { useState, useEffect } from 'react'
import { useSpatialItem } from '../hooks/useSpatialNavigation'

/**
 * DegradedBanner - Shows when server is in degraded mode (high memory)
 */
export const DegradedBanner = ({ lastStateChange }) => {
    const [elapsed, setElapsed] = useState(0)

    useEffect(() => {
        if (!lastStateChange) return
        const interval = setInterval(() => {
            setElapsed(Math.floor((Date.now() - lastStateChange) / 1000))
        }, 1000)
        return () => clearInterval(interval)
    }, [lastStateChange])

    const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60)
        const secs = seconds % 60
        return mins > 0 ? `${mins}m ${secs}s` : `${secs}s`
    }

    return (
        <div className="bg-yellow-600/90 text-yellow-100 p-4 rounded-lg mb-6 border border-yellow-500 animate-pulse mx-4">
            <div className="flex items-center gap-3">
                <span className="text-2xl">‚ùÑÔ∏è</span>
                <div>
                    <div className="font-bold text-lg">Cooling Down</div>
                    <div className="text-sm opacity-90">
                        High memory usage detected. Service may be slower.
                        <span className="ml-2 font-mono">{formatTime(elapsed)}</span>
                    </div>
                </div>
            </div>
        </div>
    )
}

/**
 * ErrorScreen - Full-screen error for circuit breaker / critical errors
 */
export const ErrorScreen = ({ status, retryAfter, onRetry }) => {
    const [countdown, setCountdown] = useState(retryAfter || 300)

    useEffect(() => {
        if (countdown <= 0) {
            onRetry()
            return
        }
        const timer = setTimeout(() => setCountdown(c => c - 1), 1000)
        return () => clearTimeout(timer)
    }, [countdown, onRetry])

    const isCircuitOpen = status === 'circuit_open'
    const icon = isCircuitOpen ? 'üîå' : '‚ö†Ô∏è'
    const title = isCircuitOpen ? 'Storage Unavailable' : 'Server Error'
    const message = isCircuitOpen
        ? 'NFS/Storage is not responding. The server will retry automatically.'
        : 'A critical error occurred. Please wait for recovery.'

    return (
        <div className="min-h-screen bg-gray-900 flex items-center justify-center p-6">
            <div className="bg-red-900/30 border border-red-700 rounded-2xl p-8 max-w-md text-center">
                <div className="text-6xl mb-4">{icon}</div>
                <h1 className="text-2xl font-bold text-red-400 mb-2">{title}</h1>
                <p className="text-gray-300 mb-6">{message}</p>
                <button
                    onClick={onRetry}
                    className="mt-6 bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg font-bold transition-colors"
                >
                    Retry Now
                </button>
            </div>
        </div>
    )
}

/**
 * BufferingBanner - Shows loading progress when starting playback
 */
export const BufferingBanner = ({ name, progress }) => {
    if (!name) return null

    return (
        <div className="fixed top-16 left-0 right-0 z-50 mx-4">
            <div className="bg-blue-900/95 backdrop-blur-md border border-blue-500 rounded-xl p-4 shadow-2xl animate-pulse">
                <div className="flex items-center gap-3">
                    <div className="animate-spin">
                        <svg className="w-6 h-6 text-blue-400" fill="none" viewBox="0 0 24 24">
                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                        </svg>
                    </div>
                    <div className="flex-1">
                        <div className="font-bold text-white">Buffering...</div>
                        <div className="text-sm text-blue-200 truncate">{name}</div>
                    </div>
                    {progress > 0 && (
                        <div className="text-blue-300 font-mono">{progress}%</div>
                    )}
                </div>
            </div>
        </div>
    )
}

/**
 * ServerStatusBar - Small indicator showing server health
 */
/**
 * ServerStatusBar - Small indicator showing server health
 */
export const ServerStatusBar = React.forwardRef(({ status, onDiagnosticsClick }, ref) => {
    const getStatusInfo = () => {
        switch (status) {
            case 'ok':
                return { icon: 'üü¢', text: 'Server OK', color: 'bg-green-900/50 border-green-700 text-green-300' }
            case 'degraded':
                return { icon: 'üü°', text: 'High RAM', color: 'bg-yellow-900/50 border-yellow-700 text-yellow-300' }
            case 'circuit_open':
                return { icon: 'üî¥', text: 'Storage Error', color: 'bg-red-900/50 border-red-700 text-red-300' }
            case 'error':
                return { icon: 'üî¥', text: 'Server Error', color: 'bg-red-900/50 border-red-700 text-red-300' }
            default:
                return { icon: '‚ö™', text: 'Connecting...', color: 'bg-gray-800/50 border-gray-600 text-gray-400' }
        }
    }

    const info = getStatusInfo()

    return (
        <button
            ref={ref}
            tabIndex="0"
            onClick={onDiagnosticsClick}
            className={`focusable px-3 py-1.5 rounded-lg border text-xs font-medium flex items-center gap-2 transition-colors hover:opacity-80 focus:bg-blue-600 focus:text-white ${info.color}`}
            onKeyDown={(e) => {
                if (e.key === 'Enter') {
                    onDiagnosticsClick()
                }
            }}
        >
            <span>{info.icon}</span>
            <span>{info.text}</span>
        </button>
    )
})

```

---

## client/src/components/TorrentModal.jsx

```javascript
import { useState, useEffect } from 'react'
import { App } from '@capacitor/app'
import { cleanTitle, formatSize, organizeFiles } from '../utils/helpers'
import { getMetadata } from '../utils/tmdbClient'
import { useSpatialItem } from '../hooks/useSpatialNavigation'

const RatingBadge = ({ rating }) => {
    if (!rating || rating === 0) return null
    const color = rating >= 7 ? 'bg-green-600' : rating >= 5 ? 'bg-yellow-600' : 'bg-red-600'
    return (
        <span className={`${color} text-white text-sm font-bold px-2 py-0.5 rounded`}>
            ‚≠ê {typeof rating === 'number' ? rating.toFixed(1) : rating}
        </span>
    )
}

const EpisodeItem = ({ file, idx, onClick }) => {
    const spatialRef = useSpatialItem('modal')
    return (
        <button
            ref={spatialRef}
            onClick={onClick}
            className="focusable w-full px-3 py-2 text-left border-t border-gray-800 focus:bg-blue-600 focus:text-white flex items-center gap-2 text-sm"
        >
            {idx !== undefined && <span className="text-blue-400 font-mono text-xs w-5">{idx + 1}</span>}
            <span className="flex-1 text-gray-300 truncate">{cleanTitle(file.name) || file.name}</span>
            <span className="text-xs text-gray-500">{formatSize(file.length)}</span>
        </button>
    )
}

const TorrentModal = ({
    torrent,
    onClose,
    onPlay,
    onPlayAll,
    onCopyUrl,
    onDelete
}) => {
    const [showFullOverview, setShowFullOverview] = useState(false)
    const [metadata, setMetadata] = useState(null)
    const [episodesExpanded, setEpisodesExpanded] = useState(false)
    const [allowInteraction, setAllowInteraction] = useState(false)

    // Spatial Refs
    const closeBtnRef = useSpatialItem('modal')
    const overviewToggleRef = useSpatialItem('modal')
    const playBtnRef = useSpatialItem('modal')
    const playAllBtnRef = useSpatialItem('modal')
    const expandBtnRef = useSpatialItem('modal')
    const copyBtnRef = useSpatialItem('modal')
    const deleteBtnRef = useSpatialItem('modal')

    useEffect(() => {
        // Prevent phantom clicks from previous screen
        const timer = setTimeout(() => setAllowInteraction(true), 500)

        // NAV-04: Focus Trap & Restore
        const previousActive = document.activeElement
        if (playBtnRef.current) playBtnRef.current.focus()
        else if (closeBtnRef.current) closeBtnRef.current.focus()

        // NAV-04: Capacitor Back Button Listener (Android TV)
        let backListener
        const setupListener = async () => {
            backListener = await App.addListener('backButton', () => {
                onClose()
            })
        }
        setupListener()

        return () => {
            clearTimeout(timer)
            if (backListener) backListener.remove()
            // Restore focus
            if (previousActive && typeof previousActive.focus === 'function') {
                previousActive.focus()
            }
        }
    }, [])

    useEffect(() => {
        if (torrent?.name) {
            const cached = getMetadata(cleanTitle(torrent.name))
            if (cached) setMetadata(cached)
        }
    }, [torrent?.name])

    if (!torrent) return null

    const videoFiles = torrent.files?.filter(f => /\.(mp4|mkv|avi|mov|webm)$/i.test(f.name)) || []
    const { episodes: sortedEpisodes, extras: sortedExtras } = organizeFiles(videoFiles)
    const mainList = sortedEpisodes.length > 0 ? sortedEpisodes : sortedEpisodes.concat(sortedExtras)
    const extraList = sortedEpisodes.length > 0 ? sortedExtras : []

    const firstVideo = mainList[0] || torrent.files?.[0]
    const cleanedName = cleanTitle(torrent.name)

    const backdropStyle = metadata?.backdrop
        ? { backgroundImage: `url(${metadata.backdrop})`, backgroundSize: 'cover', backgroundPosition: 'center' }
        : { background: 'linear-gradient(135deg, #1e3a8a 0%, #1f2937 100%)' }

    const INITIAL_EPISODES = 8
    const visibleEpisodes = episodesExpanded ? mainList : mainList.slice(0, INITIAL_EPISODES)
    const hasMoreEpisodes = mainList.length > INITIAL_EPISODES && !episodesExpanded

    return (
        <div
            className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur-sm"
            onClick={onClose}
        >
            <div
                className="bg-[#181818] rounded-2xl w-full max-w-lg max-h-[85vh] shadow-2xl flex flex-col overflow-hidden"
                onClick={e => e.stopPropagation()}
            >
                {/* Fixed Header */}
                <div
                    className="h-32 shrink-0 relative flex items-end overflow-hidden"
                    style={backdropStyle}
                >
                    <div className="absolute inset-0 bg-gradient-to-t from-black via-black/50 to-transparent" />
                    <button
                        ref={closeBtnRef}
                        onClick={onClose}
                        className="focusable absolute top-3 right-3 bg-black/50 rounded-full w-8 h-8 text-white focus:bg-white focus:text-black"
                    >‚úï</button>
                    <div className="relative z-10 p-4 w-full">
                        <div className="flex gap-2 mb-1">
                            <RatingBadge rating={metadata?.rating} />
                            {metadata?.year && <span className="bg-gray-700 text-gray-300 text-xs px-2 py-0.5 rounded">{metadata.year}</span>}
                        </div>
                        <h2 className="text-lg font-bold text-white drop-shadow-lg line-clamp-2">{metadata?.title || cleanedName}</h2>
                    </div>
                </div>

                {/* Scrollable Content */}
                <div className="flex-1 overflow-y-auto p-4 min-h-0 custom-scrollbar">
                    {metadata?.overview && (
                        <div className="mb-3">
                            <p className={`text-xs text-gray-400 ${showFullOverview ? '' : 'line-clamp-2'}`}>{metadata.overview}</p>
                            {metadata.overview.length > 80 && (
                                <button
                                    ref={overviewToggleRef}
                                    onClick={() => setShowFullOverview(!showFullOverview)}
                                    className="focusable text-purple-400 text-xs p-1 rounded hover:bg-white/5"
                                >
                                    {showFullOverview ? '‚Üê –°–≤–µ—Ä–Ω—É—Ç—å' : '–ï—â—ë ‚Üí'}
                                </button>
                            )}
                        </div>
                    )}

                    {/* Play button */}
                    <button
                        ref={playBtnRef}
                        onClick={() => allowInteraction && firstVideo && onPlay(torrent.infoHash, firstVideo.index, firstVideo.name)}
                        className={`focusable w-full bg-white text-black py-3 rounded font-bold focus:bg-yellow-400 mb-2 ${!allowInteraction ? 'opacity-50' : ''}`}
                    >‚ñ∂ Play</button>

                    {/* Play All */}
                    {mainList.length > 1 && (
                        <button
                            ref={playAllBtnRef}
                            onClick={() => allowInteraction && onPlayAll(torrent)}
                            className="focusable w-full bg-blue-600 text-white py-2 rounded font-bold focus:bg-blue-500 mb-2"
                        >üì∫ Play All ({mainList.length})</button>
                    )}

                    {/* Episode List */}
                    {videoFiles.length > 1 && (
                        <div className="bg-gray-900 rounded-lg overflow-hidden mb-2">
                            <div className="px-3 py-2 bg-gray-800 text-gray-400 text-sm flex items-center justify-between">
                                <span>üìã –°–µ—Ä–∏–∏ ({mainList.length})</span>
                            </div>

                            <div className="max-h-[28vh] overflow-y-auto custom-scrollbar">
                                {visibleEpisodes.map((file, idx) => (
                                    <EpisodeItem
                                        key={file.index}
                                        idx={idx}
                                        file={file}
                                        onClick={() => onPlay(torrent.infoHash, file.index, file.name)}
                                    />
                                ))}

                                {hasMoreEpisodes && (
                                    <button
                                        ref={expandBtnRef}
                                        onClick={() => setEpisodesExpanded(true)}
                                        className="focusable w-full px-3 py-2 text-center text-purple-400 text-sm border-t border-gray-800 focus:bg-purple-900 focus:text-white"
                                    >‚ñº –ï—â—ë {mainList.length - INITIAL_EPISODES} —Å–µ—Ä–∏–π</button>
                                )}

                                {extraList.length > 0 && (
                                    <div className="border-t border-gray-800">
                                        <div className="px-3 py-2 text-gray-500 text-xs uppercase tracking-wider bg-black/20">
                                            üéÅ –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ
                                        </div>
                                        {extraList.map((file) => (
                                            <EpisodeItem
                                                key={file.index}
                                                file={file}
                                                onClick={() => onPlay(torrent.infoHash, file.index, file.name)}
                                            />
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                </div>

                {/* Footer Actions */}
                <div className="shrink-0 p-4 pt-2 flex gap-2 border-t border-gray-800 bg-black/20">
                    <button
                        ref={copyBtnRef}
                        onClick={() => firstVideo && onCopyUrl(torrent.infoHash, firstVideo.index)}
                        className="focusable flex-1 bg-gray-800 text-gray-300 py-2.5 rounded font-medium focus:bg-white focus:text-black text-sm"
                    >üìã Copy</button>
                    <button
                        ref={deleteBtnRef}
                        onClick={() => onDelete(torrent.infoHash)}
                        className="focusable flex-1 bg-red-900/50 text-red-500 py-2.5 rounded font-medium focus:bg-red-600 focus:text-white text-sm"
                    >üóë Delete</button>
                </div>
            </div>
        </div>
    )
}

export default TorrentModal

```

---

## client/src/hooks/useDebounce.js

```javascript
/**
 * useDebounce - Debounce hook for performance optimization
 * UX-01: Prevents excessive API calls during rapid input
 *
 * @param {any} value - Value to debounce
 * @param {number} delay - Delay in milliseconds (default: 300ms)
 * @returns {any} - Debounced value
 */
import { useState, useEffect } from 'react'

export function useDebounce(value, delay = 300) {
    const [debouncedValue, setDebouncedValue] = useState(value)

    useEffect(() => {
        const timer = setTimeout(() => {
            setDebouncedValue(value)
        }, delay)

        return () => {
            clearTimeout(timer)
        }
    }, [value, delay])

    return debouncedValue
}

/**
 * useDebouncedCallback - Debounced callback hook
 * Returns a memoized callback that is debounced
 *
 * @param {Function} callback - Function to debounce
 * @param {number} delay - Delay in milliseconds
 * @returns {Function} - Debounced function
 */
export function useDebouncedCallback(callback, delay = 300) {
    const [timer, setTimer] = useState(null)

    const debouncedCallback = (...args) => {
        if (timer) clearTimeout(timer)

        const newTimer = setTimeout(() => {
            callback(...args)
        }, delay)

        setTimer(newTimer)
    }

    // Cleanup on unmount
    useEffect(() => {
        return () => {
            if (timer) clearTimeout(timer)
        }
    }, [timer])

    return debouncedCallback
}

export default useDebounce

```

---

## client/src/hooks/useSpatialNavigation.js

```javascript
/**
 * useSpatialNavigation.js - Core Spatial Engine for TV Navigation (v4.0)
 * 
 * Based on LAMPA SpatialNavigator principles:
 * 1. Zero Indices: We don't care about row/col indexes.
 * 2. DOM-Primary: The focus state in DOM is the source of truth.
 * 3. Pure Geometry: Closest neighbor is found via bounding boxes.
 */

import { useCallback, useRef, useEffect } from 'react';

const SpatialEngine = {
    zones: {},
    activeZone: 'main',
    idMap: {}, // zone -> id -> element

    register(zone, element, id = null) {
        if (!this.zones[zone]) this.zones[zone] = new Set();
        this.zones[zone].add(element);

        if (id) {
            if (!this.idMap[zone]) this.idMap[zone] = {};
            this.idMap[zone][id] = element;
        }
    },

    unregister(zone, element) {
        if (this.zones[zone]) {
            this.zones[zone].delete(element);
        }
        // Cleanup ID map (expensive reverse lookup or just ignore leaking?)
        // Better: Check if this element is in idMap for this zone
        if (this.idMap[zone]) {
            for (const [id, el] of Object.entries(this.idMap[zone])) {
                if (el === element) {
                    delete this.idMap[zone][id];
                    break;
                }
            }
        }
    },

    focusId(zone, id) {
        if (this.idMap[zone] && this.idMap[zone][id]) {
            const element = this.idMap[zone][id];
            if (element.offsetParent !== null && !element.disabled) { // Check visibility and enabled state
                console.log(`[SpatialNav] Focusing element with ID '${id}' in zone '${zone}'`);
                this.activeZone = zone; // Set active zone if focusing by ID
                element.focus();
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                return true;
            } else {
                console.warn(`[SpatialNav] Element with ID '${id}' in zone '${zone}' is not visible or disabled.`);
            }
        } else {
            console.warn(`[SpatialNav] Element with ID '${id}' not found in zone '${zone}'.`);
        }
        return false;
    },

    setActiveZone(zone) {
        console.log(`[SpatialNav] Active Zone: ${this.activeZone} -> ${zone}`);

        // Aggressively cleanup stale references in BOTH old and new zones
        [this.activeZone, zone].forEach(z => {
            if (this.zones[z]) {
                const before = this.zones[z].size;
                this.zones[z] = new Set(
                    Array.from(this.zones[z]).filter(el => document.body.contains(el))
                );
                const after = this.zones[z].size;
                if (before !== after) {
                    console.log(`[SpatialNav] Cleaned ${before - after} stale refs from zone '${z}'`);
                }
            }
        });

        this.activeZone = zone;
    },

    move(direction) {
        const current = document.activeElement;
        const elements = Array.from(this.zones[this.activeZone] || [])
            .filter(el => document.body.contains(el) && el.offsetParent !== null); // Filter valid + visible

        if (!elements.length) return;

        // If nothing focused, focus first or best
        if (!elements.includes(current)) {
            elements[0].focus();
            return;
        }

        const next = this.findNearest(current, elements, direction);
        if (next) {
            next.focus();
            next.scrollIntoView({ behavior: 'smooth', block: 'center' });
        } else {
            console.warn(`[SpatialNav] Edge reached for ${direction} in zone ${this.activeZone}`);
        }
    },

    findNearest(current, elements, direction) {
        const curRect = current.getBoundingClientRect();
        let bestCandidate = null;
        let minDistance = Infinity;

        elements.forEach(candidate => {
            if (candidate === current) return;
            const candRect = candidate.getBoundingClientRect();

            // 1. Directional Filtering
            let isCorrectDirection = false;
            switch (direction) {
                case 'ArrowUp': isCorrectDirection = candRect.bottom <= curRect.top + 5; break;
                case 'ArrowDown': isCorrectDirection = candRect.top >= curRect.bottom - 5; break;
                case 'ArrowLeft': isCorrectDirection = candRect.right <= curRect.left + 5; break;
                case 'ArrowRight': isCorrectDirection = candRect.left >= curRect.right - 5; break;
            }

            if (!isCorrectDirection) return;

            // 2. Distance Calculation (Euclidean of centers + penalty for axis misalignment)
            const dx = Math.abs((curRect.left + curRect.width / 2) - (candRect.left + candRect.width / 2));
            const dy = Math.abs((curRect.top + curRect.height / 2) - (candRect.top + candRect.height / 2));

            // Weight the axis of movement less than the orthogonal axis to prefer straight jumps
            const distance = (direction === 'ArrowLeft' || direction === 'ArrowRight')
                ? dx + dy * 2
                : dy + dx * 2;

            if (distance < minDistance) {
                minDistance = distance;
                bestCandidate = candidate;
            }
        });

        return bestCandidate;
    },

    recoverFocus(zone, retryCount = 5) {
        const targetZone = zone || this.activeZone;
        const attempt = () => {
            const elements = Array.from(this.zones[targetZone] || [])
                .filter(el => document.body.contains(el) && el.offsetParent !== null && !el.disabled);

            if (elements.length > 0) {
                console.log(`[SpatialNav] Recovering focus in ${targetZone}`);
                this.activeZone = targetZone;
                // Prefer elements that are NOT the search buttons if possible, or just first one
                elements[0].focus();
                elements[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
                return true;
            }
            if (retryCount > 0) {
                retryCount--;
                setTimeout(attempt, 100);
            }
            return false;
        };
        attempt();
    }
};

/**
 * Hook for components to register focusable items
 */
export const useSpatialItem = (zone = 'main', id = null) => {
    const elementRef = useRef(null);

    const setRef = useCallback((node) => {
        // If the node has changed (or is unmounting)
        if (elementRef.current && elementRef.current !== node) {
            SpatialEngine.unregister(zone, elementRef.current);
        }

        if (node) {
            SpatialEngine.register(zone, node, id);
        }

        elementRef.current = node;
    }, [zone, id]); // Depend on ID now

    return setRef;
};

/**
 * Hook for the App to initialize the Global Arbiter
 */
export const useSpatialArbiter = (onBack) => {
    useEffect(() => {
        const handleKeyDown = (e) => {
            const isTyping = ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName);

            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // Allow Up/Down to escape input, and Left/Right if not typing
                if (isTyping && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) return;

                e.preventDefault();
                SpatialEngine.move(e.key);
            }

            if (e.key === 'Enter' || e.key === ' ') {
                if (isTyping) return;

                e.preventDefault();
                const active = document.activeElement;
                if (active && active.classList.contains('focusable')) {
                    active.click();
                }
            }

            if (e.key === 'Escape' || e.key === 'Backspace') {
                if (isTyping && e.key === 'Backspace') return;
                if (onBack) {
                    onBack();
                }
            }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [onBack]);

    return {
        setActiveZone: (zone) => SpatialEngine.setActiveZone(zone)
    };
};

export default SpatialEngine;

```

---

## client/src/hooks/useTVNavigation.js

```javascript
/**
 * useTVNavigation - Universal TV Remote Navigation Hook
 * Stage 6.2: Handles D-pad navigation for lists and grids
 * 
 * @param {Object} options
 * @param {number} options.itemCount - Total number of items
 * @param {number} options.columns - Number of columns (1 for vertical list, >1 for grid)
 * @param {function} options.onSelect - Callback when Enter/OK pressed (receives index)
 * @param {function} options.onBack - Callback when Escape/Back pressed
 * @param {React.RefObject[]} options.itemRefs - Array of refs for scrollIntoView
 * @param {boolean} options.loop - Whether to loop at edges (default: false)
 * @param {boolean} options.trapFocus - Prevent focus from leaving (default: true)
 */
import { useState, useCallback, useEffect } from 'react'

export const useTVNavigation = ({
    itemCount,
    columns = 1,
    onSelect,
    onBack,
    itemRefs,
    loop = false,
    trapFocus = true,
    initialIndex = -1
}) => {
    const [focusedIndex, setFocusedIndex] = useState(initialIndex)

    // Calculate grid navigation
    const rows = Math.ceil(itemCount / columns)

    const handleKeyDown = useCallback((e) => {
        if (itemCount === 0) return

        let newIndex = focusedIndex
        let handled = false

        switch (e.key) {
            case 'ArrowDown':
                if (columns === 1) {
                    // Vertical list: move down by 1
                    if (focusedIndex < itemCount - 1) {
                        newIndex = focusedIndex + 1
                        handled = true
                    } else if (loop) {
                        newIndex = 0
                        handled = true
                    } else if (trapFocus) {
                        handled = true // Prevent default but don't change index
                    }
                } else {
                    // Grid: move down by columns
                    if (focusedIndex + columns < itemCount) {
                        newIndex = focusedIndex + columns
                        handled = true
                    } else if (trapFocus) {
                        handled = true
                    }
                }
                break

            case 'ArrowUp':
                if (columns === 1) {
                    // Vertical list: move up by 1
                    if (focusedIndex > 0) {
                        newIndex = focusedIndex - 1
                        handled = true
                    } else if (loop) {
                        newIndex = itemCount - 1
                        handled = true
                    }
                } else {
                    // Grid: move up by columns
                    if (focusedIndex - columns >= 0) {
                        newIndex = focusedIndex - columns
                        handled = true
                    }
                }
                break

            case 'ArrowRight':
                if (columns > 1) {
                    // Grid: move right
                    const currentCol = focusedIndex % columns
                    if (currentCol < columns - 1 && focusedIndex < itemCount - 1) {
                        newIndex = focusedIndex + 1
                        handled = true
                    }
                }
                break

            case 'ArrowLeft':
                if (columns > 1) {
                    // Grid: move left
                    const currentCol = focusedIndex % columns
                    if (currentCol > 0) {
                        newIndex = focusedIndex - 1
                        handled = true
                    }
                }
                break

            case 'Enter':
            case ' ':
                if (focusedIndex >= 0 && onSelect) {
                    e.preventDefault()
                    onSelect(focusedIndex)
                    return
                }
                break

            case 'Escape':
            case 'Backspace':
                if (onBack) {
                    e.preventDefault()
                    onBack()
                    return
                }
                break
        }

        if (handled) {
            e.preventDefault()
            e.stopPropagation() // ‚úÖ Prevent bubbling to HomePanel if handled here
            if (newIndex !== focusedIndex && newIndex >= 0 && newIndex < itemCount) {
                setFocusedIndex(newIndex)
            }
        }
    }, [focusedIndex, itemCount, columns, loop, trapFocus, onSelect, onBack])

    // Scroll into view when focused index changes
    // FIX-01a: Use 'center' instead of 'nearest' for better TV UX
    // Scroll into view logic removed: relying on focus() native behavior prevents "fighting" and lag.
    // If explicit scrolling is needed later, use 'scroll-margin' CSS on items instead.

    // Focus the element when index changes
    useEffect(() => {
        if (focusedIndex >= 0 && itemRefs?.current?.[focusedIndex]) {
            itemRefs.current[focusedIndex].focus()
        }
    }, [focusedIndex, itemRefs])

    // Reset focus when item count changes and current index is out of bounds
    useEffect(() => {
        if (focusedIndex >= itemCount) {
            setFocusedIndex(Math.max(0, itemCount - 1))
        }
    }, [itemCount, focusedIndex])

    return {
        focusedIndex,
        setFocusedIndex,
        handleKeyDown,
        // Helper for binding to container
        containerProps: {
            onKeyDown: handleKeyDown,
            tabIndex: 0
        },
        // Helper for checking if item is focused
        isFocused: (index) => focusedIndex === index
    }
}

export default useTVNavigation

```

---

## client/src/index.css

```css
@import "tailwindcss";

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   PWA-TorServe - TV-First Design System
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

/* Prevent horizontal and vertical overflow (TV App Mode) */
html,
body {
  overflow: hidden;
  /* Lock body scroll */
  height: 100vh;
  width: 100vw;
  margin: 0;
  padding: 0;
  overscroll-behavior: none;
  /* Prevent bounce */
}

#root {
  position: fixed;
  inset: 0;
  height: 100vh;
  width: 100vw;
  overflow: hidden;
  /* Lock root scroll */
  display: flex;
  flex-direction: column;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   TV Focus States (v4.0 Spatial Unified)
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

/* Remove default focus outline */
*:focus {
  outline: none;
}

/* Base focusable item */
.focusable {
  outline: none;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  scroll-margin: 120px;
  /* Automated scroll spacing */
}

.focusable:focus {
  scale: 1.05;
  box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.8), 0 10px 30px rgba(0, 0, 0, 0.5);
  z-index: 50;

  /* Only add relative if not already absolute/fixed */
  &:not(.absolute):not(.fixed) {
    position: relative;
  }
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Horizontal Snap Containers
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.snap-container {
  display: flex;
  overflow-x: auto;
  scroll-snap-type: x mandatory;
  scroll-behavior: smooth;
  -ms-overflow-style: none;
  scrollbar-width: none;
}

.snap-container::-webkit-scrollbar {
  display: none;
}

.snap-item {
  scroll-snap-align: center;
  flex-shrink: 0;
}

/* Card Focus - Netflix Style */
.tv-card {
  transition: all 0.2s ease-out;
  cursor: pointer;
}

.tv-card:focus {
  transform: scale(1.08);
  box-shadow: 0 0 0 4px white, 0 8px 30px rgba(0, 0, 0, 0.5);
  z-index: 10;
  position: relative;
}

.tv-card:hover {
  transform: scale(1.05);
}

/* Primary Button Focus */
.tv-btn-primary:focus {
  transform: scale(1.05);
  box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.8), 0 4px 20px rgba(34, 197, 94, 0.4);
}

/* Danger Button Focus */
.tv-btn-danger:focus {
  box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.8);
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Netflix Grid Layout
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

.netflix-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 1.5rem;
  padding: 1rem;
}

/* Larger cards on TV (big screens) */
@media (min-width: 1280px) {
  .netflix-grid {
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 2rem;
    padding: 2rem;
  }
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Smooth Horizontal Scroll (LAMPA-style)
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

.home-row .overflow-x-auto {
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch;
  will-change: scroll-position;
}

/* Hide scrollbar but keep functionality */
.scrollbar-hide::-webkit-scrollbar {
  display: none;
}

.scrollbar-hide {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Season Card (TV Focus)
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.season-card {
  transition: all 0.2s ease-out;
  cursor: pointer;
  border-radius: 0.5rem;
  overflow: hidden;
  position: relative;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

.season-card:focus {
  outline: none;
  transform: scale(1.05);
  box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.8), 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  z-index: 20;
}

.season-card:focus img {
  opacity: 1 !important;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Torrent Card
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

.torrent-card {
  aspect-ratio: 16 / 10;
  background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
  border-radius: 12px;
  padding: 1.25rem;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  border: 2px solid transparent;
  position: relative;
  overflow: hidden;
}

.torrent-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, #3b82f6 0%, #8b5cf6 100%);
  opacity: 0;
  transition: opacity 0.2s;
}

.torrent-card:focus::before,
.torrent-card:hover::before {
  opacity: 1;
}

.torrent-card-title {
  font-size: 1.25rem;
  font-weight: 600;
  line-height: 1.3;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.torrent-card-status {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  font-size: 0.875rem;
  color: #94a3b8;
}

.torrent-card-progress {
  height: 6px;
  background: #334155;
  border-radius: 3px;
  overflow: hidden;
  margin-top: 0.5rem;
}

.torrent-card-progress-bar {
  height: 100%;
  background: linear-gradient(90deg, #3b82f6 0%, #22c55e 100%);
  border-radius: 3px;
  transition: width 0.3s ease;
}

/* Ready state - green glow */
.torrent-card.ready {
  border-color: #22c55e;
}

.torrent-card.ready::before {
  background: #22c55e;
  opacity: 1;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Details Modal (Full Screen on TV)
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

.details-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(8px);
  z-index: 100;
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.2s ease-out;
}

.details-modal {
  background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%);
  border-radius: 24px;
  padding: 3rem;
  max-width: 700px;
  width: 90%;
  text-align: center;
  border: 1px solid #334155;
}

.details-title {
  font-size: 2.5rem;
  font-weight: 700;
  margin-bottom: 1rem;
  line-height: 1.2;
}

.details-progress-container {
  margin: 2rem 0;
}

.details-progress-bar {
  height: 12px;
  background: #334155;
  border-radius: 6px;
  overflow: hidden;
}

.details-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #3b82f6 0%, #22c55e 100%);
  border-radius: 6px;
  transition: width 0.3s ease;
}

.details-status {
  font-size: 1.25rem;
  margin-top: 0.75rem;
}

.details-status.ready {
  color: #22c55e;
}

.details-status.loading {
  color: #fbbf24;
}

.details-buttons {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin-top: 2.5rem;
}

.details-btn-watch {
  background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
  color: white;
  font-size: 1.5rem;
  font-weight: 700;
  padding: 1.25rem 2rem;
  border-radius: 16px;
  border: none;
  cursor: pointer;
  transition: all 0.2s;
}

.details-btn-watch:focus {
  transform: scale(1.05);
  box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.6), 0 8px 30px rgba(34, 197, 94, 0.3);
}

.details-btn-delete {
  background: transparent;
  color: #ef4444;
  font-size: 1rem;
  padding: 0.75rem 1.5rem;
  border-radius: 12px;
  border: 2px solid #ef4444;
  cursor: pointer;
  transition: all 0.2s;
}

.details-btn-delete:focus {
  background: #ef4444;
  color: white;
  box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.5);
}

.details-back {
  margin-top: 2rem;
  font-size: 0.875rem;
  color: #64748b;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Mobile Optimizations
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

@media (max-width: 640px) {
  .netflix-grid {
    grid-template-columns: 1fr;
    gap: 1rem;
    padding: 0.75rem;
  }

  .torrent-card {
    aspect-ratio: auto;
    padding: 1rem;
  }

  .details-modal {
    padding: 2.5rem;
    /* Larger padding */
    border-radius: 24px;
    max-width: 95%;
    /* Use more screen width */
    border: 2px solid #475569;
  }

  .details-title {
    font-size: 2rem;
    /* Larger title */
    margin-bottom: 2rem;
  }

  .details-progress-bar {
    height: 20px;
    /* Thicker bar */
  }

  .details-btn-watch {
    font-size: 1.75rem;
    /* Hugo watch button */
    padding: 1.5rem 3rem;
    width: 100%;
    /* Full width */
    margin-bottom: 1rem;
  }

  .details-btn-delete {
    font-size: 1.25rem;
    padding: 1.25rem;
    width: 100%;
  }

  .details-back {
    font-size: 1.25rem;
    /* Larger hint */
    margin-top: 2rem;
    opacity: 0.8;
  }
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Animations
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-8px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideInRight {
  from {
    transform: translateX(100%);
  }

  to {
    transform: translateX(0);
  }
}

.animate-slide-in-right {
  animation: slideInRight 0.3s cubic-bezier(0.16, 1, 0.3, 1);
}

.custom-scrollbar::-webkit-scrollbar {
  width: 4px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #333;
  border-radius: 10px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #444;
}

/* Removed pulse-ready animation to prevent visual conflict with focus state */

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Header & Settings
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

.header-btn:focus {
  transform: scale(1.2);
  color: white;
}

.settings-panel {
  max-width: 500px;
  margin: 0 auto 2rem;
}
```

---

## client/src/main.jsx

```javascript
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'
import ErrorBoundary from './components/ErrorBoundary.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <ErrorBoundary>
      <App />
    </ErrorBoundary>
  </StrictMode>,
)

```

---

## client/src/utils/ContentRowsRegistry.js

```javascript
/**
 * ContentRowsRegistry - Lampa-style registry for Home Page rows
 * Allows decoupled registration of content sources.
 */

class ContentRowsRegistry {
    constructor() {
        this.rows = []
        this.initialized = false
    }

    /**
     * Register a new row or list of rows
     * @param {Object|Array} config 
     * @param {string} config.id - Unique ID (e.g. 'trending')
     * @param {string} config.title - Display title
     * @param {string} config.type - 'list' | 'hero' | 'continue'
     * @param {Function} config.fetcher - Async function returning { items: [] }
     * @param {number} config.order - Display order (default: 100)
     */
    add(config) {
        const items = Array.isArray(config) ? config : [config]

        items.forEach(row => {
            const existing = this.rows.find(r => r.id === row.id)
            if (existing) {
                console.warn(`[Registry] Overwriting row: ${row.id}`)
                Object.assign(existing, row)
            } else {
                this.rows.push({
                    order: 100,
                    ...row
                })
            }
        })

        this.sort()
    }

    sort() {
        this.rows.sort((a, b) => a.order - b.order)
    }

    getAll() {
        return this.rows
    }

    /**
     * Get row by ID
     */
    get(id) {
        return this.rows.find(r => r.id === id)
    }

    /**
     * Initialize default Discovery rows
     * (Imported dynamically to avoid cycle deps if needed, 
     * but for now we inject the discovery array)
     */
    init(discoveryCategories) {
        if (this.initialized) return

        // Map legacy DISCOVERY_CATEGORIES to Registry format
        const defaultRows = discoveryCategories.map((cat, index) => ({
            id: cat.id,
            title: cat.name,
            icon: cat.icon,
            type: 'list',
            fetcher: cat.fetcher,
            order: (index + 1) * 10
        }))

        this.add(defaultRows)
        this.initialized = true
        console.log(`[Registry] Initialized with ${defaultRows.length} rows`)
    }
}

export const contentRowsRegistry = new ContentRowsRegistry()

```

---

## client/src/utils/SpatialNavigation.js

```javascript
/**
 * SpatialNavigation.js
 * Geometric navigation logic for TV interfaces.
 * "Focus is Global, Logic is Local"
 */

/**
 * Find the next focusable element based on geometric position
 * @param {HTMLElement} current - The currently focused element
 * @param {string} direction - 'up', 'down', 'left', 'right'
 * @param {HTMLElement} container - The container to search within (optional)
 * @returns {HTMLElement|null} The best candidate or null
 */
export const findNextFocus = (current, direction, container = document) => {
    if (!current) return null

    const rect = current.getBoundingClientRect()
    const candidates = Array.from(container.querySelectorAll('.focusable'))
        .filter(el => el !== current && isVisible(el))

    let bestCandidate = null
    let minDistance = Infinity

    for (const candidate of candidates) {
        const candidateRect = candidate.getBoundingClientRect()

        if (isValidCandidate(rect, candidateRect, direction)) {
            const distance = getDistance(rect, candidateRect, direction)

            // Weight alignment heavily to prefer straight lines
            const alignment = getAlignmentPenalty(rect, candidateRect, direction)
            const score = distance + alignment

            if (score < minDistance) {
                minDistance = score
                bestCandidate = candidate
            }
        }
    }

    return bestCandidate
}

// Check if candidate is strictly in the direction of movement
const isValidCandidate = (current, candidate, direction) => {
    switch (direction) {
        case 'up': return candidate.bottom <= current.top + 10 // To allow slight overlap
        case 'down': return candidate.top >= current.bottom - 10
        case 'left': return candidate.right <= current.left + 10
        case 'right': return candidate.left >= current.right - 10
    }
    return false
}

// Euclidean distance between closest points or centers
const getDistance = (current, candidate, direction) => {
    // Simple center-to-center distance for now
    const currentCenter = getCenter(current)
    const candidateCenter = getCenter(candidate)

    return Math.sqrt(
        Math.pow(currentCenter.x - candidateCenter.x, 2) +
        Math.pow(currentCenter.y - candidateCenter.y, 2)
    )
}

// Penalize elements that are far off the main axis
const getAlignmentPenalty = (current, candidate, direction) => {
    const currentCenter = getCenter(current)
    const candidateCenter = getCenter(candidate)

    // For vertical movement, penalize horizontal deviation
    if (direction === 'up' || direction === 'down') {
        return Math.abs(currentCenter.x - candidateCenter.x) * 2
    }
    // For horizontal movement, penalize vertical deviation
    return Math.abs(currentCenter.y - candidateCenter.y) * 2
}

const getCenter = (rect) => ({
    x: rect.left + rect.width / 2,
    y: rect.top + rect.height / 2
})

const isVisible = (el) => {
    return el.offsetParent !== null // Basic visibility check
}

```

---

## client/src/utils/discover.js

```javascript
/**
 * discover.js ‚Äî Client-side Discovery API
 * Uses tmdbClient for fetching with automatic fallback
 * 
 * Categories:
 * - üî• Trending (week)
 * - üé¨ Popular Movies
 * - üì∫ Popular TV Shows
 * - ‚≠ê Top Rated
 */

import {
    getTrending,
    getPopularMovies,
    getPopularTV,
    getTopRated,
    filterDiscoveryResults,
    getImageUrl,
    tmdbClient,
    reportBrokenImage
} from './tmdbClient.js'

export { getImageUrl }

// ‚îÄ‚îÄ‚îÄ Discovery Categories (Lampa-style) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Fetch helpers for new endpoints
const fetchNowPlaying = (page = 1) => tmdbClient(`/movie/now_playing?page=${page}`, { cacheTTL: 10 * 60 * 1000 })
const fetchTrendingDay = (page = 1) => tmdbClient(`/trending/movie/day?page=${page}`, { cacheTTL: 10 * 60 * 1000 })
const fetchUpcoming = (page = 1) => tmdbClient(`/movie/upcoming?page=${page}`, { cacheTTL: 10 * 60 * 1000 })
const fetchTopTV = (page = 1) => tmdbClient(`/tv/top_rated?page=${page}`, { cacheTTL: 10 * 60 * 1000 })
const fetchGenre = (id, page = 1) => tmdbClient(`/discover/movie?with_genres=${id}&sort_by=popularity.desc&language=ru-RU&page=${page}`, { cacheTTL: 60 * 60 * 1000 })

export const DISCOVERY_CATEGORIES = [
    { id: 'now_playing', name: '–°–µ–π—á–∞—Å —Å–º–æ—Ç—Ä—è—Ç', icon: 'üé¨', fetcher: fetchNowPlaying },
    { id: 'trending_day', name: '–¢—Ä–µ–Ω–¥—ã –¥–Ω—è', icon: 'üìà', fetcher: fetchTrendingDay },
    { id: 'genre_28', name: '–ë–æ–µ–≤–∏–∫–∏', icon: 'üëä', fetcher: (page) => fetchGenre(28, page) },
    { id: 'trending', name: '–¢—Ä–µ–Ω–¥—ã –Ω–µ–¥–µ–ª–∏', icon: 'üî•', fetcher: (page) => getTrending('week', page) },
    { id: 'genre_35', name: '–ö–æ–º–µ–¥–∏–∏', icon: 'üòÇ', fetcher: (page) => fetchGenre(35, page) },
    { id: 'upcoming', name: '–°–∫–æ—Ä–æ –≤ –∫–∏–Ω–æ', icon: 'üìÖ', fetcher: fetchUpcoming },
    { id: 'movies', name: '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ñ–∏–ª—å–º—ã', icon: '‚≠ê', fetcher: getPopularMovies },
    { id: 'genre_878', name: '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞', icon: 'üëΩ', fetcher: (page) => fetchGenre(878, page) },
    { id: 'tv', name: '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Å–µ—Ä–∏–∞–ª—ã', icon: 'üì∫', fetcher: getPopularTV },
    { id: 'genre_16', name: '–ú—É–ª—å—Ç—Ñ–∏–ª—å–º—ã', icon: 'üé®', fetcher: (page) => fetchGenre(16, page) },
    { id: 'top', name: '–¢–æ–ø —Ñ–∏–ª—å–º–æ–≤', icon: 'üèÜ', fetcher: getTopRated },
    { id: 'top_tv', name: '–¢–æ–ø —Å–µ—Ä–∏–∞–ª–æ–≤', icon: 'üèÜ', fetcher: fetchTopTV }
]

/**
 * Fetch all discovery categories in parallel
 * Includes cross-category deduplication to prevent duplicate items
 * @returns {Promise<Object>} { trending: [...], movies: [...], tv: [...], top: [...] }
 */
export async function fetchAllDiscovery() {
    const results = {}
    const seenIds = new Set() // Track seen item IDs for deduplication

    // Fetch all categories in parallel
    const categoryResults = await Promise.all(
        DISCOVERY_CATEGORIES.map(async (category) => {
            try {
                let page = 1
                let response = await category.fetcher(page)
                let items = filterDiscoveryResults(response.results || [])
                const source = response.source
                const method = response.method

                // Fetch more pages if we don't have enough items (up to 4 pages max)
                while (items.length < 20 && page < 4) {
                    try {
                        page++
                        const responseNext = await category.fetcher(page)
                        const itemsNext = filterDiscoveryResults(responseNext.results || [])

                        // Merge avoiding duplicates
                        const existingIds = new Set(items.map(i => i.id))
                        const uniqueNewItems = itemsNext.filter(i => !existingIds.has(i.id))

                        if (uniqueNewItems.length === 0) break

                        items = [...items, ...uniqueNewItems]
                    } catch (e2) {
                        console.warn(`[Discovery] Page ${page} fetch failed for ${category.id}`, e2)
                        break
                    }
                }

                // Limit to 20 items per row
                items = items.slice(0, 20)

                return {
                    category,
                    items,
                    source,
                    method
                }
            } catch (e) {
                console.error(`[Discovery] Failed to fetch ${category.id}:`, e)
                return {
                    category,
                    items: [],
                    error: e.message
                }
            }
        })
    )

    // Process results in order, deduplicating across categories
    for (const { category, items, source, method, error } of categoryResults) {
        // Filter out items already seen in previous categories
        const uniqueItems = items.filter(item => {
            if (seenIds.has(item.id)) return false
            seenIds.add(item.id)
            return true
        })

        results[category.id] = {
            ...category,
            items: uniqueItems,
            fetcher: category.fetcher,  // Include fetcher for pagination in CategoryPage
            source,
            method,
            error
        }
    }

    return results
}

/**
 * Fetch a single category
 * @param {string} categoryId - One of: trending, movies, tv, top
 */
export async function fetchCategory(categoryId) {
    const category = DISCOVERY_CATEGORIES.find(c => c.id === categoryId)
    if (!category) {
        console.warn(`[Discovery] Unknown category: ${categoryId}`)
        return { items: [], error: 'Unknown category' }
    }

    try {
        const response = await category.fetcher()
        return {
            ...category,
            items: filterDiscoveryResults(response.results || []),
            source: response.source,
            method: response.method
        }
    } catch (e) {
        console.error(`[Discovery] Failed to fetch ${categoryId}:`, e)
        return { ...category, items: [], error: e.message }
    }
}

/**
 * Get poster URL for a discovery item
 * Handles both TMDB and Kinopoisk sources
 */
export function getPosterUrl(item, size = 'w342') {
    if (!item) return null

    // Kinopoisk items have posterUrlPreview in _kp_data
    if (item._kp_data?.posterUrlPreview) {
        return `https://wsrv.nl/?url=${encodeURIComponent(item._kp_data.posterUrlPreview)}&output=webp`
    }

    // TMDB poster via CDN mirror
    if (item.poster_path) {
        // Use ssl: prefix for TMDB images to avoid mixed content in APK
        const path = `ssl:image.tmdb.org/t/p/${size}${item.poster_path}`
        return getImageUrl(item.poster_path, size)
    }

    return null
}

/**
 * Get backdrop URL for a discovery item
 */
export function getBackdropUrl(item, size = 'w1280') {
    if (!item) return null

    if (item.backdrop_path) {
        const path = `ssl:image.tmdb.org/t/p/${size}${item.backdrop_path}`
        return getImageUrl(item.backdrop_path, size)
    }

    return null
}

/**
 * Get display title for a discovery item
 */
export function getTitle(item) {
    return item?.title || item?.name || item?.original_title || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'
}

/**
 * Get year from release date
 */
export function getYear(item) {
    const date = item?.release_date || item?.first_air_date
    return date ? date.substring(0, 4) : null
}

/**
 * Generate search query for torrent lookup
 * Movies: "Title Year"
 * TV Shows: "Title S01" (to find season packs)
 */
export function getSearchQuery(item) {
    const title = getTitle(item)
    const year = getYear(item)
    const mediaType = item?.media_type

    if (mediaType === 'tv') {
        // For TV shows, search for season packs
        return `${title} S01`
    }

    // For movies, use only title (year often breaks search)
    return title
}

export default {
    DISCOVERY_CATEGORIES,
    fetchAllDiscovery,
    fetchCategory,
    getPosterUrl,
    getBackdropUrl,
    getTitle,
    getYear,
    getSearchQuery
}

```

---

## client/src/utils/discover.test.js

```javascript
/**
 * Unit Tests for discover.js utilities
 * PWA-TorServe Client Tests
 */

import { describe, it, expect, vi } from 'vitest'
import {
    getPosterUrl,
    getBackdropUrl,
    getTitle,
    getYear,
    getSearchQuery,
    DISCOVERY_CATEGORIES
} from './discover.js'

// ‚îÄ‚îÄ‚îÄ Helper Function Tests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

describe('getTitle', () => {
    it('returns title for movie', () => {
        expect(getTitle({ title: 'Inception' })).toBe('Inception')
    })

    it('returns name for TV show', () => {
        expect(getTitle({ name: 'Breaking Bad' })).toBe('Breaking Bad')
    })

    it('fallback to original_title', () => {
        expect(getTitle({ original_title: 'Original' })).toBe('Original')
    })

    it('returns default for empty item', () => {
        expect(getTitle({})).toBe('–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')
        expect(getTitle(null)).toBe('–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')
        expect(getTitle(undefined)).toBe('–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')
    })

    it('prefers title over name', () => {
        expect(getTitle({ title: 'Movie', name: 'Show' })).toBe('Movie')
    })
})

describe('getYear', () => {
    it('extracts year from release_date', () => {
        expect(getYear({ release_date: '2023-07-21' })).toBe('2023')
    })

    it('extracts year from first_air_date', () => {
        expect(getYear({ first_air_date: '2008-01-20' })).toBe('2008')
    })

    it('prefers release_date over first_air_date', () => {
        expect(getYear({ release_date: '2020-01-01', first_air_date: '2019-01-01' })).toBe('2020')
    })

    it('returns null for missing date', () => {
        expect(getYear({})).toBe(null)
        expect(getYear(null)).toBe(null)
    })
})

describe('getSearchQuery', () => {
    it('returns title for movie', () => {
        expect(getSearchQuery({ title: 'Dune', media_type: 'movie' })).toBe('Dune')
    })

    it('returns title + S01 for TV show', () => {
        expect(getSearchQuery({ name: 'The Bear', media_type: 'tv' })).toBe('The Bear S01')
    })

    it('works without media_type (treated as movie)', () => {
        expect(getSearchQuery({ title: 'Oppenheimer' })).toBe('Oppenheimer')
    })
})

// ‚îÄ‚îÄ‚îÄ Poster URL Tests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

describe('getPosterUrl', () => {
    it('returns null for empty item', () => {
        expect(getPosterUrl(null)).toBe(null)
        expect(getPosterUrl(undefined)).toBe(null)
        expect(getPosterUrl({})).toBe(null)
    })

    it('returns TMDB poster URL for poster_path', () => {
        const url = getPosterUrl({ poster_path: '/abc123.jpg' })
        expect(url).toContain('abc123.jpg')
        expect(url).toContain('w342') // default size
    })

    it('returns Kinopoisk URL when _kp_data present', () => {
        const url = getPosterUrl({
            _kp_data: { posterUrlPreview: 'https://kp.cdn.com/poster.jpg' }
        })
        expect(url).toContain('wsrv.nl')
        expect(url).toContain('poster.jpg')
    })
})

describe('getBackdropUrl', () => {
    it('returns null for empty item', () => {
        expect(getBackdropUrl(null)).toBe(null)
        expect(getBackdropUrl({})).toBe(null)
    })

    it('returns backdrop URL for backdrop_path', () => {
        const url = getBackdropUrl({ backdrop_path: '/backdrop.jpg' })
        expect(url).toContain('backdrop.jpg')
        expect(url).toContain('w1280') // default size
    })
})

// ‚îÄ‚îÄ‚îÄ Categories Config Tests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

describe('DISCOVERY_CATEGORIES', () => {
    it('has required categories', () => {
        const ids = DISCOVERY_CATEGORIES.map(c => c.id)
        expect(ids).toContain('trending')
        expect(ids).toContain('movies')
        expect(ids).toContain('tv')
        expect(ids).toContain('top')
    })

    it('each category has required fields', () => {
        DISCOVERY_CATEGORIES.forEach(cat => {
            expect(cat).toHaveProperty('id')
            expect(cat).toHaveProperty('name')
            expect(cat).toHaveProperty('icon')
            expect(cat).toHaveProperty('fetcher')
            expect(typeof cat.fetcher).toBe('function')
        })
    })
})

```

---

## client/src/utils/genres.js

```javascript
/**
 * TMDB Genre Map ‚Äî Hardcoded dictionary
 * Avoids extra API calls to /genre/movie/list
 * 
 * Source: https://developers.themoviedb.org/3/genres/get-movie-list
 */

// Movie genres
export const MOVIE_GENRES = {
    28: '–ë–æ–µ–≤–∏–∫',
    12: '–ü—Ä–∏–∫–ª—é—á–µ–Ω–∏—è',
    16: '–ú—É–ª—å—Ç—Ñ–∏–ª—å–º',
    35: '–ö–æ–º–µ–¥–∏—è',
    80: '–ö—Ä–∏–º–∏–Ω–∞–ª',
    99: '–î–æ–∫—É–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π',
    18: '–î—Ä–∞–º–∞',
    10751: '–°–µ–º–µ–π–Ω—ã–π',
    14: '–§—ç–Ω—Ç–µ–∑–∏',
    36: '–ò—Å—Ç–æ—Ä–∏—è',
    27: '–£–∂–∞—Å—ã',
    10402: '–ú—É–∑—ã–∫–∞',
    9648: '–î–µ—Ç–µ–∫—Ç–∏–≤',
    10749: '–ú–µ–ª–æ–¥—Ä–∞–º–∞',
    878: '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞',
    10770: '–¢–µ–ª–µ—Ñ–∏–ª—å–º',
    53: '–¢—Ä–∏–ª–ª–µ—Ä',
    10752: '–í–æ–µ–Ω–Ω—ã–π',
    37: '–í–µ—Å—Ç–µ—Ä–Ω'
}

// TV genres (some overlap with movies)
export const TV_GENRES = {
    10759: '–≠–∫—à–Ω –∏ –ü—Ä–∏–∫–ª—é—á–µ–Ω–∏—è',
    16: '–ú—É–ª—å—Ç—Ñ–∏–ª—å–º',
    35: '–ö–æ–º–µ–¥–∏—è',
    80: '–ö—Ä–∏–º–∏–Ω–∞–ª',
    99: '–î–æ–∫—É–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π',
    18: '–î—Ä–∞–º–∞',
    10751: '–°–µ–º–µ–π–Ω—ã–π',
    10762: '–î–µ—Ç—Å–∫–∏–π',
    9648: '–î–µ—Ç–µ–∫—Ç–∏–≤',
    10763: '–ù–æ–≤–æ—Å—Ç–∏',
    10764: '–†–µ–∞–ª–∏—Ç–∏',
    10765: '–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞ –∏ –§—ç–Ω—Ç–µ–∑–∏',
    10766: '–ú—ã–ª—å–Ω–∞—è –æ–ø–µ—Ä–∞',
    10767: '–¢–æ–∫-—à–æ—É',
    10768: '–í–æ–π–Ω–∞ –∏ –ü–æ–ª–∏—Ç–∏–∫–∞',
    37: '–í–µ—Å—Ç–µ—Ä–Ω'
}

// Combined genres (prioritizes movie names for overlaps)
export const GENRES = { ...TV_GENRES, ...MOVIE_GENRES }

/**
 * Convert genre IDs array to names
 * @param {number[]} ids - Array of genre IDs
 * @returns {string[]} Array of genre names
 */
export const getGenreNames = (ids) => {
    if (!ids || !Array.isArray(ids)) return []
    return ids.map(id => GENRES[id]).filter(Boolean)
}

/**
 * Get first N genre names as a string
 * @param {number[]} ids - Array of genre IDs
 * @param {number} limit - Max genres to show (default: 2)
 * @returns {string} Comma-separated genre names
 */
export const formatGenres = (ids, limit = 2) => {
    return getGenreNames(ids).slice(0, limit).join(', ')
}

/**
 * Get genre names for a movie/tv item
 * Handles both genre_ids (list) and genres (detail)
 * @param {Object} item - Movie/TV item
 * @returns {string[]} Array of genre names
 */
/**
 * Get genre objects for a movie/tv item
 * @param {Object} item - Movie/TV item
 * @returns {Array<{id: number, name: string}>} Array of genre objects
 */
export const getGenreObjectsForItem = (item) => {
    if (!item) return []

    // If item has genre_ids (common in list responses)
    if (item.genre_ids && Array.isArray(item.genre_ids)) {
        return item.genre_ids
            .map(id => ({ id, name: GENRES[id] }))
            .filter(g => g.name)
    }

    // If item has genres array (common in detail responses)
    // TMDB returns objects { id, name }
    if (item.genres && Array.isArray(item.genres)) {
        return item.genres.map(g => ({
            id: g.id,
            name: g.name || GENRES[g.id]
        })).filter(g => g.name)
    }

    return []
}

export const getGenresForItem = (item) => {
    if (!item) return []

    const objects = getGenreObjectsForItem(item)
    return objects.map(g => g.name)
}

export default GENRES

```

---

## client/src/utils/helpers.js

```javascript
/**
 * Utility helpers for PWA-TorServe
 */

/**
 * Clean torrent/file name for display and poster search
 * Removes technical tags, year suffixes, season markers, and garbage characters
 */
export const cleanTitle = (rawName) => {
    if (!rawName) return ''

    // 1. –ë–∞–∑–æ–≤–∞—è —á–∏—Å—Ç–∫–∞: —Ç–æ—á–∫–∏, –Ω–∏–∂–Ω–∏–µ –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏—è, —Å–∫–æ–±–∫–∏
    let name = rawName
        .replace(/\./g, ' ')
        .replace(/_/g, ' ')
        .replace(/\[.*?\]/g, '') // –£–¥–∞–ª—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö —Å–∫–æ–±–æ–∫
        .replace(/\(.*?\)/g, '') // –£–¥–∞–ª—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫—Ä—É–≥–ª—ã—Ö —Å–∫–æ–±–æ–∫
        .trim()

    // 2. üî• –í–ê–ñ–ù–û: –û–±—Ä–µ–∑–∞–µ–º –ø–æ –°–µ–∑–æ–Ω—É (S01, s01e01), –µ—Å–ª–∏ –≥–æ–¥–∞ –Ω–µ—Ç
    // –≠—Ç–æ —Å–ø–∞—Å–µ—Ç "IT Welcome to Derry S01..." -> "IT Welcome to Derry"
    const seasonMatch = name.match(/\b(S\d{2}|s\d{2})\b/i)
    if (seasonMatch) {
        const index = name.indexOf(seasonMatch[0])
        name = name.substring(0, index)
    }

    // 3. –û–±—Ä–µ–∑–∞–µ–º –ø–æ –ì–æ–¥—É (–∫–∞–∫ –∏ –±—ã–ª–æ)
    const yearMatch = name.match(/\b(19\d{2}|20\d{2})\b/)
    if (yearMatch) {
        const index = name.indexOf(yearMatch[0])
        name = name.substring(0, index)
    }

    // 4. üî• –î–æ–ø–æ–ª–Ω–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ –º—É—Å–æ—Ä–Ω—ã—Ö —Ç–µ–≥–æ–≤
    const tags = [
        // –ö–∞—á–µ—Å—Ç–≤–æ –∏ —Ä–∏–ø—ã
        '1080p', '720p', '2160p', '4k', 'WEB-DL', 'WEBRip', 'BluRay', 'HDR',
        'H.264', 'H264', 'x264', 'x265', 'HEVC', 'AAC', 'AC3', 'DTS', 'HDTV', 'DV', 'DoVi',
        'SDR', 'BDRemux', 'Remux', 'TYMBLER', 'AKTEP', 'SOFCJ',
        'CHDRip', 'HDRip', 'DVDRip', 'BDRip', 'CAMRip', 'TS', 'TC',
        'DD5', 'DD51', 'DD', 'Atmos',
        // –í–µ—Ä—Å–∏–∏ –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è
        'v2', 'v3', 'v4', 'mkv', 'avi', 'mp4',
        // –Ø–∑—ã–∫–∏ –∏ –ø—Ä–æ—á–µ–µ
        'rus', 'eng', 'torrent', 'stream', 'dub', 'sub', 'extended',
        // –°—Ç—Ä–∏–º–∏–Ω–≥–∏
        'HMAX', 'ATVP', 'AMZN', 'NF', 'DSNP', 'HULU', 'OKKO', 'OM'
    ]

    // –£–¥–∞–ª—è–µ–º —Ç–µ–≥–∏ (–Ω–∞ —Å–ª—É—á–∞–π –µ—Å–ª–∏ –æ–Ω–∏ —Å—Ç–æ—è—Ç –î–û —Å–µ–∑–æ–Ω–∞/–≥–æ–¥–∞)
    tags.forEach(tag => {
        // –£–¥–∞–ª—è–µ–º —Ç–µ–≥ –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω–æ–µ —Å–ª–æ–≤–æ
        const regex = new RegExp(`\\b${tag}\\b`, 'gi')
        name = name.replace(regex, '')
    })

    return name
        .replace(/[^\w\s\u0400-\u04FF:\-]/g, '') // –û—Å—Ç–∞–≤–ª—è–µ–º –±—É–∫–≤—ã, —Ü–∏—Ñ—Ä—ã, –¥–≤–æ–µ—Ç–æ—á–∏–µ –∏ –¥–µ—Ñ–∏—Å
        .replace(/\s+/g, ' ') // –£–±–∏—Ä–∞–µ–º –¥–≤–æ–π–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã
        .trim()
}

/**
 * Format bytes to human readable size
 */
export const formatSize = (bytes) => {
    if (!bytes) return ''
    const units = ['B', 'KB', 'MB', 'GB', 'TB']
    let i = 0
    let size = bytes
    while (size >= 1024 && i < units.length - 1) {
        size /= 1024
        i++
    }
    return `${size.toFixed(1)} ${units[i]}`
}

/**
 * Format download speed (bytes/sec to human readable)
 */
export const formatSpeed = (bytesPerSec) => {
    if (!bytesPerSec || bytesPerSec < 1024) return ''
    const kbps = bytesPerSec / 1024
    if (kbps < 1024) return `${kbps.toFixed(0)} KB/s`
    return `${(kbps / 1024).toFixed(1)} MB/s`
}

/**
 * Format ETA (seconds to human readable)
 */
export const formatEta = (seconds) => {
    if (!seconds || seconds <= 0) return ''
    if (seconds < 60) return `${seconds}—Å`
    if (seconds < 3600) return `${Math.floor(seconds / 60)}–º`
    const hours = Math.floor(seconds / 3600)
    const mins = Math.floor((seconds % 3600) / 60)
    return `${hours}—á ${mins}–º`
}

/**
 * Generate gradient based on string hash (for fallback poster background)
 */
export const getGradient = (str) => {
    let hash = 0
    for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash)
    const h1 = Math.abs(hash % 360)
    const h2 = Math.abs((hash * 13) % 360)
    return `linear-gradient(135deg, hsl(${h1}, 70%, 20%), hsl(${h2}, 80%, 15%))`
}

/**
 * Smart File Organizer for Torrents
 * Separates Episodes from Extras/Samples and sorts Episodes by SxxExx
 */
export const organizeFiles = (files) => {
    if (!files || files.length === 0) return { episodes: [], extras: [] }

    const episodes = []
    const extras = []

    // Regex for SxxExx pattern (e.g. S01E01, s1e1, 1x01)
    const seasonEpisodeRegex = /(?:s|season|^)?\s*(\d{1,2})\s*(?:e|x|episode|^)\s*(\d{1,2})/i
    // Regex for simple Episode pattern (e.g. Episode 1, Ep 1) if no season detected
    const episodeRegex = /(?:e|ep|episode)\s*(\d{1,3})/i

    // Keywords identifying junk/extras
    const extraKeywords = ['sample', 'trailer', 'promo', 'featurette', 'extra', 'bonus', 'interview', 'behind the scenes']

    files.forEach(file => {
        const nameLower = file.name.toLowerCase()

        // 1. Detect Extras
        if (extraKeywords.some(kw => nameLower.includes(kw))) {
            extras.push(file)
            return
        }

        // 2. Detect Season/Episode
        const seMatch = file.name.match(seasonEpisodeRegex)

        if (seMatch) {
            // Found SxxExx
            const season = parseInt(seMatch[1], 10)
            const episode = parseInt(seMatch[2], 10)
            episodes.push({
                ...file,
                season,
                episode,
                sortKey: season * 1000 + episode // Simple sort key (S01E01 = 1001)
            })
        } else {
            // Try just Episode number
            const epMatch = file.name.match(episodeRegex)
            if (epMatch) {
                const episode = parseInt(epMatch[1], 10)
                episodes.push({
                    ...file,
                    season: 1, // Assume S1 if unknown
                    episode,
                    sortKey: 1000 + episode
                })
            } else {
                // No numbering found - classify as Extra if it's not clearly the main movie
                // If the torrent has many files and this one has no number, it's likely extra
                // BUT if it's a single file torrent, it's the movie. 
                // Since this function is usually for lists, we treat unnumbered as extras 
                // unless it looks very much like a video file and we have no other episodes.
                extras.push(file)
            }
        }
    })

    // If we have NO episodes detected but have "extras", it might be that the regex failed 
    // or it's just a list of movies (e.g. invalid series pack). 
    // In that case, move everything to "episodes" and sort alphabetically.
    if (episodes.length === 0 && extras.length > 0) {
        return {
            episodes: extras.sort((a, b) => a.name.localeCompare(b.name)),
            extras: []
        }
    }

    // Sort Episodes by Season/Episode
    episodes.sort((a, b) => {
        if (a.sortKey !== b.sortKey) return a.sortKey - b.sortKey
        return a.name.localeCompare(b.name)
    })

    // Sort Extras alphabetically
    extras.sort((a, b) => a.name.localeCompare(b.name))

    return { episodes, extras }
}

```

---

## client/src/utils/helpers.test.js

```javascript
/**
 * Unit Tests for helper utilities
 * PWA-TorServe Client Tests
 */

import { describe, it, expect } from 'vitest'
import { cleanTitle, formatSize, formatEta } from './helpers.js'

describe('cleanTitle', () => {
    it('removes common torrent suffixes', () => {
        expect(cleanTitle('Movie.2023.1080p.BluRay')).toContain('Movie')
    })

    it('removes season markers', () => {
        // cleanTitle uses \b word boundary, so S01 must be separate word
        expect(cleanTitle('Fallout S01 1080p')).toBe('Fallout')
    })

    it('removes year from title', () => {
        expect(cleanTitle('Dune 2021 1080p')).toBe('Dune')
    })

    it('handles null/undefined', () => {
        expect(cleanTitle(null)).toBe('')
        expect(cleanTitle(undefined)).toBe('')
        expect(cleanTitle('')).toBe('')
    })
})

describe('formatSize', () => {
    it('formats bytes to KB', () => {
        expect(formatSize(1024)).toBe('1.0 KB')
    })

    it('formats bytes to MB', () => {
        expect(formatSize(1024 * 1024)).toBe('1.0 MB')
    })

    it('formats bytes to GB', () => {
        expect(formatSize(1024 * 1024 * 1024)).toBe('1.0 GB')
    })

    it('handles zero', () => {
        expect(formatSize(0)).toBe('')
    })
})

describe('formatEta', () => {
    it('formats seconds to minutes', () => {
        expect(formatEta(120)).toBe('2–º')
    })

    it('formats seconds to hours and minutes', () => {
        expect(formatEta(3720)).toBe('1—á 2–º')
    })

    it('handles zero', () => {
        expect(formatEta(0)).toBe('')
    })
})

```

---

## client/src/utils/tmdbClient.js

```javascript
/**
 * tmdbClient.js ‚Äî Unified TMDB Fetcher
 * 
 * 5-Level Cascade (from POSTER_BATTLE_HISTORY.md):
 * 1. Custom Cloudflare Worker (VITE_TMDB_PROXY_URL)
 * 2. Lampa Proxy (apn-latest.onrender.com)
 * 3. CapacitorHttp + Client DoH (bypass DNS poisoning)
 * 4. corsproxy.io (browser fallback)
 * 5. Kinopoisk API (alternative data source)
 * 
 * Features:
 * - Automatic fallback through all levels
 * - Response caching with TTL
 * - Normalized response format
 */

import { CapacitorHttp } from '@capacitor/core'
import { Capacitor } from '@capacitor/core'

// ‚îÄ‚îÄ‚îÄ Polyfills ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const timeoutSignal = (ms) => {
    try {
        if (AbortSignal.timeout) return AbortSignal.timeout(ms)
    } catch (e) { /* ignore */ }
    const controller = new AbortController()
    setTimeout(() => controller.abort(), ms)
    return controller.signal
}

// ‚îÄ‚îÄ‚îÄ Configuration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const TMDB_API_KEY = import.meta.env.VITE_TMDB_API_KEY
const KP_API_KEY = import.meta.env.VITE_KP_API_KEY
const CUSTOM_PROXY = import.meta.env.VITE_TMDB_PROXY_URL
const LAMPA_PROXY = 'https://apn-latest.onrender.com'
const KP_PROXY = 'https://cors.kp556.workers.dev:8443'

// Cache configuration
const CACHE_PREFIX = 'tmdb_cache_v1_'
const METADATA_CACHE_PREFIX = 'metadata_v1_' // Consolidated from Poster.jsx
const METADATA_CACHE_LIMIT = 300
const CACHE_TTL = 5 * 60 * 1000 // 5 minutes for search
const DISCOVERY_CACHE_TTL = 10 * 60 * 1000 // 10 minutes for discovery

// ‚îÄ‚îÄ‚îÄ Image Mirrors (from Lampa) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 5 CDN mirrors with automatic failover and ban system
// 5 CDN mirrors with automatic failover and ban system
const IMAGE_MIRRORS = [
    'imagetmdb.com',
    'nl.imagetmdb.com',
    'de.imagetmdb.com',
    'pl.imagetmdb.com',
    'lampa.byskaz.ru/tmdb/img'
]

const PROXY_MODE_KEY = 'tmdb_image_proxy_enabled'

/**
 * Helper to get the base API URL from localStorage or current origin.
 * Essential for Capacitor native platforms where relative paths fail.
 */
function getApiBase() {
    if (typeof window === 'undefined') return ''
    const stored = localStorage.getItem('serverUrl')

    // üî• FIX: Check if stored URL is valid and NOT localhost (unless in browser)
    if (stored && stored.includes('://')) {
        const url = new URL(stored)
        if (Capacitor.isNativePlatform() && (url.hostname === 'localhost' || url.hostname === '127.0.0.1')) {
            // Skiping localhost on native - it won't work for proxying
        } else {
            return stored.replace(/\/$/, '')
        }
    }

    // For browser/PWA on same origin as server
    if (window.location.protocol.startsWith('http') && !Capacitor.isNativePlatform()) {
        return window.location.origin
    }

    return ''
}

// Mirror error tracking - auto-ban after 20 errors in 10 seconds
const mirrorStats = {}
IMAGE_MIRRORS.forEach(mirror => {
    mirrorStats[mirror] = { errors: [], banned: false }
})

/**
 * Get current active image mirror (Lampa-style ImageMirror)
 * @returns {string} - Current mirror hostname
 */
export function getCurrentImageMirror() {
    const freeMirrors = IMAGE_MIRRORS.filter(m => !mirrorStats[m].banned)
    const lastMirror = localStorage.getItem('tmdb_img_mirror') || ''

    if (freeMirrors.includes(lastMirror)) {
        return lastMirror
    } else if (freeMirrors.length > 0) {
        localStorage.setItem('tmdb_img_mirror', freeMirrors[0])
        return freeMirrors[0]
    }

    // All mirrors banned - reset and try first
    IMAGE_MIRRORS.forEach(m => { mirrorStats[m].banned = false })
    return IMAGE_MIRRORS[0]
}

/**
 * Report broken image URL - triggers mirror ban after 20 errors in 10s
 * @param {string} url - Failed image URL
 */
export function reportBrokenImage(url) {
    IMAGE_MIRRORS.forEach(mirror => {
        if (url && url.includes(mirror)) {
            const now = Date.now()
            const stats = mirrorStats[mirror]

            stats.errors.push(now)
            // Keep only errors from last 10 seconds
            stats.errors = stats.errors.filter(t => now - t < 10000)

            console.log(`[ImageMirror] ${mirror} errors: ${stats.errors.length}`)

            if (stats.errors.length >= 20) {
                stats.banned = true
                stats.errors = []
                console.warn(`[ImageMirror] BANNED: ${mirror}`)
                // Clear saved mirror to trigger switch
                localStorage.removeItem('tmdb_img_mirror')

                // Check if ALL mirrors are banned
                const allBanned = IMAGE_MIRRORS.every(m => mirrorStats[m].banned)
                if (allBanned) {
                    console.warn('[ImageMirror] üö® ALL MIRRORS BANNED! Switching to WSRV.NL Proxy Mode.')
                    localStorage.setItem(PROXY_MODE_KEY, 'true')
                    // Optional: force reload or event to allow UI to update immediately
                    // window.location.reload() 
                }
            }
        }
    })
}

/**
 * Get image URL with automatic cascade (Proxy -> Worker -> Lampa -> Mirror -> wsrv.nl)
 * ARC-01: Multi-layered resilience for images
 * @param {string} path - TMDB image path (e.g., /abcd123.jpg)
 * @param {string} size - Image size (default: w342)
 */
export function getImageUrl(path, size = 'w342') {
    if (!path) return ''
    if (path.startsWith('http')) return path

    const originalUrl = `https://image.tmdb.org/t/p/${size}${path}`
    const apiBase = getApiBase()

    // 1. For Browser (Localhost): Server Proxy is fine and reliable
    if (!Capacitor.isNativePlatform() && apiBase) {
        return `${apiBase}/api/proxy?url=${encodeURIComponent(originalUrl)}`
    }

    // 2. For APK (TV): Use Dynamic Mirror System
    // ARC-01: Check if Proxy Mode (WSRV) is forcibly enabled (due to all mirrors banned)
    const proxyMode = localStorage.getItem(PROXY_MODE_KEY) === 'true'

    if (proxyMode) {
        // Fallback: WSRV Global Proxy
        // Handles "ssl:" for TMDB bypassing
        return `https://wsrv.nl/?url=ssl:image.tmdb.org/t/p/${size}${path}&output=webp`
    }

    // Default: Use active CDN mirror (e.g. imagetmdb.com)
    // This connects to Lampa's mirror system which is fast and resilient in RU
    const mirror = getCurrentImageMirror()
    return `https://${mirror}/t/p/${size}${path}`
}

// ‚îÄ‚îÄ‚îÄ Client-Side DoH (Phase 3) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const dohCache = new Map()

/**
 * Resolve hostname to IP via Google DNS-over-HTTPS
 * Bypasses DNS poisoning where provider returns 127.0.0.1
 */
async function resolveClientIP(hostname) {
    // Check cache first
    const cached = dohCache.get(hostname)
    if (cached && Date.now() - cached.timestamp < 10 * 60 * 1000) {
        return cached.ip
    }

    try {
        // Google DNS-over-HTTPS API
        const res = await fetch(`https://dns.google/resolve?name=${hostname}&type=A`, {
            headers: { 'Accept': 'application/dns-json' }
        })

        if (res.ok) {
            const data = await res.json()
            const ip = data.Answer?.find(r => r.type === 1)?.data

            if (ip && ip !== '127.0.0.1') {
                dohCache.set(hostname, { ip, timestamp: Date.now() })
                console.log(`[DoH] Resolved ${hostname} ‚Üí ${ip}`)
                return ip
            }
        }
    } catch (e) {
        console.warn('[DoH] Resolution failed:', e.message)
    }

    return null
}

// ‚îÄ‚îÄ‚îÄ Cache Utilities ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function getCached(endpoint) {
    const key = CACHE_PREFIX + endpoint
    try {
        const cached = localStorage.getItem(key)
        if (cached) {
            const { data, timestamp, ttl } = JSON.parse(cached)
            if (Date.now() - timestamp < ttl) {
                return data
            }
            localStorage.removeItem(key)
        }
    } catch { }
    return null
}

function setCache(endpoint, data, ttl = CACHE_TTL) {
    const key = CACHE_PREFIX + endpoint
    try {
        localStorage.setItem(key, JSON.stringify({
            data,
            timestamp: Date.now(),
            ttl
        }))
    } catch (e) {
        console.warn('[Cache] Failed to save:', e.message)
    }
}

// ‚îÄ‚îÄ‚îÄ Metadata Cache (Consolidated) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Save enriched metadata to localStorage with LRU eviction
 * Moved from Poster.jsx to unify cache logic
 */
export const saveMetadata = (name, data) => {
    if (!name || !data) return
    // Clean name for key consistency
    const key = METADATA_CACHE_PREFIX + name.toLowerCase().trim()
    const entry = { ...data, timestamp: Date.now() }

    try {
        localStorage.setItem(key, JSON.stringify(entry))

        // LRU Eviction: check cache size periodically (10% chance on write)
        if (Math.random() < 0.1) {
            const allKeys = Object.keys(localStorage).filter(k => k.startsWith(METADATA_CACHE_PREFIX))
            if (allKeys.length > METADATA_CACHE_LIMIT) {
                // Find oldest entries
                const entries = allKeys.map(k => {
                    try {
                        const val = JSON.parse(localStorage.getItem(k))
                        return { key: k, timestamp: val?.timestamp || 0 }
                    } catch { return { key: k, timestamp: 0 } }
                })
                entries.sort((a, b) => a.timestamp - b.timestamp)

                // Remove oldest 20%
                const toRemove = Math.ceil(METADATA_CACHE_LIMIT * 0.2)
                entries.slice(0, toRemove).forEach(e => localStorage.removeItem(e.key))
                console.log(`[Metadata] LRU eviction: removed ${toRemove} entries`)
            }
        }
    } catch (e) {
        console.warn('[Metadata] Failed to save:', e)
    }
}

/**
 * Get cached metadata for a title
 * @param {string} name - Movie/show name
 */
export const getMetadata = (name) => {
    if (!name) return null
    const key = METADATA_CACHE_PREFIX + name.toLowerCase().trim()
    try {
        const cached = localStorage.getItem(key)
        if (cached) {
            return JSON.parse(cached)
        }
    } catch { }
    return null
}

/**
 * Resolve metadata by name (Fetch + Cache + Normalization)
 * "Inversion of Control" for Poster.jsx
 * @param {string} name - Raw title from torrent
 * @returns {Promise<Object|null>}
 */
export const resolveMetadata = async (name) => {
    if (!name) return null

    // 1. Check cache first
    const cleanName = name.replace(/[\._]/g, ' ').trim()
    const cached = getMetadata(cleanName)
    if (cached) return cached

    // 2. Fetch using Unified Client (Cascading)
    try {
        const query = encodeURIComponent(cleanName)
        const response = await tmdbClient(`/search/multi?query=${query}`, {
            searchQuery: cleanName // Enable Kinopoisk fallback
        })

        const result = response.results?.find(r => r.poster_path || r._kp_data?.posterUrlPreview)

        if (result) {
            // 3. Normalize & Enrich
            const isKp = response.source === 'kinopoisk'
            const posterPath = result.poster_path || result._kp_data?.posterUrlPreview
            const backdropPath = result.backdrop_path

            // Generate full URLs using resilience logic
            const posterUrl = isKp
                ? `https://wsrv.nl/?url=${encodeURIComponent(posterPath)}&output=webp`
                : getImageUrl(posterPath, 'w500')

            const backdropUrl = !isKp && backdropPath
                ? getImageUrl(backdropPath, 'w1280')
                : null

            const metadata = {
                poster: posterUrl,
                backdrop: backdropUrl,
                overview: result.overview || null,
                rating: result.vote_average || null,
                year: (result.release_date || result.first_air_date || '').substring(0, 4) || null,
                title: result.title || result.name || cleanName,
                source: response.source,
                id: result.id
            }

            // 4. Save to cache
            saveMetadata(cleanName, metadata)
            return metadata
        }
    } catch (err) {
        console.warn('[metadata] Resolve failed:', err)
    }

    return null
}

// ‚îÄ‚îÄ‚îÄ Fetch Strategies ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Strategy 1: Custom Cloudflare Worker
 */
const getSeparator = (url) => url.includes('?') ? '&' : '?'

/**
 * Strategy 1: Custom Cloudflare Worker
 */
async function tryCustomWorker(endpoint) {
    if (!CUSTOM_PROXY) return null

    try {
        // Worker format: /search/multi?... (Worker adds /3 prefix)
        const separator = getSeparator(endpoint)
        const url = `${CUSTOM_PROXY}${endpoint}${separator}api_key=${TMDB_API_KEY}&language=ru-RU`
        console.log('[TMDB] Trying Custom Worker...')

        const res = await fetch(url, { signal: timeoutSignal(5000) })
        // ... (rest same)
    } catch (e) {
        // ...
    }
    return null
}
// Note: I will apply this pattern to all functions.

/**
 * Strategy 2: Lampa Proxy (apn-latest.onrender.com)
 */
async function tryLampaProxy(endpoint) {
    try {
        const separator = getSeparator(endpoint)
        const targetUrl = `https://api.themoviedb.org/3${endpoint}${separator}api_key=${TMDB_API_KEY}&language=ru-RU`
        const url = `${LAMPA_PROXY}/${targetUrl}`
        console.log('[TMDB] Trying Lampa Proxy...')

        const res = await fetch(url, { signal: timeoutSignal(8000) })
        if (res.ok) {
            const data = await res.json()
            console.log('[TMDB] ‚úÖ Lampa Proxy success')
            return { ...data, source: 'tmdb', method: 'lampa_proxy' }
        }
    } catch (e) {
        console.warn('[TMDB] Lampa Proxy failed:', e.message)
    }
    return null
}

/**
 * Strategy 2b (NEW): Self-Hosted Unified Proxy (Lampa Pattern v4.0)
 * Uses /api/proxy endpoint on our own server (which uses DoH)
 */
async function tryServerProxy(endpoint) {
    try {
        const separator = getSeparator(endpoint)
        const targetUrl = `https://api.themoviedb.org/3${endpoint}${separator}api_key=${TMDB_API_KEY}&language=ru-RU`
        // Use absolute URL for the proxy
        const apiBase = getApiBase()
        const proxyUrl = `${apiBase}/api/proxy?url=${encodeURIComponent(targetUrl)}`
        console.log('[TMDB] Trying Server Proxy:', proxyUrl)

        const res = await fetch(proxyUrl, { signal: timeoutSignal(8000) })
        if (res.ok) {
            const data = await res.json()
            console.log('[TMDB] ‚úÖ Server Proxy success')
            return { ...data, source: 'tmdb', method: 'server_proxy' }
        }
    } catch (e) {
        console.warn('[TMDB] Server Proxy failed:', e.message)
    }
    return null
}

/**
 * Strategy 3: CapacitorHttp with Client-Side DoH
 * Only works on native Android platform
 */
async function tryCapacitorWithDoH(endpoint) {
    if (!Capacitor.isNativePlatform()) return null

    try {
        const hostname = 'api.themoviedb.org'
        const ip = await resolveClientIP(hostname)
        const separator = getSeparator(endpoint)

        let targetUrl
        let headers = {}

        if (ip) {
            // DoH resolved ‚Äî use IP directly with Host header
            targetUrl = `https://${ip}/3${endpoint}${separator}api_key=${TMDB_API_KEY}&language=ru-RU`
            headers = { 'Host': hostname }
            console.log('[TMDB] Trying CapacitorHttp + DoH...')
        } else {
            // Fallback to direct (might work with VPN)
            targetUrl = `https://${hostname}/3${endpoint}${separator}api_key=${TMDB_API_KEY}&language=ru-RU`
            console.log('[TMDB] Trying CapacitorHttp direct...')
        }

        const response = await CapacitorHttp.get({
            url: targetUrl,
            headers,
            connectTimeout: 5000,
            readTimeout: 5000
        })

        if (response.data) {
            console.log('[TMDB] ‚úÖ CapacitorHttp success')
            return { ...response.data, source: 'tmdb', method: ip ? 'capacitor_doh' : 'capacitor_direct' }
        }
    } catch (e) {
        console.warn('[TMDB] CapacitorHttp failed:', e.message)
    }
    return null
}

/**
 * Strategy 4: corsproxy.io (browser fallback)
 */
async function tryCorsProxy(endpoint) {
    try {
        const separator = getSeparator(endpoint)
        const targetUrl = `https://api.themoviedb.org/3${endpoint}${separator}api_key=${TMDB_API_KEY}&language=ru-RU`
        const url = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`
        console.log('[TMDB] Trying corsproxy.io...')

        const res = await fetch(url, { signal: timeoutSignal(6000) })
        if (res.ok) {
            const data = await res.json()
            console.log('[TMDB] ‚úÖ corsproxy.io success')
            return { ...data, source: 'tmdb', method: 'corsproxy' }
        }
    } catch (e) {
        console.warn('[TMDB] corsproxy.io failed:', e.message)
    }
    return null
}

/**
 * Strategy 5: Kinopoisk API (alternative data source)
 */
async function tryKinopoisk(query) {
    if (!KP_API_KEY || !query) return null

    try {
        const url = `${KP_PROXY}/https://kinopoiskapiunofficial.tech/api/v2.1/films/search-by-keyword?keyword=${encodeURIComponent(query)}`
        console.log('[TMDB] Trying Kinopoisk fallback...')

        const res = await fetch(url, {
            headers: { 'X-API-KEY': KP_API_KEY },
            signal: timeoutSignal(6000)
        })

        if (res.ok) {
            const data = await res.json()
            // Map KP response to TMDB-like format
            const results = (data.films || []).map(film => ({
                id: film.filmId,
                title: film.nameRu || film.nameEn,
                name: film.nameRu || film.nameEn,
                original_title: film.nameEn,
                poster_path: film.posterUrlPreview,
                backdrop_path: null,
                overview: film.description || '',
                vote_average: film.rating || film.ratingKinopoisk,
                release_date: film.year ? `${film.year}-01-01` : null,
                first_air_date: film.year ? `${film.year}-01-01` : null,
                media_type: film.type === 'TV_SERIES' ? 'tv' : 'movie',
                genre_ids: [], // KP doesn't provide genre IDs in search
                _kp_data: film // Keep original for metadata
            }))

            console.log('[TMDB] ‚úÖ Kinopoisk success')
            return { results, source: 'kinopoisk', method: 'kinopoisk' }
        }
    } catch (e) {
        console.warn('[TMDB] Kinopoisk failed:', e.message)
    }
    return null
}

// ‚îÄ‚îÄ‚îÄ Main Client Function ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Fetch from TMDB with automatic fallback cascade
 * 
 * @param {string} endpoint - TMDB API endpoint (e.g., '/search/multi?query=...')
 * @param {Object} options - Additional options
 * @param {boolean} options.useCache - Enable caching (default: true)
 * @param {number} options.cacheTTL - Cache TTL in ms (default: 5 min)
 * @param {string} options.searchQuery - Query for Kinopoisk fallback
 * @returns {Promise<{results: Array, source: string, method: string}>}
 */
export async function tmdbClient(endpoint, options = {}) {
    const {
        useCache = true,
        cacheTTL = CACHE_TTL,
        searchQuery = null
    } = options

    // Check cache first
    if (useCache) {
        const cached = getCached(endpoint)
        if (cached) {
            console.log('[TMDB] Cache hit for:', endpoint.slice(0, 50))
            return cached
        }
    }

    // Helper to check if response is valid (works for search, credits, videos)
    const isValidResponse = (r) => r && (
        r.results?.length || // search, trending, videos
        r.cast?.length ||    // credits (cast)
        r.crew?.length ||    // credits (crew)
        r.id                 // single item details
    )

    // Try all strategies in order
    let result = null

    result = await tryCustomWorker(endpoint)
    if (isValidResponse(result)) {
        if (useCache) setCache(endpoint, result, cacheTTL)
        return result
    }

    result = await tryLampaProxy(endpoint)
    if (isValidResponse(result)) {
        if (useCache) setCache(endpoint, result, cacheTTL)
        return result
    }

    result = await tryServerProxy(endpoint)
    if (isValidResponse(result)) {
        if (useCache) setCache(endpoint, result, cacheTTL)
        return result
    }

    result = await tryCapacitorWithDoH(endpoint)
    if (isValidResponse(result)) {
        if (useCache) setCache(endpoint, result, cacheTTL)
        return result
    }

    result = await tryCorsProxy(endpoint)
    if (isValidResponse(result)) {
        if (useCache) setCache(endpoint, result, cacheTTL)
        return result
    }

    // Kinopoisk fallback (only for search queries)
    if (searchQuery) {
        result = await tryKinopoisk(searchQuery)
        if (isValidResponse(result)) {
            if (useCache) setCache(endpoint, result, cacheTTL)
            return result
        }
    }

    console.warn('[TMDB] All strategies failed for:', endpoint)
    return { results: [], source: 'none', method: 'failed' }
}

// ‚îÄ‚îÄ‚îÄ Convenience Methods ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Search for movies/TV shows
 */
export async function searchMulti(query) {
    const endpoint = `/search/multi?query=${encodeURIComponent(query)}`
    return tmdbClient(endpoint, { searchQuery: query })
}

/**
 * Get trending content
 */
export async function getTrending(timeWindow = 'week', page = 1) {
    const endpoint = `/trending/all/${timeWindow}?page=${page}`
    return tmdbClient(endpoint, { cacheTTL: DISCOVERY_CACHE_TTL })
}

/**
 * Get popular movies
 */
export async function getPopularMovies(page = 1) {
    const endpoint = `/movie/popular?page=${page}`
    return tmdbClient(endpoint, { cacheTTL: DISCOVERY_CACHE_TTL })
}

/**
 * Get popular TV shows
 */
export async function getPopularTV(page = 1) {
    const endpoint = `/tv/popular?page=${page}`
    return tmdbClient(endpoint, { cacheTTL: DISCOVERY_CACHE_TTL })
}

/**
 * Get top rated movies
 */
export async function getTopRated(page = 1) {
    const endpoint = `/movie/top_rated?page=${page}`
    return tmdbClient(endpoint, { cacheTTL: DISCOVERY_CACHE_TTL })
}

/**
 * Get movie/TV credits (cast and crew)
 * @param {number} id - TMDB ID
 * @param {string} type - 'movie' or 'tv'
 * @returns {Promise<{cast: Array, crew: Array}>}
 */
export async function getCredits(id, type = 'movie') {
    const endpoint = `/${type}/${id}/credits?`
    try {
        const result = await tmdbClient(endpoint, { cacheTTL: DISCOVERY_CACHE_TTL })
        console.log('[tmdbClient] getCredits result:', result)
        // Credits API returns cast/crew directly, not in results wrapper
        return {
            cast: result.cast || result.results?.cast || [],
            crew: result.crew || result.results?.crew || [],
            source: result.source,
            method: result.method
        }
    } catch (err) {
        console.error('[tmdbClient] getCredits error:', err)
        return { cast: [], crew: [] }
    }
}

/**
 * Get movie/TV videos (trailers, teasers)
 * @param {number} id - TMDB ID
 * @param {string} type - 'movie' or 'tv'
 * @returns {Promise<{results: Array}>}
 */
export async function getVideos(id, type = 'movie') {
    const endpoint = `/${type}/${id}/videos?`
    return tmdbClient(endpoint, { cacheTTL: DISCOVERY_CACHE_TTL })
}

/**
 * Get movie/TV recommendations
 * @param {number} id - TMDB ID
 * @param {string} type - 'movie' or 'tv'
 * @returns {Promise<{results: Array}>}
 */
export async function getRecommendations(id, type = 'movie') {
    const endpoint = `/${type}/${id}/recommendations?`
    return tmdbClient(endpoint, { cacheTTL: DISCOVERY_CACHE_TTL })
}

/**
 * Get full details (including seasons for TV)
 * @param {number} id - TMDB ID
 * @param {string} type - 'movie' or 'tv'
 */
export async function getDetails(id, type = 'movie') {
    const endpoint = `/${type}/${id}?append_to_response=external_ids`
    return tmdbClient(endpoint, { cacheTTL: DISCOVERY_CACHE_TTL })
}

/**
 * Get season details (episodes)
 * @param {number} tvId - TV Show ID
 * @param {number} seasonNumber - Season Number
 */
export async function getSeasonDetails(tvId, seasonNumber) {
    const endpoint = `/tv/${tvId}/season/${seasonNumber}?`
    return tmdbClient(endpoint, { cacheTTL: DISCOVERY_CACHE_TTL })
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª–∏ –ø–µ—Ä—Å–æ–Ω—ã (–±–∏–æ, –¥–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è –∏ —Ç.–¥.)
 */
export async function getPersonDetails(personId) {
    return tmdbClient(`/person/${personId}`, { cacheTTL: DISCOVERY_CACHE_TTL })
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å —Ñ–∏–ª—å–º–æ–≥—Ä–∞—Ñ–∏—é –ø–µ—Ä—Å–æ–Ω—ã (—Ñ–∏–ª—å–º—ã + —Å–µ—Ä–∏–∞–ª—ã)
 * –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –ø–æ–ø—É–ª—è—Ä–Ω–æ—Å—Ç–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
 */
export async function getPersonCredits(personId) {
    const data = await tmdbClient(`/person/${personId}/combined_credits`, { cacheTTL: DISCOVERY_CACHE_TTL })

    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –ø–æ–ø—É–ª—è—Ä–Ω–æ—Å—Ç–∏ (desc) –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø—É—Å—Ç—ã—Ö –ø–æ—Å—Ç–µ—Ä–æ–≤
    if (data.cast) {
        data.cast = data.cast
            .filter(item => item.poster_path) // –£–±–∏—Ä–∞–µ–º –±–µ–∑ –ø–æ—Å—Ç–µ—Ä–æ–≤
            .sort((a, b) => (b.popularity || 0) - (a.popularity || 0))
    }

    return data
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç –ø–æ –∂–∞–Ω—Ä—É
 */
export async function getDiscoverByGenre(genreId, type = 'movie', page = 1) {
    const endpoint = `/discover/${type}?with_genres=${genreId}&page=${page}&sort_by=popularity.desc`
    return tmdbClient(endpoint, { cacheTTL: DISCOVERY_CACHE_TTL })
}

/**
 * Filter results: remove people, items without posters
 */
export function filterDiscoveryResults(results) {
    return results.filter(item =>
        item.media_type !== 'person' &&
        (item.poster_path || item._kp_data?.posterUrlPreview)
    )
}

export default tmdbClient

```

---

## client/tailwind.config.js

```javascript
/** @type {import('tailwindcss').Config} */
export default {
    content: [
        "./index.html",
        "./src/**/*.{js,ts,jsx,tsx}",
    ],
    theme: {
        extend: {},
    },
    plugins: [],
}

```

---

## client/vite.config.js

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': {
        target: 'http://127.0.0.1:3000',
        changeOrigin: true,
      },
      '/stream': {
        target: 'http://127.0.0.1:3000',
        changeOrigin: true,
      },
      '/playlist.m3u': {
        target: 'http://127.0.0.1:3000',
        changeOrigin: true,
      }
    }
  }
})

```

---

## client/vitest.config.js

```javascript
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'

export default defineConfig({
    plugins: [react()],
    test: {
        environment: 'happy-dom',
        globals: true,
        include: ['src/**/*.{test,spec}.{js,jsx,ts,tsx}'],
        coverage: {
            reporter: ['text', 'html'],
            include: ['src/**/*.{js,jsx}'],
            exclude: ['src/main.jsx', 'src/**/*.test.{js,jsx}']
        }
    }
})

```

---

## db.json

```json
{
  "serverStatus": "ok",
  "lastStateChange": 1769250697878,
  "storageFailures": 0,
  "progress": {},
  "seenFiles": {
    "2f4fa04a9dc40762d174ff68e13602dc96ef545d": [
      "The.Wrecking.Crew.2026.x264.WEB-DLRip - New-Team.mkv"
    ],
    "b558880bba805f913c6b9f46accd3747e0369ee7": [
      "The.Wrecking.Crew.2026.1080p.AMZN - New-Team.mkv"
    ],
    "4b5291958b50a8e6b07e0f1f05a0cb0c3eac6132": [
      "–û–ø–∞—Å–Ω—ã–π –¥—É—ç—Ç_2026_WEB-DLRip.avi"
    ],
    "0881b232f28fa8db84f7af74912affd5f8de579d": [
      "The.Wrecking.Crew.2026.x265.WEB-DL.2160p.HDR-DV.mkv"
    ]
  },
  "torrents": [
    {
      "magnet": "magnet:?xt=urn:btih:2f4fa04a9dc40762d174ff68e13602dc96ef545d&dn=rutor.info&tr=udp://opentor.net:6969&tr=http://retracker.local/announce",
      "name": "The.Wrecking.Crew.2026.x264.WEB-DLRip - New-Team.mkv",
      "addedAt": 1769859590797,
      "completed": false
    },
    {
      "magnet": "magnet:?xt=urn:btih:b558880bba805f913c6b9f46accd3747e0369ee7&dn=rutor.info&tr=udp%3a%2f%2fopentor.net%3a6969&tr=http%3a%2f%2fretracker.local%2fannounce",
      "name": "The.Wrecking.Crew.2026.1080p.AMZN - New-Team.mkv",
      "addedAt": 1769859610556,
      "completed": false
    },
    {
      "magnet": "magnet:?xt=urn:btih:4B5291958B50A8E6B07E0F1F05A0CB0C3EAC6132&tr=http%3A%2F%2Fbt3.t-ru.org%2Fann%3Fmagnet",
      "name": "–û–ø–∞—Å–Ω—ã–π –¥—É—ç—Ç_2026_WEB-DLRip.avi",
      "addedAt": 1769859625798,
      "completed": false
    },
    {
      "magnet": "magnet:?xt=urn:btih:0881b232f28fa8db84f7af74912affd5f8de579d&dn=rutor.info&tr=udp%3a%2f%2fopentor.net%3a6969&tr=http%3a%2f%2fretracker.local%2fannounce",
      "name": "The.Wrecking.Crew.2026.x265.WEB-DL.2160p.HDR-DV.mkv",
      "addedAt": 1769859654491,
      "completed": false
    }
  ],
  "autoDownloadSettings": {
    "enabled": false,
    "intervalMinutes": 720
  },
  "autoDownloadRules": [],
  "autoDownloadHistory": []
}
```

---

## docker-compose.synology.yml

```yml
version: '3.8'

services:
  torserve:
    # Use the image built previously or build it here if you transfer the source.
    # Assuming user might build on NAS or pull from a registry. If building on NAS:
    build: .
    image: pwa-torserve:latest
    container_name: torserve
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DOWNLOAD_PATH=/app/downloads
      - DB_PATH=/app/data/db.json
    volumes:
      # Downloads folder (map to your NAS media folder)
      - /volume1/docker/pwa-torserve/downloads:/app/downloads
      # [HOTFIX] Map source code for easy updates without rebuild
      - ./server:/app/server
      # Utils folder (for DoH and other utilities)
      - ./server/utils:/app/server/utils
      # Environment file with API keys
      - ./.env:/app/.env:ro
      # Persistence for DB
      - ./data:/app/data
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"


```

---

## docker-compose.yml

```yml
version: '3.8'

services:
  pwa-torserve:
    build: .
    image: pwa-torserve:latest
    container_name: pwa-torserve
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DOWNLOAD_PATH=/app/downloads
      - DB_PATH=/app/data/db.json
    volumes:
      # Persistent data (database, settings)
      - ./data:/app/data
      # Downloads folder (map to your NAS media folder)
      - /volume1/docker/pwa-torserve/downloads:/app/downloads
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

```

---

## docs/API_SECURITY.md

```markdown
# –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å API –∫–ª—é—á–µ–π

## –ß—Ç–æ –±—ã–ª–æ —Å–¥–µ–ª–∞–Ω–æ (–î–µ–∫–∞–±—Ä—å 2025)
–í —Ü–µ–ª—è—Ö –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –≤—Å–µ API –∫–ª—é—á–∏ (TMDB, Kinopoisk) –±—ã–ª–∏ —É–¥–∞–ª–µ–Ω—ã –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞ –ø—Ä–æ–µ–∫—Ç–∞. –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ –ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –∫–æ–¥ –Ω–∞ GitHub, –Ω–µ –±–æ—è—Å—å —É—Ç–µ—á–∫–∏ –ø–ª–∞—Ç–Ω—ã—Ö –∏–ª–∏ –ª–∏—á–Ω—ã—Ö –∫–ª—é—á–µ–π.

### –¢–µ–∫—É—â–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
1. **–•—Ä–∞–Ω–µ–Ω–∏–µ –∫–ª—é—á–µ–π**: –ö–ª—é—á–∏ —Ö—Ä–∞–Ω—è—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ —Ñ–∞–π–ª–µ `.env` –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞. –≠—Ç–æ—Ç —Ñ–∞–π–ª –¥–æ–±–∞–≤–ª–µ–Ω –≤ `.gitignore` –∏ –Ω–µ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π.
2. **–ö–ª–∏–µ–Ω—Ç (Frontend)**: –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è `VITE_TMDB_API_KEY` –∏ `VITE_KP_API_KEY`.
    - –ü—Ä–∏ —Å–±–æ—Ä–∫–µ –ø—Ä–æ–µ–∫—Ç–∞ (`npm run build`) Vite –ø–æ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Ä–µ–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ `.env` –≤ –∫–æ–¥.
    - –í –∏—Å—Ö–æ–¥–Ω–∏–∫–∞—Ö (`App.jsx`) –∫–ª—é—á–µ–π –Ω–µ—Ç, —Ç–∞–º —Ç–æ–ª—å–∫–æ —Å—Å—ã–ª–∫–∏ `import.meta.env...`.

## –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –Ω–∞ –±—É–¥—É—â–µ–µ

### –ï—Å–ª–∏ –≤—ã –ø–µ—Ä–µ—É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç–µ –ø—Ä–æ–µ–∫—Ç –∏–ª–∏ –º–µ–Ω—è–µ—Ç–µ —Å–µ—Ä–≤–µ—Ä
1. –°–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª `.env` –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞ (–º–æ–∂–Ω–æ —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∏–∑ `.env.example`).
2. –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –∫–ª—é—á–∏:
   ```env
   VITE_TMDB_API_KEY=–≤–∞—à_–∫–ª—é—á
   VITE_KP_API_KEY=–≤–∞—à_–∫–ª—é—á
   ```
3. –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ —Å–µ—Ä–≤–µ—Ä (—á—Ç–æ–±—ã –æ–Ω —É–≤–∏–¥–µ–ª —Ñ–∞–π–ª).

### –ï—Å–ª–∏ –≤—ã –≤–Ω–æ—Å–∏—Ç–µ –ø—Ä–∞–≤–∫–∏ –≤ Frontend (–ø–∞–ø–∫–∞ client)
–¢–∞–∫ –∫–∞–∫ –∫–ª—é—á–∏ "–≤–ø–µ–∫–∞—é—Ç—Å—è" –≤ —Å—Ç–∞—Ç–∏–∫—É –ø—Ä–∏ —Å–±–æ—Ä–∫–µ, –µ—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –æ–±–Ω–æ–≤–∏—Ç—å –∫–æ–¥ –∫–ª–∏–µ–Ω—Ç–∞ –∏–ª–∏ –ø–æ–º–µ–Ω—è–ª–∏ –∫–ª—é—á–∏:
1. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–∞–π–ª `.env` —Å –∫–ª—é—á–∞–º–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.
2. –ó–∞–ø—É—Å—Ç–∏—Ç–µ —Å–±–æ—Ä–∫—É:
   ```bash
   cd client
   npm run build
   ```
   –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Å–æ–∑–¥–∞—Å—Ç –Ω–æ–≤—É—é –≤–µ—Ä—Å–∏—é —Å–∞–π—Ç–∞ –≤ –ø–∞–ø–∫–µ `dist`, —É–∂–µ —Å –≤–∞—à–∏–º–∏ –∫–ª—é—á–∞–º–∏.

```

---

## docs/CLOUDFLARE_WORKER_SETUP.md

```markdown
# üöÄ –ö–∞–∫ —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å —Å–≤–æ–π CORS Proxy –Ω–∞ Cloudflare Workers

–≠—Ç–æ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π –ø—Ä–æ–∫—Å–∏ –¥–ª—è –æ–±—Ö–æ–¥–∞ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫ TMDB –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–º.

## –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞
- ‚úÖ **–ë–µ—Å–ø–ª–∞—Ç–Ω–æ** ‚Äî 100,000 –∑–∞–ø—Ä–æ—Å–æ–≤/–¥–µ–Ω—å
- ‚úÖ **–í–∞—à –ª–∏—á–Ω—ã–π** ‚Äî –Ω–µ –∑–∞–≤–∏—Å–∏—Ç–µ –æ—Ç —á—É–∂–∏—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
- ‚úÖ **–ë—ã—Å—Ç—Ä—ã–π** ‚Äî –≥–ª–æ–±–∞–ª—å–Ω–∞—è CDN Cloudflare
- ‚úÖ **–ù–∞–¥—ë–∂–Ω—ã–π** ‚Äî –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä—É—é—Ç

## –®–∞–≥–∏

### 1. –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
1. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –Ω–∞ [dash.cloudflare.com](https://dash.cloudflare.com)
2. –°–æ–∑–¥–∞–π—Ç–µ –∞–∫–∫–∞—É–Ω—Ç (–±–µ—Å–ø–ª–∞—Ç–Ω–æ)

### 2. –°–æ–∑–¥–∞–Ω–∏–µ Worker
1. –í –º–µ–Ω—é —Å–ª–µ–≤–∞: **Workers & Pages**
2. –ù–∞–∂–º–∏—Ç–µ **Create application** ‚Üí **Create Worker**
3. –ò–º—è: `tmdb-proxy` (–∏–ª–∏ –ª—é–±–æ–µ –¥—Ä—É–≥–æ–µ)
4. –ù–∞–∂–º–∏—Ç–µ **Deploy**

### 3. –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞
1. –ù–∞–∂–º–∏—Ç–µ **Edit code**
2. –ó–∞–º–µ–Ω–∏—Ç–µ –≤–µ—Å—å –∫–æ–¥ –Ω–∞ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞ `cloudflare_worker.js`
3. –ù–∞–∂–º–∏—Ç–µ **Save and Deploy**

### 4. –ü–æ–ª—É—á–µ–Ω–∏–µ URL
–ü–æ—Å–ª–µ –¥–µ–ø–ª–æ—è –≤—ã –ø–æ–ª—É—á–∏—Ç–µ URL –≤–∏–¥–∞:
```
https://tmdb-proxy.YOUR-USERNAME.workers.dev
```

### 5. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ PWA-TorServe
–í –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏: **Settings ‚Üí Advanced ‚Üí TMDB API Proxy**

–í–≤–µ–¥–∏—Ç–µ:
```
https://tmdb-proxy.YOUR-USERNAME.workers.dev/api.themoviedb.org/3
```

## –§–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–æ–≤
Worker –ø—Ä–∏–Ω–∏–º–∞–µ—Ç URL –≤ —Ñ–æ—Ä–º–∞—Ç–µ:
```
https://YOUR-WORKER.workers.dev/https://api.themoviedb.org/3/search/multi?api_key=...
```

## –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞: Deno Deploy
–ï—Å–ª–∏ –Ω–µ —Ö–æ—Ç–∏—Ç–µ Cloudflare ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ [Deno Deploy](https://deno.com/deploy):
1. –°–æ–∑–¥–∞–π—Ç–µ –ø—Ä–æ–µ–∫—Ç
2. –ó–∞–≥—Ä—É–∑–∏—Ç–µ `deno_apn.js`
3. –ü–æ–ª—É—á–∏—Ç–µ URL –≤–∏–¥–∞ `https://your-app.deno.dev`

---

## –ì–æ—Ç–æ–≤—ã–µ –ø—Ä–æ–∫—Å–∏ (–µ—Å–ª–∏ –ª–µ–Ω—å —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å)
- `https://apn-latest.onrender.com/` ‚Äî —É–∂–µ –≤—Å—Ç—Ä–æ–µ–Ω –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
- `https://cors.kp556.workers.dev:8443/` ‚Äî –¥–ª—è –ö–∏–Ω–æ–ø–æ–∏—Å–∫–∞


```

---

## docs/LAMPAC_FULL_PROJECT_CODE.md

```markdown
# Project: Lampac

## File: install.sh
```
#!/usr/bin/env bash
DEST="/home/lampac"

# Become root
# sudo su -
apt-get update
apt-get install -y unzip curl libicu-dev
apt-get install -y libnss3-dev libgtk-3-dev libxss-dev libasound2
apt-get install -y libgdk-pixbuf2.0-dev
apt-get install -y libnspr4
apt-get install -y libatk1.0-0
apt-get install -y xvfb
apt-get install -y coreutils

# chromium
apt-get install -y libnss3 libatk-bridge2.0-0 libdrm-dev libxkbcommon-dev libxcomposite-dev libxdamage-dev libxrandr-dev libgbm-dev libasound2-dev libpangocairo-1.0-0 libpango-1.0-0 libcairo2-dev

# Install .NET
if ! curl -L -k -o dotnet-install.sh https://dot.net/v1/dotnet-install.sh; then
   echo "Failed to download dotnet-install.sh. Exiting."
   exit 1
fi

chmod 755 dotnet-install.sh
./dotnet-install.sh --channel 9.0 --runtime aspnetcore --install-dir /usr/share/dotnet
ln -s /usr/share/dotnet/dotnet /usr/bin/dotnet

# Download zip
mkdir $DEST -p 
cd $DEST
if ! curl -L -k -o publish.zip https://github.com/immisterio/Lampac/releases/latest/download/publish.zip; then
   echo "Failed to download publish.zip. Exiting."
   exit 1
fi

unzip -o publish.zip
rm -f publish.zip

# automatic updates
curl -k -s https://api.github.com/repos/immisterio/Lampac/releases/latest | grep tag_name | sed s/[^0-9]//g > $DEST/data/vers.txt
curl -k -s https://raw.githubusercontent.com/immisterio/lampac/main/update.sh > $DEST/update.sh
chmod 755 $DEST/update.sh
#crontab -l | { cat; echo "$(shuf -i 10-55 -n 1) * * * * /bin/bash $DEST/update.sh"; } | crontab -

CRON_JOB="$(shuf -i 10-55 -n 1) * * * * /bin/bash $DEST/update.sh"
(crontab -l | grep -vF "/bin/bash $DEST/update.sh"; echo "$CRON_JOB") | crontab -

# Create service
echo ""
echo "Install service to /etc/systemd/system/lampac.service ..."
touch /etc/systemd/system/lampac.service && chmod 664 /etc/systemd/system/lampac.service
cat <<EOF > /etc/systemd/system/lampac.service
[Unit]
Description=Lampac
Wants=network.target
After=network.target
[Service]
WorkingDirectory=$DEST
ExecStart=/usr/bin/dotnet Lampac.dll
#ExecReload=/bin/kill -s HUP $MAINPID
#ExecStop=/bin/kill -s QUIT $MAINPID
Restart=always
LimitNOFILE=32000
[Install]
WantedBy=multi-user.target
EOF

if [ ! -f "$DEST/init.conf" ]; then
random_port=$(shuf -i 9000-12999 -n 1)
cat <<EOF > $DEST/init.conf
"listen": {
  "port": $random_port
}
EOF
fi

# Enable service
systemctl daemon-reload
systemctl enable lampac

# update minor
echo -n "1" > $DEST/data/vers-minor.txt
/bin/bash $DEST/update.sh
cd $DEST

# done
systemctl start lampac

# iptables drop
cat <<EOF > iptables-drop.sh
#!/bin/sh
echo "Stopping firewall and allowing everyone..."
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT
EOF

get_external_ip() {
   local ip
   ip=$(curl -s --connect-timeout 5 https://api.ipify.org 2>/dev/null)
   if [ -z "$ip" ]; then
      ip=$(curl -s --connect-timeout 5 https://icanhazip.com 2>/dev/null)
   fi
   if [ -z "$ip" ]; then
      ip=$(curl -s --connect-timeout 5 https://ifconfig.me 2>/dev/null)
   fi
   echo "${ip:-IP}"
}

# Note
echo ""
echo "################################################################"
echo ""
echo "Have fun!"
echo ""
echo "http://$(get_external_ip):$random_port"
echo ""
echo "Please check/edit $DEST/init.conf params and configure it"
echo ""
echo "Then [re]start it as systemctl [re]start lampac"
echo ""
echo "Clear iptables if port $random_port is not available"
echo "bash $DEST/iptables-drop.sh"
echo ""

```

## File: README.md
```
# Telegram –≥—Ä—É–ø–ø–∞
https://t.me/+TIXtgvGBBOc3ZTUy

# AI –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
[![DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/immisterio/Lampac)

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞ linux
—Å–ø–∞—Å–∏–±–æ @nikk, @Denis
```bash
curl -L -k -s https://lampac.sh | bash
```
* –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è: 1 CPU, 1GB RAM, 2GB HDD
* –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è: 1 CPU, 2GB RAM, 5GB SSD
* –ü–æ—Ä—Ç –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è —Ä–∞–Ω–¥–æ–º–Ω–æ –∏ –≤—ã–≤–æ–¥–∏—Ç—Å—è –≤ –∫–æ–Ω—Ü–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å–∫—Ä–∏–ø—Ç–∞
* –ò–∑–º–µ–Ω–∏—Ç—å –∏–ª–∏ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø–æ—Ä—Ç –º–æ–∂–Ω–æ –≤ init.conf - 
```grep "port" /home/lampac/init.conf```

# –î–æ–º–∞—à–Ω—è—è (–æ–±–ª–µ–≥—á–µ–Ω–Ω–∞—è) - linux
```bash
curl -L -k -s https://lampac.sh/home | bash
```
* –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è: 1 CPU, 500Mb RAM, 1GB HDD
* –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è: 1 CPU, 1GB RAM, 1GB SSD
* DLNA/Chromium/Firefox –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –æ—Ç–∫–ª—é—á–µ–Ω, –≤–∫–ª—é—á–∞–µ—Ç—Å—è –≤ init.conf
* TorrServer –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –æ—Ç–∫–ª—é—á–µ–Ω, –≤–∫–ª—é—á–∞–µ—Ç—Å—è –≤ module/manifest.json

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞ Windows
1. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å ".NET Core 9 (SDK Installer)" https://github.com/dotnet/core/blob/main/release-notes/9.0/9.0.9/9.0.110.md
2. –†–∞—Å–ø–∞–∫–æ–≤–∞—Ç—å https://github.com/immisterio/Lampac/releases/latest/download/publish.zip
3. –ó–∞–ø—É—Å—Ç–∏—Ç—å Lampac.exe

# –ó–∞–ø—É—Å–∫ –≤ Docker
```bash
docker run -d -p 9118:9118 --restart always --name lampac immisterio/lampac
```
__tags__: latest (linux/amd64) / arm32 (linux/arm/v7) / arm64 (linux/arm64/v8)

# –ó–∞–ø—É—Å–∫ –≤ Android
1. Termux - https://github.com/immisterio/Lampac/blob/main/Termux/README.md
2. BWA - https://bwa.to

# –¢–µ—Å—Ç–∏—Ä—É–µ–º—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
* Debian 11/12 x64
* Windows 10 x64
* Raspberry arm64 (Debian 11)

# –ê–¥–º–∏–Ω–∫–∞
ip:9118/admin

# –ü–ª–∞–≥–∏–Ω—ã –¥–ª—è Lampa
1. –í—Å–µ –ø–ª–∞–≥–∏–Ω—ã —Å—Ä–∞–∑—É - http://IP:9118/on.js
2. –æ–Ω–ª–∞–π–Ω   - http://IP:9118/online.js
3. xxx      - http://IP:9118/sisi.js
4. DLNA     - http://IP:9118/dlna.js
5. Tracks   - http://IP:9118/tracks.js
6. Backup   - http://IP:9118/backup.js
7. –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è   - http://IP:9118/sync.js
8. TorrServer      - http://IP:9118/ts.js
9. –ü–∞—Ä—Å–µ—Ä Jackett  - IP:9118

# –ü–ª–∞–≥–∏–Ω—ã –¥–ª—è Lampa Lite
1. –æ–Ω–ª–∞–π–Ω/jackett  - http://IP:9118/lite.js
2. xxx     - http://IP:9118/sisi.js

# –û–±—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
1. –û—Ç–∫–ª—é—á–∏—Ç—å TorrServer/DNLA/Jackett/etc –º–æ–∂–Ω–æ –≤ module/manifest.json
2. –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Jackett –≤ module/JacRed.conf (–ø—Ä–∏–º–µ—Ä JacRed.example.conf)
3. –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤ init.conf (–ø—Ä–∏–º–µ—Ä example.conf)

# –ò—Å—Ç–æ—á–Ω–∏–∫–∏ –æ–Ω–ª–∞–π–Ω
Filmix, KinoPub, Alloha, Rezka, GetsTV, iptv.online, Kinobase, Zetflix, Collaps, Lumex, VDBmovies, VideoDB, Vibix, Videoseed, VeoVeo, HDVB, Kodik, Ashdi (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π), Eneyida (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π), KinoUKR (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π), FanCDN, Kinotochka, CDNmovies, Redheadsound, VoKino, Rutube, VK –í–∏–¥–µ–æ, Plvideo, Anilibria, AniLiberty, AniMedia, AnimeLib, MoonAnime (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π), Animevost, Animebesst, AnimeGo, HydraFlix (ENG), VidSrc (ENG), MovPI (ENG), Videasy (ENG), 2Embed (ENG), VidLink (ENG), AutoEmbed (ENG), SmashyStream (ENG), PlayEmbed (ENG), RgShows (ENG)

# –ò—Å—Ç–æ—á–Ω–∏–∫–∏ 18+
PornHub, PornHubPremium, Bongacams, Chaturbate, Cam4, Ebalovo, Eporner, HQporner, Porntrex, Spankbang, Xhamster, Xnxx, Xvideos, Lenporno, Porno365, Vtrahe, RUSporno, ProstoPorno, PornOne, Brazzrus, FilmAdult, Sosushka, Youjizz, NoodleMagazine, Veporn, XXXperevod, Huyamba, Pornk, PornoAkt, Porn4days, Beeg, Porndig, 24video, yaeby, trahkino, sex-studentki, hochu.tv, oxax.tv, Rusvideos, Porno666, Pornobolt, JopaOnline, Ebun, Pornobriz, 24rolika, SemBatsa, Lenkino, Ebasos, Vporno, BigBoss, GayPornTube

# –¢–æ—Ä—Ä–µ–Ω—Ç—ã
Kinozal, NNM-Club, Rutor, Rutracker, Megapeer, Torrentby, Bitru, Toloka (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π), BigFanGroup, Selezen, LostFilm, Anilibria, Animelayer, Anifilm

# –ò—Å—Ç–æ—á–Ω–∏–∫–∏ —Å API –¥–ª—è –ø–æ—Ä—Ç–∞–ª–æ–≤
* Filmix, Alloha, Lumex (VideoCDN), Kodik

# –ü—Ä–∏–≤—è–∑–∫–∞ PRO –∞–∫–∫–∞—É–Ω—Ç–æ–≤
* Filmix - http://IP:9118/lite/filmixpro
* KinoPub - http://IP:9118/lite/kinopubpro
* VoKino - http://IP:9118/lite/vokinotk
* HDRezka - http://IP:9118/lite/rhs/bind
* GetsTV - http://IP:9118/lite/getstv/bind
* iptv.online - http://IP:9118/lite/iptvonline/bind

# Remote Control Hub
–î–ª—è –±–∞–ª–∞–Ω—Å–µ—Ä–æ–≤ –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã –Ω–∞ VPS –Ω–æ –¥–æ—Å—Ç—É–ø–Ω—ã –≤ –≤–∞—à–µ–π —Å–µ—Ç–∏, –º–æ–∂–Ω–æ –≤–∫–ª—é—á–∏—Ç—å rhub –∏ –ø–∞—Ä—Å–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Å–∞–º–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ android/smart
```json
"Ashdi": {
  "rhub": true
},
"BongaCams": {
  "rhub": true
}
```

# –ü–ª–∞–≥–∏–Ω DLNA.js
* –ü—Ä–æ—Å–º–æ—Ç—Ä –º–µ–¥–∏–∞ —Ñ–∞–π–ª–æ–≤ —Å –ø–∞–ø–∫–∏ dlna
* –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —É–¥–∞–ª—è—Ç—å –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω—ã–µ –ø–∞–ø–∫–∏/—Ñ–∞–π–ª—ã
* –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤ –≤ –ø–∞–ø–∫—É dlna

–ó–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É "OK" –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–º —Ç–æ—Ä—Ä–µ–Ω—Ç–µ/–ø–∞–ø–∫–µ/—Ñ–∞–π–ª–µ –¥–ª—è –≤—ã–∑–æ–≤–∞ —Å–ø–∏—Å–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π

# –ü–ª–∞–≥–∏–Ω Sync.js
–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –º–µ–∂–¥—É —Ä–∞–∑–Ω—ã–º–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º–∏
* –î–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤—Å–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –≤ cub.red –ø–æ–¥ –æ–¥–Ω–∏–º –∞–∫–∫–∞—É–Ω—Ç–æ–º, –ª–∏–±–æ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö –≤–º–µ—Å—Ç–æ –ø–ª–∞–≥–∏–Ω–∞ IP:9118/sync.js, –¥–æ–ª–∂–µ–Ω –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è IP:9118/sync/js/{uid}, –≥–¥–µ {uid} —ç—Ç–æ –ª—é–±—ã–µ —Å–∏–º–≤–æ–ª—ã, –ª–∏–±–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –≤ accsdb, –Ω–∞–ø—Ä–∏–º–µ—Ä IP:9118/sync/js/myhome
* email –∏–ª–∏ {uid} –¥–æ–ª–∂–µ–Ω —Å–æ–≤–ø–∞–¥–∞—Ç—å –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö –∫–æ—Ç–æ—Ä—ã–µ –≤—ã —Ö–æ—Ç–∏—Ç–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–æ–≤–∞—Ç—å –º–µ–∂–¥—É —Å–æ–±–æ–π 
* –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∫—É–±–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç–∫–ª—é—á–µ–Ω–∞

# –ü–ª–∞–≥–∏–Ω Tracks.js
–ó–∞–º–µ–Ω—è–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ –∞—É–¥–∏–æ–¥–æ—Ä–æ–∂–µ–∫ –∏ —Å—É–±—Ç–∏—Ç—Ä–æ–≤ –≤ –ø–ª–µ–µ—Ä–µ

–ê–≤—Ç–æ—Ä: @aabytt

1. –î–æ–±–∞–≤–∏—Ç—å –ø–ª–∞–≥–∏–Ω "http://IP:9118/tracks.js" 
2. –í init.conf –∑–∞–º–µ–Ω–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ "ffprobe.os" –Ω–∞ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ "win", "linux"

# –ü–ª–∞–≥–∏–Ω TmdbProxy.js
–ü—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Å—Ç–µ—Ä–æ–≤ –¥–ª—è —Å–∞–π—Ç–∞ TMDB

1. –î–æ–±–∞–≤–∏—Ç—å –ø–ª–∞–≥–∏–Ω "http://IP:9118/tmdbproxy.js" 
2. –í –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö TMDB –≤–∫–ª—é—á–∏—Ç—å –ø—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ

# –ü–ª–∞–≥–∏–Ω Catalog.js
–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –∫–∞—Ç–∞–ª–æ–≥–∞ cub –∏ tmdb 

1. –î–æ–±–∞–≤–∏—Ç—å –ø–ª–∞–≥–∏–Ω "http://IP:9118/catalog.js" 
2. –í—ã–±—Ä–∞—Ç—å –∫–∞—Ç–∞–ª–æ–≥ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ª–∞–º–ø—ã "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ - –û—Å—Ç–∞–ª—å–Ω–æ–µ - –û—Å–Ω–æ–≤–Ω–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫"

# –î–æ—Å—Ç—É–ø –∫ –¥–æ–º–µ–Ω–∞–º .onion
1. –ó–∞–ø—É—Å—Ç–∏—Ç—å tor –Ω–∞ –ø–æ—Ä—Ç—É 9050
2. –í init.conf —É–∫–∞–∑–∞—Ç—å .onion –¥–æ–º–µ–Ω –≤ host

# Media Station X
1. Settings -> Start Parameter -> Setup
2. Enter current ip address and port "IP:9118"

–£–±—Ä–∞—Ç—å/–î–æ–±–∞–≤–∏—Ç—å –∞–¥—Ä–µ—Å–∞ –º–æ–∂–Ω–æ –≤ msx.json

# –í–∏–¥–∂–µ—Ç—ã
1. –î–ª—è Samsung "IP:9118/samsung.wgt"

# –†–∞–±–æ—Ç–∞ —Å –±–∞–∑–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö
* Microsoft.EntityFrameworkCore 9.0.8 - MS SQL Server, SQLite
* Npgsql 9.0.3 - PostgreSQL
* Pomelo.EntityFrameworkCore.MySql 9.0.0 - MariaDB, MySQL
* MongoDB.Driver 3.4.3 - MongoDB
* StackExchange.Redis 2.9.11 - Redis

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã init.conf
* checkOnlineSearch - –î–µ–ª–∞—Ç—å –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ —Å–∫—Ä—ã–≤–∞—è –±–∞–ª–∞–Ω—Å–µ—Ä—ã –±–µ–∑ –æ—Ç–≤–µ—Ç–∞
* multiaccess - –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–µ—à–∞ –≤ –æ–Ω–ª–∞–π–Ω —Å —É—á–µ—Ç–æ–º –º–Ω–æ–≥–æ–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
* accsdb - –î–æ—Å—Ç—É–ø –∫ API —á–µ—Ä–µ–∑ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é (–¥–ª—è jackett –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è apikey)
* useproxy - –ü–∞—Ä—Å–∏—Ç –∏—Å—Ç–æ—á–Ω–∏–∫ —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏ —É–∫–∞–∑–∞–Ω–Ω—ã–µ –≤ "proxy"
* streamproxy - –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç –≤–∏–¥–µ–æ —á–µ—Ä–µ–∑ "http://IP:9118/proxy/{uri}" 
* localip - –ó–∞–º–µ–Ω–∏—Ç—å –Ω–∞ "false" –µ—Å–ª–∏ —Å–∫—Ä–∏–ø—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π —Å–µ—Ç–∏
* findkp - –ö–∞—Ç–∞–ª–æ–≥ –¥–ª—è –ø–æ–∏—Å–∫ kinopoisk_id (alloha|tabus|vsdn)
* corseu - –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–æ–∫—Å–∏ cloudflare

# –ü—Ä–∏–º–µ—Ä init.conf
* –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, –∞ —Ç–∞–∫ –∂–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å–º–æ—Ç—Ä–µ—Ç—å –≤ current.conf –∏ example.conf 
* –í init.conf –Ω—É–∂–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã, –∫–æ—Ç–æ—Ä—ã–µ —Ö–æ—Ç–∏—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å
* –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å init.conf –º–æ–∂–Ω–æ —Ç–∞–∫ –∂–µ —á–µ—Ä–µ–∑ ip:9118/admin

```
{
  "listenport": 9120, // –∏–∑–º–µ–Ω–∏–ª–∏ –ø–æ—Ä—Ç
  "dlna": {
    "downloadSpeed": 25000000 // –æ–≥—Ä–∞–Ω–∏—á–∏–ª–∏ —Å–∫–æ—Ä–æ—Å—Ç—å –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ 200 Mbit/s
  },
  "Rezka": {
    "streamproxy": true // –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ –≤–∏–¥–µ–æ–ø–æ—Ç–æ–∫ —á–µ—Ä–µ–∑ "http://IP:9118/proxy/{uri}" 
  },
  "Zetflix": {
    "displayname": "Zetflix - 1080p", // –∏–∑–º–µ–Ω–∏–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ
    "geostreamproxy": ["UA"], // –ø–æ—Ç–æ–∫ –¥–ª—è UA –±—É–¥–µ—Ç –∏–¥—Ç–∏ —á–µ—Ä–µ–∑ "http://IP:9118/proxy/{uri}" 
    "apn": "http://apn.cfhttp.top" // –∑–∞–º–µ–Ω—è–µ–º –ø—Ä–æ–∫—Å–∏ "http://IP:9118/proxy/{uri}" –Ω–∞ "http://apn.cfhttp.top/{uri}"
  },
  "Kodik": {
    "useproxy": true, // –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–æ–∫—Å–∏
    "proxy": {        // –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å 91.1.1.1 –∏ 92.2.2.2
      "list": [
        "socks5://91.1.1.1:5481", // socks5
        "91.2.2.2:5481" // http
      ]
    }
  },
  "Ashdi": {
    "useproxy": true // –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–æ–∫—Å–∏ 93.3.3.3
  },
  "Filmix": {
    "token": "protoken" // –¥–æ–±–∞–≤–∏–ª–∏ —Ç–æ–∫–µ–Ω –æ—Ç PRO –∞–∫–∫–∞—É–Ω—Ç–∞
  },
  "PornHub": {
    "enable": false // –æ—Ç–∫–ª—é—á–∏–ª–∏ PornHub
  },
  "proxy": {
    "list": [
      "93.3.3.3:5481"
    ]
  },
  "globalproxy": [
    {
      "pattern": "\\.onion",  // –∑–∞–ø—Ä–æ—Å—ã –Ω–∞ –¥–æ–º–µ–Ω—ã .onion –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏
      "list": [
        "socks5://127.0.0.1:9050" // –ø—Ä–æ–∫—Å–∏ —Å–µ—Ä–≤–µ—Ä tor
      ]
    }
  ],
  "overrideResponse": [ // –ó–∞–º–µ–Ω–∏–ª–∏ –æ—Ç–≤–µ—Ç –Ω–∞ –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ñ–∞–π–ª–∞ myfile.json
    {
      "pattern": "/msx/start.json",
      "action": "file",
      "type": "application/json; charset=utf-8",
      "val": "myfile.json"
    }
  ]
}
```

# –û—à–∏–±–∫–∞: Illegal instruction
–ü—Ä–æ—Ü–µ—Å—Å–æ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ AVX

1. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ ImageMagick
```bash
apt install -y imagemagick libpng-dev libjpeg-dev libwebp-dev
```

2. –í init.conf –¥–æ–±–∞–≤—å—Ç–µ
```json
"imagelibrary": "ImageMagick"
```

3. –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è, –∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞
```json
"imagelibrary": "none"
```

```

## File: update.sh
```
#!/usr/bin/env bash
DEST="/home/lampac"
cd $DEST

VERSION=$1
if [ -n "$VERSION" ]; then
    echo "update lampac to version $VERSION"
    rm -f update.zip
    if ! curl -L -k -o update.zip "http://noah.lampac.sh/update/$VERSION.zip"; then
        echo "Failed to download update.zip. Exiting."
        exit 1
    fi
    if ! unzip -t update.zip; then
        echo "Failed to test update.zip. Exiting."
        exit 1
    fi
    systemctl stop lampac
    unzip -o update.zip
    rm -f update.zip
    echo -n $VERSION > data/vers-minor.txt
    systemctl start lampac
    exit
fi

ver=$(cat data/vers.txt)
gitver=$(curl --connect-timeout 10 -m 20 -k -s https://api.github.com/repos/immisterio/Lampac/releases/latest | grep tag_name | sed s/[^0-9]//g)
if [ $gitver -gt $ver ]; then
    echo "update lampac to version $gitver"
    rm -f update.zip
    if ! curl -L -k -o update.zip https://github.com/immisterio/Lampac/releases/latest/download/update.zip; then
        echo "Failed to download update.zip. Exiting."
        exit 1
    fi
    if ! unzip -t update.zip; then
        echo "Failed to test update.zip. Exiting."
        exit 1
    fi
    systemctl stop lampac
    unzip -o update.zip
    rm -f update.zip
    echo -n $gitver > data/vers.txt
    systemctl start lampac
else
    check_ping() {
        response=$(curl --connect-timeout 5 -m 10 -k -s "$1/ping")
        if [[ "$response" == *"pong"* ]]; then
            return 0
        else
            return 1
        fi
    }

    if check_ping "http://noah.lampac.sh"; then
        BASE_URL="http://noah.lampac.sh"
    elif check_ping "https://lampac.sh"; then
        BASE_URL="https://lampac.sh"
    else
        echo "minor updates are not available"
        exit 1
    fi

    mver=$(cat data/vers-minor.txt)
    dver=$(curl -k -s $BASE_URL/update/$ver.txt)
	
    if [[ ${#dver} -eq 8 && $dver != $mver ]]; then
        echo "update lampac to version $gitver.$mver"
        rm -f update.zip
        if ! curl -L -k -o update.zip "$BASE_URL/update/$dver.zip"; then
            echo "Failed to download update.zip. Exiting."
            exit 1
        fi
        if ! unzip -t update.zip; then
            echo "Failed to test update.zip. Exiting."
            exit 1
        fi
        systemctl stop lampac
        unzip -o update.zip
        rm -f update.zip
        echo -n $dver > data/vers-minor.txt
        systemctl start lampac
    else
        echo "lampac already current version $ver"
    fi
fi


# clear
rm -rf runtimes/wi*
rm -rf runtimes/os*

```

## File: install_home.sh
```
#!/usr/bin/env bash
DEST="/home/lampac"

# Become root
# sudo su -
apt-get update
apt-get install -y unzip curl coreutils libicu-dev

# Install .NET
if ! curl -L -k -o dotnet-install.sh https://dot.net/v1/dotnet-install.sh; then
   echo "Failed to download dotnet-install.sh. Exiting."
   exit 1
fi

chmod 755 dotnet-install.sh
./dotnet-install.sh --channel 9.0 --runtime aspnetcore --install-dir /usr/share/dotnet
ln -s /usr/share/dotnet/dotnet /usr/bin/dotnet

# Download zip
mkdir $DEST -p 
cd $DEST
if ! curl -L -k -o publish.zip https://github.com/immisterio/Lampac/releases/latest/download/publish.zip; then
   echo "Failed to download publish.zip. Exiting."
   exit 1
fi

unzip -o publish.zip
rm -f publish.zip

# automatic updates
curl -k -s https://api.github.com/repos/immisterio/Lampac/releases/latest | grep tag_name | sed s/[^0-9]//g > $DEST/data/vers.txt
curl -k -s https://raw.githubusercontent.com/immisterio/lampac/main/update.sh > $DEST/update.sh
chmod 755 $DEST/update.sh
#crontab -l | { cat; echo "$(shuf -i 10-55 -n 1) * * * * /bin/bash $DEST/update.sh"; } | crontab -

CRON_JOB="$(shuf -i 10-55 -n 1) * * * * /bin/bash $DEST/update.sh"
(crontab -l | grep -vF "/bin/bash $DEST/update.sh"; echo "$CRON_JOB") | crontab -

# init.conf
random_port=$(shuf -i 9000-12999 -n 1)
cat <<EOF > $DEST/init.conf
"listen": {
  "port": $random_port
},
"typecache": "mem",
"mikrotik": true,
"chromium": {
  "enable": false
},
"firefox": {
  "enable": false
},
"dlna": {
  "cover": {
    "enable": false
  }
},
"serverproxy": {
  "verifyip": false,
  "image": {
    "cache": false,
    "cache_rsize": false
  },
  "buffering": {
    "enable": false
  }
},
"Spankbang": {
  "rhub": true
},
"BongaCams": {
  "rhub": true
},
"Runetki": {
  "rhub": true
},
"VDBmovies": {
  "rhub": true,
  "spider": false
},
"VideoDB": {
  "rhub": true
},
"FanCDN": {
  "rhub": true
},
"Lumex": {
  "spider": false
}
EOF

# manifest.json
cat <<EOF > $DEST/module/manifest.json
[
  {
    "enable": true,
    "dll": "SISI.dll"
  },
  {
    "enable": true,
    "dll": "Online.dll"
  },
  {
    "enable":true,
    "initspace":"Catalog.ModInit",
    "dll":"Catalog.dll"
  },
  {
    "enable": true,
    "dll": "DLNA.dll"
  },
  {
    "enable": true,
    "initspace": "Jackett.ModInit",
    "dll": "JacRed.dll"
  },
  {
    "enable": false,
    "initspace": "TorrServer.ModInit",
    "dll": "TorrServer.dll"
  }
]
EOF

# Lampac.runtimeconfig.json
cat <<EOF > $DEST/Lampac.runtimeconfig.json
{
  "runtimeOptions": {
    "tfm": "net9.0",
    "frameworks": [
      {
        "name": "Microsoft.NETCore.App",
        "version": "9.0.0"
      },
      {
        "name": "Microsoft.AspNetCore.App",
        "version": "9.0.0"
      }
    ],
    "configProperties": {
      "System.GC.Server": false,
      "System.Reflection.Metadata.MetadataUpdater.IsSupported": false,
      "System.Reflection.NullabilityInfoContext.IsSupported": true,
      "System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization": false
    }
  }
}
EOF

# Create service
echo ""
echo "Install service to /etc/systemd/system/lampac.service ..."
touch /etc/systemd/system/lampac.service && chmod 664 /etc/systemd/system/lampac.service
cat <<EOF > /etc/systemd/system/lampac.service
[Unit]
Description=Lampac
Wants=network.target
After=network.target
[Service]
WorkingDirectory=$DEST
ExecStart=/usr/bin/dotnet Lampac.dll
#ExecReload=/bin/kill -s HUP $MAINPID
#ExecStop=/bin/kill -s QUIT $MAINPID
Restart=always
[Install]
WantedBy=multi-user.target
EOF

# Enable service
systemctl daemon-reload
systemctl enable lampac

# update minor
echo -n "1" > $DEST/data/vers-minor.txt
/bin/bash $DEST/update.sh

# clear
cd $DEST
rm -f data/*.json
rm -rf merchant wwwroot/bwa
rm -rf runtimes/wi*
rm -rf runtimes/os*
rm -rf runtimes/linux-m*

# clear runtimes
case $(uname -m) in
    x86_64)
        rm -rf runtimes/linux-a*
        ;;
    armv7l)
        rm -rf runtimes/linux-arm64
		rm -rf runtimes/linux-x64
        ;;
    aarch64)
        rm -rf runtimes/linux-arm
		rm -rf runtimes/linux-x64
        ;;
    *)
        echo ""
        ;;
esac

# done
systemctl start lampac

# iptables drop
cat <<EOF > iptables-drop.sh
#!/bin/sh
echo "Stopping firewall and allowing everyone..."
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT
EOF

get_external_ip() {
   local ip
   ip=$(curl -s --connect-timeout 5 https://api.ipify.org 2>/dev/null)
   if [ -z "$ip" ]; then
      ip=$(curl -s --connect-timeout 5 https://icanhazip.com 2>/dev/null)
   fi
   if [ -z "$ip" ]; then
      ip=$(curl -s --connect-timeout 5 https://ifconfig.me 2>/dev/null)
   fi
   echo "${ip:-IP}"
}

# Note
echo ""
echo "################################################################"
echo ""
echo "Have fun!"
echo ""
echo "http://$(get_external_ip):$random_port"
echo ""
echo "Please check/edit $DEST/init.conf params and configure it"
echo ""
echo "Then [re]start it as systemctl [re]start lampac"
echo ""
echo "Clear iptables if port $random_port is not available"
echo "bash $DEST/iptables-drop.sh"
echo ""

```

## File: Termux/install.sh
```
#!/bin/bash

pkg install tmux proot-distro -y
proot-distro install debian

# Start Debian
proot-distro login debian

# Install packages
apt-get update
apt-get install -y curl unzip
apt-get install -y libicu-dev
apt-get install -y libicu72
apt-get install -y libicu76

# Install .NET 9
curl -L -k -o dotnet-install.sh https://dot.net/v1/dotnet-install.sh
chmod 755 dotnet-install.sh
./dotnet-install.sh --channel 9.0 --runtime aspnetcore --install-dir /usr/share/dotnet
ln -s /usr/share/dotnet/dotnet /usr/bin/dotnet
rm dotnet-install.sh

# clear .NET 6
rm -f *.dll
rm -f *.pdb
rm -f GeoLite2-Country.mmdb vers-minor.txt
rm -rf runtimes nginx
rm -rf .playwright

for lang in cs de es fr it ja ko pl pt-BR ru tr zh-Hans zh-Hant; do
    rm -rf $lang
done

# Download zip
curl -L -k -o publish.zip https://github.com/immisterio/Lampac/releases/latest/download/publish.zip
unzip -o publish.zip
rm -f publish.zip

echo -n "termux" > passwd

# init.conf
cat <<EOF > init.conf
{
  "typecache": "mem",
  "mikrotik": true,
  "pirate_store": false,
  "listen": {
    "compression": false
  },
  "chromium": {
    "enable": false
  },
  "firefox": {
    "enable": false
  },
  "dlna": {
    "enable": false,
    "autoupdatetrackers": false
  },
  "cub": {
    "enable": false
  },
  "tmdb": {
    "enable": false
  },
  "weblog": {
    "enable": true
  },
  "LampaWeb": {
    "initPlugins": {
      "dlna": false,
      "tracks": false,
      "tmdbProxy": false,
      "online": true,
      "sisi": true,
      "timecode": true,
      "torrserver": false,
      "backup": true,
      "sync": false
    }
  },
  "serverproxy": {
    "enable": true,
    "verifyip": false,
    "encrypt_aes": true,
    "image": {
      "cache": false,
      "cache_rsize": false
    },
    "buffering": {
      "enable": false
    }
  },
  "online": {
    "checkOnlineSearch": false
  },
  "sisi": {
    "rsize": false
  },
  "Spankbang": {
    "rhub": true
  },
  "BongaCams": {
    "rhub": true
  },
  "Runetki": {
    "rhub": true
  },
  "VDBmovies": {
    "rhub": true,
    "spider": false
  },
  "VideoDB": {
    "rhub": true
  },
  "FanCDN": {
    "rhub": true
  }
}
EOF

# manifest.json
cat <<EOF > module/manifest.json
[
  {
    "enable": true,
    "dll": "SISI.dll"
  },
  {
    "enable": true,
    "dll": "Online.dll"
  }
]
EOF

# update info
curl -k -s https://api.github.com/repos/immisterio/Lampac/releases/latest | grep tag_name | sed s/[^0-9]//g > data/vers.txt
echo -n "1" > data/vers-minor.txt

# update.sh
cat <<EOF > update.sh
#!/usr/bin/env bash

ver=$(cat data/vers.txt)
gitver=$(curl --connect-timeout 10 -m 20 -k -s https://api.github.com/repos/immisterio/Lampac/releases/latest | grep tag_name | sed s/[^0-9]//g)
if [ $gitver -gt $ver ]; then
    echo "update lampac to version $gitver"
    rm -f update.zip
    if ! curl -L -k -o update.zip https://github.com/immisterio/Lampac/releases/latest/download/update.zip; then
        echo "Failed to download update.zip. Exiting."
        exit 1
    fi
    if ! unzip -t update.zip; then
        echo "Failed to test update.zip. Exiting."
        exit 1
    fi
    unzip -o update.zip
    rm -f update.zip
    echo -n $gitver > data/vers.txt
else
    check_ping() {
        response=$(curl --connect-timeout 5 -m 10 -k -s "$1/ping")
        if [[ "$response" == *"pong"* ]]; then
            return 0
        else
            return 1
        fi
    }

    if check_ping "http://noah.lampac.sh"; then
        BASE_URL="http://noah.lampac.sh"
    elif check_ping "https://lampac.sh"; then
        BASE_URL="https://lampac.sh"
    else
        echo "minor updates are not available"
        exit 1
    fi

    mver=$(cat data/vers-minor.txt)
    dver=$(curl -k -s $BASE_URL/update/$ver.txt)
	
    if [[ ${#dver} -eq 8 && $dver != $mver ]]; then
        echo "update lampac to version $gitver.$mver"
        rm -f update.zip
        if ! curl -L -k -o update.zip "$BASE_URL/update/$dver.zip"; then
            echo "Failed to download update.zip. Exiting."
            exit 1
        fi
        if ! unzip -t update.zip; then
            echo "Failed to test update.zip. Exiting."
            exit 1
        fi
        unzip -o update.zip
        rm -f update.zip
        echo -n $dver > data/vers-minor.txt
    else
        echo "lampac already current version $ver"
    fi
fi

rm -f data/GeoLite2-Country.mmdb
rm -rf .playwright merchant torrserver wwwroot/bwa
rm -rf data/widgets
rm -rf runtimes/wi*
rm -rf runtimes/os*
rm -rf runtimes/linux-m*
rm -rf runtimes/linux-arm
rm -rf runtimes/linux-x64
EOF

# update minor
/bin/bash update.sh

# Lampac.runtimeconfig.json
cat <<EOF > Lampac.runtimeconfig.json
{
  "runtimeOptions": {
    "tfm": "net9.0",
    "frameworks": [
      {
        "name": "Microsoft.NETCore.App",
        "version": "9.0.0"
      },
      {
        "name": "Microsoft.AspNetCore.App",
        "version": "9.0.0"
      }
    ],
    "configProperties": {
      "System.GC.Server": false,
      "System.Reflection.Metadata.MetadataUpdater.IsSupported": false,
      "System.Reflection.NullabilityInfoContext.IsSupported": true,
      "System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization": false
    }
  }
}
EOF

# clear
rm -f data/GeoLite2-Country.mmdb
rm -rf .playwright merchant torrserver wwwroot/bwa
rm -rf data/widgets
rm -rf runtimes/wi*
rm -rf runtimes/os*
rm -rf runtimes/linux-m*
rm -rf runtimes/linux-arm
rm -rf runtimes/linux-x64

# Clean packages cache
apt-get clean && rm -rf /var/lib/apt/lists/*

#exit from Debian
exit

cat <<EOF > start.sh
#!/bin/bash

tmux new-session -d -s Lampac "proot-distro login debian -- dotnet Lampac.dll"
EOF

cat <<EOF > stop.sh
#!/bin/bash

tmux kill-session -a -t Lampac
EOF

cat <<EOF > restart.sh
#!/bin/bash

bash stop.sh
bash start.sh
EOF

cat <<EOF > update.sh
#!/bin/bash

proot-distro login debian
bash update.sh
exit
EOF

# Run Motherfucker Run 
ln -s /data/data/com.termux/files/usr/var/lib/proot-distro/installed-rootfs/debian/ debian
tmux new-session -d -s Lampac "proot-distro login debian -- dotnet Lampac.dll"

# Note
echo ""
echo "################################################################"
echo ""
echo "Have fun!"
echo ""
echo "http://127.0.0.1:9118"
echo ""
echo "Please check/edit http://127.0.0.1:9118/admin/init params and configure it"
echo ""

```

## File: Termux/README.md
```
<b>Supports:</b> smartphone, tablet, tv-box aosp
<br><b>Note:</b> Android TV (ATV) not support! 

# Download Termux
–°–∫–∞—á–∞–π—Ç–µ –∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ Termux —Å <a href="https://play.google.com/store/apps/details?id=com.termux&hl=ru" target="_blank">Google Play</a> or <a href="https://github.com/termux/termux-app/releases" target="_blank">GitHub official</a>  or  <a href="https://f-droid.org/ru/packages/com.termux/" target="_blank">F-Droid</a>

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ Lampac
–ó–∞–ø—É—Å—Ç–∏—Ç–µ Termux –∏ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É
```
curl -L -k -s https://lampac.sh/termux | bash
```
–°–ø–∞—Å–∏–±–æ @bbk14

# –ü–ª–∞–≥–∏–Ω—ã
http://127.0.0.1:9118 - –ª–∞–º–ø–∞ –±–µ–∑ —Ä–µ–∫–ª–∞–º—ã<br>
http://127.0.0.1:9118/online.js - –æ–Ω–ª–∞–π–Ω <br>
http://127.0.0.1:9118/sisi.js - 18+

# –ò—Å—Ç–æ—á–Ω–∏–∫–∏
https://github.com/immisterio/Lampac?tab=readme-ov-file#%D0%B8%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8
* Zetflix –∏ ENG —Å–∞–π—Ç—ã –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤ Termux 

# –ö–æ–º–∞–Ω–¥—ã –≤ Termux
```
bash stop.sh
bash start.sh
bash restart.sh
bash update.sh # –æ–±–Ω–æ–≤–∏—Ç—å –≤–µ—Ä—Å–∏—é lampac
```

# –í–∞–∂–Ω–æ
* –ò–∑–º–µ–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ –ø—Ä–∏–≤—è–∑–∞—Ç—å pro –∞–∫–∫–∞—É–Ω—Ç—ã –º–æ–∂–Ω–æ —á–µ—Ä–µ–∑ http://127.0.0.1:9118/admin
* –ò–∑ –∑–∞ –Ω–∏–∑–∫–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ termux, –≤–∫–ª—é—á–∞—Ç—å chrome/firefox/torrserver/proxy/jacred/dlna –Ω–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –æ—Ç —Å–ª–æ–º–∞ —Å–æ–≤—Å–µ–º
* –ù–∞ –±–∞–ª–∞–Ω—Å–µ—Ä–∞—Ö —Å –æ—Ç–∫–ª—é—á—ë–Ω–Ω—ã–º streamproxy –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ –≤–Ω–µ—à–Ω–∏–π –ø–ª–µ–µ—Ä Vimu, MPV, MX player —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π headers, –∏–Ω–∞—á–µ –≤–∏–¥–µ–æ –Ω–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∞–ª–∞–Ω—Å–µ—Ä–∞—Ö –±—É–¥–µ—Ç –≤—ã–¥–∞–≤–∞—Ç—å –æ—à–∏–±–∫—É –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è

```

## File: SISI/SisiApi.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Base;
using Shared.Models.Events;
using Shared.Models.Module;
using Shared.Models.Module.Entrys;
using Shared.PlaywrightCore;
using System.Reflection;
using System.Text;
using System.Web;
using IO = System.IO;

namespace SISI
{
    public class SisiApiController : BaseController
    {
        #region sisi.js
        [HttpGet]
        [AllowAnonymous]
        [Route("sisi.js")]
        [Route("sisi/js/{token}")]
        public ContentResult Sisi(string token, bool lite)
        {
            if (lite)
                return Content(FileCache.ReadAllText("plugins/sisi.lite.js").Replace("{localhost}", host), "application/javascript; charset=utf-8");

            var init = AppInit.conf.sisi;
            var apr = init.appReplace ?? InvkEvent.conf?.Controller?.AppReplace?.sisi?.regex;

            string memKey = $"sisi.js:{apr?.Count ?? 0}:{init.component}:{init.iconame}:{host}:{init.push_all}:{init.forced_checkRchtype}";
            if (!memoryCache.TryGetValue(memKey, out (string file, string filecleaer) cache))
            {
                cache.file = FileCache.ReadAllText("plugins/sisi.js", saveCache: false)
                    .Replace("{rch_websoket}", FileCache.ReadAllText($"plugins/rch_{AppInit.conf.rch.websoket}.js", saveCache: false));

                #region appReplace
                if (apr != null)
                {
                    foreach (var r in apr)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        cache.file = Regex.Replace(cache.file, r.Key, val, RegexOptions.IgnoreCase);
                    }
                }

                if (InvkEvent.conf?.Controller?.AppReplace?.sisi?.list != null)
                {
                    foreach (var r in InvkEvent.conf.Controller.AppReplace.sisi.list)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        cache.file = cache.file.Replace(r.Key, val);
                    }
                }
                #endregion

                var bulder = new StringBuilder(cache.file);

                if (!init.spider)
                    bulder = bulder.Replace("Lampa.Search.addSource(Search);", "");

                if (init.component != "sisi")
                {
                    bulder = bulder.Replace("use_api: 'lampac'", $"use_api: '{init.component}'");
                    bulder = bulder.Replace("'plugin_sisi_'", $"'plugin_{init.component}_'");
                }

                if (!string.IsNullOrEmpty(init.vipcontent))
                    bulder = bulder.Replace("var content = [^\n\r]+", init.vipcontent);

                if (!string.IsNullOrEmpty(init.iconame))
                {
                    bulder = bulder.Replace("Defined.use_api == 'pwa'", "true")
                                   .Replace("'<div>p</div>'", $"'<div>{init.iconame}</div>'");
                }

                bulder = bulder
                    .Replace("{invc-rch}", FileCache.ReadAllText("plugins/invc-rch.js", saveCache: false))
                    .Replace("{invc-rch_nws}", FileCache.ReadAllText("plugins/invc-rch_nws.js", saveCache: false))
                    .Replace("{push_all}", init.push_all.ToString().ToLower())
                    .Replace("{localhost}", host)
                    .Replace("{historySave}", AppInit.conf.sisi.history.enable.ToString().ToLower());

                if (init.forced_checkRchtype)
                    bulder = bulder.Replace("window.rchtype", "Defined.rchtype");

                cache.file = bulder.ToString();
                cache.filecleaer = cache.file.Replace("{token}", string.Empty);

                if (AppInit.conf.mikrotik == false)
                    memoryCache.Set(memKey, cache, DateTime.Now.AddMinutes(1));
            }

            if (InvkEvent.conf?.Controller?.AppReplace?.sisi?.eval != null)
            {
                string source = InvkEvent.AppReplace("sisi", new EventAppReplace(cache.file, token, null, host, requestInfo, HttpContext.Request, hybridCache));
                return Content(source.Replace("{token}", HttpUtility.UrlEncode(token)), "application/javascript; charset=utf-8");
            }

            return Content(token != null ? cache.file.Replace("{token}", HttpUtility.UrlEncode(token)) : cache.filecleaer, "application/javascript; charset=utf-8");
        }
        #endregion

        #region modification.js
        [HttpGet]
        [AllowAnonymous]
        [Route("sisi/plugins/modification.js")]
        public ActionResult SisiModification()
        {
            string file = FileCache.ReadAllText("wwwroot/sisi/plugins/modification.js");

            if (!AppInit.conf.sisi.xdb)
                file = file.Replace("addId();", "");

            file = Regex.Replace(file, "\\{localhost\\}/?", $"{host}/sisi");
            return Content(file, contentType: "application/javascript; charset=utf-8");
        }
        #endregion


        [Route("sisi")]
        async public ValueTask<JsonResult> Index(string rchtype, string account_email, string uid, string token, bool spder)
        {
            var conf = AppInit.conf;
            JObject kitconf = await loadKitConf();

            var channels = new List<ChannelItem>(conf.sisi.NextHUB ? 50 : 20) 
            {
                new ChannelItem("–ó–∞–∫–ª–∞–¥–∫–∏", $"{host}/sisi/bookmarks", 0)
            };

            if (conf.sisi.history.enable)
                channels.Add(new ChannelItem("–ò—Å—Ç–æ—Ä–∏—è", $"{host}/sisi/historys", 1));

            #region modules
            SisiModuleEntry.EnsureCache();

            if (SisiModuleEntry.sisiModulesCache != null && SisiModuleEntry.sisiModulesCache.Count > 0)
            {
                var args = new SisiEventsModel(rchtype, account_email, uid, token);

                foreach (var entry in SisiModuleEntry.sisiModulesCache)
                {
                    try
                    {
                        if (entry.Invoke != null)
                        {
                            try
                            {
                                var result = entry.Invoke(HttpContext, memoryCache, requestInfo, host, args);
                                if (result != null && result.Count > 0)
                                    channels.AddRange(result);
                            }
                            catch { }
                        }

                        if (entry.InvokeAsync != null)
                        {
                            try
                            {
                                var result = await entry.InvokeAsync(HttpContext, memoryCache, requestInfo, host, args);
                                if (result != null && result.Count > 0)
                                    channels.AddRange(result);
                            }
                            catch { }
                        }

                        if (entry.Events != null)
                        {
                            try
                            {
                                var result = entry.Events(host);
                                if (result != null && result.Count > 0)
                                    channels.AddRange(result);
                            }
                            catch { }
                        }
                    }
                    catch (Exception ex) { Console.WriteLine($"Modules {entry.mod?.NamespacePath(entry.mod.sisi)}: {ex.Message}\n\n"); }
                }
            }
            #endregion

            #region send
            void send(string name, BaseSettings _init, string plugin = null, string rch_access = null, int displayindex = -1)
            {
                var init = loadKit(_init, kitconf);
                bool enable = init.enable && !init.rip;
                if (!enable)
                    return;

                if (spder == true && init.spider != true)
                    return;

                if (init.rhub && !init.rhub_fallback)
                {
                    if (rch_access != null && rchtype != null)
                    {
                        enable = rch_access.Contains(rchtype);
                        if (enable && init.rhub_geo_disable != null)
                        {
                            if (requestInfo.Country != null && init.rhub_geo_disable.Contains(requestInfo.Country))
                                enable = false;
                        }
                    }
                }

                if (!enable)
                    return;

                if (init.client_type != null && rchtype != null)
                    enable = init.client_type.Contains(rchtype);

                if (init.geo_hide != null)
                {
                    if (requestInfo.Country != null && init.geo_hide.Contains(requestInfo.Country))
                        enable = false;
                }

                if (enable)
                {
                    if (init.group > 0 && init.group_hide)
                    {
                        var user = requestInfo.user;
                        if (user == null || init.group > user.group)
                            return;
                    }

                    string url = string.Empty;

                    if (string.IsNullOrEmpty(init.overridepasswd))
                    {
                        url = init.overridehost;
                        if (string.IsNullOrEmpty(url) && init.overridehosts != null && init.overridehosts.Length > 0)
                            url = init.overridehosts[Random.Shared.Next(0, init.overridehosts.Length)];
                    }

                    string displayname = init.displayname ?? name;

                    if (string.IsNullOrEmpty(url))
                        url = $"{host}/{plugin ?? name.ToLower()}";

                    if (displayindex == -1)
                    {
                        displayindex = init.displayindex;
                        if (displayindex == 0)
                            displayindex = 20 + channels.Count;
                    }

                    channels.Add(new ChannelItem(init.displayname ?? name, url, displayindex));
                }
            }
            #endregion

            #region NextHUB
            if (conf.sisi.NextHUB)
            {
                foreach (string inFile in Directory.GetFiles("NextHUB/sites", "*.yaml"))
                {
                    try
                    {
                        if (inFile.Contains(".my."))
                            continue;

                        string plugin = Path.GetFileNameWithoutExtension(inFile);
                        if (!conf.sisi.lgbt && plugin == "gayporntube")
                            continue;

                        var init = Controllers.NextHUB.Root.goInit(plugin);
                        if (init == null)
                            continue;

                        if (init.debug)
                            Console.WriteLine("\n" + JsonConvert.SerializeObject(init, Formatting.Indented));

                        if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                        {
                            if (init.priorityBrowser != "http" || (init.view != null && init.view.viewsource == false))
                            {
                                if (AppInit.conf.multiaccess == false)
                                    Console.WriteLine($"NextHUB: {plugin} - Playwright is disabled, skipping.");
                                continue;
                            }
                        }

                        send(Regex.Replace(init.host, "^https?://", ""), init, $"nexthub?plugin={plugin}", init.client_type);
                    }
                    catch (YamlDotNet.Core.YamlException ex)
                    {
                        Console.WriteLine($"\n–û—à–∏–±–∫–∞: {ex.Message}\n—Ñ–∞–π–ª: {Path.GetFileName(inFile)}\n—Å—Ç—Ä–æ–∫–∞: {ex.Start.Line}");
                    }
                    catch (Exception ex) { Console.WriteLine($"NextHUB: error DeserializeObject {inFile}\n {ex.Message}"); }
                }
            }
            #endregion

            send("pornhubpremium.com", conf.PornHubPremium, "phubprem"); // !rhub
            send("pornhub.com", conf.PornHub, "phub", "apk,cors");
            send("xvideos.com", conf.Xvideos, "xds", "apk,cors");
            send("xhamster.com", conf.Xhamster, "xmr", "apk,cors");
            send("ebalovo.porn", conf.Ebalovo, "elo", "apk");
            send("hqporner.com", conf.HQporner, "hqr", "apk,cors");

            if (conf.Spankbang.priorityBrowser == "http" || conf.Spankbang.rhub || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Spankbang.overridehost) || conf.Spankbang.overridehosts?.Length > 0)
                send("spankbang.com", conf.Spankbang, "sbg");

            send("eporner.com", conf.Eporner, "epr", "apk,cors");
            send("porntrex.com", conf.Porntrex, "ptx", "apk");
            send("xdsred", conf.XvideosRED, "xdsred");  // !rhub
            send("xnxx.com", conf.Xnxx, "xnx", "apk,cors");
            send("tizam.pw", conf.Tizam, "tizam", "apk,cors");

            if (conf.BongaCams.priorityBrowser == "http" || conf.BongaCams.rhub || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.BongaCams.overridehost) || conf.BongaCams.overridehosts?.Length > 0)
                send("bongacams.com", conf.BongaCams, "bgs", "apk");

            if (conf.Runetki.priorityBrowser == "http" || conf.Runetki.rhub || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Runetki.overridehost) || conf.Runetki.overridehosts?.Length > 0)
                send("runetki.com", conf.Runetki, "runetki", "apk");

            send("chaturbate.com", conf.Chaturbate, "chu", "apk,cors");

            if (conf.sisi.lgbt)
            {
                send("phubgay", conf.PornHub, "phubgay", "apk,cors", 10_100);
                send("phubtrans", conf.PornHub, "phubsml", "apk,cors", 10_101);
                send("xdsgay", conf.Xvideos, "xdsgay", "apk,cors", 10_102);
                send("xdstrans", conf.Xvideos, "xdssml", "apk,cors", 10_103);
                send("xmrgay", conf.Xhamster, "xmrgay", "apk,cors", 10_104);
                send("xmrtrans", conf.Xhamster, "xmrsml", "apk,cors", 10_105);
            }

            if (conf.sisi.xdb)
            {
                try
                {
                    var ch = await Http.Get<JObject>("https://vi.sisi.am", timeoutSeconds: 4);

                    foreach (var pl in ch.GetValue("channels"))
                    {
                        string title = pl.Value<string>("title").Replace("pornhubpremium.com", "phubprem.com");
                        string playlist_url = pl.Value<string>("playlist_url");

                        if (playlist_url.Contains("/bookmarks"))
                            continue;

                        if (channels.FirstOrDefault(i => i.title == title).title != null)
                            continue;

                        channels.Add(new ChannelItem(title, playlist_url, 20 + channels.Count));
                    }
                }
                catch { }
            }

            return Json(new
            {
                title = "sisi",
                channels = channels.OrderBy(i => i.displayindex)
            });
        }
    }
}

```

## File: SISI/ModInit.cs
```
Ôªøusing Microsoft.EntityFrameworkCore;
using Shared.Models.SQL;
using System.Threading;

namespace SISI
{
    public class ModInit
    {
        private static Timer cleanupTimer;

        public static void loaded()
        {
            Directory.CreateDirectory("wwwroot/bookmarks/img");
            Directory.CreateDirectory("wwwroot/bookmarks/preview");

            cleanupTimer = new Timer(_ => CleanupHistory(), null, TimeSpan.FromMinutes(20), TimeSpan.FromHours(1));
        }

        private static void CleanupHistory()
        {
            try
            {
                var threshold = DateTime.UtcNow.AddDays(-AppInit.conf.sisi.history.days);

                using (var sqlDb = new SisiContext())
                {
                    sqlDb.historys
                        .AsNoTracking()
                        .Where(i => i.created < threshold)
                        .ExecuteDelete();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[SISI] Cleanup history failed: {ex.Message}");
            }
        }
    }
}

```

## File: SISI/BookmarkController.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Newtonsoft.Json;
using Shared.Models.SQL;
using System.Web;

namespace SISI
{
    public class BookmarkController : BaseSisiController
    {
        [Route("sisi/bookmarks")]
        public ActionResult List(string search, string model, int pg = 1, int pageSize = 36)
        {
            string md5user = getuser();
            if (md5user == null)
                return OnError("access denied");

            var menu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = $"{host}/sisi/bookmarks",
                }
            };

            #region bookmarks
            var bookmarks = new List<PlaylistItem>();
            var bookmarksQuery = new List<SisiBookmarkSqlModel>();

            using (var sqlDb = new SisiContext())
            {
                bookmarksQuery = sqlDb.bookmarks
                    .AsNoTracking()
                    .Where(i => i.user == md5user)
                    .ToList();
            }

            int total_pages = Math.Max(0, bookmarksQuery.Count / pageSize) + 1;

            #region –ú–æ–¥–µ–ª—å
            var menu_models = new MenuItem()
            {
                title = $"–ú–æ–¥–µ–ª—å: {model ?? "–≤—ã–±—Ä–∞—Ç—å"}",
                playlist_url = "submenu",
                submenu = new List<MenuItem>(20)
            };

            foreach (var m in bookmarksQuery.OrderByDescending(i => i.created).Select(i => i.model).ToHashSet())
            {
                if (string.IsNullOrEmpty(m))
                    continue;

                menu_models.submenu.Add(new MenuItem()
                {
                    title = m,
                    playlist_url = $"{host}/sisi/bookmarks?model={HttpUtility.UrlEncode(m)}"
                });
            }

            if (menu_models.submenu.Count > 0)
                menu.Add(menu_models);
            #endregion

            var items = bookmarksQuery
                .OrderByDescending(i => i.created)
                .Skip((pg * pageSize) - pageSize)
                .Take(pageSize);

            if (!string.IsNullOrEmpty(search))
            {
                string _s = StringConvert.SearchName(search);
                items = items.Where(i => i.name != null && StringConvert.SearchName(i.name).Contains(_s));
            }

            if (!string.IsNullOrEmpty(model))
                items = items.Where(i => i.model == model);

            if (items.Any())
            {
                foreach (var json in items.Select(i => i.json))
                {
                    if (string.IsNullOrEmpty(json))
                        continue;

                    try
                    {
                        var bookmark = JsonConvert.DeserializeObject<PlaylistItem>(json);
                        if (bookmark != null)
                            bookmarks.Add(bookmark);
                    }
                    catch { }
                }
            }
            #endregion

            #region getvideLink
            string getvideLink(PlaylistItem pl)
            {
                if (pl.bookmark.site is "phub" or "phubprem")
                    return $"{host}/{pl.bookmark.site}/vidosik?vkey={HttpUtility.UrlEncode(pl.bookmark.href)}";

                return $"{host}/{pl.bookmark.site}/vidosik?uri={HttpUtility.UrlEncode(pl.bookmark.href)}";
            }
            #endregion

            string localhost = $"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}";

            return new JsonResult(new
            {
                menu,
                list = bookmarks.Select(pl => new
                {
                    pl.name,
                    video = getvideLink(pl),
                    picture = HostImgProxy(pl.bookmark.image.StartsWith("bookmarks/") ? $"{localhost}/{pl.bookmark.image}" : pl.bookmark.image, plugin: pl.bookmark.site),
                    pl.time,
                    pl.json,
                    related = pl.related || Regex.IsMatch(pl.bookmark.site, "^(elo|epr|fph|phub|sbg|xmr|xnx|xds)"),
                    pl.quality,
                    preview = pl.preview != null && pl.preview.StartsWith("bookmarks/") ? $"{host}/{pl.preview}" : null,
                    pl.model,
                    bookmark = new Bookmark() { uid = pl.bookmark.uid }
                }).ToArray(),
                total_pages
            });
        }


        [HttpPost]
        [Route("sisi/bookmark/add")]
        public async Task<ActionResult> Add([FromBody] PlaylistItem data)
        {
            string md5user = getuser();
            if (md5user == null || data == null || string.IsNullOrEmpty(data?.bookmark?.site) || string.IsNullOrEmpty(data?.bookmark?.href))
                return OnError("access denied");

            string uid = CrypTo.md5($"{data.bookmark.site}:{data.bookmark.href}");

            using (var sqlDb = new SisiContext())
            {
                if (!sqlDb.bookmarks.AsNoTracking().Any(i => i.user == md5user && i.uid == uid))
                {
                    string newimage = null;

                    #region download image
                    if (AppInit.conf.sisi.bookmarks.saveimage)
                    {
                        string pimg = $"bookmarks/img/{uid.Substring(0, 2)}/{uid.Substring(2)}.jpg";

                        if (System.IO.File.Exists($"wwwroot/{pimg}"))
                        {
                            newimage = pimg;
                        }
                        else
                        {
                            var image = await Http.Download(data.bookmark.image, timeoutSeconds: 7);
                            if (image != null)
                            {
                                Directory.CreateDirectory($"wwwroot/bookmarks/img/{uid.Substring(0, 2)}");
                                System.IO.File.WriteAllBytes($"wwwroot/{pimg}", image);
                                newimage = pimg;
                            }
                        }
                    }
                    #endregion

                    #region download preview
                    if (AppInit.conf.sisi.bookmarks.savepreview)
                    {
                        if (data.preview != null)
                        {
                            string path = $"bookmarks/preview/{uid.Substring(0, 2)}/{uid.Substring(2)}.{(data.preview.Contains(".webm") ? "webm" : "mp4")}";

                            if (System.IO.File.Exists($"wwwroot/{path}"))
                            {
                                data.preview = path;
                            }
                            else
                            {
                                var preview = await Http.Download(data.preview, timeoutSeconds: 8);
                                if (preview != null)
                                {
                                    Directory.CreateDirectory($"wwwroot/bookmarks/preview/{uid.Substring(0, 2)}");
                                    System.IO.File.WriteAllBytes($"wwwroot/{path}", preview);
                                    data.preview = path;
                                }
                            }
                        }
                    }
                    #endregion

                    var b = data.bookmark;
                    data.bookmark = new Bookmark()
                    {
                        href = b.href,
                        image = newimage ?? b.image,
                        site = b.site,
                        uid = uid
                    };

                    sqlDb.bookmarks.Add(new SisiBookmarkSqlModel
                    {
                        user = md5user,
                        uid = uid,
                        created = DateTime.UtcNow,
                        json = JsonConvert.SerializeObject(data),
                        name = data.name,
                        model = data.model?.name
                    });

                    await sqlDb.SaveChangesLocks();
                }
            }

            return Json(new
            {
                result = true
            });
        }


        [Route("sisi/bookmark/remove")]
        async public Task<ActionResult> Remove(string id)
        {
            string md5user = getuser();
            if (md5user == null || string.IsNullOrEmpty(id))
                return OnError("access denied");

            try
            {
                await SisiContext.semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                using (var sqlDb = new SisiContext())
                {
                    sqlDb.bookmarks
                        .Where(i => i.user == md5user && i.uid == id)
                        .ExecuteDelete();
                }
            }
            catch { }
            finally
            {
                SisiContext.semaphore.Release();
            }

            return Json(new
            {
                result = true,
            });
        }



        string getuser()
        {
            string user_id = requestInfo.user_uid;
            if (string.IsNullOrEmpty(user_id))
                return null;

            string profile_id = getProfileid();
            if (!string.IsNullOrEmpty(profile_id))
                return CrypTo.md5($"{user_id}_{profile_id}");

            return CrypTo.md5(user_id);
        }

        string getProfileid()
        {
            if (HttpContext.Request.Query.TryGetValue("profile_id", out var profile_id) && !string.IsNullOrEmpty(profile_id) && profile_id != "0")
                return profile_id;

            return string.Empty;
        }
    }
}

```

## File: SISI/HistoryController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Newtonsoft.Json;
using Shared.Models.SQL;
using System.Web;

namespace SISI
{
    public class HistoryController : BaseSisiController
    {
        [Route("sisi/historys")]
        public ActionResult List(int pg = 1, int pageSize = 36)
        {
            string md5user = getuser();
            if (md5user == null || !AppInit.conf.sisi.history.enable)
                return OnError("access denied");

            #region historys
            var historys = new List<PlaylistItem>();
            var historysQuery = new List<SisiHistorySqlModel>();

            using (var sqlDb = new SisiContext())
            {
                historysQuery = sqlDb.historys
                    .AsNoTracking()
                    .Where(i => i.user == md5user)
                    .Take(pageSize * 20)
                    .ToList();
            }

            int total_pages = Math.Max(0, historysQuery.Count / pageSize) + 1;

            var items = historysQuery
                .OrderByDescending(i => i.created)
                .Skip((pg * pageSize) - pageSize)
                .Take(pageSize);

            if (items.Any())
            {
                foreach (var json in items.Select(i => i.json))
                {
                    if (string.IsNullOrEmpty(json))
                        continue;

                    try
                    {
                        var history = JsonConvert.DeserializeObject<PlaylistItem>(json);
                        if (history != null)
                            historys.Add(history);
                    }
                    catch { }
                }
            }
            #endregion

            #region getvideLink
            string getvideLink(PlaylistItem pl)
            {
                if (pl.bookmark.site is "phub" or "phubprem")
                    return $"{host}/{pl.bookmark.site}/vidosik?vkey={HttpUtility.UrlEncode(pl.bookmark.href)}";

                return $"{host}/{pl.bookmark.site}/vidosik?uri={HttpUtility.UrlEncode(pl.bookmark.href)}";
            }
            #endregion

            string localhost = $"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}";

            return new JsonResult(new
            {
                list = historys.Select(pl => new
                {
                    pl.name,
                    video = getvideLink(pl),
                    picture = HostImgProxy(pl.bookmark.image, plugin: pl.bookmark.site),
                    pl.time,
                    pl.json,
                    related = pl.related || Regex.IsMatch(pl.bookmark.site, "^(elo|epr|fph|phub|sbg|xmr|xnx|xds)"),
                    pl.quality,
                    pl.preview,
                    pl.model,
                    pl.bookmark,
                    pl.history_uid
                }).ToArray(),
                total_pages
            });
        }


        [HttpPost]
        [Route("sisi/history/add")]
        async public Task<ActionResult> Add([FromBody] PlaylistItem data)
        {
            string md5user = getuser();
            if (md5user == null || !AppInit.conf.sisi.history.enable || data == null || string.IsNullOrEmpty(data?.bookmark?.site) || string.IsNullOrEmpty(data?.bookmark?.href))
                return OnError("access denied");

            string uid = CrypTo.md5($"{data.bookmark.site}:{data.bookmark.href}");

            using (var sqlDb = new SisiContext())
            {
                if (!sqlDb.historys.AsNoTracking().Any(i => i.user == md5user && i.uid == uid))
                {
                    data.history_uid = uid;

                    sqlDb.historys.Add(new SisiHistorySqlModel
                    {
                        user = md5user,
                        uid = uid,
                        created = DateTime.UtcNow,
                        json = JsonConvert.SerializeObject(data)
                    });

                    await sqlDb.SaveChangesLocks();
                }
            }

            return Json(new
            {
                result = true
            });
        }


        [Route("sisi/history/remove")]
        async public Task<ActionResult> Remove(string id)
        {
            string md5user = getuser();
            if (md5user == null || !AppInit.conf.sisi.history.enable || string.IsNullOrEmpty(id))
                return OnError("access denied");

            try
            {
                await SisiContext.semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                using (var sqlDb = new SisiContext())
                {
                    sqlDb.historys
                        .Where(i => i.user == md5user && i.uid == id)
                        .ExecuteDelete();
                }
            }
            catch { }
            finally
            {
                SisiContext.semaphore.Release();
            }

            return Json(new
            {
                result = true,
            });
        }



        string getuser()
        {
            string user_id = requestInfo.user_uid;
            if (string.IsNullOrEmpty(user_id))
                return null;

            string profile_id = getProfileid();
            if (!string.IsNullOrEmpty(profile_id))
                return CrypTo.md5($"{user_id}_{profile_id}");

            return CrypTo.md5(user_id);
        }

        string getProfileid()
        {
            if (HttpContext.Request.Query.TryGetValue("profile_id", out var profile_id) && !string.IsNullOrEmpty(profile_id) && profile_id != "0")
                return profile_id;

            return string.Empty;
        }
    }
}

```

## File: SISI/GlobalUsings.cs
```
Ôªøglobal using System;
global using System.Threading.Tasks;
global using System.Collections.Generic;
global using System.Text.RegularExpressions;
global using System.IO;
global using System.Linq;
global using Shared;
global using Shared.Models;
global using Shared.Engine;
global using Shared.Engine.SISI;
global using Shared.Models.SISI.Base;
global using Shared.Models.SISI.OnResult;
```

## File: SISI/Models/BongaCams/Listing.cs
```
Ôªønamespace SISI.Models.BongaCams
{
    public class Listing
    {
        public List<Model> models { get; set; }

        public int online_count { get; set; }
    }
}

```

## File: SISI/Models/BongaCams/LocalData.cs
```
Ôªønamespace SISI.Models.BongaCams
{
    public class LocalData
    {
        public string videoServerUrl { get; set; }
    }
}

```

## File: SISI/Models/BongaCams/Amf.cs
```
Ôªønamespace SISI.Models.BongaCams
{
    public class Amf
    {
        public LocalData localData { get; set; }
    }
}

```

## File: SISI/Models/BongaCams/Model.cs
```
Ôªønamespace SISI.Models.BongaCams
{
    public class Model
    {
        public bool online { get; set; }

        public string username { get; set; }

        public string display_name { get; set; }

        public string topic { get; set; }

        public string thumb_image { get; set; }

        public string room { get; set; }

        public int hd_cam { get; set; }

        public int hd_plus { get; set; }

        public bool is_away { get; set; }
    }
}

```

## File: SISI/Controllers/Xhamster/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Xhamster
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("xmr")]
        [Route("xmrgay")]
        [Route("xmrsml")]
        async public ValueTask<ActionResult> Index(string search, string c, string q, string sort = "newest", int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Xhamster);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            pg++;
            string plugin = Regex.Match(HttpContext.Request.Path.Value, "^/([a-z]+)").Groups[1].Value;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"{plugin}:{search}:{sort}:{c}:{q}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    string html = await XhamsterTo.InvokeHtml(init.corsHost(), plugin, search, c, q, sort, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), httpversion: 2, timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    playlists = XhamsterTo.Playlist("xmr/vidosik", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(playlists, string.IsNullOrEmpty(search) ? XhamsterTo.Menu(host, plugin, c, q, sort) : null, plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Xhamster/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Xhamster
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("xmr/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            var init = await loadKit(AppInit.conf.Xhamster);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"xhamster:view:{uri}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    reset:
                    stream_links = await XhamsterTo.StreamLinks("xmr/vidosik", init.corsHost(), uri, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), httpversion: 2, timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/Runetki/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.PlaywrightCore;

namespace SISI.Controllers.Runetki
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("runetki")]
        async public ValueTask<ActionResult> Index(string search, string sort, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Runetki);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (!string.IsNullOrEmpty(search))
                return OnError("no search", false);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return OnError(rch_error);

            string memKey = $"{init.plugin}:list:{sort}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out (List<PlaylistItem> playlists, int total_pages) cache, inmemory: false))
                {
                    reset:
                    string html = await RunetkiTo.InvokeHtml(init.corsHost(), sort, pg, url =>
                    {
                        if (rch.enable)
                            return rch.Get(init.cors(url), httpHeaders(init));

                        if (init.priorityBrowser == "http")
                            return Http.Get(url, httpversion: 2, timeoutSeconds: 8, headers: httpHeaders(init), proxy: proxy.proxy);

                        return PlaywrightBrowser.Get(init, url, httpHeaders(init), proxy.data);
                    });

                    cache.playlists = RunetkiTo.Playlist(html, out int total_pages);
                    cache.total_pages = total_pages;

                    if (cache.playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, cache, cacheTime(5, init: init), inmemory: false);
                }

                return OnResult(cache.playlists, init, RunetkiTo.Menu(host, sort), proxy: proxy.proxy, total_pages: cache.total_pages);
            });
        }
    }
}

```

## File: SISI/Controllers/Xnxx/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Xnxx
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("xnx")]
        async public ValueTask<ActionResult> Index(string search, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Xnxx);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"xnx:list:{search}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    string html = await XnxxTo.InvokeHtml(init.corsHost(), search, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    playlists = XnxxTo.Playlist("xnx/vidosik", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10), inmemory: false);
                }

                return OnResult(playlists, string.IsNullOrEmpty(search) ? XnxxTo.Menu(host) : null, plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Xnxx/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Xnxx
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("xnx/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            var init = await loadKit(AppInit.conf.Xnxx);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"xnxx:view:{uri}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    reset:
                    stream_links = await XnxxTo.StreamLinks("xnx/vidosik", init.corsHost(), uri, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/Xvideos/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Xvideos
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("xds")]
        [Route("xdsgay")]
        [Route("xdssml")]
        async public ValueTask<ActionResult> Index(string search, string sort, string c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Xvideos);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string plugin = Regex.Match(HttpContext.Request.Path.Value, "^/([a-z]+)").Groups[1].Value;
            string memKey = $"{plugin}:list:{search}:{sort}:{c}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    string html = await XvideosTo.InvokeHtml(init.corsHost(), plugin, search, sort, c, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    playlists = XvideosTo.Playlist("xds/vidosik", $"{plugin}/stars", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(playlists, string.IsNullOrEmpty(search) ? XvideosTo.Menu(host, plugin, sort, c) : null, plugin: init.plugin);
            });
        }


        [HttpGet]
        [Route("xds/stars")]
        [Route("xdsgay/stars")]
        [Route("xdssml/stars")]
        async public ValueTask<ActionResult> Pornstars(string uri, string sort, int pg = 0)
        {
            var init = await loadKit(AppInit.conf.Xvideos);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string plugin = Regex.Match(HttpContext.Request.Path.Value, "^/([a-z]+)").Groups[1].Value;
            string memKey = $"{plugin}:stars:{uri}:{sort}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    playlists = await XvideosTo.Pornstars("xds/vidosik", $"{plugin}/stars", init.corsHost(), plugin, uri, sort, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    if (playlists == null || playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }


                // XvideosTo.PornstarsMenu(host, plugin, sort)
                return OnResult(playlists, null, plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Xvideos/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Xvideos
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("xds/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            var init = await loadKit(AppInit.conf.Xvideos);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"xvideos:view:{uri}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    reset:
                    stream_links = await XvideosTo.StreamLinks("xds/vidosik", $"{host}/xds/stars", init.corsHost(), uri, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(url, timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/PornHub/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.PornHub
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("phub")]
        [Route("phubgay")]
        [Route("phubsml")]
        async public ValueTask<ActionResult> Index(string search, string model, string sort, int c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.PornHub);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string plugin = Regex.Match(HttpContext.Request.Path.Value, "^/([a-z]+)").Groups[1].Value;
            string memKey = $"{plugin}:list:{search}:{model}:{sort}:{c}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out (int total_pages, List<PlaylistItem> playlists) cache, inmemory: false))
                {
                    reset:
                    string html = await PornHubTo.InvokeHtml(init.corsHost(), plugin, search, model, sort, c, null, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, httpversion: 2, headers: httpHeaders(init))
                    );

                    cache.total_pages = rch.enable ? 0 : PornHubTo.Pages(html);
                    cache.playlists = PornHubTo.Playlist("phub/vidosik", "phub", html, IsModel_page: !string.IsNullOrEmpty(model));

                    if (cache.playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, cache, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(cache.playlists, string.IsNullOrEmpty(model) ? PornHubTo.Menu(host, plugin, search, sort, c) : null, plugin: init.plugin, total_pages: cache.total_pages);
            });
        }


        [HttpGet]
        [Route("phubprem")]
        async public ValueTask<ActionResult> Prem(string search, string model, string sort, string hd, int c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.PornHubPremium);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string memKey = $"phubprem:list:{search}:{model}:{sort}:{hd}:{pg}";
            if (!hybridCache.TryGetValue(memKey, out (int total_pages, List<PlaylistItem> playlists) cache, inmemory: false))
            {
                var proxyManager = new ProxyManager(init);
                var proxy = proxyManager.Get();

                string html = await PornHubTo.InvokeHtml(init.corsHost(), "phubprem", search, model, sort, c, hd, pg, url => Http.Get(init.cors(url), timeoutSeconds: 14, proxy: proxy, httpversion: 2, headers: httpHeaders(init, HeadersModel.Init("cookie", init.cookie))));
                if (html == null)
                    return OnError("html", proxyManager, string.IsNullOrEmpty(search));

                cache.total_pages = PornHubTo.Pages(html);
                cache.playlists = PornHubTo.Playlist("phubprem/vidosik", "phubprem", html, prem: true);

                if (cache.playlists.Count == 0)
                    return OnError("playlists", proxyManager, pg > 1 && string.IsNullOrEmpty(search));

                proxyManager.Success();
                hybridCache.Set(memKey, cache, cacheTime(10, init: init), inmemory: false);
            }

            return OnResult(cache.playlists, string.IsNullOrEmpty(model) ? PornHubTo.Menu(host, "phubprem", search, sort, c, hd) : null, plugin: "phubprem", total_pages: cache.total_pages);
        }
    }
}

```

## File: SISI/Controllers/PornHub/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.PornHub
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("phub/vidosik")]
        async public ValueTask<ActionResult> Index(string vkey, bool related)
        {
            var init = await loadKit(AppInit.conf.PornHub);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"phub:vidosik:{vkey}";
            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    reset:
                    stream_links = await PornHubTo.StreamLinks("phub/vidosik", "phub", init.corsHost(), vkey, url =>
                        rch.enable 
                            ? rch.Get(init.cors(url), httpHeaders(init)) 
                            : Http.Get(init.cors(url), httpversion: 2, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init))
                    );

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy);
            });
        }


        [HttpGet]
        [Route("phubprem/vidosik")]
        async public ValueTask<ActionResult> Prem(string vkey, bool related)
        {
            var init = await loadKit(AppInit.conf.PornHubPremium);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            string memKey = $"phubprem:vidosik:{vkey}";
            if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
            {
                stream_links = await PornHubTo.StreamLinks("phubprem/vidosik", "phubprem", init.corsHost(), vkey, url => Http.Get(init.cors(url), httpversion: 2, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init, HeadersModel.Init("cookie", init.cookie))));

                if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    return OnError("stream_links", proxyManager);

                proxyManager.Success();
                hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
            }

            if (related)
                return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

            return OnResult(stream_links, init, proxy);
        }
    }
}

```

## File: SISI/Controllers/Tizam/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using System.Web;

namespace SISI.Controllers.Tizam
{
    public class ListController : BaseSisiController
    {
        [Route("tizam")]
        async public ValueTask<ActionResult> Index(string search, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Tizam);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (!string.IsNullOrEmpty(search))
                return OnError("no search", false);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"tizam:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    string uri = $"{init.corsHost()}/fil_my_dlya_vzroslyh/s_russkim_perevodom/";

                    int page = pg - 1;
                    if (page > 0)
                        uri += $"?p={page}";

                    reset:
                    string html = rch.enable ? await rch.Get(init.cors(uri), httpHeaders(init)) :
                                               await Http.Get(init.cors(uri), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init));

                    playlists = Playlist(html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(60, init: init), inmemory: false);
                }

                return OnResult(playlists, null, plugin: init.plugin);
            });
        }


        static List<PlaylistItem> Playlist(string html)
        {
            var playlists = new List<PlaylistItem>() { Capacity = 25 };
            if (string.IsNullOrEmpty(html))
                return playlists;

            foreach (string row in Regex.Split(html.Split("id=\"pagination\"")[0], "video-item").Skip(1))
            {
                if (row.Contains("pin--premium"))
                    continue;

                string title = Regex.Match(row, "-name=\"name\">([^<]+)<").Groups[1].Value;
                string href = Regex.Match(row, "href=\"/([^\"]+)\" itemprop=\"url\"").Groups[1].Value;

                if (!string.IsNullOrEmpty(href) && !string.IsNullOrWhiteSpace(title))
                {
                    string duration = Regex.Match(row, "itemprop=\"duration\" content=\"([^<]+)\"").Groups[1].Value;

                    string img = Regex.Match(row, "class=\"item__img\" src=\"/([^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(img))
                        continue;

                    var pl = new PlaylistItem()
                    {
                        name = title,
                        video = $"tizam/vidosik?uri={HttpUtility.UrlEncode(href)}",
                        picture = $"{AppInit.conf.Tizam.host}/{img}",
                        time = duration?.Trim(),
                        json = true,
                        bookmark = new Bookmark()
                        {
                            site = "tizam",
                            href = href,
                            image = $"{AppInit.conf.Tizam.host}/{img}"
                        }
                    };

                    playlists.Add(pl);
                }
            }

            return playlists;
        }
    }
}

```

## File: SISI/Controllers/Tizam/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Tizam
{
    public class ViewController : BaseSisiController
    {
        [Route("tizam/vidosik")]
        async public ValueTask<ActionResult> Index(string uri)
        {
            var init = await loadKit(AppInit.conf.Tizam);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"tizam:view:{uri}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    reset:
                    string html = rch.enable ? await rch.Get($"{init.corsHost()}/{uri}", httpHeaders(init)) :
                                               await Http.Get($"{init.corsHost()}/{uri}", timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init));

                    string location = Regex.Match(html ?? string.Empty, "src=\"(https?://[^\"]+\\.mp4)\" type=\"video/mp4\"").Groups[1].Value;

                    if (string.IsNullOrEmpty(location))
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("location", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    stream_links = new StreamItem()
                    {
                        qualitys = new Dictionary<string, string>()
                        {
                            ["auto"] = location
                        }
                    };

                    hybridCache.Set(memKey, stream_links, cacheTime(180, init: init));
                }

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/Spankbang/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.PlaywrightCore;

namespace SISI.Controllers.Spankbang
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("sbg")]
        async public ValueTask<ActionResult> Index(string search, string sort, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Spankbang);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string memKey = $"sbg:{search}:{sort}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    string html = await SpankbangTo.InvokeHtml(init.corsHost(), search, sort, pg, url =>
                    {
                        if (rch.enable)
                            return rch.Get(init.cors(url), httpHeaders(init));

                        if (init.priorityBrowser == "http")
                            return Http.Get(url, httpversion: 2, timeoutSeconds: 8, headers: httpHeaders(init), proxy: proxy.proxy);

                        return PlaywrightBrowser.Get(init, url, httpHeaders(init), proxy.data);
                    });

                    playlists = SpankbangTo.Playlist("sbg/vidosik", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(playlists, string.IsNullOrEmpty(search) ? SpankbangTo.Menu(host, sort) : null, plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Spankbang/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.PlaywrightCore;

namespace SISI.Controllers.Spankbang
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("sbg/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            var init = await loadKit(AppInit.conf.Spankbang);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string memKey = $"spankbang:view:{uri}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    reset:
                    stream_links = await SpankbangTo.StreamLinks("sbg/vidosik", init.corsHost(), uri, url =>
                    {
                        if (rch.enable)
                            return rch.Get(init.cors(url), httpHeaders(init));

                        if (init.priorityBrowser == "http")
                            return Http.Get(url, httpversion: 2, timeoutSeconds: 8, headers: httpHeaders(init), proxy: proxy.proxy);

                        return PlaywrightBrowser.Get(init, url, httpHeaders(init), proxy.data);
                    });

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy.proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/HQporner/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.HQporner
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("hqr")]
        async public ValueTask<ActionResult> Index(string search, string sort, string c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.HQporner);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"hqr:{search}:{sort}:{c}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    string html = await HQpornerTo.InvokeHtml(init.corsHost(), search, sort, c, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    playlists = HQpornerTo.Playlist("hqr/vidosik", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(playlists, string.IsNullOrEmpty(search) ? HQpornerTo.Menu(host, sort, c) : null, plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/HQporner/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.HQporner
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("hqr/vidosik")]
        async public ValueTask<ActionResult> Index(string uri)
        {
            var init = await loadKit(AppInit.conf.HQporner);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;


            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = rch.ipkey($"HQporner:view:{uri}", proxyManager);

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out Dictionary<string, string> stream_links))
                {
                    reset:
                    stream_links = await HQpornerTo.StreamLinks(init.corsHost(), uri,
                                   htmlurl => rch.enable ? rch.Get(init.cors(htmlurl), httpHeaders(init)) : Http.Get(init.cors(htmlurl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
                                   iframeurl => rch.enable ? rch.Get(init.cors(iframeurl), httpHeaders(init)) : Http.Get(init.cors(iframeurl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)));

                    if (stream_links == null || stream_links.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/NextHUB/ListController.cs
```
Ôªøusing HtmlAgilityPack;
using Microsoft.AspNetCore.Mvc;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Scripting;
using Microsoft.Playwright;
using Shared.Models.CSharpGlobals;
using Shared.Models.SISI.NextHUB;
using Shared.PlaywrightCore;
using System.Web;

namespace SISI.Controllers.NextHUB
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("nexthub")]
        async public ValueTask<ActionResult> Index(string plugin, string search, string sort, string cat, string model, int pg = 1)
        {
            if (!AppInit.conf.sisi.NextHUB)
                return OnError("disabled");

            var init = Root.goInit(plugin)?.Clone();
            if (init == null)
                return OnError("init not found", rcache: false);

            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (!string.IsNullOrEmpty(search) && string.IsNullOrEmpty(init.search?.uri))
                return OnError("search disable");

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string memKey = $"nexthub:{plugin}:{search}:{sort}:{cat}:{model}:{pg}";
            if (init.menu?.customs != null)
            {
                foreach (var item in init.menu.customs)
                    memKey += $":{HttpContext.Request.Query[item.arg]}";
            }

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    #region contentParse
                    var contentParse = init.list.contentParse ?? init.contentParse;

                    if (!string.IsNullOrEmpty(search) && init.search?.contentParse != null)
                        contentParse = init.search.contentParse;

                    if (!string.IsNullOrEmpty(model) && init.model?.contentParse != null)
                        contentParse = init.model.contentParse;
                    #endregion

                    #region html
                    string url = $"{init.host}/{(pg == 1 && init.list.firstpage != null ? init.list.firstpage : init.list.uri)}";
                    if (!string.IsNullOrEmpty(search))
                    {
                        string uri = pg == 1 && init.search?.firstpage != null ? init.search.firstpage : init.search?.uri;
                        url = $"{init.host}/{uri}".Replace("{search}", HttpUtility.UrlEncode(search));
                    }
                    else
                    {
                        if (!string.IsNullOrEmpty(sort))
                            url = $"{init.host}/{sort}";
                        else if (!string.IsNullOrEmpty(cat))
                            url = $"{init.host}/{init.menu.formatcat(cat)}";
                        else if (!string.IsNullOrEmpty(model))
                        {
                            url = $"{init.host}/{model}";
                            if (init.model?.uri != null)
                                url = init.model.uri.Replace("{host}", init.host).Replace("{model}", model);
                            else if (init.model?.format != null)
                            {
                                string eval = $"return $\"{init.model.format}\";";
                                url = CSharpEval.BaseExecute<string>(eval, new NxtMenuRoute(init.host, plugin, url, search, cat, sort, model, HttpContext.Request.Query, pg));
                            }
                        }
                        else if (init.menu?.customs != null)
                        {
                            foreach (var c in init.menu.customs)
                            {
                                if (HttpContext.Request.Query.ContainsKey(c.arg))
                                    url = $"{init.host}/{c.format.Replace("{value}", HttpContext.Request.Query[c.arg])}";
                            }
                        }

                        if (init.menu?.route != null)
                        {
                            string goroute(string name)
                            {
                                if (init.menu.route.TryGetValue(name, out string value))
                                    return value;

                                if (init.menu.route.TryGetValue("-", out value))
                                    return value;

                                return string.Empty;
                            }

                            string eval = $"return (cat != null && sort != null) ? $\"{goroute("catsort")}\" : (model != null && sort != null) ? $\"{goroute("modelsort")}\" : model != null ? $\"{goroute("model")}\" : cat != null ? $\"{goroute("cat")}\" : sort != null ? $\"{goroute("sort")}\" : \"{url}\";";
                            url = CSharpEval.BaseExecute<string>(eval, new NxtMenuRoute(init.host, plugin, url, search, cat, sort, model, HttpContext.Request.Query, pg));
                        }
                    }

                    if (init.route?.eval != null)
                        url = CSharpEval.Execute<string>(init.route.eval, new NxtMenuRoute(init.host, plugin, url, search, cat, sort, model, HttpContext.Request.Query, pg));

                    reset:
                    string html = rch.enable ? await rch.Get(url.Replace("{page}", pg.ToString()), httpHeaders(init)) :
                               init.priorityBrowser == "http" ? await Http.Get(url.Replace("{page}", pg.ToString()), headers: httpHeaders(init), proxy: proxy.proxy, timeoutSeconds: init.timeout) :
                               init.list.viewsource ? await PlaywrightBrowser.Get(init, url.Replace("{page}", pg.ToString()), httpHeaders(init), proxy.data, cookies: init.cookies) :
                                                      await ContentAsync(init, url.Replace("{page}", pg.ToString()), httpHeaders(init), proxy.data, search, sort, cat, model, pg);
                    #endregion

                    playlists = goPlaylist(requestInfo, host, contentParse, init, html, plugin);

                    if (playlists == null || playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, rcache: !(init.debug || rch.enable));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(init.cache_time, init: init), inmemory: false);
                }

                var menu = new List<MenuItem>(3);
                bool usedRoute = init.menu?.route != null || init.route?.eval != null;

                #region search
                if (string.IsNullOrEmpty(model) && init.search?.uri != null)
                {
                    menu.Add(new MenuItem()
                    {
                        title = "–ü–æ–∏—Å–∫",
                        search_on = "search_on",
                        playlist_url = $"{host}/nexthub?plugin={plugin}",
                    });
                }
                #endregion

                #region sort
                if (string.IsNullOrEmpty(search) && init.menu?.sort != null)
                {
                    var msort = new MenuItem()
                    {
                        title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {init.menu.sort.FirstOrDefault(i => i.Value.Trim() == sort).Key ?? init.menu.sort.First().Key}",
                        playlist_url = "submenu",
                        submenu = new List<MenuItem>()
                    };

                    string arg = usedRoute && init.menu.bind ? $"&cat={HttpUtility.UrlEncode(cat)}&model={HttpUtility.UrlEncode(model)}" : string.Empty;

                    foreach (var s in init.menu.sort)
                    {
                        msort.submenu.Add(new MenuItem()
                        {
                            title = s.Key,
                            playlist_url = $"{host}/nexthub?plugin={plugin}&sort={HttpUtility.UrlEncode(s.Value.Trim())}" + arg,
                        });
                    }

                    if (msort.submenu.Count > 0)
                        menu.Add(msort);
                }
                #endregion

                #region categories
                if (string.IsNullOrEmpty(search) && string.IsNullOrEmpty(model) && init.menu?.categories != null)
                {
                    var categories = init.menu.categories.Where(i => i.Key != "format");

                    var mcat = new MenuItem()
                    {
                        title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏–∏: {categories.FirstOrDefault(i => i.Value.Trim() == cat).Key ?? "–í—ã–±—Ä–∞—Ç—å"}",
                        playlist_url = "submenu",
                        submenu = new List<MenuItem>()
                    };

                    string arg = usedRoute && init.menu.bind ? $"&sort={HttpUtility.UrlEncode(sort)}" : string.Empty;

                    foreach (var s in categories)
                    {
                        mcat.submenu.Add(new MenuItem()
                        {
                            title = s.Key,
                            playlist_url = $"{host}/nexthub?plugin={plugin}&cat={HttpUtility.UrlEncode(s.Value.Trim())}" + arg,
                        });
                    }

                    if (mcat.submenu.Count > 0)
                        menu.Add(mcat);
                }
                #endregion

                #region custom categories
                if (string.IsNullOrEmpty(search) && string.IsNullOrEmpty(model) && init.menu?.customs != null)
                {
                    foreach (var custom in init.menu.customs)
                    {
                        string argvalue = HttpContext.Request.Query[custom.arg];

                        var mcat = new MenuItem()
                        {
                            title = $"{custom.name}: {custom.submenu.FirstOrDefault(i => i.Value.Trim() == argvalue).Key ?? "–í—ã–±—Ä–∞—Ç—å"}",
                            playlist_url = "submenu",
                            submenu = new List<MenuItem>()
                        };

                        foreach (var s in custom.submenu)
                        {
                            mcat.submenu.Add(new MenuItem()
                            {
                                title = s.Key,
                                playlist_url = $"{host}/nexthub?plugin={plugin}&{custom.arg}={HttpUtility.UrlEncode(s.Value.Trim())}",
                            });
                        }

                        if (mcat.submenu.Count > 0)
                            menu.Add(mcat);
                    }
                }
                #endregion

                #region total_pages
                int total_pages = init.list.total_pages;

                if (search != null && init.search != null)
                    total_pages = init.search.total_pages;

                if (model != null && init.model != null)
                    total_pages = init.model.total_pages;
                #endregion

                return OnResult(playlists, menu.Count == 0 ? null : menu, plugin: init.plugin, total_pages: total_pages);
            });
        }


        #region goPlaylist
        public static List<PlaylistItem> goPlaylist(in RequestModel requestInfo, string host, ContentParseSettings parse, NxtSettings init, in string html, string plugin)
        {
            if (parse == null || string.IsNullOrEmpty(html))
                return null;

            if (init.debug)
                Console.WriteLine(html);

            var doc = new HtmlDocument();
            doc.LoadHtml(html);

            string eval = parse.eval;
            if (!string.IsNullOrEmpty(eval) && eval.EndsWith(".cs"))
                eval = FileCache.ReadAllText($"NextHUB/sites/{eval}");

            if (string.IsNullOrEmpty(parse.nodes))
            {
                if (string.IsNullOrEmpty(eval))
                    return null;

                var options = ScriptOptions.Default
                    .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                    .AddImports("Shared.Models.SISI.Base")
                    .AddImports("Shared.Models.SISI")
                    .AddReferences(CSharpEval.ReferenceFromFile("HtmlAgilityPack.dll"))
                    .AddImports("HtmlAgilityPack");

                return CSharpEval.Execute<List<PlaylistItem>>(eval, new NxtPlaylist(init, plugin, host, html, doc, new List<PlaylistItem>()), options);
            }

            var nodes = doc.DocumentNode.SelectNodes(parse.nodes);
            if (nodes == null || nodes.Count == 0)
                return null;

            var playlists = new List<PlaylistItem>(nodes.Count);

            foreach (var row in nodes)
            {
                #region nodeValue
                string nodeValue(SingleNodeSettings nd)
                {
                    string value = null;

                    if (nd != null)
                    {
                        if (string.IsNullOrEmpty(nd.node) && (!string.IsNullOrEmpty(nd.attribute) || nd.attributes != null))
                        {
                            if (nd.attributes != null)
                            {
                                foreach (var attr in nd.attributes)
                                {
                                    var attrValue = row.GetAttributeValue(attr, null);
                                    if (!string.IsNullOrEmpty(attrValue))
                                    {
                                        value = attrValue;
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                value = row.GetAttributeValue(nd.attribute, null);
                            }
                        }
                        else
                        {
                            var inNode = row.SelectSingleNode(nd.node);
                            if (inNode != null)
                            {
                                if (nd.attributes != null)
                                {
                                    foreach (var attr in nd.attributes)
                                    {
                                        var attrValue = inNode.GetAttributeValue(attr, null);
                                        if (!string.IsNullOrEmpty(attrValue))
                                        {
                                            value = attrValue;
                                            break;
                                        }
                                    }
                                }
                                else
                                {
                                    value = (!string.IsNullOrEmpty(nd.attribute) ? inNode.GetAttributeValue(nd.attribute, null) : inNode.InnerText)?.Trim();
                                }
                            }
                        }
                    }

                    if (string.IsNullOrEmpty(value))
                        return null;

                    if (nd.format != null)
                        return CSharpEval.BaseExecute<string>($"return $\"{nd.format}\";", new NxtNodeValue(value, host));

                    return value;
                }
                #endregion

                string name = nodeValue(parse.name);
                string href = nodeValue(parse.href);
                string img = nodeValue(parse.img);
                string duration = nodeValue(parse.duration);
                string quality = nodeValue(parse.quality);
                string preview = nodeValue(parse.preview);

                #region model
                ModelItem? model = null;
                if (parse.model != null)
                {
                    string mname = nodeValue(parse.model.name);
                    string mhref = nodeValue(parse.model.href);

                    if (!string.IsNullOrEmpty(mname) && !string.IsNullOrEmpty(mhref))
                    {
                        model = new ModelItem()
                        {
                            name = mname,
                            uri = $"nexthub?plugin={plugin}&model={HttpUtility.UrlEncode(mhref)}"
                        };
                    }
                }
                #endregion

                #region args
                string args = string.Empty;

                if (parse.args != null)
                {
                    foreach (var a in parse.args)
                    {
                        string arg = nodeValue(a);
                        if (!string.IsNullOrEmpty(arg))
                            args += $"&{a.name}={HttpUtility.UrlEncode(arg)}";
                    }
                }
                #endregion

                if (init.debug)
                    Console.WriteLine($"\n\nname: {name}\nhref: {href}\nimg: {img}\nduration: {duration}\nquality: {quality}\nmyarg: {args}\n\n{row.OuterHtml}");

                if (!string.IsNullOrWhiteSpace(name) && !string.IsNullOrWhiteSpace(href))
                {
                    #region href
                    if (href.StartsWith("../"))
                        href = $"{init.host}/{href.Replace("../", "")}";
                    else if (href.StartsWith("//"))
                        href = $"https:{href}";
                    else if (href.StartsWith("/"))
                        href = init.host + href;
                    else if (!href.StartsWith("http"))
                        href = $"{init.host}/{href}";
                    #endregion

                    #region img
                    if (img != null)
                    {
                        img = img.Replace("&amp;", "&").Replace("\\", "");

                        if (img.StartsWith("../"))
                            img = $"{init.host}/{img.Replace("../", "")}";
                        else if (img.StartsWith("//"))
                            img = $"https:{img}";
                        else if (img.StartsWith("/"))
                            img = init.host + img;
                        else if (!img.StartsWith("http"))
                            img = $"{init.host}/{img}";
                    }
                    #endregion

                    if (!init.ignore_no_picture && string.IsNullOrEmpty(img))
                        continue;

                    #region preview
                    if (preview != null)
                    {
                        preview = preview.Replace("&amp;", "&").Replace("\\", "");

                        if (preview.StartsWith("../"))
                            preview = $"{init.host}/{preview.Replace("../", "")}";
                        else if (preview.StartsWith("//"))
                            preview = $"https:{preview}";
                        else if (preview.StartsWith("/"))
                            preview = init.host + preview;
                        else if (!preview.StartsWith("http"))
                            preview = $"{init.host}/{preview}";

                        if (init.streamproxy_preview)
                            preview = $"{host}/proxy/{ProxyLink.Encrypt(preview, string.Empty, verifyip: false, ex: DateTime.Now.AddHours(1))}";
                    }
                    #endregion

                    string clearText(string text)
                    {
                        if (string.IsNullOrEmpty(text))
                            return text;

                        text = text.Replace("&nbsp;", "");
                        return Regex.Replace(text, "<[^>]+>", "");
                    }

                    var pl = new PlaylistItem()
                    {
                        name = clearText(name),
                        video = $"nexthub/vidosik?uri={HttpUtility.UrlEncode($"{plugin}_-:-_{href}")}" + args,
                        preview = preview,
                        picture = img,
                        time = clearText(duration),
                        quality = clearText(quality),
                        myarg = args,
                        json = parse.json,
                        related = init.view != null ? init.view.related : false,
                        model = model,
                        bookmark = new Bookmark()
                        {
                            site = "nexthub",
                            href = $"{plugin}_-:-_{href}",
                            image = img
                        }
                    };

                    if (eval != null)
                    {
                        var options = ScriptOptions.Default
                            .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                            .AddImports("Shared.Models.SISI.Base")
                            .AddImports("Shared.Models.SISI")
                            .AddReferences(CSharpEval.ReferenceFromFile("HtmlAgilityPack.dll"))
                            .AddImports("HtmlAgilityPack");

                        pl = CSharpEval.Execute<PlaylistItem>(eval, new NxtChangePlaylis(init, plugin, host, html, nodes, pl, row), options);
                    }

                    if (pl.json == false && (init.streamproxy || (init.geostreamproxy != null && init.geostreamproxy.Contains(requestInfo.Country))))
                        pl.video = $"{host}/proxy/{ProxyLink.Encrypt(pl.video, requestInfo.IP, HeadersModel.Init(init.headers_stream))}";

                    if (pl != null)
                        playlists.Add(pl);
                }
            }

            return playlists;
        }
        #endregion

        #region ContentAsync
        async Task<string> ContentAsync(NxtSettings init, string url, List<HeadersModel> headers, (string ip, string username, string password) proxy, string search, string sort, string cat, string model, int pg)
        {
            try
            {
                var conf = string.IsNullOrEmpty(search) ? init.list : init.search;

                using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                {
                    var page = await browser.NewPageAsync(init.plugin, headers?.ToDictionary(), proxy: proxy, keepopen: init.keepopen).ConfigureAwait(false);
                    if (page == default)
                        return null;

                    if (init.cookies != null)
                        await page.Context.AddCookiesAsync(init.cookies).ConfigureAwait(false);

                    string routeEval = conf.routeEval;
                    if (!string.IsNullOrEmpty(routeEval) && routeEval.EndsWith(".cs"))
                        routeEval = FileCache.ReadAllText($"NextHUB/sites/{routeEval}");

                    await page.RouteAsync("**/*", async route =>
                    {
                        try
                        {
                            #region routeEval
                            if (routeEval != null)
                            {
                                var options = ScriptOptions.Default
                                    .AddReferences(CSharpEval.ReferenceFromFile("Microsoft.Playwright.dll"))
                                    .AddImports("Microsoft.Playwright");

                                bool _next = await CSharpEval.ExecuteAsync<bool>(routeEval, new NxtRoute(route, HttpContext.Request.Query, url, search, sort, cat, model, pg), options);
                                if (!_next)
                                    return;
                            }
                            #endregion

                            if (conf.patternAbort != null && Regex.IsMatch(route.Request.Url, conf.patternAbort, RegexOptions.IgnoreCase))
                            {
                                PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                await route.AbortAsync();
                                return;
                            }

                            if (init.abortMedia || init.fullCacheJS)
                            {
                                if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: init.abortMedia, fullCacheJS: init.fullCacheJS))
                                    return;
                            }
                            else
                            {
                                PlaywrightBase.ConsoleLog($"Playwright: {route.Request.Method} {route.Request.Url}");
                            }

                            await browser.ClearContinueAsync(route, page);
                        }
                        catch (Exception ex) { PlaywrightBase.ConsoleLog(ex.Message); }
                    });

                    string content = null;
                    PlaywrightBase.GotoAsync(page, url);

                    if (!string.IsNullOrEmpty(conf.waitForSelector))
                    {
                        try
                        {
                            await page.WaitForSelectorAsync(conf.waitForSelector, new PageWaitForSelectorOptions
                            {
                                Timeout = conf.waitForSelector_timeout

                            }).ConfigureAwait(false);
                        }
                        catch { }

                        content = await page.ContentAsync().ConfigureAwait(false);
                    }
                    else
                    {
                        await page.WaitForLoadStateAsync(LoadState.NetworkIdle, new PageWaitForLoadStateOptions() { Timeout = 20_000 }).ConfigureAwait(false);
                        content = await page.ContentAsync().ConfigureAwait(false);
                    }

                    PlaywrightBase.WebLog("GET", url, content, proxy);
                    return content;
                }
            }
            catch
            {
                return null;
            }
        }
        #endregion
    }
}

```

## File: SISI/Controllers/NextHUB/Root.cs
```
Ôªøusing Microsoft.CodeAnalysis.Scripting;
using YamlDotNet.Serialization;
using Shared.Models.SISI.NextHUB;

namespace SISI.Controllers.NextHUB
{
    public static class Root
    {
        #region evalOptionsFull
        public static ScriptOptions evalOptionsFull = ScriptOptions.Default

            .AddReferences(CSharpEval.ReferenceFromFile("Microsoft.Playwright.dll"))
            .AddImports("Microsoft.Playwright")

            .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
            .AddImports("Shared.PlaywrightCore")
            .AddImports("Shared.Engine")
            .AddImports("Shared.Models.SISI.Base")
            .AddImports("Shared.Models.SISI")

            .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll"))
            .AddImports("Newtonsoft.Json")
            .AddImports("Newtonsoft.Json.Linq");
        #endregion

        public static NxtSettings goInit(string plugin)
        {
            if (string.IsNullOrEmpty(plugin))
                return null;

            if (AppInit.conf.sisi.NextHUB_sites_enabled != null && !AppInit.conf.sisi.NextHUB_sites_enabled.Contains(plugin))
                return null;

            if (!File.Exists($"NextHUB/sites/{plugin}.yaml"))
                return null;

            var hybridCache = new HybridCache();

            string memKey = $"NextHUB:goInit:{plugin}";
            if (!hybridCache.TryGetValue(memKey, out NxtSettings init))
            {
                var deserializer = new DeserializerBuilder().Build();

                // –ß—Ç–µ–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ YAML-—Ñ–∞–π–ª–∞
                string yaml = File.ReadAllText($"NextHUB/sites/{plugin}.yaml");
                var target = deserializer.Deserialize<Dictionary<object, object>>(yaml);

                foreach (string y in new string[] { "_", plugin })
                {
                    if (File.Exists($"NextHUB/override/{y}.yaml"))
                    {
                        // –ß—Ç–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ YAML-—Ñ–∞–π–ª–∞
                        string myYaml = File.ReadAllText($"NextHUB/override/{y}.yaml");
                        var mySource = deserializer.Deserialize<Dictionary<object, object>>(myYaml);

                        // –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–ª–æ–≤–∞—Ä–µ–π
                        foreach (var property in mySource)
                        {
                            if (!target.ContainsKey(property.Key))
                            {
                                target[property.Key] = property.Value;
                                continue;
                            }

                            if (property.Value is IDictionary<object, object> sourceDict &&
                                target[property.Key] is IDictionary<object, object> targetDict)
                            {
                                // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö —Å–ª–æ–≤–∞—Ä–µ–π
                                foreach (var item in sourceDict)
                                    targetDict[item.Key] = item.Value;
                            }
                            else
                            {
                                target[property.Key] = property.Value;
                            }
                        }
                    }
                }

                // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å–ª–æ–≤–∞—Ä—è –≤ –æ–±—ä–µ–∫—Ç NxtSettings
                var serializer = new SerializerBuilder().Build();

                var yamlResult = serializer.Serialize(target);
                init = deserializer.Deserialize<NxtSettings>(yamlResult);

                if (string.IsNullOrEmpty(init.plugin))
                    init.plugin = init.displayname;

                if (!init.debug || !AppInit.conf.multiaccess)
                {
                    init = ModuleInvoke.Init(plugin, init);
                    hybridCache.Set(memKey, init, DateTime.Now.AddMinutes(1), inmemory: true);
                }
            }

            return init;
        }
    }
}

```

## File: SISI/Controllers/NextHUB/ViewController.cs
```
Ôªøusing HtmlAgilityPack;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Routing;
using Microsoft.CodeAnalysis.Scripting;
using Microsoft.Playwright;
using Newtonsoft.Json;
using Shared.Models.CSharpGlobals;
using Shared.PlaywrightCore;
using System.Net;
using Shared.Models.SISI.NextHUB;

namespace SISI.Controllers.NextHUB
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("nexthub/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            if (!AppInit.conf.sisi.NextHUB)
                return OnError("disabled");

            string plugin = uri.Split("_-:-_")[0];
            string url = uri.Split("_-:-_")[1];

            var init = Root.goInit(plugin)?.Clone();
            if (init == null)
                return OnError("init not found");

            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (init.view.initUrlEval != null)
                url = CSharpEval.Execute<string>(init.view.initUrlEval, new NxtUrlRequest(init.host, plugin, url, HttpContext.Request.Query, related));

            return await InvkSemaphore($"nexthub:InvkSemaphore:{url}", async () =>
            {
                (string file, List<HeadersModel> headers, List<PlaylistItem> recomends) video = default;
                if ((init.view.priorityBrowser ?? init.priorityBrowser) == "http" && init.view.viewsource &&
                    (init.view.nodeFile != null || init.view.eval != null || init.view.regexMatch != null) &&
                     init.view.routeEval == null && init.cookies == null && init.view.evalJS == null)
                {
                    reset: video = await goVideoToHttp(rch, plugin, url, init, proxyManager, proxy.proxy);
                    if (string.IsNullOrEmpty(video.file))
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("file", rcache: !rch.enable);
                    }
                }
                else
                {
                    video = await goVideoToBrowser(plugin, url, init, proxyManager, proxy.data);
                    if (string.IsNullOrEmpty(video.file))
                        return OnError("file");
                }

                var stream_links = new StreamItem()
                {
                    qualitys = new Dictionary<string, string>()
                    {
                        ["auto"] = video.file
                    },
                    recomends = video.recomends
                };

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy.proxy, headers_stream: httpHeaders(init.host, init.headers_stream != null ? init.headers_stream : init.headers_stream));
            });
        }


        #region goVideoToBrowser
        async ValueTask<(string file, List<HeadersModel> headers, List<PlaylistItem> recomends)> goVideoToBrowser(string plugin, string url, NxtSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(url))
                return default;

            try
            {
                string memKey = $"nexthub:view18:goVideo:{url}";
                if (init.view.bindingToIP)
                    memKey += $":{proxyManager.CurrentProxyIp}";

                if (!hybridCache.TryGetValue(memKey, out (string file, List<HeadersModel> headers, List<PlaylistItem> recomends) cache))
                {
                    using (var browser = new PlaywrightBrowser(init.view.priorityBrowser ?? init.priorityBrowser))
                    {
                        var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy, keepopen: init.view.keepopen, deferredDispose: init.view.playbtn != null).ConfigureAwait(false);
                        if (page == default)
                            return default;

                        if (init.cookies != null)
                            await page.Context.AddCookiesAsync(init.cookies).ConfigureAwait(false);

                        if (!string.IsNullOrEmpty(init.view.addInitScript))
                            await page.AddInitScriptAsync(init.view.addInitScript).ConfigureAwait(false);

                        string routeEval = init.view.routeEval;
                        if (!string.IsNullOrEmpty(routeEval) && routeEval.EndsWith(".cs"))
                            routeEval = FileCache.ReadAllText($"NextHUB/sites/{routeEval}");

                        #region RouteAsync
                        await page.RouteAsync("**/*", async route =>
                        {
                            try
                            {
                                if (browser.IsCompleted || (init.view.patternAbort != null && Regex.IsMatch(route.Request.Url, init.view.patternAbort, RegexOptions.IgnoreCase)))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }

                                #region routeEval
                                if (routeEval != null)
                                {
                                    var options = ScriptOptions.Default
                                        .AddReferences(CSharpEval.ReferenceFromFile("Microsoft.Playwright.dll"))
                                        .AddImports("Microsoft.Playwright");

                                    bool _next = await CSharpEval.ExecuteAsync<bool>(routeEval, new NxtRoute(route, HttpContext.Request.Query, url, null, null, null, null, 0), options);
                                    if (!_next)
                                        return;
                                }
                                #endregion

                                #region patternFile
                                if (init.view.patternFile != null && Regex.IsMatch(route.Request.Url, init.view.patternFile, RegexOptions.IgnoreCase))
                                {
                                    if (init.view.waitForResponse)
                                    {
                                        string result = null;
                                        await browser.ClearContinueAsync(route, page);
                                        var response = await page.WaitForResponseAsync(route.Request.Url);
                                        if (response != null)
                                            result = await response.TextAsync().ConfigureAwait(false);

                                        PlaywrightBase.ConsoleLog($"\nPlaywright: {result}\n");
                                        browser.SetPageResult(result);
                                    }
                                    else
                                    {
                                        void setHeaders(Dictionary<string, string> _headers)
                                        {
                                            if (_headers != null && _headers.Count > 0)
                                            {
                                                cache.headers = new List<HeadersModel>(_headers.Count);
                                                foreach (var item in _headers)
                                                {
                                                    if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                                        continue;

                                                    cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                                }
                                            }
                                        }

                                        setHeaders(route.Request.Headers);

                                        if (init.view.waitLocationFile)
                                        {
                                            await browser.ClearContinueAsync(route, page);
                                            string setUri = route.Request.Url;

                                            var response = await page.WaitForResponseAsync(route.Request.Url);
                                            if (response != null && response.Headers.ContainsKey("location"))
                                            {
                                                setHeaders(response.Request.Headers);
                                                setUri = response.Headers["location"];
                                            }

                                            if (setUri.StartsWith("//"))
                                                setUri = $"{(init.host.StartsWith("https") ? "https" : "http")}:{setUri}";

                                            PlaywrightBase.ConsoleLog($"\nPlaywright: SET {setUri}\n{JsonConvert.SerializeObject(cache.headers.ToDictionary(), Formatting.Indented)}\n");
                                            browser.SetPageResult(setUri);
                                        }
                                        else
                                        {
                                            PlaywrightBase.ConsoleLog($"\nPlaywright: SET {route.Request.Url}\n{JsonConvert.SerializeObject(cache.headers.ToDictionary(), Formatting.Indented)}\n");
                                            browser.SetPageResult(route.Request.Url);
                                            await route.AbortAsync();
                                        }
                                    }

                                    return;
                                }
                                #endregion

                                #region patternAbortEnd
                                if (init.view.patternAbortEnd != null && Regex.IsMatch(route.Request.Url, init.view.patternAbortEnd, RegexOptions.IgnoreCase))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }
                                #endregion

                                #region patternWhiteRequest
                                if (init.view.patternWhiteRequest != null && route.Request.Url != url && !Regex.IsMatch(route.Request.Url, init.view.patternWhiteRequest, RegexOptions.IgnoreCase))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }
                                #endregion

                                #region abortMedia
                                if (init.view.abortMedia || init.view.fullCacheJS)
                                {
                                    if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: init.view.abortMedia, fullCacheJS: init.view.fullCacheJS))
                                        return;
                                }
                                else
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: {route.Request.Method} {route.Request.Url}");
                                }
                                #endregion

                                await browser.ClearContinueAsync(route, page);
                            }
                            catch { }
                        });
                        #endregion

                        #region GotoAsync
                        resetGotoAsync: string html = null;
                        var responce = await page.GotoAsync(init.view.viewsource ? $"view-source:{url}" : url, new PageGotoOptions() 
                        {
                            Timeout = 10_000,
                            WaitUntil = WaitUntilState.DOMContentLoaded 
                        }).ConfigureAwait(false);

                        if (responce != null)
                            html = await responce.TextAsync().ConfigureAwait(false);
                        #endregion

                        if (init.view.waitForResponse)
                            html = await browser.WaitPageResult().ConfigureAwait(false);

                        #region WaitForSelector
                        if (!string.IsNullOrEmpty(init.view.waitForSelector) || !string.IsNullOrEmpty(init.view.playbtn))
                        {
                            try
                            {
                                await page.WaitForSelectorAsync(init.view.waitForSelector ?? init.view.playbtn, new PageWaitForSelectorOptions
                                {
                                    Timeout = init.view.waitForSelector_timeout

                                }).ConfigureAwait(false);
                            }
                            catch { }

                            html = await page.ContentAsync().ConfigureAwait(false);
                        }
                        #endregion

                        #region iframe
                        if (init.view.iframe != null && url.Contains(init.host))
                        {
                            string iframeUrl = CSharpEval.Execute<string>(evalCodeToRegexMatch(init.view.iframe), new NxtRegexMatch(html, init.view.iframe));
                            if (!string.IsNullOrEmpty(iframeUrl) && iframeUrl != url)
                            {
                                url = init.view.iframe.format != null ? init.view.iframe.format.Replace("{value}", iframeUrl) : iframeUrl;
                                goto resetGotoAsync;
                            }
                        }
                        #endregion

                        if (!string.IsNullOrEmpty(init.view.playbtn))
                            await page.ClickAsync(init.view.playbtn).ConfigureAwait(false);

                        if (init.view.nodeFile != null)
                        {
                            #region nodeFile
                            string goFile(string _content)
                            {
                                if (!string.IsNullOrEmpty(_content))
                                {
                                    var doc = new HtmlDocument();
                                    doc.LoadHtml(_content);
                                    var videoNode = doc.DocumentNode.SelectSingleNode(init.view.nodeFile.node);
                                    if (videoNode != null)
                                        return (!string.IsNullOrEmpty(init.view.nodeFile.attribute) ? videoNode.GetAttributeValue(init.view.nodeFile.attribute, null) : videoNode.InnerText)?.Trim();
                                }

                                return null;
                            }

                            if (init.view.NetworkIdle)
                            {
                                for (int i = 0; i < 10; i++)
                                {
                                    cache.file = goFile(await page.ContentAsync().ConfigureAwait(false));
                                    if (!string.IsNullOrEmpty(cache.file))
                                        break;

                                    PlaywrightBase.ConsoleLog("ContentAsync: " + (i + 1));
                                    await Task.Delay(800).ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                cache.file = goFile(html);
                            }

                            PlaywrightBase.ConsoleLog($"Playwright: SET {cache.file}");
                            #endregion
                        }
                        else if (init.view.regexMatch != null)
                        {
                            #region regexMatch
                            if (init.view.NetworkIdle)
                            {
                                for (int i = 0; i < 10; i++)
                                {
                                    cache.file = CSharpEval.Execute<string>(evalCodeToRegexMatch(init.view.regexMatch), new NxtRegexMatch(html, init.view.regexMatch));
                                    if (!string.IsNullOrEmpty(cache.file) && init.view.regexMatch.format != null)
                                        cache.file = init.view.regexMatch.format.Replace("{value}", cache.file).Replace("{host}", init.host);

                                    if (!string.IsNullOrEmpty(cache.file))
                                        break;

                                    PlaywrightBase.ConsoleLog("ContentAsync: " + (i + 1));
                                    await Task.Delay(800).ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                cache.file = CSharpEval.Execute<string>(evalCodeToRegexMatch(init.view.regexMatch), new NxtRegexMatch(html, init.view.regexMatch));
                                if (!string.IsNullOrEmpty(cache.file) && init.view.regexMatch.format != null)
                                    cache.file = init.view.regexMatch.format.Replace("{value}", cache.file).Replace("{host}", init.host);
                            }

                            PlaywrightBase.ConsoleLog($"Playwright: SET {cache.file}");
                            #endregion
                        }
                        else if (string.IsNullOrEmpty(init.view.eval ?? init.view.evalJS))
                        {
                            cache.file = await browser.WaitPageResult().ConfigureAwait(false);
                        }

                        cache.file = cache.file?.Replace("\\", "")?.Replace("&amp;", "&");

                        #region eval
                        if (!string.IsNullOrEmpty(init.view.eval ?? init.view.evalJS))
                        {
                            Task<string> goFile(string _content)
                            {
                                if (!string.IsNullOrEmpty(_content))
                                {
                                    string infile = $"NextHUB/sites/{init.view.eval ?? init.view.evalJS}";
                                    if ((infile.EndsWith(".cs") || infile.EndsWith(".js")) && System.IO.File.Exists(infile))
                                    {
                                        string evaluate = FileCache.ReadAllText(infile);

                                        if (infile.EndsWith(".js"))
                                            return page.EvaluateAsync<string>($"(html, plugin, url, file) => {{ {evaluate} }}", new { _content, plugin, url, cache.file });

                                        var nxt = new NxtEvalView(init, HttpContext.Request.Query, _content, plugin, url, cache.file, cache.headers, proxyManager);
                                        return CSharpEval.ExecuteAsync<string>(goEval(evaluate), nxt, Root.evalOptionsFull);
                                    }
                                    else
                                    {
                                        if (init.view.evalJS != null)
                                            return page.EvaluateAsync<string>($"(html, plugin, url, file) => {{ {init.view.evalJS} }}", new { _content, plugin, url, cache.file });

                                        var nxt = new NxtEvalView(init, HttpContext.Request.Query, _content, plugin, url, cache.file, cache.headers, proxyManager);
                                        return CSharpEval.ExecuteAsync<string>(goEval(init.view.eval), nxt, Root.evalOptionsFull);
                                    }
                                }

                                return null;
                            }

                            if (init.view.NetworkIdle)
                            {
                                for (int i = 0; i < 10; i++)
                                {
                                    cache.file = await goFile(await page.ContentAsync().ConfigureAwait(false)).ConfigureAwait(false);
                                    if (!string.IsNullOrEmpty(cache.file))
                                        break;

                                    PlaywrightBase.ConsoleLog("ContentAsync: " + (i + 1));
                                    await Task.Delay(800).ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                cache.file = await goFile(html).ConfigureAwait(false);
                            }

                            PlaywrightBase.ConsoleLog($"Playwright: SET {cache.file}");
                        }
                        #endregion

                        if (string.IsNullOrEmpty(cache.file))
                        {
                            proxyManager.Refresh();
                            return default;
                        }

                        if (cache.file.StartsWith("GotoAsync:"))
                        {
                            url = cache.file.Replace("GotoAsync:", "").Trim();
                            goto resetGotoAsync;
                        }

                        #region related
                        if (init.view.related && cache.recomends == null)
                        {
                            if (init.view.NetworkIdle)
                            {
                                string contetnt = await page.ContentAsync().ConfigureAwait(false);
                                cache.recomends = ListController.goPlaylist(requestInfo, host, init.view.relatedParse ?? init.contentParse, init, contetnt, plugin);
                            }
                            else
                            {
                                cache.recomends = ListController.goPlaylist(requestInfo, host, init.view.relatedParse ?? init.contentParse, init, html, plugin);
                            }
                        }
                        #endregion
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(init.view.cache_time, init: init));
                }

                return cache;
            }
            catch (Exception ex)
            {
                if (init.debug)
                    Console.WriteLine(ex);

                return default; 
            }
        }
        #endregion

        #region goVideoToHttp
        async ValueTask<(string file, List<HeadersModel> headers, List<PlaylistItem> recomends)> goVideoToHttp(RchClient rch, string plugin, string url, NxtSettings init, ProxyManager proxyManager, WebProxy proxy)
        {
            if (string.IsNullOrEmpty(url))
                return default;

            try
            {
                string memKey = $"nexthub:view18:goVideo:{url}";

                if (init.view.bindingToIP)
                    memKey = rch.ipkey(memKey, proxyManager);

                if (!hybridCache.TryGetValue(memKey, out (string file, List<HeadersModel> headers, List<PlaylistItem> recomends) cache))
                {
                    resetGotoAsync:
                    string html = rch.enable ? await rch.Get(url, httpHeaders(init)) :
                                               await Http.Get(url, headers: httpHeaders(init), proxy: proxy, timeoutSeconds: 8);

                    if (string.IsNullOrEmpty(html))
                        return default;

                    #region iframe
                    if (init.view.iframe != null && url.Contains(init.host))
                    {
                        string iframeUrl = CSharpEval.Execute<string>(evalCodeToRegexMatch(init.view.iframe), new NxtRegexMatch(html, init.view.iframe));
                        if (!string.IsNullOrEmpty(iframeUrl) && iframeUrl != url)
                        {
                            url = init.view.iframe.format != null ? init.view.iframe.format.Replace("{value}", iframeUrl) : iframeUrl;
                            goto resetGotoAsync;
                        }
                    }
                    #endregion

                    if (init.view.nodeFile != null)
                    {
                        #region nodeFile
                        string goFile(string _content)
                        {
                            var doc = new HtmlDocument();
                            doc.LoadHtml(_content);
                            var videoNode = doc.DocumentNode.SelectSingleNode(init.view.nodeFile.node);
                            if (videoNode != null)
                                return (!string.IsNullOrEmpty(init.view.nodeFile.attribute) ? videoNode.GetAttributeValue(init.view.nodeFile.attribute, null) : videoNode.InnerText)?.Trim();

                            return null;
                        }

                        cache.file = goFile(html);

                        PlaywrightBase.ConsoleLog($"Playwright: SET {cache.file}");
                        #endregion
                    }
                    else if (init.view.regexMatch != null)
                    {
                        #region regexMatch
                        cache.file = CSharpEval.Execute<string>(evalCodeToRegexMatch(init.view.regexMatch), new NxtRegexMatch(html, init.view.regexMatch));
                        if (!string.IsNullOrEmpty(cache.file) && init.view.regexMatch.format != null)
                            cache.file = init.view.regexMatch.format.Replace("{value}", cache.file).Replace("{host}", init.host);

                        PlaywrightBase.ConsoleLog($"Playwright: SET {cache.file}");
                        #endregion
                    }

                    cache.file = cache.file?.Replace("\\", "")?.Replace("&amp;", "&");

                    #region eval
                    if (!string.IsNullOrEmpty(init.view.eval))
                    {
                        var nxt = new NxtEvalView(init, HttpContext.Request.Query, html, plugin, url, cache.file, cache.headers, proxyManager);
                        cache.file = await CSharpEval.ExecuteAsync<string>(goEval(init.view.eval), nxt, Root.evalOptionsFull).ConfigureAwait(false);

                        PlaywrightBase.ConsoleLog($"Playwright: SET {cache.file}");
                    }
                    #endregion

                    if (string.IsNullOrEmpty(cache.file))
                    {
                        if (!rch.enable)
                            proxyManager.Refresh();

                        return default;
                    }

                    if (cache.file.StartsWith("GotoAsync:"))
                    {
                        url = cache.file.Replace("GotoAsync:", "").Trim();
                        goto resetGotoAsync;
                    }

                    if (init.view.related && cache.recomends == null)
                        cache.recomends = ListController.goPlaylist(requestInfo, host, init.view.relatedParse ?? init.contentParse, init, html, plugin);

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, cache, cacheTime(init.view.cache_time, init: init));
                }

                return cache;
            }
            catch (Exception ex)
            {
                if (init.debug)
                    Console.WriteLine(ex);

                return default;
            }
        }
        #endregion


        #region evalCodeToRegexMatch
        static string evalCodeToRegexMatch(RegexMatchSettings rm)
        {
            return @"if (m.matches != null && m.matches.Length > 0)
            {
                foreach (string q in m.matches)
                {
                    string file = Regex.Match(html, m.pattern.Replace(""{value}"", $""{q}""), RegexOptions.IgnoreCase).Groups[m.index].Value;
                    if (!string.IsNullOrEmpty(file))
                        return file;
                }
                return null;
            }

            return Regex.Match(html, m.pattern, RegexOptions.IgnoreCase).Groups[m.index].Value;";
        }
        #endregion

        #region goEval
        static string goEval(string evalcode)
        {
            string infile = $"NextHUB/sites/{evalcode}";
            if (infile.EndsWith(".cs") && System.IO.File.Exists(infile))
                evalcode = FileCache.ReadAllText(infile);

            if (evalcode.Contains("{include:"))
            {
                string includePattern = @"{include:(?<file>[^}]+)}";
                var matches = Regex.Matches(evalcode, includePattern);
                foreach (Match match in matches)
                {
                    string file = match.Groups["file"].Value.Trim();
                    if (System.IO.File.Exists($"NextHUB/utils/{file}"))
                    {
                        string includeCode = FileCache.ReadAllText($"NextHUB/utils/{file}");
                        evalcode = evalcode.Replace(match.Value, includeCode);
                    }
                }
            }

            return evalcode;
        }
        #endregion
    }
}

```

## File: SISI/Controllers/BongaCams/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.PlaywrightCore;

namespace SISI.Controllers.BongaCams
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("bgs")]
        async public ValueTask<ActionResult> Index(string search, string sort, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.BongaCams);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (!string.IsNullOrEmpty(search))
                return OnError("no search", false);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return OnError(rch_error);

            string memKey = $"BongaCams:list:{sort}:{pg}";

            return await InvkSemaphore(memKey, async () => 
            {
                if (!hybridCache.TryGetValue(memKey, out (List<PlaylistItem> playlists, int total_pages) cache, inmemory: false))
                {
                    reset: string html = await BongaCamsTo.InvokeHtml(init.corsHost(), sort, pg, url =>
                    {
                        if (rch.enable)
                            return rch.Get(init.cors(url), httpHeaders(init));

                        if (init.priorityBrowser == "http")
                            return Http.Get(url, httpversion: 2, timeoutSeconds: 8, headers: httpHeaders(init), proxy: proxy.proxy);

                        return PlaywrightBrowser.Get(init, url, httpHeaders(init), proxy.data);
                    });

                    cache.playlists = BongaCamsTo.Playlist(html, out int total_pages);
                    cache.total_pages = total_pages;

                    if (cache.playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, cache, cacheTime(5, init: init), inmemory: false);
                }

                return OnResult(cache.playlists, init, BongaCamsTo.Menu(host, sort), proxy: proxy.proxy, total_pages: cache.total_pages);
            });
        }
    }
}

```

## File: SISI/Controllers/BongaCams/StreamController.cs
```
Ôªø//using System;
//using System.Collections.Generic;
//using System.Threading.Tasks;
//using Lampac.Engine;
//using Lampac.Engine.CORE;
//using Lampac.Model.SISI.BongaCams;
//using Microsoft.AspNetCore.Mvc;
//using Microsoft.Extensions.Caching.Memory;

//namespace SISI.Controllers.BongaCams
//{
//    public class StreamController : BaseController
//    {
//        [HttpGet]
//        [Route("bgs/potok.m3u8")]
//        async public Task<ActionResult> Index(string baba)
//        {
//            if (!AppInit.conf.BongaCams.enable)
//                return OnError("disable");

//            string memKey = $"bongacams:stream:{baba}";
//            if (memoryCache.TryGetValue(memKey, out string hls))
//                return Redirect(HostStreamProxy(AppInit.conf.BongaCams.streamproxy, hls));

//            var root = await HttpClient.Post<Amf>(
//                       $"{AppInit.conf.BongaCams.host}/tools/amf.php?x-country=ua&res=1061112?{DateTimeOffset.UtcNow.ToUnixTimeSeconds()}", $"method=getRoomData&args%5B%5D={baba}&args%5B%5D=&args%5B%5D=",
//                       useproxy: AppInit.conf.BongaCams.useproxy,
//                       addHeaders: new List<(string name, string val)>()
//            {
//                ("dnt", "1"),
//                //("referer", AppInit.conf.BongaCams.host),
//                ("sec-fetch-dest", "empty"),
//                ("sec-fetch-mode", "cors"),
//                ("sec-fetch-site", "same-origin"),
//                ("x-requested-with", "XMLHttpRequest"),
//                ("x-ab-split-group", "5645da7355b7d0ac0590e38a54d1d996f6754e425c1709e4420e1c68d90620315932e5bef13fd38e"),
//                //("cookie", "bonga20120608=dcf21cf81fc13991e8f999c26126a857; ts_type2=1; fv=ZGR5BGL0AGV2ZD==; uh=GH5AAJMvIy9bLzkmDaSZsyOTsxg6Zt==; sg=501; BONGA_REF=https%3A%2F%2Fwww.google.com%2F; reg_ver2=3; warning18=%5B%22ru_RU%22%5D; __ti=H4sIAAAAAAACAyWIOw6AIBBEr2KmJ9ldIcbZ05BIQa3BgnB3Fav3GcNhymQUXZKETYKaGLgrT8cBTt6lNjB-ev3LWB1teufK7FGVtb-dHxKMhapUAAAA; __asc=6527103917a758e97aa2f42fa81; __auc=6527103917a758e97aa2f42fa81; _ga=GA1.2.901307154.1625469917; _gid=GA1.2.1041270203.1625469917; _gat_gtag_UA_10874655_24=1; _gat_gtag_UA_10874655_62=1; tj0ffcjy9e=1802827793"),
//            });

//            if (string.IsNullOrWhiteSpace(root?.localData?.videoServerUrl))
//                return OnError("baba");

//            hls = $"http:{root.localData.videoServerUrl}/hls/stream_{baba}/public-aac/stream_{baba}/chunks.m3u8";
//            memoryCache.Set(memKey, hls, DateTime.Now.AddMinutes(AppInit.conf.multiaccess ? 10 : 5));

//            return Redirect(HostStreamProxy(AppInit.conf.BongaCams.streamproxy, hls));
//        }
//    }
//}

```

## File: SISI/Controllers/Porntrex/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Porntrex
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("ptx")]
        async public ValueTask<ActionResult> Index(string search, string sort, string c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Porntrex);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return OnError(rch_error);

            string memKey = $"ptx:{search}:{sort}:{c}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    string html = await PorntrexTo.InvokeHtml(init.corsHost(), search, sort, c, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    playlists = PorntrexTo.Playlist("ptx/vidosik", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(playlists, PorntrexTo.Menu(host, search, sort, c), headers: HeadersModel.Init("referer", $"{init.host}/"), plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Porntrex/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using System.Web;

namespace SISI.Controllers.Porntrex
{
    public class ViewController : BaseSisiController
    {
        ProxyManager proxyManager = new ProxyManager("ptx", AppInit.conf.Porntrex);

        [HttpGet]
        [Route("ptx/vidosik")]
        async public ValueTask<ActionResult> vidosik(string uri)
        {
            var init = await loadKit(AppInit.conf.Porntrex);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: init.apnstream ? -1 : null);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return OnError(rch_error);

            string memKey = rch.ipkey($"porntrex:view:{uri}", proxyManager);

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out (Dictionary<string, string> links, bool userch) cache))
                {
                    reset:
                    cache.links = await PorntrexTo.StreamLinks(init.corsHost(), uri, url =>
                    {
                        if (rch.enable)
                            return rch.Get(init.cors(url), httpHeaders(init));

                        return Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxyManager.Get(), headers: httpHeaders(init));
                    });

                    if (cache.links == null || cache.links.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    cache.userch = rch.enable;
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                if (cache.userch)
                {
                    var hdstr = httpHeaders(init.host, init.headers_stream);
                    return OnResult(cache.links, init, proxyManager.Get(), headers_stream: hdstr);
                }

                return Json(cache.links.ToDictionary(k => k.Key, v => $"{host}/ptx/strem?link={HttpUtility.UrlEncode(v.Value)}"));
            });
        }


        [HttpGet]
        [Route("ptx/strem")]
        async public ValueTask<ActionResult> strem(string link)
        {
            var init = await loadKit(AppInit.conf.Porntrex);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (init.rhub && !init.rhub_fallback)
                return OnError("rhub_fallback");

            var proxy = proxyManager.Get();

            string memKey = $"Porntrex:strem:{link}:{proxyManager.CurrentProxyIp}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out string location))
                {
                    location = await Http.GetLocation(link, timeoutSeconds: 10, httpversion: 2, proxy: proxy, headers: httpHeaders(init, HeadersModel.Init(
                        ("sec-fetch-dest", "document"),
                        ("sec-fetch-mode", "navigate"),
                        ("sec-fetch-site", "none")
                    )));

                    if (string.IsNullOrEmpty(location) || link == location)
                        return OnError("location", proxyManager);

                    proxyManager.Success();
                    hybridCache.Set(memKey, location, cacheTime(40, init: init));
                }

                return Redirect(HostStreamProxy(init, location, proxy: proxy));
            });
        }
    }
}

```

## File: SISI/Controllers/Ebalovo/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Ebalovo
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("elo")]
        async public ValueTask<ActionResult> Index(string search, string sort, string c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Ebalovo);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"elo:{search}:{sort}:{c}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    var headers = httpHeaders(init, HeadersModel.Init(
                        ("sec-fetch-dest", "document"),
                        ("sec-fetch-mode", "navigate"),
                        ("sec-fetch-site", "same-origin"),
                        ("sec-fetch-user", "?1"),
                        ("upgrade-insecure-requests", "1")
                    ));

                    string ehost = await RootController.goHost(init.corsHost(), proxy);

                    reset:
                    string html = await EbalovoTo.InvokeHtml(ehost, search, sort, c, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), headers) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: headers)
                    );

                    playlists = EbalovoTo.Playlist("elo/vidosik", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(playlists, string.IsNullOrEmpty(search) ? EbalovoTo.Menu(host, sort, c) : null, plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Ebalovo/RootController.cs
```
Ôªøusing System.Net;

namespace SISI.Controllers.Ebalovo
{
    public static class RootController
    {
        async public static ValueTask<string> goHost(string host, WebProxy proxy = null)
        {
            if (!Regex.IsMatch(host, "^https?://www\\."))
                return host;

            var hybridCache = new HybridCache();
            string backhost = "https://web.epalovo.com";

            string memkey = $"ebalovo:gohost:{host}";
            if (hybridCache.TryGetValue(memkey, out string _host, inmemory: true))
                return _host;

            _host = await Http.GetLocation(host, timeoutSeconds: 5, proxy: proxy, allowAutoRedirect: true);
            if (_host != null && !Regex.IsMatch(_host, "^https?://www\\."))
            {
                _host = Regex.Replace(_host, "/$", "");
                hybridCache.Set(memkey, _host, DateTime.Now.AddHours(1), inmemory: true);
                return _host;
            }
            else
            {
                hybridCache.Set(memkey, backhost, DateTime.Now.AddMinutes(20), inmemory: true);
                return backhost;
            }
        }
    }
}

```

## File: SISI/Controllers/Ebalovo/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Ebalovo
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("elo/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            var init = await loadKit(AppInit.conf.Ebalovo);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return OnError(rch_error);

            if (rch.enable && 484 > rch.InfoConnected()?.apkVersion)
            {
                rch.Disabled(); // –Ω–∞ –≤–µ—Ä—Å–∏—è—Ö –Ω–∏–∂–µ java.lang.OutOfMemoryError
                if (!init.rhub_fallback)
                    return OnError("apkVersion", false);
            }

            string memKey = rch.ipkey($"ebalovo:view:{uri}", proxyManager);

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    string ehost = await RootController.goHost(init.corsHost());

                    reset:
                    stream_links = await EbalovoTo.StreamLinks("elo/vidosik", ehost, uri,
                        url =>
                        {
                            var headers = httpHeaders(init, HeadersModel.Init(
                                ("sec-fetch-dest", "document"),
                                ("sec-fetch-mode", "navigate"),
                                ("sec-fetch-site", "same-origin"),
                                ("sec-fetch-user", "?1"),
                                ("upgrade-insecure-requests", "1")
                            ));

                            return rch.enable ? rch.Get(init.cors(url), headers) : Http.Get(init.cors(url), timeoutSeconds: 8, proxy: proxy, headers: headers);
                        },
                        async location =>
                        {
                            var headers = httpHeaders(init, HeadersModel.Init(
                                ("referer", $"{ehost}/"),
                                ("sec-fetch-dest", "video"),
                                ("sec-fetch-mode", "no-cors"),
                                ("sec-fetch-site", "same-origin")
                            ));

                            if (rch.enable)
                            {
                                var res = await rch.Headers(init.cors(location), null, headers);
                                return res.currentUrl;
                            }

                            return await Http.GetLocation(init.cors(location), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));
                        }
                    );

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: "elo", total_pages: 1);

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/Chaturbate/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Chaturbate
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("chu")]
        async public ValueTask<ActionResult> Index(string search, string sort, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Chaturbate);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (!string.IsNullOrEmpty(search))
                return OnError("no search", false);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"Chaturbate:list:{sort}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset: string html = await ChaturbateTo.InvokeHtml(init.corsHost(), sort, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    playlists = ChaturbateTo.Playlist("chu/potok", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(5, init: init), inmemory: false);
                }

                return OnResult(playlists, ChaturbateTo.Menu(host, sort), plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Chaturbate/StreamController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Chaturbate
{
    public class StreamController : BaseSisiController
    {
        [HttpGet]
        [Route("chu/potok")]
        async public ValueTask<ActionResult> Index(string baba)
        {
            var init = await loadKit(AppInit.conf.Chaturbate);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"chaturbate:stream:{baba}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out Dictionary<string, string> stream_links))
                {
                    reset:
                    stream_links = await ChaturbateTo.StreamLinks(init.corsHost(), baba, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    if (stream_links == null || stream_links.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!init.rhub)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(10, init: init));
                }

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/XvideosRED/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using System.Web;

namespace SISI.Controllers.XvideosRED
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("xdsred")]
        async public ValueTask<ActionResult> Index(string search, string sort, string c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.XvideosRED);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string plugin = init.plugin;
            bool ismain = sort != "like" && string.IsNullOrEmpty(search) && string.IsNullOrEmpty(c);
            string memKey = $"{plugin}:list:{search}:{c}:{sort}:{(ismain ? 0 : pg)}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    var proxyManager = new ProxyManager(init);
                    var proxy = proxyManager.Get();

                    #region –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º url
                    string url;

                    if (!string.IsNullOrEmpty(search))
                    {
                        url = $"{init.corsHost()}/?k={HttpUtility.UrlEncode(search)}&p={pg}&premium=1";
                    }
                    else
                    {
                        if (sort == "like")
                        {
                            url = $"{init.corsHost()}/videos-i-like/{pg - 1}";
                        }
                        else if (!string.IsNullOrEmpty(c))
                        {
                            url = $"{init.corsHost()}/c/s:{(sort == "top" ? "rating" : "uploaddate")}/p:1/{c}/{pg}";
                        }
                        else
                        {
                            url = $"{init.corsHost()}/red/videos/{DateTime.Today.AddDays(-1):yyyy-MM-dd}";
                        }
                    }
                    #endregion

                    string html = await Http.Get(init.cors(url), cookie: init.cookie, timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init));
                    if (html == null)
                        return OnError("html", proxyManager, string.IsNullOrEmpty(search));

                    playlists = XvideosTo.Playlist("xdsred/vidosik", $"{plugin}/stars", html, site: plugin);

                    if (playlists.Count == 0)
                        return OnError("playlists", proxyManager, pg > 1 && string.IsNullOrEmpty(search));

                    proxyManager.Success();
                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                if (ismain)
                    playlists = playlists.Skip((pg * 36) - 36).Take(36).ToList();

                return OnResult(playlists, string.IsNullOrEmpty(search) ? XvideosTo.Menu(host, plugin, sort, c) : null, plugin: plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/XvideosRED/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.XvideosRED
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("xdsred/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            var init = await loadKit(AppInit.conf.XvideosRED);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            string memKey = $"xdsred:view:{uri}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    stream_links = await XvideosTo.StreamLinks("xdsred/vidosik", "xdsred/stars", init.corsHost(), uri,
                        url => Http.Get(url, cookie: init.cookie, timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                        return OnError("stream_links", proxyManager);

                    proxyManager.Success();
                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: SISI/Controllers/Eporner/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Eporner
{
    public class ListController : BaseSisiController
    {
        [HttpGet]
        [Route("epr")]
        async public ValueTask<ActionResult> Index(string search, string sort, string c, int pg = 1)
        {
            var init = await loadKit(AppInit.conf.Eporner);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            pg += 1;

            string memKey = $"epr:{search}:{sort}:{c}:{pg}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out List<PlaylistItem> playlists, inmemory: false))
                {
                    reset:
                    string html = await EpornerTo.InvokeHtml(init.corsHost(), search, sort, c, pg, url =>
                        rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : Http.Get(init.cors(url), timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init))
                    );

                    playlists = EpornerTo.Playlist("epr/vidosik", html);

                    if (playlists.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("playlists", proxyManager, string.IsNullOrEmpty(search));
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, playlists, cacheTime(10, init: init), inmemory: false);
                }

                return OnResult(playlists, EpornerTo.Menu(host, search, sort, c), plugin: init.plugin);
            });
        }
    }
}

```

## File: SISI/Controllers/Eporner/ViewController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace SISI.Controllers.Eporner
{
    public class ViewController : BaseSisiController
    {
        [HttpGet]
        [Route("epr/vidosik")]
        async public ValueTask<ActionResult> Index(string uri, bool related)
        {
            var init = await loadKit(AppInit.conf.Eporner);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return OnError(rch_error);

            string memKey = $"eporner:view:{uri}";

            return await InvkSemaphore(memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out StreamItem stream_links))
                {
                    reset:
                    stream_links = await EpornerTo.StreamLinks("epr/vidosik", init.corsHost(), uri,
                                   htmlurl => rch.enable ? rch.Get(init.cors(htmlurl), httpHeaders(init)) : Http.Get(init.cors(htmlurl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
                                   jsonurl => rch.enable ? rch.Get(init.cors(jsonurl), httpHeaders(init)) : Http.Get(init.cors(jsonurl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)));

                    if (stream_links?.qualitys == null || stream_links.qualitys.Count == 0)
                    {
                        if (IsRhubFallback(init))
                            goto reset;

                        return OnError("stream_links", proxyManager);
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, stream_links, cacheTime(20, init: init));
                }

                if (related)
                    return OnResult(stream_links?.recomends, null, plugin: init.plugin, total_pages: 1);

                return OnResult(stream_links, init, proxy);
            });
        }
    }
}

```

## File: Catalog/ListController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.PlaywrightCore;
using System.Net.Http;

namespace Catalog.Controllers
{
    public class ListController : BaseController
    {
        [HttpGet]
        [Route("catalog/list")]
        async public ValueTask<ActionResult> Index(string query, string plugin, string cat, string sort, int page = 1)
        {
            var init = ModInit.goInit(plugin)?.Clone();
            if (init == null || !init.enable)
                return BadRequest("init not found");

            if (!string.IsNullOrEmpty(query) && string.IsNullOrEmpty(init.search?.uri))
                return BadRequest("search disable");

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected())
                rch.Disabled();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string search = query;
            string memKey = $"catalog:{plugin}:{search}:{sort}:{cat}:{page}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out (List<PlaylistItem> playlists, int total_pages) cache, inmemory: false))
                {
                    #region contentParse
                    var contentParse = init.list?.contentParse ?? init.content;

                    if (!string.IsNullOrEmpty(search) && init.search?.contentParse != null)
                        contentParse = init.search.contentParse;
                    #endregion

                    #region html
                    var headers = httpHeaders(init);
                    var parse = init.list;

                    string url = $"{init.host}/{(page == 1 && init.list?.firstpage != null ? init.list?.firstpage : init.list?.uri)}";
                    string data = init.list?.postData;

                    if (!string.IsNullOrEmpty(search))
                    {
                        string uri = page == 1 && init.search?.firstpage != null ? init.search.firstpage : init.search?.uri;
                        url = $"{init.host}/{uri}".Replace("{search}", HttpUtility.UrlEncode(search));

                        data = init.search?.postData?.Replace("{search}", HttpUtility.UrlEncode(search));
                        parse = init.search;
                    }
                    else if (!string.IsNullOrEmpty(cat))
                    {
                        var menu = init.menu.FirstOrDefault(i => i.categories.Values.Contains(cat));
                        if (menu == null)
                            return BadRequest("menu");

                        string getFormat(string key)
                        {
                            if (menu.format.TryGetValue(key, out string _f))
                                return _f;

                            return string.Empty;
                        }

                        string eval = (cat != null && sort != null) ? getFormat("sort") : getFormat("-");
                        if (!string.IsNullOrEmpty(eval))
                        {
                            if (!eval.Contains("$\"") && eval.Contains("{") && eval.Contains("}"))
                                eval = $"return $\"{eval}\";";

                            url = CSharpEval.BaseExecute<string>(eval, new CatalogGlobalsMenuRoute(init.host, plugin, init.args, url, search, cat, sort, HttpContext.Request.Query, page));
                        }

                        if (!url.StartsWith("http"))
                            url = $"{init.host}/{url}";
                    }

                    if (init.args != null)
                        url = url.Contains("?") ? $"{url}&{init.args}" : $"{url}?{init.args}";

                    if (parse?.initUrl != null)
                        url = CSharpEval.Execute<string>(parse.initUrl, new CatalogGlobalsMenuRoute(init.host, plugin, init.args, url, search, cat, sort, HttpContext.Request.Query, page));

                    if (parse?.initHeader != null)
                        headers = CSharpEval.Execute<List<HeadersModel>>(parse.initHeader, new CatalogInitHeader(url, headers));

                    reset:
                    string html = null;

                    if (!string.IsNullOrEmpty(data))
                    {
                        string mediaType = data.StartsWith("{") || data.StartsWith("[") ? "application/json" : "application/x-www-form-urlencoded";
                        var httpdata = new StringContent(data, Encoding.UTF8, mediaType);

                        html = rch.enable
                            ? await rch.Post(url.Replace("{page}", page.ToString()), data, headers, useDefaultHeaders: init.useDefaultHeaders)
                            : await Http.Post(url.Replace("{page}", page.ToString()), httpdata, headers: headers, proxy: proxy.proxy, timeoutSeconds: init.timeout, useDefaultHeaders: init.useDefaultHeaders);
                    }
                    else
                    {
                        html = rch.enable
                            ? await rch.Get(url.Replace("{page}", page.ToString()), headers, useDefaultHeaders: init.useDefaultHeaders)
                            : init.priorityBrowser == "playwright" ? await PlaywrightBrowser.Get(init, url.Replace("{page}", page.ToString()), headers, proxy.data, cookies: init.cookies)
                            : await Http.Get(url.Replace("{page}", page.ToString()), headers: headers, proxy: proxy.proxy, timeoutSeconds: init.timeout, useDefaultHeaders: init.useDefaultHeaders);
                    }
                    #endregion

                    bool? jsonPath = contentParse.jsonPath;
                    if (jsonPath == null)
                        jsonPath = init.jsonPath;

                    #region parse doc/json
                    HtmlDocument doc = null;
                    JToken json = null;

                    if (jsonPath == true)
                    {
                        try
                        {
                            json = JToken.Parse(html);
                        }
                        catch
                        {
                            json = null;
                        }
                    }
                    else
                    {
                        doc = new HtmlDocument();

                        if (html != null)
                            doc.LoadHtml(html);
                    }
                    #endregion

                    cache.playlists = jsonPath == true
                        ? goPlaylistJson(cat, json, requestInfo, host, contentParse, init, html, plugin)
                        : goPlaylist(cat, doc, requestInfo, host, contentParse, init, html, plugin);

                    if (cache.playlists == null || cache.playlists.Count == 0)
                    {
                        if (ModInit.IsRhubFallback(init))
                            goto reset;

                        if (!rch.enable)
                            proxyManager.Refresh();

                        return BadRequest("playlists");
                    }

                    if (contentParse.total_pages != null)
                    {
                        string _p = jsonPath == true
                            ? ModInit.nodeValue(json, contentParse.total_pages, host)?.ToString() ?? ""
                            : ModInit.nodeValue(doc.DocumentNode, contentParse.total_pages, host)?.ToString() ?? "";

                        if (int.TryParse(_p, out int _pages) && _pages > 0)
                            cache.total_pages = _pages;
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, cache, cacheTime(init.cache_time, init: init), inmemory: false);
                }

                #region total_pages
                int? total_pages = init.list?.total_pages ?? 0;

                if (search != null && init.search != null)
                    total_pages = init.search.total_pages;

                if (total_pages == 0)
                    total_pages = cache.total_pages;
                #endregion

                #region next_page
                bool? next_page = null;

                if (search != null)
                {
                    if (init.search != null && init.search.count_page > 0 && cache.playlists.Count >= init.search.count_page)
                        next_page = true;
                }
                else
                {
                    if (init.list != null && init.list.count_page > 0 && cache.playlists.Count >= init.list.count_page)
                        next_page = true;
                }

                if (next_page == true && total_pages == 0)
                    total_pages = null;
                #endregion

                #region results
                var results = new JArray();

                foreach (var pl in cache.playlists)
                {
                    var jo = new JObject()
                    {
                        ["id"] = pl.id,
                        ["img"] = pl.img
                    };

                    if (pl.is_serial)
                    {
                        jo["first_air_date"] = pl.year;
                        jo["name"] = pl.title;
                        jo["original_name"] = string.IsNullOrWhiteSpace(pl.original_title) ? pl.title : pl.original_title;
                    }
                    else
                    {
                        jo["release_date"] = pl.year;
                        jo["title"] = pl.title;
                        jo["original_title"] = string.IsNullOrWhiteSpace(pl.original_title) ? pl.title : pl.original_title;
                    }

                    if (pl.args != null)
                    {
                        foreach (var a in pl.args)
                            jo[a.Key] = JToken.FromObject(a.Value);
                    }

                    results.Add(jo);
                }
                #endregion

                return ContentTo(JsonConvert.SerializeObject(new 
                {
                    page,
                    results,
                    total_pages,
                    next_page

                }, new JsonSerializerSettings
                {
                    NullValueHandling = NullValueHandling.Ignore,
                    DefaultValueHandling = DefaultValueHandling.Ignore
                }));
            });
        }


        #region goPlaylistJson
        static List<PlaylistItem> goPlaylistJson(string cat, JToken json, in RequestModel requestInfo, string host, ContentParseSettings parse, CatalogSettings init, in string html, string plugin)
        {
            if (parse == null || json == null)
                return null;

            if (init.debug)
                Console.WriteLine(html);

            string eval = parse.eval;
            if (!string.IsNullOrEmpty(eval) && eval.EndsWith(".cs"))
                eval = FileCache.ReadAllText($"catalog/sites/{eval}");

            if (string.IsNullOrEmpty(parse.nodes))
            {
                if (string.IsNullOrEmpty(eval))
                    return null;

                var options = ScriptOptions.Default
                    .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                    .AddImports("Shared")
                    .AddImports("Shared.Models")
                    .AddImports("Shared.Engine")
                    .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll"))
                    .AddImports("Newtonsoft.Json")
                    .AddImports("Newtonsoft.Json.Linq");

                return CSharpEval.Execute<List<PlaylistItem>>(eval, new CatalogPlaylistJson(init, plugin, host, html, json, new List<PlaylistItem>()), options);
            }

            var nodes = json.SelectTokens(parse.nodes)?.ToList();
            if (nodes == null || nodes.Count == 0)
                return null;

            var playlists = new List<PlaylistItem>(nodes.Count);

            foreach (var node in nodes)
            {
                string name = ModInit.nodeValue(node, parse.name, host)?.ToString();
                string original_name = ModInit.nodeValue(node, parse.original_name, host)?.ToString();
                string href = ModInit.nodeValue(node, parse.href, host)?.ToString();
                string img = ModInit.nodeValue(node, parse.image, host)?.ToString();
                string year = ModInit.nodeValue(node, parse.year, host)?.ToString();

                if (init.debug)
                    Console.WriteLine($"\n\nname: {name}\noriginal_name: {original_name}\nhref: {href}\nimg: {img}\nyear: {year}\n\n{node.ToString(Formatting.None)}");

                if (!string.IsNullOrWhiteSpace(name) && !string.IsNullOrWhiteSpace(href))
                {
                    #region href
                    if (href.StartsWith("../"))
                        href = href.Replace("../", "");
                    else if (href.StartsWith("//"))
                        href = Regex.Replace(href, "//[^/]+/", "");
                    else if (href.StartsWith("http"))
                        href = Regex.Replace(href, "https?://[^/]+/", "");
                    else if (href.StartsWith("/"))
                        href = href.Substring(1);
                    #endregion

                    #region img
                    if (img != null)
                    {
                        img = img.Replace("&amp;", "&").Replace("\\", "");

                        if (img.StartsWith("../"))
                            img = $"{init.host}/{img.Replace("../", "")}";
                        else if (img.StartsWith("//"))
                            img = $"https:{img}";
                        else if (img.StartsWith("/"))
                            img = init.host + img;
                        else if (!img.StartsWith("http"))
                            img = $"{init.host}/{img}";
                    }
                    #endregion

                    if (!init.ignore_no_picture && string.IsNullOrEmpty(img))
                        continue;

                    string clearText(string text)
                    {
                        if (string.IsNullOrEmpty(text))
                            return text;

                        text = text.Replace("&nbsp;", "");
                        text = Regex.Replace(text, "<[^>]+>", "");
                        text = HttpUtility.HtmlDecode(text);
                        return text.Trim();
                    }

                    #region is_serial
                    bool? is_serial = null;

                    if (cat != null)
                    {
                        if (init.movie_cats != null && init.movie_cats.Contains(cat))
                            is_serial = false;
                        else if (init.serial_cats != null && init.serial_cats.Contains(cat))
                            is_serial = true;
                    }

                    if (is_serial == null && parse.serial_regex != null)
                        is_serial = Regex.IsMatch(node.ToString(Formatting.None), parse.serial_regex, RegexOptions.IgnoreCase);

                    if (is_serial == null && parse.serial_key != null)
                    {
                        if (ModInit.nodeValue(node, parse.serial_key, host) != null)
                            is_serial = true;
                    }
                    #endregion

                    var pl = new PlaylistItem()
                    {
                        id = href,
                        title = clearText(name),
                        original_title = clearText(original_name),
                        img = PosterApi.Size(host, img),
                        year = clearText(year),
                        is_serial = is_serial == true
                    };

                    if (parse.args != null)
                    {
                        foreach (var arg in parse.args)
                        {
                            if (pl.args == null)
                                pl.args = new JObject();

                            object val = ModInit.nodeValue(node, arg, host);
                            ModInit.setArgsValue(arg, val, pl.args);
                        }
                    }

                    if (eval != null)
                    {
                        var options = ScriptOptions.Default
                            .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                            .AddImports("Shared")
                            .AddImports("Shared.Models")
                            .AddImports("Shared.Engine")
                            .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll"))
                            .AddImports("Newtonsoft.Json")
                            .AddImports("Newtonsoft.Json.Linq");

                        pl = CSharpEval.Execute<PlaylistItem>(eval, new CatalogChangePlaylisJson(init, plugin, host, html, nodes, pl, node), options);
                    }

                    if (pl != null)
                        playlists.Add(pl);
                }
            }

            return playlists;
        }
        #endregion

        #region goPlaylist
        static List<PlaylistItem> goPlaylist(string cat, HtmlDocument doc, in RequestModel requestInfo, string host, ContentParseSettings parse, CatalogSettings init, in string html, string plugin)
        {
            if (parse == null || string.IsNullOrEmpty(html))
                return null;

            if (init.debug)
                Console.WriteLine(html);

            string eval = parse.eval;
            if (!string.IsNullOrEmpty(eval) && eval.EndsWith(".cs"))
                eval = FileCache.ReadAllText($"catalog/sites/{eval}");

            if (string.IsNullOrEmpty(parse.nodes))
            {
                if (string.IsNullOrEmpty(eval))
                    return null;

                var options = ScriptOptions.Default
                    .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                    .AddImports("Shared")
                    .AddImports("Shared.Models")
                    .AddImports("Shared.Engine")
                    .AddReferences(CSharpEval.ReferenceFromFile("HtmlAgilityPack.dll"))
                    .AddImports("HtmlAgilityPack");

                return CSharpEval.Execute<List<PlaylistItem>>(eval, new CatalogPlaylist(init, plugin, host, html, doc, new List<PlaylistItem>()), options);
            }

            var nodes = doc.DocumentNode.SelectNodes(parse.nodes);
            if (nodes == null || nodes.Count == 0)
                return null;

            var playlists = new List<PlaylistItem>(nodes.Count);

            foreach (var node in nodes)
            {
                string name = ModInit.nodeValue(node, parse.name, host)?.ToString();
                string original_name = ModInit.nodeValue(node, parse.original_name, host)?.ToString();
                string href = ModInit.nodeValue(node, parse.href, host)?.ToString();
                string img = ModInit.nodeValue(node, parse.image, host)?.ToString();
                string year = ModInit.nodeValue(node, parse.year, host)?.ToString();

                if (init.debug)
                    Console.WriteLine($"\n\nname: {name}\noriginal_name: {original_name}\nhref: {href}\nimg: {img}\nyear: {year}\n\n{node.OuterHtml}");

                if (!string.IsNullOrWhiteSpace(name) && !string.IsNullOrWhiteSpace(href))
                {
                    #region href
                    if (href.StartsWith("../"))
                        href = href.Replace("../", "");
                    else if (href.StartsWith("//"))
                        href = Regex.Replace(href, "//[^/]+/", "");
                    else if (href.StartsWith("http"))
                        href = Regex.Replace(href, "https?://[^/]+/", "");
                    else if (href.StartsWith("/"))
                        href = href.Substring(1);
                    #endregion

                    #region img
                    if (img != null)
                    {
                        img = img.Replace("&amp;", "&").Replace("\\", "");

                        if (img.StartsWith("../"))
                            img = $"{init.host}/{img.Replace("../", "")}";
                        else if (img.StartsWith("//"))
                            img = $"https:{img}";
                        else if (img.StartsWith("/"))
                            img = init.host + img;
                        else if (!img.StartsWith("http"))
                            img = $"{init.host}/{img}";
                    }
                    #endregion

                    if (!init.ignore_no_picture && string.IsNullOrEmpty(img))
                        continue;

                    #region is_serial
                    bool? is_serial = null;

                    if (cat != null)
                    {
                        if (init.movie_cats != null && init.movie_cats.Contains(cat))
                            is_serial = false;
                        else if (init.serial_cats != null && init.serial_cats.Contains(cat))
                            is_serial = true;
                    }

                    if (is_serial == null && parse.serial_regex != null)
                        is_serial = Regex.IsMatch(node.OuterHtml, parse.serial_regex, RegexOptions.IgnoreCase);

                    if (is_serial == null && parse.serial_key != null)
                    {
                        if (ModInit.nodeValue(node, parse.serial_key, host) != null)
                            is_serial = true;
                    }
                    #endregion

                    var pl = new PlaylistItem()
                    {
                        id = href,
                        title = ModInit.clearText(name),
                        original_title = ModInit.clearText(original_name),
                        img = PosterApi.Size(host, img),
                        year = ModInit.clearText(year),
                        is_serial = is_serial == true
                    };

                    if (parse.args != null)
                    {
                        foreach (var arg in parse.args)
                        {
                            if (pl.args == null)
                                pl.args = new JObject();

                            object val = ModInit.nodeValue(node, arg, host);
                            ModInit.setArgsValue(arg, val, pl.args);
                        }
                    }

                    if (eval != null)
                    {
                        var options = ScriptOptions.Default
                            .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                            .AddImports("Shared")
                            .AddImports("Shared.Models")
                            .AddImports("Shared.Engine")
                            .AddReferences(CSharpEval.ReferenceFromFile("HtmlAgilityPack.dll"))
                            .AddImports("HtmlAgilityPack");

                        pl = CSharpEval.Execute<PlaylistItem>(eval, new CatalogChangePlaylis(init, plugin, host, html, nodes, pl, node), options);
                    }

                    if (pl != null)
                        playlists.Add(pl);
                }
            }

            return playlists;
        }
        #endregion
    }
}

```

## File: Catalog/ApiController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace Catalog.Controllers
{
    public class ApiController : BaseController
    {
        #region catalog.js
        [HttpGet]
        [AllowAnonymous]
        [Route("catalog.js")]
        [Route("catalog/js/{token}")]
        public ActionResult CatalogJS(string token)
        {
            var sb = new StringBuilder(FileCache.ReadAllText("plugins/catalog.js"));

            sb.Replace("{localhost}", host)
              .Replace("{token}", HttpUtility.UrlEncode(token))
              .Replace("catalogs:{}", $"catalogs:{jsonCatalogs()}");

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        [HttpGet]
        [Route("catalog")]
        public ActionResult Index()
        {
            return ContentTo(jsonCatalogs());
        }


        string jsonCatalogs()
        {
            var result = new JObject();

            string dir = Path.Combine(AppContext.BaseDirectory, "catalog", "sites");
            if (!Directory.Exists(dir))
                return result.ToString(Formatting.None);

            #region sites
            var sites = new List<(string key, JObject obj, int index)>();

            foreach (var file in Directory.GetFiles(dir, "*.yaml"))
            {
                try
                {
                    var site = Path.GetFileNameWithoutExtension(file);
                    if (string.IsNullOrEmpty(site))
                        continue;

                    var init = ModInit.goInit(site);
                    if (init == null || !init.enable || init.menu == null || init.hide)
                        continue;

                    var siteObj = new JObject();

                    foreach (var menuItem in init.menu)
                    {
                        if (menuItem?.categories == null || menuItem.categories.Count == 0)
                            continue;

                        foreach (var cat in menuItem.categories)
                        {
                            string catName = cat.Key;
                            string catCode = cat.Value;

                            if (!(siteObj[catName] is JObject catObj))
                            {
                                catObj = new JObject();

                                if (init.search != null)
                                    siteObj["search"] = $"/catalog/list?plugin={HttpUtility.UrlEncode(menuItem.catalog ?? site)}";

                                siteObj["search_lazy"] = init.search_lazy;

                                if (!string.IsNullOrEmpty(init.catalog_key))
                                    siteObj["catalog_key"] = init.catalog_key;

                                if (!string.IsNullOrEmpty(menuItem.defaultName))
                                    siteObj["defaultName"] = menuItem.defaultName;

                                siteObj[catName] = catObj;
                            }

                            string baseUrl = $"/catalog/list?plugin={HttpUtility.UrlEncode(menuItem.catalog ?? site)}&cat={HttpUtility.UrlEncode(catCode)}";

                            bool addBaseEntry = true;
                            if (menuItem.format != null)
                            {
                                if (!menuItem.format.ContainsKey("-"))
                                    addBaseEntry = false;
                            }

                            if (addBaseEntry)
                            {
                                if (catObj[catName] == null)
                                    catObj[catName] = baseUrl;
                            }

                            if (menuItem.sort != null)
                            {
                                foreach (var s in menuItem.sort)
                                {
                                    string sortName = s.Key;
                                    string sortCode = s.Value;
                                    if (string.IsNullOrEmpty(sortName) || string.IsNullOrEmpty(sortCode))
                                        continue;

                                    string sortUrl = baseUrl + "&sort=" + HttpUtility.UrlEncode(sortCode);
                                    if (catObj[sortName] == null)
                                        catObj[sortName] = sortUrl;
                                }
                            }
                        }
                    }

                    string siteKey = !string.IsNullOrEmpty(init.plugin) ? init.plugin : init.displayname ?? site;

                    int idx = init.displayindex;
                    if (idx == 0)
                        idx = int.MaxValue - sites.Count;

                    sites.Add((siteKey, siteObj, idx));
                }
                catch { }
            }
            #endregion

            #region result
            foreach (var s in sites.OrderBy(x => x.index))
            {
                result[s.key] = new JObject();

                if (s.obj.ContainsKey("search"))
                    result[s.key]["search"] = s.obj["search"];

                result[s.key]["search_lazy"] = s.obj["search_lazy"];

                string catalog_key = s.obj.ContainsKey("catalog_key") ? s.obj["catalog_key"]?.ToString() : null;
                string defaultName = s.obj.ContainsKey("defaultName") ? s.obj["defaultName"]?.ToString() : null;

                var menu = new JObject();
                var main = new JObject();

                foreach (var prop in s.obj.Properties())
                {
                    if (!(prop.Value is JObject catObj))
                        continue;

                    foreach (var inner in catObj.Properties())
                    {
                        string pname = prop.Name;
                        if (pname.StartsWith("["))
                            pname = prop.Name.Split(']')[1].Trim();

                        if (pname != inner.Name)
                            main[$"{pname} ‚Ä¢ {inner.Name.ToLower()}"] = inner.Value;
                        else
                            main[pname] = inner.Value;

                        if (!menu.ContainsKey(pname) || (catalog_key != null && catalog_key == inner.Name))
                            menu[pname] = inner.Value;
                    }

                    var categoryMap = new Dictionary<string, string>
                    {
                        { "–§–∏–ª—å–º—ã", "movie" },
                        { "–°–µ—Ä–∏–∞–ª—ã", "tv" },
                        { "–ú—É–ª—å—Ç—Ñ–∏–ª—å–º—ã", "cartoons" },
                        { "–ê–Ω–∏–º–µ", "anime" },
                        { "–†–µ–ª–∏–∑—ã", "relise" }
                    };

                    string targetCat, targetName = null;

                    if (categoryMap.TryGetValue(prop.Name, out targetCat))
                        targetName = prop.Name;

                    if (prop.Name.StartsWith("["))
                    {
                        targetCat = prop.Name.Split(']')[0].Trim('[');
                        targetName = prop.Name.Split(']')[1];
                    }

                    if (!string.IsNullOrEmpty(targetName) && !string.IsNullOrEmpty(targetCat))
                    {
                        var targetObj = new JObject();

                        foreach (var inner in catObj.Properties())
                        {
                            if (targetName.Trim() != inner.Name)
                                targetObj[inner.Name] = inner.Value;
                            else
                                targetObj[defaultName ?? inner.Name] = inner.Value;
                        }

                        if (targetObj.HasValues)
                            result[s.key][targetCat.Trim()] = targetObj;
                    }
                }

                if (menu.HasValues)
                    result[s.key]["menu"] = menu;

                if (main.HasValues)
                    result[s.key]["main"] = main;
            }
            #endregion

            return result.ToString(Formatting.None);
        }
    }
}

```

## File: Catalog/ModInit.cs
```
Ôªøusing YamlDotNet.Serialization;

namespace Catalog
{
    public class ModInit
    {
        public static void loaded()
        {
        }

        #region goInit
        public static CatalogSettings goInit(string site)
        {
            if (string.IsNullOrEmpty(site))
                return null;

            site = site.Trim().ToLowerInvariant();

            var hybridCache = new HybridCache();

            string memKey = $"catalog:goInit:{site}";
            if (!hybridCache.TryGetValue(memKey, out CatalogSettings init))
            {
                // –ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ –∏–º–µ–Ω–∏, –ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –ø–æ displayname –≤ *.yaml
                if (!File.Exists($"catalog/sites/{site}.yaml"))
                {
                    string found = FindSiteByDisplayName(site);
                    if (string.IsNullOrEmpty(found))
                        return null;

                    site = found;
                }

                var deserializer = new DeserializerBuilder().Build();

                // –ß—Ç–µ–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ YAML-—Ñ–∞–π–ª–∞
                string yaml = File.ReadAllText($"catalog/sites/{site}.yaml");
                var target = deserializer.Deserialize<Dictionary<object, object>>(yaml);

                foreach (string y in new string[] { "_", site })
                {
                    if (File.Exists($"catalog/override/{y}.yaml"))
                    {
                        // –ß—Ç–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ YAML-—Ñ–∞–π–ª–∞
                        string myYaml = File.ReadAllText($"catalog/override/{y}.yaml");
                        var mySource = deserializer.Deserialize<Dictionary<object, object>>(myYaml);

                        // –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–ª–æ–≤–∞—Ä–µ–π
                        foreach (var property in mySource)
                        {
                            if (!target.ContainsKey(property.Key))
                            {
                                target[property.Key] = property.Value;
                                continue;
                            }

                            if (property.Value is IDictionary<object, object> sourceDict &&
                                target[property.Key] is IDictionary<object, object> targetDict)
                            {
                                // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö —Å–ª–æ–≤–∞—Ä–µ–π
                                foreach (var item in sourceDict)
                                    targetDict[item.Key] = item.Value;
                            }
                            else
                            {
                                target[property.Key] = property.Value;
                            }
                        }
                    }
                }

                // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å–ª–æ–≤–∞—Ä—è –≤ –æ–±—ä–µ–∫—Ç CatalogSettings
                var serializer = new SerializerBuilder().Build();

                var yamlResult = serializer.Serialize(target);
                init = deserializer.Deserialize<CatalogSettings>(yamlResult);

                if (string.IsNullOrEmpty(init.plugin))
                    init.plugin = init.displayname;

                if (!init.debug || !AppInit.conf.multiaccess)
                    hybridCache.Set(memKey, init, DateTime.Now.AddMinutes(1), inmemory: true);
            }

            return init;
        }
        #endregion

        #region FindSiteByDisplayName
        static string FindSiteByDisplayName(string site)
        {
            var deserializer = new DeserializerBuilder().Build();

            foreach (var folder in new[] { "catalog/sites", "catalog/override" })
            {
                if (!Directory.Exists(folder))
                    continue;

                foreach (var file in Directory.EnumerateFiles(folder, "*.yaml"))
                {
                    try
                    {
                        var yaml = File.ReadAllText(file);
                        var dict = deserializer.Deserialize<Dictionary<object, object>>(yaml);
                        if (dict != null && dict.TryGetValue("displayname", out var dnObj) && dnObj != null)
                        {
                            var dn = dnObj.ToString().Trim().ToLowerInvariant();
                            if (dn == site)
                                return Path.GetFileNameWithoutExtension(file);
                        }
                    }
                    catch { }
                }
            }

            return null;
        }
        #endregion

        #region IsRhubFallback
        public static bool IsRhubFallback(BaseSettings init)
        {
            if (init.rhub && init.rhub_fallback)
            {
                init.rhub = false;
                return true;
            }

            return false;
        }
        #endregion


        #region nodeValue - HtmlNode
        public static object nodeValue(HtmlNode node, SingleNodeSettings nd, string host)
        {
            string value = null;

            if (nd != null)
            {
                if (string.IsNullOrEmpty(nd.node) && (!string.IsNullOrEmpty(nd.attribute) || nd.attributes != null))
                {
                    if (nd.attributes != null)
                    {
                        foreach (var attr in nd.attributes)
                        {
                            var attrValue = node.GetAttributeValue(attr, null);
                            if (!string.IsNullOrEmpty(attrValue))
                            {
                                value = attrValue;
                                break;
                            }
                        }
                    }
                    else
                    {
                        value = node.GetAttributeValue(nd.attribute, null);
                    }
                }
                else
                {
                    var inNode = node.SelectSingleNode(nd.node);
                    if (inNode != null)
                    {
                        if (nd.attributes != null)
                        {
                            foreach (var attr in nd.attributes)
                            {
                                var attrValue = inNode.GetAttributeValue(attr, null);
                                if (!string.IsNullOrEmpty(attrValue))
                                {
                                    value = attrValue;
                                    break;
                                }
                            }
                        }
                        else
                        {
                            value = (!string.IsNullOrEmpty(nd.attribute) ? inNode.GetAttributeValue(nd.attribute, null) : inNode.InnerText)?.Trim();
                        }
                    }
                }
            }

            if (string.IsNullOrEmpty(value))
                return null;

            if (nd.format != null)
            {
                var options = ScriptOptions.Default
                    .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                    .AddImports("Shared")
                    .AddImports("Shared.Engine")
                    .AddImports("Shared.Models")
                    .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll"))
                    .AddImports("Newtonsoft.Json")
                    .AddImports("Newtonsoft.Json.Linq");

                return CSharpEval.Execute<object>(nd.format, new CatalogNodeValue(value, host), options);
            }

            return value?.Trim();
        }
        #endregion

        #region nodeValue - JToken
        public static object nodeValue(JToken node, SingleNodeSettings nd, string host)
        {
            if (node == null || nd == null)
                return null;

            var current = node is JProperty property ? property.Value : node;

            JToken valueToken = null;

            if (!string.IsNullOrEmpty(nd.node))
            {
                current = current.SelectToken(nd.node);
                if (current == null)
                    return null;
            }

            if (nd.attributes != null)
            {
                foreach (var attr in nd.attributes)
                {
                    valueToken = current[attr];
                    if (valueToken != null)
                        break;
                }
            }

            if (valueToken == null && !string.IsNullOrEmpty(nd.attribute))
                valueToken = current[nd.attribute];

            if (valueToken == null)
                return null;

            string value = valueToken switch
            {
                JValue jValue => jValue.Value?.ToString(),
                JProperty jProp => jProp.Value?.ToString(),
                _ => valueToken.ToString(Formatting.None)
            };

            if (string.IsNullOrEmpty(value))
                return null;

            if (nd.format != null)
            {
                var options = ScriptOptions.Default
                    .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                    .AddImports("Shared")
                    .AddImports("Shared.Engine")
                    .AddImports("Shared.Models")
                    .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll"))
                    .AddImports("Newtonsoft.Json")
                    .AddImports("Newtonsoft.Json.Linq");

                return CSharpEval.Execute<object>(nd.format, new CatalogNodeValue(value, host), options);
            }

            if (valueToken is JValue)
                return value?.Trim();

            return valueToken;
        }
        #endregion


        #region setArgsValue
        public static void setArgsValue(SingleNodeSettings arg, object val, JObject jo)
        {
            if (val != null)
            {
                if (arg.name_arg is "kp_rating" or "imdb_rating")
                {
                    string rating = val?.ToString()?.Trim();
                    if (!string.IsNullOrEmpty(rating) && rating != "0" && rating != "0.0" && double.TryParse(rating.Replace(".", ","), out _))
                    {
                        rating = rating.Length > 3 ? rating.Substring(0, 3) : rating;
                        if (rating.Length == 1)
                            rating = $"{rating}.0";

                        jo[arg.name_arg] = JToken.FromObject(rating.Replace(",", "."));
                    }
                }
                else if (arg.name_arg is "vote_average")
                {
                    string value = val?.ToString()?.Trim()?.Replace(".", ",");
                    if (!string.IsNullOrEmpty(value) && double.TryParse(value, out double _v) && _v > 0)
                        jo[arg.name_arg] = JToken.FromObject(_v);
                }
                else if (arg.name_arg is "runtime" or "PG")
                {
                    string value = val?.ToString()?.Trim();
                    if (!string.IsNullOrEmpty(value) && long.TryParse(value, out long _v) && _v > 0)
                        jo[arg.name_arg] = JToken.FromObject(_v);
                }
                else if (arg.name_arg is "genres" or "created_by" or "production_countries" or "production_companies" or "networks" or "spoken_languages")
                {
                    if (val is string)
                    {
                        string arrayStr = val?.ToString();
                        var array = new JArray();

                        if (!string.IsNullOrEmpty(arrayStr))
                        {
                            foreach (string str in arrayStr.Split(","))
                            {
                                if (string.IsNullOrWhiteSpace(str))
                                    continue;

                                array.Add(new JObject() { ["name"] = clearText(str) });
                            }

                            jo[arg.name_arg] = array;
                        }
                    }
                    else if (IsStringList(val as JToken))
                    {
                        var array = new JArray();
                        foreach (var item in (JArray)val)
                            array.Add(new JObject() { ["name"] = clearText(item.ToString()) });

                        jo[arg.name_arg] = array;
                    }
                }
                else if (val is string && (arg.name_arg is "origin_country" or "languages"))
                {
                    string arrayStr = val?.ToString();
                    var array = new JArray();

                    if (!string.IsNullOrEmpty(arrayStr))
                    {
                        foreach (string str in arrayStr.Split(","))
                        {
                            if (!string.IsNullOrWhiteSpace(str))
                                array.Add(str.Trim());
                        }

                        if (array.Count > 0)
                            jo[arg.name_arg] = array;
                    }
                }
                else
                {
                    jo[arg.name_arg] = JToken.FromObject(val);
                }
            }
        }
        #endregion

        #region IsStringList
        static bool IsStringList(JToken token)
        {
            if (token?.Type != JTokenType.Array)
                return false;

            var array = token as JArray;
            return array?.All(item => item.Type == JTokenType.String) == true;
        }
        #endregion

        #region clearText
        public static string clearText(string text)
        {
            if (string.IsNullOrEmpty(text))
                return text;

            text = text.Replace("&nbsp;", "");
            text = Regex.Replace(text, "<[^>]+>", "");
            text = HttpUtility.HtmlDecode(text);
            return text.Trim();
        }
        #endregion
    }
}

```

## File: Catalog/CardController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.PlaywrightCore;
using System.Net.Http;

namespace Catalog.Controllers
{
    public class CardController : BaseController
    {
        [HttpGet]
        [Route("catalog/card")]
        public async Task<ActionResult> Index(string plugin, string uri, string type)
        {
            var init = ModInit.goInit(plugin)?.Clone();
            if (init == null || !init.enable)
                return BadRequest("init not found");

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected())
                rch.Disabled();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string memKey = $"catalog:card:{plugin}:{uri}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out JObject jo, inmemory: false))
                {
                    string url = $"{init.host}/{uri}";
                    var headers = httpHeaders(init);

                    if (init.args != null)
                        url = url.Contains("?") ? $"{url}&{init.args}" : $"{url}?{init.args}";

                    if (init.card_parse.initUrl != null)
                        url = CSharpEval.Execute<string>(init.card_parse.initUrl, new CatalogInitUrlCard(init.host, init.args, uri, HttpContext.Request.Query, type));

                    if (init.card_parse.initHeader != null)
                        headers = CSharpEval.Execute<List<HeadersModel>>(init.card_parse.initHeader, new CatalogInitHeader(url, headers));

                    reset:

                    string html = null;

                    if (!string.IsNullOrEmpty(init.card_parse.postData))
                    {
                        string mediaType = init.card_parse.postData.StartsWith("{") || init.card_parse.postData.StartsWith("[") ? "application/json" : "application/x-www-form-urlencoded";
                        var httpdata = new StringContent(init.card_parse.postData, Encoding.UTF8, mediaType);

                        html = rch.enable
                            ? await rch.Post(url, init.card_parse.postData, headers, useDefaultHeaders: init.useDefaultHeaders)
                            : await Http.Post(url, httpdata, headers: headers, proxy: proxy.proxy, timeoutSeconds: init.timeout, useDefaultHeaders: init.useDefaultHeaders);
                    }
                    else
                    {
                        html = rch.enable
                            ? await rch.Get(url, headers, useDefaultHeaders: init.useDefaultHeaders)
                            : init.priorityBrowser == "playwright" ? await PlaywrightBrowser.Get(init, url, headers, proxy.data, cookies: init.cookies)
                            : await Http.Get(url, headers: headers, proxy: proxy.proxy, timeoutSeconds: init.timeout, useDefaultHeaders: init.useDefaultHeaders);
                    }

                    if (html == null)
                    {
                        if (ModInit.IsRhubFallback(init))
                            goto reset;

                        if (!rch.enable)
                            proxyManager.Refresh();

                        return BadRequest("html");
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    var parse = init.card_parse;
                    bool? jsonPath = parse.jsonPath;
                    if (jsonPath == null)
                        jsonPath = init.jsonPath;

                    #region parse doc/json
                    HtmlNode node = null;
                    JToken json = null;

                    if (jsonPath == true)
                    {
                        try
                        {
                            json = JToken.Parse(html);

                            if (!string.IsNullOrEmpty(parse.node))
                            {
                                json = json.SelectToken(parse.node);
                                if (json == null)
                                    return BadRequest("parse.node");
                            }
                        }
                        catch
                        {
                            json = null;
                            return BadRequest("json");
                        }
                    }
                    else
                    {
                        var doc = new HtmlDocument();
                        doc.LoadHtml(html);

                        node = doc.DocumentNode;
                    }
                    #endregion

                    #region name / original_name / year
                    string name;
                    string original_name;
                    string year;

                    if (jsonPath == true)
                    {
                        name = ModInit.nodeValue(json, parse.name, host)?.ToString();
                        original_name = ModInit.nodeValue(json, parse.original_name, host)?.ToString();
                        year = ModInit.nodeValue(json, parse.year, host)?.ToString();
                    }
                    else
                    {
                        name = ModInit.nodeValue(node, parse.name, host)?.ToString();
                        original_name = ModInit.nodeValue(node, parse.original_name, host)?.ToString();
                        year = ModInit.nodeValue(node, parse.year, host)?.ToString();
                    }
                    #endregion

                    #region img
                    string img = jsonPath == true
                        ? ModInit.nodeValue(json, parse.image, host)?.ToString()
                        : ModInit.nodeValue(node, parse.image, host)?.ToString();

                    if (img != null)
                    {
                        img = img.Replace("&amp;", "&").Replace("\\", "");

                        if (img.StartsWith("../"))
                            img = $"{init.host}/{img.Replace("../", "")}";
                        else if (img.StartsWith("//"))
                            img = $"https:{img}";
                        else if (img.StartsWith("/"))
                            img = init.host + img;
                        else if (!img.StartsWith("http"))
                            img = $"{init.host}/{img}";
                    }
                    #endregion

                    jo = new JObject()
                    {
                        ["id"] = uri.Trim(),
                        ["img"] = PosterApi.Size(host, img),

                        ["vote_average"] = 0,
                        ["genres"] = new JArray(),
                        ["production_countries"] = new JArray(),
                        ["production_companies"] = new JArray()
                    };

                    string overview = jsonPath == true
                        ? ModInit.nodeValue(json, parse.description, host)?.ToString()
                        : ModInit.nodeValue(node, parse.description, host)?.ToString();

                    if (!string.IsNullOrEmpty(overview))
                        jo["overview"] = overview;

                    if (type == "tv")
                    {
                        jo["first_air_date"] = year;
                        jo["name"] = name;

                        if (!string.IsNullOrEmpty(original_name))
                            jo["original_name"] = original_name;
                    }
                    else
                    {
                        jo["release_date"] = year;
                        jo["title"] = name;

                        if (!string.IsNullOrEmpty(original_name))
                            jo["original_title"] = original_name;
                    }

                    #region card_args
                    if (init.card_args != null)
                    {
                        foreach (var arg in init.card_args)
                        {
                            object val = jsonPath == true
                                ? ModInit.nodeValue(json, arg, host)
                                : ModInit.nodeValue(node, arg, host);

                            ModInit.setArgsValue(arg, val, jo);
                        }
                    }
                    #endregion

                    if (init.tmdb_injects != null && init.tmdb_injects.Length > 0)
                        await Injects(year, jo, init.tmdb_injects);

                    if (!jo.ContainsKey("tagline") && !string.IsNullOrEmpty(original_name))
                        jo["tagline"] = original_name;

                    hybridCache.Set(memKey, jo, cacheTime(init.cache_time, init: init), inmemory: false);
                }

                return ContentTo(JsonConvert.SerializeObject(jo));
            });
        }


        #region TMDB Injects
        static readonly string[] defaultInjectskeys =
        [
            "imdb_id",
            "external_ids",
            "backdrop_path",
            "created_by",
            "genres",
            "production_companies",
            "production_countries",
            "content_ratings",
            "episode_run_time",
            "languages",
            "number_of_episodes",
            "number_of_seasons",
            "last_episode_to_air",
            "origin_country",
            "original_language",
            "status",
            "networks",
            "seasons",
            "type",
            "budget",
            "spoken_languages",
            "alternative_titles",
            "keywords",

            // &append_to_response=
            "videos",
            "credits",
            "recommendations",
            "similar",
        ];

        static readonly string[] addEmptykeys =
        [
            "tagline",
            "overview",
            "first_air_date",
            "last_air_date",
            "release_date",
            "runtime"
        ];

        async Task Injects(string year, JObject jo, string[] keys)
        {
            if (!jo.ContainsKey("imdb_id") && !jo.ContainsKey("original_title") && !jo.ContainsKey("original_name"))
                return;

            if (keys.Length == 1 && keys[0] == "default")
                keys = defaultInjectskeys;

            #region –ü–æ–∏—Å–∫ –∫–∞—Ä—Ç–æ—á–∫–∏ –≤ TMDB
            string imdbId = null;
            if (jo.ContainsKey("imdb_id"))
                imdbId = jo["imdb_id"]?.ToString();

            var header = HeadersModel.Init(("localrequest", AppInit.rootPasswd));

            long id = 0;
            string cat = string.Empty;

            if (!string.IsNullOrWhiteSpace(imdbId) && imdbId.StartsWith("tt"))
            {
                var find = await Http.Get<JObject>($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/3/find/{imdbId}?external_source=imdb_id&api_key={AppInit.conf.tmdb.api_key}", timeoutSeconds: 5, headers: header);
                if (find != null)
                {
                    foreach (string key in new string[] { "movie_results", "tv_results" })
                    {
                        if (find.ContainsKey(key))
                        {
                            var movies = find[key] as JArray;
                            if (movies != null && movies.Count > 0)
                            {
                                id = movies[0].Value<long>("id");
                                cat = key == "movie_results" ? "movie" : "tv";
                                break;
                            }
                        }
                    }
                }
            }
            else if (jo.ContainsKey("original_title") || jo.ContainsKey("original_name"))
            {
                string type = jo.ContainsKey("original_title") ? "movie" : "tv";
                string originalTitle = jo.Value<string>(type == "movie" ? "original_title" : "original_name");

                if (!string.IsNullOrEmpty(originalTitle) && int.TryParse(year.Split("-")[0], out int _year) && _year > 0)
                {
                    var searchMovie = await Http.Get<JObject>($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/3/search/{type}?query={HttpUtility.UrlEncode(originalTitle)}&api_key={AppInit.conf.tmdb.api_key}", timeoutSeconds: 5, headers: header);
                    if (searchMovie != null && searchMovie.ContainsKey("results"))
                    {
                        var results = searchMovie["results"] as JArray;
                        if (results != null && results.Count > 0)
                        {
                            long foundId = 0;
                            for (int i = 0; i < results.Count; i++)
                            {
                                var item = results[i] as JObject;
                                if (item == null)
                                    continue;

                                string date = item.Value<string>("release_date") ?? item.Value<string>("first_air_date");
                                if (string.IsNullOrEmpty(date))
                                    continue;

                                // date is usually in format YYYY-MM-DD, take first 4 chars
                                string yearStr = date.Length >= 4 ? date.Substring(0, 4) : date;
                                if (int.TryParse(yearStr, out int itemYear) && itemYear == _year)
                                {
                                    string _s1 = StringConvert.SearchName(originalTitle);
                                    string _s2 = StringConvert.SearchName(item.Value<string>(type == "movie" ? "original_title" : "original_name"));

                                    if (!string.IsNullOrEmpty(_s1) && !string.IsNullOrEmpty(_s2) && _s1 == _s2)
                                    {
                                        foundId = item.Value<long>("id");
                                        break;
                                    }
                                }
                            }

                            if (foundId != 0)
                            {
                                id = foundId;
                                cat = type;
                            }
                        }
                    }
                }
            }
            #endregion

            if (id == 0)
                return;

            string append = "content_ratings,release_dates,external_ids,keywords,alternative_titles,videos,credits,recommendations,similar";
            var result = await Http.Get<JObject>($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/3/{cat}/{id}?api_key={AppInit.conf.tmdb.api_key}&append_to_response={append}&language=ru", timeoutSeconds: 5, headers: header);
            if (result == null)
                return;

            foreach (string key in keys)
            {
                if (key is "videos" or "recommendations" or "similar")
                {
                    if (result.ContainsKey(key) && result[key] is JObject _jo && _jo.ContainsKey("results"))
                        jo[key] = _jo["results"];
                }
                else if (result.ContainsKey(key))
                {
                    jo[key] = result[key];
                }
            }

            if (result.ContainsKey("id"))
                jo["tmdb_id"] = result["id"];

            if (!jo.ContainsKey("imdb_id") && result.ContainsKey("external_ids") && result["external_ids"] is JObject extIds && extIds.ContainsKey("imdb_id"))
                jo["imdb_id"] = extIds["imdb_id"];

            foreach (string key in addEmptykeys)
            {
                if (!jo.ContainsKey(key) && result.ContainsKey(key))
                {
                    var tok = result[key];
                    if (tok == null)
                        continue;

                    if (tok.Type == JTokenType.String)
                    {
                        var str = tok.Value<string>();
                        if (!string.IsNullOrWhiteSpace(str))
                            jo[key] = str;
                    }
                    else
                    {
                        jo[key] = tok;
                    }
                }
            }
        }
        #endregion
    }
}

```

## File: Catalog/GlobalUsings.cs
```
Ôªøglobal using System;
global using System.Threading.Tasks;
global using System.Collections.Generic;
global using System.Text.RegularExpressions;
global using System.IO;
global using System.Linq;
global using Shared;
global using Shared.Models;
global using Shared.Engine;
global using Shared.Models.Base;
global using Shared.Models.Catalog;
global using Shared.Models.CSharpGlobals;
global using HtmlAgilityPack;
global using Newtonsoft.Json;
global using Newtonsoft.Json.Linq;
global using Microsoft.CodeAnalysis.Scripting;
global using System.Text;
global using System.Web;
```

## File: DLNA/ApiController.cs
```
Ôªøusing DLNA.Models;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using MongoDB.Driver;
using MonoTorrent;
using MonoTorrent.Client;
using NetVips;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Engine.JacRed;
using Shared.Models;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
using IO = System.IO;

namespace DLNA.Controllers
{
    public class DLNAController : BaseController
    {
        #region DLNAController
        static string dlna_path => AppInit.conf.dlna.path;

        static string defTrackers = "tr=http://retracker.local/announce&tr=http%3A%2F%2Fbt4.t-ru.org%2Fann%3Fmagnet&tr=http://retracker.mgts.by:80/announce&tr=http://tracker.city9x.com:2710/announce&tr=http://tracker.electro-torrent.pl:80/announce&tr=http://tracker.internetwarriors.net:1337/announce&tr=http://tracker2.itzmx.com:6961/announce&tr=udp://opentor.org:2710&tr=udp://public.popcorn-tracker.org:6969/announce&tr=udp://tracker.opentrackr.org:1337/announce&tr=http://bt.svao-ix.ru/announce&tr=udp://explodie.org:6969/announce&tr=wss://tracker.btorrent.xyz&tr=wss://tracker.openwebtorrent.com";

        static ClientEngine torrentEngine;
        static DateTime lastBullderClientEngineCall = DateTime.MinValue;

        public static void Initialization()
        {
            Directory.CreateDirectory("cache/torrent");
            Directory.CreateDirectory($"{dlna_path}/");
            Directory.CreateDirectory($"{dlna_path}/thumbs/");
            Directory.CreateDirectory($"{dlna_path}/tmdb/");

            ThreadPool.QueueUserWorkItem(async _ =>
            {
                string trackers_best_ip = await Http.Get("https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_best_ip.txt", timeoutSeconds: 20);
                if (trackers_best_ip != null)
                {
                    foreach (string line in trackers_best_ip.Split("\n"))
                    {
                        string tr = line.Replace("\n", "").Replace("\r", "").Trim();
                        if (!string.IsNullOrWhiteSpace(tr))
                            defTrackers += $"&tr={tr}";
                    }
                }
            });

            ThreadPool.QueueUserWorkItem(async _ =>
            {
                while (true)
                {
                    try
                    {
                        await Task.Delay(TimeSpan.FromMinutes(5));
                        await removeClientEngine();
                    }
                    catch { }
                }
            });

            ThreadPool.QueueUserWorkItem(async _ =>
            {
                while (true)
                {
                    try
                    {
                        await Task.Delay(TimeSpan.FromMinutes(1));

                        if (torrentEngine == null)
                            continue;

                        if (lastBullderClientEngineCall == DateTime.MinValue || DateTime.UtcNow - lastBullderClientEngineCall < TimeSpan.FromMinutes(10))
                            continue;

                        if (!HasActiveTorrentTasks())
                            await removeClientEngine();
                    }
                    catch { }
                }
            });

            if (!Directory.Exists("cache/metadata"))
                return;

            #region Resume download
            var _files = Directory.GetFiles("cache/metadata", "*.torrent");
            if (_files.Length == 0)
                return;

            bullderClientEngine();

            foreach (string path in _files)
            {
                var t = Torrent.Load(path);
                var manager = AppInit.conf.dlna.mode == "stream" ? torrentEngine.AddStreamingAsync(t, $"{dlna_path}/").Result : torrentEngine.AddAsync(t, $"{dlna_path}/").Result;

                //if (FastResume.TryLoad($"cache/fastresume/{t.InfoHash.ToHex()}.fresume", out FastResume resume))
                //    manager.LoadFastResume(resume);

                int[] indexs = null;

                try
                {
                    if (IO.File.Exists($"cache/metadata/{t.InfoHashes.V1.ToHex()}.json"))
                        indexs = JsonConvert.DeserializeObject<int[]>(IO.File.ReadAllText($"cache/metadata/{t.InfoHashes.V1.ToHex()}.json"));
                }
                catch { }

                bool setPriority = false;

                manager.TorrentStateChanged += async (s, e) =>
                {
                    try
                    {
                        if (e != null && e.NewState == TorrentState.Seeding)
                            await e.TorrentManager.StopAsync();

                        if (e != null && (e.NewState == TorrentState.Metadata || e.NewState == TorrentState.Hashing || e.NewState == TorrentState.Downloading))
                        {
                            if (!setPriority)
                            {
                                setPriority = true;

                                if (indexs == null || indexs.Length == 0)
                                {
                                    await manager.SetFilePriorityAsync(manager.Files[0], Priority.High);
                                }
                                else
                                {
                                    for (int i = 0; i < manager.Files.Count; i++)
                                    {
                                        if (indexs.Contains(i))
                                        {
                                            await manager.SetFilePriorityAsync(manager.Files[i], i == indexs[0] ? Priority.High : Priority.Normal);
                                        }
                                        else
                                        {
                                            await manager.SetFilePriorityAsync(manager.Files[i], Priority.DoNotDownload);
                                        }
                                    }
                                }
                            }
                        }

                        if (e != null && (e.NewState == TorrentState.Stopped || e.NewState == TorrentState.Stopping))
                        {
                            try
                            {
                                IO.File.Delete(path);
                                IO.File.Delete(path.Replace(".torrent", ".json"));
                            }
                            catch { }

                            foreach (var f in e.TorrentManager.Files)
                            {
                                try
                                {
                                    if (f.Priority == Priority.DoNotDownload && IO.File.Exists(f.FullPath))
                                        IO.File.Delete(f.FullPath);
                                }
                                catch { }
                            }

                            await removeClientEngine(e.TorrentManager.InfoHashes.V1.ToHex().ToLower());
                        }
                    }
                    catch { }
                };
            }
            #endregion
        }
        #endregion

        #region dlna.js
        [HttpGet]
        [AllowAnonymous]
        [Route("dlna.js")]
        [Route("dlna/js/{token}")]
        public ActionResult Plugin(string token)
        {
            if (!AppInit.conf.dlna.enable)
                return Content(string.Empty);

            var sb = new StringBuilder(FileCache.ReadAllText("plugins/dlna.js"));

            sb.Replace("{localhost}", host)
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        #region bullderClientEngine
        static Task bullderClientEngine(int connectionTimeout = 10)
        {
            lastBullderClientEngineCall = DateTime.UtcNow;

            if (torrentEngine != null)
                return Task.CompletedTask;

            EngineSettingsBuilder engineSettingsBuilder = new EngineSettingsBuilder()
            {
                MaximumHalfOpenConnections = 20,
                ConnectionTimeout = TimeSpan.FromSeconds(connectionTimeout),
                MaximumDownloadRate = AppInit.conf.dlna.downloadSpeed,
                MaximumUploadRate = AppInit.conf.dlna.uploadSpeed,
                MaximumDiskReadRate = AppInit.conf.dlna.maximumDiskReadRate,
                MaximumDiskWriteRate = AppInit.conf.dlna.maximumDiskWriteRate
            };

            torrentEngine = new ClientEngine(engineSettingsBuilder.ToSettings());
            return torrentEngine.StartAllAsync();
        }
        #endregion

        #region HasActiveTorrentTasks
        static bool HasActiveTorrentTasks()
        {
            try
            {
                if (torrentEngine?.Torrents == null)
                    return false;

                foreach (var torrent in torrentEngine.Torrents)
                {
                    if (torrent.State == TorrentState.Metadata || torrent.State == TorrentState.Downloading || torrent.State == TorrentState.Starting || torrent.State == TorrentState.Hashing)
                        return true;
                }
            }
            catch { }

            return false;
        }
        #endregion

        #region removeClientEngine
        async static Task removeClientEngine(string hash = null)
        {
            try
            {
                if (torrentEngine?.Torrents != null)
                {
                    var tdl = new List<TorrentManager>();

                    foreach (var i in torrentEngine.Torrents)
                    {
                        if (hash != null)
                        {
                            if (i.InfoHashes.V1.ToHex().ToLower() == hash)
                            {
                                try
                                {
                                    await i.StopAsync(TimeSpan.FromSeconds(20));
                                }
                                catch { }

                                tdl.Add(i);
                            }
                        }
                        else
                        {
                            if (i.State == TorrentState.Seeding || i.State == TorrentState.Stopped || i.State == TorrentState.Stopping)
                            {
                                try
                                {
                                    await i.StopAsync(TimeSpan.FromSeconds(120));
                                }
                                catch { }

                                tdl.Add(i);
                            }
                        }
                    }

                    if (tdl.Count > 0)
                    {
                        foreach (var item in tdl)
                        {
                            try
                            {
                                torrentEngine.Torrents.Remove(item);
                            }
                            catch { }

                            try
                            {
                                await torrentEngine.RemoveAsync(item);
                            }
                            catch { }
                        }

                    }

                    if (torrentEngine.Torrents.Count == 0)
                    {
                        try
                        {
                            await torrentEngine.StopAllAsync();
                        }
                        catch { }

                        torrentEngine.Dispose();
                        torrentEngine = null;
                    }
                }
            }
            catch { }
        }
        #endregion

        #region getTorrent
        async ValueTask<(string magnet, byte[] torrent)> getTorrent(string path)
        {
            if (!path.StartsWith("http"))
                return (path, null);

            string memkey = $"DLNAController:getTorrent:{path}";
            if (!memoryCache.TryGetValue(memkey, out (string magnet, byte[] torrent) cache))
            {
                var handler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                };

                handler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;

                using (var client = new System.Net.Http.HttpClient(handler))
                {
                    client.Timeout = TimeSpan.FromSeconds(10);

                    using (var response = await client.GetAsync(path))
                    {
                        if (response.StatusCode == System.Net.HttpStatusCode.OK)
                        {
                            using (var content = response.Content)
                            {
                                var t = await content.ReadAsByteArrayAsync();
                                cache.magnet = BencodeTo.Magnet(t);
                                if (cache.magnet != null)
                                    cache.torrent = t;
                            }
                        }
                        else if ((int)response.StatusCode is 301 or 302 or 307)
                        {
                            string location = response.Headers.Location?.ToString() ?? response.RequestMessage.RequestUri?.ToString();
                            if (location != null && location.StartsWith("magnet:"))
                                cache.magnet = location;
                        }
                    }
                }

                if (cache.magnet == null && cache.torrent == null)
                    return (null, null);

                memoryCache.Set(memkey, cache, DateTime.Now.AddMinutes(10));
            }

            return (cache.magnet, cache.torrent);
        }
        #endregion

        #region getTmdb
        JObject getTmdb(string name)
        {
            try
            {
                string file = $"{dlna_path}/tmdb/{CrypTo.md5(name)}.json";
                if (IO.File.Exists(file))
                {
                    var tmdb = JsonConvert.DeserializeObject<JObject>(IO.File.ReadAllText(file));
                    tmdb.Remove("created_by");
                    tmdb.Remove("networks");
                    tmdb.Remove("production_companies");

                    return tmdb;
                }
            }
            catch { }

            return null;
        }
        #endregion

        #region getEpisodes
        JArray getEpisodes(JObject tmdb, string fileName)
        {
            try
            {
                if (tmdb == null || !tmdb.ContainsKey("number_of_seasons"))
                    return null;

                int season = getSeason(fileName);

                string file = $"{dlna_path}/tmdb/{tmdb.Value<long>("id")}_season-{season}.json";
                if (IO.File.Exists(file))
                {
                    if (memoryCache.TryGetValue(file, out JArray episodes))
                        return episodes;

                    episodes = JsonConvert.DeserializeObject<JObject>(IO.File.ReadAllText(file)).Value<JArray>("episodes");
                    
                    memoryCache.Set(file, episodes, DateTime.Now.AddSeconds(10));
                    return episodes;
                }
            }
            catch { }

            return null;
        }
        #endregion

        #region getEpisode
        int getEpisode(string fileName)
        {
            if (int.TryParse(Regex.Match(fileName, "EP?([0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value, out int _e) && _e > 0)
                return _e;

            return 0;
        }
        #endregion

        #region getSeason
        int getSeason(string fileName)
        {
            if (int.TryParse(Regex.Match(fileName, "S([0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value, out int _s) && _s > 0)
                return _s;

            return 0;
        }
        #endregion


        #region Navigation
        [HttpGet]
        [Route("dlna")]
        public ActionResult Index(string path)
        {
            if (!AppInit.conf.dlna.enable)
                return Json(new { });

            #region getImage
            string getImage(string name)
            {
                string pathimage = $"thumbs/{name}.jpg";
                if (IO.File.Exists($"{dlna_path}/" + pathimage))
                    return $"{host}/dlna/stream?path={HttpUtility.UrlEncode(pathimage)}";

                return null;
            }
            #endregion

            #region getPreview
            string getPreview(string name)
            {
                string pathimage = $"temp/{name}.mp4";
                if (IO.File.Exists($"{dlna_path}/" + pathimage))
                    return $"{host}/dlna/stream?path={HttpUtility.UrlEncode(pathimage)}";

                pathimage = $"temp/{name}.webm";
                if (IO.File.Exists($"{dlna_path}/" + pathimage))
                    return $"{host}/dlna/stream?path={HttpUtility.UrlEncode(pathimage)}";

                return null;
            }
            #endregion

            #region countFiles
            int countFiles(string _path)
            {
                int count = 0;

                foreach (string file in Directory.GetFiles(_path))
                {
                    if (!Regex.IsMatch(Path.GetExtension(file), AppInit.conf.dlna.mediaPattern))
                        continue;

                    if (new FileInfo(file).Length > 0)
                        count++;
                }

                return count;
            }
            #endregion

            var playlist = new List<DlnaModel>();

            #region folders
            foreach (string folder in Directory.GetDirectories($"{dlna_path}/" + path))
            {
                if (folder.Contains("thumbs") || folder.Contains("tmdb") || folder.Contains("temp"))
                    continue;

                int length = countFiles(folder);
                if (length > 0 || Directory.GetDirectories(folder).Length > 0)
                {
                    playlist.Add(new DlnaModel()
                    {
                        type = "folder",
                        name = Path.GetFileName(folder),
                        uri = $"{host}/dlna?path={HttpUtility.UrlEncode(folder.Replace($"{dlna_path}/", ""))}",
                        img = getImage(CrypTo.md5(Path.GetFileName(folder))),
                        preview = getPreview(CrypTo.md5(Path.GetFileName(folder))),
                        path = folder.Replace($"{dlna_path}/", ""),
                        length = countFiles(folder),
                        creationTime = Directory.GetCreationTime(folder),
                        tmdb = getTmdb(Path.GetFileName(folder))
                    });
                }
            }
            #endregion

            #region files
            var filesTmdb = getTmdb(path);
            var subtitles = Directory.GetFiles($"{dlna_path}/" + path, "*.srt");

            foreach (string file in Directory.GetFiles($"{dlna_path}/" + path))
            {
                if (!Regex.IsMatch(Path.GetExtension(file), AppInit.conf.dlna.mediaPattern))
                    continue;

                string name = Path.GetFileName(file);
                var fileinfo = new FileInfo(file);
                if (fileinfo.Length == 0)
                    continue;

                JObject episodeTmdb = null;

                string img = getImage(CrypTo.md5(name));
                var episodes = getEpisodes(filesTmdb, name);
                if (episodes != null)
                {
                    int episode = getEpisode(name);
                    if (episode > 0)
                    {
                        episodeTmdb = episodes.FirstOrDefault(i => i.Value<int>("episode_number") == episode)?.ToObject<JObject>();
                        episodeTmdb.Remove("crew");
                        episodeTmdb.Remove("guest_stars");

                        if (episodeTmdb != null && episodeTmdb.ContainsKey("still_path"))
                            img = $"tmdb:/t/p/w400" + episodeTmdb.Value<string>("still_path");
                    }
                }

                if (img == null)
                    img = getImage(CrypTo.md5($"{path}/{name}"));

                var dlnaModel = new DlnaModel()
                {
                    type = "file",
                    name = name,
                    uri = $"{host}/dlna/stream?path={HttpUtility.UrlEncode(file.Replace($"{dlna_path}/", ""))}",
                    img = img,
                    preview = getPreview(CrypTo.md5(name)),
                    subtitles = new List<Subtitle>(),
                    path = file.Replace($"{dlna_path}/", ""),
                    length = fileinfo.Length,
                    creationTime = fileinfo.CreationTime,
                    s = getSeason(name),
                    e = getEpisode(name),
                    tmdb = string.IsNullOrEmpty(path) ? getTmdb(name) : filesTmdb,
                    episode = episodeTmdb
                };

                #region subtitles
                foreach (string subfile in subtitles)
                {
                    if (subfile.Contains(Path.GetFileNameWithoutExtension(file)))
                    {
                        dlnaModel.subtitles.Add(new Subtitle()
                        {
                            label = "Sub #1",
                            url = $"{host}/dlna/stream?path={HttpUtility.UrlEncode($"{path}/{Path.GetFileName(subfile)}")}"
                        });
                    }
                }
                #endregion

                playlist.Add(dlnaModel);
            }
            #endregion

            var jSettings = new JsonSerializerSettings()
            {
                DefaultValueHandling = DefaultValueHandling.Ignore,
                NullValueHandling = NullValueHandling.Ignore
            };

            if (string.IsNullOrWhiteSpace(path))
            {
                #region torrentEngine
                if (torrentEngine?.Torrents != null)
                {
                    foreach (var t in torrentEngine.Torrents)
                    {
                        if (t.State == TorrentState.Metadata || t.State == TorrentState.Downloading || t.State == TorrentState.Starting)
                        {
                            if (t.Torrent?.Name == null || (!IO.File.Exists($"{dlna_path}/{t.Torrent.Name}") && !Directory.Exists($"{dlna_path}/{t.Torrent.Name}")))
                            {
                                playlist.Add(new DlnaModel()
                                {
                                    type = "file",
                                    name = t.Torrent?.Name ?? t.InfoHashes.V1.ToHex(),
                                    img = getImage(t.InfoHashes.V1.ToHex())
                                });
                            }
                        }
                    }
                }
                #endregion

                return ContentTo(JsonConvert.SerializeObject(playlist.OrderByDescending(i => i.creationTime), jSettings));
            }

            return ContentTo(JsonConvert.SerializeObject(playlist.OrderBy(i =>
            {
                ulong.TryParse(Regex.Replace(i.name, "[^0-9]+", ""), out ulong ident);
                return ident;

            }), jSettings));
        }
        #endregion

        #region Stream
        [Route("dlna/stream")]
        public ActionResult Stream(string path)
        {
            if (!AppInit.conf.dlna.enable)
                return Json(new { });

            string contentType = "application/octet-stream";

            if (path.EndsWith(".jpg"))
                contentType = "image/jpeg";

            return File(IO.File.OpenRead($"{dlna_path}/" + path), contentType, true);
        }
        #endregion

        #region Delete
        [HttpGet]
        [Route("dlna/delete")]
        public ActionResult Delete(string path)
        {
            if (!AppInit.conf.dlna.enable)
                return Content(string.Empty);

            try
            {
                IO.File.Delete($"{dlna_path}/" + path);
            }
            catch { }

            try
            {
                Directory.Delete($"{dlna_path}/" + path, true);
            }
            catch { }

            return Content(string.Empty);
        }
        #endregion


        #region Managers
        [HttpGet]
        [Route("dlna/tracker/managers")]
        public ActionResult Managers()
        {
            if (!AppInit.conf.dlna.enable || torrentEngine?.Torrents == null)
                return Content("[]");

            return Json(torrentEngine.Torrents.Select(i => new
            {
                InfoHash = i.InfoHashes.V1.ToHex(),
                Name = i.Torrent?.Name ?? i.InfoHashes.V1.ToHex(),
                //Engine = new 
                //{
                //    i.Engine.ConnectionManager.HalfOpenConnections,
                //    i.Engine.ConnectionManager.OpenConnections,
                //    i.Engine.TotalDownloadSpeed,
                //    i.Engine.TotalUploadSpeed,
                //},
                Files = i.Files?.Select(f => new
                {
                    f.Path,
                    Priority = f.Priority.ToString(),
                    f.Length,
                    BytesDownloaded = f.BytesDownloaded()
                }),
                i.Monitor,
                i.OpenConnections,
                i.PartialProgress,
                i.Progress,
                i.Peers,
                State = i.State.ToString(),
                i.UploadingTo
            }));
        }
        #endregion

        #region Show
        [HttpGet]
        [Route("dlna/tracker/show")]
        async public Task<JsonResult> Show(string path)
        {
            if (!AppInit.conf.dlna.enable)
                return Json(new { error = "enable" });

            try
            {
                var tparse = await getTorrent(path);
                if (tparse.torrent != null)
                    return Json(Torrent.Load(tparse.torrent).Files.Select(i => new { i.Path }));

                if (tparse.magnet == null)
                    return Json(new { error = "magnet" });

                string hash = Regex.Match(tparse.magnet, "btih:([a-z0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value.ToLower();
                if (IO.File.Exists($"cache/torrent/{hash}"))
                    return Json(Torrent.Load(IO.File.ReadAllBytes($"cache/torrent/{hash}")).Files.Select(i => new { i.Path }));

                var s_cts = new CancellationTokenSource();
                s_cts.CancelAfter(1000 * 60 * 3);

                string magnet = tparse.magnet;
                magnet += (magnet.Contains("?") ? "&" : "?") + defTrackers;

                #region trackers
                //if (IO.File.Exists("cache/trackers.txt") && AppInit.conf.dlna.addTrackersToMagnet)
                //{
                //    foreach (string line in IO.File.ReadLines("cache/trackers.txt"))
                //    {
                //        if (string.IsNullOrWhiteSpace(line))
                //            continue;

                //        if (line.StartsWith("http") || line.StartsWith("udp:"))
                //        {
                //            string host = line.Replace("\r", "").Replace("\n", "").Replace("\t", "").Trim();
                //            string tr = HttpUtility.UrlEncode(host);

                //            if (!magnet.Contains(tr))
                //                magnet += $"&tr={tr}";
                //        }
                //    }
                //}
                #endregion

                await bullderClientEngine();

                if (torrentEngine.Torrents.FirstOrDefault(i => i.InfoHashes.V1.ToHex().ToLower() == hash) is TorrentManager manager)
                {
                    if (manager.Files != null)
                        return Json(manager.Files.Select(i => (ITorrentFile)i).Select(i => new { i.Path }));

                    await manager.WaitForMetadataAsync(s_cts.Token);
                    var files = manager.Files.Select(i => (ITorrentFile)i);
                    return Json(files.Select(i => new { i.Path }));
                }

                var data = await torrentEngine.DownloadMetadataAsync(MagnetLink.Parse(magnet), s_cts.Token);
                if (data.IsEmpty)
                    return Json(new { error = "DownloadMetadata" });

                var array = data.Span.ToArray();
                IO.File.WriteAllBytes($"cache/torrent/{hash}", array);

                return Json(Torrent.Load(array).Files.Select(i => new { i.Path }));
            }
            catch (Exception ex)
            {
                return Json(new { error = ex.ToString() });
            }
        }
        #endregion

        #region Download
        [HttpGet]
        [Route("dlna/tracker/download")]
        async public Task<JsonResult> Download(string path, int[] indexs, string thumb, long id, bool serial, int lastCount = -1)
        {
            if (!AppInit.conf.dlna.enable)
                return Json(new { error = "enable" });

            try
            {
                var tparse = await getTorrent(path);
                if (tparse.magnet == null)
                    return Json(new { error = "magnet" });

                // cache metadata
                string hash = Regex.Match(tparse.magnet, "btih:([a-z0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value.ToLower();
                if (IO.File.Exists($"cache/torrent/{hash}") && !IO.File.Exists($"cache/metadata/{hash.ToUpper()}.torrent"))
                    IO.File.Copy($"cache/torrent/{hash}", $"cache/metadata/{hash.ToUpper()}.torrent");
                
                var magnetLink = MagnetLink.Parse(tparse.magnet + (tparse.magnet.Contains("?") ? "&" : "?") + defTrackers);

                await bullderClientEngine();
                TorrentManager manager = torrentEngine.Torrents.FirstOrDefault(i => i.InfoHashes.V1.ToHex() == magnetLink.InfoHashes.V1.ToHex());

                ThreadPool.QueueUserWorkItem(async _ =>
                {
                    try
                    {
                        #region Download thumb
                        if (thumb != null)
                        {
                            try
                            {
                                #region IsValidImg
                                bool IsValidImg(byte[] _img)
                                {
                                    if (AppInit.conf.imagelibrary == "NetVips")
                                        return IsValidImgage(_img, path);

                                    return true;
                                }
                                #endregion

                                string uri = Regex.Replace(thumb, "^https?://[^/]+/", "");

                                var array = await Http.Download($"https://image.tmdb.org/{uri}", timeoutSeconds: 8);
                                if (array == null || !IsValidImg(array))
                                    array = await Http.Download($"https://imagetmdb.{AppInit.conf.cub.mirror}/{uri}");

                                if (array != null && IsValidImg(array))
                                {
                                    Directory.CreateDirectory($"{dlna_path}/thumbs");
                                    IO.File.WriteAllBytes($"{dlna_path}/thumbs/{magnetLink.InfoHashes.V1.ToHex()}.jpg", array);
                                }
                            }
                            catch { }
                        }
                        #endregion

                        if (manager == null)
                        {
                            dynamic tlink = tparse.torrent != null ? Torrent.Load(tparse.torrent) : magnetLink;
                            manager = AppInit.conf.dlna.mode == "stream" ? await torrentEngine.AddStreamingAsync(tlink, $"{dlna_path}/") : await torrentEngine.AddAsync(tlink, $"{dlna_path}/");

                            #region AddTrackerAsync
                            if (IO.File.Exists("cache/trackers.txt") && AppInit.conf.dlna.addTrackersToMagnet)
                            {
                                foreach (string line in IO.File.ReadLines("cache/trackers.txt").OrderBy(x => Random.Shared.Next()))
                                {
                                    if (string.IsNullOrWhiteSpace(line))
                                        continue;

                                    string host = line.Replace("\r", "").Replace("\n", "").Replace("\t", "").Trim();

                                    if (host.StartsWith("http") || host.StartsWith("udp:"))
                                    {
                                        try
                                        {
                                            await manager.TrackerManager.AddTrackerAsync(new Uri(host));
                                        }
                                        catch { }
                                    }
                                }
                            }
                            #endregion
                        }

                        await manager.StartAsync();
                        await manager.WaitForMetadataAsync();

                        #region thumb
                        if (IO.File.Exists($"{dlna_path}/thumbs/{magnetLink.InfoHashes.V1.ToHex()}.jpg"))
                        {
                            try
                            {
                                IO.File.Copy($"{dlna_path}/thumbs/{magnetLink.InfoHashes.V1.ToHex()}.jpg", $"{dlna_path}/thumbs/{CrypTo.md5(manager.Torrent.Name)}.jpg", true);
                            }
                            catch { }
                        }
                        #endregion

                        #region TorrentStateChanged
                        bool dispose = false;

                        manager.TorrentStateChanged += async (s, e) =>
                        {
                            try
                            {
                                if (!dispose && e != null && (e.NewState == TorrentState.Seeding || e.NewState == TorrentState.Stopped || e.NewState == TorrentState.Stopping))
                                {
                                    dispose = true;

                                    try
                                    {
                                        IO.File.Delete($"cache/metadata/{e.TorrentManager.InfoHashes.V1.ToHex()}.torrent");
                                        IO.File.Delete($"cache/metadata/{e.TorrentManager.InfoHashes.V1.ToHex()}.json");
                                    }
                                    catch { }

                                    foreach (var f in e.TorrentManager.Files)
                                    {
                                        try
                                        {
                                            if (f.Priority == Priority.DoNotDownload && IO.File.Exists(f.FullPath))
                                            {
                                                if (f.Length == 0 || f.BytesDownloaded() == 0)
                                                {
                                                    IO.File.Delete(f.FullPath);
                                                }
                                                else
                                                {
                                                    double percentageDownloaded = (double)f.BytesDownloaded() / f.Length;

                                                    if (percentageDownloaded < 0.9)
                                                        IO.File.Delete(f.FullPath);
                                                }
                                            }
                                        }
                                        catch { }
                                    }

                                    await removeClientEngine(e.TorrentManager.InfoHashes.V1.ToHex().ToLower());
                                }
                            }
                            catch { }
                        };
                        #endregion

                        #region lastCount
                        if (lastCount > 0 && manager.Files.Count >= lastCount)
                        {
                            var _indexs = new List<int>();
                            for (int i = manager.Files.Count-1; i >= 0; i--)
                            {
                                if (_indexs.Count == lastCount)
                                    break;

                                if (!Regex.IsMatch(Path.GetExtension(manager.Files[i].Path), AppInit.conf.dlna.mediaPattern))
                                    continue;

                                _indexs.Add(i);
                            }

                            indexs = _indexs.ToArray();
                        }
                        #endregion

                        #region indexs
                        if (indexs == null || indexs.Length == 0)
                        {
                            foreach (var file in manager.Files)
                            {
                                if (file.Priority != Priority.Normal)
                                    await manager.SetFilePriorityAsync(file, Priority.Normal);
                            }
                        }
                        else
                        {
                            Directory.CreateDirectory("cache/metadata/");
                            IO.File.WriteAllText($"cache/metadata/{manager.InfoHashes.V1.ToHex()}.json", JsonConvert.SerializeObject(indexs));

                            for (int i = 0; i < manager.Files.Count; i++)
                            {
                                if (indexs.Contains(i))
                                {
                                    if (manager.Files[i].Priority != Priority.Normal)
                                        await manager.SetFilePriorityAsync(manager.Files[i], Priority.Normal);
                                }
                                else
                                {
                                    if (manager.Files[i].Priority != Priority.DoNotDownload)
                                        await manager.SetFilePriorityAsync(manager.Files[i], Priority.DoNotDownload);
                                }
                            }
                        }
                        #endregion

                        #region tmdb
                        string cat = serial ? "tv" : "movie";
                        var header = HeadersModel.Init(("localrequest", AppInit.rootPasswd));
                        string json = await Http.Get($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/3/{cat}/{id}?api_key={AppInit.conf.tmdb.api_key}&language=ru", timeoutSeconds: 20, headers: header);

                        if (string.IsNullOrEmpty(json))
                            json = await Http.Get($"https://apitmdb.{AppInit.conf.cub.mirror}/3/{cat}/{id}?api_key={AppInit.conf.tmdb.api_key}&language=ru", timeoutSeconds: 20);

                        if (!string.IsNullOrEmpty(json))
                        {
                            IO.File.WriteAllText($"{dlna_path}/tmdb/{CrypTo.md5(manager.Torrent.Name)}.json", json);

                            if (serial)
                            {
                                if (int.TryParse(Regex.Match(json, "\"number_of_seasons\":([0-9 ]+)").Groups[1].Value.Trim(), out int number_of_seasons) && number_of_seasons > 0)
                                {
                                    async ValueTask write(int s)
                                    {
                                        string seasons = await Http.Get($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/3/{cat}/{id}/season/{s}?api_key={AppInit.conf.tmdb.api_key}&language=ru", timeoutSeconds: 20, headers: header);

                                        if (string.IsNullOrEmpty(seasons))
                                            seasons = await Http.Get($"https://apitmdb.{AppInit.conf.cub.mirror}/3/{cat}/{id}/season/{s}?api_key={AppInit.conf.tmdb.api_key}&language=ru", timeoutSeconds: 20);

                                        if (!string.IsNullOrEmpty(seasons))
                                            IO.File.WriteAllText($"{dlna_path}/tmdb/{id}_season-{s}.json", json);
                                    }

                                    if (number_of_seasons == 1)
                                        await write(number_of_seasons);
                                    else
                                    {
                                        foreach (var f in manager.Files)
                                        {
                                            int s = getSeason(Path.GetFileName(f.Path));
                                            if (s > 0)
                                                await write(s);
                                        }
                                    }
                                }
                            }
                        }
                        #endregion
                    }
                    catch { }
                });
            }
            catch (Exception ex)
            {
                return Json(new { error = ex.ToString() });
            }

            return Json(new { status = true });
        }
        #endregion


        #region Delete
        [HttpGet]
        [Route("dlna/tracker/stop")]
        [Route("dlna/tracker/delete")]
        async public Task<JsonResult> TorrentDelete(string infohash)
        {
            if (!AppInit.conf.dlna.enable || torrentEngine == null)
                return Json(new { });

            var manager = torrentEngine.Torrents.FirstOrDefault(i => i.InfoHashes.V1.ToHex() == infohash);
            if (manager != null)
            {
                try
                {
                    IO.File.Delete($"cache/metadata/{manager.InfoHashes.V1.ToHex()}.torrent");
                    IO.File.Delete($"cache/metadata/{manager.InfoHashes.V1.ToHex()}.json");
                }
                catch { }

                try
                {
                    await manager.StopAsync();
                }
                catch { }

                await removeClientEngine(manager.InfoHashes.V1.ToHex().ToLower());
            }

            return Json(new { status = true });
        }
        #endregion

        #region Pause
        [HttpGet]
        [Route("dlna/tracker/pause")]
        async public Task<JsonResult> TorrentPause(string infohash)
        {
            if (!AppInit.conf.dlna.enable || torrentEngine == null)
                return Json(new { });

            var manager = torrentEngine.Torrents.FirstOrDefault(i => i.InfoHashes.V1.ToHex() == infohash);
            if (manager != null)
                await manager.PauseAsync();

            return Json(new { status = true });
        }
        #endregion

        #region Start
        [HttpGet]
        [Route("dlna/tracker/start")]
        async public Task<JsonResult> TorrentStart(string infohash)
        {
            if (!AppInit.conf.dlna.enable || torrentEngine == null)
                return Json(new { });

            var manager = torrentEngine.Torrents.FirstOrDefault(i => i.InfoHashes.V1.ToHex() == infohash);
            if (manager != null)
                await manager.StartAsync();

            return Json(new { status = true });
        }
        #endregion

        #region ChangeFilePriority
        [HttpGet]
        [Route("dlna/tracker/changefilepriority")]
        async public Task<JsonResult> ChangeFilePriority(string infohash, int[] indexs)
        {
            if (!AppInit.conf.dlna.enable || torrentEngine == null)
                return Json(new { });

            var manager = torrentEngine.Torrents.FirstOrDefault(i => i.InfoHashes.V1.ToHex() == infohash);
            if (manager != null)
            {
                if (indexs == null || indexs.Length == 0)
                {
                    foreach (var file in manager.Files)
                    {
                        if (file.Priority != Priority.Normal)
                            await manager.SetFilePriorityAsync(file, Priority.Normal);
                    }

                    if (IO.File.Exists($"cache/metadata/{manager.InfoHashes.V1.ToHex()}.json"))
                        IO.File.Delete($"cache/metadata/{manager.InfoHashes.V1.ToHex()}.json");
                }
                else
                {
                    Directory.CreateDirectory("cache/metadata/");
                    IO.File.WriteAllText($"cache/metadata/{manager.InfoHashes.V1.ToHex()}.json", JsonConvert.SerializeObject(indexs));

                    for (int i = 0; i < manager.Files.Count; i++)
                    {
                        if (indexs.Contains(i))
                        {
                            if (manager.Files[i].Priority != Priority.Normal)
                                await manager.SetFilePriorityAsync(manager.Files[i], Priority.Normal);
                        }
                        else
                        {
                            if (manager.Files[i].Priority != Priority.DoNotDownload)
                                await manager.SetFilePriorityAsync(manager.Files[i], Priority.DoNotDownload);
                        }
                    }
                }
            }

            return Json(new { status = true });
        }
        #endregion



        #region IsValidImgage
        static bool IsValidImgage(byte[] _img, string path)
        {
            if (_img == null)
                return false;

            using (var image = Image.NewFromBuffer(_img))
            {
                try
                {
                    if (!path.Contains(".svg"))
                    {
                        // —Ç–µ—Å—Ç–∏—Ä—É–µ–º jpg/png –Ω–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å
                        byte[] temp = image.JpegsaveBuffer();
                        if (temp == null || temp.Length == 0)
                            return false;
                    }

                    return true;
                }
                catch
                {
                    return false;
                }
            }
        }
        #endregion
    }
}
```

## File: DLNA/ModInit.cs
```
Ôªøusing DLNA.Controllers;
using Shared;
using Shared.Engine;
using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace DLNA
{
    public class ModInit
    {
        public static void loaded()
        {
            DLNAController.Initialization();

            var init = AppInit.conf.dlna;
            var cover = init.cover;
            Directory.CreateDirectory($"{init.path}/temp/");

            ThreadPool.QueueUserWorkItem(async _ => 
            {
                bool? ffmpegInit = null;

                while (true)
                {
                    if (cover.timeout == -666)
                        await Task.Delay(TimeSpan.FromSeconds(5));
                    else
                        await Task.Delay(TimeSpan.FromMinutes(cover.timeout > 0 ? cover.timeout : 1));

                    if (!init.enable || !cover.enable)
                        continue;

                    if (ffmpegInit == null)
                    {
                        ffmpegInit = await FFmpeg.InitializationAsync();
                        if (ffmpegInit == false)
                            break;
                    }

                    try
                    {
                        #region path files
                        foreach (string file in Directory.GetFiles(init.path))
                        {
                            if (!Regex.IsMatch(Path.GetExtension(file), cover.extension))
                                continue;

                            string name = Path.GetFileName(file);
                            var fileinfo = new FileInfo(file);
                            if (fileinfo.Length == 0)
                                continue;

                            var time = fileinfo.CreationTime > fileinfo.LastWriteTime ? fileinfo.CreationTime : fileinfo.LastWriteTime;
                            if (time.AddMinutes(cover.skipModificationTime) > DateTime.Now)
                            {
                                log("skip time: " + file);
                                continue;
                            }

                            string thumb = Path.Combine(init.path, "thumbs", $"{CrypTo.md5(name)}.jpg");
                            if (File.Exists(thumb))
                            {
                                log("thumb ok: " + file);
                                continue;
                            }

                            string lockfile = Path.Combine(init.path, "temp", $"{CrypTo.md5(name)}-ffmpeg.lock");
                            if (File.Exists(lockfile))
                            {
                                log("lock: " + file);
                                continue;
                            }

                            File.Create(lockfile);

                            string coverComand = cover.coverComand.Replace("{file}", file).Replace("{thumb}", thumb);
                            log("\ncoverComand: " + coverComand);
                            var ffmpegLog = await FFmpeg.RunAsync(coverComand, priorityClass: cover.priorityClass);

                            log(ffmpegLog.outputData);
                            log(ffmpegLog.errorData);

                            if (cover.preview)
                            {
                                string preview = Path.Combine(init.path, "temp", $"{CrypTo.md5(name)}.mp4");
                                string previewComand = cover.previewComand.Replace("{file}", file).Replace("{preview}", preview);

                                log("\npreviewComand: " + previewComand);
                                ffmpegLog = await FFmpeg.RunAsync(previewComand, priorityClass: cover.priorityClass);

                                log(ffmpegLog.outputData);
                                log(ffmpegLog.errorData);
                            }
                        }
                        #endregion

                        #region path directories
                        foreach (string folder in Directory.GetDirectories(init.path))
                        {
                            if (folder.Contains("thumbs") || folder.Contains("tmdb") || folder.Contains("temp"))
                                continue;

                            string folder_name = Path.GetFileName(folder);
                            string folder_thumb = Path.Combine(init.path, "thumbs", $"{CrypTo.md5(folder_name)}.jpg");
                            if (File.Exists(folder_thumb))
                            {
                                log("thumb ok: " + folder);
                                continue;
                            }

                            var files = Directory.GetFiles(folder);
                            if (files.Length == 0)
                                continue;

                            var folderinfo = new DirectoryInfo(folder);
                            var time = folderinfo.CreationTime > folderinfo.LastWriteTime ? folderinfo.CreationTime : folderinfo.LastWriteTime;
                            if (time.AddMinutes(cover.skipModificationTime) > DateTime.Now)
                            {
                                log("skip time: " + folder);
                                continue;
                            }

                            string lockfile = Path.Combine(init.path, "temp", $"{CrypTo.md5(folder_name)}-ffmpeg.lock");
                            if (File.Exists(lockfile))
                            {
                                log("lock: " + folder);
                                continue;
                            }

                            File.Create(lockfile);

                            #region –ø–æ—Å—Ç–µ—Ä —Å –ø—Ä–µ–≤—å—é –Ω–∞ –ø–∞–ø–∫—É
                            {
                                string coverComand = cover.coverComand.Replace("{file}", files[0]).Replace("{thumb}", folder_thumb);
                                log("\ncoverComand: " + coverComand);
                                var ffmpegLog = await FFmpeg.RunAsync(coverComand, priorityClass: cover.priorityClass);

                                log(ffmpegLog.outputData);
                                log(ffmpegLog.errorData);

                                if (cover.preview)
                                {
                                    string preview = Path.Combine(init.path, "temp", $"{CrypTo.md5(folder_name)}.mp4");
                                    string previewComand = cover.previewComand.Replace("{file}", files[0]).Replace("{preview}", preview);

                                    log("\npreviewComand: " + previewComand);
                                    ffmpegLog = await FFmpeg.RunAsync(previewComand, priorityClass: cover.priorityClass);

                                    log(ffmpegLog.outputData);
                                    log(ffmpegLog.errorData);
                                }
                            }
                            #endregion

                            #region –ø–æ—Å—Ç–µ—Ä—ã –Ω–∞ —Ñ–∞–π–ª—ã –≤–Ω—É—Ç—Ä–∏ –ø–∞–ø–∫–∏
                            foreach (string file in files)
                            {
                                string name = $"{Path.GetFileName(folder)}/{Path.GetFileName(file)}";
                                string thumb = Path.Combine(init.path, "thumbs", $"{CrypTo.md5(name)}.jpg");

                                string coverComand = cover.coverComand.Replace("{file}", file).Replace("{thumb}", thumb);
                                log("\ncoverComand: " + coverComand);
                                var ffmpegLog = await FFmpeg.RunAsync(coverComand, priorityClass: cover.priorityClass);

                                log(ffmpegLog.outputData);
                                log(ffmpegLog.errorData);
                            }
                            #endregion
                        }
                        #endregion
                    }
                    catch { }
                }

            });
        }


        public static void log(string value)
        {
            if (AppInit.conf.dlna.cover.consoleLog && !string.IsNullOrEmpty(value))
                Console.WriteLine("\nFFmpeg: " + value);
        }
    }
}

```

## File: DLNA/Models/Subtitle.cs
```
Ôªønamespace DLNA.Models
{
    public class Subtitle
    {
        public string label { get; set; }

        public string url { get; set; }
    }
}

```

## File: DLNA/Models/DlnaModel.cs
```
Ôªøusing Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;

namespace DLNA.Models
{
    public class DlnaModel
    {
        public string name { get; set; }

        public string uri { get; set; }

        public string img { get; set; }

        public string preview { get; set; }

        public List<Subtitle> subtitles { get; set; }

        public string path { get; set; }

        public string type { get; set; }

        public long length { get; set; }

        public DateTime creationTime { get; set; }

        public int s { get; set; }

        public int e { get; set; }

        public JObject tmdb { get; set; }

        public JObject episode { get; set; }
    }
}

```

## File: Tracks/ModInit.cs
```
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Shared;
using Shared.Engine;
using Shared.Models.Module;
using System;
using System.IO;
using Tracks.Engine;

namespace Tracks
{
    public class ModInit
    {
        public static bool IsInitialization { get; private set; }

        public static void loaded(InitspaceModel initspace)
        {
            RegisterShutdown(initspace);

            Directory.CreateDirectory("database/tracks");
            FFprobe.InitializationAsync().ContinueWith(t =>
            {
                IsInitialization = t.Result;
                TranscodingService.Instance.Configure(AppInit.conf.transcoding);
            });
        }

        static void RegisterShutdown(InitspaceModel initspace)
        {
            if (initspace?.app?.ApplicationServices != null)
            {
                var lifetime = initspace.app.ApplicationServices.GetService<IHostApplicationLifetime>();
                lifetime?.ApplicationStopping.Register(StopTranscoding);
            }

            AppDomain.CurrentDomain.ProcessExit += (_, _) => StopTranscoding();
        }

        static void StopTranscoding()
        {
            try
            {
                TranscodingService.Instance.StopAll();
            }
            catch { }
        }
    }
}

```

## File: Tracks/TracksController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Shared;
using Shared.Engine;
using System;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Web;

namespace Tracks.Controllers
{
    public class TracksController : BaseController
    {
        [HttpGet]
        [AllowAnonymous]
        [Route("tracks.js")]
        [Route("tracks/js/{token}")]
        public ActionResult Tracks(string token)
        {
            if (!AppInit.conf.ffprobe.enable)
                return Content(string.Empty);

            var sb = new StringBuilder(FileCache.ReadAllText("plugins/tracks.js"));

            sb.Replace("{localhost}", host)
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }


        [Route("ffprobe")]
        async public Task<ActionResult> Ffprobe(string media, bool showerror)
        {
            if (!AppInit.conf.ffprobe.enable || string.IsNullOrWhiteSpace(media) || !media.StartsWith("http") || media.Contains("/transcoding/"))
                return ContentTo("{}");

            return ContentTo(await FfprobeJson(host, HttpContext, hybridCache, media));
        }


        public static async Task<string> FfprobeJson(string host, HttpContext httpContext, HybridCache hybridCache, string media, bool showerror = false)
        {
            string magnethash = null;

            if (media.Contains("/dlna/stream"))
            {
                string path = Regex.Match(media, "\\?path=([^&]+)").Groups[1].Value;
                if (!System.IO.File.Exists("dlna/" + HttpUtility.UrlDecode(path)))
                    return showerror ? "path" : "{}";

                magnethash = path;
            }
            else if (media.Contains("/stream/") || media.Contains("/lite/pidtor/"))
            {
                media = Regex.Replace(media, "[^a-z0-9_:\\-\\/\\.\\=\\?\\&\\%\\@]+", "", RegexOptions.IgnoreCase);

                if (media.Contains("/stream/") && !string.IsNullOrWhiteSpace(AppInit.conf.ffprobe.tsuri))
                    media = Regex.Replace(media, "^https?://[^/]+", AppInit.conf.ffprobe.tsuri, RegexOptions.IgnoreCase);
            }
            else if (media.Contains("/proxy/") && media.Contains(".mkv"))
            {
                string hash = Regex.Match(media, "/proxy/([^\n\r]+\\.mkv)").Groups[1].Value;
                media = ProxyLink.Decrypt(hash, null)?.uri;
                if (string.IsNullOrWhiteSpace(media))
                    return showerror ? "media" : "{}";
            }

            string argumentList = string.Empty;

            string memKey = $"tracks:ffprobe:{media}";
            if (!hybridCache.TryGetValue(memKey, out string outPut, inmemory: false))
            {
                #region getFolder
                static string getFolder(string magnethash)
                {
                    return $"database/tracks/{magnethash}";
                }
                #endregion

                if (media.Contains("/stream/"))
                {
                    magnethash = Regex.Match(media, "link=([a-z0-9]+)").Groups[1].Value;
                    string index = Regex.Match(media, @"index=([0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value;

                    if (!string.IsNullOrWhiteSpace(magnethash))
                        magnethash = $"{magnethash}_{index}";
                }
                else if (media.Contains("/lite/pidtor/"))
                {
                    magnethash = Regex.Match(media, "/lite/pidtor/s([a-z0-9]+)").Groups[1].Value;
                    string index = Regex.Match(media, @"tsid=([0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value;

                    if (!string.IsNullOrWhiteSpace(magnethash))
                        magnethash = $"{magnethash}_{index}";
                }

                if (string.IsNullOrEmpty(magnethash))
                    magnethash = CrypTo.md5(media);

                if (System.IO.File.Exists(getFolder(magnethash)))
                    outPut = BrotliTo.Decompress(getFolder(magnethash));

                if (string.IsNullOrWhiteSpace(outPut))
                {
                    if (!Uri.TryCreate(media, UriKind.Absolute, out var uri) ||
                        (uri.Scheme != Uri.UriSchemeHttp && uri.Scheme != Uri.UriSchemeHttps))
                        return showerror ? "uri" : "{}";

                    var process = new System.Diagnostics.Process();
                    process.StartInfo.UseShellExecute = false;
                    process.StartInfo.RedirectStandardOutput = true;
                    process.StartInfo.StandardOutputEncoding = Encoding.UTF8;
                    process.StartInfo.FileName = AppInit.Win32NT ? "data/ffprobe.exe" : System.IO.File.Exists("data/ffprobe") ? "data/ffprobe" : "ffprobe";

                    process.StartInfo.ArgumentList.Add("-v");
                    process.StartInfo.ArgumentList.Add("quiet");
                    process.StartInfo.ArgumentList.Add("-print_format");
                    process.StartInfo.ArgumentList.Add("json");
                    process.StartInfo.ArgumentList.Add("-show_format");
                    process.StartInfo.ArgumentList.Add("-show_streams");
                    process.StartInfo.ArgumentList.Add(AccsDbInvk.Args(uri.AbsoluteUri, httpContext));

                    argumentList = process.StartInfo.FileName + " " + string.Join(" ", process.StartInfo.ArgumentList);

                    process.Start();

                    outPut = await process.StandardOutput.ReadToEndAsync();
                    await process.WaitForExitAsync();

                    if (outPut == null)
                        outPut = string.Empty;

                    if (Regex.Replace(outPut, "[\n\r\t ]+", "") == "{}")
                        outPut = string.Empty;

                    if (!string.IsNullOrWhiteSpace(outPut) && !string.IsNullOrWhiteSpace(magnethash))
                    {
                        BrotliTo.Compress(getFolder(magnethash), outPut);
                    }
                    else
                    {
                        // –∑–∞–≥–ª—É—à–∫–∞
                        hybridCache.Set(memKey, outPut, DateTime.Now.AddMinutes(AppInit.conf.multiaccess ? 20 : 1), inmemory: false);
                    }
                }
            }

            return string.IsNullOrEmpty(outPut) ? (showerror ? argumentList : "{}") : outPut;
        }
    }
}

```

## File: Tracks/TranscodingController.cs
```
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.StaticFiles;
using Newtonsoft.Json;
using Shared;
using Shared.Engine;
using Shared.Models.AppConf;
using Shared.Models.Templates;
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Web;
using Tracks.Engine;

namespace Tracks.Controllers
{
    [ApiController]
    [Route("transcoding")]
    public sealed class TranscodingController : Controller
    {
        #region static
        readonly TranscodingService _service = TranscodingService.Instance;

        static readonly FileExtensionContentTypeProvider provider = new FileExtensionContentTypeProvider()
        {
            Mappings = {
                [".m4s"] = "video/mp4",
                [".ts"] = "video/mp2t",
                [".mp4"] = "video/mp4",
                [".m2ts"] = "video/MP2T"
            }
        };
        #endregion

        #region transcoding.js
        [AllowAnonymous]
        [HttpGet("/transcoding.js")]
        [HttpGet("js/{token}")]
        public ActionResult TranscodingJs(string token)
        {
            if (!AppInit.conf.transcoding.enable)
                return Content(string.Empty);

            var sb = new StringBuilder(FileCache.ReadAllText("plugins/transcoding.js"));

            sb.Replace("{localhost}", AppInit.Host(HttpContext))
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion


        #region Start
        [HttpGet("start.m3u8")]
        public async Task<IActionResult> StartM3u8(string src, int a, int s, bool subtitles, bool live)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (string.IsNullOrEmpty(src))
                return BadRequest(new { error = "src" });

            if (src.Contains("/proxy/") && src.Contains(".mkv"))
            {
                string hash = Regex.Match(src, "/proxy/([^\n\r]+\\.mkv)").Groups[1].Value;
                src = ProxyLink.Decrypt(hash, null)?.uri;
                if (string.IsNullOrWhiteSpace(src))
                    return BadRequest(new { error = "src decrypt" });
            }

            var defaults = AppInit.conf.transcoding;

            var (job, error) = await _service.Start(new TranscodingStartRequest() 
            { 
                src = src,
                live = live,
                subtitles = subtitles,
                audio = new TranscodingAudioOptions() { index = a },
                hls = new TranscodingHlsOptions() { seek = s }
            });

            if (job == null)
                return BadRequest(new { error });

            string uri = $"{AppInit.Host(HttpContext)}/transcoding/{job.StreamId}/{(live ? "live" : "main")}.m3u8";

            return Redirect(AccsDbInvk.Args(uri, HttpContext));
        }

        [HttpPost("start")]
        public async Task<IActionResult> Start([FromBody] TranscodingStartRequest request)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (request == null)
                return BadRequest(new { error = "Request body is required" });

            var (job, error) = await _service.Start(request);
            if (job == null)
                return BadRequest(new { error });

            return Ok(new
            {
                job.StreamId,
                playlistUrl = AccsDbInvk.Args($"{AppInit.Host(HttpContext)}/transcoding/{job.StreamId}/{(job.Context.live ? "live" : "main")}.m3u8", HttpContext),
                subtitlesUrl = job.Context.subtitles ? AccsDbInvk.Args($"{AppInit.Host(HttpContext)}/transcoding/{job.StreamId}/subtitles", HttpContext) : null,
                hls_timeout_seconds = 60
            });
        }
        #endregion

        #region Seek
        [HttpGet("{streamId}/seek/{ss}")]
        public async Task<IActionResult> Seek(string streamId, int ss)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (!_service.TryResolveJob(streamId, out var job))
                return NotFound();

            if (!job.Context.live)
                return BadRequest(new { error = "Context not live" });

            if (ss < 0)
                return BadRequest(new { error = "ss must be greater or equal 0" });

            var (success, error) = await _service.SeekAsync(streamId, ss);
            if (!success)
                return BadRequest(new { error });

            return Ok();
        }
        #endregion

        #region Live
        [HttpGet("{streamId}/live.m3u8")]
        public async Task<IActionResult> Live(string streamId)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (!_service.TryResolveJob(streamId, out var job))
                return NotFound();

            if (!job.Context.live)
                return BadRequest(new { error = "Context not live" });

            _service.Touch(job);

            string path = Path.Combine(job.Context.OutputDirectory, "index.m3u8");

            var fileExistsTimeout = TimeSpan.FromSeconds(60);
            var sw = System.Diagnostics.Stopwatch.StartNew();

            bool fileExists = System.IO.File.Exists(path);

            while (!fileExists && sw.Elapsed < fileExistsTimeout)
            {
                await Task.Delay(250);
                fileExists = System.IO.File.Exists(path);
                if (fileExists)
                    break;
            }

            if (!fileExists)
                return NotFound();

            string m3u8 = null;

            sw.Restart();
            while (sw.Elapsed < fileExistsTimeout)
            {
                try
                {
                    m3u8 = System.IO.File.ReadAllText(path);
                }
                catch
                {
                    m3u8 = null;
                }

                if (!string.IsNullOrEmpty(m3u8) && Regex.IsMatch(m3u8, "seg_[0-9]+\\.(m4s|ts)"))
                    break;

                await Task.Delay(250);
            }

            if (string.IsNullOrEmpty(m3u8))
                return NotFound();

            m3u8 = Regex.Replace(m3u8, "#EXT-X-MAP:URI=[^\n\r]+", $"#EXT-X-MAP:URI=\"{AccsDbInvk.Args("init.mp4", HttpContext)}\"");
            m3u8 = Regex.Replace(m3u8, "(seg_[0-9]+\\.(m4s|ts))", r =>
            {
                string file = r.Groups[1].Value;
                return AccsDbInvk.Args(file, HttpContext);
            });

            return Content(m3u8, "application/vnd.apple.mpegurl");
        }
        #endregion

        #region Playlist
        [HttpGet("{streamId}/main.m3u8")]
        public async Task<IActionResult> Playlist(string streamId)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (!_service.TryResolveJob(streamId, out var job))
                return NotFound();

            if (job.Context.live)
                return BadRequest(new { error = "Context not playlist" });

            if (!int.TryParse(job.Context.ffprobe["format"].Value<string>("duration").Split('.')[0].Split(',')[0], out int duration) || duration == 0)
                return BadRequest(new { error = "duration" });

            _service.Touch(job);

            var fileExistsTimeout = TimeSpan.FromSeconds(60);
            var sw = System.Diagnostics.Stopwatch.StartNew();

            while (sw.Elapsed < fileExistsTimeout)
            {
                if (Directory.GetFiles(job.Context.OutputDirectory).Length > 2)
                    break;

                await Task.Delay(250);
            }

            int segDur = job.Context.HlsOptions.segDur;

            var builder = new StringBuilder();
            builder.AppendLine("#EXTM3U");
            builder.AppendLine("#EXT-X-PLAYLIST-TYPE:VOD");
            builder.AppendLine($"#EXT-X-VERSION:{(job.Context.HlsOptions.fmp4 ? 7 : 3)}");
            builder.AppendLine($"#EXT-X-TARGETDURATION:{segDur}");
            builder.AppendLine("#EXT-X-MEDIA-SEQUENCE:0");

            if (job.Context.HlsOptions.fmp4)
                builder.AppendLine($"#EXT-X-MAP:URI=\"{AccsDbInvk.Args("init.mp4", HttpContext)}\"");

            for (int i = 0; i < (duration / segDur); i++)
            {
                builder.AppendLine($"#EXTINF:{segDur}.0,");
                builder.AppendLine(AccsDbInvk.Args($"seg_{i:d5}.{(job.Context.HlsOptions.fmp4 ? "m4s" : "ts")}", HttpContext));
            }

            builder.AppendLine("#EXT-X-ENDLIST");

            return Content(builder.ToString(), "application/vnd.apple.mpegurl");
        }
        #endregion

        #region Segment
        [HttpGet("{streamId}/{file}")]
        public async Task<IActionResult> Segment(string streamId, string file)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (!_service.TryResolveJob(streamId, out var job))
                return NotFound();

            _service.Touch(job);

            int? segmentIndex = null;
            if (!job.Context.live && file != null)
            {
                var matchSegment = Regex.Match(file, @"seg_(\d+)\.(m4s|ts)$", RegexOptions.IgnoreCase);
                if (matchSegment.Success && int.TryParse(matchSegment.Groups[1].Value, out var idx))
                    segmentIndex = idx;
            }

            var fileExistsTimeout = TimeSpan.FromSeconds(60);
            var sw = System.Diagnostics.Stopwatch.StartNew();

            string resolved = _service.GetFilePath(job, file);

            if (job.Context.live == false && resolved == null && !file.Contains(".vtt"))
            {
                #region SeekAsync
                if (segmentIndex.HasValue)
                {
                    int segDur = job.Context.HlsOptions.segDur;
                    int ss = segmentIndex.Value * segDur;

                    if (job.Context.HlsOptions.seek == 0 && 30 > ss)
                    {
                        // –ø–µ—Ä–≤—ã–µ 30 —Å–µ–∫—É–Ω–¥ –±–µ–∑ seek-–∞ - –Ω–µ —Ç—Ä–æ–≥–∞–µ–º
                    }
                    else if (job.Context.HlsOptions.seek == ss)
                    {
                        // ffmpeg –Ω–∞ —Ç–µ–∫—É—â–µ–º —Å–µ–≥–º–µ–Ω—Ç–µ
                    }
                    else
                    {
                        // —Ä–∞–±–æ—Ç–∞–µ—Ç –¥–∞–ª—å—à–µ —á–µ–º —Ç–µ–∫—É—â–∏–π —Å–µ–≥–º–µ–Ω—Ç
                        bool goSeek = job.Context.HlsOptions.seek > ss;

                        string extension = Path.GetExtension(file);
                        int segmentsPerMinute = (int)Math.Ceiling(30.0 / segDur);
                        int startIndex = Math.Max(0, segmentIndex.Value - segmentsPerMinute);

                        if (goSeek == false)
                        {
                            goSeek = true;

                            for (int i = startIndex; i < segmentIndex.Value; i++)
                            {
                                string candidate = $"seg_{i:d5}{extension}";
                                if (_service.GetFilePath(job, candidate) != null)
                                {
                                    // –µ—Å—Ç—å —Å–µ–≥–º–µ–Ω—Ç—ã –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 30 —Å–µ–∫—É–Ω–¥
                                    goSeek = false;
                                    break;
                                }
                            }
                        }

                        if (goSeek)
                            await _service.SeekAsync(streamId, ss, segmentIndex.Value);
                    }
                }
                #endregion

                do
                {
                    try
                    {
                        await Task.Delay(200);
                        resolved = _service.GetFilePath(job, file);
                        if (resolved != null)
                            break;
                    }
                    catch { }
                }
                while (sw.Elapsed < fileExistsTimeout);
            }

            if (resolved == null)
                return NotFound();

            #region –∂–¥–µ–º –ø–æ—è–≤–ª–µ–Ω–∏—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞
            while (segmentIndex.HasValue && sw.Elapsed < fileExistsTimeout)
            {
                try
                {
                    string seg = Path.Combine(job.OutputDirectory, $"seg_{segmentIndex.Value + 1:d5}");
                    if (System.IO.File.Exists($"{seg}.{(job.Context.HlsOptions.fmp4 ? "m4s" : "ts")}"))
                        break;
                }
                catch { }

                await Task.Delay(200);
            }
            #endregion

            #region FileStream
            FileStream fs = null;
            do
            {
                try
                {
                    fs = file.Contains(".vtt")
                        ? new FileStream(resolved, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
                        : System.IO.File.OpenRead(resolved);
                    break;
                }
                catch (IOException)
                {
                    await Task.Delay(200);
                }
                catch (UnauthorizedAccessException)
                {
                    await Task.Delay(200);
                }
            } 
            while (sw.Elapsed < fileExistsTimeout);

            if (fs == null)
                return NotFound();
            #endregion

            if (!provider.TryGetContentType(resolved, out var contentType))
                contentType = "application/octet-stream";

            if (segmentIndex.HasValue)
                _service.ReportSegmentAccess(job, segmentIndex.Value);

            return File(fs, contentType, enableRangeProcessing: true);
        }
        #endregion

        #region Subtitles
        [HttpGet("{streamId}/subtitles")]
        public IActionResult Subtitles(string streamId)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (!_service.TryResolveJob(streamId, out var job))
                return NotFound();

            _service.Touch(job);

            var subsTpl = new SubtitleTpl();

            if (job.Context.subtitles && job.Context.ffprobe.ContainsKey("streams"))
            {
                foreach (var s in job.Context.ffprobe["streams"])
                {
                    if (s.Value<string>("codec_type") != "subtitle")
                        continue;

                    if (s.Value<string>("codec_name") is "subrip" or "webvtt" or "ass" or "ssa" or "mov_text" or "ttml" or "sami")
                    {
                        int subIndex = s.Value<int>("index");
                        if (subIndex == 0)
                            continue;

                        string uri = $"{AppInit.Host(HttpContext)}/transcoding/{streamId}/{AccsDbInvk.Args($"subs_{subIndex}.vtt", HttpContext)}";

                        string name = s["tags"].Value<string>("title")
                            ?? s["language"].Value<string>("title")
                            ?? $"sub_{subIndex}";

                        subsTpl.Append(name, uri);
                    }
                }
            }

            return Ok(subsTpl.ToObject());
        }
        #endregion

        #region Heartbeat
        [HttpGet("{streamId}/heartbeat")]
        public IActionResult Heartbeat(string streamId)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (!_service.TryResolveJob(streamId, out var job))
                return NotFound();

            _service.Touch(job);
            return Ok();
        }
        #endregion

        #region StopAsync
        [HttpGet("{streamId}/stop")]
        public async Task<IActionResult> StopAsync(string streamId)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            var stopped = await _service.StopAsync(streamId);
            return stopped ? Ok() : NotFound();
        }
        #endregion

        #region Status
        [HttpGet("{streamId}/status")]
        public IActionResult Status(string streamId)
        {
            if (!AppInit.conf.transcoding.enable || !ModInit.IsInitialization)
                return BadRequest(new { error = "Transcoding disabled" });

            if (!_service.TryResolveJob(streamId, out var job))
                return NotFound();

            var now = DateTime.UtcNow;
            var state = job.Process.HasExited ? TranscodingJobState.Stopped : TranscodingJobState.Running;

            var uptime = now - job.StartedUtc;

            int? exitCode = null;
            try
            {
                if (job.Process.HasExited)
                    exitCode = job.Process.ExitCode;
            }
            catch { }

            var snapshotLog = job.SnapshotLog();

            ulong time_ms = 0;
            foreach (string line in snapshotLog.Reverse())
            {
                if (!line.Contains("out_time_ms="))
                    continue;

                if (!ulong.TryParse(Regex.Match(line, "out_time_ms=([0-9]+)").Groups[1].Value, out time_ms))
                    continue;

                break;
            }

            return Content(JsonConvert.SerializeObject(new
            {
                job.StreamId,
                state = state.ToString(),
                job.OutputDirectory,
                ffmpeg = string.Join(" ", job.Process.StartInfo.ArgumentList),
                startedUtc = job.StartedUtc,
                lastAccessUtc = job.LastAccessUtc,
                uptime = uptime.TotalSeconds,
                positionSec = (ulong)(job.Context.HlsOptions.seek + (time_ms > 0 ? (time_ms / 1000000.0) : 0)),
                exitCode,
                job.Context.ffprobe,
                log = snapshotLog
            }), "application/json; charset=utf-8");
        }
        #endregion


        #region DOC
        [HttpGet("")]
        public IActionResult DOC()
        {
            var endpoints = new object[]
            {
                new {
                    path = "/transcoding/start.m3u8",
                    method = "GET",
                    query = new object[] {
                        new { name = "src", type = "string", required = true, description = "Source URL or local path to media" },
                        new { name = "a", type = "int", required = false, description = "Audio index (optional)" },
                        new { name = "s", type = "int", required = false, description = "Seek position in seconds (optional)" },
                        new { name = "subtitles", type = "bool", required = false, description = "subtitles on/off" },
                        new { name = "live", type = "bool", required = false, description = "Context live/playlist" }
                    },
                    description = "Start transcoding with query parameters and redirect to the generated HLS playlist"
                },
                new {
                    path = "/transcoding/start",
                    method = "POST",
                    contentType = "application/json",
                    body = new {
                        src = "https://example.com/media.mp4",
                        videoFormat = "",
                        live = false,
                        subtitles = false,
                        headers = new { referer = "https://example.com", userAgent = "HlsProxy/1.0" },
                        audio = AppInit.conf.transcoding.audioOptions,
                        hls = AppInit.conf.transcoding.hlsOptions
                    },
                    description = "Start transcoding by POSTing a JSON body. Returns StreamId and playlist URL"
                },
                new {
                    path = "/transcoding/{streamId}/live.m3u8",
                    method = "GET",
                    route = new { name = "streamId", type = "string", required = true },
                    description = "Returns the HLS live for the given transcoding job"
                },
                new {
                    path = "/transcoding/{streamId}/main.m3u8",
                    method = "GET",
                    route = new { name = "streamId", type = "string", required = true },
                    description = "Returns the HLS master/variant playlist for the given transcoding job"
                },
                new {
                    path = "/transcoding/{streamId}/{file}",
                    method = "GET",
                    route = new object[] {
                        new { name = "streamId", type = "string", required = true },
                        new { name = "file", type = "string", required = true, description = "Requested segment or asset (e.g. init.mp4, seg_1.m4s, index.m3u8)" }
                    },
                    description = "Serves individual segment files, init files and playlists produced by the transcoder. Supports range requests."
                },
                new {
                    path = "/transcoding/{streamId}/seek/{ss}",
                    method = "GET",
                    route = new object[] {
                        new { name = "streamId", type = "string", required = true },
                        new { name = "ss", type = "int", required = true, description = "Seek position in seconds (>= 0)" }
                    },
                    description = "Request the transcoder to seek to the specified position (async). Returns 200 on success."
                },
                new {
                    path = "/transcoding/{streamId}/heartbeat",
                    method = "GET",
                    route = new { name = "streamId", type = "string", required = true },
                    description = "Touch the job to keep it alive. Returns 200 if job exists."
                },
                new {
                    path = "/transcoding/{streamId}/stop",
                    method = "GET",
                    route = new { name = "streamId", type = "string", required = true },
                    description = "Stop the transcoding job. Returns 200 if stopped or 404 if job not found."
                },
                new {
                    path = "/transcoding/{streamId}/status",
                    method = "GET",
                    query = new { name = "log", type = "bool", required = false, description = "Include job log snapshot when true" },
                    route = new { name = "streamId", type = "string", required = true },
                    description = "Return current job status, uptime, position and optional log snapshot."
                }
            };

            return Ok(JsonConvert.SerializeObject(endpoints, Formatting.Indented));
        }
        #endregion
    }
}

```

## File: Tracks/Engine/TranscodingService.cs
```
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Models.AppConf;
using Shared.Models.Events;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Tracks.Controllers;

namespace Tracks.Engine
{
    internal sealed class TranscodingService
    {
        static readonly Lazy<TranscodingService> _lazy = new(() => new TranscodingService());

        readonly ConcurrentDictionary<string, TranscodingJob> _jobs = new();
        readonly Regex _safeFileNameRegex = new("^[A-Za-z0-9_.-]+$", RegexOptions.Compiled | RegexOptions.CultureInvariant);
        readonly Regex _segmentFileRegex = new("^seg_(\\d+)\\.(m4s|ts)$", RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant);

        int _segmentCleanupRunning;
        readonly Timer _segmentCleanupTimer;

        byte[] _hmacKey = RandomNumberGenerator.GetBytes(32);
        static string _ffmpegPath;

        public static TranscodingService Instance => _lazy.Value;

        private TranscodingService()
        {
            _segmentCleanupTimer = new Timer(_ => CleanupSegments(), null, TimeSpan.FromMinutes(1), TimeSpan.FromSeconds(20));
        }

        public void Configure(TranscodingConf config)
        {
            if (config == null)
                return;

            _ffmpegPath = string.IsNullOrWhiteSpace(config.ffmpeg)
                    ? (AppInit.Win32NT ? "data/ffmpeg.exe" : (File.Exists("data/ffmpeg") ? "data/ffmpeg" : "ffmpeg"))
                    : config.ffmpeg;

            if (string.IsNullOrWhiteSpace(config.tempRoot))
                config.tempRoot = Path.Combine("cache", "transcoding");

            try
            {
                if (!Directory.Exists(config.tempRoot))
                {
                    Directory.CreateDirectory(config.tempRoot);
                }
                else
                {
                    foreach (var dir in Directory.GetDirectories(config.tempRoot))
                    {
                        try
                        {
                            Directory.Delete(dir, true);
                        }
                        catch { }
                    }
                }
            }
            catch { }
        }

        public ICollection<TranscodingJob> Jobs => _jobs.Values;

        async public Task<(TranscodingJob job, string error)> Start(TranscodingStartRequest request)
        {
            var config = GetConfig();
            if (!config.enable)
                return (null!, "Transcoding disabled");

            if (request == null || string.IsNullOrWhiteSpace(request.src))
                return (null!, "Source URL is required");

            if (_jobs.Count >= Math.Max(1, config.maxConcurrentJobs))
                return (null!, "Maximum concurrent jobs reached");

            if (!TryValidateSource(request.src, config, out var source, out var error))
                return (null!, error);

            var id = Guid.NewGuid().ToString("N");
            var streamId = BuildToken(id);

            var outputDir = Path.Combine(config.tempRoot!, id);
            Directory.CreateDirectory(outputDir);

            #region ffprobe
            JObject ffprobe = null;

            string ffprobeJson = await TracksController.FfprobeJson(null, null, new HybridCache(), request.src);
            if (string.IsNullOrEmpty(ffprobeJson) || ffprobeJson == "{}")
                return (null!, "ffprobe");

            ffprobe = JsonConvert.DeserializeObject<JObject>(ffprobeJson);

            if (ffprobe == null || !ffprobe.ContainsKey("format"))
                return (null!, "ffprobe");
            #endregion

            var context = new TranscodingStartContext(
                source,
                SanitizeHeader(GetHeader(request.headers, "userAgent"), Http.UserAgent),
                SanitizeHeader(GetHeader(request.headers, "referer")),
                MergeHlsOptions(config, request.hls),
                MergeAudioOptions(config, request.audio),
                request.live,
                request.subtitles ?? config.defaultSubtitles,
                outputDir,
                null,
                ffprobe
            );

            var process = CreateProcess(context);

            try
            {
                if (!process.Start())
                {
                    process.Dispose();
                    return (null!, "Failed to start ffmpeg");
                }
            }
            catch (Exception ex)
            {
                process.Dispose();
                return (null!, $"Failed to start ffmpeg: {ex.Message}");
            }

            var job = new TranscodingJob(id, streamId, outputDir, process, context);
            if (!_jobs.TryAdd(id, job))
            {
                try
                {
                    process.Kill(true);
                }
                catch { }

                process.Dispose();
                try
                {
                    if (Directory.Exists(outputDir))
                        Directory.Delete(outputDir, true);
                }
                catch { }
                return (null!, "Failed to register job");
            }

            _ = Task.Run(() => PumpStdErrAsync(job));
            _ = Task.Run(() => IdleWatchdogAsync(job, config));

            process.EnableRaisingEvents = true;
            process.Exited += (_, _) => 
            {
                if (process.EnableRaisingEvents)
                    OnProcessExit(job);
            };

            return (job, string.Empty);
        }

        public bool TryResolveJob(string streamId, out TranscodingJob job)
        {
            job = null!;
            if (string.IsNullOrWhiteSpace(streamId))
                return false;

            if (!TryParseToken(streamId, out var id))
                return false;

            if (!_jobs.TryGetValue(id, out job))
                return false;

            return true;
        }

        public async Task<(bool success, string error)> SeekAsync(string streamId, int seconds, int? startSegment = null)
        {
            if (seconds < 0)
                return (false, "ss must be greater or equal 0");

            if (!TryResolveJob(streamId, out var job))
                return (false, "Job not found");

            var config = GetConfig();

            var newContext = job.Context with
            {
                HlsOptions = new TranscodingHlsOptions
                {
                    seek = seconds,
                    segDur = job.Context.HlsOptions.segDur,
                    winSize = job.Context.HlsOptions.winSize,
                    fmp4 = job.Context.HlsOptions.fmp4
                },
                startNumber = startSegment
            };

            job.Process.EnableRaisingEvents = false;
            await StopJobAsync(job, forced: true, cleanup: false);

            Directory.CreateDirectory(newContext.OutputDirectory);

            var process = CreateProcess(newContext);

            try
            {
                if (!process.Start())
                {
                    process.Dispose();
                    return (false, "Failed to start ffmpeg");
                }
            }
            catch (Exception ex)
            {
                process.Dispose();
                return (false, $"Failed to start ffmpeg: {ex.Message}");
            }

            var newJob = new TranscodingJob(job.Id, job.StreamId, job.OutputDirectory, process, newContext);

            if (_jobs.AddOrUpdate(job.Id, newJob, (k, v) => newJob) == null)
            {
                try
                {
                    process.Kill(true);
                }
                catch { }

                process.Dispose();
                return (false, "Failed to restart job");
            }

            _ = Task.Run(() => PumpStdErrAsync(newJob));
            _ = Task.Run(() => IdleWatchdogAsync(newJob, config));

            process.EnableRaisingEvents = true;
            process.Exited += (_, _) =>
            {
                if (process.EnableRaisingEvents)
                    OnProcessExit(newJob);
            };

            return (true, string.Empty);
        }

        public async Task<bool> StopAsync(string streamId)
        {
            if (!TryResolveJob(streamId, out var job))
                return false;

            await StopJobAsync(job);
            return true;
        }

        public void Touch(TranscodingJob job) => job.UpdateLastAccess();

        public string GetFilePath(TranscodingJob job, string file)
        {
            if (string.IsNullOrWhiteSpace(file) || !_safeFileNameRegex.IsMatch(file))
                return null;

            var candidate = Path.Combine(job.OutputDirectory, file);
            if (!candidate.StartsWith(job.OutputDirectory, StringComparison.Ordinal))
                return null;

            return File.Exists(candidate) ? candidate : null;
        }

        public void ReportSegmentAccess(TranscodingJob job, int segmentIndex)
        {
            job?.UpdateLastSegmentIndex(segmentIndex);
        }

        private async Task StopJobAsync(TranscodingJob job, bool forced = false, bool cleanup = true)
        {
            try
            {
                if (!job.Process.HasExited)
                {
                    if (forced)
                    {
                        job.Process.Kill(true);
                    }
                    else
                    {
                        try
                        {
                            await job.Process.StandardInput.WriteLineAsync("q");
                            await job.Process.StandardInput.FlushAsync();
                        }
                        catch { }

                        var waitTask = job.Process.WaitForExitAsync();
                        var timeout = Task.Delay(TimeSpan.FromMilliseconds(1500));
                        var completed = await Task.WhenAny(waitTask, timeout);
                        if (completed != waitTask)
                        {
                            try
                            {
                                job.Process.Kill(true);
                            }
                            catch { }

                            try
                            {
                                await job.Process.WaitForExitAsync();
                            }
                            catch { }
                        }
                        else
                        {
                            try
                            {
                                await waitTask;
                            }
                            catch { }
                        }
                    }
                }
            }
            finally
            {
                if (cleanup)
                    Cleanup(job);
            }
        }

        private void Cleanup(TranscodingJob job)
        {
            var removed = _jobs.TryRemove(job.Id, out _);

            try
            {
                job.StopBackground();
                job.SignalExit();
            }
            catch { }

            if (!removed)
                return;

            try
            {
                if (Directory.Exists(job.OutputDirectory))
                    Directory.Delete(job.OutputDirectory, true);
            }
            catch { }

            job.Dispose();
        }

        private TranscodingConf GetConfig()
        {
            return AppInit.conf.transcoding;
        }

        private static string GetHeader(Dictionary<string, string> headers, string key)
        {
            if (headers == null || headers.Count == 0)
                return null;

            foreach (var (k, v) in headers)
            {
                if (string.Equals(k, key, StringComparison.OrdinalIgnoreCase))
                    return v;
            }

            return null;
        }

        private static TranscodingHlsOptions MergeHlsOptions(TranscodingConf config, TranscodingHlsOptions request)
        {
            var opt = request ?? config.hlsOptions;

            return new TranscodingHlsOptions
            {
                seek = opt?.seek > 0 ? opt.seek : 0,
                segDur = opt?.segDur > 1 ? opt.segDur : 1,
                winSize = opt?.winSize > 5 ? opt.winSize : 5,
                fmp4 = opt?.fmp4 ?? true
            };
        }

        private static TranscodingAudioOptions MergeAudioOptions(TranscodingConf config, TranscodingAudioOptions request)
        {
            var opt = request ?? config.audioOptions;

            return new TranscodingAudioOptions
            {
                index = opt?.index >= 0 ? opt.index : 0,
                bitrateKbps = opt?.bitrateKbps is > 0 and <= 512 ? opt.bitrateKbps : 160,
                stereo = opt?.stereo ?? true,
                codec_copy = opt?.codec_copy ?? config.audioOptions.codec_copy
            };
        }

        private static bool TryValidateSource(string src, TranscodingConf config, out Uri uri, out string error)
        {
            error = string.Empty;
            uri = null!;

            if (!Uri.TryCreate(src, UriKind.Absolute, out uri) ||
                (uri.Scheme != Uri.UriSchemeHttp && uri.Scheme != Uri.UriSchemeHttps))
            {
                error = "Only http/https URLs are allowed";
                return false;
            }

            if (config.allowHosts != null && config.allowHosts.Length > 0)
            {
                if (!config.allowHosts.Contains(uri.Host, StringComparer.OrdinalIgnoreCase))
                {
                    error = "Source host is not allowed";
                    return false;
                }
            }

            return true;
        }

        public void StopAll()
        {
            var jobs = _jobs.Values.ToArray();
            foreach (var job in jobs)
            {
                try
                {
                    _ = StopJobAsync(job, forced: true).ConfigureAwait(false);
                }
                catch { }
            }
        }

        private Process CreateProcess(TranscodingStartContext context)
        {
            var config = GetConfig();

            var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = _ffmpegPath,
                    UseShellExecute = false,
                    RedirectStandardError = true,
                    RedirectStandardInput = true,
                    RedirectStandardOutput = false,
                    CreateNoWindow = true,
                    WorkingDirectory = context.OutputDirectory
                }
            };

            var args = process.StartInfo.ArgumentList;

            /*
-hide_banner ‚Äî –æ—Ç–∫–ª—é—á–∞–µ—Ç –≤—ã–≤–æ–¥ –±–∞–Ω–Ω–µ—Ä–∞ ffmpeg (–≤–µ—Ä—Å–∏—è/–∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è) –≤ stderr, —á—Ç–æ–±—ã –ª–æ–≥–∏ –±—ã–ª–∏ —á–∏—â–µ.
-user_agent {context.UserAgent} ‚Äî –∑–∞–¥–∞—ë—Ç –∑–∞–≥–æ–ª–æ–≤–æ–∫ User-Agent –¥–ª—è HTTP-–∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –≤—Ö–æ–¥–Ω–æ–º—É URL.
-headers "Referer: {context.Referer}\n" ‚Äî –¥–æ–±–∞–≤–ª—è–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–µ HTTP-–∑–∞–≥–æ–ª–æ–≤–∫–∏ (–∑–¥–µ—Å—å: Referer) –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ –≤—Ö–æ–¥–Ω–æ–º—É URL.
-re ‚Äî —á–∏—Ç–∞–µ—Ç –≤—Ö–æ–¥–Ω–æ–π –ø–æ—Ç–æ–∫ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏; –ø–æ–ª–µ–∑–Ω–æ –ø—Ä–∏ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏/—Å—Ç—Ä–∏–º–∏–Ω–≥–µ, —á—Ç–æ–±—ã –Ω–µ —á–∏—Ç–∞—Ç—å –≤—Ö–æ–¥ –±—ã—Å—Ç—Ä–µ–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏.
-threads 0 ‚Äî –ø–æ–∑–≤–æ–ª—è–µ—Ç ffmpeg –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–±—Ä–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤ (CPU) –¥–ª—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è/–¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è.
-fflags +genpts ‚Äî –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç PTS –¥–ª—è –∫–∞–¥—Ä–æ–≤, –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç (–∏–∑–±–µ–≥–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º —Å –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–º–∏ –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –º–µ—Ç–∫–∞–º–∏).
-i {Source} ‚Äî —É–∫–∞–∑—ã–≤–∞–µ—Ç –≤—Ö–æ–¥–Ω–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫ (URL/—Ñ–∞–π–ª).
-map 0:v:0 ‚Äî –º–∞–ø–ø–∏—Ç –ø–µ—Ä–≤—ã–π –≤–∏–¥–µ–æ–ø–æ—Ç–æ–∫ –ø–µ—Ä–≤–æ–≥–æ –≤—Ö–æ–¥–∞ –≤ –≤—ã—Ö–æ–¥.
-map 0:a:0 ‚Äî –º–∞–ø–ø–∏—Ç –ø–µ—Ä–≤—ã–π –∞—É–¥–∏–æ–ø–æ—Ç–æ–∫ –ø–µ—Ä–≤–æ–≥–æ –≤—Ö–æ–¥–∞ –≤ –≤—ã—Ö–æ–¥.
-sn (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –ø—Ä–∏ subtitles == false) ‚Äî –∏—Å–∫–ª—é—á–∏—Ç—å —Å—É–±—Ç–∏—Ç—Ä—ã –∏–∑ –≤—ã–≤–æ–¥–∞.
-dn ‚Äî –∏—Å–∫–ª—é—á–∏—Ç—å data-–ø–æ—Ç–æ–∫–∏ (metadata/data tracks).
-map_metadata -1 ‚Äî –Ω–µ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –≤ –≤—ã—Ö–æ–¥ (–æ—á–∏—â–∞–µ—Ç –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ).
-map_chapters -1 ‚Äî –Ω–µ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≥–ª–∞–≤—ã (—É–¥–∞–ª—è–µ—Ç chapters).
-c:v copy ‚Äî –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–∏–¥–µ–æ–ø–æ—Ç–æ–∫–∞ –±–µ–∑ –ø–µ—Ä–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è (–¥–ª—è –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –Ω–∞–≥—Ä—É–∑–∫–∏ –∏ –±–µ–∑ –ø–æ—Ç–µ—Ä–∏ –∫–∞—á–µ—Å—Ç–≤–∞).

–ê—É–¥–∏–æ:
–ï—Å–ª–∏ transcodeToAac:
-c:a aac ‚Äî –∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –∞—É–¥–∏–æ –≤ AAC.
-ac 2 / -ac 1 ‚Äî —á–∏—Å–ª–æ –∫–∞–Ω–∞–ª–æ–≤ (—Å—Ç–µ—Ä–µ–æ/–º–æ–Ω–æ) –ø–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ.
-b:a {N}k ‚Äî –±–∏—Ç—Ä–µ–π—Ç –∞—É–¥–∏–æ.
-profile:a aac_low ‚Äî –ø—Ä–æ—Ñ–∏–ª—å AAC (–æ–±—ã—á–Ω–æ LC –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ –∏ –Ω–∏–∑–∫–æ–π –∑–∞–¥–µ—Ä–∂–∫–∏).
–ò–Ω–∞—á–µ: -c:a copy ‚Äî –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –∞—É–¥–∏–æ –±–µ–∑ –ø–µ—Ä–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è.

HLS / –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä:
-avoid_negative_ts disabled ‚Äî –Ω–µ —Å–¥–≤–∏–≥–∞—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö TS; —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –∏—Å—Ö–æ–¥–Ω—ã–µ PTS –ø—Ä–∏ HLS-—Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏.
-max_muxing_queue_size 2048 ‚Äî —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –æ—á–µ—Ä–µ–¥—å –ø–∞–∫–µ—Ç–æ–≤ –ø—Ä–∏ –º—É–ª—å—Ç–∏–ø–ª–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–∏ (–ø–æ–º–æ–≥–∞–µ—Ç –ø—Ä–æ—Ç–∏–≤ ‚ÄúToo many packets buffered‚Äù).
-f hls ‚Äî —Ñ–æ—Ä–º–∞—Ç –≤—ã—Ö–æ–¥–∞ HLS (HTTP Live Streaming).
-max_delay 5000000 ‚Äî –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –±—É—Ñ–µ—Ä–∞ (–≤ –º–∫—Å; –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞), —Å–Ω–∏–∂–∞–µ—Ç —Ä–∏—Å–∫ –∏–∑–±—ã—Ç–æ—á–Ω–æ–≥–æ –±—É—Ñ–µ—Ä–∏–Ω–≥–∞.
-hls_segment_type fmp4 –∏–ª–∏ mpegts ‚Äî —Ç–∏–ø —Å–µ–≥–º–µ–Ω—Ç–æ–≤ HLS (CMAF/fMP4 –∏–ª–∏ MPEG-TS).
–¥–ª—è mpegts: -bsf:v h264_mp4toannexb ‚Äî –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç H.264 –∫ Annex-B, –∫–∞–∫ —Ç—Ä–µ–±—É–µ—Ç—Å—è –¥–ª—è TS.
-hls_time {segDur} ‚Äî –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–µ–≥–º–µ–Ω—Ç–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö.
-hls_flags append_list+omit_endlist ‚Äî
append_list ‚Äî –¥–æ–ø–∏—Å—ã–≤–∞—Ç—å –∑–∞–ø–∏—Å–∏ –≤ –ø–ª–µ–π–ª–∏—Å—Ç;
omit_endlist ‚Äî –Ω–µ –¥–æ–±–∞–≤–ª—è—Ç—å #EXT-X-ENDLIST, —á—Ç–æ–±—ã –ø–ª–µ–π–ª–∏—Å—Ç —Å—á–∏—Ç–∞–ª—Å—è ‚Äú–∂–∏–≤—ã–º‚Äù.
-hls_list_size {winSize} ‚Äî —Ä–∞–∑–º–µ—Ä –æ–∫–Ω–∞ –ø–ª–µ–π–ª–∏—Å—Ç–∞ (—Å–∫–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Å–µ–≥–º–µ–Ω—Ç–æ–≤ –≤–∏–¥–∏—Ç –∫–ª–∏–µ–Ω—Ç).
-master_pl_name index.m3u8 ‚Äî –∏–º—è master-–ø–ª–µ–π–ª–∏—Å—Ç–∞ (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è).
-hls_fmp4_init_filename {init.mp4} ‚Äî –∏–º—è init-—Å–µ–≥–º–µ–Ω—Ç–∞ –¥–ª—è fMP4.
-hls_segment_filename {seg_%05d.m4s | seg_%05d.ts} ‚Äî —à–∞–±–ª–æ–Ω –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–æ–≤ —Å–µ–≥–º–µ–Ω—Ç–æ–≤.
-y {PlaylistPath} ‚Äî –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å –≤—ã—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª –±–µ–∑ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è (–ø—É—Ç—å –∏—Ç–æ–≥–æ–≤–æ–≥–æ –ø–ª–µ–π–ª–∏—Å—Ç–∞/—Ñ–∞–π–ª–∞).
             */

            args.Add("-hide_banner");

            if (context.UserAgent != null)
            {
                args.Add("-user_agent");
                args.Add(context.UserAgent);
            }

            if (!string.IsNullOrWhiteSpace(context.Referer))
            {
                args.Add("-headers");
                args.Add($"Referer: {context.Referer}\\r\\n");
            }

            if (context.HlsOptions.seek > 0)
            {
                args.Add("-ss");
                args.Add(context.HlsOptions.seek.ToString());
                args.Add("-noaccurate_seek");
            }

            args.Add("-nostats");
            args.Add("-progress");
            args.Add("pipe:2");
            args.Add("-stats_period");
            args.Add(context.live ? "1" : "5");

            #region demuxer
            foreach (var c in config.comand["demuxer"])
            {
                foreach (var a in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                    args.Add(a);
            }
            #endregion

            #region readrate
            if (context.live)
            {
                args.Add("-re");
            }
            else if (config.playlistOptions.readrate > 0)
            {
                args.Add("-readrate");
                args.Add(config.playlistOptions.readrate.ToString().Replace(",", "."));

                if (config.playlistOptions.burst > 0)
                {
                    args.Add("-readrate_initial_burst");
                    args.Add(config.playlistOptions.burst.ToString());
                }
            }
            #endregion

            args.Add("-i");
            args.Add(context.Source.AbsoluteUri);

            #region input
            foreach (var c in config.comand["input"])
            {
                foreach (var a in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                    args.Add(a);
            }
            #endregion

            #region subtitles map
            if (context.subtitles && !context.live && 0 >= config.playlistOptions.readrate && context.ffprobe.ContainsKey("streams"))
            {
                args.Add("-copyts");

                foreach (var s in context.ffprobe["streams"])
                {
                    if (s.Value<string>("codec_type") != "subtitle")
                        continue;

                    string codec_name = s.Value<string>("codec_name");
                    if (!string.IsNullOrEmpty(codec_name) && config.subtitleOptions.codec.Contains(codec_name))
                    {
                        int subIndex = s.Value<int>("index");
                        if (subIndex == 0)
                            continue;

                        foreach (var c in config.subtitleOptions.comand)
                        {
                            foreach (var a in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                                args.Add(a.Replace("{subIndex}", subIndex.ToString()));
                        }
                    }
                }
            }
            #endregion

            #region HLS map
            foreach (var c in config.comand["output"])
            {
                foreach (var a in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                    args.Add(a.Replace("{audio_index}", $"{(0 >= context.Audio.index ? 0 : context.Audio.index)}"));
            }

            #region -c:v
            if (config.convertOptions.transcodeVideo && config.convertOptions.codec != null &&
                context.ffprobe != null && context.ffprobe.ContainsKey("streams") &&
                config.convertOptions.comand != null && config.convertOptions.comand.Count > 0)
            {
                try
                {
                    bool convert = false;

                    string codec_name = context.ffprobe["streams"].First.Value<string>("codec_name") ?? "";
                    if (!string.IsNullOrEmpty(codec_name) && config.convertOptions.codec.Contains(codec_name))
                        convert = true;

                    string pix_fmt = context.ffprobe["streams"].First.Value<string>("pix_fmt") ?? "";
                    if (!string.IsNullOrEmpty(pix_fmt) && config.convertOptions.codec.Contains(pix_fmt))
                        convert = true;

                    if (config.convertOptions.codec.Contains($"{codec_name}_{pix_fmt}"))
                        convert = true;

                    if (convert)
                    {
                        string[] comand = config.convertOptions.comand["default"];

                        foreach (string key in new string[] { $"{codec_name}_{pix_fmt}", pix_fmt, codec_name })
                        {
                            if (config.convertOptions.comand.ContainsKey(key))
                            {
                                comand = config.convertOptions.comand[key];
                                break;
                            }
                        }

                        foreach (var c in comand)
                        {
                            foreach (var t in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                                args.Add(t);
                        }
                    }
                    else
                    {
                        args.Add("-c:v");
                        args.Add("copy");
                    }
                }
                catch
                {
                    args.Add("-c:v");
                    args.Add("copy");
                }
            }
            else
            {
                args.Add("-c:v");
                args.Add("copy");
            }
            #endregion

            #region -c:a
            {
                bool convert = true;

                var audioCodec = context.ffprobe["streams"].FirstOrDefault(i => i.Value<int>("index") == ((0 >= context.Audio.index ? 0 : context.Audio.index) + 1));

                string codec_name = audioCodec?.Value<string>("codec_name") ?? string.Empty;
                if (!string.IsNullOrEmpty(codec_name) && context.Audio.codec_copy.Contains(codec_name))
                    convert = false;

                string channel = audioCodec?.Value<int?>("channels")?.ToString() ?? string.Empty;
                if (!string.IsNullOrEmpty(channel) && context.Audio.codec_copy.Contains(channel))
                    convert = false;

                if (context.Audio.codec_copy.Contains($"{codec_name}_{channel}"))
                    convert = false;

                if (convert)
                {
                    string[] comand = config.audioOptions.comand_transcode["default"];

                    foreach (string key in new string[] { $"{codec_name}_{channel}", channel, codec_name })
                    {
                        if (config.audioOptions.comand_transcode.ContainsKey(key))
                        {
                            comand = config.audioOptions.comand_transcode[key];
                            break;
                        }
                    }

                    foreach (var c in comand)
                    {
                        foreach (var a in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                            args.Add(a.Replace("{stereo}", context.Audio.stereo ? "2" : "1").Replace("{bitrateKbps}", $"{Math.Clamp(context.Audio.bitrateKbps, 32, 512)}k"));
                    }
                }
                else
                {
                    args.Add("-c:a");
                    args.Add("copy");
                }
            }
            #endregion

            args.Add("-f");
            args.Add("hls");

            foreach (var c in config.hlsOptions.comand["output"])
            {
                foreach (var a in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                    args.Add(a);
            }

            #region -hls_segment_type
            args.Add("-hls_segment_type");

            if (context.HlsOptions.fmp4)
            {
                args.Add("fmp4");
            }
            else
            {
                args.Add("mpegts");

                foreach (var c in config.hlsOptions.comand["segment_mpegts"])
                {
                    foreach (var a in c.Split(' ', StringSplitOptions.RemoveEmptyEntries))
                        args.Add(a);
                }
            }
            #endregion

            args.Add("-hls_time");
            args.Add(context.HlsOptions.segDur.ToString(CultureInfo.InvariantCulture));

            if (context.live)
            {
                args.Add("-hls_flags");
                args.Add("append_list+omit_endlist+delete_segments");
            }

            args.Add("-hls_list_size");
            args.Add(context.HlsOptions.winSize.ToString(CultureInfo.InvariantCulture));

            #region -start_number
            int? startNumber = context.startNumber;
            if (!startNumber.HasValue && context.HlsOptions.seek > 0)
            {
                int segDur = Math.Max(1, context.HlsOptions.segDur);
                startNumber = context.HlsOptions.seek / segDur;
            }

            if (startNumber.HasValue)
            {
                args.Add("-start_number");
                args.Add(startNumber.Value.ToString());
            }
            #endregion

            args.Add("-master_pl_name");
            args.Add("index.m3u8");

            if (context.HlsOptions.fmp4)
            {
                args.Add("-hls_fmp4_init_filename");
                args.Add("init.mp4");
            }
            else
            {
                args.Add("-hls_playlist_type");
                args.Add("vod");
            }

            args.Add("-hls_segment_filename");
            args.Add(context.HlsOptions.fmp4 ? "seg_%05d.m4s" : "seg_%05d.ts");

            args.Add("-y");
            args.Add("index.m3u8");
            #endregion

            InvkEvent.Transcoding(new EventTranscoding(args, startNumber, context));

            return process;
        }

        private async Task PumpStdErrAsync(TranscodingJob job)
        {
            try
            {
                while (!job.Process.StandardError.EndOfStream)
                {
                    var line = await job.Process.StandardError.ReadLineAsync();
                    if (line == null)
                        break;

                    job.AppendLog(line);
                }
            }
            catch { }
        }

        private async Task IdleWatchdogAsync(TranscodingJob job, TranscodingConf config)
        {
            var idle = TimeSpan.FromSeconds(Math.Max(180, config.idleTimeoutSec));
            var idle_live = TimeSpan.FromSeconds(Math.Max(20, config.idleTimeoutSec_live));

            try
            {
                while (!job.CancellationToken.IsCancellationRequested && !job.Process.HasExited)
                {
                    await Task.Delay(TimeSpan.FromSeconds(1), job.CancellationToken);

                    if (job.Context.live)
                    {
                        if (config.idleTimeoutSec_live == -1)
                            continue;

                        if (DateTime.UtcNow - job.LastAccessUtc > idle_live)
                        {
                            await StopJobAsync(job);
                            break;
                        }
                    }
                    else
                    {

                        if (config.idleTimeoutSec == -1)
                            continue;

                        if (DateTime.UtcNow - job.LastAccessUtc > idle)
                        {
                            await StopJobAsync(job);
                            break;
                        }
                    }
                }
            }
            catch (TaskCanceledException)
            {
            }
        }

        private void OnProcessExit(TranscodingJob job)
        {
            if (job.Context.live)
            {
                job.SignalExit();
                Cleanup(job);
            }
        }

        private bool TryParseToken(string streamId, out string id)
        {
            id = string.Empty;
            var parts = streamId.Split('.', 2);
            if (parts.Length != 2)
                return false;

            id = parts[0];
            if (id.Length != 32)
                return false;

            try
            {
                var padded = parts[1].PadRight(parts[1].Length + (4 - parts[1].Length % 4) % 4, '=');
                var hmac = Convert.FromBase64String(padded.Replace('-', '+').Replace('_', '/'));
                var expected = ComputeHmac(id);
                if (!CryptographicOperations.FixedTimeEquals(hmac, expected))
                    return false;
            }
            catch
            {
                return false;
            }

            return true;
        }

        private string BuildToken(string id)
        {
            var mac = ComputeHmac(id);
            var b64 = Convert.ToBase64String(mac).TrimEnd('=').Replace('+', '-').Replace('/', '_');
            return $"{id}.{b64}";
        }

        private byte[] ComputeHmac(string id)
        {
            using var hmac = new HMACSHA256(_hmacKey);
            return hmac.ComputeHash(Encoding.UTF8.GetBytes(id));
        }

        private static string SanitizeHeader(string value, string fallback = "")
        {
            if (string.IsNullOrWhiteSpace(value))
                return fallback;

            var clean = value.Replace("\r", string.Empty).Replace("\n", string.Empty);
            return string.IsNullOrWhiteSpace(clean) ? fallback : clean;
        }

        private void CleanupSegments()
        {
            if (Interlocked.Exchange(ref _segmentCleanupRunning, 1) == 1)
                return;

            try
            {
                if (!(AppInit.conf?.transcoding?.playlistOptions?.delete_segments ?? false))
                    return;

                foreach (var job in _jobs.Values)
                {
                    if (job.Context.live)
                        continue;

                    var lastIndex = job.LastSegmentIndex;
                    if (0 >= lastIndex)
                        continue;

                    try
                    {
                        if (!Directory.Exists(job.OutputDirectory))
                            continue;

                        foreach (var file in Directory.GetFiles(job.OutputDirectory, "seg_*"))
                        {
                            try
                            {
                                var name = Path.GetFileName(file);
                                var match = _segmentFileRegex.Match(name);
                                if (!match.Success)
                                    continue;

                                if (!int.TryParse(match.Groups[1].Value, out var index))
                                    continue;

                                if (index >= lastIndex - 1)
                                    continue;

                                File.Delete(file);
                            }
                            catch { }
                        }
                    }
                    catch { }
                }
            }
            catch { }
            finally
            {
                Interlocked.Exchange(ref _segmentCleanupRunning, 0);
            }
        }
    }
}

```

## File: Tracks/Engine/TranscodingJob.cs
```
using Shared.Models.AppConf;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;

namespace Tracks.Engine
{
    internal sealed class TranscodingJob : IDisposable
    {
        private const int MaxLogLines = 200;

        private readonly LinkedList<string> _log = new();
        private readonly object _logSync = new();
        private readonly CancellationTokenSource _cts = new();
        private int _lastSegmentIndex = -1;

        public TranscodingJob(string id, string streamId, string outputDirectory, Process process, TranscodingStartContext context)
        {
            Id = id;
            StreamId = streamId;
            OutputDirectory = outputDirectory;
            Process = process;
            Context = context;
            StartedUtc = DateTime.UtcNow;
            LastAccessUtc = StartedUtc;
        }

        public string Id { get; }

        public string StreamId { get; }

        public string OutputDirectory { get; }

        public Process Process { get; }

        public TranscodingStartContext Context { get; }

        public DateTime StartedUtc { get; }

        public DateTime LastAccessUtc { get; private set; }

        public int? ExitCode { get; private set; }

        public bool HasExited => Process.HasExited;

        public CancellationToken CancellationToken => _cts.Token;

        public void UpdateLastAccess() => LastAccessUtc = DateTime.UtcNow;

        public int LastSegmentIndex => Volatile.Read(ref _lastSegmentIndex);

        public void UpdateLastSegmentIndex(int segmentIndex)
        {
            if (segmentIndex < 0)
                return;

            while (true)
            {
                var current = Volatile.Read(ref _lastSegmentIndex);
                if (segmentIndex <= current)
                    return;

                if (Interlocked.CompareExchange(ref _lastSegmentIndex, segmentIndex, current) == current)
                    return;
            }
        }


        public void AppendLog(string line)
        {
            if (string.IsNullOrWhiteSpace(line))
                return;

            lock (_logSync)
            {
                foreach (var part in line.Split('\n'))
                {
                    string trimmed = part.TrimEnd('\r');
                    if (string.IsNullOrWhiteSpace(trimmed))
                        continue;

                    if (trimmed.Length > 2000)
                        trimmed = trimmed[..2000];

                    _log.AddLast(trimmed);
                    if (_log.Count > MaxLogLines)
                        _log.RemoveFirst();
                }
            }
        }

        public string[] SnapshotLog()
        {
            lock (_logSync)
                return _log.ToArray();
        }

        public void SignalExit()
        {
            if (Process.HasExited)
                ExitCode = Process.ExitCode;
        }

        public void StopBackground()
            => _cts.Cancel();

        public void Dispose()
        {
            try
            {
                StopBackground();
            }
            catch { }

            try
            {
                Process.Dispose();
            }
            catch { }
        }
    }
}

```

## File: Tracks/Engine/TranscodingModels.cs
```
using Shared.Models.AppConf;
using System.Collections.Generic;

namespace Tracks.Engine
{
    public sealed class TranscodingStartRequest
    {
        public string src { get; set; } = string.Empty;

        public TranscodingAudioOptions audio { get; set; }

        public TranscodingHlsOptions hls { get; set; }

        public Dictionary<string, string> headers { get; set; }

        public bool live { get; set; }

        public bool? subtitles { get; set; }
    }

    public enum TranscodingJobState
    {
        Running,
        Idle,
        Stopped
    }
}

```

## File: Shared/AppInit.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Newtonsoft.Json;
using Shared.Engine;
using Shared.Models;
using Shared.Models.AppConf;
using Shared.Models.Base;
using Shared.Models.Browser;
using Shared.Models.DLNA;
using Shared.Models.Merchant;
using Shared.Models.Module;
using Shared.Models.Online.Settings;
using Shared.Models.ServerProxy;
using Shared.Models.SISI.Base;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Threading;
using YamlDotNet.Serialization;

namespace Shared
{
    public class AppInit
    {
        #region static
        public static string rootPasswd;

        public static bool Win32NT => Environment.OSVersion.Platform == PlatformID.Win32NT;

        public static bool IsDefaultApnOrCors(string apn) => apn != null && Regex.IsMatch(apn, "(apn.monster|apn.watch|cfhttp.top|lampac.workers.dev)");

        static FileSystemWatcher fileWatcher;

        static AppInit()
        {
            updateConf();
            if (File.Exists("init.conf"))
                lastUpdateConf = File.GetLastWriteTime("init.conf");

            updateYamlConf();
            if (File.Exists("init.yaml") && File.GetLastWriteTime("init.yaml") > lastUpdateConf)
                lastUpdateConf = File.GetLastWriteTime("init.yaml");

            LoadModules();

            #region watcherInit
            if (conf.watcherInit == "system")
            {
                fileWatcher = new FileSystemWatcher
                {
                    Path = Directory.GetCurrentDirectory(),
                    Filter = "init.conf",
                    NotifyFilter = NotifyFilters.FileName | NotifyFilters.LastWrite,
                    EnableRaisingEvents = true
                };

                fileWatcher.Changed += async (s, e) =>
                {
                    fileWatcher.EnableRaisingEvents = false;

                    try
                    {
                        await Task.Delay(200);
                        updateConf();
                        updateYamlConf();
                    }
                    catch { }
                    finally
                    {
                        fileWatcher.EnableRaisingEvents = true;
                    }
                };
            }
            else
            {
                ThreadPool.QueueUserWorkItem(async _ =>
                {
                    while (true)
                    {
                        await Task.Delay(TimeSpan.FromSeconds(1));

                        try
                        {
                            if (File.Exists("init.conf"))
                            {
                                var lwtConf = File.GetLastWriteTime("init.conf");
                                var lwtYaml = File.GetLastWriteTime("init.yaml");

                                if (lwtConf > lastUpdateConf || lwtYaml > lastUpdateConf)
                                {
                                    updateConf();
                                    updateYamlConf();

                                    lastUpdateConf = lwtConf > lwtYaml ? lwtConf : lwtYaml;

                                    try
                                    {

                                        string init = JsonConvert.SerializeObject(conf, Formatting.Indented, new JsonSerializerSettings()
                                        {
                                            NullValueHandling = NullValueHandling.Ignore,
                                            DefaultValueHandling = DefaultValueHandling.Ignore
                                        });

                                        Directory.CreateDirectory("database/backup/init");
                                        File.WriteAllText($"database/backup/init/{DateTime.Now.ToString("dd-MM-yyyy.HH")}.conf", init);
                                    }
                                    catch { }
                                }
                            }
                        }
                        catch { }
                    }
                });
            }
            #endregion
        }
        #endregion

        public readonly string guid = Guid.NewGuid().ToString();

        #region conf
        static DateTime lastUpdateConf = default;

        public static AppInit conf = null;

        static void updateConf()
        {
            if (!File.Exists("init.conf"))
            {
                conf = new AppInit();
                return;
            }

            string initfile = File.ReadAllText("init.conf").Trim();
            initfile = Regex.Replace(initfile, "\"weblog\":([ \t]+)?(true|false)([ \t]+)?,", "", RegexOptions.IgnoreCase);

            if (!initfile.StartsWith("{"))
                initfile = "{" + initfile + "}";

            try
            {
                conf = JsonConvert.DeserializeObject<AppInit>(initfile, new JsonSerializerSettings
                {
                    Error = (se, ev) =>
                    {
                        ev.ErrorContext.Handled = true;
                        Console.WriteLine($"DeserializeObject Exception init.conf:\n{ev.ErrorContext.Error}\n\n");
                    }
                });
            }
            catch { }

            if (conf == null)
                conf = new AppInit();

            PosterApi.Initialization(conf.omdbapi_key, conf.posterApi, new ProxyLink());

            #region accounts
            if (conf.accsdb.accounts != null)
            {
                foreach (var u in conf.accsdb.accounts)
                {
                    if (conf.accsdb.findUser(u.Key) is AccsUser user)
                    {
                        if (u.Value > user.expires)
                            user.expires = u.Value;
                    }
                    else
                    {
                        conf.accsdb.users.Add(new AccsUser()
                        {
                            id = u.Key.ToLower().Trim(),
                            expires = u.Value
                        });
                    }
                }
            }
            #endregion

            #region users.txt
            if (File.Exists("merchant/users.txt"))
            {
                long utc = DateTime.UtcNow.ToFileTimeUtc();
                foreach (string line in File.ReadAllLines("merchant/users.txt"))
                {
                    if (string.IsNullOrWhiteSpace(line) && !line.Contains("@"))
                        continue;

                    var data = line.Split(',');
                    if (data.Length > 1)
                    {
                        if (long.TryParse(data[1], out long ex) && ex > utc)
                        {
                            try
                            {
                                DateTime e = DateTime.FromFileTimeUtc(ex);
                                string email = data[0].ToLower().Trim();

                                if (conf.accsdb.findUser(email) is AccsUser user)
                                {
                                    if (e > user.expires)
                                        user.expires = e;

                                    user.group = conf.Merchant.defaultGroup;
                                }
                                else
                                {
                                    conf.accsdb.users.Add(new AccsUser()
                                    {
                                        id = email,
                                        expires = e,
                                        group = conf.Merchant.defaultGroup
                                    });
                                }
                            }
                            catch { }
                        }
                    }
                }
            }
            #endregion

            try
            {
                File.WriteAllText("current.conf", JsonConvert.SerializeObject(conf, Formatting.Indented));
            }
            catch { }
        }

        static void updateYamlConf()
        {
            if (conf == null)
                return;

            try
            {
                if (File.Exists("init.yaml"))
                {
                    string yaml = File.ReadAllText("init.yaml");
                    if (!string.IsNullOrWhiteSpace(yaml))
                    {
                        var deserializer = new DeserializerBuilder().IgnoreUnmatchedProperties().Build();
                        var yamlObject = deserializer.Deserialize(new StringReader(yaml));
                        if (yamlObject != null)
                        {
                            string json = JsonConvert.SerializeObject(yamlObject);
                            JsonConvert.PopulateObject(json, conf, new JsonSerializerSettings
                            {
                                Error = (se, ev) =>
                                {
                                    ev.ErrorContext.Handled = true;
                                    Console.WriteLine($"DeserializeObject Exception init.yaml:\n{ev.ErrorContext.Error}\n\n");
                                }
                            });

                            try
                            {
                                File.WriteAllText("current.conf", JsonConvert.SerializeObject(conf, Formatting.Indented));
                            }
                            catch { }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"DeserializeObject Exception init.yaml:\n{ex}\n\n");
            }
        }
        #endregion

        #region Host
        public static string Host(HttpContext httpContext)
        {
            string scheme = string.IsNullOrEmpty(conf.listen.scheme) ? httpContext.Request.Scheme : conf.listen.scheme;
            if (httpContext.Request.Headers.TryGetValue("xscheme", out var xscheme) && !string.IsNullOrEmpty(xscheme))
                scheme = xscheme;

            if (!string.IsNullOrEmpty(conf.listen.host))
                return $"{scheme}://{conf.listen.host}";

            if (httpContext.Request.Headers.TryGetValue("xhost", out var xhost))
                return $"{scheme}://{Regex.Replace(xhost, "^https?://", "")}";

            return $"{scheme}://{httpContext.Request.Host.Value}";
        }
        #endregion

        #region modules
        public static List<RootModule> modules;

        public static void LoadModules()
        {
            if (modules != null)
                return;

            modules = null;

            if (File.Exists("module/manifest.json"))
            {
                var jss = new JsonSerializerSettings { Error = (se, ev) => 
                { 
                    ev.ErrorContext.Handled = true; 
                    Console.WriteLine("module/manifest.json - " + ev.ErrorContext.Error + "\n\n"); 
                }};

                var mods = JsonConvert.DeserializeObject<List<RootModule>>(File.ReadAllText("module/manifest.json"), jss);
                if (mods == null)
                    return;

                modules = new List<RootModule>();
                foreach (var mod in mods)
                {
                    if (!mod.enable || mod.dll == "Jackett.dll")
                        continue;

                    string path = File.Exists(mod.dll) ? mod.dll : $"{Environment.CurrentDirectory}/module/{mod.dll}";
                    if (File.Exists(path))
                    {
                        try
                        {
                            mod.assembly = Assembly.LoadFile(path);
                            mod.index = mod.index != 0 ? mod.index : (100 + modules.Count);
                            modules.Add(mod);
                        }
                        catch { }
                    }
                }
            }
        }
        #endregion


        #region server
        public ListenConf listen = new ListenConf() 
        {
            localhost = "127.0.0.1",
            ip = "any", port = 9118,
            compression = true,
            frontend = null // cloudflare|nginx
        };

        public bool multiaccess = false;

        public bool mikrotik = false;

        public string watcherInit = "cron";// system

        public string imagelibrary = "NetVips"; // NetVips|ImageMagick|none

        public bool pirate_store = true;

        public string apikey = null;

        public bool litejac = true;

        public bool filelog = false;

        public bool disableEng = false;

        public bool always_rjson = false;

        public string anticaptchakey;

        public string omdbapi_key;

        public string playerInner;

        public string defaultOn = "enable";

        public string corsehost { get; set; } = "https://cors.apn.monster";

        public CorseuConf —Åorseu { get; set; } = new CorseuConf();

        public MediaApiConf media { get; set; } = new MediaApiConf();

        public ApnConf apn { get; set; } = new ApnConf() { secure = "none" };

        public Dictionary<string, CmdConf> cmd = new Dictionary<string, CmdConf>();

        public PosterApiConf posterApi = new PosterApiConf() 
        {
            rsize = true, width = 210,
            bypass = "statichdrezka\\."
        };

        public KitConf kit = new KitConf() { cacheToSeconds = 20 };

        public SyncConf sync = new SyncConf();

        public HybridCacheConf cache = new HybridCacheConf() 
        {
            type = "file",  // mem|file|hybrid
            extend = -1     // seconds (hybrid)
        };

        public WafConf WAF = new WafConf();

        public WebLogConf weblog = new WebLogConf();

        public OpenStatConf openstat = new OpenStatConf();

        public RchConf rch = new RchConf() 
        { 
            enable = true,
            websoket = "nws" // signalr|nws
        };

        public SyncUserConf sync_user = new SyncUserConf() { enable = true, version = 2 };

        public StorageConf storage = new StorageConf() { enable = true, max_size = 7_000000, brotli = false, md5name = true };

        public GCConf GC { get; set; } = new GCConf() 
        {
            enable = true,
            RetainVM = false, //Concurrent = false,
            ConserveMemory = 9, HighMemoryPercent = 1
        };

        public PuppeteerConf chromium = new PuppeteerConf()
        {
            enable = true, Headless = true,
            Args = ["--disable-blink-features=AutomationControlled"], // , "--window-position=-2000,100"
            context = new KeepopenContext() { keepopen = true, keepalive = 20, min = 0, max = 4 }
        };

        public PuppeteerConf firefox = new PuppeteerConf()
        {
            enable = false, Headless = true,
            context = new KeepopenContext() { keepopen = true, keepalive = 20, min = 1, max = 2 }
        };

        public FfprobeSettings ffprobe = new FfprobeSettings() { enable = true };

        public TranscodingConf transcoding { get; set; } = new TranscodingConf()
        {
            tempRoot = Path.Combine("cache", "transcoding"),
            idleTimeoutSec = 60 * 5, idleTimeoutSec_live = 120,
            maxConcurrentJobs = 5
        };

        public CubConf cub { get; set; } = new CubConf()
        {
            enable = false, viewru = true,
            domain = CrypTo.DecodeBase64("Y3ViLnJlZA=="), scheme = "http",
            mirror = "mirror-kurwa.men",
            cache_api = 180, cache_img = 120,
        };

        public TmdbConf tmdb { get; set; } = new TmdbConf()
        {
            enable = true,
            httpversion = 2, DNS_TTL = 20,
            cache_api = 240, cache_img = 60, check_img = false,
            api_key = "4ef0d7355d9ffb5151e987764708ce96"
        };

        public ServerproxyConf serverproxy = new ServerproxyConf()
        {
            enable = true, verifyip = true,
            encrypt = true, encrypt_aes = true,
            buffering = new ServerproxyBufferingConf()
            {
                enable = true, 
                rent = 81920, // 80KB
                length = 390  // 80KB * 390 —è—á–µ–µ–∫ = ~30MB
            },
            image = new ServerproxyImageConf()
            {
                cache = true, 
                cache_rsize = true,
                cache_time = 60 // minute
            },
            maxlength_m3u = 5000000, // 5mb
            maxlength_ts = 40000000  // 40mb
        };

        public FileCacheConf fileCacheInactive = new FileCacheConf() 
        { 
            hls = 90, html = 5, torrent = 2880 // minute
        };

        public DLNASettings dlna = new DLNASettings() 
        { 
            enable = true, path = "dlna",
            uploadSpeed = 125000 * 10,
            autoupdatetrackers = true, intervalUpdateTrackers = 90, addTrackersToMagnet = true,
            mediaPattern = "^\\.(aac|flac|mpga|mpega|mp2|mp3|m4a|oga|ogg|opus|spx|opus|weba|wav|dif|dv|fli|mp4|mpeg|mpg|mpe|mpv|mkv|ts|m4s|m2ts|mts|ogv|webm|avi|qt|mov)$",
            cover = new CoverSettings() 
            {
                enable = true, preview = true, 
                timeout = 20, skipModificationTime = 60,
                priorityClass = System.Diagnostics.ProcessPriorityClass.Idle,
                extension = "(mp4|mkv|avi|mpg|mpe|mpv)",
                coverComand = "-n -ss 3:00 -i \"{file}\" -vf \"thumbnail=150,scale=400:-2\" -frames:v 1 \"{thumb}\"",
                // —Ñ—Ä—ç–º—Ä—ç–π—Ç -r   : –±–æ–ª—å—à–µ - –±–æ–ª—å—à–µ —Ñ–∞–π–ª , –ø–ª–∞–≤–Ω–µ–µ –¥–≤–∏–∂–µ–Ω–∏—è
                // –∫–∞—á–µ—Å—Ç–≤–æ -crf : –±–æ–ª—å—à–µ - –º–µ–Ω—å—à–µ —Ñ–∞–π–ª , –ø–æ—è–≤–ª—è—é—Ç—Å—è –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã
                previewComand = "-n -ss 00:03:00 -to 00:03:07 -i \"{file}\" -ss 00:04:37 -to 00:04:44 -i \"{file}\" -ss 00:06:41 -to 00:06:48 -i \"{file}\" -ss 00:09:20 -to 00:09:27 -i \"{file}\" -ss 00:12:45 -to 00:12:52 -i \"{file}\" -ss 00:17:09 -to 00:17:16 -i \"{file}\" -ss 00:22:50 -to 00:22:57 -i \"{file}\" -ss 00:29:51 -to 00:29:58 -i \"{file}\" -ss 00:39:23 -to 00:39:30 -i \"{file}\" -ss 00:51:44 -to 00:51:51 -i \"{file}\" -ss 01:07:45 -to 01:07:52 -i \"{file}\" -ss 01:20:33 -to 01:20:40 -i \"{file}\" -filter_complex \"[0:v]setpts=0.5*PTS,scale=-2:240[v0];[1:v]setpts=0.5*PTS,scale=-2:240[v1];[2:v]setpts=0.5*PTS,scale=-2:240[v2];[3:v]setpts=0.5*PTS,scale=-2:240[v3];[4:v]setpts=0.5*PTS,scale=-2:240[v4];[5:v]setpts=0.5*PTS,scale=-2:240[v5];[6:v]setpts=0.5*PTS,scale=-2:240[v6];[7:v]setpts=0.5*PTS,scale=-2:240[v7];[8:v]setpts=0.5*PTS,scale=-2:240[v8];[9:v]setpts=0.5*PTS,scale=-2:240[v9];[10:v]setpts=0.5*PTS,scale=-2:240[v10];[11:v]setpts=0.5*PTS,scale=-2:240[v11];[v0][v1][v2][v3][v4][v5][v6][v7][v8][v9][v10][v11]concat=n=12:v=1:a=0\" -an -r 20 -c:v libx264 -crf 28 -preset veryslow \"{preview}\""
            }
        };

        public WebConf LampaWeb = new WebConf()
        {
            autoupdate = true,
            intervalupdate = 90, // minute
            basetag = true, index = "lampa-main/index.html",
            git = "yumata/lampa",
            tree = "c2416bb9f719d1ef89725443ef0450e20f299f3b"
        };

        public OnlineConf online = new OnlineConf()
        {
            findkp = "all", checkOnlineSearch = true, 
            spider = true, spiderName = "Spider",
            component = "lampac", name = "Lampac", description = "–ü–ª–∞–≥–∏–Ω –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –æ–Ω–ª–∞–π–Ω —Å–µ—Ä–∏–∞–ª–æ–≤ –∏ —Ñ–∏–ª—å–º–æ–≤",
            version = true, btn_priority_forced = true, showquality = true,
            with_search = new List<string>() { "kinotochka", "kinobase", "kinopub", "lumex", "filmix", "filmixtv", "fxapi", "redheadsound", "animevost", "animego", "animedia", "animebesst", "anilibria", "aniliberty", "rezka", "rhsprem", "kodik", "remux", "animelib", "kinoukr", "rc/filmix", "rc/fxapi", "rc/rhs", "vcdn", "videocdn", "lumex", "collaps", "collaps-dash", "vdbmovies", "hdvb", "alloha", "veoveo", "rutubemovie", "vkmovie" }
        };

        public SisiConf sisi { get; set; } = new SisiConf()
        {
            NextHUB = true, spider = true, lgbt = true,
            component = "sisi", iconame = "", push_all = true,
            heightPicture = 240, rsize = true, rsize_disable = ["Chaturbate", "PornHub", "PornHubPremium", "HQporner", "Spankbang", "Porntrex", "Xnxx", "Porndig", "Youjizz", "Veporn", "Pornk"],
            bookmarks = new BookmarksConf() { saveimage = true, savepreview = true },
            history = new HistoryConf() { enable = true, days = 30 }
        };

        public AccsConf accsdb = new AccsConf() 
        { 
            authMesage = "–í–æ–π–¥–∏—Ç–µ –≤ –∞–∫–∫–∞—É–Ω—Ç - –Ω–∞—Å—Ç—Ä–æ–π–∫–∏, —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è",
            denyMesage = "–î–æ–±–∞–≤—å—Ç–µ {account_email} –≤ init.conf –∏–ª–∏ —á–µ—Ä–µ–∑ {host}/admin",
            denyGroupMesage = "–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —ç—Ç–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã",
            expiresMesage = "–í—Ä–µ–º—è –¥–æ—Å—Ç—É–ø–∞ –¥–ª—è {account_email} –∏—Å—Ç–µ–∫–ª–æ –≤ {expires}",
            maxip_hour = 15, maxrequest_hour = 500, maxlock_day = 3, blocked_hour = 36,
            shared_daytime = 366*10, // 10 years
        };

        public MerchantsModel Merchant = new MerchantsModel();

        public VastConf vast = new VastConf();

        public HashSet<Known> KnownProxies { get; set; } = new HashSet<Known>() 
        {
            new Known() { ip = "10.2.0.0", prefixLength = 16 },
            new Known() { ip = "192.168.0.0", prefixLength = 16 }
        };

        public bool real_ip_cf { get; set; }

        public ProxySettings proxy = new ProxySettings();

        public ProxySettings[] globalproxy = new ProxySettings[]
        {
            new ProxySettings()
            {
                pattern = "\\.onion",
                list = ["socks5://127.0.0.1:9050"]
            }
        };

        public IReadOnlyCollection<OverrideResponse> overrideResponse = new List<OverrideResponse>()
        {
            new OverrideResponse()
            {
                pattern = "/over/text",
                action = "html",
                type = "text/plain; charset=utf-8",
                val = "text"
            },
            new OverrideResponse()
            {
                pattern = "/over/online.js",
                action = "file",
                type = "application/javascript; charset=utf-8",
                val = "plugins/online.js"
            },
            new OverrideResponse()
            {
                pattern = "/over/gogoole",
                action = "redirect",
                val = "https://www.google.com/"
            }
        };
        #endregion

        #region SISI
        public SisiSettings BongaCams { get; set; } = new SisiSettings("BongaCams", "kwwsv=22hh1erqjdfdpv1frp")
        {
            spider = false,
            headers = HeadersModel.Init(
                ("referer", "{host}/"),
                ("x-requested-with", "XMLHttpRequest")
            ).ToDictionary()
        };

        public SisiSettings Runetki { get; set; } = new SisiSettings("Runetki", "kwwsv=22uxv1uxqhwnl81frp")
        {
            spider = false,
            headers = HeadersModel.Init(
                ("referer", "{host}/"),
                ("x-requested-with", "XMLHttpRequest")
            ).ToDictionary()
        };

        public SisiSettings Chaturbate { get; set; } = new SisiSettings("Chaturbate", "kwwsv=22fkdwxuedwh1frp")
        {
            spider = false,
        };

        public SisiSettings Ebalovo { get; set; } = new SisiSettings("Ebalovo", "kwwsv=22zzz1hedoryr1sur")
        {
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5")
            ).ToDictionary(),
            headers_stream = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("sec-fetch-dest", "video"),
                ("sec-fetch-mode", "no-cors"),
                ("sec-fetch-site", "same-origin")
            ).ToDictionary()
        };

        public SisiSettings Eporner { get; set; } = new SisiSettings("Eporner", "kwwsv=22zzz1hsruqhu1frp", streamproxy: true);

        public SisiSettings HQporner { get; set; } = new SisiSettings("HQporner", "kwwsv=22p1ktsruqhu1frp")
        {
            geostreamproxy = ["ALL"],
            headers = HeadersModel.Init("referer", "{host}").ToDictionary()
        };

        public SisiSettings Porntrex { get; set; } = new SisiSettings("Porntrex", "kwwsv=22zzz1sruqwuh{1frp", streamproxy: true)
        {
            headers_stream = HeadersModel.Init(
                ("referer", "{host}/")
            ).ToDictionary()
        };

        public SisiSettings Spankbang { get; set; } = new SisiSettings("Spankbang", "kwwsv=22ux1vsdqnedqj1frp");

        public SisiSettings Xhamster { get; set; } = new SisiSettings("Xhamster", "kwwsv=22ux1{kdpvwhu1frp")
        {
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/plain, */*; q=0.0"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "cross-site")
            ).ToDictionary()
        };

        public SisiSettings Xnxx { get; set; } = new SisiSettings("Xnxx", "kwwsv=22zzz1{q{{1frp");

        public SisiSettings Tizam { get; set; } = new SisiSettings("Tizam", "kwwsv=22lq1wl}dp1lqir", streamproxy: true);

        public SisiSettings Xvideos { get; set; } = new SisiSettings("Xvideos", "kwwsv=22zzz1{ylghrv1frp");

        public SisiSettings XvideosRED { get; set; } = new SisiSettings("XvideosRED", "kwwsv=22zzz1{ylghrv1uhg", enable: false);

        public SisiSettings PornHub { get; set; } = new SisiSettings("PornHub", "kwwsv=22uw1sruqkxe1frp", streamproxy: true)
        {
            headers = HeadersModel.Init(
                Http.defaultFullHeaders,
                ("sec-ch-ua-mobile", "?0"),
                ("sec-ch-ua-platform", "\"Windows\""),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-site", "same-origin"),
                ("sec-fetch-mode", "navigate"),
                ("cookie", "platform=pc; accessAgeDisclaimerPH=1")
            ).ToDictionary()
        };

        public SisiSettings PornHubPremium { get; set; } = new SisiSettings("PornHubPremium", "kwwsv=22uw1sruqkxesuhplxp1frp", streamproxy: true, enable: false)
        {
            headers = HeadersModel.Init(
                ("sec-ch-ua-mobile", "?0"),
                ("sec-ch-ua-platform", "\"Windows\""),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-site", "none"),
                ("sec-fetch-user", "?1"),
                ("upgrade-insecure-requests", "1")
            ).ToDictionary()
        };
        #endregion

        #region Online
        /// <summary>
        /// https://iptv.online/ru/dealers/api
        /// </summary>
        public OnlinesSettings IptvOnline { get; set; } = new OnlinesSettings("IptvOnline", "https://iptv.online", enable: false);

        /// <summary>
        /// aHR0cHM6Ly92ZW92ZW8uaW8=
        /// </summary>
        public OnlinesSettings VeoVeo { get; set; } = new OnlinesSettings("VeoVeo", "kwwsv=22dsl1uvwsujdslsw1frp");

        public RezkaSettings Rezka { get; set; } = new RezkaSettings("Rezka", "kwwsv=22kguh}nd1ph", true) 
        {
            ajax = true, reserve = true,
            hls = true, scheme = "http",
            headers = Http.defaultHeaders
        };

        public RezkaSettings RezkaPrem { get; set; } = new RezkaSettings("RezkaPrem", null) 
        { 
            enable = false,
            reserve = true, hls = true, scheme = "http",
            headers = Http.defaultHeaders
        };

        public CollapsSettings Collaps { get; set; } = new CollapsSettings("Collaps", "kwwsv=22dsl1ox{hpeg1zv", streamproxy: true, two: false)
        {
            two = true,
            apihost = "https://api.bhcesh.me",
            token = "eedefb541aeba871dcfc756e6b31c02e",
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("Origin", "https://kinokrad.my")
            ).ToDictionary(),
            headers_stream = HeadersModel.Init(Http.defaultFullHeaders,
                ("Origin", "https://kinokrad.my"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "cross-site"),
                ("accept", "*/*")
            ).ToDictionary()
        };

        public OnlinesSettings Ashdi { get; set; } = new OnlinesSettings("Ashdi", "kwwsv=22edvh1dvkgl1yls") 
        { 
            geo_hide = ["RU", "BY"] 
        };

        public OnlinesSettings Kinoukr { get; set; } = new OnlinesSettings("Kinoukr", "kwwsv=22nlqrxnu1frp")
        {
            geo_hide = ["RU", "BY"],
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("cookie", "legit_user=1;"),
                ("origin", "{host}"),
                ("referer", "{host}/"),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-mode", "navigate"),
                ("sec-fetch-site", "same-origin"),
                ("sec-fetch-user", "?1"),
                ("upgrade-insecure-requests", "1")
            ).ToDictionary()
        };

        public OnlinesSettings Eneyida { get; set; } = new OnlinesSettings("Eneyida", "kwwsv=22hqh|lgd1wy");

        public OnlinesSettings Kinotochka { get; set; } = new OnlinesSettings("Kinotochka", "kwwsv=22nlqryleh1yls", streamproxy: true);

        public OnlinesSettings RutubeMovie { get; set; } = new OnlinesSettings("RutubeMovie", "kwwsv=22uxwxeh1ux", streamproxy: true);

        public OnlinesSettings VkMovie { get; set; } = new OnlinesSettings("VkMovie", "kwwsv=22dsl1ynylghr1ux", streamproxy: true)
        {
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("origin", "encrypt:kwwsv=22ynylghr1ux"),
                ("referer", "encrypt:kwwsv=22ynylghr1ux2")
            ).ToDictionary()
        };

        public OnlinesSettings Plvideo { get; set; } = new OnlinesSettings("Plvideo", "kwwsv=22dsl1j41soylghr1ux", streamproxy: true, enable: false);

        public OnlinesSettings CDNvideohub { get; set; } = new OnlinesSettings("CDNvideohub", "kwwsv=22sodsl1fgqylghrkxe1frp", streamproxy: true)
        {
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("referer", "encrypt:kwwsv=22kgnlqr1sxe2"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "cross-site")
            ).ToDictionary()
        };

        public OnlinesSettings Redheadsound { get; set; } = new OnlinesSettings("Redheadsound", "kwwsv=22uhgkhdgvrxqg1vwxglr", enable: false)
        {
            headers = HeadersModel.Init("referer", "{host}/").ToDictionary()
        };

        public OnlinesSettings iRemux { get; set; } = new OnlinesSettings("iRemux", "kwwsv=22phjdreodnr1frp", streamproxy: true) { corseu = true };

        public PidTorSettings PidTor { get; set; } = new PidTorSettings() 
        { 
            enable = true, redapi = "http://redapi.cfhttp.top", 
            min_sid = 15, emptyVoice = true 
        };

        /// <summary>
        /// http://filmixapp.cyou
        /// http://filmixapp.vip
        /// http://fxapp.biz
        /// </summary>
        public FilmixSettings Filmix { get; set; } = new FilmixSettings("Filmix", "http://filmixapp.cyou")
        {
            reserve = true,
            headers = HeadersModel.Init(
                ("Accept-Encoding", "gzip")
            ).ToDictionary()
        };

        public FilmixSettings FilmixTV { get; set; } = new FilmixSettings("FilmixTV", "kwwsv=22dsl1ilopl{1wy", enable: false)
        {
            pro = true,
            headers = HeadersModel.Init(
                ("user-agent", "Mozilla/5.0 (SMART-TV; LINUX; Tizen 6.0) AppleWebKit/537.36 (KHTML, like Gecko) 76.0.3809.146/6.0 TV Safari/537.36")
            ).ToDictionary()
        };

        public FilmixSettings FilmixPartner { get; set; } = new FilmixSettings("FilmixPartner", "kwws=22819418914;2sduwqhubdsl", enable: false);

        /// <summary>
        /// aHR0cHM6Ly9nby56ZXQtZmxpeC5vbmxpbmU=
        /// aHR0cHM6Ly9nby56ZXRmbGl4LW9ubGluZS5sb2w=
        /// </summary>
        public ZetflixSettings Zetflix { get; set; } = new ZetflixSettings("Zetflix", "kwwsv=22jr1}hw0iol{1rqolqh", enable: false)
        {
            browser_keepopen = true,
            geostreamproxy = ["ALL"],
            hls = true
        };

        /// <summary>
        /// aHR0cHM6Ly9raW5vcGxheTIuc2l0ZS8=
        /// a2lub2dvLm1lZGlh
        /// aHR0cHM6Ly9maWxtLTIwMjQub3JnLw==
        /// </summary>
        public OnlinesSettings VideoDB { get; set; } = new OnlinesSettings("VideoDB", "kwwsv=22nlqrjr1phgld", "kwwsv=2263ei6:<31reuxw1vkrz", streamproxy: true)
        {
            imitationHuman = true,
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("sec-fetch-storage-access", "active"),
                ("upgrade-insecure-requests", "1")
            ).ToDictionary(),
            headers_stream = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "*/*"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("origin", "{host}"),
                ("referer", "{host}/"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "same-site")
            ).ToDictionary()
        };

        /// <summary>
        /// aHR0cHM6Ly9jb2xkZmlsbS5pbmsv
        /// </summary>
        public OnlinesSettings CDNmovies { get; set; } = new OnlinesSettings("CDNmovies", "kwwsv=22frogfgq1{|}")
        {
            headers = HeadersModel.Init(
                ("DNT", "1"),
                ("Upgrade-Insecure-Requests", "1")
            ).ToDictionary()
        };

        public OnlinesSettings VDBmovies { get; set; } = new OnlinesSettings("VDBmovies", "kwwsv=22fgqprylhv0vwuhdp1rqolqh")
        {
            geostreamproxy = ["ALL"],
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("sec-fetch-storage-access", "active"),
                ("upgrade-insecure-requests", "1")
            ).ToDictionary()
        };

        public OnlinesSettings FanCDN { get; set; } = new OnlinesSettings("FanCDN", "kwwsv=22p|idqvhuldo1qhw", streamproxy: true)
        {
            enable = false,
            imitationHuman = true,
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("sec-fetch-storage-access", "active"),
                ("upgrade-insecure-requests", "1")
            ).ToDictionary(),
            headers_stream = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "*/*"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("origin", "encrypt:kwwsv=22idqfgq1qhw"),
                ("referer", "encrypt:kwwsv=22idqfgq1qhw2"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "same-site")
            ).ToDictionary()
        };

        public KinobaseSettings Kinobase { get; set; } = new KinobaseSettings("Kinobase", "kwwsv=22nlqredvh1ruj", true, hdr: true) 
        { 
            geostreamproxy = ["ALL"]
        };

        /// <summary>
        /// aHR0cHM6Ly91YWtpbm9nby5lYw==
        /// aHR0cHM6Ly91YWtpbm9nby5vbmxpbmU=
        /// </summary>
        public OnlinesSettings Kinogo { get; set; } = new OnlinesSettings("Kinogo", "kwwsv=22nlqrjr1ox{xu|", enable: false)
        {
            streamproxy = true
        };

        /// <summary>
        /// –ü–æ–ª—É—á–µ–Ω–∏–µ —É—á–µ—Ç–Ω–æ–π –∑–∞–ø–∏—Å–∏
        /// 
        /// tg: @monk_in_a_hat
        /// email: helpdesk@lumex.ink
        /// </summary>
        public LumexSettings VideoCDN { get; set; } = new LumexSettings("VideoCDN", "https://api.lumex.space", "API-—Ç–æ–∫–µ–Ω", "https://portal.lumex.host", "ID –∫–ª–∏–µ–Ω—Ç")
        {
            enable = false,
            log = false,
            verifyip = true, // —Å—Å—ã–ª–∫–∏ –ø—Ä–∏–≤—è–∑–∞–Ω—ã –∫ ip –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            scheme = "http",
            geostreamproxy = ["UA"],
            hls = false, // false - mp4 / true - m3u8
            disable_protection = false, // true - –æ—Ç–∫–ª—é—á–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ –ø–∞—Ä—Å–µ—Ä
            disable_ads = false, // –æ—Ç–∫–ª—é—á–∏—Ç—å —Ä–µ–∫–ª–∞–º—É
            vast = new VastConf() { msg = "–†–µ–∫–ª–∞–º–∞ –æ—Ç VideoCDN" }
        };

        public LumexSettings Lumex { get; set; } = new LumexSettings("Lumex", "kwwsv=22sruwdo1oxph{1krvw", null, "lumex.space", "tl6h28Hn1rL5")
        {
            enable = true,
            hls = true, scheme = "http",
            priorityBrowser = "http",
            geostreamproxy = ["ALL"]
        };

        public VokinoSettings VoKino { get; set; } = new VokinoSettings("VoKino", "http://api.vokino.org", streamproxy: true);

        public IframeVideoSettings IframeVideo { get; set; } = new IframeVideoSettings("IframeVideo", "kwwsv=22liudph1ylghr", "kwwsv=22ylghriudph1vsdfh", enable: false);

        /// <summary>
        /// aHR0cHM6Ly92aWQxNzMwODAxMzcwLmZvdHBybzEzNWFsdG8uY29tL2FwaS9pZGtwP2twX2lkPTEzOTI1NTAmZD1raW5vZ28uaW5j
        /// </summary>
        public OnlinesSettings HDVB { get; set; } = new OnlinesSettings("HDVB", "kwwsv=22dslye1frp", token: "8h5ih7f:3edig<d:747f7i4:3hh4e4<5")
        {
            headers = Http.defaultFullHeaders
        };

        /// <summary>
        /// aHR0cHM6Ly92aWJpeC5vcmcvYXBpL2V4dGVybmFsL2RvY3VtZW50YXRpb24=
        /// </summary>
        public OnlinesSettings Vibix { get; set; } = new OnlinesSettings("Vibix", "kwwsv=22ylel{1ruj", streamproxy: true, enable: false)
        {
            headers = Http.defaultFullHeaders
        };

        /// <summary>
        /// aHR0cHM6Ly92aWRlb3NlZWQudHYvZmFxLnBocA==
        /// </summary>
        public OnlinesSettings Videoseed { get; set; } = new OnlinesSettings("Videoseed", "kwwsv=22ylghrvhhg1wy", streamproxy: true, enable: false)
        {
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("sec-fetch-storage-access", "active"),
                ("upgrade-insecure-requests", "1")
            ).ToDictionary(),
            headers_stream = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "*/*"),
                ("referer", "encrypt:kwwsv=22wy040nlqrvhuldo1qhw2"),
                ("sec-fetch-dest", "video"),
                ("sec-fetch-mode", "no-cors"),
                ("sec-fetch-site", "cross-site")
            ).ToDictionary()
        };

        /// <summary>
        /// https://api.srvkp.com - —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π 
        /// https://cdn32.lol/api- apk
        /// https://cdn4t.store/api - apk
        /// https://kpapp.link/api - smart tv
        /// https://api.service-kp.com - —Å—Ç–∞—Ä—ã–π 
        /// </summary>
        public KinoPubSettings KinoPub { get; set; } = new KinoPubSettings("KinoPub", "https://api.srvkp.com")
        {
            // hls | hls4 | mp4
            filetype = "hls",
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-mode", "navigate"),
                ("sec-fetch-site", "none"),
                ("sec-fetch-user", "?1"),
                ("upgrade-insecure-requests", "1")
            ).ToDictionary()
        };

        public AllohaSettings Alloha { get; set; } = new AllohaSettings("Alloha", "kwwsv=22dsl1dsexjdoo1ruj", "kwwsv=22wruvr0dv1vwordgl1olyh", "", "", true, true) 
        { 
            reserve = true 
        };

        public AllohaSettings Mirage { get; set; } = new AllohaSettings("Mirage", "kwwsv=22dsl1dsexjdoo1ruj", "kwwsv=22txdguloolrq0dv1doodunqrz1rqolqh", "6892d506bbdd5790e0ca047ff39462", "", true, true)
        {
            enable = true,
            streamproxy = true,
            headers = Http.defaultFullHeaders
        };

        public OnlinesSettings GetsTV { get; set; } = new OnlinesSettings("GetsTV", "https://getstv.com", enable: false) 
        {
            headers = HeadersModel.Init(
                ("user-agent", "Mozilla/5.0 (Web0S; Linux/SmartTV) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.34 Safari/537.36 WebAppManager")
            ).ToDictionary()
        };
        #endregion

        #region ENG
        /// <summary>
        /// aHR0cHM6Ly93d3cuaHlkcmFmbGl4LnZpcA==
        /// </summary>
        public OnlinesSettings Hydraflix { get; set; } = new OnlinesSettings("Hydraflix", "kwwsv=22ylgidvw1sur", streamproxy: true) 
        {
            priorityBrowser = "scraping"
        };

        /// <summary>
        /// aHR0cHM6Ly92aWRzcmMueHl6
        /// aHR0cHM6Ly92aWRzcmMucHJv
        /// aHR0cHM6Ly92aWRzcmMudG8=
        /// </summary>
        public OnlinesSettings Vidsrc { get; set; } = new OnlinesSettings("Vidsrc", "kwwsv=22ylgvuf1ff", streamproxy: true);

        public OnlinesSettings MovPI { get; set; } = new OnlinesSettings("MovPI", "kwwsv=22prylhvdsl1foxe", streamproxy: true);

        /// <summary>
        /// aHR0cHM6Ly9kYXkyc29hcC54eXov
        /// </summary>
        public OnlinesSettings VidLink { get; set; } = new OnlinesSettings("VidLink", "kwwsv=22ylgolqn1sur", streamproxy: true);

        public OnlinesSettings Videasy { get; set; } = new OnlinesSettings("Videasy", "kwwsv=22sod|hu1ylghdv|1qhw", streamproxy: true);

        /// <summary>
        /// aHR0cHM6Ly9zbWFzaHlzdHJlYW0ueHl6
        /// </summary>
        public OnlinesSettings Smashystream { get; set; } = new OnlinesSettings("Smashystream", "kwwsv=22sod|hu1vpdvk|vwuhdp1frp", streamproxy: true);

        public OnlinesSettings Autoembed { get; set; } = new OnlinesSettings("Autoembed", "kwwsv=22sod|hu1dxwrhpehg1ff", streamproxy: true);

        /// <summary>
        /// Omega
        /// </summary>
        public OnlinesSettings Playembed { get; set; } = new OnlinesSettings("Playembed", "https://vidora.su", streamproxy: true, enable: false);


        /// <summary>
        /// EmbedSu
        /// </summary>
        public OnlinesSettings Twoembed { get; set; } = new OnlinesSettings("Twoembed", "https://embed.su", streamproxy: true, enable: false)
        {
            headers_stream = HeadersModel.Init(
                ("accept", "*/*"),
                ("accept-language", "en-US,en;q=0.5"),
                ("referer", "{host}/"),
                ("origin", "{host}"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "cross-site")
            ).ToDictionary()
        };

        public OnlinesSettings Rgshows { get; set; } = new OnlinesSettings("Rgshows", "kwwsv=22dsl1ujvkrzv1ph", streamproxy: true, enable: false)
        {
            headers = HeadersModel.Init(
                ("accept", "*/*"),
                ("user-agent", "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1"),
                ("accept-language", "en-US,en;q=0.5"),
                ("referer", "encrypt:kwwsv=22zzz1ujvkrzv1ph2"),
                ("origin", "encrypt:kwwsv=22zzz1ujvkrzv1ph"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "same-site")
            ).ToDictionary(),
            headers_stream = HeadersModel.Init(
                ("accept", "*/*"),
                ("user-agent", "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1"),
                ("accept-language", "en-US,en;q=0.5"),
                ("referer", "encrypt:kwwsv=22zzz1ujvkrzv1ph2"),
                ("origin", "encrypt:kwwsv=22zzz1ujvkrzv1ph"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "cross-site")
            ).ToDictionary()
        };
        #endregion

        #region Anime
        public KodikSettings Kodik { get; set; } = new KodikSettings("Kodik", "kwwsv=22nrglndsl1frp", "kwwsv=22nrgln1lqir", "74gg<8i;7f54:4<e3<g9f:44;556:d58", "", true)
        {
            auto_proxy = true,      // –ø—Ä–æ–∫—Å–∏ UA –≤ api 
            cdn_is_working = true,  // –ø—Ä–æ–∫—Å–∏ UA –≤ –æ–±—ã—á–Ω–æ–º 
            //geostreamproxy = ["UA"],
            headers = HeadersModel.Init(
                ("referer", "encrypt:kwwsv=22dqlole1ph2")
            ).ToDictionary()
        };

        /// <summary>
        /// move to AniLiberty
        /// </summary>
        public OnlinesSettings AnilibriaOnline { get; set; } = new OnlinesSettings("AnilibriaOnline", "kwwsv=22dsl1dqloleuld1wy", enable: false);

        public OnlinesSettings AniLiberty { get; set; } = new OnlinesSettings("AniLiberty", "kwwsv=22dsl1dqloleuld1dss");

        /// <summary>
        /// aHR0cHM6Ly9hbmlsaWIubWU=
        /// </summary>
        public OnlinesSettings AnimeLib { get; set; } = new OnlinesSettings("AnimeLib", "kwwsv=22dsl1fgqolev1ruj", streamproxy: true)
        {
            enable = false,
            headers = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("origin", "encrypt:kwwsv=22dqlphole1ruj"),
                ("referer", "encrypt:kwwsv=22dqlphole1ruj2"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "cross-site")
            ).ToDictionary(),
            headers_stream = HeadersModel.Init(Http.defaultFullHeaders,
                ("accept", "*/*"),
                ("accept-encoding", "identity;q=1, *;q=0"),
                ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                ("origin", "encrypt:kwwsv=22dqlphole1ruj"),
                ("referer", "encrypt:kwwsv=22dqlphole1ruj2"),
                ("sec-fetch-dest", "video"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "same-site")
            ).ToDictionary()
        };

        public OnlinesSettings AniMedia { get; set; } = new OnlinesSettings("AniMedia", "kwwsv=22dphgld1rqolqh");

        public OnlinesSettings Animevost { get; set; } = new OnlinesSettings("Animevost", "kwwsv=22dqlphyrvw1ruj", streamproxy: true);

        public OnlinesSettings MoonAnime { get; set; } = new OnlinesSettings("MoonAnime", "kwwsv=22dsl1prrqdqlph1duw", token: ";98iHI0H5h4Ef05fd7640h9D4830:;3GIG0:6:F9E") { geo_hide = new string[] { "RU", "BY" } };

        public OnlinesSettings Animebesst { get; set; } = new OnlinesSettings("Animebesst", "kwwsv=22dqlph41ehvw");

        public OnlinesSettings AnimeGo { get; set; } = new OnlinesSettings("AnimeGo", "kwwsv=22dqlphjr1ph", streamproxy: true, enable: false)
        {
            headers_stream = HeadersModel.Init(
                ("origin", "https://aniboom.one"),
                ("referer", "https://aniboom.one/")
            ).ToDictionary()
        };
        #endregion
    }
}

```

## File: Shared/BaseSisiController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Base;
using Shared.Models.Events;
using Shared.Models.Module;
using Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using System.Net;
using System.Reflection;

namespace Shared
{
    public class BaseSisiController : BaseController
    {
        public BaseSettings init { get; private set; }

        #region IsBadInitialization
        async public ValueTask<bool> IsBadInitialization(BaseSettings init, bool? rch = null)
        {
            #region module initialization
            if (AppInit.modules != null)
            {
                var args = new InitializationModel(init, rch);

                foreach (RootModule mod in AppInit.modules.Where(i => i.initialization != null))
                {
                    try
                    {
                        if (mod.assembly.GetType(mod.NamespacePath(mod.initialization)) is Type t)
                        {
                            if (t.GetMethod("Invoke") is MethodInfo m2)
                            {
                                badInitMsg = (ActionResult)m2.Invoke(null, [HttpContext, memoryCache, requestInfo, host, args]);
                                if (badInitMsg != null)
                                    return true;
                            }

                            if (t.GetMethod("InvokeAsync") is MethodInfo m)
                            {
                                badInitMsg = await (Task<ActionResult>)m.Invoke(null, [HttpContext, memoryCache, requestInfo, host, args]);
                                if (badInitMsg != null)
                                    return true;
                            }
                        }
                    }
                    catch { }
                }
            }
            #endregion

            badInitMsg = await InvkEvent.BadInitialization(new EventBadInitialization(init, rch, requestInfo, host, HttpContext.Request, HttpContext, hybridCache));
            if (badInitMsg != null)
                return true;

            this.init = init;

            if (!init.enable || init.rip)
            {
                badInitMsg = OnError("disable");
                return true;
            }

            if (NoAccessGroup(init, out string error_msg))
            {
                badInitMsg = OnError(error_msg, false);
                return true;
            }

            var overridehost = await IsOverridehost(init);
            if (overridehost != null)
            {
                badInitMsg = overridehost;
                return true;
            }

            return IsCacheError(init);
        }
        #endregion

        #region OnError
        public JsonResult OnError(string msg, ProxyManager proxyManager, bool refresh_proxy = true, bool rcache = true)
        {
            if (refresh_proxy && !init.rhub)
                proxyManager?.Refresh();

            return OnError(msg, rcache: rcache);
        }

        public JsonResult OnError(string msg, bool rcache = true)
        {
            var model = new OnErrorResult(msg);

            if (AppInit.conf.multiaccess && rcache && !init.rhub)
                memoryCache.Set(ResponseCache.ErrorKey(HttpContext), model, DateTime.Now.AddSeconds(15));

            HttpContext.Response.StatusCode = 500;
            return Json(model);
        }
        #endregion

        #region OnResult
        public JsonResult OnResult(IList<PlaylistItem> playlists, BaseSettings conf, IList<MenuItem> menu, WebProxy proxy = null, int total_pages = 0)
        {
            if (playlists == null || playlists.Count == 0)
                return OnError("playlists", false);

            var result = new OnListResult(playlists.Count, total_pages, menu);

            for (int i = 0; i < playlists.Count; i++)
            {
                var pl = playlists[i];
                result.list[i] = new OnResultPlaylistItem
                {
                    name = pl.name,
                    video = HostStreamProxy(conf, pl.video, proxy: proxy),
                    model = pl.model,
                    picture = HostImgProxy(pl.picture, plugin: conf?.plugin),
                    preview = pl.preview,
                    time = pl.time,
                    json = pl.json,
                    related = pl.related,
                    quality = pl.quality,
                    qualitys = pl.qualitys,
                    bookmark = pl.bookmark,
                    hide = pl.hide,
                    myarg = pl.myarg
                };
            }

            return new JsonResult(result);
        }

        public JsonResult OnResult(IList<PlaylistItem> playlists, IList<MenuItem> menu, List<HeadersModel> headers = null, int total_pages = 0, string plugin = null)
        {
            if (playlists == null || playlists.Count == 0)
                return OnError("playlists", false);

            var result = new OnListResult(playlists.Count, total_pages, menu);

            for (int i = 0; i < playlists.Count; i++)
            {
                var pl = playlists[i];
                result.list[i] = new OnResultPlaylistItem
                {
                    name = pl.name,
                    video = pl.video.StartsWith("http") ? pl.video : $"{AppInit.Host(HttpContext)}/{pl.video}",
                    model = pl.model,
                    picture = HostImgProxy(pl.picture, plugin: plugin, headers: headers),
                    preview = pl.preview,
                    time = pl.time,
                    json = pl.json,
                    related = pl.related,
                    quality = pl.quality,
                    qualitys = pl.qualitys,
                    bookmark = pl.bookmark,
                    hide = pl.hide,
                    myarg = pl.myarg
                };
            }

            return new JsonResult(result);
        }

        public JsonResult OnResult(Dictionary<string, string> stream_links, BaseSettings init, WebProxy proxy, List<HeadersModel> headers_stream = null)
        {
            return OnResult(new StreamItem() { qualitys = stream_links }, init, proxy, headers_stream: headers_stream);
        }

        public JsonResult OnResult(StreamItem stream_links, BaseSettings init, WebProxy proxy, List<HeadersModel> headers_img = null, List<HeadersModel> headers_stream = null)
        {
            var result = new OnStreamResult(stream_links?.recomends?.Count ?? 0);

            if (!init.streamproxy && (init.geostreamproxy == null || init.geostreamproxy.Length == 0))
            {
                if (init.qualitys_proxy)
                    result.qualitys_proxy = stream_links.qualitys.ToDictionary(k => k.Key, v => HostStreamProxy(init, v.Value, proxy: proxy, headers: headers_stream, force_streamproxy: true));
            }

            if (stream_links.recomends != null && stream_links.recomends.Count > 0)
            {
                for (int i = 0; i < stream_links.recomends.Count; i++)
                {
                    var pl = stream_links.recomends[i];
                    result.recomends[i] = new OnResultPlaylistItem
                    {
                        name = pl.name,
                        video = pl.video.StartsWith("http") ? pl.video : $"{AppInit.Host(HttpContext)}/{pl.video}",
                        picture = HostImgProxy(pl.picture, height: 110, plugin: init?.plugin, headers: headers_img),
                        json = pl.json
                    };
                }
            }

            result.qualitys = stream_links.qualitys.ToDictionary(k => k.Key, v => HostStreamProxy(init, v.Value, proxy: proxy, headers: headers_stream));
            result.headers_stream = init.streamproxy ? null : (headers_stream?.ToDictionary() ?? init.headers_stream);

            return new JsonResult(result);
        }
        #endregion

        #region IsRhubFallback
        public bool IsRhubFallback(BaseSettings init)
        {
            if (init.rhub && init.rhub_fallback)
            {
                init.rhub = false;
                return true;
            }

            return false;
        }
        #endregion

        public Task<ActionResult> InvkSemaphore(string key, Func<ValueTask<ActionResult>> func) => InvkSemaphore(init, key, func);
    }
}

```

## File: Shared/Startup.cs
```
Ôªøusing Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Caching.Memory;

namespace Shared
{
    public class Startup
    {
        public static bool IsShutdown { get; set; }

        public static IServiceProvider ApplicationServices { get; private set; }

        public static IMemoryCache memoryCache { get; private set; }

        public static void Configure(IApplicationBuilder app, IMemoryCache mem)
        {
            ApplicationServices = app.ApplicationServices;
            memoryCache = mem;
        }
    }
}

```

## File: Shared/EventListener.cs
```
using Microsoft.AspNetCore.Mvc;
using Shared.Models;
using Shared.Models.Events;
using Shared.Models.JacRed;

namespace Shared
{
    public class EventListener
    {
        public static Action<EventLoadKit> LoadKitInit;

        public static Action<EventLoadKit> LoadKit;

        public static Func<EventProxyApiCreateHttpRequest, Task> ProxyApiCreateHttpRequest;

        public static Func<EventBadInitialization, Task<ActionResult>> BadInitialization;

        public static Func<EventHostStreamProxy, string> HostStreamProxy;

        public static Func<EventMyLocalIp, Task<string>> MyLocalIp;

        public static Func<EventControllerHttpHeaders, List<HeadersModel>> HttpHeaders;

        public static Func<bool, EventMiddleware, Task<bool>> Middleware;

        public static Func<string, EventAppReplace, string> AppReplace;

        public static Action<TorrentDetails> RedApiAddTorrents;

        public static Action<EventTranscoding> TranscodingCreateProcess;

        public static Action<EventHttpHandler> HttpHandler;

        public static Action<EventHttpHeaders> HttpRequestHeaders;

        public static Func<EventHttpResponse, Task> HttpResponse;

        public static Func<EventExternalids, (string imdb_id, string kinopoisk_id)> Externalids;

        public static Func<EventStreamQuality, (bool? next, string link)> StreamQuality;

        public static Func<EventStreamQualityFirts, (string link, string quality)?> StreamQualityFirts;

        public static Func<string, EventHybridCache, (DateTimeOffset ex, string value)> HybridCache;


        public static Action<EventRchRegistry> RchRegistry;

        public static Action<string> RchDisconnected;


        public static Action<EventNwsConnected> NwsConnected;

        public static Action<EventNwsMessage> NwsMessage;

        public static Action<string> NwsDisconnected;
    }
}

```

## File: Shared/BaseOnlineController.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Base;
using Shared.Models.Events;
using Shared.Models.Module;
using System.Reflection;

namespace Shared
{
    public class BaseOnlineController : BaseController
    {
        #region IsBadInitialization
        async public ValueTask<bool> IsBadInitialization(BaseSettings init, bool? rch = null)
        {
            #region module initialization
            if (AppInit.modules != null)
            {
                var args = new InitializationModel(init, rch);

                foreach (RootModule mod in AppInit.modules.Where(i => i.initialization != null))
                {
                    try
                    {
                        if (mod.assembly.GetType(mod.NamespacePath(mod.initialization)) is Type t)
                        {
                            if (t.GetMethod("Invoke") is MethodInfo m2)
                            {
                                badInitMsg = (ActionResult)m2.Invoke(null, [HttpContext, memoryCache, requestInfo, host, args]);
                                if (badInitMsg != null)
                                    return true;
                            }

                            if (t.GetMethod("InvokeAsync") is MethodInfo m)
                            {
                                badInitMsg = await (Task<ActionResult>)m.Invoke(null, [HttpContext, memoryCache, requestInfo, host, args]);
                                if (badInitMsg != null)
                                    return true;
                            }
                        }
                    }
                    catch { }
                }
            }
            #endregion

            badInitMsg = await InvkEvent.BadInitialization(new EventBadInitialization(init, rch, requestInfo, host, HttpContext.Request, HttpContext, hybridCache));
            if (badInitMsg != null)
                return true;

            if (!init.enable || init.rip)
            {
                badInitMsg = OnError("disable");
                return true;
            }

            if (NoAccessGroup(init, out string error_msg))
            {
                badInitMsg = new JsonResult(new { accsdb = true, msg = error_msg });
                return true;
            }

            var overridehost = await IsOverridehost(init);
            if (overridehost != null)
            {
                badInitMsg = overridehost;
                return true;
            }

            if (rch != null)
            {
                if ((bool)rch)
                {
                    if (init.rhub && !AppInit.conf.rch.enable)
                    {
                        badInitMsg = ShowError(RchClient.ErrorMsg);
                        return true;
                    }
                }
                else
                {
                    if (init.rhub)
                    {
                        badInitMsg = ShowError(RchClient.ErrorMsg);
                        return true;
                    }
                }
            }

            return IsCacheError(init);
        }
        #endregion


        #region MaybeInHls
        public bool MaybeInHls(bool hls, BaseSettings init)
        {
            if (!string.IsNullOrEmpty(init.apn?.host) && AppInit.IsDefaultApnOrCors(init.apn?.host))
                return false;

            if (init.apnstream && AppInit.IsDefaultApnOrCors(AppInit.conf.apn?.host))
                return false;

            return hls;
        }
        #endregion

        #region OnLog
        public void OnLog(string msg)
        {
            if (AppInit.conf.weblog.enable)
                Http.onlog?.Invoke(null, msg + "\n");
        }
        #endregion

        #region OnError
        public ActionResult OnError(ProxyManager proxyManager, bool refresh_proxy = true, string weblog = null) => OnError(string.Empty, proxyManager, refresh_proxy, weblog: weblog);

        public ActionResult OnError(string msg, ProxyManager? proxyManager, bool refresh_proxy = true, string weblog = null)
        {
            if (string.IsNullOrEmpty(msg) || !msg.StartsWith("{\"rch\""))
            {
                if (refresh_proxy)
                    proxyManager?.Refresh();
            }

            return OnError(msg, weblog: weblog);
        }

        public ActionResult OnError() => OnError(string.Empty);

        public ActionResult OnError(string msg, bool gbcache = true, string weblog = null)
        {
            if (!string.IsNullOrEmpty(msg))
            {
                if (msg.StartsWith("{\"rch\""))
                    return Content(msg);

                string log = $"{HttpContext.Request.Path.Value}\n{msg}";
                if (!string.IsNullOrEmpty(weblog))
                    log += $"\n\n\n===================\n\n{weblog}";

                Http.onlog?.Invoke(null, log);
            }

            if (AppInit.conf.multiaccess && gbcache)
                memoryCache.Set(ResponseCache.ErrorKey(HttpContext), msg ?? string.Empty, DateTime.Now.AddSeconds(20));

            HttpContext.Response.StatusCode = 500;
            return Content(msg ?? string.Empty, "text/html; charset=utf-8");
        }
        #endregion

        #region OnResult
        public ActionResult OnResult(CacheResult<string> cache, bool gbcache = true)
        {
            if (!cache.IsSuccess)
                return OnError(cache.ErrorMsg, gbcache: gbcache);

            return Content(cache.Value, "text/html; charset=utf-8");
        }

        public ActionResult OnResult<T>(CacheResult<T> cache, Func<string> html, bool origsource = false, bool gbcache = true)
        {
            if (!cache.IsSuccess)
                return OnError(cache.ErrorMsg, gbcache: gbcache);

            if (origsource && cache.Value != null)
                return Json(cache.Value);

            return ContentTo(html.Invoke());
        }
        #endregion

        public ActionResult ShowError(string msg) => Json(new { accsdb = true, msg });

        public string ShowErrorString(string msg) => System.Text.Json.JsonSerializer.Serialize(new { accsdb = true, msg });

        #region IsRhubFallback
        public bool IsRhubFallback<T>(CacheResult<T> cache, BaseSettings init)
        {
            if (cache.IsSuccess)
                return false;

            if (cache.ErrorMsg != null && cache.ErrorMsg.StartsWith("{\"rch\""))
                return false;

            if (cache.Value == null && init.rhub && init.rhub_fallback)
            {
                init.rhub = false;
                return true;
            }

            return false;
        }
        #endregion
    }
}

```

## File: Shared/InvkEvent.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.CodeAnalysis.Scripting;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Events;
using System.Collections.ObjectModel;
using System.Net;
using System.Net.Http;
using System.Security.Cryptography;
using System.Text.Json;
using System.Threading;
using YamlDotNet.Serialization;

namespace Shared
{
    public static class InvkEvent
    {
        #region static
        static InvkEvent()
        {
            updateConf();

            var eventsDir = Path.Combine(AppContext.BaseDirectory, "events");
            var lastWriteTimes = new Dictionary<string, DateTime>();

            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞—Ç
            foreach (var file in Directory.Exists(eventsDir) ? Directory.GetFiles(eventsDir, "*.yaml") : Array.Empty<string>())
                lastWriteTimes[file] = File.GetLastWriteTimeUtc(file);

            ThreadPool.QueueUserWorkItem(async _ =>
            {
                while (true)
                {
                    await Task.Delay(TimeSpan.FromSeconds(1));

                    if (!Directory.Exists(eventsDir))
                        continue;

                    bool changed = false;
                    var files = Directory.GetFiles(eventsDir, "*.yaml");

                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–æ–≤—ã—Ö –∏ –∏–∑–º–µ–Ω—ë–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
                    foreach (var file in files)
                    {
                        var writeTime = File.GetLastWriteTimeUtc(file);
                        if (!lastWriteTimes.TryGetValue(file, out var lastTime) || writeTime != lastTime)
                        {
                            changed = true;
                            lastWriteTimes[file] = writeTime;
                        }
                    }

                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–¥–∞–ª—ë–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
                    foreach (var file in lastWriteTimes.Keys.ToList())
                    {
                        if (!files.Contains(file))
                        {
                            changed = true;
                            lastWriteTimes.Remove(file);
                        }
                    }

                    if (changed)
                        updateConf();
                }
            });
        }
        #endregion

        #region conf
        public static EventsModel conf = new EventsModel();

        static void updateConf()
        {
            var eventsDir = Path.Combine(AppContext.BaseDirectory, "events");
            if (!Directory.Exists(eventsDir))
                return;

            var deserializer = new DeserializerBuilder().Build();
            var serializer = new SerializerBuilder().Build();

            // –ò—Ç–æ–≥–æ–≤—ã–π —Å–ª–æ–≤–∞—Ä—å –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤
            var merged = new Dictionary<object, object>();

            foreach (string file in Directory.GetFiles(eventsDir, "*.yaml"))
            {
                try
                {
                    if (Path.GetFileName(file) is "example.yaml" or "interceptors.yaml")
                        continue;

                    var yaml = File.ReadAllText(file);
                    var dict = deserializer.Deserialize<Dictionary<object, object>>(yaml);

                    foreach (var property in dict)
                    {
                        if (!merged.ContainsKey(property.Key))
                        {
                            merged[property.Key] = property.Value;
                            continue;
                        }

                        if (property.Value is IDictionary<object, object> sourceDict &&
                            merged[property.Key] is IDictionary<object, object> targetDict)
                        {
                            foreach (var item in sourceDict)
                                targetDict[item.Key] = item.Value;
                        }
                        else
                        {
                            merged[property.Key] = property.Value;
                        }
                    }
                }
                catch (Exception ex) { Console.WriteLine(ex); }
            }

            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ–±—ä–µ–¥–∏–Ω—ë–Ω–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å –æ–±—Ä–∞—Ç–Ω–æ –≤ YAML, –∑–∞—Ç–µ–º –¥–µ—Å–µ—Ä–∏–∞–ª–∏–∑—É–µ–º –≤ EventsModel
            var yamlResult = serializer.Serialize(merged);
            conf = deserializer.Deserialize<EventsModel>(yamlResult);
        }
        #endregion

        #region FileOrCode
        static string FileOrCode(string _val)
        {
            if (_val.EndsWith(".cs"))
                return FileCache.ReadAllText(Path.Combine("events", _val));

            return _val;
        }
        #endregion


        #region Invoke<T>
        static T Invoke<T>(string cs, object model, ScriptOptions options = null)
        {
            try
            {
                if (cs != null)
                    return CSharpEval.Execute<T>(FileOrCode(cs), model, options);
            }
            catch { }

            return default;
        }
        #endregion

        #region InvokeAsync<T>
        static Task<T> InvokeAsync<T>(string cs, object model, ScriptOptions options = null)
        {
            try
            {
                if (cs != null)
                    return CSharpEval.ExecuteAsync<T>(FileOrCode(cs), model, options);
            }
            catch { }

            return Task.FromResult(default(T));
        }
        #endregion

        #region Invoke
        static void Invoke(string cs, object model, ScriptOptions options = null)
        {
            try
            {
                if (cs != null)
                    CSharpEval.Execute(FileOrCode(cs), model, options);
            }
            catch { }
        }
        #endregion

        #region InvokeAsync
        static Task InvokeAsync(string cs, object model, ScriptOptions options = null)
        {
            try
            {
                if (cs != null)
                    return CSharpEval.ExecuteAsync(FileOrCode(cs), model, options);
            }
            catch { }

            return Task.CompletedTask;
        }
        #endregion


        #region LoadKitInit
        public static void LoadKitInit(EventLoadKit model)
        {
            EventListener.LoadKitInit?.Invoke(model);

            if (conf?.LoadKitInit == null)
                return;

            Invoke(conf?.LoadKitInit, model, ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Models.Base")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO"));
        }
        #endregion

        #region LoadKit
        public static void LoadKit(EventLoadKit model)
        {
            EventListener.LoadKit?.Invoke(model);

            if (conf?.LoadKit == null)
                return;

            Invoke(conf?.LoadKit, model, ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Models.Base")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO"));
        }
        #endregion

        #region ProxyApi
        async public static Task ProxyApi(object model)
        {
            string code = null;

            if (model is EventProxyApiCreateHttpRequest httpRequestModel)
            {
                code = conf?.ProxyApi?.CreateHttpRequest;

                if (EventListener.ProxyApiCreateHttpRequest != null)
                    await EventListener.ProxyApiCreateHttpRequest.Invoke(httpRequestModel);
            }

            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(typeof(HttpRequest).Assembly).AddImports("Microsoft.AspNetCore.Http")
                .AddReferences(typeof(Task).Assembly).AddImports("System.Threading.Tasks")
                .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine")
                .AddReferences(typeof(HttpRequestMessage).Assembly).AddImports("System.Net.Http")
                .AddReferences(typeof(System.Net.Cookie).Assembly).AddImports("System.Net")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO");

            await InvokeAsync(code, model, option);
        }
        #endregion

        #region BadInitialization
        public static Task<ActionResult> BadInitialization(EventBadInitialization model)
        {
            if (conf?.Controller?.BadInitialization == null)
            {
                if (EventListener.BadInitialization != null)
                    return EventListener.BadInitialization.Invoke(model);

                return Task.FromResult(default(ActionResult));
            }

            var option = ScriptOptions.Default
                .AddReferences(typeof(ActionResult).Assembly).AddImports("Microsoft.AspNetCore.Mvc")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Models.Base").AddImports("Shared.Engine")
                .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO");

            return InvokeAsync<ActionResult>(conf?.Controller?.BadInitialization, model, option);
        }
        #endregion

        #region HostStreamProxy
        public static string HostStreamProxy(EventHostStreamProxy model)
        {
            if (conf?.Controller?.HostStreamProxy == null)
                return EventListener.HostStreamProxy?.Invoke(model);

            var option = ScriptOptions.Default
                .AddReferences(typeof(HttpContext).Assembly).AddImports("Microsoft.AspNetCore.Http")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Engine").AddImports("Shared.Models.Base").AddImports("Shared.Models")
                .AddReferences(typeof(WebProxy).Assembly).AddImports("System.Net")
                .AddReferences(typeof(MD5).Assembly).AddImports("System.Security.Cryptography")
                .AddImports("System.Collections.Generic");

            return Invoke<string>(conf.Controller.HostStreamProxy, model, option);
        }
        #endregion

        #region MyLocalIp
        public static Task<string> MyLocalIp(EventMyLocalIp model)
        {
            if (string.IsNullOrEmpty(conf?.Controller?.MyLocalIp))
            {
                if (EventListener.MyLocalIp != null)
                    return EventListener.MyLocalIp.Invoke(model);

                return Task.FromResult(default(string));
            }

            var option = ScriptOptions.Default
                .AddReferences(typeof(HttpContext).Assembly).AddImports("Microsoft.AspNetCore.Http")
                .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Engine").AddImports("Shared.Models.Base")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO");

            return InvokeAsync<string>(conf.Controller.MyLocalIp, model, option);
        }
        #endregion

        #region HttpHeaders
        public static List<HeadersModel> HttpHeaders(EventControllerHttpHeaders model)
        {
            if (string.IsNullOrEmpty(conf?.Controller?.HttpHeaders))
                return EventListener.HttpHeaders?.Invoke(model);

            var option = ScriptOptions.Default
                .AddReferences(typeof(HttpContext).Assembly).AddImports("Microsoft.AspNetCore.Http")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Models.Base").AddImports("Shared.Models")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO")
                .AddImports("System.Collections.Generic");

            return Invoke<List<HeadersModel>>(conf.Controller.HttpHeaders, model, option);
        }
        #endregion

        #region Middleware
        public static Task<bool> Middleware(bool first, EventMiddleware model)
        {
            if ((first ? conf?.Middleware?.first : conf?.Middleware?.end) == null)
            {
                if (EventListener.Middleware != null)
                    return EventListener.Middleware.Invoke(first, model);

                return Task.FromResult(default(bool));
            }

            var option = ScriptOptions.Default
                .AddReferences(typeof(HttpContext).Assembly).AddImports("Microsoft.AspNetCore.Http")
                .AddReferences(typeof(Task).Assembly).AddImports("System.Threading.Tasks")
                .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine")
                .AddReferences(typeof(HttpRequestMessage).Assembly).AddImports("System.Net.Http")
                .AddReferences(typeof(System.Net.Cookie).Assembly).AddImports("System.Net")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO");

            return InvokeAsync<bool>(first ? conf?.Middleware?.first : conf?.Middleware?.end, model, option);
        }
        #endregion

        #region AppReplace
        public static string AppReplace(string e, EventAppReplace model)
        {
            string code = null;

            switch (e)
            {
                case "online":
                    code = conf?.Controller?.AppReplace?.online?.eval;
                    break;

                case "sisi":
                    code = conf?.Controller?.AppReplace?.sisi?.eval;
                    break;

                case "appjs":
                    code = conf?.Controller?.AppReplace?.appjs?.eval;
                    break;

                case "appcss":
                    code = conf?.Controller?.AppReplace?.appcss?.eval;
                    break;
            }

            if (string.IsNullOrEmpty(code))
                return EventListener.AppReplace?.Invoke(e, model);

            return Invoke<string>(code, model, ScriptOptions.Default.AddReferences(typeof(File).Assembly).AddImports("System.IO"));
        }
        #endregion

        #region Http
        public static void Http(object model)
        {
            string code = null;
            var modelType = model.GetType();

            if (modelType == typeof(EventHttpHandler))
            {
                code = conf?.Http?.Handler;
                EventListener.HttpHandler?.Invoke((EventHttpHandler)model);
            }

            else if (modelType == typeof(EventHttpHeaders))
            {
                code = conf?.Http?.Headers;
                EventListener.HttpRequestHeaders?.Invoke((EventHttpHeaders)model);
            }

            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(typeof(WebProxy).Assembly).AddImports("System.Net")
                .AddReferences(typeof(HttpClientHandler).Assembly).AddImports("System.Net.Http")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO");

            Invoke(code, model, option);
        }

        public static Task HttpAsync(object model)
        {
            string code = null;
            var modelType = model.GetType();

            if (modelType == typeof(EventHttpResponse))
            {
                code = conf?.Http?.Response;

                if (string.IsNullOrEmpty(code) && EventListener.HttpResponse != null)
                    return EventListener.HttpResponse.Invoke((EventHttpResponse)model);
            }

            if (string.IsNullOrEmpty(code))
                return Task.CompletedTask;

            var option = ScriptOptions.Default
                .AddReferences(typeof(WebProxy).Assembly).AddImports("System.Net")
                .AddReferences(typeof(HttpClientHandler).Assembly).AddImports("System.Net.Http");

            if (modelType == typeof(EventHttpResponse))
            {
                option.AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                      .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine")
                      .AddReferences(typeof(File).Assembly).AddImports("System.IO");
            }

            return InvokeAsync(code, model, option);
        }
        #endregion

        #region RedApi
        public static bool RedApi(string e, object model)
        {
            string code = null;

            switch (e)
            {
                case "addtorrent":
                    code = conf?.RedApi?.AddTorrents;
                    break;
            }

            return Invoke<bool>(code, model);
        }
        #endregion

        #region Externalids
        public static void Externalids(string id, ref string imdb_id, ref string kinopoisk_id, int serial)
        {
            (string imdb_id, string kinopoisk_id) result = default;

            var md = new EventExternalids(id, imdb_id, kinopoisk_id, serial);

            if (EventListener.Externalids != null)
                result = EventListener.Externalids.Invoke(md);

            if (!string.IsNullOrEmpty(conf?.Controller?.Externalids))
                result = Invoke<(string imdb_id, string kinopoisk_id)>(conf.Controller.Externalids, md);

            if (result == default || (result.imdb_id == null && result.kinopoisk_id == null))
                return;

            imdb_id = result.imdb_id;
            kinopoisk_id = result.kinopoisk_id;
        }
        #endregion

        #region StreamQualityTpl
        public static (bool? next, string link) StreamQuality(EventStreamQuality model)
        {
            if (string.IsNullOrEmpty(conf?.StreamQualityTpl))
                return EventListener.StreamQuality?.Invoke(model) ?? default;

            var option = ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Models.Events").AddImports("Shared.Models.Templates");

            return Invoke<(bool? next, string link)>(conf.StreamQualityTpl, model, option);
        }

        public static (string link, string quality)? StreamQualityFirts(EventStreamQualityFirts model)
        {
            if (string.IsNullOrEmpty(conf?.StreamQualityFirts))
                return EventListener.StreamQualityFirts?.Invoke(model);

            var option = ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Models.Events").AddImports("Shared.Models.Templates");

            return Invoke<(string link, string quality)?>(conf.StreamQualityFirts, model, option);
        }
        #endregion

        #region Transcoding
        public static void Transcoding(EventTranscoding model)
        {
            EventListener.TranscodingCreateProcess?.Invoke(model);

            var code = conf?.Transcoding?.CreateProcess;
            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(typeof(Collection<string>).Assembly).AddImports("System.Collections.ObjectModel")
                .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine").AddImports("Shared.Models.AppConf");

            Invoke(code, model, option);
        }
        #endregion

        #region Rch
        public static void RchRegistry(EventRchRegistry model)
        {
            EventListener.RchRegistry?.Invoke(model);

            var code = conf?.Rch?.Registry;
            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                .AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine");

            Invoke(code, model, option);
        }

        public static void RchDisconnected(EventRchDisconnected model)
        {
            EventListener.RchDisconnected?.Invoke(model.connectionId);

            var code = conf?.Rch?.Disconnected;
            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll"))
                .AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine");

            Invoke(code, model, option);
        }
        #endregion

        #region Nws
        public static void NwsConnected(EventNwsConnected model)
        {
            EventListener.NwsConnected?.Invoke(model);

            var code = conf?.Nws?.Connected;
            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(typeof(CancellationToken).Assembly).AddImports("System.Threading")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine");

            Invoke(code, model, option);
        }

        public static void NwsMessage(EventNwsMessage model)
        {
            EventListener.NwsMessage?.Invoke(model);

            var code = conf?.Nws?.Message;
            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(typeof(JsonElement).Assembly).AddImports("System.Text.Json")
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine");

            Invoke(code, model, option);
        }

        public static void NwsDisconnected(EventNwsDisconnected model)
        {
            EventListener.NwsDisconnected?.Invoke(model.connectionId);

            var code = conf?.Nws?.Disconnected;
            if (string.IsNullOrEmpty(code))
                return;

            var option = ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared").AddImports("Shared.Models").AddImports("Shared.Engine");

            Invoke(code, model, option);
        }
        #endregion

        #region HybridCache
        public static (DateTimeOffset ex, string value) HybridCache(string e, string key, string value, DateTimeOffset ex)
        {
            string code = null;

            var model = new EventHybridCache(key, value, ex);

            switch (e)
            {
                case "read":
                    code = conf?.HybridCache?.Read;
                    break;

                case "write":
                    code = conf?.HybridCache?.Write;
                    break;
            }

            if (string.IsNullOrEmpty(code))
                return EventListener.HybridCache?.Invoke(e, model) ?? default;

            var option = ScriptOptions.Default
                .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Engine")
                .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                .AddReferences(typeof(File).Assembly).AddImports("System.IO");

            return Invoke<(DateTimeOffset ex, string value)>(code, model, option);
        }
        #endregion

        public static void PidTor(EventPidTor model) => Invoke(conf?.PidTor, model);
    }
}

```

## File: Shared/Extensions.cs
```
Ôªøusing Shared.Models;

public static class Extensions
{
    public static Dictionary<string, string> ToDictionary(this IEnumerable<HeadersModel> headers)
    {
        if (headers == null)
            return null;

        var result = new Dictionary<string, string>();
        foreach (var h in headers)
            result.TryAdd(h.name, h.val);

        return result;
    }
}
```

## File: Shared/GlobalUsings.cs
```
Ôªøglobal using System;
global using System.Threading.Tasks;
global using System.Collections.Generic;
global using System.IO;
global using System.Linq;
```

## File: Shared/BaseController.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Engine;
using Shared.Models;
using Shared.Models.AppConf;
using Shared.Models.Base;
using Shared.Models.Events;
using Shared.Models.Online.Settings;
using Shared.Models.SISI.OnResult;
using System.Collections.Concurrent;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Web;
using IO = System.IO;

namespace Shared
{
    public class BaseController : Controller, IDisposable
    {
        IServiceScope serviceScope;

        public static string appversion => "149";

        public static string minorversion => "38";

        public HybridCache hybridCache { get; private set; }

        public IMemoryCache memoryCache { get; private set; }

        public RequestModel requestInfo => HttpContext.Features.Get<RequestModel>();

        public string host => AppInit.Host(HttpContext);

        protected static readonly ConcurrentDictionary<string, SemaphoreSlim> _semaphoreLocks = new();

        public ActionResult badInitMsg { get; set; }

        public BaseController()
        {
            hybridCache = new HybridCache();

            serviceScope = Startup.ApplicationServices.CreateScope();
            var scopeServiceProvider = serviceScope.ServiceProvider;
            memoryCache = scopeServiceProvider.GetService<IMemoryCache>();
        }

        #region mylocalip
        static string lastMyIp = null;

        async public ValueTask<string> mylocalip()
        {
            string key = "BaseController:mylocalip";
            if (!memoryCache.TryGetValue(key, out string userIp))
            {
                userIp = await InvkEvent.MyLocalIp(new EventMyLocalIp(requestInfo, HttpContext.Request, HttpContext, hybridCache));

                if (string.IsNullOrEmpty(userIp))
                {
                    var myip = await Http.Get<JObject>("https://api.ipify.org/?format=json");
                    if (myip == null || string.IsNullOrEmpty(myip.Value<string>("ip")))
                        return lastMyIp;

                    userIp = myip.Value<string>("ip");
                    lastMyIp = userIp;
                }

                memoryCache.Set(key, userIp, DateTime.Now.AddMinutes(5));
            }

            return userIp;
        }
        #endregion

        #region httpHeaders
        public List<HeadersModel> httpHeaders(BaseSettings init, List<HeadersModel> _startHeaders = null)
        {
            var headers = HeadersModel.Init(_startHeaders);
            if (init.headers == null)
                return headers;

            return httpHeaders(init.host, HeadersModel.Join(HeadersModel.Init(init.headers), headers));
        }

        public List<HeadersModel> httpHeaders(string site, Dictionary<string, string> headers)
        {
            return httpHeaders(site, HeadersModel.Init(headers));
        }

        public List<HeadersModel> httpHeaders(string site, List<HeadersModel> _headers)
        {
            if (_headers == null || _headers.Count == 0)
                return _headers;

            var headers = new List<HeadersModel>(_headers.Count);

            string ip = requestInfo.IP;
            string account_email = HttpContext.Request.Query["account_email"].ToString()?.ToLower().Trim() ?? string.Empty;

            foreach (var h in _headers)
            {
                if (string.IsNullOrEmpty(h.val) || string.IsNullOrEmpty(h.name))
                    continue;

                var bulder = new StringBuilder(h.val)
                   .Replace("{account_email}", account_email)
                   .Replace("{ip}", ip)
                   .Replace("{host}", site);

                string val = bulder.ToString();

                if (val.StartsWith("encrypt:"))
                {
                    string encrypt = Regex.Match(val, "^encrypt:([^\n\r]+)").Groups[1].Value;
                    val = new OnlinesSettings(null, encrypt).host;
                }

                if (val.Contains("{arg:"))
                {
                    foreach (Match m in Regex.Matches(val, "\\{arg:([^\\}]+)\\}"))
                    {
                        string _a = Regex.Match(HttpContext.Request.QueryString.Value, $"&{m.Groups[1].Value}=([^&]+)").Groups[1].Value;
                        val = val.Replace(m.Groups[0].Value, _a);
                    }
                }

                if (val.Contains("{head:"))
                {
                    foreach (Match m in Regex.Matches(val, "\\{head:([^\\}]+)\\}"))
                    {
                        if (HttpContext.Request.Headers.TryGetValue(m.Groups[1].Value, out var _h))
                        {
                            val = val.Replace(m.Groups[0].Value, string.Join(" ", _h.ToString()));
                        }
                        else
                        {
                            val = val.Replace(m.Groups[0].Value, string.Empty);
                        }

                        string _a = Regex.Match(HttpContext.Request.QueryString.Value, $"&{m.Groups[1].Value}=([^&]+)").Groups[1].Value;
                        val = val.Replace(m.Groups[0].Value, _a);
                    }
                }

                if (headers.FirstOrDefault(i => i.name == h.name) == null)
                    headers.Add(new HeadersModel(h.name, val));
            }

            var eventHeaders = InvkEvent.HttpHeaders(new EventControllerHttpHeaders(site, headers, requestInfo, HttpContext.Request, HttpContext));
            if (eventHeaders != null)
                headers = eventHeaders;

            return headers;
        }
        #endregion

        #region HostImgProxy
        public string HostImgProxy(string uri, int height = 0, List<HeadersModel> headers = null, string plugin = null)
        {
            if (!AppInit.conf.sisi.rsize || string.IsNullOrWhiteSpace(uri)) 
                return uri;

            var init = AppInit.conf.sisi;
            int width = init.widthPicture;
            height = height > 0 ? height : init.heightPicture;

            string goEncryptUri(string _uri)
            {
                string encrypt_uri = ProxyLink.Encrypt(_uri, requestInfo.IP, headers, verifyip: false, ex: DateTime.Now.AddMinutes(20));
                if (AppInit.conf.accsdb.enable && !AppInit.conf.serverproxy.encrypt)
                    encrypt_uri = AccsDbInvk.Args(encrypt_uri, HttpContext);

                return encrypt_uri;
            }

            if (plugin != null && init.proxyimg_disable != null && init.proxyimg_disable.Contains(plugin))
                return uri;

            if (width == 0 && height == 0 || plugin != null && init.rsize_disable != null && init.rsize_disable.Contains(plugin))
            {
                if (!string.IsNullOrEmpty(init.bypass_host))
                {
                    string sheme = uri.StartsWith("https:") ? "https" : "http";
                    string bypass_host = init.bypass_host.Replace("{sheme}", sheme).Replace("{uri}", Regex.Replace(uri, "^https?://", ""));

                    if (bypass_host.Contains("{encrypt_uri}"))
                        bypass_host = bypass_host.Replace("{encrypt_uri}", goEncryptUri(uri));

                    return bypass_host;
                }

                return $"{host}/proxyimg/{goEncryptUri(uri)}";
            }

            if (!string.IsNullOrEmpty(init.rsize_host))
            {
                string sheme = uri.StartsWith("https:") ? "https" : "http";
                string rsize_host = init.rsize_host.Replace("{width}", width.ToString()).Replace("{height}", height.ToString())
                                                   .Replace("{sheme}", sheme).Replace("{uri}", Regex.Replace(uri, "^https?://", ""));

                if (rsize_host.Contains("{encrypt_uri}"))
                    rsize_host = rsize_host.Replace("{encrypt_uri}", goEncryptUri(uri));

                return rsize_host;
            }

            return $"{host}/proxyimg:{width}:{height}/{goEncryptUri(uri)}";
        }
        #endregion

        #region HostStreamProxy
        public string HostStreamProxy(BaseSettings conf, string uri, List<HeadersModel> headers = null, WebProxy proxy = null, bool force_streamproxy = false)
        {
            if (!AppInit.conf.serverproxy.enable || string.IsNullOrEmpty(uri) || conf == null)
                return uri?.Split(" ")?[0]?.Trim();

            string _eventUri = InvkEvent.HostStreamProxy(new EventHostStreamProxy(conf, uri, headers, proxy, requestInfo, HttpContext, hybridCache));
            if (_eventUri != null)
                return _eventUri;

            if (conf.rhub && !conf.rhub_streamproxy)
                return uri.Split(" ")[0].Trim();

            bool streamproxy = conf.streamproxy || conf.useproxystream || force_streamproxy;
            if (!streamproxy && conf.geostreamproxy != null && conf.geostreamproxy.Length > 0)
            {
                string country = requestInfo.Country;
                if (!string.IsNullOrEmpty(country) && country.Length == 2)
                {
                    if (conf.geostreamproxy.Contains("ALL") || conf.geostreamproxy.Contains(country))
                        streamproxy = true;
                }
            }

            if (streamproxy)
            {
                if (conf.headers_stream != null && conf.headers_stream.Count > 0)
                    headers = HeadersModel.Init(conf.headers_stream);

                #region apnstream
                string apnlink(ApnConf apn)
                {
                    string link = uri.Split(" ")[0].Split("#")[0].Trim();

                    if (apn.secure == "nginx")
                    {
                        using (MD5 md5 = MD5.Create())
                        {
                            long ex = ((DateTimeOffset)DateTime.Now.AddHours(12)).ToUnixTimeSeconds();
                            string hash = Convert.ToBase64String(md5.ComputeHash(Encoding.UTF8.GetBytes($"{ex}{requestInfo.IP} {apn.secret}"))).Replace("=", "").Replace("+", "-").Replace("/", "_");

                            return $"{apn.host}/{hash}:{ex}/{link}";
                        }
                    }
                    else if (apn.secure == "cf")
                    {
                        using (var sha1 = SHA1.Create())
                        {
                            var data = Encoding.UTF8.GetBytes($"{requestInfo.IP}{link}{apn.secret}");
                            return Convert.ToBase64String(sha1.ComputeHash(data));
                        }
                    }
                    else if (apn.secure == "lampac")
                    {
                        string aes = AesTo.Encrypt(System.Text.Json.JsonSerializer.Serialize(new 
                        {
                            u = link,
                            i = requestInfo.IP,
                            v = true,
                            e = DateTime.Now.AddHours(36),
                            h = headers?.ToDictionary() 
                        }));

                        if (uri.Contains(".m3u"))
                            aes += ".m3u8";

                        return $"{apn.host}/proxy/{aes}";
                    }

                    return $"{apn.host}/{link}";
                }

                if (!string.IsNullOrEmpty(conf.apn?.host) && conf.apn.host.StartsWith("http"))
                    return apnlink(conf.apn);

                if (AppInit.conf.serverproxy.forced_apn || conf.apnstream)
                {
                    if (!string.IsNullOrEmpty(AppInit.conf?.apn?.host) && AppInit.conf.apn.host.StartsWith("http"))
                        return apnlink(AppInit.conf.apn);

                    return uri;
                }  
                #endregion

                uri = ProxyLink.Encrypt(uri, requestInfo.IP, httpHeaders(conf.host ?? conf.apihost, headers), conf != null && conf.useproxystream ? proxy : null, conf?.plugin);

                if (AppInit.conf.accsdb.enable && !AppInit.conf.serverproxy.encrypt)
                    uri = AccsDbInvk.Args(uri, HttpContext);

                return $"{host}/proxy/{uri}";
            }

            if (conf.url_reserve && !uri.Contains(" or ") && !uri.Contains("/proxy/") &&
                !Regex.IsMatch(HttpContext.Request.QueryString.Value, "&play=true", RegexOptions.IgnoreCase))
            {
                string url_reserve = ProxyLink.Encrypt(uri, requestInfo.IP, httpHeaders(conf.host ?? conf.apihost, headers), conf != null && conf.useproxystream ? proxy : null, conf?.plugin);

                if (AppInit.conf.accsdb.enable && !AppInit.conf.serverproxy.encrypt)
                    url_reserve = AccsDbInvk.Args(uri, HttpContext);

                uri += $" or {host}/proxy/{url_reserve}";
            }

            return uri;
        }
        #endregion

        #region InvokeCache
        public ValueTask<CacheResult<T>> InvokeCache<T>(string key, TimeSpan time, Func<CacheResult<T>, ValueTask<dynamic>> onget) => InvokeCache(key, time, null, onget);

        async public ValueTask<CacheResult<T>> InvokeCache<T>(string key, TimeSpan time, ProxyManager proxyManager, Func<CacheResult<T>, ValueTask<dynamic>> onget, bool? memory = null)
        {
            var semaphore = new SemaphorManager(key, TimeSpan.FromSeconds(40));

            try
            {
                await semaphore.WaitAsync();

                if (hybridCache.TryGetValue(key, out T _val, memory))
                {
                    HttpContext.Response.Headers.TryAdd("X-Invoke-Cache", "HIT");
                    return new CacheResult<T>() { IsSuccess = true, Value = _val };
                }

                HttpContext.Response.Headers.TryAdd("X-Invoke-Cache", "MISS");

                var val = await onget.Invoke(new CacheResult<T>());

                if (val == null)
                    return new CacheResult<T>() { IsSuccess = false, ErrorMsg = "null" };

                if (val.GetType() == typeof(CacheResult<T>))
                    return (CacheResult<T>)val;

                if (val.Equals(default(T)))
                    return new CacheResult<T>() { IsSuccess = false, ErrorMsg = "default" };

                if (typeof(T) == typeof(string) && string.IsNullOrEmpty(val.ToString()))
                    return new CacheResult<T>() { IsSuccess = false, ErrorMsg = "empty" };

                proxyManager?.Success();
                hybridCache.Set(key, val, time, memory);
                return new CacheResult<T>() { IsSuccess = true, Value = val };
            }
            finally
            {
                semaphore.Release();
            }
        }

        async public ValueTask<T> InvokeCache<T>(string key, TimeSpan time, Func<ValueTask<T>> onget, ProxyManager proxyManager = null, bool? memory = null)
        {
            var semaphore = new SemaphorManager(key, TimeSpan.FromSeconds(40));

            try
            {
                await semaphore.WaitAsync();

                if (hybridCache.TryGetValue(key, out T val, memory))
                    return val;

                val = await onget.Invoke();
                if (val == null || val.Equals(default(T)))
                    return default;

                proxyManager?.Success();
                hybridCache.Set(key, val, time, memory);
                return val;
            }
            finally
            {
                semaphore.Release();
            }
        }
        #endregion

        #region InvkSemaphore
        async public Task<ActionResult> InvkSemaphore(BaseSettings init, string key, Func<ValueTask<ActionResult>> func)
        {
            if (init != null)
            {
                if (init.rhub && init.rhub_fallback == false)
                    return await func.Invoke();
            }

            var semaphore = new SemaphorManager(key, TimeSpan.FromSeconds(40));

            try
            {
                await semaphore.WaitAsync();
                return await func.Invoke();
            }
            finally
            {
                semaphore.Release();
            }
        }
        #endregion

        #region cacheTime
        public TimeSpan cacheTime(int multiaccess, int home = 5, int mikrotik = 2, BaseSettings init = null, int rhub = -1)
        {
            if (init != null && init.rhub && rhub != -1)
                return TimeSpan.FromMinutes(rhub);

            int ctime = AppInit.conf.mikrotik ? mikrotik : AppInit.conf.multiaccess ? init != null && init.cache_time > 0 ? init.cache_time : multiaccess : home;
            if (ctime > multiaccess)
                ctime = multiaccess;

            return TimeSpan.FromMinutes(ctime);
        }
        #endregion

        #region IsCacheError
        public bool IsCacheError(BaseSettings init)
        {
            if (!AppInit.conf.multiaccess || init.rhub)
                return false;

            if (memoryCache.TryGetValue(ResponseCache.ErrorKey(HttpContext), out object errorCache))
            {
                HttpContext.Response.Headers.TryAdd("X-RCache", "true");

                if (errorCache is OnErrorResult)
                {
                    badInitMsg = Json(errorCache);
                    return true;
                }
                else if (errorCache is string)
                {
                    string msg = errorCache.ToString();
                }

                badInitMsg = Ok();
                return true;
            }

            return false;
        }
        #endregion

        #region IsOverridehost
        async public ValueTask<ActionResult> IsOverridehost(BaseSettings init)
        {
            string overridehost = null;

            if (!string.IsNullOrEmpty(init.overridehost))
                overridehost = init.overridehost;

            if (string.IsNullOrEmpty(overridehost) && init.overridehosts != null && init.overridehosts.Length > 0)
                overridehost = init.overridehosts[Random.Shared.Next(0, init.overridehosts.Length)];

            if (string.IsNullOrEmpty(overridehost))
                return null;

            if (string.IsNullOrEmpty(init.overridepasswd))
            {
                if (overridehost.Contains("?"))
                    overridehost += "&" + HttpContext.Request.QueryString.Value.Remove(0, 1);
                else
                    overridehost += HttpContext.Request.QueryString.Value;

                return new RedirectResult(overridehost);
            }

            overridehost = Regex.Replace(overridehost, "^(https?://[^/]+)/.*", "$1");
            string uri = overridehost + HttpContext.Request.Path.Value + HttpContext.Request.QueryString.Value;

            string clientip = requestInfo.IP;
            if (requestInfo.Country == null)
                clientip = await mylocalip();

            string html = await Http.Get(uri, timeoutSeconds: 10, headers: HeadersModel.Init
            (
                ("localrequest", init.overridepasswd),
                ("x-client-ip", clientip)
            ));

            if (html == null)
                return new ContentResult() { StatusCode = 502, Content = string.Empty };

            html = Regex.Replace(html, "\"(https?://[^/]+/proxy/)", "\"_tmp_ $1");
            html = Regex.Replace(html, $"\"{overridehost}", $"\"{host}");
            html = html.Replace("\"_tmp_ ", "\"");

            return ContentTo(html);
        }
        #endregion

        #region NoAccessGroup
        public bool NoAccessGroup(Igroup init, out string error_msg)
        {
            error_msg = null;

            if (init.group > 0)
            {
                var user = requestInfo.user;
                if (user == null || init.group > user.group)
                {
                    error_msg = AppInit.conf.accsdb.denyGroupMesage.
                                Replace("{account_email}", requestInfo.user_uid).
                                Replace("{user_uid}", requestInfo.user_uid);

                    return true;
                }
            }

            return false;
        }
        #endregion

        #region accsArgs
        public string accsArgs(string uri)
        {
            return AccsDbInvk.Args(uri, HttpContext);
        }
        #endregion

        #region loadKit
        public bool IsKitConf { get; private set; }

        async public ValueTask<JObject> loadKitConf()
        {
            var init = AppInit.conf.kit;
            if (!init.enable || string.IsNullOrEmpty(init.path) || string.IsNullOrEmpty(requestInfo.user_uid))
                return null;

            if (init.IsAllUsersPath)
            {
                if (init.allUsers != null && init.allUsers.TryGetValue(requestInfo.user_uid, out JObject userInit))
                    return userInit;

                return null;
            }
            else
            {
                string memKey = $"loadKit:{requestInfo.user_uid}";
                if (!memoryCache.TryGetValue(memKey, out JObject appinit))
                {
                    string json;

                    if (Regex.IsMatch(init.path, "^https?://"))
                    {
                        string uri = init.path.Replace("{uid}", HttpUtility.UrlEncode(requestInfo.user_uid));
                        json = await Http.Get(uri, timeoutSeconds: 5);
                    }
                    else
                    {
                        string init_file = $"{init.path}/{CrypTo.md5(requestInfo.user_uid)}";

                        if (init.eval_path != null)
                            init_file = CSharpEval.Execute<string>(init.eval_path, new KitConfEvalPath(init.path, requestInfo.user_uid));
                       
                        if (!IO.File.Exists(init_file))
                            return null;

                        json = IO.File.ReadAllText(init_file);
                    }

                    if (json == null)
                        return null;

                    try
                    {
                        if (!json.TrimStart().StartsWith("{"))
                            json = "{" + json + "}";

                        appinit = JsonConvert.DeserializeObject<JObject>(json);
                    }
                    catch { return null; }

                    memoryCache.Set(memKey, appinit, DateTime.Now.AddSeconds(Math.Max(5, init.cacheToSeconds)));
                }

                return appinit;
            }
        }

        async public ValueTask<T> loadKit<T>(T _init, Func<JObject, T, T, T> func = null) where T : BaseSettings, ICloneable
        {
            if (_init.kit == false && _init.rhub_fallback == false)
                return (T)_init.Clone();

            return loadKit((T)_init.Clone(), await loadKitConf(), func, clone: false);
        }

        public T loadKit<T>(T _init, JObject appinit, Func<JObject, T, T, T> func = null, bool clone = true) where T : BaseSettings, ICloneable
        {
            var init = clone ? (T)_init.Clone() : _init;
            var defaultinit = InvkEvent.conf.LoadKit != null ? (clone ? _init : (T)_init.Clone()) : null;

            InvkEvent.LoadKitInit(new EventLoadKit(defaultinit, init, appinit, requestInfo, hybridCache));

            if (init == null || !init.kit || appinit == null || string.IsNullOrEmpty(init.plugin) || !appinit.ContainsKey(init.plugin))
            {
                InvkEvent.LoadKit(new EventLoadKit(defaultinit, init, appinit, requestInfo, hybridCache));
                return init;
            }

            var conf = appinit.Value<JObject>(init.plugin);

            void update<T2>(string key, Action<T2> updateAction)
            {
                if (conf.ContainsKey(key))
                    updateAction(conf.Value<T2>(key));
            }

            update<bool>("enable", v => init.enable = v);
            if (conf.ContainsKey("enable") && init.enable)
                init.geo_hide = null;

            update<string>("displayname", v => init.displayname = v);
            update<int>("displayindex", v => init.displayindex = v);
            update<string>("client_type", v => init.client_type = v);

            update<string>("cookie", v => init.cookie = v);
            update<string>("token", v => init.token = v);

            update<string>("host", v => init.host = v);
            update<string>("apihost", v => init.apihost = v);
            update<string>("scheme", v => init.scheme = v);
            update<bool>("hls", v => init.hls = v);

            update<string>("overridehost", v => init.overridehost = v);
            update<string>("overridepasswd", v => init.overridepasswd = v);
            if (conf.ContainsKey("overridehosts"))
                init.overridehosts = conf["overridehosts"].ToObject<string[]>();

            if (conf.ContainsKey("headers"))
                init.headers = conf["headers"].ToObject<Dictionary<string, string>>();

            init.apnstream = true;
            if (conf.ContainsKey("apn"))
                init.apn = conf["apn"].ToObject<ApnConf>();

            init.useproxystream = false;
            update<bool>("streamproxy", v => init.streamproxy = v);
            if (conf.ContainsKey("geostreamproxy"))
                init.geostreamproxy = conf["geostreamproxy"].ToObject<string[]>();

            if (conf.ContainsKey("proxy"))
            {
                init.proxy = conf["proxy"].ToObject<ProxySettings>();
                if (init?.proxy?.list != null && init.proxy.list.Length > 0)
                    update<bool>("useproxy", v => init.useproxy = v);
            }

            if (init.useproxy)
            {
                init.rhub = false;
                init.rhub_fallback = true;
            }
            else if (AppInit.conf.kit.rhub_fallback || init.rhub_fallback)
            {
                update<bool>("rhub", v => init.rhub = v);
                update<bool>("rhub_fallback", v => init.rhub_fallback = v);
            }
            else
            {
                init.rhub = true;
                init.rhub_fallback = true;
            }

            if (init.rhub)
                update<int>("cache_time", v => init.cache_time = v);

            IsKitConf = true;

            InvkEvent.LoadKit(new EventLoadKit(defaultinit, init, conf, requestInfo, hybridCache));

            if (func != null)
                return func.Invoke(conf, init, conf.ToObject<T>());

            return init;
        }
        #endregion

        #region RedirectToPlay
        public RedirectResult RedirectToPlay(string url)
        {
            if (!url.Contains(" "))
                return new RedirectResult(url);

            return new RedirectResult(url.Split(" ")[0].Trim());
        }
        #endregion

        #region ContentTo / Dispose
        public ActionResult ContentTo(in string html)
        {
            return Content(html, html.StartsWith("{") || html.StartsWith("[") ? "application/json; charset=utf-8" : "text/html; charset=utf-8");
        }

        public new void Dispose()
        {
            serviceScope?.Dispose();
            base.Dispose();
        }
        #endregion
    }
}

```

## File: Shared/Models/HeadersModel.cs
```
Ôªønamespace Shared.Models
{
    public class HeadersModel
    {
        public HeadersModel(string name, string val)
        {
            this.name = name;
            this.val = val;
        }

        public string name { get; set; }

        public string val { get; set; }


        #region Init
        public static List<HeadersModel> Init(string name, string val)
        {
            return new List<HeadersModel>() { new HeadersModel(name, val)};
        }

        public static List<HeadersModel> Init(List<HeadersModel> headers)
        {
            return headers ?? new List<HeadersModel>();
        }

        public static List<HeadersModel> Init(params (string name, string val)[] headers)
        {
            var h = new List<HeadersModel>(headers.Count());

            foreach (var i in headers)
                h.Add(new HeadersModel(i.name, i.val));

            return h;
        }

        public static List<HeadersModel> Init(Dictionary<string, string> defaultHeaders, params (string name, string val)[] headers)
        {
            return Join(Init(headers), defaultHeaders);
        }

        public static List<HeadersModel> Init(IEnumerable<KeyValuePair<string, string>> headers)
        {
            if (headers == null || headers.Count() == 0)
                return new List<HeadersModel>();

            var h = new List<HeadersModel>(headers.Count());

            foreach (var i in headers)
                h.Add(new HeadersModel(i.Key, i.Value));

            return h;
        }
        #endregion

        #region Join
        public static List<HeadersModel> Join(List<HeadersModel> h1, List<HeadersModel> h2)
        {
            if (h1 == null)
                return h2 ?? new List<HeadersModel>();

            if (h2 == null)
                return h1 ?? new List<HeadersModel>();

            var result = new List<HeadersModel>(h1);
            result.AddRange(h2);

            return result;
        }

        public static List<HeadersModel> Join(List<HeadersModel> h1, Dictionary<string, string> h2)
        {
            if (h1 == null)
            {
                if (h2 == null)
                    return new List<HeadersModel>();

                return Init(h2);
            }

            if (h2 == null)
                return h1 ?? new List<HeadersModel>();

            var result = new List<HeadersModel>(h1);
            foreach (var _h2 in h2)
                result.Add(new HeadersModel(_h2.Key, _h2.Value));

            return result;
        }
        #endregion
    }
}

```

## File: Shared/Models/RequestModel.cs
```
Ôªøusing Shared.Engine;
using Shared.Models.Base;

namespace Shared.Models
{
    public struct RequestModel
    {
        public RequestModel()
        {
        }

        public bool IsLocalRequest { get; set; }

        public bool IsAnonymousRequest { get; set; }

        public string IP { get; set; }

        public string Path { get; set; }

        public string Query { get; set; }

        public string UserAgent { get; set; }

        #region Country
        private string _countryCode = null;
        public string Country
        {
            get
            {
                if (_countryCode == string.Empty)
                    return null;

                if (_countryCode != null)
                    return _countryCode;

                _countryCode = GeoIP2.Country(IP);
                if (_countryCode == null)
                {
                    _countryCode = string.Empty;
                    return null;
                }

                return _countryCode;
            }
            set
            {
                if (!string.IsNullOrEmpty(value))
                    _countryCode = value;
            }
        }
        #endregion

        public AccsUser user { get; set; }

        public string user_uid { get; set; }

        public Dictionary<string, object> @params { get; set; }
    }
}

```

## File: Shared/Models/AsyncManualResetEvent.cs
```
Ôªøusing System.Threading;

namespace Shared.Models
{
    public class AsyncManualResetEvent
    {
        private volatile TaskCompletionSource<bool> tcs = new TaskCompletionSource<bool>();

        public Task WaitAsync()
        {
            return tcs.Task;
        }

        async public ValueTask WaitAsync(int millisecondsTimeout)
        {
            try
            {
                await tcs.Task.WaitAsync(TimeSpan.FromMilliseconds(millisecondsTimeout));
            }
            catch { }
        }

        async public ValueTask WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken)
        {
            try
            {
                await tcs.Task.WaitAsync(TimeSpan.FromMilliseconds(millisecondsTimeout), cancellationToken);
            }
            catch { }
        }

        public void Set()
        {
            var currentTcs = tcs;
            if (Interlocked.CompareExchange(ref tcs, new TaskCompletionSource<bool>(), currentTcs) == currentTcs)
            {
                currentTcs.SetResult(true);
            }
        }

        //public void Reset()
        //{
        //    while (true)
        //    {
        //        var currentTcs = tcs;
        //        if (!currentTcs.Task.IsCompleted ||
        //            Interlocked.CompareExchange(ref tcs, currentTcs, null) == null)
        //        {
        //            return;
        //        }
        //    }
        //}
    }
}

```

## File: Shared/Models/CacheResult.cs
```
Ôªønamespace Shared.Models
{
    public class CacheResult<T>
    {
        public bool IsSuccess { get; set; }

        public string ErrorMsg { get; set; }

        public T Value { get; set; }


        public CacheResult<T> Fail(string msg)
        {
            return new CacheResult<T>() { IsSuccess = false, ErrorMsg = msg };
        }
    }
}

```

## File: Shared/Models/INws.cs
```
using System.Collections.Concurrent;
using System.Net.WebSockets;
using System.Threading;

namespace Shared.Models
{
    public interface INws
    {
        ConcurrentDictionary<string, NwsConnection> AllConnections();

        void WebLog(string message, string plugin);

        Task EventsAsync(string connectionId, string uid, string name, string data);

        Task SendAsync(string connectionId, string method, params object[] args);
    }

    public class NwsConnection : IDisposable
    {
        public NwsConnection(string connectionId, WebSocket socket, string host, string ip, string userAgent)
        {
            ConnectionId = connectionId;
            Socket = socket;
            Host = host;
            Ip = ip;
            UserAgent = userAgent;
            SendLock = new SemaphoreSlim(1, 1);
            UpdateActivity();
        }

        public string ConnectionId { get; }

        public WebSocket Socket { get; }

        public string Host { get; }

        public string Ip { get; }

        public string UserAgent { get; }

        public SemaphoreSlim SendLock { get; }

        long _lastActivityTicks;

        CancellationTokenSource _cancellationSource;

        public DateTime LastActivityUtc
        {
            get
            {
                long ticks = Interlocked.Read(ref _lastActivityTicks);
                return new DateTime(ticks, DateTimeKind.Utc);
            }
        }

        public void UpdateActivity()
        {
            Interlocked.Exchange(ref _lastActivityTicks, DateTime.UtcNow.Ticks);
        }

        public void SetCancellationSource(CancellationTokenSource source)
        {
            var previous = Interlocked.Exchange(ref _cancellationSource, source);
            previous?.Dispose();
        }

        public void Cancel()
        {
            var source = Interlocked.CompareExchange(ref _cancellationSource, null, null);
            if (source == null)
                return;

            try
            {
                source.Cancel();
            }
            catch (ObjectDisposedException)
            {
            }
        }

        public void Dispose()
        {
            SendLock.Dispose();
            Interlocked.Exchange(ref _cancellationSource, null)?.Dispose();
        }
    }
}

```

## File: Shared/Models/ISoks.cs
```
Ôªøusing Microsoft.AspNetCore.SignalR;

namespace Shared.Models
{
    public interface ISoks
    {
        IHubCallerClients AllClients { get; }

        void WebLog(string message, string plugin);

        Task EventsAsync(string connectionId, string uid, string name, string data);
    }
}

```

## File: Shared/Models/Proxy/ProxyLinkModel.cs
```
Ôªøusing System.Net;
using System.Text.Json.Serialization;

namespace Shared.Models.Proxy
{
    public class ProxyLinkModel
    {
        public ProxyLinkModel() 
        { 
            ex = DateTime.Now.AddHours(AppInit.conf.mikrotik ? 4 : 20);
        }

        public ProxyLinkModel(string reqip, List<HeadersModel> headers, WebProxy proxy, string uri, string plugin = null, bool verifyip = true, DateTime ex = default)
        {
            this.ex = ex;
            this.reqip = reqip;
            this.headers = headers;
            this.proxy = proxy;
            this.uri = uri;
            this.plugin = plugin;
            this.verifyip = verifyip;

            if (this.ex == default)
                this.ex = DateTime.Now.AddHours(AppInit.conf.mikrotik ? 4 : 20);
        }

        [JsonIgnore]
        public string id { get; set; }

        [JsonIgnore]
        public DateTime ex { get; set; }

        public string reqip { get; set; }

        public List<HeadersModel> headers { get; set; }

        [JsonIgnore]
        public WebProxy proxy { get; set; }

        public string uri { get; set; }

        public string plugin { get; set; }

        public bool verifyip { get; set; }
    }
}

```

## File: Shared/Models/Proxy/ProxyManagerModel.cs
```
Ôªønamespace Shared.Models.Proxy
{
    public class ProxyManagerModel
    {
        public string proxyip { get; set; }

        public int errors { get; set; }
    }
}

```

## File: Shared/Models/SISI/User.cs
```
Ôªøusing LiteDB;
using Shared.Models.SISI.Base;

namespace Shared.Models.SISI
{
    public class User
    {
        [BsonId]
        public string Id { get; set; }

        public List<PlaylistItem> Bookmarks { get; set; } = new();
    }
}

```

## File: Shared/Models/SISI/Xvideos.cs
```
Ôªønamespace Shared.Models.SISI.Xvideos
{
    public struct Related
    {
        public string u { get; set; }

        public string i { get; set; }

        public string d { get; set; }

        public string @if { get; set; }

        public string tf { get; set; }


        public string pn { get; set; }

        public string p { get; set; }

        public bool ch { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/ModelParse.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class ModelParse
    {
        public SingleNodeSettings name { get; set; }

        public SingleNodeSettings href { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/RouteSettings.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class RouteSettings
    {
        public string eval { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/ContentParseSettings.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class ContentParseSettings
    {
        public string nodes { get; set; }

        public SingleNodeSettings name { get; set; }

        public SingleNodeSettings href { get; set; }

        public SingleNodeSettings img { get; set; }

        public SingleNodeSettings duration { get; set; }

        public SingleNodeSettings quality { get; set; }

        public SingleNodeSettings preview { get; set; }

        public ModelParse model { get; set; }

        public List<ContentParseArg> args { get; set; }

        public bool json { get; set; } = true;

        public string eval { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/MenuSettings.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class MenuSettings
    {
        public bool bind { get; set; } = true;

        public Dictionary<string, string> route { get; set; }

        public Dictionary<string, string> sort { get; set; }

        public Dictionary<string, string> categories { get; set; }

        public string formatcat(string cat)
        {
            if (categories != null && categories.TryGetValue("format", out string format))
                return format.Replace("{cat}", cat);

            return cat;
        }

        public List<CustomCategories> customs { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/CustomCategories.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class CustomCategories
    {
        public string name { get; set; }

        public string arg { get; set; }

        public string format { get; set; }

        public Dictionary<string, string> submenu { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/NxtSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.SISI.NextHUB
{
    public class NxtSettings : BaseSettings, ICloneable
    {
        public NxtSettings()
        {
            cache_time = 5;
        }

        public bool debug { get; set; }

        public int timeout { get; set; } = 10;

        public bool streamproxy_preview { get; set; }

        public bool ignore_no_picture { get; set; } = true;

        public bool abortMedia { get; set; } = true;

        public bool fullCacheJS { get; set; } = true;

        public bool keepopen { get; set; } = true;

        public List<Microsoft.Playwright.Cookie> cookies { get; set; }

        public RouteSettings route { get; set; }

        public MenuSettings menu { get; set; }

        public ListSettings list { get; set; }

        public ListSettings search { get; set; }

        public ListSettings model { get; set; }

        public ContentParseSettings contentParse { get; set; }

        public ViewSettings view { get; set; }


        public NxtSettings Clone()
        {
            return (NxtSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/SISI/NextHUB/SingleNodeSettings.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class SingleNodeSettings
    {
        public string node { get; set; }

        public string attribute { get; set; }

        public string[] attributes { get; set; }

        public string format { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/ViewSettings.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class ViewSettings
    {
        public string initUrlEval { get; set; }

        public string addInitScript { get; set; }

        public string routeEval { get; set; }

        public string eval { get; set; }

        public string evalJS { get; set; }

        public string playbtn { get; set; }

        public string waitForSelector { get; set; }

        public float waitForSelector_timeout { get; set; } = 5000;

        public string patternFile { get; set; }

        public bool waitLocationFile { get; set; }

        public bool waitForResponse { get; set; }

        public RegexMatchSettings iframe { get; set; }

        public SingleNodeSettings nodeFile { get; set; }

        public RegexMatchSettings regexMatch { get; set; }

        public bool bindingToIP { get; set; }

        public bool fullCacheJS { get; set; } = true;

        public bool abortMedia { get; set; } = true;

        public string patternAbort { get; set; }

        public string patternAbortEnd { get; set; }

        public string patternWhiteRequest { get; set; }

        public bool related { get; set; }

        public ContentParseSettings relatedParse { get; set; }

        public bool NetworkIdle { get; set; }

        public int cache_time { get; set; } = 15;


        public bool viewsource { get; set; }

        public string priorityBrowser { get; set; }

        public bool keepopen { get; set; } = true;
    }
}

```

## File: Shared/Models/SISI/NextHUB/RegexMatchSettings.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class RegexMatchSettings
    {
        public string pattern { get; set; }

        public int index { get; set; } = 1;

        public string format { get; set; }

        public string[] matches { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/ContentParseArg.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class ContentParseArg : SingleNodeSettings
    {
        public string name { get; set; }
    }
}

```

## File: Shared/Models/SISI/NextHUB/ListSettings.cs
```
Ôªønamespace Shared.Models.SISI.NextHUB
{
    public class ListSettings
    {
        public int total_pages { get; set; } = 0;

        public string firstpage { get; set; }

        public string uri { get; set; }

        public string format { get; set; }

        public bool viewsource { get; set; } = true;

        public string waitForSelector { get; set; }

        public float waitForSelector_timeout { get; set; } = 5000;

        public string patternAbort { get; set; }

        public string routeEval { get; set; }

        public ContentParseSettings contentParse { get; set; }
    }
}

```

## File: Shared/Models/SISI/OnResult/OnListResult.cs
```
Ôªøusing Shared.Models.SISI.Base;

namespace Shared.Models.SISI.OnResult
{
    public struct OnListResult
    {
        public OnListResult(int listCount, int total_pages, IList<MenuItem> menu)
        {
            list = new OnResultPlaylistItem[listCount];
            this.total_pages = total_pages;
            this.menu = menu;
        }

        public IList<MenuItem> menu { get; set; }

        public int total_pages { get; set; }

        public OnResultPlaylistItem[] list { get; set; }
    }
}

```

## File: Shared/Models/SISI/OnResult/OnResultPlaylistItem.cs
```
Ôªøusing Shared.Models.SISI.Base;

namespace Shared.Models.SISI.OnResult
{
    public struct OnResultPlaylistItem
    {
        public string video { get; set; }

        public string name { get; set; }

        public string picture { get; set; }

        public string preview { get; set; }

        public string quality { get; set; }

        public string time { get; set; }

        public string myarg { get; set; }

        public bool json { get; set; }

        public bool hide { get; set; }

        public bool related { get; set; }

        public ModelItem model { get; set; }

        public Dictionary<string, string> qualitys { get; set; }

        public Bookmark bookmark { get; set; }
    }
}

```

## File: Shared/Models/SISI/OnResult/StreamItem.cs
```
Ôªøusing Shared.Models.SISI.Base;

namespace Shared.Models.SISI.OnResult
{
    public class StreamItem
    {
        public Dictionary<string, string> qualitys { get; set; }

        public Dictionary<string, string> qualitys_proxy { get; set; }

        public IList<PlaylistItem> recomends { get; set; }
    }
}

```

## File: Shared/Models/SISI/OnResult/OnStreamResult.cs
```
Ôªønamespace Shared.Models.SISI.OnResult
{
    public struct OnStreamResult
    {
        public OnStreamResult(int recomendsCount) 
        {
            recomends = new OnResultPlaylistItem[recomendsCount];
        }

        public Dictionary<string, string> qualitys { get; set; }

        public Dictionary<string, string> qualitys_proxy { get; set; }

        public Dictionary<string, string> headers_stream { get; set; }

        public OnResultPlaylistItem[] recomends { get; set; }
    }
}

```

## File: Shared/Models/SISI/OnResult/OnErrorResult.cs
```
Ôªønamespace Shared.Models.SISI.OnResult
{
    public struct OnErrorResult
    {
        public OnErrorResult(string msg)
        {
            this.msg = msg;
        }

        public bool error { get; set; } = true;

        public string msg { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/SisiSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.SISI.Base
{
    public class SisiSettings : BaseSettings, ICloneable
    {
        public SisiSettings(string plugin, string host, bool enable = true, bool useproxy = false, bool streamproxy = false)
        {
            this.enable = enable;
            this.plugin = plugin;
            this.useproxy = useproxy;
            this.streamproxy = streamproxy;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);
        }

        public SisiSettings Clone()
        {
            return (SisiSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/SISI/Base/HistoryConf.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public class HistoryConf
    {
        public bool enable { get; set; }

        public int days { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/PlaylistItem.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public class PlaylistItem
    {
        public string video { get; set; }

        public string name { get; set; }

        public string picture { get; set; }

        public string preview { get; set; }

        public string quality { get; set; }

        public string time { get; set; }

        public string myarg { get; set; }

        public bool json { get; set; }

        public bool hide { get; set; }

        public bool related { get; set; }

        public ModelItem model { get; set; }

        public Dictionary<string, string> qualitys { get; set; }

        public Bookmark bookmark { get; set; }

        public string history_uid { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/ModelItem.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public class ModelItem
    {
        public ModelItem() { }

        public ModelItem(string name, string uri)
        {
            this.uri = uri;
            this.name = name;
        }

        public string uri { get; set; }

        public string name { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/SisiConf.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public class SisiConf
    {
        public bool xdb { get; set; }

        public bool lgbt { get; set; }

        public bool NextHUB { get; set; }

        public string[] NextHUB_sites_enabled { get; set; }

        public bool rsize { get; set; }

        public string rsize_host { get; set; }

        public string bypass_host { get; set; }

        public string[] rsize_disable { get; set; }

        public string[] proxyimg_disable { get; set; }

        public int heightPicture { get; set; }

        public int widthPicture { get; set; }


        public bool spider { get; set; }

        public string component { get; set; }

        public string vipcontent { get; set; }

        public string iconame { get; set; }


        public bool push_all { get; set; }

        public bool forced_checkRchtype { get; set; }


        public BookmarksConf bookmarks { get; set; }

        public HistoryConf history { get; set; }


        public Dictionary<string, string> appReplace { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/BookmarksConf.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public class BookmarksConf
    {
        public bool saveimage { get; set; }

        public bool savepreview { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/ChannelItem.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public struct ChannelItem
    {
        public ChannelItem(string title, string playlist_url, int displayindex)
        {
            this.title = title;
            this.playlist_url = playlist_url;
            this.displayindex = displayindex;
        }

        public string title { get; set; }

        public string playlist_url { get; set; }

        public int displayindex { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/Bookmark.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public class Bookmark
    {
        public string uid { get; set; }

        public string site { get; set; }

        public string image { get; set; }

        public string href { get; set; }
    }
}

```

## File: Shared/Models/SISI/Base/MenuItem.cs
```
Ôªønamespace Shared.Models.SISI.Base
{
    public struct MenuItem
    {
        public MenuItem(string title, string playlist_url) 
        {
            this.title = title;
            this.playlist_url = playlist_url;
        }

        public string title { get; set; }

        public string search_on { get; set; }

        public string logo_30x30 { get; set; }

        public string playlist_url { get; set; }

        public List<MenuItem> submenu { get; set; }
    }
}

```

## File: Shared/Models/Module/SisiEventsModel.cs
```
Ôªønamespace Shared.Models.Module
{
    public class SisiEventsModel
    {
        public SisiEventsModel(string rchtype, string account_email, string uid, string token)
        {
            this.rchtype = rchtype;
            this.account_email = account_email;
            this.uid = uid;
            this.token = token;
        }

        public string rchtype { get; set; }
        public string account_email { get; set; }
        public string uid { get; set; }
        public string token { get; set; }
    }
}

```

## File: Shared/Models/Module/SisiMod.cs
```
Ôªønamespace Shared.Models.Module
{
    public class SisiMod
    {
        public bool enable { get; set; }

        public string name { get; set; }

        public string url { get; set; }
    }
}

```

## File: Shared/Models/Module/OnlineEventsModel.cs
```
Ôªønamespace Shared.Models.Module
{
    public class OnlineEventsModel
    {
        public OnlineEventsModel(string id, string imdb_id, long kinopoisk_id, string title, string original_title, string original_language, int year, string source, string rchtype, int serial, bool life, bool islite, string account_email, string uid, string token, string nws_id)
        {
            this.id = id;
            this.imdb_id = imdb_id;
            this.kinopoisk_id = kinopoisk_id;
            this.title = title;
            this.original_title = original_title;
            this.original_language = original_language;
            this.year = year;
            this.source = source;
            this.rchtype = rchtype;
            this.serial = serial;
            this.life = life;
            this.islite = islite;
            this.account_email = account_email;
            this.uid = uid;
            this.token = token;
            this.nws_id = nws_id;
        }

        public string id { get; set; }
        public string imdb_id { get; set; }
        public long kinopoisk_id { get; set; }
        public string title { get; set; }
        public string original_title { get; set; }
        public string original_language { get; set; }
        public int year { get; set; }
        public string source { get; set; }
        public string rchtype { get; set; }
        public int serial { get; set; }
        public bool life { get; set; }
        public bool islite { get; set; }
        public string account_email { get; set; }
        public string uid { get; set; }
        public string token { get; set; }
        public string nws_id { get; set; }
    }
}

```

## File: Shared/Models/Module/JacMod.cs
```
Ôªønamespace Shared.Models.Module
{
    public class JacMod
    {
        public bool enable { get; set; }

        public string @namespace { get; set; }
    }
}

```

## File: Shared/Models/Module/OnlineMod.cs
```
Ôªønamespace Shared.Models.Module
{
    public class OnlineMod
    {
        public bool enable { get; set; }

        public string @namespace { get; set; }
    }
}

```

## File: Shared/Models/Module/OnlineSpiderModel.cs
```
namespace Shared.Models.Module
{
    public class OnlineSpiderModel
    {
        public OnlineSpiderModel(string title, bool isanime)
        {
            this.title = title;
            this.isanime = isanime;
        }

        public string title { get; set; }
        public bool isanime { get; set; }
        public bool requireRhub { get; set; }
    }
}

```

## File: Shared/Models/Module/InitspaceModel.cs
```
Ôªøusing Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace Shared.Models.Module
{
    public class InitspaceModel
    {
        public string path { get; set; }

        public ISoks soks { get; set; }

        public INws nws { get; set; }

        public IMemoryCache memoryCache { get; set; }

        public IConfiguration configuration { get; set; }

        public IServiceCollection services { get; set; }

        public IApplicationBuilder app { get; set; }
    }
}

```

## File: Shared/Models/Module/InitializationModel.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Module
{
    public class InitializationModel
    {
        public InitializationModel(BaseSettings init, bool? rch)
        {
            this.init = init;
            this.rch = rch;
        }

        public BaseSettings init { get; set; }
        public bool? rch { get; set; }
    }
}

```

## File: Shared/Models/Module/RootModule.cs
```
Ôªøusing System.Reflection;

namespace Shared.Models.Module
{
    public class RootModule
    {
        public bool enable { get; set; }

        public bool dynamic { get; set; }

        public int index { get; set; }

        public int version { get; set; }

        public string dll { get; set; }

        public string[] references { get; set; }

        public Assembly assembly { get; set; }


        public string @namespace { get; set; }

        public string initspace { get; set; }

        public string middlewares { get; set; }

        public string online { get; set; }

        public string sisi { get; set; }

        public string initialization { get; set; }

        public List<JacMod> jac { get; set; } = new List<JacMod>();


        public string NamespacePath(string val)
        {
            if (version >= 3 && !string.IsNullOrEmpty(@namespace))
                return $"{@namespace}.{val}";

            return val;
        }
    }
}

```

## File: Shared/Models/Module/Entrys/SisiModuleEntry.cs
```
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Shared.Models.SISI.Base;

namespace Shared.Models.Module.Entrys
{
    public class SisiModuleEntry
    {
        public RootModule mod;

        // version >= 3
        public Func<HttpContext, IMemoryCache, RequestModel, string, SisiEventsModel, List<ChannelItem>> Invoke = null;
        public Func<HttpContext, IMemoryCache, RequestModel, string, SisiEventsModel, Task<List<ChannelItem>>> InvokeAsync = null;

        // version < 3
        public Func<string, List<ChannelItem>> Events = null;

        public static List<SisiModuleEntry> sisiModulesCache = null;
        static readonly object _sisiModulesCacheLock = new object();

        public static void EnsureCache(bool forced = false)
        {
            if (AppInit.modules == null)
                return;

            if (forced == false && sisiModulesCache != null)
                return;

            lock (_sisiModulesCacheLock)
            {
                if (forced == false && sisiModulesCache != null)
                    return;

                sisiModulesCache = new List<SisiModuleEntry>();

                try
                {
                    foreach (var mod in AppInit.modules.Where(i => i.sisi != null && i.enable))
                    {
                        try
                        {
                            var entry = new SisiModuleEntry() { mod = mod };

                            var assembly = mod.assembly;
                            if (assembly == null)
                                continue;

                            var type = assembly.GetType(mod.NamespacePath(mod.sisi));
                            if (type == null)
                                continue;

                            if (mod.version >= 3)
                            {
                                try
                                {
                                    var m = type.GetMethod("Invoke");
                                    if (m != null)
                                    {
                                        entry.Invoke = (Func<HttpContext, IMemoryCache, RequestModel, string, SisiEventsModel, List<ChannelItem>>)Delegate.CreateDelegate(
                                            typeof(Func<HttpContext, IMemoryCache, RequestModel, string, SisiEventsModel, List<ChannelItem>>), m);
                                    }
                                }
                                catch { }

                                try
                                {
                                    var m2 = type.GetMethod("InvokeAsync");
                                    if (m2 != null)
                                    {
                                        entry.InvokeAsync = (Func<HttpContext, IMemoryCache, RequestModel, string, SisiEventsModel, Task<List<ChannelItem>>>)Delegate.CreateDelegate(
                                            typeof(Func<HttpContext, IMemoryCache, RequestModel, string, SisiEventsModel, Task<List<ChannelItem>>>), m2);
                                    }
                                }
                                catch { }
                            }
                            else
                            {
                                try
                                {
                                    var m = type.GetMethod("Events");
                                    if (m != null)
                                    {
                                        entry.Events = (Func<string, List<ChannelItem>>)Delegate.CreateDelegate(
                                            typeof(Func<string, List<ChannelItem>>), m);
                                    }
                                }
                                catch { }
                            }

                            if (entry.Invoke != null || entry.InvokeAsync != null || entry.Events != null)
                                sisiModulesCache.Add(entry);
                        }
                        catch { }
                    }
                }
                catch { }
            }
        }
    }
}

```

## File: Shared/Models/Module/Entrys/MiddlewaresModuleEntry.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using System.Reflection;

namespace Shared.Models.Module.Entrys
{
    public class MiddlewaresModuleEntry
    {
        public RootModule mod;
        public Func<bool, HttpContext, IMemoryCache, bool> Invoke = null;
        public Func<bool, HttpContext, IMemoryCache, Task<bool>> InvokeAsync = null;
        public Func<HttpContext, IMemoryCache, bool> InvokeV1 = null;
        public Func<HttpContext, IMemoryCache, Task<bool>> InvokeAsyncV1 = null;


        public static List<MiddlewaresModuleEntry> middlewareModulesCache = null;
        static readonly object _middlewareModulesCacheLock = new object();

        public static void EnsureCache(bool forced = false)
        {
            if (AppInit.modules == null)
                return;

            if (forced == false && middlewareModulesCache != null)
                return;

            lock (_middlewareModulesCacheLock)
            {
                if (forced == false && middlewareModulesCache != null)
                    return;

                middlewareModulesCache = new List<MiddlewaresModuleEntry>();

                foreach (var mod in AppInit.modules.Where(i => i.middlewares != null && i.enable))
                {
                    try
                    {
                        var entry = new MiddlewaresModuleEntry() { mod = mod };

                        Assembly assembly = mod.assembly;
                        if (assembly == null)
                            continue;

                        var type = assembly.GetType(mod.NamespacePath(mod.middlewares));
                        if (type == null)
                            continue;

                        if (mod.version >= 2)
                        {
                            try
                            {
                                var m = type.GetMethod("Invoke");
                                if (m != null)
                                {
                                    entry.Invoke = (Func<bool, HttpContext, IMemoryCache, bool>)Delegate.CreateDelegate(
                                        typeof(Func<bool, HttpContext, IMemoryCache, bool>), m);
                                }
                            }
                            catch { }

                            try
                            {
                                var m2 = type.GetMethod("InvokeAsync");
                                if (m2 != null)
                                {
                                    entry.InvokeAsync = (Func<bool, HttpContext, IMemoryCache, Task<bool>>)Delegate.CreateDelegate(
                                        typeof(Func<bool, HttpContext, IMemoryCache, Task<bool>>), m2);
                                }
                            }
                            catch { }
                        }
                        else
                        {
                            try
                            {
                                var m = type.GetMethod("Invoke");
                                if (m != null)
                                {
                                    entry.InvokeV1 = (Func<HttpContext, IMemoryCache, bool>)Delegate.CreateDelegate(
                                        typeof(Func<HttpContext, IMemoryCache, bool>), m);
                                }
                            }
                            catch { }

                            try
                            {
                                var m2 = type.GetMethod("InvokeAsync");
                                if (m2 != null)
                                {
                                    entry.InvokeAsyncV1 = (Func<HttpContext, IMemoryCache, Task<bool>>)Delegate.CreateDelegate(
                                        typeof(Func<HttpContext, IMemoryCache, Task<bool>>), m2);
                                }
                            }
                            catch { }
                        }

                        if (entry.Invoke != null || entry.InvokeAsync != null || entry.InvokeV1 != null || entry.InvokeAsyncV1 != null)
                            middlewareModulesCache.Add(entry);
                    }
                    catch { }
                }
            }
        }
    }
}

```

## File: Shared/Models/Module/Entrys/OnlineModuleEntry.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;

namespace Shared.Models.Module.Entrys
{
    public class OnlineModuleEntry
    {
        public RootModule mod;

        // version >= 3
        public Func<HttpContext, IMemoryCache, RequestModel, string, OnlineEventsModel, List<(string name, string url, string plugin, int index)>> Invoke = null;
        public Func<HttpContext, IMemoryCache, RequestModel, string, OnlineEventsModel, Task<List<(string name, string url, string plugin, int index)>>> InvokeAsync = null;
        public Func<HttpContext, IMemoryCache, RequestModel, string, OnlineSpiderModel, List<(string name, string url, int index)>> Spider = null;
        public Func<HttpContext, IMemoryCache, RequestModel, string, OnlineSpiderModel, Task<List<(string name, string url, int index)>>> SpiderAsync = null;

        // version < 3
        public Func<string, long, string, long, string, string, string, int, string, int, string, List<(string name, string url, string plugin, int index)>> Events = null;
        public Func<HttpContext, IMemoryCache, string, long, string, long, string, string, string, int, string, int, string, Task<List<(string name, string url, string plugin, int index)>>> EventsAsync = null;
        public static List<OnlineModuleEntry> onlineModulesCache = null;
        static readonly object _onlineModulesCacheLock = new object();

        public static void EnsureCache(bool forced = false)
        {
            if (AppInit.modules == null)
                return;

            if (forced == false && onlineModulesCache != null)
                return;

            lock (_onlineModulesCacheLock)
            {
                if (forced == false && onlineModulesCache != null)
                    return;

                onlineModulesCache = new List<OnlineModuleEntry>();

                try
                {
                    foreach (var mod in AppInit.modules.Where(i => i.online != null && i.enable))
                    {
                        try
                        {
                            var entry = new OnlineModuleEntry() { mod = mod };

                            var assembly = mod.assembly;
                            if (assembly == null)
                                continue;

                            var type = assembly.GetType(mod.NamespacePath(mod.online));
                            if (type == null)
                                continue;

                            if (mod.version >= 3)
                            {
                                try
                                {
                                    var m = type.GetMethod("Invoke");
                                    if (m != null)
                                    {
                                        entry.Invoke = (Func<HttpContext, IMemoryCache, RequestModel, string, OnlineEventsModel, List<(string name, string url, string plugin, int index)>>)Delegate.CreateDelegate(
                                            typeof(Func<HttpContext, IMemoryCache, RequestModel, string, OnlineEventsModel, List<(string name, string url, string plugin, int index)>>), m);
                                    }
                                }
                                catch { }

                                try
                                {
                                    var m2 = type.GetMethod("InvokeAsync");
                                    if (m2 != null)
                                    {
                                        entry.InvokeAsync = (Func<HttpContext, IMemoryCache, RequestModel, string, OnlineEventsModel, Task<List<(string name, string url, string plugin, int index)>>>)Delegate.CreateDelegate(
                                            typeof(Func<HttpContext, IMemoryCache, RequestModel, string, OnlineEventsModel, Task<List<(string name, string url, string plugin, int index)>>>), m2);
                                    }
                                }
                                catch { }

                                try
                                {
                                    var m3 = type.GetMethod("Spider");
                                    if (m3 != null)
                                    {
                                        entry.Spider = (Func<HttpContext, IMemoryCache, RequestModel, string, OnlineSpiderModel, List<(string name, string url, int index)>>)Delegate.CreateDelegate(
                                            typeof(Func<HttpContext, IMemoryCache, RequestModel, string, OnlineSpiderModel, List<(string name, string url, int index)>>), m3);
                                    }
                                }
                                catch { }

                                try
                                {
                                    var m4 = type.GetMethod("SpiderAsync");
                                    if (m4 != null)
                                    {
                                        entry.SpiderAsync = (Func<HttpContext, IMemoryCache, RequestModel, string, OnlineSpiderModel, Task<List<(string name, string url, int index)>>>)Delegate.CreateDelegate(
                                            typeof(Func<HttpContext, IMemoryCache, RequestModel, string, OnlineSpiderModel, Task<List<(string name, string url, int index)>>>), m4);
                                    }
                                }
                                catch { }

                            }
                            else
                            {
                                try
                                {
                                    var m = type.GetMethod("Events");
                                    if (m != null)
                                    {
                                        entry.Events = (Func<string, long, string, long, string, string, string, int, string, int, string, List<(string name, string url, string plugin, int index)>>)Delegate.CreateDelegate(
                                            typeof(Func<string, long, string, long, string, string, string, int, string, int, string, List<(string name, string url, string plugin, int index)>>), m);
                                    }
                                }
                                catch { }

                                try
                                {
                                    var m2 = type.GetMethod("EventsAsync");
                                    if (m2 != null)
                                    {
                                        entry.EventsAsync = (Func<HttpContext, IMemoryCache, string, long, string, long, string, string, string, int, string, int, string, Task<List<(string name, string url, string plugin, int index)>>>)Delegate.CreateDelegate(
                                            typeof(Func<HttpContext, IMemoryCache, string, long, string, long, string, string, string, int, string, int, string, Task<List<(string name, string url, string plugin, int index)>>>), m2);
                                    }
                                }
                                catch { }
                            }

                            if (entry.Invoke != null || entry.InvokeAsync != null || entry.Events != null || entry.EventsAsync != null || entry.Spider != null || entry.SpiderAsync != null)
                                onlineModulesCache.Add(entry);
                        }
                        catch { }
                    }
                }
                catch { }
            }
        }

    }
}

```

## File: Shared/Models/Catalog/ContentParseSettings.cs
```
Ôªønamespace Shared.Models.Catalog
{
    public class ContentParseSettings
    {
        public string serial_regex { get; set; }

        public SingleNodeSettings serial_key { get; set; }

        public bool? jsonPath { get; set; }


        public string nodes { get; set; }

        public SingleNodeSettings name { get; set; }

        public SingleNodeSettings original_name { get; set; }

        public SingleNodeSettings href { get; set; }

        public SingleNodeSettings image { get; set; }

        public SingleNodeSettings year { get; set; }

        public List<SingleNodeSettings> args { get; set; }

        public SingleNodeSettings total_pages { get; set; }

        public string eval { get; set; }
    }
}

```

## File: Shared/Models/Catalog/MenuSettings.cs
```
Ôªønamespace Shared.Models.Catalog
{
    public class MenuSettings
    {
        public Dictionary<string, string> categories { get; set; }

        public Dictionary<string, string> sort { get; set; }

        public Dictionary<string, string> format { get; set; }

        public string defaultName { get; set; }

        public string catalog { get; set; }
    }
}

```

## File: Shared/Models/Catalog/CardParseSettings.cs
```
Ôªønamespace Shared.Models.Catalog
{
    public class CardParseSettings
    {
        public bool? jsonPath { get; set; }

        public string initUrl { get; set; }

        public string postData { get; set; }

        public string initHeader { get; set; }


        public string node { get; set; }

        public SingleNodeSettings name { get; set; }

        public SingleNodeSettings original_name { get; set; }

        public SingleNodeSettings image { get; set; }

        public SingleNodeSettings year { get; set; }

        public SingleNodeSettings description { get; set; }
    }
}

```

## File: Shared/Models/Catalog/PlaylistItem.cs
```
Ôªøusing Newtonsoft.Json.Linq;

namespace Shared.Models.Catalog
{
    public class PlaylistItem
    {
        public string id { get; set; }

        public bool is_serial { get; set; }

        public string title { get; set; }

        public string original_title { get; set; }

        public string img { get; set; }

        public string year { get; set; }

        public string card { get; set; }

        public JObject args { get; set; }
    }
}

```

## File: Shared/Models/Catalog/SingleNodeSettings.cs
```
Ôªønamespace Shared.Models.Catalog
{
    public class SingleNodeSettings
    {
        public string node { get; set; }

        public string attribute { get; set; }

        public string[] attributes { get; set; }


        public string format { get; set; }

        public string name_arg { get; set; }
    }
}

```

## File: Shared/Models/Catalog/CatalogSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Catalog
{
    public class CatalogSettings : BaseSettings, ICloneable
    {
        public CatalogSettings()
        {
            cache_time = 5;
        }

        public string args { get; set; }

        public bool hide { get; set; }

        public bool? jsonPath { get; set; }

        public bool search_lazy { get; set; } = true;

        public bool debug { get; set; }

        public int timeout { get; set; } = 10;

        public bool useDefaultHeaders { get; set; } = true;

        public List<Microsoft.Playwright.Cookie> cookies { get; set; }

        public bool ignore_no_picture { get; set; } = true;


        public string[] serial_cats { get; set; }

        public string[] movie_cats { get; set; }

        public string catalog_key { get; set; }

        public List<MenuSettings> menu { get; set; }


        public ListSettings search { get; set; }

        public ListSettings list { get; set; }

        public ContentParseSettings content { get; set; }


        public CardParseSettings card_parse { get; set; }

        public List<SingleNodeSettings> card_args { get; set; }

        public string[] tmdb_injects { get; set; }


        public CatalogSettings Clone()
        {
            return (CatalogSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Catalog/ListSettings.cs
```
Ôªønamespace Shared.Models.Catalog
{
    public class ListSettings
    {
        public string initUrl { get; set; }

        public string initHeader { get; set; }

        public int total_pages { get; set; }

        public int count_page { get; set; }

        public string firstpage { get; set; }

        public string uri { get; set; }

        public string postData { get; set; }

        public ContentParseSettings contentParse { get; set; }
    }
}

```

## File: Shared/Models/DLNA/CoverSettings.cs
```
Ôªøusing System.Diagnostics;

namespace Shared.Models.DLNA
{
    public class CoverSettings
    {
        public bool enable { get; set; }

        public bool consoleLog { get; set; }

        public bool preview { get; set; }

        public int timeout { get; set; }

        public int skipModificationTime { get; set; }

        public string extension { get; set; }

        public string coverComand { get; set; }

        public string previewComand { get; set; }

        public ProcessPriorityClass? priorityClass { get; set; }
    }
}

```

## File: Shared/Models/DLNA/DLNASettings.cs
```
Ôªønamespace Shared.Models.DLNA
{
    public class DLNASettings
    {
        public bool enable { get; set; }

        public string path { get; set; }

        public string mediaPattern { get; set; }

        public bool autoupdatetrackers { get; set; }

        public bool addTrackersToMagnet { get; set; }

        public int intervalUpdateTrackers { get; set; }

        public string mode { get; set; }

        public int downloadSpeed { get; set; }

        public int uploadSpeed { get; set; }

        public int maximumDiskReadRate { get; set; }

        public int maximumDiskWriteRate { get; set; }

        public CoverSettings cover { get; set; }
    }
}

```

## File: Shared/Models/JacRed/TorrentDetails.cs
```
Ôªøusing Shared.Models.JacRed.Tracks;

namespace Shared.Models.JacRed
{
    public class TorrentDetails : ICloneable
    {
        public string trackerName { get; set; }

        public string[] types { get; set; }

        public string url { get; set; }

        public HashSet<string> urls { get; set; }


        public string title { get; set; }

        public int sid { get; set; }

        public int pir { get; set; }

        public string sizeName { get; set; }

        public DateTime createTime { get; set; } = DateTime.UtcNow;

        public DateTime updateTime { get; set; } = DateTime.UtcNow;

        public DateTime checkTime { get; set; } = DateTime.Now;

        public string magnet { get; set; }

        public string parselink { get; set; }


        public string name { get; set; }

        public string originalname { get; set; }

        public int relased { get; set; }

        public double size { get; set; }

        public int quality { get; set; }

        public string videotype { get; set; }

        public HashSet<string> voices { get; set; } = new HashSet<string>();

        public HashSet<int> seasons { get; set; } = new HashSet<int>();


        public HashSet<string> languages { get; set; }

        public List<ffStream> ffprobe { get; set; }


        public object Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/JacRed/Tracks/ffTags.cs
```
Ôªønamespace Shared.Models.JacRed.Tracks
{
    public class ffTags
    {
        public string language { get; set; }

        public string BPS { get; set; }

        public string DURATION { get; set; }

        public string title { get; set; }
    }
}

```

## File: Shared/Models/JacRed/Tracks/ffStream.cs
```
Ôªønamespace Shared.Models.JacRed.Tracks
{
    public class ffStream
    {
        public int index { get; set; }

        public string codec_name { get; set; }

        public string codec_long_name { get; set; }

        public string codec_type { get; set; }

        public int? width { get; set; }

        public int? height { get; set; }

        public int? coded_width { get; set; }

        public int? coded_height { get; set; }

        public string sample_fmt { get; set; }

        public string sample_rate { get; set; }

        public int? channels { get; set; }

        public string channel_layout { get; set; }

        public string bit_rate { get; set; }

        public ffTags tags { get; set; }
    }
}

```

## File: Shared/Models/JacRed/Tracks/ffprobemodel.cs
```
Ôªønamespace Shared.Models.JacRed.Tracks
{
    public class ffprobemodel
    {
        public List<ffStream> streams { get; set; }
    }
}

```

## File: Shared/Models/Browser/KeepopenContext.cs
```
Ôªønamespace Shared.Models.Browser
{
    public class KeepopenContext
    {
        public bool keepopen { get; set; }

        public int keepalive { get; set; }

        public int min { get; set; }

        public int max { get; set; }
    }
}

```

## File: Shared/Models/Browser/KeepopenPage.cs
```
Ôªøusing Microsoft.Playwright;

namespace Shared.Models.Browser
{
    public class KeepopenPage
    {
        #region Firefox
        public IPage page { get; set; }

        public bool busy { get; set; }

        public DateTime lockTo { get; set; }
        #endregion


        public IBrowserContext context { get; set; }

        public DateTime lastActive { get; set; } = DateTime.Now;

        public DateTime create { get; set; } = DateTime.Now;


        public string plugin { get; set; }

        public  (string ip, string username, string password) proxy { get; set; }
    }
}

```

## File: Shared/Models/AppConf/KitConf.cs
```
Ôªøusing Newtonsoft.Json.Linq;

namespace Shared.Models.AppConf
{
    public class KitConf
    {
        public bool enable { get; set; }

        public string path { get; set; }

        public string eval_path { get; set; }

        public bool IsAllUsersPath { get; set; }

        public int cacheToSeconds { get; set; }

        public bool rhub_fallback { get; set; }

        [System.Text.Json.Serialization.JsonIgnore]
        [Newtonsoft.Json.JsonIgnore]
        public Dictionary<string, JObject> allUsers { get; set; }
    }


    public record KitConfEvalPath(string path, string uid);
}

```

## File: Shared/Models/AppConf/CmdConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class CmdConf
    {
        public string path { get; set; }

        public string arguments { get; set; }

        public string eval { get; set; }
    }
}

```

## File: Shared/Models/AppConf/OpenStatConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class OpenStatConf
    {
        public bool enable { get; set; }

        public string token { get; set; }
    }
}

```

## File: Shared/Models/AppConf/MediaApiConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class MediaApiConf
    {
        public string[] tokens { get; set; } = Array.Empty<string>();
    }
}
```

## File: Shared/Models/AppConf/OverrideResponse.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class OverrideResponse
    {
        public bool firstEndpoint { get; set; }

        public string pattern { get; set; }

        public string action { get; set; }

        public string type { get; set; }

        public string val { get; set; }
    }
}

```

## File: Shared/Models/AppConf/WebConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class WebConf
    {
        public bool autoupdate { get; set; }

        public string git { get; set; }

        public string tree { get; set; }

        public int intervalupdate { get; set; }

        public string index { get; set; }

        public string path { get; set; }

        public bool basetag { get; set; }

        public InitPlugins initPlugins { get; set; } = new InitPlugins();


        public Dictionary<string, string> appReplace { get; set; }

        public Dictionary<string, string> cssReplace { get; set; }
    }
}

```

## File: Shared/Models/AppConf/FfprobeSettings.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class FfprobeSettings
    {
        public bool enable { get; set; }

        public string tsuri { get; set; }
    }
}

```

## File: Shared/Models/AppConf/Known.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class Known
    {
        public string ip { get; set; }

        public int prefixLength { get; set; }
    }
}

```

## File: Shared/Models/AppConf/FileCacheConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class FileCacheConf
    {
        public int html { get; set; }

        public int torrent { get; set; }

        public int hls { get; set; }
    }
}

```

## File: Shared/Models/AppConf/TmdbConf.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.AppConf
{
    public class TmdbConf : Iproxy
    {
        public bool enable { get; set; }

        public int httpversion { get; set; }

        public string api_key { get; set; }


        public string DNS { get; set; }

        public int DNS_TTL { get; set; }


        public string API_IP { get; set; }

        public string API_Minor { get; set; }


        public string IMG_IP { get; set; }

        public string IMG_Minor { get; set; }


        public int cache_api { get; set; }

        public int cache_img { get; set; }

        public bool check_img { get; set; }


        public bool useproxy { get; set; }

        public bool useproxystream { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }
    }
}

```

## File: Shared/Models/AppConf/RchConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class RchConf
    {
        public bool enable { get; set; }

        public string websoket { get; set; }

        public bool requiredConnected { get; set; }

        public string notSupportMsg { get; set; }

        public string[] blacklistHost { get; set; }
    }
}

```

## File: Shared/Models/AppConf/WebLogConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class WebLogConf
    {
        public bool enable { get; set; }

        public string token { get; set; }
    }
}

```

## File: Shared/Models/AppConf/InitPlugins.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class InitPlugins
    {
        public bool dlna { get; set; } = true;

        public bool tracks { get; set; } = true;

        public bool transcoding { get; set; }

        public bool tmdbProxy { get; set; } = true;

        public bool online { get; set; } = true;

        public bool catalog { get; set; } = true;

        public bool sisi { get; set; } = true;

        public bool torrserver { get; set; } = true;

        public bool backup { get; set; } = true;


        public bool sync { get; set; } = true;

        public bool bookmark { get; set; }

        public bool timecode { get; set; }
    }
}

```

## File: Shared/Models/AppConf/StorageConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class StorageConf
    {
        public bool enable { get; set; }

        public long max_size { get; set; }

        public bool brotli { get; set; }

        public bool md5name { get; set; }
    }
}

```

## File: Shared/Models/AppConf/CubConf.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.AppConf
{
    public class CubConf : Iproxy
    {
        public bool enable { get; set; }

        public string[] geo { get; set; }

        public bool viewru { get; set; }


        public string domain { get; set; }

        public string scheme { get; set; }

        public string mirror { get; set; }


        public int cache_api { get; set; }

        public int cache_img { get; set; }


        public bool useproxy { get; set; }

        public bool useproxystream { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }


        public bool enabled(string country)
        {
            bool cubproxy = enable;
            if (cubproxy && geo != null)
                cubproxy = geo.Contains(country);

            return cubproxy;
        }
    }
}

```

## File: Shared/Models/AppConf/GCConf.cs
```
namespace Shared.Models.AppConf
{
    public class GCConf
    {
        public bool enable { get; set; }

        public bool aggressive { get; set; }

        public bool? Concurrent { get; set; }

        public int? ConserveMemory { get; set; }

        public int? HighMemoryPercent { get; set; }

        public bool? RetainVM { get; set; }
    }
}

```

## File: Shared/Models/AppConf/TracksTranscodingConf.cs
```
Ôªøusing Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Shared.Models.AppConf
{
    public class TranscodingConf
    {
        public bool enable { get; set; }

        public string ffmpeg { get; set; }

        public string tempRoot { get; set; }

        public int idleTimeoutSec { get; set; }

        public int idleTimeoutSec_live { get; set; }

        public bool defaultSubtitles { get; set; }

        public int maxConcurrentJobs { get; set; }

        public string[] allowHosts { get; set; } = Array.Empty<string>();

        public TranscodingHlsOptions hlsOptions { get; set; } = new();

        public TranscodingAudioOptions audioOptions { get; set; } = new();

        public TranscodingSubtitleOptions subtitleOptions { get; set; } = new();

        public TranscodingPlaylistOptions playlistOptions { get; set; } = new();

        public TranscodingConvertOptions convertOptions { get; set; } = new();

        [JsonProperty("comand", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string[]> comand { get; set; } = new Dictionary<string, string[]>()
        {
            ["demuxer"] = ["-threads 0", "-fflags +genpts"],
            ["input"] = ["-avoid_negative_ts disabled"],
            ["output"] = [
                "-map 0:v:0", "-map 0:a:{audio_index}",
                "-dn", "-sn",
                "-map_metadata -1", "-map_chapters -1", "-max_muxing_queue_size 2048"
            ],
        };
    }

    public class TranscodingHlsOptions
    {
        [JsonIgnore]
        public int seek { get; set; }

        /// <summary>
        /// hls_time
        /// </summary>
        public int segDur { get; set; } = 6;

        /// <summary>
        /// hls_list_size
        /// </summary>
        public int winSize { get; set; } = 10;

        /// <summary>
        /// hls_segment_type fmp4 / mpegts
        /// </summary>
        public bool fmp4 { get; set; } = true;

        [JsonProperty("comand", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string[]> comand { get; set; } = new Dictionary<string, string[]>()
        {
            ["output"] = ["-max_delay 5000000"],
            ["segment_mpegts"] = ["-bsf:v h264_mp4toannexb"],
        };
    }

    public class TranscodingAudioOptions
    {
        [JsonIgnore]
        public int index { get; set; }

        public int bitrateKbps { get; set; } = 192;

        public bool stereo { get; set; } = true;

        [JsonProperty("codec_copy", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public string[] codec_copy { get; set; } = Array.Empty<string>();

        [JsonProperty("comand_transcode", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string[]> comand_transcode { get; set; } = new Dictionary<string, string[]>()
        {
            ["default"] = ["-c:a aac", "-ac {stereo}", "-b:a {bitrateKbps}", "-profile:a aac_low"]
        };
    }

    public class TranscodingPlaylistOptions
    {
        /// <summary>
        /// sped
        /// </summary>
        public double readrate { get; set; } = 1.6;

        /// <summary>
        /// 10 MB
        /// </summary>
        public int burst { get; set; } = 10485760;

        public bool delete_segments { get; set; } = true;
    }

    public class TranscodingConvertOptions
    {
        public bool transcodeVideo { get; set; }

        [JsonProperty("codec", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public string[] codec { get; set; } = { "mpeg4", "msmpeg4v3", "flv1", "av1" };

        [JsonProperty("comand", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string[]> comand { get; set; } = new Dictionary<string, string[]>()
        {
            ["default"] = ["-c:v libx264", "-preset veryfast", "-tune zerolatency", "-pix_fmt yuv420p"],
            
            ["h264_yuv420p10le"] = [
                "-vf", "scale=in_color_matrix=bt2020nc:out_color_matrix=bt709:in_range=pc:out_range=tv,format=yuv420p",
                "-c:v libx264", "-preset veryfast", "-tune zerolatency", "-pix_fmt yuv420p",
                "-x264-params", "colorprim=bt709:transfer=bt709:colormatrix=bt709",
                "-color_primaries bt709", "-color_trc bt709", "-colorspace bt709", "-color_range tv"
            ]
        };
    }

    public class TranscodingSubtitleOptions
    {
        [JsonProperty("codec", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public string[] codec { get; set; } = { "subrip", "webvtt", "ass", "ssa", "mov_text", "ttml", "sami" };

        [JsonProperty("comand", ObjectCreationHandling = ObjectCreationHandling.Replace, NullValueHandling = NullValueHandling.Ignore)]
        public string[] comand { get; set; } = ["-map 0:{subIndex}", "-an -vn", "-c:s webvtt", "-flush_packets 1", "-max_interleave_delta 0", "-muxpreload 0", "-muxdelay 0", "-f webvtt", "subs_{subIndex}.vtt"];
    }

    public record TranscodingStartContext(
        Uri Source,
        string UserAgent,
        string Referer,
        TranscodingHlsOptions HlsOptions,
        TranscodingAudioOptions Audio,
        bool live,
        bool subtitles,
        string OutputDirectory,
        int? startNumber,
        JObject ffprobe
    );
}

```

## File: Shared/Models/AppConf/OnlineConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class OnlineConf
    {
        public string findkp { get; set; }

        public bool checkOnlineSearch { get; set; }

        public bool spider { get; set; }

        public string spiderName { get; set; }


        public string component { get; set; }

        public string name { get; set; }

        public string description { get; set; }

        public bool version { get; set; }

        public bool btn_priority_forced { get; set; }

        public bool showquality { get; set; }


        public string apn { get; set; }

        public Dictionary<string, string> appReplace { get; set; }


        public List<string> with_search { get; set; }
    }
}

```

## File: Shared/Models/AppConf/HybridCacheConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class HybridCacheConf
    {
        public string type { get; set; }

        public int extend { get; set; }
    }
}

```

## File: Shared/Models/AppConf/AccsConf.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Shared.Models.Base;
using System.Collections.Concurrent;

namespace Shared.Models.AppConf
{
    public class AccsConf
    {
        public bool enable { get; set; }

        public string shared_passwd { get; set; }

        public int shared_daytime { get; set; }

        public string whitepattern { get; set; }

        public HashSet<string> white_uids { get; set; }

        public string premium_pattern { get; set; }

        public string domainId_pattern { get; set; }

        public int maxip_hour { get; set; }

        public int maxrequest_hour { get; set; }

        public int maxlock_day { get; set; }

        public int blocked_hour { get; set; }

        public string authMesage { get; set; }

        public string denyMesage { get; set; }

        public string denyGroupMesage { get; set; }

        public string expiresMesage { get; set; }

        public Dictionary<string, object> @params { get; set; }

        public Dictionary<string, DateTime> accounts { get; set; } = new Dictionary<string, DateTime>();

        public ConcurrentBag<AccsUser> users { get; set; } = new ConcurrentBag<AccsUser>();


        public AccsUser findUser(HttpContext httpContext, out string uid)
        {
            var user = findUser(httpContext.Request.Query["token"].ToString()) ??
                       findUser(httpContext.Request.Query["account_email"].ToString()) ??
                       findUser(httpContext.Request.Query["uid"].ToString()) ??
                       findUser(httpContext.Request.Query["box_mac"].ToString());

            if (user != null)
            {
                uid = user.id;
                return user;
            }

            uid = null;
            return null;
        }

        public AccsUser findUser(string uid)
        {
            if (string.IsNullOrEmpty(uid))
                return null;

            uid = uid.ToLower().Trim();
            return users.FirstOrDefault(i => (i.id != null && i.id.ToLower() == uid) || (i.ids != null && i.ids.FirstOrDefault(id => id.ToLower() == uid) != null));
        }
    }
}

```

## File: Shared/Models/AppConf/SyncUserConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class SyncUserConf
    {
        public bool enable { get; set; }

        public int version { get; set; }

        public bool fullset { get; set; }
    }
}

```

## File: Shared/Models/AppConf/WafConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class WafConf
    {
        public bool enable { get; set; }

        public List<string> whiteIps { get; set; }

        public int limit_req { get; set; }

        /// <summary>
        /// uri_pattern: limit_req
        /// </summary>
        public Dictionary<string, int> limit_map { get; set; }

        public List<string> ipsDeny { get; set; }

        public List<string> ipsAllow { get; set; }

        public List<string> countryDeny { get; set; }

        public List<string> countryAllow { get; set; }

        /// <summary>
        /// header_key: regex
        /// </summary>
        public Dictionary<string, string> headersDeny { get; set; }
    }
}

```

## File: Shared/Models/AppConf/CorseuConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class CorseuConf
    {
        public string[] tokens { get; set; }
    }
}
```

## File: Shared/Models/AppConf/ListenConf.cs
```
using Microsoft.AspNetCore.Server.Kestrel.Core;

namespace Shared.Models.AppConf
{
    public class ListenConf
    {
        public string ip { get; set; }

        public int port { get; set; }

        public bool compression { get; set; }

        public string sock { get; set; }

        public string scheme { get; set; }

        public string host { get; set; }

        public string frontend { get; set; }

        public string localhost { get; set; }

        public int? keepalive { get; set; }

        public HttpProtocols? endpointDefaultsProtocols { get; set; }
    }
}

```

## File: Shared/Models/AppConf/CronTime.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class CronTime
    {
        public int updateLampaWeb;

        public int clearCache;

        public int updateTrackers;
    }
}

```

## File: Shared/Models/AppConf/PuppeteerConf.cs
```
Ôªøusing Shared.Models.Browser;

namespace Shared.Models.AppConf
{
    public class PuppeteerConf
    {
        public bool enable { get; set; }

        public KeepopenContext context { get; set; }

        public bool Headless { get; set; }

        public bool DEV { get; set; }

        public bool consoleLog { get; set; }

        public bool Devtools { get; set; }

        public string executablePath { get; set; }

        public string[] Args { get; set; }
    }
}

```

## File: Shared/Models/AppConf/SyncConf.cs
```
Ôªønamespace Shared.Models.AppConf
{
    public class SyncConf
    {
        public bool enable { get; set; }

        /// <summary>
        /// master
        /// slave
        /// </summary>
        public string type { get; set; }

        public string initconf { get; set; }

        public bool sync_full { get; set; } = true;

        public string api_host { get; set; }

        public string api_passwd { get; set; }

        public Dictionary<string, string> override_conf { get; set; }
    }
}

```

## File: Shared/Models/Templates/EpisodeTpl.cs
```
Ôªøusing Shared.Models.Base;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Web;

namespace Shared.Models.Templates
{
    public struct EpisodeTpl
    {
        public List<(string name, string title, string s, string e, string link, string method, StreamQualityTpl? streamquality, SubtitleTpl? subtitles, string streamlink, string voice_name, VastConf vast, List<HeadersModel> headers, int? hls_manifest_timeout, SegmentTpl? segments, string subtitles_call)> data { get; set; }

        public EpisodeTpl() : this(20) { }

        public EpisodeTpl(int capacity) 
        {
            data = new List<(string, string, string, string, string, string, StreamQualityTpl?, SubtitleTpl?, string, string, VastConf, List<HeadersModel>, int?, SegmentTpl?, string)>(capacity);
        }

        public void Append(string name, string title, string s, string e, string link, string method = "play", in StreamQualityTpl? streamquality = null, in SubtitleTpl? subtitles = null, string streamlink = null, string voice_name = null, VastConf vast = null, List<HeadersModel> headers = null, int? hls_manifest_timeout = null, SegmentTpl? segments = null, string subtitles_call = null)
        {
            if (!string.IsNullOrEmpty(name) && !string.IsNullOrEmpty(link))
                data.Add((name, $"{title} ({e} —Å–µ—Ä–∏—è)", s, e, link, method, streamquality, subtitles, streamlink, voice_name, vast, headers, hls_manifest_timeout, segments, subtitles_call));
        }

        public string ToHtml()
        {
            if (data.Count == 0)
                return string.Empty;

            bool firstjson = true;
            var html = new StringBuilder();
            html.Append("<div class=\"videos__line\">");

            foreach (var i in data) 
            {
                var vast = i.vast ?? AppInit.conf.vast;

                string datajson = JsonSerializer.Serialize(new
                {
                    i.method,
                    url = i.link,
                    i.title,
                    stream = i.streamlink,
                    headers = i.headers != null ? i.headers.ToDictionary(k => k.name, v => v.val) : null,
                    quality = i.streamquality?.ToObject(emptyToNull: true),
                    subtitles = i.subtitles?.ToObject(emptyToNull: true),
                    i.subtitles_call,
                    i.voice_name,
                    i.hls_manifest_timeout,
                    vast = vast?.url != null ? vast : null,
                    i.segments

                }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault });

                html.Append($"<div class=\"videos__item videos__movie selector {(firstjson ? "focused" : "")}\" media=\"\" s=\"{i.s}\" e=\"{i.e}\" data-json='{datajson}'><div class=\"videos__item-imgbox videos__movie-imgbox\"></div><div class=\"videos__item-title\">{HttpUtility.HtmlEncode(i.name)}</div></div>");
                firstjson = false;
            }

            return html.ToString() + "</div>";
        }

        public string ToJson(in VoiceTpl? vtpl = null)
        {
            if (data.Count == 0)
                return "[]";

            return JsonSerializer.Serialize(new
            {
                type = "episode",
                voice = vtpl?.ToObject(),
                data = data.Select(i => new
                {
                    i.method,
                    url = i.link,
                    stream = i.streamlink,
                    headers = i.headers != null ? i.headers.ToDictionary(k => k.name, v => v.val) : null,
                    quality = i.streamquality?.ToObject(emptyToNull: true),
                    subtitles = i.subtitles?.ToObject(emptyToNull: true),
                    i.subtitles_call,
                    s = int.TryParse(i.s, out int _s) ? _s : 0,
                    e = int.TryParse(i.e, out int _e) ? _e : 0,
                    details = i.voice_name,
                    i.name,
                    i.title,
                    i.hls_manifest_timeout,
                    vast = (i.vast ?? AppInit.conf.vast)?.url != null ? (i.vast ?? AppInit.conf.vast) : null,
                    i.segments
                })
            }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull });
        }
    }
}

```

## File: Shared/Models/Templates/VideoTpl.cs
```
Ôªøusing Shared.Models.Base;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Shared.Models.Templates
{
    public static class VideoTpl
    {
        public static string ToJson(string method, string url, string title, in StreamQualityTpl? streamquality = null, in SubtitleTpl? subtitles = null, string quality = null, VastConf vast = null, List<HeadersModel> headers = null, int? hls_manifest_timeout = null, SegmentTpl? segments = null, string subtitles_call = null)
        {
            var _vast = vast ?? AppInit.conf.vast;

            return JsonSerializer.Serialize(new
            {
                title,
                method,
                url,
                headers = headers != null ? headers.ToDictionary(k => k.name, v => v.val) : null,
                quality = streamquality?.ToObject(emptyToNull: true) ?? new StreamQualityTpl(new List<(string, string)>() { (url, quality??"auto") }).ToObject(),
                subtitles = subtitles?.ToObject(emptyToNull: true),
                subtitles_call,
                hls_manifest_timeout,
                vast = _vast?.url != null ? _vast : _vast,
                segments = segments?.ToObject()

            }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault });
        }
    }
}

```

## File: Shared/Models/Templates/VoiceTpl.cs
```
Ôªøusing System.Text;
using System.Text.Json;
using System.Web;

namespace Shared.Models.Templates
{
    public struct VoiceTpl
    {
        public List<(string name, bool active, string link)> data { get; set; }

        public VoiceTpl() : this(15) { }

        public VoiceTpl(int capacity) { data = new List<(string, bool, string)>(capacity); }

        public void Append(string name, bool active, string link)
        {
            if (!string.IsNullOrEmpty(name))
                data.Add((name, active, link));
        }

        public string ToHtml()
        {
            if (data.Count == 0)
                return string.Empty;

            var html = new StringBuilder();
            html.Append("<div class=\"videos__line\">");

            foreach (var i in data)
                html.Append("<div class=\"videos__button selector " + (i.active ? "active" : "") + "\" data-json='{\"method\":\"link\",\"url\":\"" + i.link + "\"}'>" + HttpUtility.HtmlEncode(i.name) + "</div>");

            return html.ToString() + "</div>";
        }

        public string ToJson() => JsonSerializer.Serialize(ToObject());

        public object ToObject()
        {
            if (data.Count == 0)
                return new List<string>();

            return data.Select(i => new 
            {
                method = "link",
                url = i.link,
                i.active,
                i.name
            });
        }
    }
}

```

## File: Shared/Models/Templates/SeasonTpl.cs
```
Ôªøusing System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Web;

namespace Shared.Models.Templates
{
    public struct SeasonTpl
    {
        public List<(string name, string link, int? id)> data { get; set; }

        public string quality = null;

        public SeasonTpl() : this(10) { }

        public SeasonTpl(int capacity) { data = new List<(string, string, int?)>(capacity); }

        public SeasonTpl(string quality, int capacity = 10) 
        {
            data = new List<(string, string, int?)>(capacity);
            this.quality = quality; 
        }

        public void Append(string name, string link, string id)
        {
            int.TryParse(id, out int sid);
            Append(name, link, sid);
        }

        public void Append(string name, string link, int id)
        {
            if (!string.IsNullOrEmpty(name))
                data.Add((name, link, id));
        }

        public string ToHtml(in VoiceTpl? vtpl = null)
        {
            if (data.Count == 0)
                return string.Empty;

            bool firstjson = true;
            var html = new StringBuilder();

            if (vtpl != null)
                html.Append(vtpl?.ToHtml());

            html.Append("<div class=\"videos__line\">");

            if (!string.IsNullOrEmpty(quality))
                html.Append($"<!--q:{quality}-->");

            foreach (var i in data) 
            {
                html.Append("<div class=\"videos__item videos__season selector " + (firstjson ? "focused" : "") + "\" data-json='{\"method\":\"link\",\"url\":\"" + i.link + "\"}'><div class=\"videos__season-layers\"></div><div class=\"videos__item-imgbox videos__season-imgbox\"><div class=\"videos__item-title videos__season-title\">" + HttpUtility.HtmlEncode(i.name) + "</div></div></div>");
                firstjson = false;
            }

            return html.ToString() + "</div>";
        }

        public string ToJson(in VoiceTpl? vtpl = null)
        {
            if (data.Count == 0)
                return "[]";

            return JsonSerializer.Serialize(new
            {
                type = "season",
                maxquality = quality,
                voice = vtpl?.ToObject(),
                data = data.Select(i => new
                {
                    i.id,
                    method = "link",
                    url = i.link,
                    i.name
                })
            }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull });
        }
    }
}

```

## File: Shared/Models/Templates/SimilarTpl.cs
```
Ôªøusing System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Web;

namespace Shared.Models.Templates
{
    public struct SimilarTpl
    {
        public List<(string title, string year, string details, string link, string img)> data { get; set; }

        public SimilarTpl() : this(20) { }

        public SimilarTpl(int capacity) { data = new List<(string, string, string, string, string)>(capacity); }


        public string OnlineSplit => "{prestige-split}";


        public void Append(string title, string year, string details, string link, string img = null)
        {
            if (!string.IsNullOrEmpty(title))
                data.Add((title, year, details, link, img));
        }

        public string ToHtml()
        {
            if (data.Count == 0)
                return string.Empty;

            bool firstjson = true;
            var html = new StringBuilder();
            html.Append("<div class=\"videos__line\">");

            foreach (var i in data) 
            {
                string datajson = JsonSerializer.Serialize(new
                {
                    method = "link",
                    url = i.link,
                    similar = true,
                    year = i.year != null && int.TryParse(i.year, out int _year) ? _year : 0,
                    i.details,
                    i.img

                }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault });

                datajson = datajson.Replace("{prestige-split}", "<span class=\\\"online-prestige-split\\\">‚óè</span>");

                html.Append($"<div class=\"videos__item videos__season selector {(firstjson ? "focused" : "")}\" data-json='{datajson}'><div class=\"videos__season-layers\"></div><div class=\"videos__item-imgbox videos__season-imgbox\"><div class=\"videos__item-title videos__season-title\">{HttpUtility.HtmlEncode(i.title)}</div></div></div>");
                firstjson = false;
            }

            return html.ToString() + "</div>";
        }


        public string ToJson()
        {
            if (data.Count == 0)
                return "[]";

            return JsonSerializer.Serialize(new 
            {
                type = "similar",
                data = data.Select(i => new 
                {
                    url = i.link,
                    details = i.details?.Replace("{prestige-split}", "<span class=\"online-prestige-split\">‚óè</span>"),
                    i.title,
                    year = int.TryParse(i.year, out int _year) ? _year : 0,
                    i.img
                })
            }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault });
        }
    }
}

```

## File: Shared/Models/Templates/SubtitleTpl.cs
```
Ôªøusing System.Text.Json;

namespace Shared.Models.Templates
{
    public struct SubtitleTpl
    {
        public List<(string label, string url)> data { get; set; }

        public SubtitleTpl() : this(10) { }

        public SubtitleTpl(int capacity) { data = new List<(string, string)>(capacity); }

        public bool IsEmpty() => data.Count == 0;

        public void Append(string label, string url)
        {
            if (!string.IsNullOrEmpty(label) && !string.IsNullOrEmpty(url))
                data.Add((label, url));
        }

        public string ToJson() => JsonSerializer.Serialize(ToObject());

        public object ToObject(bool emptyToNull = false)
        {
            if (data.Count == 0)
                return emptyToNull ? null : new List<string>();

            return data.Select(i => new
            {
                method = "link",
                i.url,
                i.label
            });
        }
    }
}

```

## File: Shared/Models/Templates/MovieTpl.cs
```
Ôªøusing System.Text;
using System.Text.Json.Serialization;
using System.Text.Json;
using System.Web;
using Shared.Models.Base;

namespace Shared.Models.Templates
{
    public struct MovieTpl
    {
        string title, original_title;

        public List<(string voiceOrQuality, string link, string method, string stream, StreamQualityTpl? streamquality, SubtitleTpl? subtitles, string voice_name, string year, string details, string quality, VastConf vast, List<HeadersModel> headers, int? hls_manifest_timeout, SegmentTpl? segments, string subtitles_call)> data { get; set; }

        public MovieTpl(string title) : this(title, null, 15) { }

        public MovieTpl(string title, string original_title) : this(title, original_title, 15) { }

        public MovieTpl(string title, string original_title, int capacity) 
        {
            this.title = title;
            this.original_title = original_title;
            data = new List<(string, string, string, string, StreamQualityTpl?, SubtitleTpl?, string, string, string, string, VastConf vast, List<HeadersModel>, int?, SegmentTpl?, string)> (capacity); 
        }

        public bool IsEmpty() => data.Count == 0;

        public void Append(string voiceOrQuality, string link, string method = "play", string stream = null, in StreamQualityTpl? streamquality = null, in SubtitleTpl? subtitles = null, string voice_name = null, string year = null, string details = null, string quality = null, VastConf vast = null, List<HeadersModel> headers = null, int? hls_manifest_timeout = null, SegmentTpl? segments = null, string subtitles_call = null)
        {
            if (!string.IsNullOrEmpty(voiceOrQuality) && !string.IsNullOrEmpty(link))
                data.Add((voiceOrQuality, link, method, stream, streamquality, subtitles, voice_name, year, details, quality, vast, headers, hls_manifest_timeout, segments, subtitles_call));
        }

        public string ToHtml(string voiceOrQuality, string link, string method = "play", string stream = null, in StreamQualityTpl? streamquality = null, in SubtitleTpl? subtitles = null, string voice_name = null, string year = null, string details = null, string quality = null, VastConf vast = null, List<HeadersModel> headers = null, int? hls_manifest_timeout = null, SegmentTpl? segments = null, string subtitles_call = null)
        {
            Append(voiceOrQuality, link, method, stream, streamquality, subtitles, voice_name, year, details, quality, vast, headers, hls_manifest_timeout, segments, subtitles_call);
            return ToHtml();
        }

        public string ToHtml(bool reverse = false)
        {
            if (data.Count == 0)
                return string.Empty;

            bool firstjson = true;
            var html = new StringBuilder();
            html.Append("<div class=\"videos__line\">");

            if (reverse)
                data.Reverse();

            foreach (var i in data) 
            {
                var vast = i.vast ?? AppInit.conf.vast;

                string datajson = JsonSerializer.Serialize(new
                {
                    i.method,
                    url = i.link,
                    i.stream,
                    headers = i.headers != null ? i.headers.ToDictionary(k => k.name, v => v.val) : null,
                    quality = i.streamquality?.ToObject(emptyToNull: true),
                    subtitles = i.subtitles?.ToObject(emptyToNull: true),
                    i.subtitles_call,
                    translate = i.voiceOrQuality,
                    maxquality = i.streamquality?.MaxQuality() ?? i.quality,
                    i.voice_name,
                    i.details,
                    year = int.TryParse(i.year, out int _year) ? _year : 0,
                    title = $"{title ?? original_title} ({i.voiceOrQuality})",
                    i.hls_manifest_timeout,
                    vast = vast?.url != null ? vast : null,
                    i.segments

                }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault });

                html.Append($"<div class=\"videos__item videos__movie selector {(firstjson ? "focused" : "")}\" media=\"\" data-json='{datajson}'><div class=\"videos__item-imgbox videos__movie-imgbox\"></div><div class=\"videos__item-title\">{HttpUtility.HtmlEncode(i.voiceOrQuality)}</div></div>");
                firstjson = false;

                if (!string.IsNullOrEmpty(i.quality))
                    html.Append($"<!--{i.quality}p-->");
            }

            return html.ToString() + "</div>";
        }

        public string ToJson(bool reverse = false, in VoiceTpl? vtpl = null)
        {
            if (data.Count == 0)
                return "[]";

            if (reverse)
                data.Reverse();

            string name = title ?? original_title;

            return JsonSerializer.Serialize(new
            {
                type = "movie",
                voice = vtpl?.ToObject(),
                data = data.Select(i => new
                {
                    i.method,
                    url = i.link,
                    i.stream,
                    headers = i.headers != null ? i.headers.ToDictionary(k => k.name, v => v.val) : null,
                    quality = i.streamquality?.ToObject(emptyToNull: true),
                    subtitles = i.subtitles?.ToObject(emptyToNull: true),
                    i.subtitles_call,
                    translate = i.voiceOrQuality,
                    maxquality = i.streamquality?.MaxQuality() ?? i.quality,
                    details = (i.voice_name == null && i.details == null) ? null : (i.voice_name + i.details),
                    year = int.TryParse(i.year, out int _year) ? _year : 0,
                    title = $"{name} ({i.voiceOrQuality})",
                    i.hls_manifest_timeout,
                    vast = (i.vast ?? AppInit.conf.vast)?.url != null ? (i.vast ?? AppInit.conf.vast) : null,
                    i.segments
                })
            }, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault });
        }
    }
}

```

## File: Shared/Models/Templates/StreamQualityTpl.cs
```
using Shared.Models.Events;
using System.Text.Json;

namespace Shared.Models.Templates
{
    public struct StreamQualityTpl
    {
        public List<(string link, string quality)> data { get; set; } = new List<(string, string)>(8);

        public StreamQualityTpl() { }

        public StreamQualityTpl(IEnumerable<(string link, string quality)> streams) 
        {
            if (streams != null)
            {
                foreach (var item in streams)
                    Append(item.link, item.quality);
            }
        }

        public bool Any() => data.Any();

        public void Append(string link, string quality)
        {
            if (string.IsNullOrEmpty(quality))
                return;

            var eventResult = InvkEvent.StreamQuality(new EventStreamQuality(link, quality, prepend: false));
            if (eventResult.next.HasValue && !eventResult.next.Value)
                return;

            link = eventResult.link ?? link;

            if (!string.IsNullOrEmpty(link))
                data.Add((link, quality));
        }

        public void Insert(string link, string quality)
        {
            if (string.IsNullOrEmpty(quality))
                return;

            var eventResult = InvkEvent.StreamQuality(new EventStreamQuality(link, quality, prepend: true));
            if (eventResult.next.HasValue && !eventResult.next.Value)
                return;

            link = eventResult.link ?? link;

            if (!string.IsNullOrEmpty(link))
                data.Insert(0, (link, quality));
        }

        public string ToJson() => JsonSerializer.Serialize(ToObject());

        public Dictionary<string, string> ToObject(bool emptyToNull = false)
        {
            var result = new Dictionary<string, string>();
            foreach (var item in data)
                result.TryAdd(item.quality, item.link);

            if (emptyToNull && result.Count == 0)
                return null;

            return result;
        }

        public string MaxQuality()
        {
            if (data.Count == 0)
                return string.Empty;

            return data[0].quality;
        }

        public (string link, string quality) Firts()
        {
            if (data.Count == 0)
                return default;

            var eventResult = InvkEvent.StreamQualityFirts(new EventStreamQualityFirts(data));

            return eventResult ?? data[0];
        }
    }
}

```

## File: Shared/Models/Templates/SegmentTpl.cs
```
Ôªønamespace Shared.Models.Templates
{
    public struct SegmentTpl
    {
        public List<(int start, int end)> ads { get; set; }

        public List<(int start, int end)> skips { get; set; }

        public SegmentTpl()
        {
            ads = new List<(int, int)>();
            skips = new List<(int, int)>();
        }

        public bool IsEmpty() => ads.Count == 0 && skips.Count == 0;

        public void ad(int start, int end)
        {
            if (start >= 0 && end >= 0 && end >= start)
                ads.Add((start == 0 ? 1 : start, end));
        }

        public void skip(int start, int end)
        {
            if (start >= 0 && end >= 0 && end >= start)
                skips.Add((start == 0 ? 1 : start, end));
        }

        public object ToObject()
        {
            if (IsEmpty())
                return null;

            var adList = ads.Select(i => new { i.start, i.end }).ToList();
            var skipList = skips.Select(i => new { i.start, i.end }).ToList();

            return new { ad = adList, skip = skipList };
        }
    }
}

```

## File: Shared/Models/Online/ApiModel.cs
```
Ôªønamespace Shared.Models.Online
{
    public class ApiModel
    {
        public string title { get; set; }

        public string stream_url { get; set; }

        public List<(string link, string quality)> streams { get; set; } = new List<(string link, string quality)>();

        public List<ApiModel> submenu { get; set; }

        /// <summary>
        /// voice
        /// season
        /// episode
        /// </summary>
        public string type { get; set; }
    }
}

```

## File: Shared/Models/Online/Mirage.cs
```
Ôªønamespace Shared.Models.Online.Mirage
{
    public record AcDecode(string baer);
}

```

## File: Shared/Models/Online/CDNmovies/Episode.cs
```
Ôªønamespace Shared.Models.Online.CDNmovies
{
    public struct Episode
    {
        public string title { get; set; }

        public string file { get; set; }
    }
}

```

## File: Shared/Models/Online/CDNmovies/Voice.cs
```
Ôªønamespace Shared.Models.Online.CDNmovies
{
    public struct Voice
    {
        public string title { get; set; }

        public Season[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/CDNmovies/Season.cs
```
Ôªønamespace Shared.Models.Online.CDNmovies
{
    public struct Season
    {
        public string title { get; set; }

        public Episode[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/Settings/KinoPubSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class KinoPubSettings : BaseSettings, ICloneable
    {
        public KinoPubSettings(string plugin, string host = null)
        {
            this.plugin = plugin;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);
        }

        public string[] tokens { get; set; }

        public string filetype { get; set; }


        public KinoPubSettings Clone()
        {
            return (KinoPubSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/KodikSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class KodikSettings : BaseSettings, ICloneable
    {
        public KodikSettings(string plugin, string apihost, string linkhost, string token, string secret_token, bool localip, bool enable = true, bool hls = true, bool streamproxy = false)
        {
            this.plugin = plugin;
            this.secret_token = secret_token;
            this.localip = localip;
            this.enable = enable;
            this.hls = hls;
            this.streamproxy = streamproxy;

            this.linkhost = linkhost.StartsWith("http") ? linkhost : Decrypt(linkhost)!;
            this.apihost = apihost.StartsWith("http") ? apihost : Decrypt(apihost);
            this.token = token.Contains(":") ? Decrypt(token)! : token;
        }

        public bool auto_proxy { get; set; }

        public bool cdn_is_working { get; set; }

        public string secret_token { get; set; }

        public string linkhost { get; set; }

        public bool localip { get; set; }

        public KodikSettings Clone()
        {
            return (KodikSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/IframeVideoSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class IframeVideoSettings : BaseSettings, ICloneable
    {
        public IframeVideoSettings(string plugin, string host, string cdnhost, bool enable = true)
        {
            this.cdnhost = cdnhost;
            this.enable = enable;
            this.plugin = plugin;

            if (host != null)
                apihost = host.StartsWith("http") ? host : Decrypt(host);
        }

        public string cdnhost { get; set; }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/LumexSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class LumexSettings : BaseSettings, ICloneable
    {
        public LumexSettings(string plugin, string apihost, string token, string iframehost, string clientId)
        {
            this.plugin = plugin;

            if (apihost != null)
                this.apihost = apihost.StartsWith("http") ? apihost : Decrypt(apihost);

            if (iframehost != null)
                this.iframehost = iframehost.StartsWith("http") ? iframehost : (iframehost.Contains("{") ? Decrypt(iframehost) : iframehost);

            if (token != null)
                this.token = (token.Contains(":") || token.Contains("{")) ? Decrypt(token) : token;

            this.clientId = clientId;
        }


        public string clientId { get; set; }

        public string iframehost { get; set; }


        public string username { get; set; }

        public string password { get; set; }

        public string domain { get; set; }

        public bool disable_protection { get; set; }

        public bool disable_ads { get; set; }

        public bool log { get; set; }

        public bool verifyip { get; set; }


        public LumexSettings Clone()
        {
            return (LumexSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/CollapsSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class CollapsSettings : BaseSettings, ICloneable
    {
        public CollapsSettings(string plugin, string host, bool enable = true, bool streamproxy = false, bool two = false)
        {
            this.enable = enable;
            this.plugin = plugin;
            this.streamproxy = streamproxy;
            this.two = two;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);
        }


        public bool two { get; set; }
         
        public bool dash { get; set; }


        public CollapsSettings Clone()
        {
            return (CollapsSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/KinobaseSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class KinobaseSettings : BaseSettings
    {
        public KinobaseSettings(string plugin, string host, bool playerjs, bool hdr)
        {
            enable = true;
            this.plugin = plugin;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);

            this.playerjs = playerjs;
            this.hdr = hdr;
        }


        public bool playerjs { get; set; }

        public bool hdr { get; set; }
    }
}

```

## File: Shared/Models/Online/Settings/ZetflixSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class ZetflixSettings : BaseSettings, ICloneable
    {
        public ZetflixSettings(string plugin, string host, bool enable = true, bool streamproxy = false, bool rip = false)
        {
            this.enable = enable;
            this.plugin = plugin;
            this.streamproxy = streamproxy;
            this.rip = rip;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);
        }


        public bool browser_keepopen { get; set; }

        public ZetflixSettings Clone()
        {
            return (ZetflixSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/RezkaSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class RezkaSettings : BaseSettings, ICloneable
    {
        public RezkaSettings(string plugin, string host, bool streamproxy = false)
        {
            enable = true;
            this.plugin = plugin;
            this.streamproxy = streamproxy;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);
        }


        public string login { get; set; }

        public string passwd { get; set; }

        public bool premium { get; set; }

        public bool reserve { get; set; }

        public string uacdn { get; set; }

        public bool forceua { get; set; }

        public bool xrealip { get; set; }

        public bool xapp { get; set; }

        public bool? ajax { get; set; }


        public RezkaSettings Clone()
        {
            return (RezkaSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/VokinoSettings.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.VoKino;

namespace Shared.Models.Online.Settings
{
    public class VokinoSettings : BaseSettings, ICloneable
    {
        public VokinoSettings(string plugin, string host, bool streamproxy, bool rip = false)
        {
            this.streamproxy = streamproxy;
            this.plugin = plugin;
            this.rip = rip;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);
        }


        public bool onlyBalancerName { get; set; }

        public ViewOnline online { get; set; } = new ViewOnline();


        public VokinoSettings Clone()
        {
            return (VokinoSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/OnlinesSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class OnlinesSettings : BaseSettings, ICloneable
    {
        public OnlinesSettings(string plugin, string host, string apihost = null, bool useproxy = false, string token = null, bool enable = true, bool streamproxy = false, bool rip = false, bool forceEncryptToken = false)
        {
            this.enable = enable;
            this.plugin = plugin;
            this.useproxy = useproxy;
            this.streamproxy = streamproxy;
            this.rip = rip;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);

            if (apihost != null)
                this.apihost = apihost.StartsWith("http") ? apihost : Decrypt(apihost);

            if (token != null)
                this.token = forceEncryptToken || token.Contains(":") || token.Contains("<") ? Decrypt(token) : token;
        }

        public bool imitationHuman { get; set; }


        public OnlinesSettings Clone()
        {
            return (OnlinesSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/AllohaSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class AllohaSettings : BaseSettings, ICloneable
    {
        public AllohaSettings(string plugin, string apihost, string linkhost, string token, string secret_token, bool localip, bool m4s)
        {
            this.plugin = plugin;
            this.token = token;
            this.secret_token = secret_token;
            this.localip = localip;
            this.m4s = m4s;

            this.linkhost = linkhost == null ? string.Empty : (linkhost.StartsWith("http") ? linkhost : Decrypt(linkhost)!);
            this.apihost = apihost == null ? string.Empty : (apihost.StartsWith("http") ? apihost : Decrypt(apihost));
        }


        public string secret_token { get; set; }

        public string linkhost { get; set; }

        public bool localip { get; set; }

        public bool m4s { get; set; }

        public bool reserve { get; set; }


        public AllohaSettings Clone()
        {
            return (AllohaSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Settings/PidTorSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class PidTorSettings : Igroup, ICloneable
    {
        bool _enable;

        public bool enable
        {
            get
            {
                if (AppInit.conf.defaultOn == "enabled")
                    return enabled;

                return _enable;
            }
            set
            {
                _enable = value;
            }
        }

        public bool enabled { get; set; }


        public string displayname { get; set; }

        public int displayindex { get; set; }

        public string redapi { get; set; }

        public string apikey { get; set; }

        public int min_sid { get; set; }

        public long max_size { get; set; }

        public long max_serial_size { get; set; }

        public bool emptyVoice { get; set; }

        public bool forceAll { get; set; }

        public string filter { get; set; }

        public string filter_ignore { get; set; }

        public string sort { get; set; }

        public PidTorAuthTS base_auth { get; set; }

        public string[] torrs { get; set; }

        public List<PidTorAuthTS> auth_torrs { get; set; }

        public int group { get; set; }

        public bool group_hide { get; set; } = true;


        public PidTorSettings Clone()
        {
            return (PidTorSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }

    public class PidTorAuthTS
    {
        public bool enable { get; set; }

        public string host { get; set; }

        public string login { get; set; }

        public string passwd { get; set; }

        public string country { get; set; }

        public string no_country { get; set; }

        public Dictionary<string, string> headers { get; set; }
    }
}

```

## File: Shared/Models/Online/Settings/FilmixSettings.cs
```
Ôªøusing Newtonsoft.Json;
using Shared.Models.Base;

namespace Shared.Models.Online.Settings
{
    public class FilmixSettings : BaseSettings, ICloneable
    {
        public FilmixSettings(string plugin, string host, bool enable = true)
        {
            this.enable = enable;
            this.plugin = plugin;

            if (host != null)
                this.host = host.StartsWith("http") ? host : Decrypt(host);
        }

        public int hidefreeStart { get; set; } = 19;

        public int hidefreeEnd { get; set; } = 23;

        public string[] tokens { get; set; }

        public bool reserve { get; set; }

        public bool pro { get; set; }

        public bool livehash { get; set; }

        [JsonIgnore]
        public string token_apitv { get; set; }

        [JsonIgnore]
        public string hash_apitv { get; set; }

        public string user_apitv { get; set; }

        public string passwd_apitv { get; set; }


        public string APIKEY { get; set; }

        public string APISECRET { get; set; }

        public string user_name { get; set; }

        public string user_passw { get; set; }

        public string lowlevel_api_passw { get; set; }


        public FilmixSettings Clone()
        {
            return (FilmixSettings)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Online/Kodik/RootObject.cs
```
Ôªønamespace Shared.Models.Online.Kodik
{
    public class RootObject
    {
        public List<Result> results { get; set; }
    }
}

```

## File: Shared/Models/Online/Kodik/MaterialData.cs
```
Ôªønamespace Shared.Models.Online.Kodik
{
    public struct MaterialData
    {
        public string poster_url { get; set; }

        public string drama_poster_url { get; set; }

        public string anime_poster_url { get; set; }
    }
}

```

## File: Shared/Models/Online/Kodik/EmbedModel.cs
```
Ôªøusing Shared.Models.Templates;

namespace Shared.Models.Online.Kodik
{
    public class EmbedModel
    {
        public SimilarTpl? stpl { get; set; }

        public List<Result> result { get; set; }
    }
}

```

## File: Shared/Models/Online/Kodik/Result.cs
```
Ôªønamespace Shared.Models.Online.Kodik
{
    public struct Result
    {
        public string id { get; set; }

        public string title { get; set; }

        public string title_orig { get; set; }

        public string type { get; set; }

        public int? year { get; set; }

        public string link { get; set; }

        public string imdb_id { get; set; }

        public string kinopoisk_id { get; set; }

        public Translation translation { get; set; }

        public int last_season { get; set; }

        public Dictionary<string, Season> seasons { get; set; }


        public MaterialData material_data { get; set; }
    }
}

```

## File: Shared/Models/Online/Kodik/StreamModel.cs
```
Ôªønamespace Shared.Models.Online.Kodik
{
    public struct StreamModel
    {
        public string q { get; set; }

        public string url { get; set; }
    }
}

```

## File: Shared/Models/Online/Kodik/Translation.cs
```
Ôªønamespace Shared.Models.Online.Kodik
{
    public struct Translation
    {
        public string title { get; set; }
    }
}

```

## File: Shared/Models/Online/Kodik/Season.cs
```
Ôªønamespace Shared.Models.Online.Kodik
{
    public struct Season
    {
        public string link { get; set; }

        public Dictionary<string, string> episodes { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoCDN/VCDNSettings.cs
```
Ôªønamespace Shared.Models.Online.VideoCDN
{
    public class VCDNSettings
    {
        public VCDNSettings(string apihost, string token, string cdnhost, bool useproxy)
        {
            this.apihost = apihost;
            this.token = token;
            this.cdnhost = cdnhost;
            this.useproxy = useproxy;
        }


        public string apihost { get; set; }

        public string token { get; set; }

        public string cdnhost { get; set; }

        public bool useproxy { get; set; }

        public bool streamproxy { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoCDN/Folder.cs
```
Ôªønamespace Shared.Models.Online.VideoCDN
{
    public struct Folder
    {
        public string id { get; set; }

        public string file { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoCDN/SearchRoot.cs
```
Ôªønamespace Shared.Models.Online.VideoCDN
{
    public class SearchRoot
    {
        public Datum[] data { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoCDN/Datum.cs
```
Ôªønamespace Shared.Models.Online.VideoCDN
{
    public struct Datum
    {
        public int kp_id { get; set; }

        public string imdb_id { get; set; }

        public string title { get; set; }

        public string orig_title { get; set; }

        public string add { get; set; }

        public string content_type { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoCDN/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.VideoCDN
{
    public class EmbedModel
    {
        public string type { get; set; } = null!;

        public Dictionary<string, string> voices { get; set; }

        public Dictionary<string, HashSet<int>> voiceSeasons { get; set; }

        public Dictionary<string, List<Season>> serial { get; set; }

        public Dictionary<string, string> movie { get; set; }

        public string quality { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoCDN/Season.cs
```
Ôªønamespace Shared.Models.Online.VideoCDN
{
    public struct Season
    {
        public int id { get; set; }

        public Folder[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/Redheadsound/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Redheadsound
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public string iframe { get; set; }

        public string iframeUri { get; set; }
    }
}

```

## File: Shared/Models/Online/Lumex/Track.cs
```
Ôªønamespace Shared.Models.Online.Lumex
{
    public struct Track
    {
        public string src { get; set; }
        public string srlang { get; set; }
        public string label { get; set; }
    }
}

```

## File: Shared/Models/Online/Lumex/Medium.cs
```
Ôªønamespace Shared.Models.Online.Lumex
{
    public struct Medium
    {
        public int translation_id { get; set; }

        public string translation_name { get; set; }

        public int? max_quality { get; set; }

        public string playlist { get; set; }

        public string[] subtitles { get; set; }

        public Track[] tracks { get; set; }



        public int season_id { get; set; }

        public Episode[] episodes { get; set; }
    }
}

```

## File: Shared/Models/Online/Lumex/SearchRoot.cs
```
Ôªønamespace Shared.Models.Online.Lumex
{
    public class SearchRoot
    {
        public Datum[] data { get; set; }
    }
}

```

## File: Shared/Models/Online/Lumex/DatumDB.cs
```
Ôªønamespace Shared.Models.Online.Lumex
{
    public struct DatumDB
    {
        public long id { get; set; }

        public long kinopoisk_id { get; set; }

        public string imdb_id { get; set; }

        public string ru_title { get; set; }

        public string orig_title { get; set; }

        public string content_type { get; set; }

        public string year { get; set; }
    }
}

```

## File: Shared/Models/Online/Lumex/Datum.cs
```
Ôªønamespace Shared.Models.Online.Lumex
{
    public struct Datum
    {
        public long kp_id { get; set; }

        public string imdb_id { get; set; }

        public string title { get; set; }

        public string orig_title { get; set; }

        public string add { get; set; }

        public long id { get; set; }

        public string content_type { get; set; }
    }
}

```

## File: Shared/Models/Online/Lumex/Episode.cs
```
Ôªønamespace Shared.Models.Online.Lumex
{
    public struct Episode
    {
        public int episode_id { get; set; }

        public Medium[] media { get; set; }
    }
}

```

## File: Shared/Models/Online/Lumex/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Lumex
{
    public class EmbedModel
    {
        public string csrf { get; set; }

        public string tag_url { get; set; }

        public string content_type { get; set; }

        public Medium[] media { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoDB/RootObject.cs
```
Ôªønamespace Shared.Models.Online.VideoDB
{
    public struct RootObject
    {
        public string title { get; set; }

        public string file { get; set; }

        public string subtitle { get; set; }

        public Folder[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoDB/Folder.cs
```
Ôªønamespace Shared.Models.Online.VideoDB
{
    public struct Folder
    {
        public string title { get; set; }

        public Folder[] folder { get; set; }

        public string file { get; set; }
    }
}

```

## File: Shared/Models/Online/VideoDB/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.VideoDB
{
    public class EmbedModel
    {
        public RootObject[] pl { get; set; }

        public bool movie { get; set; }

        public bool obfuscation { get; set; }

        public string quality { get; set; }
    }
}

```

## File: Shared/Models/Online/Filmix/RootObject.cs
```
Ôªønamespace Shared.Models.Online.Filmix
{
    public class RootObject
    {
        public PlayerLinks player_links { get; set; }

        public string quality { get; set; }
    }
}

```

## File: Shared/Models/Online/Filmix/PlayerLinks.cs
```
Ôªøusing Newtonsoft.Json.Linq;

namespace Shared.Models.Online.Filmix
{
    public struct PlayerLinks
    {
        public Movie[] movie { get; set; }

        /// <summary>
        /// —Å–µ–∑–æ–Ω, (–æ–∑–≤—É—á–∫–∞, (—Å–µ—Ä–∏—è, item))
        /// </summary>
        public Dictionary<string, Dictionary<string, JToken>> playlist { get; set; }
    }
}

```

## File: Shared/Models/Online/Filmix/SearchResult.cs
```
Ôªøusing Shared.Models.Templates;

namespace Shared.Models.Online.Filmix
{
    public class SearchResult
    {
        public int id { get; set; }

        public SimilarTpl? similars { get; set; }
    }
}

```

## File: Shared/Models/Online/Filmix/SearchModel.cs
```
Ôªønamespace Shared.Models.Online.Filmix
{
    public class SearchModel
    {
        public int id { get; set; }

        public string title { get; set; }

        public string original_title { get; set; }

        /// <summary>
        /// api.filmix.tv
        /// </summary>
        public string original_name { get; set; }

        public string poster { get; set; }

        public int year { get; set; }
    }
}

```

## File: Shared/Models/Online/Filmix/Movie.cs
```
Ôªønamespace Shared.Models.Online.Filmix
{
    public struct Movie
    {
        public string link { get; set; }

        public string translation { get; set; }

        public int[] qualities { get; set; }
    }
}

```

## File: Shared/Models/Online/AniLibria/RootObject.cs
```
Ôªønamespace Shared.Models.Online.AniLibria
{
    public struct RootObject
    {
        public Names names { get; set; }

        public string code { get; set; }

        public Season season { get; set; }

        public Player player { get; set; }

        public Poster posters { get; set; }
    }
}

```

## File: Shared/Models/Online/AniLibria/Series.cs
```
Ôªønamespace Shared.Models.Online.AniLibria
{
    public struct Series
    {
        public int serie { get; set; }

        public Hls hls { get; set; }
    }
}

```

## File: Shared/Models/Online/AniLibria/Hls.cs
```
Ôªønamespace Shared.Models.Online.AniLibria
{
    public struct Hls
    {
        public string fhd { get; set; }

        public string hd { get; set; }

        public string sd { get; set; }
    }
}

```

## File: Shared/Models/Online/AniLibria/Names.cs
```
Ôªønamespace Shared.Models.Online.AniLibria
{
    public struct Names
    {
        public string ru { get; set; }

        public string en { get; set; }
    }
}

```

## File: Shared/Models/Online/AniLibria/Poster.cs
```
Ôªønamespace Shared.Models.Online.AniLibria
{
    public struct Poster
    {
        public Poster_url small { get; set; }

        public Poster_url medium { get; set; }

        public Poster_url original { get; set; }
    }

    public struct Poster_url
    {
        public string url { get; set; }
    }
}

```

## File: Shared/Models/Online/AniLibria/Player.cs
```
Ôªønamespace Shared.Models.Online.AniLibria
{
    public struct Player
    {
        public string host { get; set; }

        public Dictionary<string, Series> playlist { get; set; }
    }
}

```

## File: Shared/Models/Online/AniLibria/Season.cs
```
Ôªønamespace Shared.Models.Online.AniLibria
{
    public struct Season
    {
        public int year { get; set; }
    }
}

```

## File: Shared/Models/Online/Zetflix/RootObject.cs
```
Ôªønamespace Shared.Models.Online.Zetflix
{
    public struct RootObject
    {
        public string title { get; set; }

        public string file { get; set; }

        public Folder[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/Zetflix/Folder.cs
```
Ôªønamespace Shared.Models.Online.Zetflix
{
    public struct Folder
    {
        public string comment { get; set; }

        public string file { get; set; }
    }
}

```

## File: Shared/Models/Online/Zetflix/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Zetflix
{
    public class EmbedModel
    {
        public List<RootObject> pl { get; set; }

        public bool movie { get; set; }

        public string quality { get; set; }

        public string check_url { get; set; }
    }
}

```

## File: Shared/Models/Online/AnimeLib/Episode.cs
```
Ôªønamespace Shared.Models.Online.AnimeLib
{
    public struct Episode
    {
        public int id { get; set; }
        public string name { get; set; }
        public string number { get; set; }
        public string season { get; set; }
    }
}

```

## File: Shared/Models/Online/AnimeLib/Quality.cs
```
Ôªønamespace Shared.Models.Online.AnimeLib
{
    public struct Quality
    {
        public string href { get; set; }

        public int quality { get; set; }
    }
}

```

## File: Shared/Models/Online/AnimeLib/DataSearch.cs
```
Ôªønamespace Shared.Models.Online.AnimeLib
{
    public struct DataSearch
    {
        public string rus_name { get; set; }
        public string eng_name { get; set; }
        public string slug_url { get; set; }
        public string releaseDate { get; set; }
        public –°over cover { get; set; }
    }
}

```

## File: Shared/Models/Online/AnimeLib/Video.cs
```
Ôªønamespace Shared.Models.Online.AnimeLib
{
    public struct Video
    {
        public List<Quality> quality { get; set; }
    }
}

```

## File: Shared/Models/Online/AnimeLib/AnimeLibTokenState.cs
```
Ôªønamespace Shared.Models.Online.AnimeLib
{
    public class AnimeLibTokenState
    {
        public string token { get; set; }
        public string refresh_token { get; set; }
        public long refresh_time { get; set; }
    }
}

```

## File: Shared/Models/Online/AnimeLib/–°over.cs
```
Ôªønamespace Shared.Models.Online.AnimeLib
{
    public struct –°over
    {
        public string @default { get; set; }
    }
}

```

## File: Shared/Models/Online/AnimeLib/Player.cs
```
Ôªønamespace Shared.Models.Online.AnimeLib
{
    public struct Player
    {
        public string player { get; set; }

        public PlayerTeam team { get; set; }

        public Video video { get; set; }
    }

    public struct PlayerTeam
    {
        public string name { get; set; }
    }
}

```

## File: Shared/Models/Online/Kinobase/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Kinobase
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }
        public string errormsg { get; set; }


        public string content { get; set; }

        public Season[] serial { get; set; }

        public string quality { get; set; }
    }
}

```

## File: Shared/Models/Online/Kinobase/Playlist.cs
```
Ôªønamespace Shared.Models.Online.Kinobase
{
    public struct Playlist
    {
        public int id { get; set; }
        public string file { get; set; }
        public string comment { get; set; }
        public string title { get; set; }
        public string subtitle { get; set; }
    }
}

```

## File: Shared/Models/Online/Kinobase/SearchModel.cs
```
Ôªøusing Shared.Models.Templates;

namespace Shared.Models.Online.Kinobase
{
    public class SearchModel
    {
        public string link { get; set; }

        public SimilarTpl? similar { get; set; }
    }
}

```

## File: Shared/Models/Online/Kinobase/Season.cs
```
Ôªønamespace Shared.Models.Online.Kinobase
{
    public struct Season
    {
        public long id { get; set; }

        public string file { get; set; }

        public string title { get; set; }

        public string comment { get; set; }

        public string subtitle { get; set; }

        public Season[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/Rezka/MovieModel.cs
```
Ôªønamespace Shared.Models.Online.Rezka
{
    public class MovieModel
    {
        /// <summary>
        /// Rezka
        /// </summary>
        public List<ApiModel> links { get; set; }

        /// <summary>
        /// Voidboos
        /// </summary>
        public string url { get; set; }

        public string subtitlehtml { get; set; }
    }
}

```

## File: Shared/Models/Online/Rezka/Episodes.cs
```
Ôªønamespace Shared.Models.Online.Rezka
{
    public class Episodes
    {
        public string episodes { get; set; }

        public string seasons { get; set; }
    }
}

```

## File: Shared/Models/Online/Rezka/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Rezka
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public string content { get; set; }

        public string id { get; set; }

        public List<SimilarModel> similar { get; set; }
    }
}

```

## File: Shared/Models/Online/Rezka/SimilarModel.cs
```
Ôªønamespace Shared.Models.Online.Rezka
{
    public class SimilarModel
    {
        public SimilarModel(string title, string year, string href, string img)
        {
            this.title = title;
            this.year = year;
            this.href = href;
            this.img = img;
        }

        public string title { get; set; }

        public string year { get; set; }

        public string href { get; set; }

        public string img { get; set; }
    }
}

```

## File: Shared/Models/Online/Rezka/SearchModel.cs
```
Ôªønamespace Shared.Models.Online.Rezka
{
    public class SearchModel
    {
        public bool IsEmpty { get; set; }

        public string content { get; set; }

        public string href { get; set; }

        public string search_uri { get; set; }

        public List<SimilarModel> similar { get; set; }
    }
}

```

## File: Shared/Models/Online/PiTor/RootObject.cs
```
Ôªønamespace Shared.Models.Online.PiTor
{
    public class RootObject
    {
        public Result[] Results { get; set; }
    }
}

```

## File: Shared/Models/Online/PiTor/Info.cs
```
Ôªønamespace Shared.Models.Online.PiTor
{
    public struct Info
    {
        public string[] voices { get; set; }

        public string sizeName { get; set; }

        public int[] seasons { get; set; }
    }
}

```

## File: Shared/Models/Online/PiTor/FileStat.cs
```
Ôªønamespace Shared.Models.Online.PiTor
{
    public struct FileStat
    {
        public int Id { get; set; }

        public string Path { get; set; }

        public long Length { get; set; }
    }
}

```

## File: Shared/Models/Online/PiTor/Result.cs
```
Ôªønamespace Shared.Models.Online.PiTor
{
    public struct Result
    {
        public string Tracker { get; set; }
        public string Title { get; set; }
        public long? Size { get; set; }
        public int Seeders { get; set; }
        public string MagnetUri { get; set; }
        public Info info { get; set; }

        public DateTime PublishDate { get; set; }
    }
}

```

## File: Shared/Models/Online/PiTor/Stat.cs
```
Ôªønamespace Shared.Models.Online.PiTor
{
    public class Stat
    {
        public FileStat[] file_stats { get; set; }
    }
}

```

## File: Shared/Models/Online/Vibix/Seasons.cs
```
Ôªønamespace Shared.Models.Online.Vibix
{
    public struct Seasons
    {
        public string title { get; set; }
        public Seasons[] folder { get; set; }
        public string file { get; set; }
    }
}

```

## File: Shared/Models/Online/Vibix/Video.cs
```
Ôªønamespace Shared.Models.Online.Vibix
{
    public class Video
    {
        public string iframe_url { get; set; }

        public string type { get; set; }
    }
}

```

## File: Shared/Models/Online/Vibix/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Vibix
{
    public class EmbedModel
    {
        public Seasons[] playlist { get; set; }
    }
}

```

## File: Shared/Models/Online/Eneyida/BobrKurwa.cs
```
Ôªønamespace Shared.Models.Online.Eneyida
{
    public struct BobrKurwa
    {
        public string name { get; set; }

        public string eng_name { get; set; }

        public string year { get; set; }


        public string ashdi { get; set; }

        public string tortuga { get; set; }
    }
}

```

## File: Shared/Models/Online/Eneyida/Similar.cs
```
Ôªønamespace Shared.Models.Online.Eneyida
{
    public class Similar
    {
        public string title { get; set; }

        public string year { get; set; }

        public string href { get; set; }

        public string img { get; set; }
    }
}

```

## File: Shared/Models/Online/Eneyida/EmbedModel.cs
```
Ôªøusing Shared.Models.Online.Tortuga;

namespace Shared.Models.Online.Eneyida
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public string source_type { get; set; }

        public string content { get; set; }

        public string quel { get; set; }

        public Voice[] serial { get; set; }

        public Ashdi.Voice[] serial_ashdi { get; set; }

        public List<Similar> similars { get; set; }
    }
}

```

## File: Shared/Models/Online/Alloha/Episode.cs
```
Ôªønamespace Shared.Models.Online.Alloha
{
    public struct Episode
    {
        public int episode { get; set; }

        public Dictionary<string, Translation> translation { get; set; }
    }
}
```

## File: Shared/Models/Online/Alloha/FileQ.cs
```
Ôªønamespace Shared.Models.Online.Alloha
{
    public struct FileQ
    {
        public string h264 { get; set; }

        public string av1 { get; set; }
    }
}

```

## File: Shared/Models/Online/Alloha/Translation.cs
```
Ôªønamespace Shared.Models.Online.Alloha
{
    public struct Translation
    {
        public string translation { get; set; }
    }
}

```

## File: Shared/Models/Online/Plvideo/Profile.cs
```
Ôªønamespace Shared.Models.Online.Plvideo
{
    public struct Profile
    {
        public string hls { get; set; }
    }
}

```

## File: Shared/Models/Online/Plvideo/Item.cs
```
Ôªønamespace Shared.Models.Online.Plvideo
{
    public struct Item
    {
        public string id { get; set; }

        public string title { get; set; }

        public ItemuploadFile uploadFile { get; set; }

        public string visible { get; set; }
    }

    public struct ItemuploadFile
    {
        public long videoDuration { get; set; }
    }
}

```

## File: Shared/Models/Online/Ashdi/Series.cs
```
Ôªønamespace Shared.Models.Online.Ashdi
{
    public struct Series
    {
        public string title { get; set; }

        public string file { get; set; }

        public string subtitle { get; set; }
    }
}

```

## File: Shared/Models/Online/Ashdi/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Ashdi
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public string content { get; set; }

        public Voice[] serial { get; set; }
    }
}

```

## File: Shared/Models/Online/Ashdi/Voice.cs
```
Ôªønamespace Shared.Models.Online.Ashdi
{
    public struct Voice
    {
        public string title { get; set; }

        public Season[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/Ashdi/Season.cs
```
Ôªønamespace Shared.Models.Online.Ashdi
{
    public struct Season
    {
        public string title { get; set; }

        public Series[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/VoKino/RootObject.cs
```
Ôªønamespace Shared.Models.Online.VoKino
{
    public class RootObject
    {
        public –°hannel[] menu { get; set; }

        public –°hannel[] channels { get; set; }
    }
}

```

## File: Shared/Models/Online/VoKino/–°hannel.cs
```
Ôªønamespace Shared.Models.Online.VoKino
{
    public class –°hannel
    {
        public string title { get; set; }

        public string ident { get; set; }

        public string playlist_url { get; set; }

        public bool selected { get; set; }

        public –°hannel[] submenu { get; set; }


        public string stream_url { get; set; }

        public string quality_full { get; set; }

        public Dictionary<string, string> extra { get; set; }

        public Details details { get; set; }
    }
}

```

## File: Shared/Models/Online/VoKino/Similar.cs
```
Ôªønamespace Shared.Models.Online.VoKino
{
    public struct Similar
    {
        public string title { get; set; }

        public string balancer { get; set; }
    }
}

```

## File: Shared/Models/Online/VoKino/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.VoKino
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public –°hannel[] menu { get; set; }

        public –°hannel[] channels { get; set; }

        public List<Similar> similars { get; set; }
    }
}

```

## File: Shared/Models/Online/VoKino/Details.cs
```
Ôªønamespace Shared.Models.Online.VoKino
{
    public struct Details
    {
        public string id { get; set; }
    }
}

```

## File: Shared/Models/Online/VoKino/ViewOnline.cs
```
Ôªønamespace Shared.Models.Online.VoKino
{
    public class ViewOnline
    {
        public bool vokino { get; set; } = true;

        public bool filmix { get; set; } = true;

        public bool alloha { get; set; } = true;

        public bool hdvb { get; set; } = true;

        public bool remux { get; set; } = true;

        public bool monframe { get; set; } = true;

        public bool ashdi { get; set; } = true;

        public bool vibix { get; set; } = true;
    }
}

```

## File: Shared/Models/Online/Kinotochka/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Kinotochka
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public string content { get; set; }
    }
}

```

## File: Shared/Models/Online/Collaps/RootObject.cs
```
Ôªønamespace Shared.Models.Online.Collaps
{
    public struct RootObject
    {

        public int season { get; set; }

        public Episode[] episodes { get; set; }
    }
}

```

## File: Shared/Models/Online/Collaps/Cc.cs
```
Ôªønamespace Shared.Models.Online.Collaps
{
    public struct Cc
    {
        public string url { get; set; }

        public string name { get; set; }
    }
}

```

## File: Shared/Models/Online/Collaps/Episode.cs
```
Ôªønamespace Shared.Models.Online.Collaps
{
    public struct Episode
    {
        public string episode { get; set; }
        
        public string hls { get; set; }

        public string dasha { get; set; }
        public string dash { get; set; }

        public Cc[] cc { get; set; }

        public Audio audio { get; set; }
    }
}

```

## File: Shared/Models/Online/Collaps/Audio.cs
```
Ôªønamespace Shared.Models.Online.Collaps
{
    public struct Audio
    {
        public string[] names { get; set; }
    }
}

```

## File: Shared/Models/Online/Collaps/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Collaps
{
    public class EmbedModel
    {
        public string content { get; set; }

        public RootObject[] serial { get; set; }
    }
}

```

## File: Shared/Models/Online/Collaps/ResultSearch.cs
```
Ôªønamespace Shared.Models.Online.Collaps
{
    public struct ResultSearch
    {
        public int id { get; set; }

        public string name { get; set; }

        public string origin_name { get; set; }

        public int year { get; set; }

        public string poster { get; set; }
    }
}

```

## File: Shared/Models/Online/FanCDN/Episode.cs
```
Ôªønamespace Shared.Models.Online.FanCDN
{
    public struct Episode
    {
        public string title { get; set; }

        public string file { get; set; }

        public string subtitles { get; set; }


        public Dictionary<string, Episode> folder { get; set; }
    }
}

```

## File: Shared/Models/Online/FanCDN/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.FanCDN
{
    public class EmbedModel
    {
        public Episode[] movies { get; set; }

        public Voice[] serial { get; set; }
    }
}

```

## File: Shared/Models/Online/FanCDN/Voice.cs
```
Ôªønamespace Shared.Models.Online.FanCDN
{
    public struct Voice
    {
        public int id { get; set; }

        public string title { get; set; }

        public Dictionary<string, Episode> folder { get; set; }

        public int seasons { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/RootObject.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public class RootObject
    {
        public int status { get; set; }

        public Item item { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/SearchItem.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public struct SearchItem
    {
        public int id { get; set; }

        public string type { get; set; }

        public string title { get; set; }

        public string voice { get; set; }

        public long? kinopoisk { get; set; }

        public long? imdb { get; set; }

        public int year { get; set; }

        public Dictionary<string, string> posters { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Author.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public class Author
    {
        public int? id { get; set; }

        public string title { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Subtitle.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public struct Subtitle
    {
        public string lang { get; set; }

        public string url { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/SearchObject.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public class SearchObject
    {
        public SearchItem[] items { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Episode.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public struct Episode
    {
        public long id { get; set; }

        public int number { get; set; }

        public string title { get; set; }

        public Subtitle[] subtitles { get; set; }

        public File[] files { get; set; }

        public Audio[] audios { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Audio.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public class Audio
    {
        public int index { get; set; }

        public string lang { get; set; }

        public string codec { get; set; }

        public Author author { get; set; }

        public Author type { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Video.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public class Video
    {
        public long id { get; set; }

        public string title { get; set; }

        public Subtitle[] subtitles { get; set; }

        public File[] files { get; set; }

        public Audio[] audios { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Item.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public struct Item
    {
        public bool advert { get; set; }

        public int quality { get; set; }

        public string voice { get; set; }

        public Video[] videos { get; set; }

        public Season[] seasons { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Url.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public struct Url
    {
        public string http { get; set; }

        public string hls { get; set; }

        public string hls4 { get; set; }

        public string hls2 { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/SearchResult.cs
```
Ôªøusing Shared.Models.Templates;

namespace Shared.Models.Online.KinoPub
{
    public class SearchResult
    {
        public int id { get; set; }

        public SimilarTpl? similars { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/File.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public struct File
    {
        public string quality { get; set; }

        public string file { get; set; }

        public Url url { get; set; }
    }
}

```

## File: Shared/Models/Online/KinoPub/Season.cs
```
Ôªønamespace Shared.Models.Online.KinoPub
{
    public struct Season
    {
        public int number { get; set; }

        public Episode[] episodes { get; set; }
    }
}

```

## File: Shared/Models/Online/FilmixTV/RootObject.cs
```
Ôªøusing System.Text.Json.Serialization;

namespace Shared.Models.Online.FilmixTV
{
    public class RootObject
    {
        [JsonInclude]
        public Dictionary<string, Dictionary<string, Season>> SerialVoice { get; set; }

        [JsonInclude]
        public MovieTV[] Movies { get; set; }
    }
}

```

## File: Shared/Models/Online/FilmixTV/Serial.cs
```
Ôªønamespace Shared.Models.Online.FilmixTV
{
    public struct Season
    {
        public int season { get; set; }
        public Dictionary<string, Episode> episodes { get; set; }
    }

    public struct Episode
    {
        public int episode { get; set; }
        public File[] files { get; set; }
    }

    public struct File
    {
        public string url { get; set; }
        public int quality { get; set; }
    }
}

```

## File: Shared/Models/Online/FilmixTV/Movie.cs
```
Ôªønamespace Shared.Models.Online.FilmixTV
{
    public struct MovieTV
    {
        public File[] files { get; set; }
        public string voiceover { get; set; }
    }
}

```

## File: Shared/Models/Online/RutubeMovie/–°ategory.cs
```
Ôªønamespace Shared.Models.Online.RutubeMovie
{
    public struct –°ategory
    {
        public int id { get; set; }
    }
}

```

## File: Shared/Models/Online/RutubeMovie/Result.cs
```
Ôªønamespace Shared.Models.Online.RutubeMovie
{
    public struct Result
    {
        public string id { get; set; }

        public string title { get; set; }

        public long duration { get; set; }

        public –°ategory category { get; set; }

        public bool is_hidden { get; set; }
        public bool is_deleted { get; set; }
        public bool is_adult { get; set; }
        public bool is_locked { get; set; }
        public bool is_audio { get; set; }
        public bool is_paid { get; set; }
        public bool is_livestream { get; set; }
    }
}

```

## File: Shared/Models/Online/iRemux/Similar.cs
```
Ôªønamespace Shared.Models.Online.iRemux
{
    public class Similar
    {
        public string title { get; set; }

        public string year { get; set; }

        public string href { get; set; }
    }
}

```

## File: Shared/Models/Online/iRemux/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.iRemux
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public string content { get; set; }

        public List<Similar> similars { get; set; } = new List<Similar>(15);
    }
}

```

## File: Shared/Models/Online/VkMovie/CatalogVideo.cs
```
namespace Shared.Models.Online.VkMovie
{
    public class CatalogVideo
    {
        public Video video { get; set; }
    }
}

```

## File: Shared/Models/Online/VkMovie/VideoSubtitle.cs
```
namespace Shared.Models.Online.VkMovie
{
    public class VideoSubtitle
    {
        public string lang { get; set; }
        public string title { get; set; }
        public bool is_auto { get; set; }
        public string url { get; set; }
        public string manifest_name { get; set; }
    }
}

```

## File: Shared/Models/Online/VkMovie/Video.cs
```
namespace Shared.Models.Online.VkMovie
{
    public class Video
    {
        public long id { get; set; }
        public long owner_id { get; set; }
        public string title { get; set; }
        public string description { get; set; }
        public long duration { get; set; }
        public VideoFiles files { get; set; }
        public VideoSubtitle[] subtitles { get; set; }
    }
}

```

## File: Shared/Models/Online/VkMovie/VideoFiles.cs
```
namespace Shared.Models.Online.VkMovie
{
    public class VideoFiles
    {
        public string mp4_144 { get; set; }
        public string mp4_240 { get; set; }
        public string mp4_360 { get; set; }
        public string mp4_480 { get; set; }
        public string mp4_720 { get; set; }
        public string mp4_1080 { get; set; }
        public string mp4_1440 { get; set; }
        public string mp4_2160 { get; set; }
        public string hls { get; set; }
        public string hls_fmp4 { get; set; }
        public string hls_streams { get; set; }
        public string dash_sep { get; set; }
        public string dash_streams { get; set; }
        public string dash_webm { get; set; }
        public string failover_host { get; set; }
    }
}

```

## File: Shared/Models/Online/HDVB/Folder.cs
```
Ôªønamespace Shared.Models.Online.HDVB
{
    public struct Folder
    {
        public string id { get; set; }

        public string episode { get; set; }

        public Folder[] folder { get; set; }

        public string title { get; set; }

        public string file { get; set; }
    }
}

```

## File: Shared/Models/Online/VDBmovies/RootObject.cs
```
Ôªønamespace Shared.Models.Online.VDBmovies
{
    public class RootObject
    {
        public Dictionary<string, Movie> data { get; set; }
    }
}

```

## File: Shared/Models/Online/VDBmovies/Episode.cs
```
Ôªønamespace Shared.Models.Online.VDBmovies
{
    public struct Episode
    {
        public string title { get; set; }

        public string file { get; set; }

        public string subtitle { get; set; }

        public string subtitles { get; set; }
    }
}

```

## File: Shared/Models/Online/VDBmovies/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.VDBmovies
{
    public class EmbedModel
    {
        public Episode[] movies { get; set; }

        public CDNmovies.Voice[] serial { get; set; }

        public string quality { get; set; }
    }
}

```

## File: Shared/Models/Online/VDBmovies/MovieDB.cs
```
Ôªønamespace Shared.Models.Online.VDBmovies
{
    public struct MovieDB
    {
        public string id { get; set; }
        public string ru_title { get; set; }
        public string orig_title { get; set; }
        public string imdb_id { get; set; }
        public long? kinopoisk_id { get; set; }
        public int year { get; set; }
    }
}

```

## File: Shared/Models/Online/VDBmovies/Movie.cs
```
Ôªønamespace Shared.Models.Online.VDBmovies
{
    public struct Movie
    {
        public string iframe_src { get; set; }
    }
}

```

## File: Shared/Models/Online/Tortuga/Series.cs
```
Ôªønamespace Shared.Models.Online.Tortuga
{
    public struct Series
    {
        public string title { get; set; }

        public string file { get; set; }

        public string subtitle { get; set; }
    }
}

```

## File: Shared/Models/Online/Tortuga/EmbedModel.cs
```
Ôªønamespace Shared.Models.Online.Tortuga
{
    public class EmbedModel
    {
        public bool IsEmpty { get; set; }

        public string content { get; set; } = null!;

        public List<Voice> serial { get; set; }
    }
}

```

## File: Shared/Models/Online/Tortuga/Voice.cs
```
Ôªønamespace Shared.Models.Online.Tortuga
{
    public struct Voice
    {
        public string title { get; set; }

        public string season { get; set; }

        public Season[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/Tortuga/Season.cs
```
Ôªønamespace Shared.Models.Online.Tortuga
{
    public struct Season
    {
        public string title { get; set; }

        public string number { get; set; }

        public Series[] folder { get; set; }
    }
}

```

## File: Shared/Models/Online/VeoVeo/Movie.cs
```
Ôªønamespace Shared.Models.Online.VeoVeo
{
    public struct Movie
    {
        public long id { get; set; }

        public int year { get; set; }

        public long? kinopoiskId { get; set; }

        public string imdbId { get; set; }

        public string originalTitle { get; set; }

        public string title { get; set; }
    }
}

```

## File: Shared/Models/Events/EventsRecord.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json.Linq;
using Shared.Engine;
using Shared.Models.AppConf;
using Shared.Models.Base;
using Shared.Models.JacRed;
using Shared.Models.Online.Settings;
using System.Collections.ObjectModel;
using System.Net;
using System.Net.Http;
using System.Threading;
using System.Text.Json;

namespace Shared.Models.Events
{
    public record EventLoadKit(BaseSettings defaultinit, BaseSettings init, JObject userconf, RequestModel requestInfo, HybridCache hybridCache);

    public record EventMiddleware(RequestModel requestInfo, HttpRequest request, HttpContext httpContext, HybridCache hybridCache, IMemoryCache memoryCache);

    public record EventBadInitialization(BaseSettings init, bool? rch, RequestModel requestInfo, string host, HttpRequest request, HttpContext httpContext, HybridCache hybridCache);

    public record EventAppReplace(string source, string token, string arg, string host, RequestModel requestInfo, HttpRequest request, HybridCache hybridCache);

    public record EventExternalids(string id, string imdb_id, string kinopoisk_id, int serial);

    public record EventHybridCache(string key, string value, DateTimeOffset ex);

    public record EventRedApi(TorrentDetails torrent);

    public record EventPidTor(PidTorSettings init, RequestModel requestInfo, HybridCache hybridCache);

    public record EventHostStreamProxy(BaseSettings conf, string uri, List<HeadersModel> headers, WebProxy proxy, RequestModel requestInfo, HttpContext httpContext, HybridCache hybridCache);

    public record EventMyLocalIp(RequestModel requestInfo, HttpRequest request, HttpContext httpContext, HybridCache hybridCache);

    public record EventControllerHttpHeaders(string site, List<HeadersModel> headers, RequestModel requestInfo, HttpRequest request, HttpContext httpContext);

    public record EventStreamQuality(string link, string quality, bool prepend);

    public record EventStreamQualityFirts(IReadOnlyList<(string link, string quality)> data);

    public record EventHttpHandler(string url, HttpClientHandler handler, WebProxy proxy, CookieContainer cookieContainer, IMemoryCache memoryCache);

    public record EventHttpHeaders(string url, HttpRequestMessage client, string cookie, string referer, List<HeadersModel> headers, bool useDefaultHeaders, IMemoryCache memoryCache);

    public record EventHttpResponse(string url, HttpContent data, HttpClient client, string result, HttpResponseMessage response, IMemoryCache memoryCache);

    public record EventProxyApiCreateHttpRequest(string plugin, HttpRequest request, List<HeadersModel> headers, Uri uri, bool ismedia, HttpRequestMessage requestMessage);

    public record EventTranscoding(Collection<string> args, int? startNumber, TranscodingStartContext context);

    public record EventRchRegistry(string connectionId, string ip, string host, RchClientInfo info, NwsConnection connection);

    public record EventRchDisconnected(string connectionId);

    public record EventNwsConnected(string connectionId, string ip, RequestModel requestInfo, NwsConnection connection, CancellationToken token);

    public record EventNwsDisconnected(string connectionId);

    public record EventNwsMessage(string connectionId, string payload, string method, JsonElement args);
}

```

## File: Shared/Models/Events/EventsModel.cs
```
Ôªønamespace Shared.Models.Events
{
    public class EventsModel()
    {
        public string LoadKitInit { get; set; }

        public string LoadKit { get; set; }

        public string PidTor { get; set; }

        public string StreamQualityTpl { get; set; }

        public string StreamQualityFirts { get; set; }

        public EventModelMiddleware Middleware { get; set; }

        public EventModelController Controller { get; set; }

        public EventModelHttp Http { get; set; }

        public EventModelRedApi RedApi { get; set; }

        public EventModelHybridCache HybridCache { get; set; }

        public EventModelProxyApi ProxyApi { get; set; }

        public EventModelTranscoding Transcoding { get; set; }

        public EventModelRch Rch { get; set; }

        public EventModelNws Nws { get; set; }
    }

    public class EventModelController()
    {
        public string BadInitialization { get; set; }

        public EventModelAppReplace AppReplace { get; set; }

        public string Externalids { get; set; }

        public string HostStreamProxy { get; set; }

        public string MyLocalIp { get; set; }

        public string HttpHeaders { get; set; }
    }

    public class EventModelAppReplace()
    {
        public EventModelAppReplaceComand online { get; set; }

        public EventModelAppReplaceComand sisi { get; set; }

        public EventModelAppReplaceComand appjs { get; set; }

        public EventModelAppReplaceComand appcss { get; set; }
    }

    public class EventModelAppReplaceComand()
    {
        public Dictionary<string, string> list { get; set; }

        public Dictionary<string, string> regex { get; set; }

        public string eval { get; set; }
    }

    public class EventModelMiddleware()
    {
        public string first { get; set; }

        public string end { get; set; }
    }

    public class EventModelHttp()
    {
        public string Handler { get; set; }

        public string Headers { get; set; }

        public string Response { get; set; }
    }

    public class EventModelRedApi()
    {
        public string AddTorrents { get; set; }
    }

    public class EventModelHybridCache()
    {
        public string Read { get; set; }

        public string Write { get; set; }
    }

    public class EventModelProxyApi()
    {
        public string CreateHttpRequest { get; set; }
    }

    public class EventModelTranscoding()
    {
        public string CreateProcess { get; set; }
    }

    public class EventModelRch()
    {
        public string Registry { get; set; }

        public string Disconnected { get; set; }
    }

    public class EventModelNws()
    {
        public string Connected { get; set; }

        public string Disconnected { get; set; }

        public string Message { get; set; }
    }
}

```

## File: Shared/Models/CSharpGlobals/recordGlobals.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Shared.Engine;

namespace Shared.Models.CSharpGlobals
{
    public record CmdEvalModel(string key, string comand, RequestModel requestInfo, HttpRequest request, HybridCache hybridCache, IMemoryCache memoryCache);
}

```

## File: Shared/Models/CSharpGlobals/CatalogGlobals.cs
```
using HtmlAgilityPack;
using Microsoft.AspNetCore.Http;
using Newtonsoft.Json.Linq;
using Shared.Models.Catalog;

namespace Shared.Models.CSharpGlobals
{
    public record CatalogPlaylist(CatalogSettings init, string plugin, string host, string html, HtmlDocument doc, List<PlaylistItem> playlists);

    public record CatalogChangePlaylis(CatalogSettings init, string plugin, string host, string html, HtmlNodeCollection nodes, PlaylistItem pl, HtmlNode row);

    public record CatalogPlaylistJson(CatalogSettings init, string plugin, string host, string html, JToken json, List<PlaylistItem> playlists);

    public record CatalogChangePlaylisJson(CatalogSettings init, string plugin, string host, string html, IEnumerable<JToken> nodes, PlaylistItem pl, JToken row);

    public record CatalogGlobalsMenuRoute(string host, string plugin, string args, string url, string search, string cat, string sort, IQueryCollection query, int page);

    public record CatalogNodeValue(string value, string host);

    public record CatalogInitUrlCard(string host, string args, string uri, IQueryCollection query, string type);

    public record CatalogInitHeader(string url, List<HeadersModel> headers);
}

```

## File: Shared/Models/CSharpGlobals/OverrideResponseGlobals.cs
```
Ôªøusing Microsoft.AspNetCore.Http;

namespace Shared.Models.CSharpGlobals
{
    public class OverrideResponseGlobals
    {
        public OverrideResponseGlobals() { }

        public OverrideResponseGlobals(string url, HttpRequest rq, RequestModel rinfo)
        {
            request = rq;
            requestInfo = rinfo;
        }

        public string url { get; set; }

        public HttpRequest request { get; set; }

        public RequestModel requestInfo { get; set; }
    }
}

```

## File: Shared/Models/CSharpGlobals/NxtGlobals.cs
```
Ôªøusing HtmlAgilityPack;
using Microsoft.AspNetCore.Http;
using Microsoft.Playwright;
using Shared.Engine;
using Shared.Models.SISI.Base;
using Shared.Models.SISI.NextHUB;

namespace Shared.Models.CSharpGlobals
{
    public record NxtPlaylist(NxtSettings init, string plugin, string host, string html, HtmlDocument doc, List<PlaylistItem> playlists);

    public record NxtChangePlaylis(NxtSettings init, string plugin, string host, string html, HtmlNodeCollection nodes, PlaylistItem pl, HtmlNode row);

    public record NxtRoute(IRoute route, IQueryCollection query, string requestUrl, string search, string sort, string cat, string model, int page);

    public record NxtEvalView(NxtSettings init, IQueryCollection query, string html, string plugin, string url, string file, List<HeadersModel> headers, ProxyManager proxyManager);

    public record NxtRegexMatch(string html, RegexMatchSettings m);

    public record NxtMenuRoute(string host, string plugin, string url, string search, string cat, string sort, string model, IQueryCollection query, int page);

    public record NxtUrlRequest(string host, string plugin, string url, IQueryCollection query, bool related);

    public record NxtNodeValue(string value, string host);
}

```

## File: Shared/Models/ServerProxy/HlsCachePattern.cs
```
Ôªønamespace Shared.Models.ServerProxy
{
    public class HlsCachePattern
    {
        /// <summary>
        /// match
        /// replace
        /// </summary>
        public string type { get; set; }

        /// <summary>
        /// match[index]
        /// </summary>
        public int index { get; set; }

        public string pattern { get; set; }

        public string replacement { get; set; }
    }
}

```

## File: Shared/Models/ServerProxy/ServerproxyBufferingConf.cs
```
Ôªønamespace Shared.Models.ServerProxy
{
    public class ServerproxyBufferingConf
    {
        public bool enable { get; set; }

        public string pattern { get; set; }

        public int rent { get; set; }

        public int length { get; set; }
    }
}

```

## File: Shared/Models/ServerProxy/ServerproxyConf.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.ServerProxy
{
    public class ServerproxyConf : Iproxy
    {
        public bool enable { get; set; }

        public bool encrypt { get; set; }

        public bool encrypt_aes { get; set; }

        public bool verifyip { get; set; }

        public bool showOrigUri { get; set; }

        public bool responseContentLength { get; set; }

        public ServerproxyImageConf image { get; set; } = new ServerproxyImageConf();


        public bool forced_apn { get; set; }

        public ServerproxyBufferingConf buffering { get; set; } = new ServerproxyBufferingConf();

        public int maxlength_m3u { get; set; }

        public int maxlength_ts { get; set; }


        public bool useproxy { get; set; }

        public bool useproxystream { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }
    }
}

```

## File: Shared/Models/ServerProxy/HlsCacheConf.cs
```
Ôªønamespace Shared.Models.ServerProxy
{
    public class HlsCacheConf
    {
        public bool enable { get; set; }

        public string plugin { get; set; }

        public List<HlsCachePattern> tasks { get; set; }
    }
}

```

## File: Shared/Models/ServerProxy/ServerproxyImageConf.cs
```
Ôªøusing Shared.Models.Base;

namespace Shared.Models.ServerProxy
{
    public class ServerproxyImageConf : Iproxy
    {
        public bool cache { get; set; }

        public bool cache_rsize { get; set; }

        public int cache_time { get; set; }


        public bool useproxy { get; set; }

        public bool useproxystream { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }
    }
}

```

## File: Shared/Models/Base/CorseuRequest.cs
```
Ôªønamespace Shared.Models.Base
{
    public class CorseuRequest
    {
        public string browser { get; set; }

        public string url { get; set; }

        public string method { get; set; }

        public string data { get; set; }

        public int? httpversion { get; set; }

        public int? timeout { get; set; }

        public string encoding { get; set; }

        public Dictionary<string, string> headers { get; set; }

        public bool? defaultHeaders { get; set; }

        public bool? autoredirect { get; set; }

        public string proxy { get; set; }

        public string proxy_name { get; set; }

        public bool? headersOnly { get; set; }

        public string auth_token { get; set; }
    }
}

```

## File: Shared/Models/Base/UserSync.cs
```
Ôªøusing LiteDB;

namespace Shared.Models.Base
{
    public class UserSync
    {
        [BsonId]
        public string id { get; set; }

        public Dictionary<string, Dictionary<string, string>> timecodes { get; set; } = new Dictionary<string, Dictionary<string, string>>();
    }
}

```

## File: Shared/Models/Base/MediaRequest.cs
```
Ôªønamespace Shared.Models.Base
{
    public class MediaRequestBase
    {
        public string auth_token { get; set; }

        public string type { get; set; }

        public int? width { get; set; }

        public int? height { get; set; }

        public Dictionary<string, string> headers { get; set; }

        public string proxy { get; set; }

        public string proxy_name { get; set; }

        public bool apnstream { get; set; }

        public bool useproxystream { get; set; } = true;
    }

    public class MediaRequest : MediaRequestBase
    {
        public List<string> urls { get; set; } = new();
    }
}

```

## File: Shared/Models/Base/PosterApi.cs
```
Ôªøusing System.Text.RegularExpressions;

namespace Shared.Models.Base
{
    public static class PosterApi
    {
        static string omdbapi_key;
        static PosterApiConf init;
        static IProxyLink iproxy;

        public static void Initialization(string omdbkey, PosterApiConf conf, IProxyLink _iproxy)
        {
            omdbapi_key = omdbkey;
            init = conf;
            iproxy = _iproxy;
        }

        public static string Find(long? kpid, string imdb)
        {
            string imdb_img = null, kp_img = null;

            if (!string.IsNullOrEmpty(omdbapi_key) && !string.IsNullOrEmpty(imdb))
                imdb_img = $"https://img.omdbapi.com/?apikey={omdbapi_key}&i={imdb}";

            if (kpid > 0)
                kp_img = $"https://st.kp.yandex.net/images/film_iphone/iphone360_{kpid}.jpg";

            if (imdb_img != null && kp_img != null)
                return Size($"{imdb_img} or {kp_img}");

            return Size(imdb_img ?? kp_img);
        }

        public static string Size(string host, string uri)
        {
            if (string.IsNullOrEmpty(uri))
                return uri;

            string img = Size(uri);
            if (img.StartsWith("http"))
                return img;

            return host + img;
        }

        public static string Size(string uri)
        {
            if (string.IsNullOrEmpty(uri) || iproxy == null || init == null || !init.rsize || (init.width == 0 && init.height == 0))
                return uri?.Split(" or ")?[0];

            if (!string.IsNullOrEmpty(init.disable_rsize) && Regex.IsMatch(uri, init.disable_rsize, RegexOptions.IgnoreCase))
                return uri?.Split(" or ")?[0];

            if (!string.IsNullOrEmpty(init.bypass) && Regex.IsMatch(uri, init.bypass, RegexOptions.IgnoreCase))
                return $"{init.host}/proxyimg/{iproxy.Encrypt(uri, "posterapi")}";

            return $"{init.host}/proxyimg:{init.width}:{init.height}/{iproxy.Encrypt(uri, "posterapi")}";
        }
    }
}

```

## File: Shared/Models/Base/Igroup.cs
```
Ôªønamespace Shared.Models.Base
{
    public interface Igroup
    {
        public int group { get; set; }

        public bool group_hide { get; set; }
    }
}

```

## File: Shared/Models/Base/ProxySettings.cs
```
Ôªønamespace Shared.Models.Base
{
    public class ProxySettings : ICloneable
    {
        public string name;

        public string pattern;


        public bool useAuth;

        public bool BypassOnLocal;

        public string username;

        public string password;


        public string pattern_auth = "^(?<sheme>[^/]+//)?(?<username>[^:/]+):(?<password>[^@]+)@(?<host>.*)";

        public int maxRequestError = 2;


        public string file;

        public string url;

        public string[] list;


        public string refresh_uri;

        public List<ProxyAction> actions;

        public int actions_attempts = 6;


        public object Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Base/PosterApiConf.cs
```
Ôªønamespace Shared.Models.Base
{
    public class PosterApiConf : Iproxy
    {
        public string host { get; set; }

        public bool rsize { get; set; }

        public int height { get; set; }

        public int width { get; set; }


        /// <summary>
        /// –ü—Ä–æ–∫—Å–∏—Ç—å –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞
        /// </summary>
        public string bypass { get; set; }

        /// <summary>
        /// –ù–µ –ø—Ä–æ–∫—Å–∏—Ç—å
        /// </summary>
        public string disable_rsize { get; set; }


        #region proxy
        public bool useproxy { get; set; }

        public bool useproxystream { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }
        #endregion
    }
}

```

## File: Shared/Models/Base/BaseSettings.cs
```
Ôªøusing Newtonsoft.Json;

namespace Shared.Models.Base
{
    public class BaseSettings : Iproxy, Istreamproxy, Icors, Igroup, ICloneable
    {
        bool _enable;

        public bool enable 
        {
            get 
            {
                if (AppInit.conf.defaultOn == "enabled")
                    return enabled;

                return _enable;
            }
            set
            {
                _enable = value;
            }
        }

        public bool enabled { get; set; }

        public bool spider { get; set; } = true;


        public bool kit { get; set; } = true;

        public string plugin { get; set; }

        public int group { get; set; }

        public bool group_hide { get; set; } = true;

        public bool rhub { get; set; }

        public bool rhub_streamproxy { get; set; }

        public bool rhub_fallback { get; set; }

        public string[] rhub_geo_disable { get; set; }

        public string[] geo_hide { get; set; }

        public string client_type { get; set; }

        public bool rip { get; set; }

        public int cache_time { get; set; }

        public string displayname { get; set; }

        public int displayindex { get; set; }

        public string overridehost { get; set; }

        public string[] overridehosts { get; set; }

        public string overridepasswd { get; set; }

        public string host { get; set; }

        public string apihost { get; set; }

        public string scheme { get; set; }

        public bool hls { get; set; }

        public string cookie { get; set; }

        public string token { get; set; }

        [JsonProperty("headers",
            ObjectCreationHandling = ObjectCreationHandling.Replace,   // ‚Üê –∑–∞–º–µ–Ω–∏—Ç—å, –∞ –Ω–µ –¥–æ–ø–æ–ª–Ω—è—Ç—å
            NullValueHandling = NullValueHandling.Ignore               // ‚Üê –Ω–µ –∑–∞—Ç–∏—Ä–∞—Ç—å null-–æ–º
        )]
        public Dictionary<string, string> headers { get; set; }

        [JsonProperty("headers_stream",
            ObjectCreationHandling = ObjectCreationHandling.Replace,   // ‚Üê –∑–∞–º–µ–Ω–∏—Ç—å, –∞ –Ω–µ –¥–æ–ø–æ–ª–Ω—è—Ç—å
            NullValueHandling = NullValueHandling.Ignore               // ‚Üê –Ω–µ –∑–∞—Ç–∏—Ä–∞—Ç—å null-–æ–º
        )]
        public Dictionary<string, string> headers_stream { get; set; }

        public VastConf vast { get; set; }

        public string priorityBrowser { get; set; }


        #region proxy
        public bool useproxy { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }

        public bool useproxystream { get; set; }

        public bool streamproxy { get; set; }

        public bool apnstream { get; set; }

        public string[] geostreamproxy { get; set; }

        public ApnConf apn { get; set; }

        public bool qualitys_proxy { get; set; } = true;

        public bool url_reserve { get; set; }
        #endregion

        #region cors
        public bool corseu { get; set; }

        public string webcorshost { get; set; }

        public string corsHost()
        {
            string crhost = !string.IsNullOrWhiteSpace(webcorshost) ? webcorshost : corseu ? AppInit.conf.corsehost : null;
            if (string.IsNullOrWhiteSpace(crhost))
                return host;

            return $"{crhost}/{host}";
        }

        public string cors(string uri)
        {
            string crhost = !string.IsNullOrWhiteSpace(webcorshost) ? webcorshost : corseu ? AppInit.conf.corsehost : null;
            if (string.IsNullOrWhiteSpace(crhost) || string.IsNullOrWhiteSpace(uri) || uri.Contains(crhost))
                return uri;

            return $"{crhost}/{uri}";
        }
        #endregion


        public string Decrypt(string data)
        {
            try
            {
                if (data == null)
                    return data;

                char[] buffer = data.ToCharArray();
                for (int i = 0; i < buffer.Length; i++)
                {
                    char letter = buffer[i];
                    letter = (char)(letter - 3);
                    buffer[i] = letter;
                }

                return new string(buffer);
            }
            catch { return null; }
        }

        object ICloneable.Clone()
        {
            return MemberwiseClone();
        }
    }
}

```

## File: Shared/Models/Base/AccsUser.cs
```
Ôªønamespace Shared.Models.Base
{
    public class AccsUser
    {
        public string id { get; set; }

        public List<string> ids { get; set; } = new List<string>();

        public bool IsPasswd { get; set; }

        public DateTime expires { get; set; }

        public int group { get; set; }

        public bool ban { get; set; }

        public string ban_msg { get; set; }

        public string comment { get; set; }

        public Dictionary<string, object> @params { get; set; }
    }
}

```

## File: Shared/Models/Base/VastConf.cs
```
Ôªønamespace Shared.Models.Base
{
    public class VastConf
    {
        public VastConf() { }

        public VastConf(string url, string msg) 
        {
            this.url = url;
            this.msg = msg;
        }

        public string url { get; set; }

        public string msg { get; set; }

        /// <summary>
        /// ru,ua,kz,etc
        /// </summary>
        public string region { get; set; }

        /// <summary>
        /// 'android','noname','webos','tizen','apple','browser','nw','philips','orsay','apple_tv','netcast','electron'
        /// </summary>
        public string platform { get; set; }

        /// <summary>
        /// tv, mobile
        /// </summary>
        public string screen { get; set; }
    }
}

```

## File: Shared/Models/Base/IProxyLink.cs
```
Ôªønamespace Shared.Models.Base
{
    public interface IProxyLink
    {
        public string Encrypt(string uri, string plugin, DateTime ex = default);
    }
}

```

## File: Shared/Models/Base/Iproxy.cs
```
Ôªønamespace Shared.Models.Base
{
    public interface Iproxy
    {
        public bool useproxy { get; set; }

        public bool useproxystream { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }
    }
}

```

## File: Shared/Models/Base/ApnConf.cs
```
Ôªønamespace Shared.Models.Base
{
    public class ApnConf
    {
        public string host { get; set; }

        public string secure { get; set; }

        public string secret { get; set; }
    }
}

```

## File: Shared/Models/Base/Istreamproxy.cs
```
Ôªønamespace Shared.Models.Base
{
    public interface Istreamproxy
    {
        public bool rhub { get; set; }

        public bool rhub_streamproxy { get; set; }

        public bool useproxystream { get; set; }

        public bool streamproxy { get; set; }

        public bool apnstream { get; set; }

        public string[] geostreamproxy { get; set; }

        public bool qualitys_proxy { get; set; }

        public ProxySettings proxy { get; set; }

        public ApnConf apn { get; set; }
    }
}

```

## File: Shared/Models/Base/Icors.cs
```
Ôªønamespace Shared.Models.Base
{
    public interface Icors
    {
        public string host { get; set; }

        public bool corseu { get; set; }

        public string webcorshost { get; set; }


        public string corsHost();

        public string cors(string uri);
    }
}

```

## File: Shared/Models/Base/ProxyAction.cs
```
Ôªønamespace Shared.Models.Base
{
    public class ProxyAction
    {
        public string url;
        public string data;
        public string contains;

        public int timeoutSeconds = 5;
    }
}

```

## File: Shared/Models/Merchant/StreampayConf.cs
```
Ôªønamespace Shared.Models.Merchant
{
    public class StreampayConf
    {
        public bool enable { get; set; }

        public long store_id { get; set; }

        public string public_key { get; set; }

        public string private_key { get; set; }
    }
}

```

## File: Shared/Models/Merchant/MerchantsModel.cs
```
Ôªøusing Shared.Models.Merchant.LtcWallet;

namespace Shared.Models.Merchant
{
    public class MerchantsModel
    {
        public int accessCost { get; set; } = 2;

        public int accessForMonths { get; set; } = 1;

        public int allowedDifference { get; set; }

        public int defaultGroup { get; set; }

        public B2payConf B2PAY { get; set; } = new B2payConf();

        public CryptoCloudConf CryptoCloud { get; set; } = new CryptoCloudConf();

        public FreekassaConf FreeKassa { get; set; } = new FreekassaConf();

        public StreampayConf Streampay { get; set; } = new StreampayConf();

        public LtcWalletConf LtcWallet { get; set; } = new LtcWalletConf();
    }
}

```

## File: Shared/Models/Merchant/CryptoCloudConf.cs
```
Ôªønamespace Shared.Models.Merchant
{
    public class CryptoCloudConf
    {
        public bool enable { get; set; }

        public string SHOPID { get; set; }

        public string APIKEY { get; set; }

        public string SECRETKEY { get; set; }
    }
}

```

## File: Shared/Models/Merchant/B2payConf.cs
```
Ôªønamespace Shared.Models.Merchant
{
    public class B2payConf
    {
        public bool enable { get; set; }

        public bool sandbox { get; set; }

        public long username_id { get; set; }

        public string encryption_iv { get; set; }

        public string encryption_password { get; set; }
    }
}

```

## File: Shared/Models/Merchant/FreekassaConf.cs
```
Ôªønamespace Shared.Models.Merchant
{
    public class FreekassaConf
    {
        public bool enable { get; set; }

        public long shop_id { get; set; }

        public string secret { get; set; }
    }
}

```

## File: Shared/Models/Merchant/LtcWallet/Transaction.cs
```
Ôªønamespace Shared.Models.Merchant.LtcWallet
{
    public class Transaction
    {
        public string address { get; set; }

        public string category { get; set; }

        public double amount { get; set; }

        public string status { get; set; }

        public string txid { get; set; }
    }
}

```

## File: Shared/Models/Merchant/LtcWallet/LtcWalletConf.cs
```
Ôªønamespace Shared.Models.Merchant.LtcWallet
{
    public class LtcWalletConf
    {
        public bool enable { get; set; }

        public string rpc { get; set; } = "http://127.0.0.1:9332/";

        public string rpcuser { get; set; } = "ltc";

        public string rpcpassword { get; set; } = "ltc";
    }
}

```

## File: Shared/Models/Merchant/LtcWallet/RootTransactions.cs
```
Ôªønamespace Shared.Models.Merchant.LtcWallet
{
    public class RootTransactions
    {
        public List<Transaction> result { get; set; }
    }
}

```

## File: Shared/Models/SQL/HybridCacheContext.cs
```
Ôªøusing Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;

namespace Shared.Models.SQL
{
    public partial class HybridCacheContext
    {
        public static void Initialization() 
        {
            try
            {
                var sqlDb = new HybridCacheContext();
                    sqlDb.Database.EnsureCreated();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"HybridCacheDb initialization failed: {ex.Message}");
            }
        }
    }


    public partial class HybridCacheContext : DbContext
    {
        public DbSet<HybridCacheSqlModel> files { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlite("Data Source=cache/HybridCache.sql");
            optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<HybridCacheSqlModel>()
                        .HasIndex(j => j.ex);
        }
    }

    public class HybridCacheSqlModel
    {
        [Key]
        public string Id { get; set; }

        public DateTime ex { get; set; }

        public string value { get; set; }
    }
}

```

## File: Shared/Models/SQL/ExternalidsContext.cs
```
Ôªøusing Microsoft.Data.Sqlite;
using Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;
using System.Threading;

namespace Shared.Models.SQL
{
    public partial class ExternalidsContext
    {
        public static readonly SemaphoreSlim semaphore = new SemaphoreSlim(1, 1);

        public static void Initialization() 
        {
            try
            {
                var sqlDb = new ExternalidsContext();
                    sqlDb.Database.EnsureCreated();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"ExternalidsDb initialization failed: {ex.Message}");
            }
        }

        async public Task<int> SaveChangesLocks()
        {
            try
            {
                await semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                return await base.SaveChangesAsync();
            }
            catch
            {
                return 0;
            }
            finally
            {
                semaphore.Release();
            }
        }
    }


    public partial class ExternalidsContext : DbContext
    {
        public DbSet<ExternalidsSqlModel> imdb { get; set; }

        public DbSet<ExternalidsSqlModel> kinopoisk { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlite(new SqliteConnectionStringBuilder
            {
                DataSource = "cache/Externalids.sql",
                Cache = SqliteCacheMode.Shared,
                DefaultTimeout = 10,
                Pooling = true
            }.ToString());

            optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
        }
    }

    public class ExternalidsSqlModel
    {
        [Key]
        public string Id { get; set; }

        public string value { get; set; }
    }
}

```

## File: Shared/Models/SQL/SisiContext.cs
```
using Microsoft.Data.Sqlite;
using Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;
using System.Threading;

namespace Shared.Models.SQL
{
    public partial class SisiContext
    {
        public static readonly SemaphoreSlim semaphore = new SemaphoreSlim(1, 1);

        public static void Initialization() 
        {
            Directory.CreateDirectory("database");

            try
            {
                using (var sqlDb = new SisiContext())
                {
                    sqlDb.Database.EnsureCreated();

                    #region migrate historys table
                    try
                    {
                        using (var conn = sqlDb.Database.GetDbConnection())
                        {
                            conn.Open();
                            using (var cmd = conn.CreateCommand())
                            {
                                cmd.CommandText = "SELECT name FROM sqlite_master WHERE type='table' AND name='historys';";
                                var res = cmd.ExecuteScalar();
                                if (res == null)
                                {
                                    cmd.CommandText = @"CREATE TABLE IF NOT EXISTS historys (
                                                        Id INTEGER PRIMARY KEY AUTOINCREMENT,
                                                        user TEXT NOT NULL,
                                                        uid TEXT NOT NULL,
                                                        created TEXT,
                                                        json TEXT
                                                    );";
                                    cmd.ExecuteNonQuery();

                                    cmd.CommandText = "CREATE UNIQUE INDEX IF NOT EXISTS IX_historys_user_uid ON historys(user, uid);";
                                    cmd.ExecuteNonQuery();
                                }
                            }
                            conn.Close();
                        }
                    }
                    catch { }
                    #endregion
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"SisiDb initialization failed: {ex.Message}");
            }
        }

        async public Task<int> SaveChangesLocks()
        {
            try
            {
                await semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                return await base.SaveChangesAsync();
            }
            catch
            {
                return 0;
            }
            finally
            {
                semaphore.Release();
            }
        }
    }


    public partial class SisiContext : DbContext
    {
        public DbSet<SisiBookmarkSqlModel> bookmarks { get; set; }

        public DbSet<SisiHistorySqlModel> historys { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlite(new SqliteConnectionStringBuilder
            {
                DataSource = "database/Sisi.sql",
                Cache = SqliteCacheMode.Shared,
                DefaultTimeout = 10,
                Pooling = true
            }.ToString());

            optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<SisiBookmarkSqlModel>()
                        .HasIndex(b => new { b.user, b.uid })
                        .IsUnique();

            modelBuilder.Entity<SisiHistorySqlModel>()
                        .HasIndex(h => new { h.user, h.uid })
                        .IsUnique();
        }
    }

    public class SisiBookmarkSqlModel
    {
        [Key]
        public long Id { get; set; }

        [Required]
        public string user { get; set; }

        [Required]
        public string uid { get; set; }

        public DateTime created { get; set; }

        public string json { get; set; }

        public string name { get; set; }

        public string model { get; set; }
    }

    public class SisiHistorySqlModel
    {
        [Key]
        public long Id { get; set; }

        [Required]
        public string user { get; set; }

        [Required]
        public string uid { get; set; }

        public DateTime created { get; set; }

        public string json { get; set; }
    }
}

```

## File: Shared/Models/SQL/SyncUserContext.cs
```
Ôªøusing Microsoft.Data.Sqlite;
using Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Threading;

namespace Shared.Models.SQL
{
    public partial class SyncUserContext
    {
        public static readonly SemaphoreSlim semaphore = new SemaphoreSlim(1, 1);

        public static void Initialization() 
        {
            Directory.CreateDirectory("database");

            try
            {
                var sqlDb = new SyncUserContext();
                    sqlDb.Database.EnsureCreated();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"SyncUserDb initialization failed: {ex.Message}");
            }
        }

        async public Task<int> SaveChangesLocks()
        {
            try
            {
                await semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                return await base.SaveChangesAsync();
            }
            catch
            {
                return 0;
            }
            finally
            {
                semaphore.Release();
            }
        }
    }


    public partial class SyncUserContext : DbContext
    {
        public DbSet<SyncUserTimecodeSqlModel> timecodes { get; set; }

        public DbSet<SyncUserBookmarkSqlModel> bookmarks { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlite(new SqliteConnectionStringBuilder
            {
                DataSource = "database/SyncUser.sql",
                Cache = SqliteCacheMode.Shared,
                DefaultTimeout = 10,
                Pooling = true
            }.ToString());

            optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<SyncUserTimecodeSqlModel>()
                        .HasIndex(t => new { t.user, t.card, t.item })
                        .IsUnique();

            modelBuilder.Entity<SyncUserBookmarkSqlModel>()
                        .HasIndex(t => t.user)
                        .IsUnique();
        }
    }

    public class SyncUserTimecodeSqlModel
    {
        [Key]
        public long Id { get; set; }

        [Required]
        public string user { get; set; }

        [Required]
        public string card { get; set; }

        [Required]
        public string item { get; set; }

        public string data { get; set; }

        public DateTime updated { get; set; }
    }

    [Table("bookmarks")]
    public class SyncUserBookmarkSqlModel
    {
        [Key]
        public long Id { get; set; }

        [Required]
        public string user { get; set; }

        [Required]
        public string data { get; set; }

        public DateTime updated { get; set; }
    }
}

```

## File: Shared/Models/SQL/ProxyLinkContext.cs
```
Ôªøusing Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;

namespace Shared.Models.SQL
{
    public partial class ProxyLinkContext
    {
        public static ProxyLinkContext Read { get; private set; }

        public static void Initialization() 
        {
            try
            {
                var sqlDb = new ProxyLinkContext();
                    sqlDb.Database.EnsureCreated();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"ProxyLinkDb initialization failed: {ex.Message}");
            }
        }
    }


    public partial class ProxyLinkContext : DbContext
    {
        public DbSet<ProxyLinkSqlModel> links { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlite("Data Source=cache/ProxyLink.sql");
            optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<ProxyLinkSqlModel>()
                        .HasIndex(j => j.ex);
        }
    }

    public class ProxyLinkSqlModel
    {
        [Key]
        public string Id { get; set; }

        public DateTime ex { get; set; }

        public string json { get; set; }
    }
}

```

## File: Shared/Models/SQL/PlaywrightContext.cs
```
Ôªøusing Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;

namespace Shared.Models.SQL
{
    public partial class PlaywrightContext
    {
        public static void Initialization() 
        {
            try
            {
                var sqlDb = new PlaywrightContext();
                    sqlDb.Database.EnsureCreated();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"PlaywrightDb initialization failed: {ex.Message}");
            }
        }
    }


    public partial class PlaywrightContext : DbContext
    {
        public DbSet<PlaywrightSqlModel> files { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseSqlite("Data Source=cache/Playwright.sql");
            optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<ProxyLinkSqlModel>()
                        .HasIndex(j => j.ex);
        }
    }

    public class PlaywrightSqlModel
    {
        [Key]
        public string Id { get; set; }

        public DateTime ex { get; set; }

        public byte[] content { get; set; }

        public string headers { get; set; }
    }
}

```

## File: Shared/PlaywrightCore/Firefox.cs
```
Ôªøusing Microsoft.Playwright;
using Shared.Engine;
using Shared.Models.Browser;
using System.Runtime.InteropServices;
using System.Threading;

namespace Shared.PlaywrightCore
{
    public class Firefox : PlaywrightBase, IDisposable
    {
        #region static
        static List<KeepopenPage> pages_keepopen = new();

        public static long stats_keepopen { get; set; }

        public static long stats_newcontext { get; set; }

        static IPlaywright playwright = null;
        static IBrowser browser = null;

        static bool shutdown = false;

        public static PlaywrightStatus Status { get; private set; } = PlaywrightStatus.disabled;

        public static int ContextsCount => browser?.Contexts?.Count ?? 0;

        async public static Task CreateAsync()
        {
            try
            {
                var init = AppInit.conf.firefox;
                if (!init.enable || browser != null || shutdown)
                    return;

                string executablePath = init.executablePath;

                #region Download firefox
                if (string.IsNullOrEmpty(executablePath))
                {
                    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                    {
                        switch (RuntimeInformation.ProcessArchitecture)
                        {
                            case Architecture.X86:
                            case Architecture.X64:
                                {
                                    string camoufox = RuntimeInformation.ProcessArchitecture == Architecture.X64 ? "x86_64" : "i686";
                                    string uri = $"https://github.com/immisterio/playwright/releases/download/chrome/camoufox-135.0.1-beta.23-win.{camoufox}.zip";
                                    bool res = await DownloadFile(uri, ".playwright/firefox/release.zip", "firefox/");
                                    if (!res)
                                    {
                                        Console.WriteLine("Firefox: error download firefox.zip");
                                        return;
                                    }

                                    executablePath = ".playwright\\firefox\\camoufox.exe";
                                    break;
                                }
                            default:
                                Console.WriteLine("Firefox: Architecture unknown");
                                return;
                        }
                    }
                    else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
                    {
                        switch (RuntimeInformation.ProcessArchitecture)
                        {
                            case Architecture.X64:
                            case Architecture.Arm64:
                                {
                                    string camoufox = RuntimeInformation.ProcessArchitecture == Architecture.X64 ? "x86_64" : "arm64";
                                    string uri = $"https://github.com/immisterio/playwright/releases/download/chrome/camoufox-135.0.1-beta.23-mac.{camoufox}.zip";
                                    bool res = await DownloadFile(uri, ".playwright/camoufox.zip");
                                    if (!res)
                                    {
                                        Console.WriteLine("Firefox: error download camoufox.zip");
                                        return;
                                    }

                                    Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), ".playwright/Camoufox.app/Contents/MacOS/camoufox")}");
                                    executablePath = ".playwright/Camoufox.app/Contents/MacOS/camoufox";
                                    await Task.Delay(TimeSpan.FromSeconds(4));
                                    break;
                                }
                            default:
                                Console.WriteLine("Firefox: Architecture unknown");
                                return;
                        }
                    }
                    else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                    {
                        string camoufox = null;

                        switch (RuntimeInformation.ProcessArchitecture)
                        {
                            case Architecture.X86:
                                camoufox = "i686";
                                break;
                            case Architecture.X64:
                                camoufox = "x86_64";
                                break;
                            case Architecture.Arm64:
                                camoufox = "arm64";
                                break;
                            default:
                                Console.WriteLine("Firefox: Architecture unknown");
                                return;
                        }

                        if (camoufox != null)
                        {
                            string uri = $"https://github.com/immisterio/playwright/releases/download/chrome/camoufox-135.0.1-beta.23-lin.{camoufox}.zip";
                            bool res = await DownloadFile(uri, ".playwright/camoufox.zip", "firefox/");
                            if (!res)
                            {
                                Console.WriteLine("Firefox: error download camoufox.zip");
                                return;
                            }

                            Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), ".playwright/firefox/camoufox")}");
                            executablePath = ".playwright/firefox/camoufox";
                            await Task.Delay(TimeSpan.FromSeconds(4));
                        }
                    }
                    else
                    {
                        Console.WriteLine("Firefox: IsOSPlatform unknown");
                        return;
                    }
                }
                #endregion

                if (string.IsNullOrEmpty(executablePath))
                {
                    Console.WriteLine("Firefox: firefox is not installed, please specify full path in executablePath");
                    return;
                }

                Console.WriteLine("Firefox: Initialization");

                playwright = await Playwright.CreateAsync();

                Console.WriteLine("Firefox: CreateAsync");

                browser = await playwright.Firefox.LaunchAsync(new BrowserTypeLaunchOptions
                {
                    Headless = init.Headless,
                    ExecutablePath = executablePath,
                    Args = init.Args
                });

                Console.WriteLine("Firefox: LaunchAsync");

                Status = init.Headless ? PlaywrightStatus.headless : PlaywrightStatus.NoHeadless;
                Console.WriteLine($"Firefox: v{browser.Version} / {Status.ToString()} / {browser.IsConnected}");

                browser.Disconnected += Browser_Disconnected;
            }
            catch (Exception ex) 
            {
                Status = PlaywrightStatus.disabled;
                Console.WriteLine($"Firefox: {ex.Message}"); 
            }
        }

        async private static void Browser_Disconnected(object sender, IBrowser e)
        {
            Status = PlaywrightStatus.disabled;
            browser.Disconnected -= Browser_Disconnected;
            Console.WriteLine("Firefox: Browser_Disconnected");

            if (pages_keepopen != null)
                pages_keepopen.Clear();

            try
            {
                await browser.CloseAsync();
                await browser.DisposeAsync();
            }
            catch { }

            browser = null;

            try
            {
                playwright.Dispose();
            }
            catch { }

            playwright = null;
            pages_keepopen = new();
            await Task.Delay(TimeSpan.FromSeconds(10));
            await CreateAsync();
        }
        #endregion

        #region CronStart
        public static void CronStart()
        {
            _closeLifetimeTimer = new Timer(CronCloseLifetimeContext, null, TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1));
        }

        static Timer _closeLifetimeTimer;

        static bool _cronCloseLifetimeWork = false;
        #endregion

        #region CronCloseLifetimeContext
        async static void CronCloseLifetimeContext(object state)
        {
            if (!AppInit.conf.firefox.enable || Status == PlaywrightStatus.disabled)
                return;

            if (_cronCloseLifetimeWork)
                return;

            _cronCloseLifetimeWork = true;

            try
            {
                var init = AppInit.conf.firefox;
                if (0 >= init.context.keepalive)
                    return;

                foreach (var k in pages_keepopen.ToArray())
                {
                    if (Math.Max(1, init.context.min) >= pages_keepopen.Count)
                        break;

                    if (DateTime.Now > k.lastActive.AddMinutes(init.context.keepalive))
                    {
                        try
                        {
                            await k.page.CloseAsync().ConfigureAwait(false);
                            pages_keepopen.Remove(k);
                        }
                        catch { }
                    }
                }
            }
            catch { }
            finally
            {
                _cronCloseLifetimeWork = false;
            }
        }
        #endregion


        public bool IsCompleted { get; set; }

        public string failedUrl { get; set; }

        IPage page { get; set; }

        KeepopenPage keepopen_page { get; set; }


        async public Task<IPage> NewPageAsync(string plugin, Dictionary<string, string> headers = null, (string ip, string username, string password) proxy = default, bool keepopen = true)
        {
            try
            {
                if (browser == null)
                    return null;

                if (proxy != default)
                {
                    #region proxy NewContext
                    if (keepopen)
                    {
                        foreach (var pg in pages_keepopen.ToArray().Where(i => i.proxy != default))
                        {
                            if (pg.plugin == plugin)
                            {
                                if (pg.proxy.ip != proxy.ip || pg.proxy.username != proxy.username || pg.proxy.password != proxy.password)
                                {
                                    _ = pg.page.CloseAsync().ConfigureAwait(false);
                                    pages_keepopen.Remove(pg);
                                    continue;
                                }
                            }

                            if (pg.proxy.ip == proxy.ip && pg.proxy.username == proxy.username && pg.proxy.password == proxy.password)
                            {
                                stats_keepopen++;
                                pg.busy = true;
                                keepopen_page = pg;
                                page = pg.page;
                                page.RequestFailed += Page_RequestFailed;

                                if (headers != null && headers.Count > 0)
                                    await page.SetExtraHTTPHeadersAsync(headers).ConfigureAwait(false);

                                return page;
                            }
                        }
                    }

                    var contextOptions = new BrowserNewContextOptions
                    {
                        Proxy = new Proxy 
                        { 
                            Server = proxy.ip,
                            Bypass = "127.0.0.1",
                            Username = proxy.username,
                            Password = proxy.password
                        }
                    };

                    stats_newcontext++;
                    var context = await browser.NewContextAsync(contextOptions).ConfigureAwait(false);
                    page = await context.NewPageAsync().ConfigureAwait(false);
                    #endregion
                }
                else
                {
                    #region NewContext
                    if (keepopen)
                    {
                        foreach (var pg in pages_keepopen.Where(i => i.proxy == default))
                        {
                            if (pg.busy == false && DateTime.Now > pg.lockTo)
                            {
                                stats_keepopen++;
                                pg.busy = true;
                                keepopen_page = pg;
                                page = pg.page;
                                page.RequestFailed += Page_RequestFailed;

                                if (headers != null && headers.Count > 0)
                                    await page.SetExtraHTTPHeadersAsync(headers).ConfigureAwait(false);

                                return page;
                            }
                        }
                    }

                    stats_newcontext++;
                    page = await browser.NewPageAsync().ConfigureAwait(false);
                    #endregion
                }

                if (headers != null && headers.Count > 0)
                    await page.SetExtraHTTPHeadersAsync(headers).ConfigureAwait(false);

                page.Popup += Page_Popup;
                page.Download += Page_Download;

                if (!keepopen || !AppInit.conf.firefox.context.keepopen || pages_keepopen.Count >= Math.Max(AppInit.conf.firefox.context.min, AppInit.conf.firefox.context.max))
                {
                    page.RequestFailed += Page_RequestFailed;
                    return page;
                }

                keepopen_page = new KeepopenPage() { page = page, busy = true, plugin = plugin, proxy = proxy };
                pages_keepopen.Add(keepopen_page);
                page.RequestFailed += Page_RequestFailed;
                return page;
            }
            catch { return null; }
        }


        void Page_RequestFailed(object sender, IRequest e)
        {
            try
            {
                if (failedUrl != null && e.Url == failedUrl)
                {
                    completionSource.SetResult(null);
                    WebLog(e.Method, e.Url, "RequestFailed", default, e);
                }
            }
            catch { }
        }

        void Page_Download(object sender, IDownload e)
        {
            try
            {
                e.CancelAsync().ConfigureAwait(false);
            }
            catch { }
        }

        void Page_Popup(object sender, IPage e)
        {
            try
            {
                e.CloseAsync().ConfigureAwait(false);
            }
            catch { }
        }


        public void Dispose()
        {
            if (browser == null || AppInit.conf.firefox.DEV)
                return;

            try
            {
                page.RequestFailed -= Page_RequestFailed;

                if (keepopen_page != null)
                {
                    keepopen_page.page.GotoAsync("about:blank").ConfigureAwait(false);
                    keepopen_page.lastActive = DateTime.Now;
                    keepopen_page.lockTo = DateTime.Now.AddSeconds(1);
                    keepopen_page.busy = false;
                }
                else
                {
                    page.Popup -= Page_Popup;
                    page.Download -= Page_Download;
                    page.CloseAsync().ConfigureAwait(false);
                }
            }
            catch { }
        }

        public static void FullDispose()
        {
            shutdown = true;
            if (browser == null)
                return;

            try
            {
                browser.CloseAsync().ContinueWith(t => browser.DisposeAsync());
            }
            catch { }
        }
    }
}

```

## File: Shared/PlaywrightCore/Scraping.cs
```
Ôªøusing Shared.Engine;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.Text.RegularExpressions;
using Titanium.Web.Proxy;
using Titanium.Web.Proxy.EventArguments;
using Titanium.Web.Proxy.Http;
using Titanium.Web.Proxy.Models;

namespace Shared.PlaywrightCore
{
    public class Scraping : IDisposable
    {
        Process process;

        ExplicitProxyEndPoint explicitEndPoint;
        ProxyServer proxyServer;

        string patternUrl, headerKey;

        public bool IsCompleted { get; set; }

        public Action<SessionEventArgs> OnRequest { get; set; }

        public Action<SessionEventArgs> OnResponse { get; set; }


        public Scraping(string targetUrl, string patternUrl, string headerKey, string proxyBypassList = "*.example.com")
        {
            try
            {
                this.patternUrl = patternUrl;
                this.headerKey = headerKey;

                if (Chromium.Status != PlaywrightStatus.disabled)
                {
                    proxyServer = new ProxyServer();
                    proxyServer.BeforeRequest += Request;
                    proxyServer.BeforeResponse += Response;

                    if (!File.Exists("cache/titanium.pfx"))
                    {
                        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–æ—Ä–Ω–µ–≤–æ–π —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç (–µ—Å–ª–∏ –µ—â–µ –Ω–µ —Å–æ–∑–¥–∞–Ω)
                        if (proxyServer.CertificateManager.RootCertificate == null)
                            proxyServer.CertificateManager.CreateRootCertificate();

                        // –ü–æ–ª—É—á–∞–µ–º –∫–æ—Ä–Ω–µ–≤–æ–π —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç
                        X509Certificate2 rootCert = proxyServer.CertificateManager.RootCertificate;

                        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ PFX-—Ñ–∞–π–ª (—Å –ø–∞—Ä–æ–ª–µ–º)
                        byte[] certBytes = rootCert.Export(X509ContentType.Pkcs12, "35sd85454gfd");
                        File.WriteAllBytes("cache/titanium.pfx", certBytes);

                        certBytes = proxyServer.CertificateManager.RootCertificate.Export(X509ContentType.Cert);
                        File.WriteAllBytes("cache/titanium.crt", certBytes);
                    }

                    if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux) && !File.Exists("/usr/local/share/ca-certificates/lampac_titanium.crt"))
                    {
                        File.Copy("cache/titanium.crt", "/usr/local/share/ca-certificates/lampac_titanium.crt", true);
                        _ = Bash.Run("update-ca-certificates");
                    }

                    proxyServer.CertificateManager.LoadRootCertificate("cache/titanium.pfx", "35sd85454gfd");
                    proxyServer.ServerCertificateValidationCallback += OnCertificateValidation;

                    explicitEndPoint = new ExplicitProxyEndPoint(System.Net.IPAddress.Loopback, 0, true);
                    proxyServer.AddEndPoint(explicitEndPoint);
                    proxyServer.Start();

                    #region executablePath
                    string executablePath = AppInit.conf.chromium.executablePath;

                    if (string.IsNullOrEmpty(executablePath))
                    {
                        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                        {
                            if (RuntimeInformation.ProcessArchitecture == Architecture.Arm64)
                                executablePath = ".playwright\\chrome-win32\\chrome.exe";
                            else
                                executablePath = ".playwright\\chrome-win\\chrome.exe";
                        }
                        else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
                        {
                            executablePath = ".playwright/chrome-mac/Chromium.app/Contents/MacOS/Chromium";
                        }
                        else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                        {
                            executablePath = ".playwright/chrome-linux/chrome";
                        }
                    }

                    if (string.IsNullOrEmpty(executablePath) || !File.Exists(executablePath))
                        return;
                    #endregion

                    int proxyPort = explicitEndPoint.Port;

                    var startInfo = new ProcessStartInfo
                    {
                        FileName = executablePath,
                        UseShellExecute = false,
                        RedirectStandardOutput = true,
                        RedirectStandardError = true,
                        CreateNoWindow = false
                    };

                    startInfo.ArgumentList.Add($"--proxy-server=127.0.0.1:{proxyPort}");
                    startInfo.ArgumentList.Add($"--proxy-bypass-list=localhost;127.0.0.1;*.microsoft.com;{proxyBypassList}");
                    startInfo.ArgumentList.Add("--incognito");
                    startInfo.ArgumentList.Add("--ignore-certificate-errors");
                    startInfo.ArgumentList.Add("--ignore-ssl-errors");
                    startInfo.ArgumentList.Add("--disable-web-security");
                    startInfo.ArgumentList.Add("--no-first-run");
                    startInfo.ArgumentList.Add("--no-default-browser-check");
                    startInfo.ArgumentList.Add("--disable-background-mode");
                    startInfo.ArgumentList.Add("--no-sandbox");

                    if (AppInit.conf.chromium.Headless)
                    {
                        startInfo.ArgumentList.Add("--headless");
                        startInfo.ArgumentList.Add($"--user-agent=\"{Http.UserAgent}\"");
                    }

                    startInfo.ArgumentList.Add(targetUrl);

                    process = Process.Start(startInfo);
                    if (process == null)
                        return;
                }
            }
            catch { Dispose(); }
        }


        private Task Request(object sender, SessionEventArgs e)
        {
            try
            {
                var session = e.HttpClient.Request;

                if (IsCompleted)
                {
                    e.Ok(string.Empty);
                    return Task.CompletedTask;
                }

                if (session.Method == "GET" && !string.IsNullOrEmpty(patternUrl) && Regex.IsMatch(session.Url, patternUrl))
                {
                    IsCompleted = true;
                    completionSource.TrySetResult(session);
                    e.Ok(string.Empty);
                    return Task.CompletedTask;
                }

                if (!string.IsNullOrEmpty(headerKey))
                {
                    foreach (var header in session.Headers)
                    {
                        if (header.Name == headerKey)
                        {
                            IsCompleted = true;
                            completionSource.TrySetResult(session);
                            e.Ok(string.Empty);
                            return Task.CompletedTask;
                        }
                    }
                }

                if (AppInit.conf.chromium.consoleLog)
                {
                    Console.WriteLine("=== HTTP –ó–ê–ü–†–û–° ===");
                    Console.WriteLine($"URL: {session.Url}");
                    Console.WriteLine($"–ú–µ—Ç–æ–¥: {session.Method}");
                    Console.WriteLine("–ó–∞–≥–æ–ª–æ–≤–∫–∏:");
                    foreach (var header in session.Headers)
                        Console.WriteLine($"  {header.Name}: {header.Value}");
                    Console.WriteLine();
                }
            }
            catch { }

            OnRequest?.Invoke(e);
            return Task.CompletedTask;
        }

        private Task Response(object sender, SessionEventArgs e)
        {
            try
            {
                if (AppInit.conf.chromium.consoleLog)
                {
                    var session = e.HttpClient.Response;
                    Console.WriteLine("=== HTTP –û–¢–í–ï–¢ ===");
                    Console.WriteLine($"URL: {e.HttpClient.Request.Url}");
                    Console.WriteLine($"–°—Ç–∞—Ç—É—Å: {session.StatusCode} {session.StatusDescription}");
                    Console.WriteLine("–ó–∞–≥–æ–ª–æ–≤–∫–∏:");
                    foreach (var header in session.Headers)
                        Console.WriteLine($"  {header.Name}: {header.Value}");
                    Console.WriteLine();
                }

                OnResponse?.Invoke(e);
            }
            catch { }

            return Task.CompletedTask;
        }


        #region WaitPageResult
        TaskCompletionSource<Request> completionSource { get; set; } = new TaskCompletionSource<Request>();

        async public Task<Request> WaitPageResult(int seconds = 10)
        {
            try
            {
                if (proxyServer == null)
                    return null;

                var completionTask = completionSource.Task;
                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(seconds));

                var completedTask = await Task.WhenAny(completionTask, timeoutTask).ConfigureAwait(false);

                if (completedTask == completionTask)
                    return await completionTask;

                return null;
            }
            catch { return null; }
        }
        #endregion

        #region Dispose
        public void Dispose()
        {
            if (AppInit.conf.chromium.DEV)
                return;

            try
            {
                if (proxyServer != null)
                {
                    proxyServer.BeforeRequest -= Request;
                    proxyServer.BeforeResponse -= Response;
                    proxyServer.ServerCertificateValidationCallback -= OnCertificateValidation;

                    Task.Run(() =>
                    {
                        try
                        {
                            proxyServer.Stop();
                            proxyServer.Dispose();
                        }
                        catch { }
                        finally
                        {
                            proxyServer = null;
                        }
                    });
                }
            }
            catch { }

            try
            {
                if (process != null)
                {
                    Task.Run(() =>
                    {
                        try
                        {
                            process.Kill(true);
                            process.Close();
                            process.Dispose();
                        }
                        catch { }
                        finally
                        {
                            process = null;
                        }
                    });
                }
            }
            catch { }

            completionSource = null;
        }
        #endregion



        private Task OnCertificateValidation(object sender, CertificateValidationEventArgs e)
        {
            e.IsValid = true;
            return Task.CompletedTask;
        }
    }
}

```

## File: Shared/PlaywrightCore/PlaywrightBrowser.cs
```
Ôªøusing Microsoft.Playwright;
using Shared.Models;
using Shared.Models.Base;

namespace Shared.PlaywrightCore
{
    public class PlaywrightBrowser : IDisposable
    {
        public static PlaywrightStatus Status
        {
            get
            {
                if (Chromium.Status == PlaywrightStatus.NoHeadless || Firefox.Status != PlaywrightStatus.disabled)
                    return PlaywrightStatus.NoHeadless;

                if (Chromium.Status == PlaywrightStatus.headless)
                    return PlaywrightStatus.headless;

                return PlaywrightStatus.disabled;
            }
        }

        public bool IsCompleted
        {
            get
            {
                if (chromium != null)
                    return chromium.IsCompleted;

                return firefox.IsCompleted;
            }
        }

        public TaskCompletionSource<string> completionSource
        {
            get
            {
                if (chromium != null)
                    return chromium.completionSource;

                return firefox.completionSource;
            }
        }


        public Chromium chromium = null;

        public Firefox firefox = null;


        public PlaywrightBrowser(string priorityBrowser = null)
        {
            if (priorityBrowser == "firefox" && Firefox.Status != PlaywrightStatus.disabled)
            {
                firefox = new Firefox();
                return;
            }

            chromium = new Chromium();
        }

        public void SetFailedUrl(string url)
        {
            if (chromium != null)
            {
                chromium.failedUrl = url;
            }
            else
            {
                firefox.failedUrl = url;
            }
        }

        async public Task<IPage> NewPageAsync(string plugin, Dictionary<string, string> headers = null, (string ip, string username, string password) proxy = default, bool keepopen = true, bool imitationHuman = false, bool deferredDispose = false)
        {
            try
            {
                if (chromium == null && firefox == null)
                    return default;

                IPage page = default;

                if (chromium != null)
                    page = await chromium.NewPageAsync(plugin, headers, proxy, keepopen: keepopen, imitationHuman: imitationHuman, deferredDispose: deferredDispose).ConfigureAwait(false);
                else
                    page = await firefox.NewPageAsync(plugin, headers, proxy, keepopen: keepopen).ConfigureAwait(false);

                return page;
            }
            catch { return default; }
        }


        public void SetPageResult(in string val)
        {
            try
            {
                if (chromium != null)
                {
                    chromium.IsCompleted = true;
                    chromium.completionSource.SetResult(val);
                }
                else
                {
                    firefox.IsCompleted = true;
                    firefox.completionSource.SetResult(val);
                }
            }
            catch { }
        }

        public Task<string> WaitPageResult(int seconds = 10)
        {
            try
            {
                if (chromium != null)
                    return chromium.WaitPageResult(seconds);

                return firefox.WaitPageResult(seconds);
            }
            catch { return default; }
        }


        public Task WaitForAnySelectorAsync(IPage page, params string[] selectors)
        {
            var tasks = selectors.Select(selector =>
                page.WaitForSelectorAsync(selector)
            ).ToArray();

            return Task.WhenAny(tasks);
        }


        async public Task ClearContinueAsync(IRoute route, IPage page)
        {
            var cookies = await page.Context.CookiesAsync();
            if (cookies == null || cookies.Count == 0)
            {
                // –Ω–µ—Ç—É –∫—É–∫–∏, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
                await route.ContinueAsync();
                return;
            }

            var filteredCookies = cookies.Where(c => c.Name != "cf_clearance").Select(c => new Cookie
            {
                Name = c.Name,
                Value = c.Value,
                Domain = c.Domain,
                Path = c.Path,
                Expires = c.Expires,
                HttpOnly = c.HttpOnly,
                Secure = c.Secure,
                SameSite = c.SameSite
            }).ToList();

            if (filteredCookies.Count == cookies.Count)
            {
                // –ï—Å–ª–∏ –∫—É–∫–∏ –Ω–µ —Å–æ–¥–µ—Ä–∂–∞—Ç cf_clearance, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
                await route.ContinueAsync();
                return;
            }

            if (filteredCookies.Count == 0)
            {
                // –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è cf_clearance –Ω–µ –æ—Å—Ç–∞–ª–æ—Å—å –¥—Ä—É–≥–∏—Ö –∫—É–∫–∏
                await page.Context.ClearCookiesAsync();
                await route.ContinueAsync();
                return;
            }

            await page.Context.ClearCookiesAsync();
            await page.Context.AddCookiesAsync(filteredCookies);

            await route.ContinueAsync();
        }


        public void Dispose()
        {
            chromium?.Dispose();
            firefox?.Dispose();
        }




        async public static ValueTask<string> Get(BaseSettings init, string url, List<HeadersModel> headers = null, (string ip, string username, string password) proxy = default, List<Cookie> cookies = null)
        {
            try
            {
                using (var browser = new PlaywrightBrowser(init?.priorityBrowser))
                {
                    var page = await browser.NewPageAsync(init?.plugin, headers?.ToDictionary(), proxy).ConfigureAwait(false);
                    if (page == null)
                        return null;

                    if (cookies != null)
                        await page.Context.AddCookiesAsync(cookies).ConfigureAwait(false);

                    IResponse response = default;

                    if (browser.firefox != null)
                    {
                        response = await page.GotoAsync(url, new PageGotoOptions() { WaitUntil = WaitUntilState.DOMContentLoaded }).ConfigureAwait(false);
                    }
                    else
                    {
                        response = await page.GotoAsync($"view-source:{url}", new PageGotoOptions()
                        {
                            Timeout = 10_000,
                            WaitUntil = WaitUntilState.DOMContentLoaded
                        }).ConfigureAwait(false);
                    }

                    if (response != null)
                    {
                        string result = await response.TextAsync().ConfigureAwait(false);
                        PlaywrightBase.WebLog(response.Request, response, result, proxy);

                        return result;
                    }
                }
            }
            catch { }

            return null;
        }
    }
}

```

## File: Shared/PlaywrightCore/Chromium.cs
```
Ôªøusing Microsoft.Playwright;
using Shared.Engine;
using Shared.Models.Browser;
using System.Runtime.InteropServices;
using System.Threading;

namespace Shared.PlaywrightCore
{
    public class Chromium : PlaywrightBase, IDisposable
    {
        #region static
        public static BrowserNewContextOptions baseContextOptions = new BrowserNewContextOptions
        {
            UserAgent = Http.UserAgent,
            ExtraHTTPHeaders = new Dictionary<string, string>(Http.defaultHeaders)
            {
                ["accept-language"] = "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"
            }
        };

        static List<KeepopenPage> pages_keepopen = new();

        static IBrowserContext keepopen_context { get; set; }

        static DateTime create_keepopen_context { get; set; }

        public static long stats_keepopen { get; set; }

        public static long stats_newcontext { get; set; }

        public static (DateTime time, int status, string ex) stats_ping { get; set; }


        public static IPlaywright playwright { get; private set; } = null;

        static IBrowser browser = null;

        static bool shutdown = false;

        public static PlaywrightStatus Status { get; private set; } = PlaywrightStatus.disabled;

        public static int ContextsCount => browser?.Contexts?.Count ?? 0;

        async public static Task CreateAsync()
        {
            try
            {
                var init = AppInit.conf.chromium;
                if (!init.enable || browser != null || shutdown)
                    return;

                string executablePath = init.executablePath;

                #region Download chromium
                if (string.IsNullOrEmpty(executablePath))
                {
                    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                    {
                        switch (RuntimeInformation.ProcessArchitecture)
                        {
                            case Architecture.X86:
                            case Architecture.X64:
                            case Architecture.Arm64:
                                {
                                    string uri = $"https://github.com/immisterio/playwright/releases/download/chrome/chrome-win-{RuntimeInformation.ProcessArchitecture.ToString().ToLower()}.zip";
                                    bool res = await DownloadFile(uri, ".playwright/chrome.zip");
                                    if (!res)
                                    {
                                        Console.WriteLine("Chromium: error download chrome.zip");
                                        return;
                                    }

                                    if (RuntimeInformation.ProcessArchitecture == Architecture.Arm64)
                                        executablePath = ".playwright\\chrome-win32\\chrome.exe";
                                    else
                                        executablePath = ".playwright\\chrome-win\\chrome.exe";
                                    break;
                                }
                            default:
                                Console.WriteLine("Chromium: Architecture unknown");
                                return;
                        }
                    }
                    else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
                    {
                        switch (RuntimeInformation.ProcessArchitecture)
                        {
                            case Architecture.X64:
                            case Architecture.Arm64:
                                {
                                    string uri = $"https://github.com/immisterio/playwright/releases/download/chrome/chrome-mac-{RuntimeInformation.ProcessArchitecture.ToString().ToLower()}.zip";
                                    bool res = await DownloadFile(uri, ".playwright/chrome.zip");
                                    if (!res)
                                    {
                                        Console.WriteLine("Chromium: error download chrome.zip");
                                        return;
                                    }

                                    Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), ".playwright/chrome-mac/Chromium.app/Contents/MacOS/Chromium")}");
                                    executablePath = ".playwright/chrome-mac/Chromium.app/Contents/MacOS/Chromium";
                                    await Task.Delay(TimeSpan.FromSeconds(4));
                                    break;
                                }
                            default:
                                Console.WriteLine("Chromium: Architecture unknown");
                                return;
                        }
                    }
                    else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                    {
                        switch (RuntimeInformation.ProcessArchitecture)
                        {
                            case Architecture.X86:
                            case Architecture.X64:
                                {
                                    string uri = $"https://github.com/immisterio/playwright/releases/download/chrome/chrome-linux-{RuntimeInformation.ProcessArchitecture.ToString().ToLower()}.zip";
                                    bool res = await DownloadFile(uri, ".playwright/chrome.zip");
                                    if (!res)
                                    {
                                        Console.WriteLine("Chromium: error download chrome.zip");
                                        return;
                                    }

                                    Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), ".playwright/chrome-linux/chrome")}");
                                    executablePath = ".playwright/chrome-linux/chrome";
                                    await Task.Delay(TimeSpan.FromSeconds(4));
                                    break;
                                }
                            default:
                                Console.WriteLine("PlaywChromiumright: Architecture unknown");
                                return;
                        }
                    }
                    else
                    {
                        Console.WriteLine("Chromium: IsOSPlatform unknown");
                        return;
                    }
                }
                #endregion

                if (string.IsNullOrEmpty(executablePath))
                {
                    Console.WriteLine("Chromium: chromium is not installed, please specify full path in executablePath");
                    return;
                }

                Console.WriteLine("Chromium: Initialization");

                playwright = await Playwright.CreateAsync();

                Console.WriteLine("Chromium: CreateAsync");

                browser = await playwright.Chromium.LaunchAsync(new BrowserTypeLaunchOptions
                {
                    Headless = init.Headless,
                    ExecutablePath = executablePath,
                    Args = init.Args,
                    Devtools = init.Devtools
                });

                Console.WriteLine("Chromium: LaunchAsync");

                Status = init.Headless ? PlaywrightStatus.headless : PlaywrightStatus.NoHeadless;
                Console.WriteLine($"Chromium: v{browser.Version} / {Status.ToString()} / {browser.IsConnected}");

                if (AppInit.conf.chromium.context.keepopen)
                {
                    create_keepopen_context = DateTime.Now;
                    var kpc = await browser.NewContextAsync(baseContextOptions);
                    await kpc.NewPageAsync();
                    keepopen_context = kpc;
                }
            }
            catch (Exception ex) 
            {
                Status = PlaywrightStatus.disabled;
                Console.WriteLine($"Chromium: {ex.Message}"); 
            }
        }
        #endregion

        #region CronStart
        public static void CronStart()
        {
            _closeLifetimeTimer = new Timer(CronCloseLifetimeContext, null, TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1));
            _browserDisconnectedTimer = new Timer(CronBrowserDisconnected, null, TimeSpan.FromMinutes(2), TimeSpan.FromMinutes(1));
        }

        static Timer _closeLifetimeTimer, _browserDisconnectedTimer;

        static bool _cronCloseLifetimeWork = false, _cronBrowserDisconnectedWork = false;
        #endregion

        #region CronCloseLifetimeContext
        async static void CronCloseLifetimeContext(object state)
        {
            if (!AppInit.conf.chromium.enable || Status == PlaywrightStatus.disabled)
                return;

            if (_cronCloseLifetimeWork)
                return;

            _cronCloseLifetimeWork = true;

            try
            {
                var init = AppInit.conf.chromium;
                if (!init.context.keepopen || 0 >= init.context.keepalive)
                    return;

                if (DateTime.Now.AddMinutes(-init.context.keepalive) > create_keepopen_context)
                {
                    create_keepopen_context = DateTime.Now;
                    var kpc = await browser.NewContextAsync(baseContextOptions);
                    await kpc.NewPageAsync();

                    try
                    {
                        _ = keepopen_context.CloseAsync().ConfigureAwait(false);
                    }
                    catch { }

                    keepopen_context = kpc;
                }

                if (pages_keepopen.Count > 0 && pages_keepopen.Count > init.context.min)
                {
                    foreach (var k in pages_keepopen.ToArray())
                    {
                        if (init.context.min >= pages_keepopen.Count)
                            break;

                        if (DateTime.Now.AddMinutes(-init.context.keepalive) > k.create)
                        {
                            try
                            {
                                if (pages_keepopen.Remove(k))
                                {
                                    await Task.Delay(TimeSpan.FromSeconds(20));
                                    await k.context.CloseAsync();
                                }
                            }
                            catch { }
                        }
                    }
                }
            }
            catch { }
            finally
            {
                _cronCloseLifetimeWork = false;
            }
        }
        #endregion

        #region CronBrowserDisconnected
        async static void CronBrowserDisconnected(object state)
        {
            if (!AppInit.conf.chromium.enable)
                return;

            if (_cronBrowserDisconnectedWork)
                return;

            _cronBrowserDisconnectedWork = true;

            try
            {
                stats_ping = (DateTime.Now, 1, null);
                if (shutdown)
                    return;

                stats_ping = (DateTime.Now, 2, null);

                if ((AppInit.conf.multiaccess || AppInit.conf.chromium.Headless) && Status != PlaywrightStatus.disabled)
                {
                    try
                    {
                        stats_ping = (DateTime.Now, 3, null);
                        if (AppInit.conf.multiaccess == false && keepopen_context == null)
                            return;

                        stats_ping = (DateTime.Now, 4, null);
                        if (browser == null && keepopen_context == null)
                            return;

                        bool isOk = false;

                        try
                        {
                            stats_ping = (DateTime.Now, 5, null);
                            IPage p = keepopen_context != null ? await keepopen_context.NewPageAsync() : await browser.NewPageAsync();
                            if (p != null)
                            {
                                try
                                {
                                    var options = new PageGotoOptions
                                    {
                                        Timeout = 5000, // 5 —Å–µ–∫—É–Ω–¥
                                        WaitUntil = WaitUntilState.DOMContentLoaded
                                    };

                                    var r = await p.GotoAsync($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/api/chromium/ping", options);
                                    if (r != null)
                                    {
                                        stats_ping = (DateTime.Now, r.Status, null);
                                        if (r.Status == 200)
                                            isOk = true;
                                    }
                                }
                                finally
                                {
                                    await p.CloseAsync();
                                }
                            }
                        }
                        catch
                        {
                            stats_ping = (DateTime.Now, 500, null);
                        }

                        if (!isOk)
                        {
                            Console.WriteLine("\nChromium: Browser_Disconnected");

                            Status = PlaywrightStatus.disabled;

                            keepopen_context = null;

                            if (pages_keepopen != null)
                                pages_keepopen.Clear();

                            try
                            {
                                if (browser != null)
                                {
                                    await browser.CloseAsync();
                                    await browser.DisposeAsync();
                                }
                            }
                            catch { }

                            try
                            {
                                playwright.Dispose();
                            }
                            catch { }

                            browser = null;
                            playwright = null;

                            await CreateAsync();
                        }
                    }
                    catch (Exception ex)
                    {
                        stats_ping = (DateTime.Now, -1, ex.Message);
                        Console.WriteLine(ex.Message);
                    }
                }
            }
            catch { }
            finally
            {
                _cronBrowserDisconnectedWork = false;
            }
        }
        #endregion


        public bool IsCompleted { get; set; }

        bool imitationHuman { get; set; }

        bool deferredDispose { get; set; }

        public string failedUrl { get; set; }

        IPage page { get; set; }

        IBrowserContext context { get; set; }

        KeepopenPage keepopen_page { get; set; }


        async public Task<IPage> NewPageAsync(string plugin, Dictionary<string, string> headers = null, (string ip, string username, string password) proxy = default, bool keepopen = true, bool imitationHuman = false, bool deferredDispose = false)
        {
            try
            {
                if (browser == null)
                    return null;

                this.imitationHuman = imitationHuman;
                this.deferredDispose = deferredDispose;

                if (proxy != default)
                {
                    #region NewPageAsync
                    if (keepopen)
                    {
                        foreach (var pg in pages_keepopen.ToArray())
                        {
                            if (pg.plugin == plugin)
                            {
                                if (pg.proxy.ip != proxy.ip || pg.proxy.username != proxy.username || pg.proxy.password != proxy.password)
                                {
                                    _ = pg.context.CloseAsync().ConfigureAwait(false);
                                    pages_keepopen.Remove(pg);
                                    continue;
                                }
                            }

                            if (pg.proxy.ip == proxy.ip && pg.proxy.username == proxy.username && pg.proxy.password == proxy.password)
                            {
                                stats_keepopen++;
                                keepopen_page = pg;
                                await ClearCookie(pg.context).ConfigureAwait(false);
                                page = await pg.context.NewPageAsync().ConfigureAwait(false);
                                break;
                            }
                        }
                    }

                    if (page == default)
                    {
                        var contextOptions = new BrowserNewContextOptions
                        {
                            Proxy = new Proxy
                            {
                                Server = proxy.ip,
                                Bypass = "127.0.0.1",
                                Username = proxy.username,
                                Password = proxy.password
                            },
                            UserAgent = baseContextOptions.UserAgent,
                            ExtraHTTPHeaders = baseContextOptions.ExtraHTTPHeaders
                        };

                        stats_newcontext++;
                        context = await browser.NewContextAsync(contextOptions).ConfigureAwait(false);
                        page = await context.NewPageAsync().ConfigureAwait(false);
                    }
                    #endregion

                    if (headers != null && headers.Count > 0)
                        await page.SetExtraHTTPHeadersAsync(headers).ConfigureAwait(false);

                    page.Popup += Page_Popup;
                    page.Download += Page_Download;
                    page.RequestFailed += Page_RequestFailed;

                    if (AppInit.conf.chromium.Devtools)
                        await Task.Delay(TimeSpan.FromSeconds(2)).ConfigureAwait(false); // —á—Ç–æ –±—ã devtools —É—Å–ø–µ–ª –æ—Ç–∫—Ä—ã—Ç—å—Å—è

                    if (!keepopen || keepopen_page != null || !AppInit.conf.chromium.context.keepopen || pages_keepopen.Count >= AppInit.conf.chromium.context.max)
                        return page;

                    await context.NewPageAsync().ConfigureAwait(false); // —á—Ç–æ-–±—ã context –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–ª—Å—è —Å –ø–æ—Å–ª–µ–¥–Ω–µ–π –∑–∞–∫—Ä—ã—Ç–æ–π –≤–∫–ª–∞–¥–∫–æ–π
                    if (pages_keepopen.Count >= AppInit.conf.chromium.context.max)
                        return page;

                    // –æ–¥–∏–Ω –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤ —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —ç—Ç–æ—Ç –ø—Ä–æ–∫—Å–∏
                    if (proxy != default && pages_keepopen.FirstOrDefault(i => i.proxy.ip == proxy.ip && i.proxy.username == proxy.username && i.proxy.password == proxy.password)?.proxy != default)
                        return page;

                    keepopen_page = new KeepopenPage() { context = context, plugin = plugin, proxy = proxy };
                    pages_keepopen.Add(keepopen_page);
                    return page;
                }
                else
                {
                    #region NewPageAsync
                    if (keepopen && keepopen_context != default)
                    {
                        stats_keepopen++;
                        await ClearCookie(keepopen_context).ConfigureAwait(false);
                        page = await keepopen_context.NewPageAsync().ConfigureAwait(false);
                    }
                    else
                    {
                        stats_newcontext++;
                        page = await browser.NewPageAsync().ConfigureAwait(false);
                    }
                    #endregion

                    if (headers != null && headers.Count > 0)
                        await page.SetExtraHTTPHeadersAsync(headers).ConfigureAwait(false);

                    page.Popup += Page_Popup;
                    page.Download += Page_Download;
                    page.RequestFailed += Page_RequestFailed;

                    if (AppInit.conf.chromium.Devtools)
                        await Task.Delay(TimeSpan.FromSeconds(2)).ConfigureAwait(false); // —á—Ç–æ –±—ã devtools —É—Å–ø–µ–ª –æ—Ç–∫—Ä—ã—Ç—å—Å—è

                    return page;
                }
            }
            catch { return null; }
        }


        static bool workClearCookie = false;

        async Task ClearCookie(IBrowserContext context)
        {
            if (workClearCookie)
                return;

            try
            {
                workClearCookie = true;
                var cookies = await context.CookiesAsync();

                foreach (var cookie in cookies.Where(c => c.Name == "cf_clearance"))
                {
                    await context.ClearCookiesAsync(new BrowserContextClearCookiesOptions
                    {
                        Name = cookie.Name,
                        Domain = cookie.Domain,
                        Path = cookie.Path
                    });
                }
            }
            catch { }

            workClearCookie = false;
        }


        void Page_RequestFailed(object sender, IRequest e)
        {
            try
            {
                if (failedUrl != null && e.Url == failedUrl)
                {
                    completionSource.SetResult(null);
                    WebLog(e.Method, e.Url, "RequestFailed", default, e);
                }
            }
            catch { }
        }

        void Page_Download(object sender, IDownload e)
        {
            try
            {
                e.CancelAsync().ConfigureAwait(false);
            }
            catch { }
        }

        void Page_Popup(object sender, IPage e)
        {
            try
            {
                e.CloseAsync().ConfigureAwait(false);
            }
            catch { }
        }


        public void Dispose()
        {
            if (browser == null || AppInit.conf.chromium.DEV)
                return;

            try
            {
                page.RequestFailed -= Page_RequestFailed;
                page.Popup -= Page_Popup;
                page.Download -= Page_Download;

                void close()
                {
                    if (keepopen_page != null)
                    {
                        page.CloseAsync().ConfigureAwait(false);
                    }
                    else if (context != null)
                    {
                        context.CloseAsync().ConfigureAwait(false);
                    }
                    else
                    {
                        page.CloseAsync().ConfigureAwait(false);
                    }
                }

                if (imitationHuman || deferredDispose)
                {
                    Task.Delay(deferredDispose ? 2_000 : 10_000)
                        .ContinueWith(t => close());
                }
                else
                {
                    close();
                }
            }
            catch { }
        }

        public static void FullDispose()
        {
            shutdown = true;
            if (browser == null)
                return;

            try
            {
                browser.CloseAsync().ContinueWith(t => browser.DisposeAsync());
            }
            catch { }
        }
    }
}

```

## File: Shared/PlaywrightCore/PlaywrightBase.cs
```
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.Playwright;
using Shared.Engine;
using Shared.Models;
using Shared.Models.SQL;
using System.IO.Compression;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.PlaywrightCore
{
    public enum PlaywrightStatus
    {
        disabled,
        headless,
        NoHeadless
    }

    public class PlaywrightBase
    {
        static DateTime _nextClearDb = default;

        public TaskCompletionSource<string> completionSource { get; private set; } = new TaskCompletionSource<string>();

        #region WaitPageResult
        async public Task<string> WaitPageResult(int seconds = 10)
        {
            try
            {
                var completionTask = completionSource.Task;
                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(seconds));

                var completedTask = await Task.WhenAny(completionTask, timeoutTask).ConfigureAwait(false);

                if (completedTask == completionTask)
                    return await completionTask;

                return null;
            }
            catch { return null; }
        }
        #endregion


        #region InitializationAsync
        async public static Task<bool> InitializationAsync()
        {
            try
            {
                if (!AppInit.conf.chromium.enable && !AppInit.conf.firefox.enable)
                    return false;

                if (!File.Exists(".playwright/package/index.js"))
                {
                    bool res = await DownloadFile("https://github.com/immisterio/playwright/releases/download/chrome/package.zip", ".playwright/package.zip");
                    if (!res)
                    {
                        Console.WriteLine("Playwright: error download package.zip");
                        return false;
                    }
                }

                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                {
                    switch (RuntimeInformation.ProcessArchitecture)
                    {
                        case Architecture.X86:
                        case Architecture.X64:
                        case Architecture.Arm64:
                            {
                                string arc = RuntimeInformation.ProcessArchitecture.ToString().ToLower();
                                bool res = await DownloadFile($"https://github.com/immisterio/playwright/releases/download/chrome/node-win-{arc}.exe", $".playwright\\node\\win32_{arc}\\node.exe");
                                if (!res)
                                {
                                    Console.WriteLine($"Playwright: error download node-win-{arc}.exe");
                                    return false;
                                }
                                break;
                            }
                        default:
                            Console.WriteLine("Playwright: Architecture unknown");
                            return false;
                    }
                }
                else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
                {
                    switch (RuntimeInformation.ProcessArchitecture)
                    {
                        case Architecture.X64:
                        case Architecture.Arm64:
                            {
                                string arc = RuntimeInformation.ProcessArchitecture.ToString().ToLower();
                                bool res = await DownloadFile($"https://github.com/immisterio/playwright/releases/download/chrome/node-mac-{arc}", $".playwright/node/mac-{arc}/node");
                                if (!res)
                                {
                                    Console.WriteLine($"Playwright: error download node-mac-{arc}");
                                    return false;
                                }

                                Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), $".playwright/node/mac-{arc}/node")}");
                                await Task.Delay(TimeSpan.FromSeconds(4));
                                break;
                            }
                        default:
                            Console.WriteLine("Playwright: Architecture unknown");
                            return false;
                    }
                }
                else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                {
                    switch (RuntimeInformation.ProcessArchitecture)
                    {
                        case Architecture.X86:
                        case Architecture.X64:
                        case Architecture.Arm64:
                            {
                                string arc = RuntimeInformation.ProcessArchitecture.ToString().ToLower();
                                bool res = await DownloadFile($"https://github.com/immisterio/playwright/releases/download/chrome/node-linux-{arc}", $".playwright/node/linux-{arc}/node");
                                if (!res)
                                {
                                    Console.WriteLine($"Playwright: error download node-linux-{arc}");
                                    return false;
                                }

                                Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), $".playwright/node/linux-{arc}/node")}");
                                await Task.Delay(TimeSpan.FromSeconds(4));
                                break;
                            }
                        case Architecture.Arm:
                            {
                                bool res = await DownloadFile("https://github.com/immisterio/playwright/releases/download/chrome/node-linux-armv7l", ".playwright/node/linux-arm/node");
                                if (!res)
                                {
                                    Console.WriteLine("Playwright: error download node-linux-armv7l");
                                    return false;
                                }

                                Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), ".playwright/node/linux-arm/node")}");
                                await Task.Delay(TimeSpan.FromSeconds(4));
                                break;
                            }
                        default:
                            Console.WriteLine("Playwright: Architecture unknown");
                            return false;
                    }
                }
                else
                {
                    Console.WriteLine("Playwright: IsOSPlatform unknown");
                    return false;
                }

                if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux) && (AppInit.conf.chromium.Headless == false || AppInit.conf.firefox.Headless == false))
                {
                    if (!File.Exists("/usr/bin/Xvfb"))
                    {
                        Console.WriteLine("Playwright: install xvfb");
                        await Bash.Run("apt update && apt install -y xvfb");
                    }

                    _ = Bash.Run("Xvfb :99 -screen 0 1280x1024x24").ConfigureAwait(false);
                    Environment.SetEnvironmentVariable("DISPLAY", ":99");
                    await Task.Delay(TimeSpan.FromSeconds(5));
                    Console.WriteLine("Playwright: Xvfb 99");
                }

                Console.WriteLine("Playwright: Initialization");
                return true;
            }
            catch (Exception ex) 
            {
                Console.WriteLine($"Playwright: {ex.Message}");
                return false;
            }
        }
        #endregion

        #region DownloadFile
        async public static Task<bool> DownloadFile(string uri, string outfile, string folder = null)
        {
            if (File.Exists($"{outfile}.ok"))
                return true;

            if (File.Exists(outfile))
                File.Delete(outfile);

            Directory.CreateDirectory(Path.GetDirectoryName(outfile));

            Console.WriteLine($"Playwright: Download {outfile}");

            if (await Http.DownloadFile(uri, outfile))
            {
                File.Create($"{outfile}.ok");

                if (outfile.EndsWith(".zip"))
                {
                    Console.WriteLine($"Playwright: unzip {outfile}");

                    if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                    {
                        await Bash.Run($"unzip {Path.Combine(Environment.CurrentDirectory, outfile)} -d {Path.Combine(Environment.CurrentDirectory, ".playwright", folder ?? string.Empty)}");
                    }
                    else
                    {
                        ZipFile.ExtractToDirectory(outfile, ".playwright/" + folder, overwriteFiles: true);
                    }

                    File.Delete(outfile);
                }

                return true;
            }
            else
            {
                File.Delete(outfile);
                return false;
            }
        }
        #endregion

        #region WebLog
        public static void WebLog(IRequest request, IResponse response, in string result, (string ip, string username, string password) proxy = default)
        {
            try
            {
                if (request.Url.Contains("127.0.0.1") || !AppInit.conf.weblog.enable)
                    return;

                var log = new StringBuilder();

                log.Append($"{DateTime.Now}\n");

                if (proxy != default)
                    log.Append($"proxy: {proxy}\n");

                log.Append($"{request.Method}: {request.Url}\n");

                foreach (var item in request.Headers)
                    log.Append($"{item.Key}: {item.Value}\n");

                if (response == null)
                {
                    log.Append("\nresponse null");
                    Http.onlog?.Invoke(null, log.ToString());
                    return;
                }

                log.Append($"\n\nCurrentUrl: {response.Url}\nStatusCode: {response.Status}\n");
                foreach (var item in response.Headers)
                    log.Append($"{item.Key}: {item.Value}\n");

                Http.onlog?.Invoke(null, $"{log.ToString()}\n{result}");
            }
            catch { }
        }

        public static void WebLog(string method, string url, in string result, (string ip, string username, string password) proxy = default, IRequest request = default, IResponse response = default)
        {
            try
            {
                if (url.Contains("127.0.0.1") || !AppInit.conf.weblog.enable)
                    return;

                var log = new StringBuilder();

                log.Append($"{DateTime.Now}\n");

                if (proxy != default)
                    log.Append($"proxy: {proxy}\n");

                log.Append($"{method}: {url}\n");

                if (request?.Headers != null)
                {
                    foreach (var item in request.Headers)
                        log.Append($"{item.Key}: {item.Value}\n");
                }

                if (response?.Headers != null)
                {
                    log.Append($"\n\nCurrentUrl: {response.Url}\nStatusCode: {response.Status}\n");
                    foreach (var item in response.Headers)
                        log.Append($"{item.Key}: {item.Value}\n");
                }

                Http.onlog?.Invoke(null, $"{log.ToString()}\n{result}");
            }
            catch { }
        }
        #endregion

        #region IframeUrl
        public static string IframeUrl(string link) => $"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/api/chromium/iframe?src={HttpUtility.UrlEncode(link)}";

        public static string IframeHtml(string link) => $@"<html lang=""ru"">
                <head>
                    <meta charset=""UTF-8"">
                    <meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
                    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"">
                </head>
                <body>
                    <iframe width=""560"" height=""400"" src=""{link}"" frameborder=""0"" allow=""*"" allowfullscreen></iframe>
                </body>
            </html>";
        #endregion

        #region AbortOrCache
        async public static ValueTask<bool> AbortOrCache(IPage page, IRoute route, bool abortMedia = false, bool fullCacheJS = false, string patterCache = null)
        {
            try
            {
                if (Regex.IsMatch(route.Request.Url, "(image.tmdb.org|yandex\\.|google-analytics|yahoo\\.|fonts.googleapis|googletagmanager|opensubtitles\\.|/favicon\\.ico$)"))
                {
                    await route.AbortAsync();
                    return true;
                }

                if (abortMedia && Regex.IsMatch(route.Request.Url.Split("?")[0], "\\.(woff2?|vtt|srt|css|svg|jpe?g|png|gif|webp|ico|ts|m4s)$"))
                {
                    if (AppInit.conf.chromium.consoleLog || AppInit.conf.firefox.consoleLog)
                        Console.WriteLine($"Playwright: Abort {route.Request.Url}");

                    await route.AbortAsync();
                    return true;
                }

                if (route.Request.Method == "GET")
                {
                    bool valid = false;
                    string memkey = route.Request.Url;

                    if ((fullCacheJS && route.Request.Url.Contains(".js")) || Regex.IsMatch(route.Request.Url, "(\\.googleapis\\.com/css|gstatic\\.com|plrjs\\.com)", RegexOptions.IgnoreCase))
                    {
                        valid = true;
                        memkey = route.Request.Url.Split("?")[0];
                    }
                    else if (Regex.IsMatch(route.Request.Url, "\\.(js|wasm)$") || Regex.IsMatch(route.Request.Url, "\\.(css|woff2?|svg|jpe?g|png|gif)"))
                    {
                        valid = true;
                        memkey = route.Request.Url;
                    }
                    else if (patterCache != null && Regex.IsMatch(route.Request.Url, patterCache))
                    {
                        valid = true;
                        memkey = route.Request.Url;
                    }

                    if (valid)
                    {
                        #region ClearDb
                        try
                        {
                            if (DateTime.Now > _nextClearDb)
                            {
                                _nextClearDb = DateTime.Now.AddMinutes(5);

                                var now = DateTime.Now;

                                using (var sqlDb = new PlaywrightContext())
                                {
                                    await sqlDb.files
                                        .Where(i => now > i.ex)
                                        .ExecuteDeleteAsync();
                                }
                            }
                        }
                        catch { }
                        #endregion

                        PlaywrightSqlModel doc = null;

                        using (var sqlDb = new PlaywrightContext())
                            doc = sqlDb.files.Find(memkey);

                        if (doc?.content != null)
                        {
                            if (AppInit.conf.chromium.consoleLog || AppInit.conf.firefox.consoleLog)
                                Console.WriteLine($"Playwright: CACHE {route.Request.Url}");

                            await route.FulfillAsync(new RouteFulfillOptions
                            {
                                BodyBytes = doc.content,
                                Headers = JsonSerializer.Deserialize<Dictionary<string, string>>(doc.headers)
                            });
                        }
                        else
                        {
                            if (AppInit.conf.chromium.consoleLog || AppInit.conf.firefox.consoleLog)
                                Console.WriteLine($"Playwright: MISS {route.Request.Url}");

                            await route.ContinueAsync();

                            try
                            {
                                var response = await page.WaitForResponseAsync(route.Request.Url);
                                if (response != null)
                                {
                                    var content = await response.BodyAsync();
                                    if (content != null)
                                    {
                                        using (var sqlDb = new PlaywrightContext())
                                        {
                                            sqlDb.files.Add(new PlaywrightSqlModel()
                                            {
                                                Id = memkey,
                                                ex = DateTime.Now.AddHours(1),
                                                headers = JsonSerializer.Serialize(response.Headers.ToDictionary()),
                                                content = content
                                            });

                                            await sqlDb.SaveChangesAsync();
                                        }
                                    }
                                }
                            }
                            catch { }
                        }

                        return true;
                    }
                }

                if (AppInit.conf.chromium.consoleLog || AppInit.conf.firefox.consoleLog)
                    Console.WriteLine($"Playwright: {route.Request.Method} {route.Request.Url}");

                return false;
            }
            catch { return false; }
        }
        #endregion

        #region GotoAsync
        public static void GotoAsync(IPage page, string uri)
        {
            var options = new PageGotoOptions
            {
                Timeout = 60_000, // 60 —Å–µ–∫—É–Ω–¥
                WaitUntil = WaitUntilState.DOMContentLoaded
            };

            _ = page.GotoAsync(uri, options).ConfigureAwait(false);
        }
        #endregion

        #region ConsoleLog
        public static void ConsoleLog(in string value, List<HeadersModel> headers = null)
        {
            if (AppInit.conf.chromium.consoleLog || AppInit.conf.firefox.consoleLog)
            {
                if (headers != null)
                {
                    Console.WriteLine($"\n{value}\n{Newtonsoft.Json.JsonConvert.SerializeObject(headers.ToDictionary(), Newtonsoft.Json.Formatting.Indented)}\n");
                }
                else
                {
                    Console.WriteLine(value);
                }
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/AccsDbInvk.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using System.Text;
using System.Web;

namespace Shared.Engine
{
    public static class AccsDbInvk
    {
        public static string Args(string uri, HttpContext httpContext)
        {
            var args = new StringBuilder();

            if (httpContext.Request.Query.ContainsKey("account_email") && !uri.Contains("account_email="))
            {
                string account_email = httpContext.Request.Query["account_email"].ToString()?.ToLower()?.Trim();
                if (!string.IsNullOrEmpty(account_email))
                    args.Append($"&account_email={HttpUtility.UrlEncode(account_email)}");
            }

            if (httpContext.Request.Query.ContainsKey("uid") && !uri.Contains("uid="))
            {
                string uid = httpContext.Request.Query["uid"].ToString()?.ToLower()?.Trim();
                if (!string.IsNullOrEmpty(uid))
                    args.Append($"&uid={HttpUtility.UrlEncode(uid)}");
            }

            if (httpContext.Request.Query.ContainsKey("token") && !uri.Contains("token="))
            {
                string token = httpContext.Request.Query["token"].ToString()?.ToLower()?.Trim();
                if (!string.IsNullOrEmpty(token))
                    args.Append($"&token={HttpUtility.UrlEncode(token)}");
            }

            if (httpContext.Request.Query.ContainsKey("box_mac") && !uri.Contains("box_mac="))
            {
                string box_mac = httpContext.Request.Query["box_mac"].ToString()?.ToLower()?.Trim();
                if (!string.IsNullOrEmpty(box_mac))
                    args.Append($"&box_mac={HttpUtility.UrlEncode(box_mac)}");
            }

            if (httpContext.Request.Query.ContainsKey("nws_id") && !uri.Contains("nws_id="))
            {
                string nws_id = httpContext.Request.Query["nws_id"].ToString()?.ToLower()?.Trim();
                if (!string.IsNullOrEmpty(nws_id))
                    args.Append($"&nws_id={HttpUtility.UrlEncode(nws_id)}");
            }

            if (args.Length == 0)
                return uri;

            if (string.IsNullOrEmpty(uri))
                return args.ToString();

            if (uri.Contains("?"))
                return uri + args.ToString();

            return $"{uri}?{args.Remove(0, 1).ToString()}";
        }
    }
}

```

## File: Shared/Engine/Bash.cs
```
Ôªøusing System.Diagnostics;

namespace Shared.Engine
{
    public static class Bash
    {
        public static bool Invoke(string comand)
        {
            try
            {
                var processInfo = new ProcessStartInfo();
                processInfo.UseShellExecute = false;
                processInfo.RedirectStandardOutput = true;
                processInfo.FileName = "/bin/bash";
                processInfo.Arguments = $" -c \"{comand.Replace("\"", "\\\"").Replace("'", "\\\'")}\"";

                var process = Process.Start(processInfo);
                if (process == null)
                    return false;

                return true;
            }
            catch
            {
                return false;
            }
        }

        async public static Task<string> Run(string comand)
        {
            try
            {
                var processInfo = new ProcessStartInfo();
                processInfo.UseShellExecute = false;
                processInfo.RedirectStandardError = true;
                processInfo.RedirectStandardOutput = true;
                processInfo.FileName = "/bin/bash";
                processInfo.Arguments = $" -c \"{comand.Replace("\"", "\\\"").Replace("'", "\\\'")}\"";

                var process = Process.Start(processInfo);
                if (process == null)
                    return null;

                string outPut = await process.StandardOutput.ReadToEndAsync();
                outPut += await process.StandardError.ReadToEndAsync();

                await process.WaitForExitAsync();

                return outPut;
            }
            catch
            {
                return null;
            }
        }
    }
}

```

## File: Shared/Engine/AesTo.cs
```
Ôªøusing System.Security.Cryptography;
using System.Text;

namespace Shared.Engine
{
    public static class AesTo
    {
        static byte[] aesKey, aesIV;

        static AesTo()
        {
            if (File.Exists("cache/aeskey"))
            {
                var i = File.ReadAllText("cache/aeskey").Split("/");
                aesKey = Encoding.UTF8.GetBytes(i[0]);
                aesIV = Encoding.UTF8.GetBytes(i[1]);
            }
            else
            {
                string k = CrypTo.unic(16);
                string v = CrypTo.unic(16);
                File.WriteAllText("cache/aeskey", $"{k}/{v}");

                aesKey = Encoding.UTF8.GetBytes(k);
                aesIV = Encoding.UTF8.GetBytes(v);
            }
        }

        public static string Encrypt(string plainText)
        {
            try
            {
                using (var aes = Aes.Create())
                {
                    aes.Key = aesKey;
                    aes.IV = aesIV;

                    using (var encryptor = aes.CreateEncryptor(aes.Key, aes.IV))
                    {
                        using (var ms = new MemoryStream())
                        {
                            using (var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                            {
                                try
                                {
                                    using (var sw = new StreamWriter(cs, Encoding.UTF8))
                                        sw.Write(plainText ?? string.Empty);

                                    return Convert.ToBase64String(ms.ToArray());
                                }
                                catch { return null; }
                            }
                        }
                    }
                }
            }
            catch
            {
                return null;
            }
        }

        public static string Decrypt(string cipherText)
        {
            try
            {
                using (var aes = Aes.Create())
                {
                    aes.Key = aesKey;
                    aes.IV = aesIV;

                    using (var decryptor = aes.CreateDecryptor(aes.Key, aes.IV))
                    {
                        using (var ms = new MemoryStream(Convert.FromBase64String(cipherText)))
                        {
                            using (var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))
                            {
                                try
                                {
                                    using (var sr = new StreamReader(cs, Encoding.UTF8))
                                        return sr.ReadToEnd();
                                }
                                catch { return null; }
                            }
                        }
                    }
                }
            }
            catch
            {
                return null;
            }
        }
    }
}
```

## File: Shared/Engine/FFmpeg.cs
```
Ôªøusing System.Diagnostics;
using System.Runtime.InteropServices;

namespace Shared.Engine
{
    /// <summary>
    /// https://github.com/BtbN/FFmpeg-Builds/releases
    /// </summary>
    public static class FFmpeg
    {
        #region InitializationAsync
        static bool disableInstall = false;

        async public static Task<bool> InitializationAsync()
        {
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                #region Windows
                if (File.Exists("data/ffmpeg.exe") && File.Exists("data/ffprobe.exe"))
                {
                    Console.WriteLine("FFmpeg: Initialization");
                    return true;
                }

                if (RuntimeInformation.ProcessArchitecture != Architecture.X64 && RuntimeInformation.ProcessArchitecture != Architecture.Arm64)
                {
                    Console.WriteLine("FFmpeg: Architecture unknown");
                    return false;
                }

                if (disableInstall)
                    return true;

                disableInstall = true;
                string arh = RuntimeInformation.ProcessArchitecture == Architecture.X64 ? "64" : "arm64";

                foreach (string fileName in new string[] { "ffmpeg", "ffprobe" })
                {
                    if (File.Exists($"data/{fileName}.exe"))
                        continue;

                    if (!await Http.DownloadFile($"https://github.com/immisterio/ffmpeg/releases/download/ffmpeg2/{fileName}-win{arh}-gpl.exe", $"data/{fileName}.exe"))
                        File.Delete($"data/{fileName}.exe");
                }

                bool success = File.Exists("data/ffmpeg.exe") && File.Exists("data/ffprobe.exe");

                Console.WriteLine(success ? "FFmpeg: Initialization" : "FFmpeg: error download");
                disableInstall = false;
                return success;
                #endregion
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                #region Linux
                if ((File.Exists("data/ffmpeg") && File.Exists("data/ffprobe")) || File.Exists("/bin/ffmpeg"))
                {
                    Console.WriteLine("FFmpeg: Initialization");
                    return true;
                }

                string version = await Bash.Run("ffmpeg -version");
                if (version == null || !version.Contains("FFmpeg developers"))
                {
                    if (disableInstall)
                        return true;

                    disableInstall = true;

                    if (RuntimeInformation.ProcessArchitecture == Architecture.X64 || RuntimeInformation.ProcessArchitecture == Architecture.Arm64)
                    {
                        string arh = RuntimeInformation.ProcessArchitecture == Architecture.X64 ? "64" : "arm64";

                        foreach (string fileName in new string[] { "ffmpeg", "ffprobe" })
                        {
                            if (File.Exists($"data/{fileName}"))
                                continue;

                            if (!await Http.DownloadFile($"https://github.com/immisterio/ffmpeg/releases/download/ffmpeg2/{fileName}-linux{arh}-gpl", $"data/{fileName}"))
                            {
                                File.Delete($"data/{fileName}");
                                continue;
                            }

                            Bash.Invoke($"chmod +x {Path.Join(Directory.GetCurrentDirectory(), $"data/{fileName}")}");
                        }

                        bool success = File.Exists("data/ffmpeg") && File.Exists("data/ffprobe");

                        await Task.Delay(1000); // Wait for chmod to complete
                        Console.WriteLine(success ? "FFmpeg: Initialization" : "FFmpeg: error download");
                        disableInstall = false;
                        return success;
                    }
                    else
                    {
                        await Bash.Run("apt update && apt install -y ffmpeg");
                        version = await Bash.Run("ffmpeg -version");
                        if (version == null || !version.Contains("FFmpeg developers"))
                        {
                            Console.WriteLine("FFmpeg: error install ffmpeg");
                            disableInstall = false;
                            return false;
                        }
                    }
                }

                Console.WriteLine("FFmpeg: Initialization");
                return true;
                #endregion
            }

            Console.WriteLine("FFmpeg: OS unknown");
            return false;
        }
        #endregion

        #region RunAsync
        async public static ValueTask<(string outputData, string errorData)> RunAsync(string comand, string workingDirectory = null, ProcessPriorityClass? priorityClass = null)
        {
            try
            {
                var process = new Process();
                process.StartInfo.UseShellExecute = false;
                process.StartInfo.RedirectStandardOutput = true;
                process.StartInfo.RedirectStandardError = true;
                process.StartInfo.FileName = AppInit.Win32NT ? "data/ffmpeg.exe" : File.Exists("data/ffmpeg") ? "data/ffmpeg" : "ffmpeg";
                process.StartInfo.Arguments = comand;
                process.StartInfo.WorkingDirectory = workingDirectory;
                process.Start();

                if (priorityClass != null)
                {
                    try
                    {
                        process.PriorityClass = (ProcessPriorityClass)priorityClass;
                    }
                    catch (InvalidOperationException)
                    {
                        // –ü—Ä–æ—Ü–µ—Å—Å –∑–∞–≤–µ—Ä—à–∏–ª—Å—è –¥–æ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞
                    }
                    catch(Exception ex)
                    {
                        Console.WriteLine("FFmpeg: " + ex.Message);
                    }
                }

                string outputData = string.Empty, errorData = string.Empty;

                process.OutputDataReceived += (sender, args) =>
                {
                    if (!string.IsNullOrEmpty(args.Data))
                        outputData += args.Data + "\n";
                };

                process.ErrorDataReceived += (sender, args) =>
                {
                    if (!string.IsNullOrEmpty(args.Data))
                        errorData += args.Data + "\n";
                };

                process.BeginOutputReadLine();
                process.BeginErrorReadLine();

                await process.WaitForExitAsync();

                return (outputData, errorData);
            }
            catch 
            {
                return default;
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/ProxyLink.cs
```
Ôªøusing Microsoft.EntityFrameworkCore;
using Shared.Models;
using Shared.Models.Base;
using Shared.Models.Proxy;
using Shared.Models.SQL;
using System.Collections.Concurrent;
using System.Net;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;
using System.Threading;

namespace Shared.Engine
{
    public class ProxyLink : IProxyLink
    {
        #region ProxyLink
        static ConcurrentDictionary<string, ProxyLinkModel> links = new ConcurrentDictionary<string, ProxyLinkModel>();

        static Timer _cronTimer;

        static ProxyLink()
        {
            _cronTimer = new Timer(Cron, null, TimeSpan.Zero, TimeSpan.FromSeconds(5));
        }
        #endregion


        #region Encrypt
        public string Encrypt(string uri, string plugin, DateTime ex = default) => Encrypt(uri, null, verifyip: false, ex: ex, plugin: plugin);

        public static string Encrypt(string uri, ProxyLinkModel p, bool forceMd5 = false) => Encrypt(uri, p.reqip, p.headers, p.proxy, p.plugin, p.verifyip, forceMd5: forceMd5);

        public static string Encrypt(string uri, string reqip, List<HeadersModel> headers = null, WebProxy proxy = null, string plugin = null, bool verifyip = true, DateTime ex = default, bool forceMd5 = false)
        {
            if (string.IsNullOrWhiteSpace(uri))
                return string.Empty;

            string hash;
            bool IsMd5 = false;
            string uri_clear = uri.Contains("#") ? uri.Split("#")[0].Trim() : uri.Trim();

            if (plugin == "posterapi")
            {
                hash = AesTo.Encrypt(JsonSerializer.Serialize(new { u = uri_clear }));
            }
            else if (!forceMd5 && AppInit.conf.serverproxy.encrypt_aes && (headers == null || headers.Count == 0) && proxy == null && !uri_clear.Contains(" or "))
            {
                if (verifyip && AppInit.conf.serverproxy.verifyip)
                {
                    hash = AesTo.Encrypt(JsonSerializer.Serialize(new
                    {
                        p = plugin,
                        u = uri_clear,
                        i = reqip,
                        v = true,
                        e = DateTime.Now.AddHours(36)
                    }));
                }
                else
                {
                    hash = AesTo.Encrypt(JsonSerializer.Serialize(new { p = plugin, u = uri_clear }));
                }
            }
            else
            {
                IsMd5 = true;
                hash = CrypTo.md5(uri_clear + (verifyip && AppInit.conf.serverproxy.verifyip ? reqip : string.Empty));
            }

            if (uri.Contains(".m3u8"))
                hash += ".m3u8";
            else if (uri.Contains(".m3u"))
                hash += ".m3u";
            else if (uri.Contains(".mpd"))
                hash += ".mpd";
            else if (uri.Contains(".webm"))
                hash += ".webm";
            else if (uri.Contains(".ts"))
                hash += ".ts";
            else if (uri.Contains(".m4s"))
                hash += ".m4s";
            else if (uri.Contains(".mp4"))
                hash += ".mp4";
            else if (uri.Contains(".mkv"))
                hash += ".mkv";
            else if (uri.Contains(".aac"))
                hash += ".aac";
            else if (uri.Contains(".jpg") || uri.Contains(".jpeg"))
                hash += ".jpg";
            else if (uri.Contains(".png"))
                hash += ".png";
            else if (uri.Contains(".webp"))
                hash += ".webp";
            else if (uri.Contains(".vtt"))
                hash += ".vtt";
            else if (uri.Contains(".srt"))
                hash += ".srt";

            if (IsMd5)
            {
                var md = new ProxyLinkModel(verifyip ? reqip : null, headers, proxy, uri_clear, plugin, verifyip, ex: ex);
                links.AddOrUpdate(hash, md, (d, u) => md);
            }

            return hash;
        }
        #endregion

        #region Decrypt
        public static ProxyLinkModel Decrypt(string hash, string reqip)
        {
            if (string.IsNullOrEmpty(hash))
                return null;

            if (IsAes(hash))
            {
                hash = Regex.Replace(hash, "\\.[a-z0-9]+$", "", RegexOptions.IgnoreCase);

                string dec = AesTo.Decrypt(hash);
                if (string.IsNullOrEmpty(dec))
                    return null;

                var root = JsonNode.Parse(dec);

                if (root["v"]?.GetValue<bool>() == true)
                {
                    if (reqip != null && root["i"].GetValue<string>() != reqip)
                        return null;

                    if (DateTime.Now > root["e"].GetValue<DateTime>())
                        return null;
                }

                var headers = HeadersModel.Init(root["h"]?.Deserialize<Dictionary<string, string>>());

                return new ProxyLinkModel(reqip, headers, null, root["u"].GetValue<string>(), root["p"]?.GetValue<string>());
            }

            if (!links.TryGetValue(hash, out ProxyLinkModel val))
            {
                try
                {
                    if (!AppInit.conf.mikrotik)
                    {
                        using (var sqlDb = new ProxyLinkContext())
                        {
                            var link = sqlDb.links.Find(hash);

                            if (link != null && link.ex > DateTime.Now)
                            {
                                val = JsonSerializer.Deserialize<ProxyLinkModel>(link.json);
                                val.id = link.Id;
                                val.ex = link.ex;
                            }
                        }
                    }
                }
                catch { }
            }

            if (val != null)
            {
                if (val.verifyip == false || AppInit.conf.serverproxy.verifyip == false || val.reqip == string.Empty || reqip == null || reqip == val.reqip)
                    return val;
            }

            return null;
        }
        #endregion

        #region IsAes
        public static bool IsAes(string hash)
        {
            if (hash.StartsWith("http"))
                return false;

            if (hash.Split('?', '&', '.')[0].Length == 32)
                return false;

            return true;
        }
        #endregion


        #region Cron
        static HashSet<string> tempLinks = new();

        static int cronRound = 0;

        static DateTime _nextClearDb = DateTime.Now.AddHours(1);

        static bool _cronWork = false;

        async static void Cron(object state)
        {
            if (_cronWork || links.Count == 0)
                return;

            _cronWork = true;

            try
            {
                if (cronRound == 60)
                {
                    cronRound = 0;
                    tempLinks.Clear();
                }

                cronRound++;

                using (var sqlDb = new ProxyLinkContext())
                {
                    if (DateTime.Now > _nextClearDb)
                    {
                        _nextClearDb = DateTime.Now.AddHours(1);

                        var now = DateTime.Now;

                        await sqlDb.links
                             .Where(i => now > i.ex)
                             .ExecuteDeleteAsync();
                    }
                    else
                    {
                        foreach (var link in links.ToArray())
                        {
                            try
                            {
                                if (AppInit.conf.mikrotik || link.Value.proxy != null || DateTime.Now.AddMinutes(5) > link.Value.ex || link.Value.uri.Contains(" or "))
                                {
                                    if (DateTime.Now > link.Value.ex)
                                        links.TryRemove(link.Key, out _);
                                }
                                else
                                {
                                    if (tempLinks.Contains(link.Key))
                                        links.TryRemove(link.Key, out _);
                                    else
                                    {
                                        link.Value.id = link.Key;

                                        await sqlDb.links
                                            .Where(x => x.Id == link.Key)
                                            .ExecuteDeleteAsync();

                                        sqlDb.links.Add(new ProxyLinkSqlModel()
                                        {
                                            Id = link.Key,
                                            ex = link.Value.ex,
                                            json = JsonSerializer.Serialize(link.Value)
                                        });

                                        if (await sqlDb.SaveChangesAsync() > 0)
                                        {
                                            tempLinks.Add(link.Key);
                                            links.TryRemove(link.Key, out _);
                                        }
                                    }
                                }
                            }
                            catch (Exception ex) { Console.WriteLine($"ProxyLink: {ex}"); }
                        }
                    }
                }
            }
            catch (Exception ex) { Console.WriteLine($"ProxyLink: {ex}"); }
            finally 
            {
                _cronWork = false;
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/ModuleRepository.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc.ApplicationParts;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.IO.Compression;
using System.Net.Http;
using System.Text;
using System.Threading;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Shared.Engine
{
    /// <summary>
    /// Codex AI - Module Repository
    /// </summary>
    public static class ModuleRepository
    {
        private const string RepositoryFile = "module/repository.yaml";
        private const string StateFile = "module/.repository_state.json";

        private static readonly object SyncRoot = new object();
        private static readonly HttpClient HttpClient;

        private static ApplicationPartManager partManager;
        private static Dictionary<string, string> repositoryState;

        static ModuleRepository()
        {
            HttpClient = new HttpClient
            {
                Timeout = TimeSpan.FromSeconds(60)
            };

            if (!HttpClient.DefaultRequestHeaders.UserAgent.Any())
                HttpClient.DefaultRequestHeaders.UserAgent.ParseAdd("LampacModuleRepository/1.0");

            if (!HttpClient.DefaultRequestHeaders.Accept.Any())
                HttpClient.DefaultRequestHeaders.Accept.ParseAdd("application/vnd.github+json");
        }

        public static void Configuration(IMvcBuilder mvcBuilder)
        {
            partManager = mvcBuilder?.PartManager;

            UpdateModules();
        }

        private static void UpdateModules()
        {
            if (!Monitor.TryEnter(SyncRoot))
            {
                Console.WriteLine("ModuleRepository: UpdateModules skipped because another update is running");
                return;
            }

            Console.WriteLine("ModuleRepository: UpdateModules start");

            try
            {
                var repositories = LoadConfiguration();
                if (repositories.Count == 0)
                {
                    Console.WriteLine("ModuleRepository: no repositories configured");
                    return;
                }

                Directory.CreateDirectory(Path.Combine(Environment.CurrentDirectory, "module"));
                Console.WriteLine("ModuleRepository: ensured module directory exists");

                var state = LoadState();
                bool stateChanged = false;
                var modulesToCompile = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

                foreach (var repository in repositories)
                {
                    try
                    {
                        if (!repository.IsValid)
                        {
                            Console.WriteLine($"ModuleRepository: skipping invalid repository '{repository?.Url}'");
                            continue;
                        }

                        bool missingModule = repository.Folders.Any(folder => !Directory.Exists(Path.Combine(Environment.CurrentDirectory, "module", folder.ModuleName)));
                        string commitSha = GetLatestCommitSha(repository);
                        if (string.IsNullOrEmpty(commitSha))
                        {
                            Console.WriteLine($"ModuleRepository: could not determine latest commit for {repository.Url}");
                            continue;
                        }

                        string stateKey = repository.StateKey;
                        if (!missingModule && state.TryGetValue(stateKey, out string storedSha) && string.Equals(storedSha, commitSha, StringComparison.OrdinalIgnoreCase))
                        {
                            Console.WriteLine($"ModuleRepository: repository '{repository.Url}' is up-to-date (sha={commitSha})");
                            continue;
                        }

                        if (DownloadAndExtract(repository, modulesToCompile))
                        {
                            state[stateKey] = commitSha;
                            stateChanged = true;
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"ModuleRepository: error processing repository {repository?.Url} - {ex.Message}");
                    }
                }

                if (stateChanged)
                {
                    SaveState(state);
                    Console.WriteLine("ModuleRepository: state saved");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"module repository: {ex.Message}");
            }
            finally
            {
                Console.WriteLine("ModuleRepository: UpdateModules finished, releasing lock");
                Monitor.Exit(SyncRoot);
            }
        }

        private static List<RepositoryEntry> LoadConfiguration()
        {
            string path = Path.Combine(Environment.CurrentDirectory, RepositoryFile.Replace('/', Path.DirectorySeparatorChar));
            if (!File.Exists(path))
            {
                Console.WriteLine($"ModuleRepository: repository config file not found at {path}");
                return new List<RepositoryEntry>();
            }

            try
            {
                string yaml = File.ReadAllText(path);
                if (string.IsNullOrWhiteSpace(yaml))
                {
                    Console.WriteLine("ModuleRepository: repository config file is empty");
                    return new List<RepositoryEntry>();
                }

                var deserializer = new DeserializerBuilder()
                    .WithNamingConvention(UnderscoredNamingConvention.Instance)
                    .IgnoreUnmatchedProperties()
                    .Build();

                var document = deserializer.Deserialize(new StringReader(yaml));
                if (document == null)
                {
                    Console.WriteLine("ModuleRepository: repository config deserialized to null");
                    return new List<RepositoryEntry>();
                }

                var repos = ParseRepositories(document);
                Console.WriteLine($"ModuleRepository: loaded {repos.Count} repository entries from config");
                return repos;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"module repository: failed to read configuration - {ex.Message}");
                return new List<RepositoryEntry>();
            }
        }

        private static List<RepositoryEntry> ParseRepositories(object document)
        {
            var list = new List<RepositoryEntry>();

            if (document is IList<object> sequence)
            {
                foreach (var item in sequence)
                {
                    var repository = CreateRepository(item);
                    if (repository != null)
                        list.Add(repository);
                    else
                        Console.WriteLine("ModuleRepository: skipped invalid repository entry in sequence");
                }
            }
            else if (document is IDictionary<object, object> map)
            {
                foreach (var entry in map)
                {
                    var repository = CreateRepository(entry.Value);
                    if (repository != null)
                        list.Add(repository);
                    else
                        Console.WriteLine("ModuleRepository: skipped invalid repository entry in map");
                }
            }

            return list;
        }

        private static RepositoryEntry CreateRepository(object node)
        {
            if (node is IDictionary<object, object> map)
            {
                string url = GetString(map, "repository", "repo", "url", "git", "remote");
                if (string.IsNullOrWhiteSpace(url))
                {
                    Console.WriteLine("ModuleRepository: repository entry missing url");
                    return null;
                }

                string branch = GetString(map, "branch", "ref");
                var folders = ParseFolders(map);

                var repository = new RepositoryEntry
                {
                    Url = url.Trim(),
                    Branch = string.IsNullOrWhiteSpace(branch) ? null : branch.Trim(),
                    Folders = folders
                };

                if (!TryParseGitHubUrl(repository.Url, out string owner, out string name))
                {
                    Console.WriteLine($"module repository: unsupported repository url '{repository.Url}'");
                    return null;
                }

                repository.Owner = owner;
                repository.Name = name;

                ApplyAuthenticationSettings(map, repository);
                Console.WriteLine($"ModuleRepository: parsed repository {repository.Owner}/{repository.Name} branch={repository.Branch ?? "(default)"}");

                // If no folders were specified in YAML, try to fetch top-level directories from GitHub repo
                if (repository.Folders == null || repository.Folders.Count == 0)
                {
                    try
                    {
                        var remoteFolders = FetchRepositoryFolders(repository);
                        if (remoteFolders.Count > 0)
                        {
                            repository.Folders = remoteFolders;
                            Console.WriteLine($"ModuleRepository: populated {remoteFolders.Count} folders from remote repository {repository.Owner}/{repository.Name}");
                        }
                        else
                        {
                            Console.WriteLine($"ModuleRepository: no folders found in remote repository {repository.Owner}/{repository.Name}");
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"ModuleRepository: failed to fetch folders for {repository.Owner}/{repository.Name} - {ex.Message}");
                    }
                }

                return repository;
            }

            return null;
        }

        private static void ApplyAuthenticationSettings(IDictionary<object, object> map, RepositoryEntry repository)
        {
            if (map == null || repository == null)
                return;

            string accept = GetString(map, "accept", "accept_header");
            if (!string.IsNullOrWhiteSpace(accept))
                repository.AcceptHeader = accept.Trim();

            string authHeader = GetString(map, "auth_header", "authorization", "authorization_header");
            if (!string.IsNullOrWhiteSpace(authHeader))
            {
                string resolvedHeader = ResolveSecretValue(authHeader, "auth_header", repository);
                if (!string.IsNullOrWhiteSpace(resolvedHeader))
                    repository.Token = resolvedHeader.Trim();

                return;
            }

            string tokenValue = GetString(map, "token", "pat", "personal_access_token");
            if (string.IsNullOrWhiteSpace(tokenValue))
                return;

            string resolvedToken = ResolveSecretValue(tokenValue, "token", repository);
            if (string.IsNullOrWhiteSpace(resolvedToken))
                return;

            string tokenType = GetString(map, "token_type", "auth_type", "authorization_scheme", "scheme", "token_scheme");
            string headerValue;

            if (!string.IsNullOrWhiteSpace(tokenType))
            {
                headerValue = $"{tokenType.Trim()} {resolvedToken.Trim()}".Trim();
            }
            else
            {
                string trimmed = resolvedToken.Trim();
                headerValue = trimmed.Contains(' ') ? trimmed : $"token {trimmed}";
            }

            if (string.IsNullOrWhiteSpace(headerValue))
            {
                Console.WriteLine($"ModuleRepository: resolved token for {repository.Url} is empty");
                return;
            }

            repository.Token = headerValue;
        }

        private static string ResolveSecretValue(string value, string fieldName, RepositoryEntry repository)
        {
            if (string.IsNullOrWhiteSpace(value))
                return null;

            string trimmed = value.Trim();

            int envIndex = trimmed.IndexOf("env:", StringComparison.OrdinalIgnoreCase);
            if (envIndex < 0)
                return trimmed;

            var builder = new StringBuilder();
            int currentIndex = 0;

            while (envIndex >= 0)
            {
                builder.Append(trimmed, currentIndex, envIndex - currentIndex);

                int nameStart = envIndex + 4;
                int nameEnd = nameStart;
                while (nameEnd < trimmed.Length && (char.IsLetterOrDigit(trimmed[nameEnd]) || trimmed[nameEnd] == '_'))
                    nameEnd++;

                if (nameEnd == nameStart)
                {
                    Console.WriteLine($"ModuleRepository: {fieldName} environment variable name is missing for repository {repository?.Url}");
                    return null;
                }

                string envName = trimmed[nameStart..nameEnd];
                string envValue = Environment.GetEnvironmentVariable(envName);
                if (string.IsNullOrWhiteSpace(envValue))
                {
                    Console.WriteLine($"ModuleRepository: environment variable '{envName}' not found for repository {repository?.Url}");
                    return null;
                }

                builder.Append(envValue.Trim());
                currentIndex = nameEnd;
                envIndex = trimmed.IndexOf("env:", currentIndex, StringComparison.OrdinalIgnoreCase);
            }

            builder.Append(trimmed[currentIndex..]);
            return builder.ToString().Trim();
        }

        private static List<RepositoryFolder> ParseFolders(IDictionary<object, object> map)
        {
            foreach (string key in new[] { "modules", "folders", "directories", "paths", "include" })
            {
                if (TryGetValue(map, key, out object value))
                    return ConvertToFolders(value);
            }

            return new List<RepositoryFolder>();
        }

        private static List<RepositoryFolder> ConvertToFolders(object value)
        {
            var result = new List<RepositoryFolder>();

            if (value is IList<object> sequence)
            {
                foreach (var item in sequence)
                {
                    var folder = ConvertFolderItem(item);
                    if (folder != null)
                        result.Add(folder);
                    else
                        Console.WriteLine("ModuleRepository: skipped invalid folder item in sequence");
                }
            }
            else if (value is IDictionary<object, object> map)
            {
                foreach (var entry in map)
                {
                    var folder = ConvertFolderEntry(entry.Key, entry.Value);
                    if (folder != null)
                        result.Add(folder);
                    else
                        Console.WriteLine("ModuleRepository: skipped invalid folder entry in map");
                }
            }

            return result;
        }

        private static RepositoryFolder ConvertFolderItem(object item)
        {
            if (item is string str)
                return CreateFolder(str, null);

            if (item is IDictionary<object, object> map)
            {
                string source = GetString(map, "path", "source", "folder", "repo_path", "from");
                string target = GetString(map, "target", "name", "to", "destination");

                if (string.IsNullOrEmpty(source) && map.Count == 1)
                {
                    var single = map.First();
                    source = single.Key?.ToString();
                    target = single.Value?.ToString();
                }

                return CreateFolder(source, target);
            }

            return null;
        }

        private static RepositoryFolder ConvertFolderEntry(object key, object value)
        {
            if (value is IDictionary<object, object> map)
            {
                string source = GetString(map, "path", "source", "folder", "repo_path", "from") ?? key?.ToString();
                string target = GetString(map, "target", "name", "to", "destination") ?? value?.ToString();
                return CreateFolder(source, target);
            }

            return CreateFolder(key?.ToString(), value?.ToString());
        }

        private static RepositoryFolder CreateFolder(string source, string target)
        {
            if (string.IsNullOrWhiteSpace(source))
                return null;

            var folder = new RepositoryFolder(source, target);
            if (!folder.IsValid)
                return null;

            return folder;
        }

        private static string GetString(IDictionary<object, object> map, params string[] keys)
        {
            foreach (var key in keys)
            {
                foreach (var entry in map)
                {
                    if (string.Equals(entry.Key?.ToString(), key, StringComparison.OrdinalIgnoreCase))
                        return entry.Value?.ToString();
                }
            }

            return null;
        }

        private static bool TryGetValue(IDictionary<object, object> map, string key, out object value)
        {
            foreach (var entry in map)
            {
                if (string.Equals(entry.Key?.ToString(), key, StringComparison.OrdinalIgnoreCase))
                {
                    value = entry.Value;
                    return true;
                }
            }

            value = null;
            return false;
        }

        private static Dictionary<string, string> LoadState()
        {
            if (repositoryState != null)
                return repositoryState;

            string path = Path.Combine(Environment.CurrentDirectory, StateFile.Replace('/', Path.DirectorySeparatorChar));

            if (File.Exists(path))
            {
                try
                {
                    var json = File.ReadAllText(path);
                    var data = JsonConvert.DeserializeObject<Dictionary<string, string>>(json);
                    if (data != null)
                        repositoryState = new Dictionary<string, string>(data, StringComparer.OrdinalIgnoreCase);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"module repository: failed to load state - {ex.Message}");
                }
            }

            repositoryState ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            Console.WriteLine($"ModuleRepository: loaded state entries = {repositoryState.Count}");
            return repositoryState;
        }

        private static void SaveState(Dictionary<string, string> state)
        {
            try
            {
                string path = Path.Combine(Environment.CurrentDirectory, StateFile.Replace('/', Path.DirectorySeparatorChar));
                Directory.CreateDirectory(Path.GetDirectoryName(path));
                File.WriteAllText(path, JsonConvert.SerializeObject(state, Formatting.Indented));
            }
            catch (Exception ex)
            {
                Console.WriteLine($"module repository: failed to save state - {ex.Message}");
            }
        }

        private static string GetLatestCommitSha(RepositoryEntry repository)
        {
            if (string.IsNullOrEmpty(repository.Owner) || string.IsNullOrEmpty(repository.Name))
            {
                Console.WriteLine("ModuleRepository: GetLatestCommitSha - owner or name is empty");
                return null;
            }

            // Determine a usable branch (try configured, default, then main, then master)
            var branch = DetermineBranch(repository);
            if (string.IsNullOrEmpty(branch))
            {
                Console.WriteLine($"ModuleRepository: could not determine a valid branch for {repository.Owner}/{repository.Name}");
                return null;
            }

            var branchInfo = GetJson(repository, $"https://api.github.com/repos/{repository.Owner}/{repository.Name}/branches/{Uri.EscapeDataString(branch)}");
            var sha = branchInfo?["commit"]?["sha"]?.Value<string>();
            Console.WriteLine($"ModuleRepository: latest commit sha for {repository.Owner}/{repository.Name} ({branch}) = {sha}");
            return sha;
        }

        private static string DetermineBranch(RepositoryEntry repository)
        {
            if (string.IsNullOrEmpty(repository.Owner) || string.IsNullOrEmpty(repository.Name))
                return null;

            var candidates = new List<string>();
            if (!string.IsNullOrWhiteSpace(repository.Branch))
                candidates.Add(repository.Branch.Trim());

            // Try to get default branch from repo metadata
            var repoInfo = GetJson(repository, $"https://api.github.com/repos/{repository.Owner}/{repository.Name}");
            var defaultBranch = repoInfo?["default_branch"]?.Value<string>();
            if (!string.IsNullOrWhiteSpace(defaultBranch) && !candidates.Contains(defaultBranch, StringComparer.OrdinalIgnoreCase))
                candidates.Add(defaultBranch);

            // Add common fallbacks
            if (!candidates.Contains("main", StringComparer.OrdinalIgnoreCase))
                candidates.Add("main");
            if (!candidates.Contains("master", StringComparer.OrdinalIgnoreCase))
                candidates.Add("master");

            foreach (var b in candidates)
            {
                if (string.IsNullOrWhiteSpace(b))
                    continue;

                var branchInfo = GetJson(repository, $"https://api.github.com/repos/{repository.Owner}/{repository.Name}/branches/{Uri.EscapeDataString(b)}");
                if (branchInfo != null)
                {
                    repository.Branch = b;
                    Console.WriteLine($"ModuleRepository: selected branch '{b}' for {repository.Owner}/{repository.Name}");
                    return b;
                }
            }

            return null;
        }

        private static HttpResponseMessage SendGetRequest(string url, RepositoryEntry repository, string acceptOverride = null, bool includeConfiguredAccept = true)
        {
            var request = CreateRequest(HttpMethod.Get, url, repository, acceptOverride, includeConfiguredAccept);

            try
            {
                return HttpClient.SendAsync(request).GetAwaiter().GetResult();
            }
            finally
            {
                request.Dispose();
            }
        }

        private static HttpRequestMessage CreateRequest(HttpMethod method, string url, RepositoryEntry repository, string acceptOverride, bool includeConfiguredAccept)
        {
            var request = new HttpRequestMessage(method, url);

            if (!string.IsNullOrWhiteSpace(repository?.Token))
                request.Headers.TryAddWithoutValidation("Authorization", repository.Token);

            if (includeConfiguredAccept && !string.IsNullOrWhiteSpace(repository?.AcceptHeader))
                request.Headers.TryAddWithoutValidation("Accept", repository.AcceptHeader);

            if (!string.IsNullOrWhiteSpace(acceptOverride))
                request.Headers.TryAddWithoutValidation("Accept", acceptOverride);

            return request;
        }

        private static JObject GetJson(RepositoryEntry repository, string url)
        {
            try
            {
                using var response = SendGetRequest(url, repository);
                if (!response.IsSuccessStatusCode)
                {
                    Console.WriteLine($"module repository: request {url} failed with {(int)response.StatusCode} {response.StatusCode}");
                    return null;
                }

                string json = response.Content.ReadAsStringAsync().GetAwaiter().GetResult();
                if (string.IsNullOrEmpty(json))
                    return null;

                Console.WriteLine($"ModuleRepository: GetJson success for {url}");
                return JsonConvert.DeserializeObject<JObject>(json);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"module repository: request {url} failed - {ex.Message}");
                return null;
            }
        }

        private static JArray GetJsonArray(RepositoryEntry repository, string url)
        {
            try
            {
                using var response = SendGetRequest(url, repository);
                if (!response.IsSuccessStatusCode)
                {
                    Console.WriteLine($"module repository: request {url} failed with {(int)response.StatusCode} {response.StatusCode}");
                    return null;
                }

                string json = response.Content.ReadAsStringAsync().GetAwaiter().GetResult();
                if (string.IsNullOrEmpty(json))
                    return null;

                Console.WriteLine($"ModuleRepository: GetJsonArray success for {url}");
                return JsonConvert.DeserializeObject<JArray>(json);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"module repository: request {url} failed - {ex.Message}");
                return null;
            }
        }

        private static List<RepositoryFolder> FetchRepositoryFolders(RepositoryEntry repository)
        {
            var result = new List<RepositoryFolder>();
            if (string.IsNullOrEmpty(repository.Owner) || string.IsNullOrEmpty(repository.Name))
                return result;

            var branch = DetermineBranch(repository);
            if (string.IsNullOrEmpty(branch))
                return result;

            string url = $"https://api.github.com/repos/{repository.Owner}/{repository.Name}/contents?ref={Uri.EscapeDataString(branch)}";
            var items = GetJsonArray(repository, url);
            if (items == null)
                return result;

            foreach (var item in items)
            {
                var type = item["type"]?.Value<string>();
                if (!string.Equals(type, "dir", StringComparison.OrdinalIgnoreCase))
                    continue;

                var name = item["name"]?.Value<string>();
                if (string.IsNullOrEmpty(name))
                    continue;

                var folder = new RepositoryFolder(name, null);
                if (folder.IsValid)
                    result.Add(folder);
            }

            return result;
        }

        private static bool DownloadAndExtract(RepositoryEntry repository, HashSet<string> modulesToCompile)
        {
            string branch = string.IsNullOrWhiteSpace(repository.Branch) ? "main" : repository.Branch;
            string archiveUrl = $"https://codeload.github.com/{repository.Owner}/{repository.Name}/zip/refs/heads/{Uri.EscapeDataString(branch)}";
            string tempZip = Path.Combine(Path.GetTempPath(), $"lampac-modrepo-{Guid.NewGuid():N}.zip");
            string tempDir = Path.Combine(Path.GetTempPath(), $"lampac-modrepo-{Guid.NewGuid():N}");

            Console.WriteLine($"ModuleRepository: DownloadAndExtract start for {repository.Owner}/{repository.Name} branch={branch}");

            try
            {
                Console.WriteLine($"ModuleRepository: downloading archive {archiveUrl}");
                using (var response = SendGetRequest(archiveUrl, repository))
                {
                    if (!response.IsSuccessStatusCode)
                    {
                        Console.WriteLine($"module repository: failed to download {archiveUrl} - {(int)response.StatusCode}{response.StatusCode}");
                        return false;
                    }

                    using (var stream = File.Create(tempZip))
                        response.Content.CopyToAsync(stream).GetAwaiter().GetResult();
                }

                ZipFile.ExtractToDirectory(tempZip, tempDir, true);
                Console.WriteLine($"ModuleRepository: archive extracted to {tempDir}");

                string root = Directory.GetDirectories(tempDir).FirstOrDefault();
                if (string.IsNullOrEmpty(root) || !Directory.Exists(root))
                {
                    Console.WriteLine("module repository: archive structure not recognized");
                    return false;
                }

                Console.WriteLine($"ModuleRepository: archive root = {root}");

                foreach (var folder in repository.Folders)
                {
                    string sourcePath = folder.GetSourcePath(root);
                    if (!Directory.Exists(sourcePath))
                    {
                        Console.WriteLine($"module repository: folder '{folder.Source}' not found in {repository.Url}");
                        continue;
                    }

                    string destinationPath = Path.Combine(Environment.CurrentDirectory, "module", folder.ModuleName);

                    string existingManifestJson = null;
                    string existingManifestPath = Path.Combine(destinationPath, "manifest.json");

                    if (Directory.Exists(destinationPath))
                    {
                        try
                        {
                            // Read existing manifest if present so we can preserve/merge its values
                            if (File.Exists(existingManifestPath))
                            {
                                try { existingManifestJson = File.ReadAllText(existingManifestPath); } catch { existingManifestJson = null; }
                            }

                            Directory.Delete(destinationPath, true);
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"module repository: failed to clean '{destinationPath}': {ex.Message}");
                            continue;
                        }
                    }

                    Directory.CreateDirectory(destinationPath);
                    CopyDirectory(sourcePath, destinationPath);

                    // After copying, merge manifests if we had an existing one
                    string newManifestPath = Path.Combine(destinationPath, "manifest.json");
                    if (!string.IsNullOrEmpty(existingManifestJson) && File.Exists(newManifestPath))
                    {
                        try
                        {
                            string newManifestJson = File.ReadAllText(newManifestPath);
                            var merged = MergeManifests(existingManifestJson, newManifestJson);
                            if (merged != null)
                                File.WriteAllText(newManifestPath, merged);
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"module repository: failed to merge post-copy manifest.json for '{folder.ModuleName}': {ex.Message}");
                        }
                    }

                    modulesToCompile.Add(folder.ModuleName);
                    Console.WriteLine($"module repository: updated module '{folder.ModuleName}' from {repository.Url}");
                }

                return true;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"module repository: {ex.Message}");
                return false;
            }
            finally
            {
                try { if (File.Exists(tempZip)) File.Delete(tempZip); } catch { }
                try { if (Directory.Exists(tempDir)) Directory.Delete(tempDir, true); } catch { }
                Console.WriteLine($"ModuleRepository: DownloadAndExtract finished for {repository.Owner}/{repository.Name}");
            }
        }

        private static string MergeManifests(string existingJson, string newJson)
        {
            try
            {
                var existingToken = JsonConvert.DeserializeObject<JToken>(existingJson);
                var newToken = JsonConvert.DeserializeObject<JToken>(newJson);

                if (existingToken == null)
                    return newJson;

                if (newToken == null)
                    return existingJson;

                // If both are arrays: merge by 'dll' key; start from existing to preserve custom fields
                if (existingToken is JArray existingArr && newToken is JArray newArr)
                {
                    // Build index for existing by dll (case-insensitive)
                    var existingIndex = new Dictionary<string, JObject>(StringComparer.OrdinalIgnoreCase);
                    foreach (var e in existingArr.OfType<JObject>())
                    {
                        var dll = e["dll"]?.Value<string>();
                        if (!string.IsNullOrEmpty(dll))
                            existingIndex[dll.ToLowerInvariant()] = (JObject)e.DeepClone();
                    }

                    // Apply updates from newArr: only properties present in source overwrite existing
                    foreach (var n in newArr.OfType<JObject>())
                    {
                        var ndll = n["dll"]?.Value<string>();
                        if (!string.IsNullOrEmpty(ndll) && existingIndex.TryGetValue(ndll.ToLowerInvariant(), out JObject existObj))
                        {
                            foreach (var prop in n.Properties())
                            {
                                var name = prop.Name;
                                if (string.Equals(name, "enable", StringComparison.OrdinalIgnoreCase))
                                {
                                    // preserve existing enable if present
                                    if (existObj.Property(name, StringComparison.OrdinalIgnoreCase) == null)
                                        existObj[name] = prop.Value.DeepClone();

                                    continue;
                                }

                                // Only update properties that exist in new manifest (we are iterating them)
                                existObj[name] = prop.Value.DeepClone();
                            }

                            existingIndex[ndll.ToLowerInvariant()] = existObj;
                        }
                        else
                        {
                            // New entry: add to existingIndex
                            var clone = (JObject)n.DeepClone();
                            existingIndex[ndll?.ToLowerInvariant() ?? Guid.NewGuid().ToString()] = clone;
                        }
                    }

                    // Preserve original order where possible: start with original existingArr order, then append any new ones not present
                    var resultArr = new JArray();

                    var added = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                    foreach (var e in existingArr.OfType<JObject>())
                    {
                        var dll = e["dll"]?.Value<string>() ?? string.Empty;
                        if (existingIndex.TryGetValue(dll.ToLowerInvariant(), out JObject val))
                        {
                            resultArr.Add(val);
                            added.Add(dll.ToLowerInvariant());
                        }
                        else
                        {
                            resultArr.Add(e);
                            added.Add(dll.ToLowerInvariant());
                        }
                    }

                    // Append remaining
                    foreach (var kv in existingIndex)
                    {
                        if (!added.Contains(kv.Key))
                            resultArr.Add(kv.Value);
                    }

                    return JsonConvert.SerializeObject(resultArr, Formatting.Indented);
                }

                // If both are objects: merge into existing, updating only fields present in new, but preserve existing enable
                if (existingToken is JObject existingObjRoot && newToken is JObject newObjRoot)
                {
                    foreach (var prop in newObjRoot.Properties())
                    {
                        var name = prop.Name;
                        if (string.Equals(name, "enable", StringComparison.OrdinalIgnoreCase) && existingObjRoot.Property(name, StringComparison.OrdinalIgnoreCase) != null)
                            continue; // preserve

                        existingObjRoot[name] = prop.Value.DeepClone();
                    }

                    return JsonConvert.SerializeObject(existingObjRoot, Formatting.Indented);
                }

                // Fallback: return newJson
                return newJson;
            }
            catch
            {
                return newJson;
            }
        }

        private static void CopyDirectory(string source, string destination)
        {
            foreach (string directory in Directory.GetDirectories(source, "*", SearchOption.AllDirectories))
            {
                string relative = Path.GetRelativePath(source, directory);
                if (ShouldSkip(relative))
                    continue;

                Directory.CreateDirectory(Path.Combine(destination, relative));
            }

            foreach (string file in Directory.GetFiles(source, "*", SearchOption.AllDirectories))
            {
                string relative = Path.GetRelativePath(source, file);
                if (ShouldSkip(relative))
                    continue;

                string target = Path.Combine(destination, relative);
                Directory.CreateDirectory(Path.GetDirectoryName(target));

                try
                {
                    File.Copy(file, target, true);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"module repository: failed to copy file '{file}' to '{target}': {ex.Message}");
                }
            }
        }

        private static bool ShouldSkip(string relative)
        {
            if (string.IsNullOrEmpty(relative))
                return false;

            string normalized = relative.Replace('\\', '/');
            if (normalized.StartsWith(".git", StringComparison.OrdinalIgnoreCase) || normalized.StartsWith(".github", StringComparison.OrdinalIgnoreCase))
                return true;

            string fileName = Path.GetFileName(normalized);
            if (string.Equals(fileName, ".gitignore", StringComparison.OrdinalIgnoreCase) || string.Equals(fileName, ".gitattributes", StringComparison.OrdinalIgnoreCase))
                return true;

            return false;
        }

        private static bool TryParseGitHubUrl(string url, out string owner, out string name)
        {
            owner = null;
            name = null;

            if (string.IsNullOrWhiteSpace(url))
                return false;

            string working = url.Trim();

            if (working.StartsWith("git@", StringComparison.OrdinalIgnoreCase))
            {
                int index = working.IndexOf(':');
                if (index != -1 && working.Length > index + 1)
                    working = working[(index + 1)..];
            }

            if (!working.StartsWith("http", StringComparison.OrdinalIgnoreCase) && working.Contains("github.com"))
                working = "https://" + working.TrimStart('/');

            if (Uri.TryCreate(working, UriKind.Absolute, out var uri) && uri.Host.EndsWith("github.com", StringComparison.OrdinalIgnoreCase))
            {
                var segments = uri.AbsolutePath.Trim('/').Split('/', StringSplitOptions.RemoveEmptyEntries);
                if (segments.Length >= 2)
                {
                    owner = segments[0];
                    name = segments[1];
                }
            }
            else
            {
                var parts = working.Trim('/').Split('/', StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length >= 2)
                {
                    owner = parts[^2];
                    name = parts[^1];
                }
            }

            if (!string.IsNullOrEmpty(name) && name.EndsWith(".git", StringComparison.OrdinalIgnoreCase))
                name = name[..^4];

            return !string.IsNullOrEmpty(owner) && !string.IsNullOrEmpty(name);
        }

        private sealed class RepositoryEntry
        {
            public string Url { get; set; }
            public string Branch { get; set; }
            public string Owner { get; set; }
            public string Name { get; set; }
            public string Token { get; set; }
            public string AcceptHeader { get; set; }
            public List<RepositoryFolder> Folders { get; set; } = new List<RepositoryFolder>();

            public bool IsValid => !string.IsNullOrEmpty(Url) && !string.IsNullOrEmpty(Owner) && !string.IsNullOrEmpty(Name) && Folders.Count > 0;

            public string StateKey => $"repo:{Url}|{Branch}";
        }

        private sealed class RepositoryFolder
        {
            public RepositoryFolder(string source, string target)
            {
                Source = Normalize(source);
                ModuleName = NormalizeTarget(target, Source);
            }

            public string Source { get; }

            public string ModuleName { get; }

            public bool IsValid => !string.IsNullOrEmpty(Source) && !string.IsNullOrEmpty(ModuleName);

            private static string Normalize(string value)
            {
                if (string.IsNullOrWhiteSpace(value))
                    return null;

                string trimmed = value.Trim().Replace('\\', '/').Trim('/');
                if (trimmed.Contains(".."))
                    return null;

                return trimmed;
            }

            private static string NormalizeTarget(string target, string source)
            {
                string normalized = Normalize(target);
                if (string.IsNullOrEmpty(normalized))
                    normalized = Normalize(source);

                if (string.IsNullOrEmpty(normalized))
                    return null;

                var segments = normalized.Split('/', StringSplitOptions.RemoveEmptyEntries);
                if (segments.Length == 0)
                    return null;

                return segments[^1].Replace('/', Path.DirectorySeparatorChar);
            }

            public string GetSourcePath(string root)
            {
                string path = root;
                foreach (string part in Source.Split('/', StringSplitOptions.RemoveEmptyEntries))
                    path = Path.Combine(path, part);

                return path;
            }
        }
    }
}
```

## File: Shared/Engine/SemaphorManager.cs
```
using System.Collections.Concurrent;
using System.Threading;

namespace Shared.Engine
{
    public class SemaphorManager
    {
        #region static
        private static readonly ConcurrentDictionary<string, SemaphoreEntry> _semaphoreLocks = new();
        private static readonly Timer _cleanupTimer = new(_ => Cleanup(), null, TimeSpan.FromMinutes(1), TimeSpan.FromSeconds(20));

        static void Cleanup()
        {
            var threshold = DateTime.UtcNow - TimeSpan.FromMinutes(2);

            foreach (var kvp in _semaphoreLocks.ToArray())
            {
                if (kvp.Value.LastUsed < threshold && _semaphoreLocks.TryRemove(kvp.Key, out var removed))
                    removed.Dispose();
            }
        }
        #endregion

        SemaphoreEntry semaphore { get; set; }
        TimeSpan timeSpan;


        public SemaphorManager(string key)
        {
            timeSpan = TimeSpan.FromSeconds(40);
            semaphore = _semaphoreLocks.GetOrAdd(key, _ => new SemaphoreEntry(new SemaphoreSlim(1, 1)));
        }

        public SemaphorManager(string key, TimeSpan timeSpan)
        {
            this.timeSpan = timeSpan;
            semaphore = _semaphoreLocks.GetOrAdd(key, _ => new SemaphoreEntry(new SemaphoreSlim(1, 1)));
        }


        public Task WaitAsync()
        {
            return semaphore.WaitAsync(timeSpan);
        }

        public Task WaitAsync(TimeSpan timeSpan)
        {
            return semaphore.WaitAsync(timeSpan);
        }

        public void Release()
        {
            try
            {
                semaphore.Release();
            }
            catch { }
        }


        async public Task Invoke(Action action)
        {
            try
            {
                await semaphore.WaitAsync(timeSpan);
                action();
            }
            finally
            {
                semaphore.Release();
            }
        }

        async public Task Invoke(Func<Task> func)
        {
            try
            {
                await semaphore.WaitAsync(timeSpan);
                await func();
            }
            finally
            {
                semaphore.Release();
            }
        }


        async public Task<T> Invoke<T>(Func<T> func)
        {
            try
            {
                await semaphore.WaitAsync(timeSpan);
                return func();
            }
            finally
            {
                semaphore.Release();
            }
        }

        async public Task<T> Invoke<T>(Func<Task<T>> func)
        {
            try
            {
                await semaphore.WaitAsync(timeSpan);
                return await func();
            }
            finally
            {
                semaphore.Release();
            }
        }


        #region SemaphoreEntry
        private sealed class SemaphoreEntry : IDisposable
        {
            private readonly SemaphoreSlim _semaphore;

            public SemaphoreEntry(SemaphoreSlim semaphore)
            {
                _semaphore = semaphore;
                Touch();
            }

            public DateTime LastUsed { get; private set; }

            public void Touch()
            {
                LastUsed = DateTime.UtcNow;
            }

            public Task WaitAsync(TimeSpan timeSpan)
            {
                Touch();
                return _semaphore.WaitAsync(timeSpan);
            }

            public void Release()
            {
                Touch();
                _semaphore.Release();
            }

            public void Dispose()
            {
                _semaphore.Dispose();
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/UnicTo.cs
```
Ôªøusing System.Text;

namespace Shared.Engine
{
    public static class UnicTo
    {
        static string ArrayList => "qwertyuioplkjhgfdsazxcvbnmQWERTYUIOPLKJHGFDSAZXCVBNM1234567890";
        static string ArrayListToNumber => "1234567890";

        public static string Code(int size = 8, bool IsNumberCode = false)
        {
            StringBuilder array = new StringBuilder();
            for (int i = 0; i < size; i++)
            {
                array.Append(ArrayList[Random.Shared.Next(0, 61)]);
            }

            return array.ToString();
        }

        public static string Number(int size = 8)
        {
            StringBuilder array = new StringBuilder();
            for (int i = 0; i < size; i++)
            {
                array.Append(ArrayListToNumber[Random.Shared.Next(0, 9)]);
            }

            return array.ToString();
        }
    }
}

```

## File: Shared/Engine/RchClient.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models;
using Shared.Models.Base;
using Shared.Models.Events;
using System.Collections.Concurrent;
using System.Text.RegularExpressions;
using System.Threading;

namespace Shared.Engine
{
    public class RchClientInfo
    {
        public int version { get; set; }
        public string host { get; set; }
        public string rchtype { get; set; }
        public int apkVersion { get; set; }
        public string player { get; set; }
        public string account_email { get; set; }
        public string unic_id { get; set; }
        public string profile_id { get; set; }
        public string token { get; set; }

        public object ob { get; set; }
        public Dictionary<string, object> obs { get; set; } = new Dictionary<string, object>();
    }

    public struct RchClient
    {
        #region static
        static RchClient()
        {
            _checkConnectionTimer = new Timer(CheckConnection, null, TimeSpan.FromMinutes(2), TimeSpan.FromMinutes(4));
        }

        static Timer _checkConnectionTimer;

        static bool _cronCheckConnectionWork = false;

        async static void CheckConnection(object state)
        {
            if (_cronCheckConnectionWork || clients.Count == 0)
                return;

            _cronCheckConnectionWork = true;

            try
            {
                await Parallel.ForEachAsync(clients.Keys.ToArray(), new ParallelOptions 
                { 
                    MaxDegreeOfParallelism = Math.Max(2, Environment.ProcessorCount) 
                }, 
                async (connectionId, cancellationToken) =>
                {
                    if (clients.TryGetValue(connectionId, out var client) && client.connection == null)
                    {
                        var rch = new RchClient(connectionId);
                        string result = await rch.SendHub("ping", useDefaultHeaders: false);
                        if (result != "pong")
                            OnDisconnected(connectionId);
                    }
                });
            }
            catch { }
            finally
            {
                _cronCheckConnectionWork = false;
            }
        }


        public static string ErrorMsg => AppInit.conf.rch.enable ? "rhub –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –¥–∞–Ω–Ω—ã–º –±–∞–ª–∞–Ω—Å–µ—Ä–æ–º" : "–í–∫–ª—é—á–∏—Ç–µ rch –≤ init.conf";

        public static EventHandler<(string connectionId, string rchId, string url, string data, Dictionary<string, string> headers, bool returnHeaders)> hub = null;

        public static readonly ConcurrentDictionary<string, (string ip, string host, RchClientInfo info, NwsConnection connection)> clients = new ConcurrentDictionary<string, (string, string, RchClientInfo, NwsConnection)>();

        public static readonly ConcurrentDictionary<string, TaskCompletionSource<string>> rchIds = new ConcurrentDictionary<string, TaskCompletionSource<string>>();


        public static void Registry(string ip, string connectionId, string host = null, string json = null, NwsConnection connection = null)
        {
            var info = new RchClientInfo();

            if (json != null)
            {
                try
                {
                    info = System.Text.Json.JsonSerializer.Deserialize<RchClientInfo>(json);
                }
                catch { }
            }

            if (AppInit.conf.rch.blacklistHost != null && info.host != null)
            {
                foreach (string h in AppInit.conf.rch.blacklistHost)
                {
                    if (info.host.Contains(h))
                        return;
                }
            }

            if (info == null)
                info = new RchClientInfo() { version = -1 };

            clients.AddOrUpdate(connectionId, (ip, host, info, connection), (i, j) => (ip, host, info, connection));
            InvkEvent.RchRegistry(new EventRchRegistry(connectionId, ip, host, info, connection));
        }


        public static void OnDisconnected(string connectionId)
        {
            if (clients.TryRemove(connectionId, out _))
                InvkEvent.RchDisconnected(new EventRchDisconnected(connectionId));
        }
        #endregion

        BaseSettings init;

        HttpContext httpContext;

        string ip, connectionId;

        bool enableRhub, rhub_fallback;

        public bool enable => init.rhub && enableRhub;

        public string connectionMsg { get; private set; }

        public string ipkey(string key, ProxyManager? proxy) => $"{key}:{(enableRhub ? ip : proxy?.CurrentProxyIp)}";

        public RchClient(string connectionId) 
        {
            this.connectionId = connectionId;
        }

        public RchClient(HttpContext context, string host, BaseSettings init, in RequestModel requestInfo, int? keepalive = null)
        {
            this.init = init;
            httpContext = context;
            enableRhub = init.rhub;
            rhub_fallback = init.rhub_fallback;
            ip = requestInfo.IP;

            if (enableRhub && rhub_fallback && init.rhub_geo_disable != null)
            {
                if (requestInfo.Country != null && init.rhub_geo_disable.Contains(requestInfo.Country))
                {
                    enableRhub = false;
                    init.rhub = false;
                }
            }

            connectionMsg = System.Text.Json.JsonSerializer.Serialize(new
            {
                rch = true,
                ws = $"{host}/ws",
                nws = $"{(host.StartsWith("https") ? "wss" : "ws")}://{Regex.Replace(host, "^https?://", "")}/nws"
            });
        }


        public void Disabled()
        {
            enableRhub = false;
        }


        #region Eval
        public void EvalRun(string data)
        {
            _= SendHub("evalrun", data).ConfigureAwait(false);
        }

        async public Task<string> Eval(string data)
        {
            return await SendHub("eval", data).ConfigureAwait(false);
        }

        async public Task<T> Eval<T>(string data, bool IgnoreDeserializeObject = false)
        {
            try
            {
                string json = await SendHub("eval", data, useDefaultHeaders: false).ConfigureAwait(false);
                if (json == null)
                    return default;

                if (IgnoreDeserializeObject)
                    return JsonConvert.DeserializeObject<T>(json, new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } });

                return JsonConvert.DeserializeObject<T>(json);
            }
            catch
            {
                return default;
            }
        }
        #endregion

        #region Headers
        async public Task<(JObject headers, string currentUrl, string body)> Headers(string url, string data, List<HeadersModel> headers = null, bool useDefaultHeaders = true)
        {
            try
            {
                string json = await SendHub(url, data, headers, useDefaultHeaders, true).ConfigureAwait(false);
                if (json == null)
                    return default;

                var job = JsonConvert.DeserializeObject<JObject>(json);
                if (!job.ContainsKey("body"))
                    return default;

                return (job.Value<JObject>("headers"), job.Value<string>("currentUrl"), job.Value<string>("body"));
            }
            catch
            {
                return default;
            }
        }
        #endregion

        #region Get
        async public ValueTask<string> Get(string url, List<HeadersModel> headers = null, bool useDefaultHeaders = true)
        {
            return await SendHub(url, null, headers, useDefaultHeaders).ConfigureAwait(false);
        }

        async public ValueTask<T> Get<T>(string url, List<HeadersModel> headers = null, bool IgnoreDeserializeObject = false, bool useDefaultHeaders = true)
        {
            try
            {
                string html = await SendHub(url, null, headers, useDefaultHeaders).ConfigureAwait(false);
                if (html == null)
                    return default;

                if (IgnoreDeserializeObject)
                    return JsonConvert.DeserializeObject<T>(html, new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } });

                return JsonConvert.DeserializeObject<T>(html);
            }
            catch
            {
                return default;
            }
        }
        #endregion

        #region Post
        async public ValueTask<string> Post(string url, string data, List<HeadersModel> headers = null, bool useDefaultHeaders = true) 
        {
            return await SendHub(url, data, headers, useDefaultHeaders).ConfigureAwait(false);
        }

        async public ValueTask<T> Post<T>(string url, string data, List<HeadersModel> headers = null, bool IgnoreDeserializeObject = false, bool useDefaultHeaders = true)
        {
            try
            {
                string json = await SendHub(url, data, headers, useDefaultHeaders).ConfigureAwait(false);
                if (json == null)
                    return default;

                if (IgnoreDeserializeObject)
                    return JsonConvert.DeserializeObject<T>(json, new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } });

                return JsonConvert.DeserializeObject<T>(json);
            }
            catch
            {
                return default;
            }
        }
        #endregion

        #region SendHub
        async Task<string> SendHub(string url, string data = null, List<HeadersModel> headers = null, bool useDefaultHeaders = true, bool returnHeaders = false, bool waiting = true)
        {
            if (hub == null)
                return null;

            if (string.IsNullOrEmpty(connectionId) || !clients.ContainsKey(connectionId))
                connectionId = SocketClient().connectionId;

            if (string.IsNullOrEmpty(connectionId))
                return null;

            string rchId = Guid.NewGuid().ToString();

            try
            {
                var tcs = new TaskCompletionSource<string>();
                rchIds.TryAdd(rchId, tcs);

                var send_headers = !useDefaultHeaders ? null : new Dictionary<string, string>(Http.defaultHeaders)
                {
                    { "Accept-Language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5" }
                };

                if (headers != null)
                {
                    if (send_headers == null)
                        send_headers = new Dictionary<string, string>();

                    foreach (var h in headers)
                    {
                        if (!send_headers.ContainsKey(h.name))
                            send_headers.TryAdd(h.name, h.val);
                    }
                }

                hub.Invoke(null, (connectionId, rchId, url, data, send_headers, returnHeaders));

                if (!waiting)
                    return null;

                string result = await tcs.Task.WaitAsync(TimeSpan.FromSeconds(rhub_fallback ? 8 : 12)).ConfigureAwait(false);
                rchIds.TryRemove(rchId, out _);

                if (string.IsNullOrWhiteSpace(result))
                    return null;

                return result;
            }
            catch
            {
                return null;
            }
            finally 
            {
                rchIds.TryRemove(rchId, out _);
            }
        }
        #endregion


        #region IsNotConnected
        public bool IsNotConnected() => IsNotConnected(ip);

        bool IsNotConnected(string ip)
        {
            if (!enableRhub)
                return false; // rch –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è

            if (httpContext != null && httpContext.Request.QueryString.Value.Contains("&checksearch=true"))
                return true; // –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è checksearch

            return SocketClient().connectionId == null;
        }
        #endregion

        #region IsRequiredConnected
        public bool IsRequiredConnected()
        {
            if (!AppInit.conf.rch.requiredConnected)
                return false; // –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ

            if (httpContext != null)
            {
                var requestInfo = httpContext.Features.Get<RequestModel>();
                if (requestInfo.IsLocalRequest)
                    return false;
            }

            return SocketClient().connectionId == null;
        }
        #endregion

        #region IsNotSupport
        public bool IsNotSupport(string rch_deny, out string rch_msg)
        {
            rch_msg = null;

            if (!enableRhub)
                return false; // rch –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è

            if (httpContext != null && httpContext.Request.QueryString.Value.Contains("&checksearch=true"))
                return false; // –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è checksearch

            var info = InfoConnected();
            if (info == null || string.IsNullOrEmpty(info.rchtype))
                return false; // –∫–ª–∏–µ–Ω—Ç –Ω–µ –≤ —Å–µ—Ç–∏

            // —Ä–∞–∑—Ä–µ—à–µ–Ω –≤–æ–∑–≤—Ä–∞—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä
            if (rhub_fallback)
            {
                if (rch_deny.Contains(info.rchtype)) {
                    enableRhub = false;
                    init.rhub = false;
                }
                return false;
            }

            if (AppInit.conf.rch.notSupportMsg != null)
                rch_msg = AppInit.conf.rch.notSupportMsg;
            else if (info.rchtype == "web")
                rch_msg = "–ù–∞ MSX –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ";
            else
                rch_msg = "–¢–æ–ª—å–∫–æ –Ω–∞ android";

            return rch_deny.Contains(info.rchtype);
        }
        #endregion

        #region InfoConnected
        public RchClientInfo InfoConnected()
        {
            return SocketClient().data.rch_info;
        }
        #endregion

        #region SocketClient
        public (string connectionId, (string ip, string host, RchClientInfo rch_info, NwsConnection connection) data) SocketClient()
        {
            string _ip = ip;

            if (AppInit.conf.rch.websoket == "nws")
            {
                if (!string.IsNullOrEmpty(connectionId) && clients.ContainsKey(connectionId))
                    return (connectionId, clients[connectionId]);

                if (httpContext == null)
                    return default;

                if (httpContext.Request.Query.ContainsKey("nws_id"))
                {
                    string nws_id = httpContext.Request.Query["nws_id"].ToString()?.ToLower()?.Trim();
                    if (!string.IsNullOrEmpty(nws_id) && clients.ContainsKey(nws_id))
                        return (nws_id, clients[nws_id]);
                }
            }
            else
            {
                var client = clients.LastOrDefault(i => i.Value.ip == _ip);
                if (client.Value.info?.rchtype != null)
                    return (client.Key, client.Value);
            }

            return default;
        }
        #endregion
    }
}

```

## File: Shared/Engine/ProxyManager.cs
```
Ôªøusing Microsoft.Extensions.Caching.Memory;
using Shared.Models.Base;
using Shared.Models.Proxy;
using System.Collections.Concurrent;
using System.Net;
using System.Text.RegularExpressions;
using System.Threading;

namespace Shared.Engine
{
    public class ProxyManager
    {
        #region static
        static IMemoryCache memoryCache;
        static ConcurrentDictionary<string, ProxyManagerModel> database = new ConcurrentDictionary<string, ProxyManagerModel>();

        public static void Configure(IMemoryCache mem)
        {
            memoryCache = mem;
        }
        #endregion

        #region ProxyManager
        string plugin;
        bool refresh;
        Iproxy conf;

        public string[] proxyKeys;

        public ProxyManager(string plugin, Iproxy conf, bool refresh = true)
        {
            this.plugin = plugin;
            this.conf = conf;
            this.refresh = refresh;
            proxyKeys = [plugin, $"{plugin}:conf", $"{plugin}:globalname"];
        }

        public ProxyManager(BaseSettings conf, bool refresh = true)
        {
            plugin = !string.IsNullOrEmpty(conf.plugin) ? conf.plugin : conf.host ?? conf.apihost;
            this.conf = conf;
            this.refresh = refresh;
            proxyKeys = [plugin, $"{plugin}:conf", $"{plugin}:globalname"];
        }
        #endregion

        #region Get / BaseGet
        public WebProxy Get() => BaseGet().proxy;

        public (WebProxy proxy, (string ip, string username, string password) data) BaseGet()
        {
            if (!conf.useproxy && !conf.useproxystream)
                return default;

            (WebProxy proxy, (string ip, string username, string password) data) proxy(ProxySettings p_orig, string key)
            {
                ProxySettings p = ConfigureProxy(p_orig);

                if (p?.list == null || p.list.Length == 0)
                    return default;

                if (!database.TryGetValue(key, out ProxyManagerModel val) || val.proxyip == null || !p.list.Contains(val.proxyip))
                {
                    val = new ProxyManagerModel();

                    if (p.actions != null && p.actions.Count > 0)
                    {
                        val.proxyip = p.list.First();
                        start_action(p, key, val.proxyip);
                    }
                    else
                    {
                        val.proxyip = p.list.OrderBy(a => Guid.NewGuid()).First();
                        database.AddOrUpdate(key, val, (k, v) => val);
                    }
                }

                return ConfigureWebProxy(p, val.proxyip);
            }


            if (conf.proxy?.list != null && conf.proxy.list.Length > 0 || !string.IsNullOrEmpty(conf.proxy?.file) || !string.IsNullOrEmpty(conf.proxy?.url))
            {
                return proxy(conf.proxy, $"{plugin}:conf");
            }
            else
            {
                if (!string.IsNullOrEmpty(conf.globalnameproxy))
                {
                    string _globalnameproxy = conf.globalnameproxy;
                    return proxy(AppInit.conf.globalproxy.FirstOrDefault(i => i.name == _globalnameproxy), $"{plugin}:globalname");
                }
                else
                {
                    return proxy(AppInit.conf.proxy, $"{plugin}:conf");
                }
            }
        }
        #endregion

        #region Refresh
        public void Refresh()
        {
            if (!refresh)
                return;

            void update(ProxySettings p, string key)
            {
                if (database.TryGetValue(key, out ProxyManagerModel val))
                {
                    int maxRequestError = 2;
                    if (p?.maxRequestError > 0)
                        maxRequestError = p.maxRequestError;

                    if (val.errors >= maxRequestError)
                    {
                        if (!string.IsNullOrEmpty(p?.refresh_uri))
                            _ = Http.Get(p.refresh_uri, timeoutSeconds: 5).ConfigureAwait(false);

                        if (p?.actions != null && p.actions.Count > 0)
                        {
                            val.errors = 0;
                            start_action(ConfigureProxy(p), key);
                            return;
                        }

                        val.errors = 0;
                        val.proxyip = null;
                        database.TryRemove(key, out _);
                    }
                    else
                    {
                        val.errors += 1;
                    }
                }
            }

            update(AppInit.conf.proxy, plugin);

            if (conf == null)
                return;

            update(conf.proxy, $"{plugin}:conf");
            string _globalnameproxy = conf.globalnameproxy;
            update(AppInit.conf.globalproxy.FirstOrDefault(i => i.name == _globalnameproxy), $"{plugin}:globalname");
        }
        #endregion

        #region Success
        public void Success()
        {
            foreach (string key in proxyKeys)
            {
                if (database.TryGetValue(key, out var val) && val.errors > 0)
                    val.errors = 0;
            }
        }
        #endregion

        #region CurrentProxyIp
        public string CurrentProxyIp
        {
            get
            {
                foreach (string key in proxyKeys)
                {
                    if (database.TryGetValue(key, out var val))
                        return val.proxyip;
                }

                return null;
            }
        }
        #endregion



        ProxySettings ConfigureProxy(ProxySettings orig)
        {
            if (orig == null)
                return null;

            ProxySettings p = (ProxySettings)orig.Clone();

            if (!string.IsNullOrEmpty(p.file) && File.Exists(p.file))
                p.list = File.ReadAllLines(p.file);

            if (!string.IsNullOrEmpty(p.url))
            {
                string mkey = $"ProxyManager:{p.url}";
                if (!memoryCache.TryGetValue(mkey, out List<string> list))
                {
                    list = new List<string>();

                    string txt = Http.Get(p.url, timeoutSeconds: 5).Result;
                    if (txt != null)
                    {
                        foreach (string line in txt.Split("\n"))
                        {
                            if (line.Contains(":"))
                                list.Add(line.Trim());
                        }
                    }

                    memoryCache.Set(mkey, list, DateTime.Now.AddMinutes(15));
                }

                p.list = list.ToArray();
            }

            return p;
        }


        public static (WebProxy proxy, (string ip, string username, string password) data) ConfigureWebProxy(ProxySettings p, string proxyip)
        {
            NetworkCredential credentials = null;

            if (proxyip.Contains("@"))
            {
                var g = Regex.Match(proxyip, p.pattern_auth).Groups;
                proxyip = g["sheme"].Value + g["host"].Value;
                credentials = new NetworkCredential(g["username"].Value, g["password"].Value);
            }
            else if (p.useAuth)
                credentials = new NetworkCredential(p.username, p.password);

            var proxy = new WebProxy(proxyip, p.BypassOnLocal, null, credentials);
            return (proxy, (proxyip, credentials?.UserName, credentials?.Password));
        }


        void start_action(ProxySettings p, string key, string current_proxyip = null)
        {
            if (p == null)
                return;

            string mkey = $"ProxyManager:start_action:{key}";
            if (memoryCache.TryGetValue(mkey, out _))
                return;

            memoryCache.Set(mkey, 0, DateTime.Now.AddMinutes(10));

            ThreadPool.QueueUserWorkItem(async _ =>
            {
                try
                {
                    string proxyip = null;
                    var list = p.list.OrderBy(a => Guid.NewGuid()).ToList();

                    if (!string.IsNullOrEmpty(current_proxyip))
                    {
                        if (list.Contains(current_proxyip))
                        {
                            list.Remove(current_proxyip);
                            list.Insert(0, current_proxyip);
                        }
                    }

                    foreach (string proxy in list.Take(p.actions_attempts))
                    {
                        bool isok = true;
                        proxyip = proxy;

                        foreach (var action in p.actions)
                        {
                            string result = string.Empty;

                            if (!string.IsNullOrEmpty(action.data))
                                result = await Http.Post(action.url, action.data, httpversion: 2, timeoutSeconds: action.timeoutSeconds, proxy: ConfigureWebProxy(p, proxy).proxy);
                            else
                                result = await Http.Get(action.url, httpversion: 2, timeoutSeconds: action.timeoutSeconds, proxy: ConfigureWebProxy(p, proxy).proxy);

                            if (result == null || !result.Contains(action.contains))
                            {
                                isok = false;
                                break;
                            }
                        }

                        if (isok)
                            break;
                    }

                    var val = new ProxyManagerModel();
                    val.proxyip = proxyip;
                    database.AddOrUpdate(key, val, (k, v) => val);
                }
                catch { }
                finally
                {
                    memoryCache.Remove(mkey);
                }
            });
        }
    }
}

```

## File: Shared/Engine/FrendlyHttp.cs
```
Ôªøusing System.Collections.Concurrent;
using System.Net;
using System.Net.Http;
using System.Threading;

namespace Shared.Engine
{
    public static class FrendlyHttp
    {
        #region static
        static ConcurrentDictionary<string, (DateTime lifetime, HttpClient http)> _clients = new ConcurrentDictionary<string, (DateTime, HttpClient)>();

        static FrendlyHttp()
        {
            ThreadPool.QueueUserWorkItem(async _ => 
            {
                while (true)
                {
                    await Task.Delay(TimeSpan.FromMinutes(1));

                    try
                    {
                        foreach (var c in _clients.Where(c => DateTime.UtcNow > c.Value.lifetime).ToArray())
                        {
                            try
                            {
                                if (_clients.TryRemove(c.Key, out var _c))
                                {
                                    await Task.Delay(TimeSpan.FromSeconds(20));
                                    _c.http.Dispose();
                                }
                            }
                            catch { }
                        }
                    }
                    catch { }
                }
            });
        }
        #endregion

        #region HttpMessageClient
        public static HttpClient HttpMessageClient
        (
            string factoryClient,
            HttpClientHandler handler,
            long MaxResponseContentBufferSize = -1
        )
        {
            // 10MB
            long maxBufferSize = 10_000_000;
            if (MaxResponseContentBufferSize > 0)
                maxBufferSize = MaxResponseContentBufferSize;

            if ((handler != null && handler.CookieContainer.Count > 0) || Http.httpClientFactory == null)
            {
                var client = new HttpClient(handler);
                client.MaxResponseContentBufferSize = maxBufferSize;
                return client;
            }

            var webProxy = handler?.Proxy != null ? handler.Proxy as WebProxy : null;

            if (webProxy == null)
            {
                if (handler != null && handler.AllowAutoRedirect == false)
                {
                    if (factoryClient is "base" or "http2")
                        factoryClient += "NoRedirect";
                }

                var factory = Http.httpClientFactory.CreateClient(factoryClient);

                if (maxBufferSize > factory.MaxResponseContentBufferSize)
                    factory.MaxResponseContentBufferSize = maxBufferSize;

                return factory;
            }

            int port = 0;
            string ip = null, username = null, password = null;

            ip = webProxy.Address?.Host;
            port = webProxy.Address?.Port ?? 0;

            if (webProxy.Credentials is NetworkCredential credentials)
            {
                username = credentials.UserName;
                password = credentials.Password;
            }

            return _clients.GetOrAdd($"{ip}:{port}:{username}:{password}:{MaxResponseContentBufferSize}:{handler?.AllowAutoRedirect}", k => 
            {
                var client = new HttpClient(handler);
                client.MaxResponseContentBufferSize = maxBufferSize;

                return (DateTime.UtcNow.AddMinutes(30), client);

            }).http;
        }
        #endregion
    }
}

```

## File: Shared/Engine/HtmlParse.cs
```
Ôªøusing HtmlAgilityPack;
using System.Text.RegularExpressions;

namespace Shared.Engine
{
    public class HtmlParse
    {
        public List<HtmlRowParse> nodes { get; private set; } = new List<HtmlRowParse>();

        public HtmlParse(string html, string xpathNodes) 
        {
            var doc = new HtmlDocument();
            doc.LoadHtml(html);

            var _nodes = doc.DocumentNode?.SelectNodes(xpathNodes);
            if (_nodes == null)
                return;

            foreach (var node in _nodes)
                nodes.Add(new HtmlRowParse(node));
        }

        public static List<HtmlRowParse> Nodes(string html, string xpathNodes)
        {
            return new HtmlParse(html, xpathNodes).nodes;
        }
    }


    public class HtmlRowParse
    {
        public HtmlNode row { get; private set; }

        public HtmlRowParse(HtmlNode node)
        {
            row = node;
        }

        #region SelectText
        public string SelectText(string xpath, string attribute = null, string[] attributes = null)
        {
            string value = null;

            if (string.IsNullOrEmpty(xpath) && (!string.IsNullOrEmpty(attribute) || attributes != null))
            {
                if (attributes != null)
                {
                    foreach (var attr in attributes)
                    {
                        string attrValue = row.GetAttributeValue(attr, null);
                        if (!string.IsNullOrWhiteSpace(attrValue))
                        {
                            value = attrValue;
                            break;
                        }
                    }
                }
                else
                {
                    value = row.GetAttributeValue(attribute, null);
                }
            }
            else
            {
                var inNode = row.SelectSingleNode(xpath);
                if (inNode != null)
                {
                    if (attributes != null)
                    {
                        foreach (var attr in attributes)
                        {
                            string attrValue = inNode.GetAttributeValue(attr, null);
                            if (!string.IsNullOrWhiteSpace(attrValue))
                            {
                                value = attrValue;
                                break;
                            }
                        }
                    }
                    else
                    {
                        value = (!string.IsNullOrEmpty(attribute) ? inNode.GetAttributeValue(attribute, null) : inNode.InnerText);
                    }
                }
            }

            if (string.IsNullOrWhiteSpace(value))
                return null;

            return value?.Trim();
        }
        #endregion

        #region SelectHtml
        public string SelectHtml(string xpath)
        {
            var inNode = row.SelectSingleNode(xpath);
            if (inNode != null)
            {
                string html = inNode.InnerHtml;
                if (string.IsNullOrWhiteSpace(html))
                    return null;

                return inNode.InnerHtml;
            }

            return null;
        }
        #endregion

        #region Regex
        public string Regex(string xpath, string pattern, int index = 1, RegexOptions options = RegexOptions.IgnoreCase)
        {
            string html = SelectHtml(pattern);
            if (string.IsNullOrWhiteSpace(html))
                return null;

            string res = System.Text.RegularExpressions.Regex.Match(html, pattern, options).Groups[index].Value;
            if (string.IsNullOrWhiteSpace(res))
                return null;

            return res.Trim();
        }

        public string Regex(string xpath, string pattern, string groupName, RegexOptions options = RegexOptions.IgnoreCase)
        {
            string html = SelectHtml(pattern);
            if (string.IsNullOrWhiteSpace(html))
                return null;

            string res = System.Text.RegularExpressions.Regex.Match(html, pattern, options).Groups[groupName].Value;
            if (string.IsNullOrWhiteSpace(res))
                return null;

            return res.Trim();
        }


        public string Regex(string pattern, int index = 1, RegexOptions options = RegexOptions.IgnoreCase)
        {
            string res = System.Text.RegularExpressions.Regex.Match(row.InnerHtml, pattern, options).Groups[index].Value;
            if (string.IsNullOrWhiteSpace(res))
                return null;

            return res.Trim();
        }

        public string Regex(string pattern, string groupName, RegexOptions options = RegexOptions.IgnoreCase)
        {
            string res = System.Text.RegularExpressions.Regex.Match(row.InnerHtml, pattern, options).Groups[groupName].Value;
            if (string.IsNullOrWhiteSpace(res))
                return null;

            return res.Trim();
        }
        #endregion
    }
}

```

## File: Shared/Engine/CSharpEval.cs
```
Ôªøusing Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;
using Microsoft.CodeAnalysis.Scripting.Hosting;
using Microsoft.Extensions.DependencyModel;
using Shared.Models.Module;
using System.Collections.Concurrent;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine
{
    public static class CSharpEval
    {
        static ConcurrentDictionary<string, dynamic> scripts = new ConcurrentDictionary<string, dynamic>();

        public static PortableExecutableReference ReferenceFromFile(string dll)
        {
            if (File.Exists(dll))
                return MetadataReference.CreateFromFile(Path.Combine(AppContext.BaseDirectory, dll));

            return MetadataReference.CreateFromFile(Path.Combine(AppContext.BaseDirectory, "runtimes", "references", dll));
        }


        #region Execute<T>
        public static T Execute<T>(in string cs, object model, ScriptOptions options = null)
        {
            return ExecuteAsync<T>(cs, model, options).GetAwaiter().GetResult();
        }

        public static Task<T> ExecuteAsync<T>(string cs, object model, ScriptOptions options = null)
        {
            var entry = scripts.GetOrAdd(CrypTo.md5(cs), _ =>
            {
                if (options == null)
                    options = ScriptOptions.Default;

                options = options.AddReferences(typeof(Console).Assembly).AddImports("System")
                                 .AddReferences(typeof(HttpUtility).Assembly).AddImports("System.Web")
                                 .AddReferences(typeof(Enumerable).Assembly).AddImports("System.Linq")
                                 .AddReferences(typeof(List<>).Assembly).AddImports("System.Collections.Generic")
                                 .AddReferences(typeof(Regex).Assembly).AddImports("System.Text.RegularExpressions");

                return CSharpScript.Create<T>(
                    cs,
                    options,
                    globalsType: model.GetType(),
                    assemblyLoader: new InteractiveAssemblyLoader()
                ).CreateDelegate();
            });

            return entry(model);
        }
        #endregion

        #region BaseExecute<T>
        public static T BaseExecute<T>(in string cs, object model, ScriptOptions options = null, InteractiveAssemblyLoader loader = null)
        {
            return BaseExecuteAsync<T>(cs, model, options, loader).GetAwaiter().GetResult();
        }

        public static Task<T> BaseExecuteAsync<T>(string cs, object model, ScriptOptions options = null, InteractiveAssemblyLoader loader = null)
        {
            var entry = scripts.GetOrAdd(CrypTo.md5(cs), _ =>
            {
                return CSharpScript.Create<T>(
                    cs,
                    options,
                    globalsType: model.GetType(),
                    assemblyLoader: loader
                ).CreateDelegate();
            });

            return entry(model);
        }
        #endregion

        #region Execute
        public static void Execute(in string cs, object model, ScriptOptions options = null)
        {
            ExecuteAsync(cs, model, options).GetAwaiter().GetResult();
        }

        public static Task ExecuteAsync(string cs, object model, ScriptOptions options = null)
        {
            var entry = scripts.GetOrAdd(CrypTo.md5(cs), _ =>
            {
                if (options == null)
                    options = ScriptOptions.Default;

                options = options.AddReferences(typeof(Console).Assembly).AddImports("System")
                                 .AddReferences(typeof(HttpUtility).Assembly).AddImports("System.Web")
                                 .AddReferences(typeof(Enumerable).Assembly).AddImports("System.Linq")
                                 .AddReferences(typeof(List<>).Assembly).AddImports("System.Collections.Generic")
                                 .AddReferences(typeof(Regex).Assembly).AddImports("System.Text.RegularExpressions");

                return CSharpScript.Create(
                    cs,
                    options,
                    globalsType: model.GetType(),
                    assemblyLoader: new InteractiveAssemblyLoader()
                ).CreateDelegate();
            });

            return entry(model);
        }
        #endregion


        #region Compilation
        public static List<PortableExecutableReference> appReferences;
        static readonly object lockCompilationObj = new();

        public static Assembly Compilation(RootModule mod)
        {
            string path = $"{Environment.CurrentDirectory}/module/{mod.dll}";
            if (Directory.Exists(path))
            {
                lock (lockCompilationObj)
                {
                    var syntaxTree = new List<SyntaxTree>();

                    foreach (string file in Directory.GetFiles(path, "*.cs", SearchOption.AllDirectories))
                    {
                        string _file = file.Replace("\\", "/").Replace(path.Replace("\\", "/"), "").Replace(Environment.CurrentDirectory.Replace("\\", "/"), "");
                        if (Regex.IsMatch(_file, "(\\.vs|bin|obj|Properties)/", RegexOptions.IgnoreCase))
                            continue;

                        syntaxTree.Add(CSharpSyntaxTree.ParseText(File.ReadAllText(file)));
                    }

                    if (appReferences == null)
                    {
                        var dependencyContext = DependencyContext.Default;
                        var assemblies = dependencyContext.RuntimeLibraries
                            .SelectMany(library => library.GetDefaultAssemblyNames(dependencyContext))
                            .Select(Assembly.Load)
                            .ToList();

                        appReferences = assemblies.Select(assembly => MetadataReference.CreateFromFile(assembly.Location)).ToList();
                    }

                    if (mod.references != null)
                    {
                        foreach (string refns in mod.references)
                        {
                            string dlrns = Path.Combine(Environment.CurrentDirectory, "module", mod.dll, refns);
                            if (File.Exists(dlrns) && appReferences.FirstOrDefault(a => Path.GetFileName(a.FilePath) == refns) == null)
                            {
                                var assembly = Assembly.LoadFrom(dlrns);
                                appReferences.Add(MetadataReference.CreateFromFile(assembly.Location));
                            }
                        }
                    }

                    CSharpCompilation compilation = CSharpCompilation.Create(Path.GetFileName(mod.dll), syntaxTree, references: appReferences, options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

                    using (var ms = new MemoryStream())
                    {
                        var result = compilation.Emit(ms);

                        if (result.Success)
                        {
                            ms.Seek(0, SeekOrigin.Begin);
                            return Assembly.Load(ms.ToArray());
                        }
                        else
                        {
                            Console.WriteLine($"\ncompilation error: {mod.dll}");
                            foreach (var diagnostic in result.Diagnostics)
                            {
                                if (diagnostic.Severity == DiagnosticSeverity.Error)
                                    Console.WriteLine(diagnostic);
                            }
                            Console.WriteLine("\n");
                        }
                    }
                }
            }

            return null;
        }
        #endregion
    }
}

```

## File: Shared/Engine/StringConvert.cs
```
Ôªøusing System.Text.RegularExpressions;

namespace Shared.Engine
{
    public static class StringConvert
    {
        #region FindStartText
        public static string FindStartText(in string data, string end, string start = null)
        {
            try
            {
                int endtIndex = data.IndexOf(end);
                if (endtIndex == -1)
                    return null;

                return data.AsSpan(0, endtIndex).ToString();
            }
            catch
            {
                return null;
            }
        }
        #endregion

        #region FindLastText
        public static string FindLastText(in string data, string start, string end = null)
        {
            try
            {
                int startIndex = data.IndexOf(start);
                if (startIndex == -1)
                    return null;

                var resSpan = data.AsSpan(startIndex);
                string res = resSpan.ToString();

                if (end == null)
                    return res;

                return FindStartText(res, end);
            }
            catch 
            {
                return null;
            }
        }
        #endregion

        #region Remove
        public static string Remove(string data, string start, string end)
        {
            try
            {
                for (int i = 0; i < 10; i++)
                {
                    int startIndex = data.IndexOf(start);
                    if (startIndex == 0)
                        break;


                    int endIndex = data.IndexOf(end);
                    if (endIndex == 0) {
                        data = data.Remove(startIndex);
                        break;
                    }
                    
                    data = data.Remove(startIndex, (endIndex - startIndex));
                }

                return data;
            }
            catch
            {
                return data;
            }
        }
        #endregion


        #region SearchName
        public static string SearchName(string val, string empty = null)
        {
            if (string.IsNullOrWhiteSpace(val))
                return empty;

            string result = Regex.Replace(val.ToLower(), "[^a-zA-Z–∞-—è–ê-–Ø0-9–Å—ë]+", "").Replace("—ë", "–µ").Replace("—â", "—à");
            if (string.IsNullOrWhiteSpace(result))
                return empty;

            return result;
        }
        #endregion
    }
}

```

## File: Shared/Engine/BrotliTo.cs
```
Ôªøusing System.IO.Compression;
using System.Text;

namespace Shared.Engine
{
    public static class BrotliTo
    {
        static readonly object lockObj = new object();


        public static byte[] Compress(string value)
        {
            return Compress(Encoding.UTF8.GetBytes(value));
        }

        public static byte[] Compress(in byte[] value)
        {
            try
            {
                using (var input = new MemoryStream(value))
                {
                    using (var output = new MemoryStream())
                    {
                        try
                        {
                            using (var stream = new BrotliStream(output, CompressionLevel.Fastest))
                                input.CopyTo(stream);

                            return output.ToArray();
                        }
                        catch { return null; }
                    }
                }
            }
            catch { return null; }
        }

        public static void Compress(string outfile, in string value)
        {
            try
            {
                Compress(outfile, Encoding.UTF8.GetBytes(value));
            }
            catch { }
        }

        public static void Compress(string outfile, in byte[] value)
        {
            try
            {
                lock (lockObj)
                {
                    using (var input = new MemoryStream(value))
                    {
                        using (var output = new FileStream(outfile, FileMode.Create, FileAccess.Write, FileShare.None))
                        {
                            try
                            {
                                using (var stream = new BrotliStream(output, CompressionLevel.Fastest))
                                    input.CopyTo(stream);
                            }
                            catch { }
                        }
                    }
                }
            }
            catch { }
        }


        public static string Decompress(byte[] value)
        {
            try
            {
                using (var input = new MemoryStream(value))
                {
                    using (var output = new MemoryStream())
                    {
                        try
                        {
                            using (var stream = new BrotliStream(input, CompressionMode.Decompress))
                                stream.CopyTo(output);

                            return Encoding.UTF8.GetString(output.ToArray());
                        }
                        catch { return null; }
                    }
                }
            }
            catch { return null; }
        }

        public static string Decompress(string infile)
        {
            try
            {
                byte[] array = DecompressArray(infile);
                if (array == null)
                    return null;

                return Encoding.UTF8.GetString(array);
            }
            catch { return null; }
        }

        public static byte[] DecompressArray(string infile)
        {
            try
            {
                using (var input = new FileStream(infile, FileMode.Open, FileAccess.Read))
                {
                    using (var output = new MemoryStream())
                    {
                        try
                        {
                            using (var stream = new BrotliStream(input, CompressionMode.Decompress))
                                stream.CopyTo(output);

                            return output.ToArray();
                        }
                        catch { return null; }
                    }
                }
            }
            catch { return null; }
        }
    }
}

```

## File: Shared/Engine/HtmlCommon.cs
```
Ôªøusing HtmlAgilityPack;
using System.Text.RegularExpressions;

namespace Shared.Engine
{
    public class HtmlCommon
    {
        HtmlNode row;

        public HtmlCommon(HtmlNode row)
        {
            this.row = row;
        }


        public string NodeValue(in string node, string attribute = null, string removeChild = null)
        {
            if (string.IsNullOrEmpty(node) && !string.IsNullOrEmpty(attribute))
            {
                return row.GetAttributeValue(attribute, null);
            }
            else
            {
                var inNode = row.SelectSingleNode(node);
                if (inNode != null)
                {
                    if (removeChild != null)
                        inNode.RemoveChild(inNode.SelectSingleNode(removeChild));

                    return (!string.IsNullOrEmpty(attribute) ? inNode.GetAttributeValue(attribute, null) : inNode.InnerText)?.Trim();
                }
            }

            return null;
        }


        public string Match(string pattern, int index = 1)
        {
            return new Regex(pattern, RegexOptions.IgnoreCase).Match(row.InnerHtml).Groups[index].Value.Trim();
        }


        public static int Integer(string value)
        {
            if (string.IsNullOrEmpty(value))
                return 0;

            if (int.TryParse(Regex.Replace(value, "[^0-9]+", ""), out int result))
                return result;

            return 0;
        }
    }
}

```

## File: Shared/Engine/GeoIP2.cs
```
Ôªøusing MaxMind.GeoIP2;

namespace Shared.Engine
{
    public class GeoIP2
    {
        static DatabaseReader cityReader = null;

        static GeoIP2()
        {
            if (File.Exists("data/GeoLite2-Country.mmdb"))
                cityReader = new DatabaseReader("data/GeoLite2-Country.mmdb");
        }

        /// <param name="IP">IP –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</param>
        /// <returns>–°—Ç—Ä–∞–Ω–∞ UA,RU,BY,KZ</returns>
        public static string Country(string IP)
        {
            if (string.IsNullOrEmpty(IP) || cityReader == null)
                return null;

            try
            {
                return cityReader.Country(IP).Country.IsoCode.ToUpper();
            }
            catch { return null; }
        }
    }
}

```

## File: Shared/Engine/FFprobe.cs
```
Ôªøusing System.Diagnostics;

namespace Shared.Engine
{
    public static class FFprobe
    {
        #region InitializationAsync
        public static Task<bool> InitializationAsync()
        {
            return FFmpeg.InitializationAsync();
        }
        #endregion

        #region RunAsync
        async public static ValueTask<(string outputData, string errorData)> RunAsync(string comand, string workingDirectory = null)
        {
            try
            {
                var process = new Process();
                process.StartInfo.UseShellExecute = false;
                process.StartInfo.RedirectStandardOutput = true;
                process.StartInfo.RedirectStandardError = true;
                process.StartInfo.FileName = AppInit.Win32NT ? "data/ffprobe.exe" : File.Exists("data/ffprobe") ? "data/ffprobe" : "ffprobe";
                process.StartInfo.Arguments = comand;
                process.StartInfo.WorkingDirectory = workingDirectory;
                process.Start();

                string outputData = string.Empty, errorData = string.Empty;

                process.OutputDataReceived += (sender, args) =>
                {
                    if (!string.IsNullOrEmpty(args.Data))
                        outputData += args.Data;
                };

                process.ErrorDataReceived += (sender, args) =>
                {
                    if (!string.IsNullOrEmpty(args.Data))
                        errorData += args.Data;
                };

                process.BeginOutputReadLine();
                process.BeginErrorReadLine();

                await process.WaitForExitAsync();

                return (outputData, errorData);
            }
            catch
            {
                return default;
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/TimeZoneTo.cs
```
Ôªønamespace Shared.Engine
{
    public static class TimeZoneTo
    {
        public static bool ByIds(string[] zones, out DateTime zoneTime)
        {
            zoneTime = DateTime.MinValue;

            foreach (var zone in zones)
            {
                if (ById(zone, out zoneTime))
                    return true;
            }

            return false;
        }

        public static bool ById(string zone, out DateTime zoneTime)
        {
            zoneTime = DateTime.MinValue;

            try
            {
                TimeZoneInfo tz = TimeZoneInfo.FindSystemTimeZoneById("Europe/Kiev");
                zoneTime = TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, tz);

                return true;
            }
            catch 
            {
                return false;
            }
        }
    }
}

```

## File: Shared/Engine/HybridCache.cs
```
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.SQL;
using System.Collections.Concurrent;
using System.Threading;

namespace Shared.Engine
{
    public struct HybridCache
    {
        #region HybridCache
        static IMemoryCache memoryCache;

        static Timer _clearTimer;

        static DateTime _nextClearDb = DateTime.Now.AddMinutes(20);

        static ConcurrentDictionary<string, (DateTime extend, HybridCacheSqlModel cache)> tempDb;

        public static void Configure(IMemoryCache mem)
        {
            memoryCache = mem;

            tempDb = new ConcurrentDictionary<string, (DateTime extend, HybridCacheSqlModel value)>();
            _clearTimer = new Timer(UpdateDB, null, TimeSpan.Zero, TimeSpan.FromSeconds(5));
        }

        static bool updatingDb = false;
        async static void UpdateDB(object state)
        {
            if (updatingDb || tempDb.Count == 0)
                return;

            try
            {
                updatingDb = true;

                using (var sqlDb = new HybridCacheContext())
                {
                    if (DateTime.Now > _nextClearDb)
                    {
                        _nextClearDb = DateTime.Now.AddMinutes(20);

                        var now = DateTime.Now;

                        await sqlDb.files
                            .Where(i => now > i.ex)
                            .ExecuteDeleteAsync();
                    }
                    else
                    {
                        var array = tempDb.ToArray().Where(t => t.Value.extend >= DateTime.Now);
                        if (array.Any())
                        {
                            var delete_ids = array.Select(k => k.Key).ToHashSet();
                            if (delete_ids.Count > 0)
                            {
                                await sqlDb.files
                                    .Where(x => delete_ids.Contains(x.Id))
                                    .ExecuteDeleteAsync();
                            }

                            var hash_ids = new HashSet<string>();

                            foreach (var t in array)
                            {
                                if (hash_ids.Add(t.Key))
                                {
                                    sqlDb.files.Add(new HybridCacheSqlModel()
                                    {
                                        Id = t.Key,
                                        ex = t.Value.cache.ex,
                                        value = t.Value.cache.value
                                    });
                                }
                            }

                            await sqlDb.SaveChangesAsync();

                            foreach (var t in array)
                                tempDb.TryRemove(t.Key, out _);
                        }
                    }
                }
            }
            catch (Exception ex) 
            { 
                Console.WriteLine("HybridCache: " + ex); 
            }
            finally
            {
                updatingDb = false;
            }
        }
        #endregion


        #region TryGetValue
        public bool TryGetValue(string key, out object value)
        {
            return memoryCache.TryGetValue(key, out value);
        }

        public bool TryGetValue<TItem>(string key, out TItem value, bool? inmemory = null)
        {
            if (!AppInit.conf.mikrotik && AppInit.conf.cache.type != "mem")
            {
                if (memoryCache.TryGetValue(key, out value))
                    return true;

                if (ReadCache(key, out value, out bool setmemory))
                {
                    if (setmemory && inmemory != false && AppInit.conf.cache.type == "hybrid" && AppInit.conf.cache.extend > 0)
                        memoryCache.Set(key, value, DateTime.Now.AddSeconds(AppInit.conf.cache.extend));

                    return true;
                }

                return false;
            }

            return memoryCache.TryGetValue(key, out value);
        }
        #endregion

        #region ReadCache
        private bool ReadCache<TItem>(string key, out TItem value, out bool setmemory)
        {
            value = default;
            setmemory = true;

            if (AppInit.conf.cache.type == "mem")
                return false;

            var type = typeof(TItem);
            bool isText = type == typeof(string);

            bool IsDeserialize = type.GetConstructor(Type.EmptyTypes) != null 
                || type.IsValueType 
                || type.IsArray
                || type == typeof(JToken)
                || type == typeof(JObject)
                || type == typeof(JArray);

            if (!isText && !IsDeserialize)
                return false;

            try
            {
                bool deserializeCache(HybridCacheSqlModel doc, out TItem result)
                {
                    result = default;

                    if (doc?.Id == null || DateTime.Now > doc.ex)
                        return false;

                    var eventResult = InvkEvent.HybridCache("read", key, doc.value, doc.ex);

                    if (IsDeserialize)
                        result = JsonConvert.DeserializeObject<TItem>(eventResult.value ?? doc.value);
                    else
                        result = (TItem)Convert.ChangeType(eventResult.value ?? doc.value, type);

                    return true;
                }

                string md5key = CrypTo.md5(key);

                tempDb.TryGetValue(md5key, out var _temp);

                if (_temp.cache != null)
                {
                    setmemory = false;
                    return deserializeCache(_temp.cache, out value);
                }
                else
                {
                    using (var sqlDb = new HybridCacheContext())
                    {
                        var doc = sqlDb.files.Find(md5key);
                        return deserializeCache(doc, out value);
                    }
                }
            }
            catch { }

            return false;
        }
        #endregion


        #region Set
        public TItem Set<TItem>(string key, TItem value, DateTimeOffset absoluteExpiration, bool? inmemory = null)
        {
            if (inmemory != true && !AppInit.conf.mikrotik && WriteCache(key, value, absoluteExpiration, default))
                return value;

            if (inmemory != true && !AppInit.conf.mikrotik)
                Console.WriteLine($"set memory: {key} / {DateTime.Now}");

            return memoryCache.Set(key, value, absoluteExpiration);
        }

        public TItem Set<TItem>(string key, TItem value, TimeSpan absoluteExpirationRelativeToNow, bool? inmemory = null)
        {
            if (inmemory != true && !AppInit.conf.mikrotik && WriteCache(key, value, default, absoluteExpirationRelativeToNow))
                return value;

            if (inmemory != true && !AppInit.conf.mikrotik)
                Console.WriteLine($"set memory: {key} / {DateTime.Now}");

            return memoryCache.Set(key, value, absoluteExpirationRelativeToNow);
        }
        #endregion

        #region WriteCache
        private bool WriteCache<TItem>(string key, TItem value, DateTimeOffset absoluteExpiration, TimeSpan absoluteExpirationRelativeToNow)
        {
            if (AppInit.conf.cache.type == "mem")
                return false;

            var type = typeof(TItem);
            bool isText = type == typeof(string);

            bool IsSerialize = type.GetConstructor(Type.EmptyTypes) != null
                || type.IsValueType
                || type.IsArray
                || type == typeof(JToken)
                || type == typeof(JObject)
                || type == typeof(JArray);

            if (!isText && !IsSerialize)
                return false;

            try
            {
                string result;

                if (IsSerialize)
                {
                    result = JsonConvert.SerializeObject(value);
                }
                else
                {
                    result = value.ToString();
                }

                if (absoluteExpiration == default)
                    absoluteExpiration = DateTimeOffset.Now.Add(absoluteExpirationRelativeToNow);

                var eventResult = InvkEvent.HybridCache("write", key, result, absoluteExpiration);
                if (eventResult != default)
                {
                    result = eventResult.value;
                    absoluteExpiration = eventResult.ex;
                }

                var extend = DateTime.Now.AddSeconds(Math.Max(5, AppInit.conf.cache.extend));

                tempDb.TryAdd(CrypTo.md5(key), (extend, new HybridCacheSqlModel()
                {
                    Id = CrypTo.md5(key),
                    ex = absoluteExpiration.DateTime,
                    value = result
                }));

                return true;
            }
            catch { }

            return false;
        }
        #endregion
    }
}

```

## File: Shared/Engine/JsonHelper.cs
```
using Newtonsoft.Json;
using System.Collections;
using System.IO.Compression;

namespace Shared.Engine
{
    public static class JsonHelper
    {
        #region ListReader
        public static List<T> ListReader<T>(string filePath, int capacity = 0)
        {
            var items = new List<T>(capacity);

            using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read))
            {
                using (var gzipStream = new GZipStream(fileStream, CompressionMode.Decompress))
                {
                    using (var reader = new StreamReader(gzipStream))
                    {
                        using (var jsonReader = new JsonTextReader(reader))
                        {
                            var serializer = new JsonSerializer();
                            while (jsonReader.Read())
                            {
                                if (jsonReader.TokenType == JsonToken.StartObject)
                                {
                                    try
                                    {
                                        items.Add(serializer.Deserialize<T>(jsonReader));
                                    }
                                    catch { }
                                }
                            }
                        }
                    }
                }
            }

            return items;
        }
        #endregion

        #region IEnumerableReader
        public static IEnumerable<T> IEnumerableReader<T>(string filePath)
        {
            if (!File.Exists(filePath))
                return Enumerable.Empty<T>();

            return new JsonItemEnumerable<T>(filePath);
        }
        #endregion


        #region [Codex AI] JsonItemEnumerable<T>
        private class JsonItemEnumerable<T> : IEnumerable<T>
        {
            readonly string filePath;

            public JsonItemEnumerable(string filePath)
            {
                this.filePath = filePath;
            }

            public IEnumerator<T> GetEnumerator() => new JsonItemEnumerator(filePath);

            IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

            private class JsonItemEnumerator : IEnumerator<T>
            {
                readonly string filePath;
                readonly JsonSerializer serializer = new JsonSerializer();

                FileStream fileStream;
                GZipStream gzipStream;
                StreamReader reader;
                JsonTextReader jsonReader;

                public JsonItemEnumerator(string filePath)
                {
                    this.filePath = filePath;
                    Initialize();
                }

                public T Current { get; private set; }

                object IEnumerator.Current => Current;

                void Initialize()
                {
                    try
                    {
                        fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read);
                        gzipStream = new GZipStream(fileStream, CompressionMode.Decompress);
                        reader = new StreamReader(gzipStream);
                        jsonReader = new JsonTextReader(reader);
                    }
                    catch
                    {
                        Dispose();
                    }
                }

                public bool MoveNext()
                {
                    if (jsonReader == null)
                        return false;

                    while (jsonReader.Read())
                    {
                        if (jsonReader.TokenType == JsonToken.StartObject)
                        {
                            try
                            {
                                Current = serializer.Deserialize<T>(jsonReader);
                                return true;
                            }
                            catch { }
                        }
                    }

                    Current = default;
                    return false;
                }

                public void Reset() => throw new NotSupportedException();

                public void Dispose()
                {
                    jsonReader?.Close();
                    reader?.Dispose();
                    gzipStream?.Dispose();
                    fileStream?.Dispose();
                }
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/ModuleInvoke.cs
```
Ôªøusing Newtonsoft.Json.Linq;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Shared.Engine
{
    /// <summary>
    /// [Copilot AI]
    /// </summary>
    public static class ModuleInvoke
    {
        public static T Init<T>(string filed, T val)
        {
            if (val == null)
                return val;

            // Use existing ConfObject logic to get merged JObject/token
            var confObj = Conf(filed, val);
            if (confObj == null)
                return val;

            // If caller expects a JObject, return directly
            if (typeof(T) == typeof(JObject))
                return (T)(object)confObj;

            // If we have a wrapper for non-object values { "value": ... }, extract it
            if (confObj.Count == 1 && confObj.ContainsKey("value"))
            {
                try
                {
                    var token = confObj["value"];
                    return token.ToObject<T>();
                }
                catch
                {
                    return val;
                }
            }

            // Otherwise try to convert the merged object back to T
            try
            {
                return confObj.ToObject<T>();
            }
            catch
            {
                return val;
            }
        }

        public static JObject Conf(string filed, object val)
        {
            if (val == null)
                return null;

            // Convert incoming value to JToken/JObject
            JToken baseToken = val as JToken ?? JToken.FromObject(val);
            if (baseToken == null)
                return null;

            if (baseToken.Type != JTokenType.Object)
            {
                // For non-object values wrap into a simple object so merging still possible
                return new JObject { ["value"] = baseToken };
            }

            var baseObj = (JObject)baseToken;

            try
            {
                if (!File.Exists("init.conf") && !File.Exists("init.yaml"))
                    return baseObj;

                JObject jo = null;
                // First try init.conf if exists
                if (File.Exists("init.conf"))
                {
                    string initfile = File.ReadAllText("init.conf").Trim();
                    if (!string.IsNullOrEmpty(initfile))
                    {
                        if (!initfile.StartsWith("{"))
                            initfile = "{" + initfile + "}";

                        try
                        {
                            jo = JObject.Parse(initfile);
                        }
                        catch
                        {
                            try 
                            { 
                                jo = JObject.FromObject(Newtonsoft.Json.JsonConvert.DeserializeObject(initfile) ?? new JObject()); 
                            } 
                            catch { jo = null; }
                        }
                    }
                }

                // Then try init.yaml and merge/override into jo if present
                if (File.Exists("init.yaml"))
                {
                    try
                    {
                        var yaml = File.ReadAllText("init.yaml").Trim();
                        if (!string.IsNullOrEmpty(yaml))
                        {
                            var deserializer = new DeserializerBuilder()
                                .WithNamingConvention(CamelCaseNamingConvention.Instance)
                                .IgnoreUnmatchedProperties()
                                .Build();

                            var deserialized = deserializer.Deserialize<object>(yaml) ?? new object();

                            // Convert deserialized YAML to JSON and then to JObject
                            var json = Newtonsoft.Json.JsonConvert.SerializeObject(deserialized);

                            JObject yamlJo = null;
                            try
                            {
                                yamlJo = JObject.Parse(json);
                            }
                            catch
                            {
                                try 
                                { 
                                    yamlJo = JObject.FromObject(Newtonsoft.Json.JsonConvert.DeserializeObject(json) ?? new JObject()); 
                                } 
                                catch { yamlJo = null; }
                            }

                            if (yamlJo != null)
                            {
                                if (jo == null)
                                    jo = yamlJo;
                                else
                                    Merge(jo, yamlJo);
                            }
                        }
                    }
                    catch
                    {
                        // ignore yaml parse errors
                    }
                }

                if (jo == null || !jo.ContainsKey(filed))
                    return baseObj;

                var node = jo[filed];

                // If field explicitly false -> return original val
                if (node.Type == JTokenType.Boolean && node.Value<bool>() == false)
                    return baseObj;

                // If node is not an object, nothing to merge -> return original
                if (node.Type != JTokenType.Object)
                    return baseObj;

                var overrideObj = (JObject)node;

                // Deep clone base
                var result = (JObject)baseObj.DeepClone();

                Merge(result, overrideObj);

                return result;
            }
            catch
            {
                return baseObj;
            }
        }

        static void Merge(JObject target, JObject source)
        {
            foreach (var prop in source.Properties())
            {
                var tprop = target.Property(prop.Name);

                if (tprop != null && tprop.Value.Type == JTokenType.Object && prop.Value.Type == JTokenType.Object)
                {
                    Merge((JObject)tprop.Value, (JObject)prop.Value);
                }
                else
                {
                    // Replace or add
                    target[prop.Name] = prop.Value.DeepClone();
                }
            }
        }
    }
}

```

## File: Shared/Engine/CrypTo.cs
```
Ôªøusing System.Security.Cryptography;
using System.Text;

namespace Shared.Engine
{
    public class CrypTo
    {
        public static string md5(string text)
        {
            if (text == null)
                return string.Empty;

            using (var md5 = MD5.Create())
            {
                var result = md5.ComputeHash(Encoding.UTF8.GetBytes(text));
                return BitConverter.ToString(result).Replace("-", "").ToLower();
            }
        }

        public static byte[] md5binary(string text)
        {
            if (text == null)
                return null;

            using (var md5 = MD5.Create())
            {
                var result = md5.ComputeHash(Encoding.UTF8.GetBytes(text));
                return result;
            }
        }

        public static string DecodeBase64(string base64Text)
        {
            if (string.IsNullOrEmpty(base64Text))
                return string.Empty;

            try
            {
                return Encoding.UTF8.GetString(Convert.FromBase64String(base64Text));
            }
            catch { }

            return string.Empty;
        }

        public static string Base64(string text)
        {
            if (text == null)
                return string.Empty;

            return Convert.ToBase64String(Encoding.UTF8.GetBytes(text));
        }

        public static string Base64(byte[] text)
        {
            if (text == null)
                return string.Empty;

            return Convert.ToBase64String(text);
        }

        public static string SHA256(string text)
        {
            using (SHA256 sha256 = System.Security.Cryptography.SHA256.Create())
            {
                // Compute the hash of the given string
                byte[] hashValue = sha256.ComputeHash(Encoding.UTF8.GetBytes(text));

                // Convert the byte array to string format
                return BitConverter.ToString(hashValue).Replace("-", "").ToLower();
            }
        }

        public static string SHA(string text)
        {
            using (SHA1 sha = SHA1.Create())
            {
                // Compute the hash of the given string
                byte[] hashValue = sha.ComputeHash(Encoding.UTF8.GetBytes(text));

                // Convert the byte array to string format
                return BitConverter.ToString(hashValue).Replace("-", "").ToLower();
            }
        }

        public static string AES256(string text, string secret_pw, string secret_iv)
        {
            using (Aes encryptor = Aes.Create())
            {
                encryptor.Mode = CipherMode.CBC;
                encryptor.KeySize = 256;
                encryptor.BlockSize = 128;
                encryptor.Padding = PaddingMode.PKCS7;

                // Set key and IV
                encryptor.Key = Encoding.UTF8.GetBytes(SHA256(secret_pw).Substring(0, 32));
                encryptor.IV = Encoding.UTF8.GetBytes(SHA256(secret_iv).Substring(0, 16));

                // Instantiate a new MemoryStream object to contain the encrypted bytes
                MemoryStream memoryStream = new MemoryStream();

                // Instantiate a new encryptor from our Aes object
                ICryptoTransform aesEncryptor = encryptor.CreateEncryptor();

                // Instantiate a new CryptoStream object to process the data and write it to the 
                // memory stream
                CryptoStream cryptoStream = new CryptoStream(memoryStream, aesEncryptor, CryptoStreamMode.Write);

                // Convert the plainText string into a byte array
                byte[] plainBytes = Encoding.UTF8.GetBytes(text);

                // Encrypt the input plaintext string
                cryptoStream.Write(plainBytes, 0, plainBytes.Length);

                // Complete the encryption process
                cryptoStream.FlushFinalBlock();

                // Convert the encrypted data from a MemoryStream to a byte array
                byte[] cipherBytes = memoryStream.ToArray();

                // Close both the MemoryStream and the CryptoStream
                memoryStream.Close();
                cryptoStream.Close();

                // Convert the encrypted byte array to a base64 encoded string
                return Convert.ToBase64String(cipherBytes, 0, cipherBytes.Length);
            }
        }

        #region unic
        static string ArrayList => "qwertyuioplkjhgfdsazxcvbnmQWERTYUIOPLKJHGFDSAZXCVBNM1234567890";
        static string ArrayListToNumber => "1234567890";
        public static string unic(int size = 8, bool IsNumberCode = false, string addArrayList = null)
        {
            StringBuilder array = new StringBuilder(size);
            string list = IsNumberCode ? ArrayListToNumber : ArrayList + addArrayList;

            for (int i = 0; i < size; i++)
                array.Append(list[Random.Shared.Next(0, list.Length)]);

            return array.ToString();
        }
        #endregion
    }
}

```

## File: Shared/Engine/ResponseCache.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using System.Text.RegularExpressions;

namespace Shared.Engine
{
    public static class ResponseCache
    {
        public static string ErrorKey(HttpContext httpContext)
        {
            string key = httpContext.Request.Path.Value + httpContext.Request.QueryString.Value;
            return "ResponseCache:errorMsg:" + Regex.Replace(key, "(\\?|&)(account_email|cub_id|box_mac|uid|token|source|rchtype)=[^&]+", "");
        }
    }
}

```

## File: Shared/Engine/FileCache.cs
```
Ôªøusing System.Text.RegularExpressions;

namespace Shared.Engine
{
    public static class FileCache
    {
        private static readonly object _lock = new object();

        static Dictionary<string, (DateTime lockTime, string value)> db = new();

        public static string ReadAllText(string path)
        {
            return ReadAllText(path, true);
        }

        public static string ReadAllText(string path, bool saveCache)
        {
            var secondCache = DateTime.Now.AddSeconds(AppInit.conf.multiaccess ? 5 : 1);

            try
            {
                lock (_lock)
                {
                    if (db.TryGetValue(path, out var cache))
                    {
                        if (cache.lockTime > DateTime.Now)
                            return cache.value;
                    }

                    string extension = Path.GetExtension(path);
                    string mypath = Regex.Replace(path, $"{extension}$", $".my{extension}");

                    if (!File.Exists(mypath))
                    {
                        if (!File.Exists(path))
                        {
                            db.TryAdd(path, (secondCache, string.Empty));
                            return string.Empty;
                        }

                        mypath = path;
                    }

                    cache = (secondCache, File.ReadAllText(mypath));

                    if (saveCache)
                        db.TryAdd(path, cache);

                    return cache.value;
                }
            }
            catch 
            {
                return string.Empty;
            }
        }
    }
}

```

## File: Shared/Engine/Http.cs
```
Ôªøusing Newtonsoft.Json;
using Shared.Models;
using Shared.Models.Events;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace Shared.Engine
{
    public static class Http
    {
        public static IHttpClientFactory httpClientFactory;

        #region defaultHeaders / UserAgent
        public static readonly Dictionary<string, string> defaultHeaders = new Dictionary<string, string>()
        {
            ["sec-ch-ua-mobile"] = "?0",
            ["sec-ch-ua-platform"] = "\"Windows\"",
            ["sec-ch-ua"] = "\"Chromium\";v=\"142\", \"Google Chrome\";v=\"142\", \"Not_A Brand\";v=\"99\"",
            ["user-agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36"
        };

        public static readonly Dictionary<string, string> defaultFullHeaders = new Dictionary<string, string>(defaultHeaders)
        {
            ["cache-control"] = "no-cache",
            ["dnt"] = "1",
            ["pragma"] = "no-cache",
            ["priority"] = "u=0, i"
        };

        public static string UserAgent => defaultHeaders["user-agent"];
        #endregion

        #region Handler
        public static HttpClientHandler Handler(string url, WebProxy proxy, CookieContainer cookieContainer = null)
        {
            string log = string.Empty;
            return Handler(url, proxy, ref log, cookieContainer);
        }

        static HttpClientHandler Handler(string url, WebProxy proxy, ref string loglines, CookieContainer cookieContainer = null)
        {
            var handler = new HttpClientHandler()
            {
                AllowAutoRedirect = true,
                AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate
            };

            handler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;

            if (proxy != null)
            {
                handler.UseProxy = true;
                handler.Proxy = proxy;
                loglines += $"proxy: {proxy.Address.ToString()}\n";
            }
            else
            {
                handler.UseProxy = false;
            }

            if (cookieContainer != null)
            {
                handler.CookieContainer = cookieContainer;
                handler.UseCookies = true; //<-- Enable the use of cookies.
            }

            if (AppInit.conf.globalproxy != null && AppInit.conf.globalproxy.Length > 0)
            {
                foreach (var p in AppInit.conf.globalproxy)
                {
                    if (p.list == null || p.list.Length == 0 || p.pattern == null)
                        continue;

                    if (Regex.IsMatch(url, p.pattern, RegexOptions.IgnoreCase))
                    {
                        string proxyip = p.list.OrderBy(a => Guid.NewGuid()).First();

                        NetworkCredential credentials = null;

                        if (proxyip.Contains("@"))
                        {
                            var g = Regex.Match(proxyip, p.pattern_auth).Groups;
                            proxyip = g["sheme"].Value + g["host"].Value;
                            credentials = new NetworkCredential(g["username"].Value, g["password"].Value);
                        }
                        else if (p.useAuth)
                            credentials = new NetworkCredential(p.username, p.password);

                        handler.UseProxy = true;
                        handler.Proxy = new WebProxy(proxyip, p.BypassOnLocal, null, credentials);
                        loglines += $"globalproxy: {proxyip} {(p.useAuth ? $" - {p.username}:{p.password}" : "")}\n";
                        break;
                    }
                }
            }

            InvkEvent.Http(new EventHttpHandler(url, handler, proxy, cookieContainer, Startup.memoryCache));

            return handler;
        }
        #endregion

        #region DefaultRequestHeaders
        public static void DefaultRequestHeaders(string url, HttpRequestMessage client, string cookie, string referer, List<HeadersModel> headers, bool useDefaultHeaders = true)
        {
            string loglines = string.Empty;
            DefaultRequestHeaders(url, client, cookie, referer, headers, ref loglines, useDefaultHeaders);
        }

        public static void DefaultRequestHeaders(string url, HttpRequestMessage client, string cookie, string referer, List<HeadersModel> headers, ref string loglines, bool useDefaultHeaders = true)
        {
            if (useDefaultHeaders)
            {
                client.Headers.TryAddWithoutValidation("Accept-Language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5");
                loglines += $"Accept-Language: {client.Headers.AcceptLanguage}\n";
            }

            if (cookie != null)
            {
                client.Headers.TryAddWithoutValidation("cookie", cookie);
                loglines += $"cookie: {cookie}\n";
            }

            if (referer != null)
            {
                client.Headers.TryAddWithoutValidation("referer", referer);
                loglines += $"referer: {referer}\n";
            }

            bool setDefaultUseragent = true;

            if (headers != null)
            {
                foreach (var item in headers)
                {
                    if (item.name.ToLower() == "user-agent")
                        setDefaultUseragent = false;

                    if (!client.Headers.Contains(item.name))
                    {
                        client.Headers.TryAddWithoutValidation(item.name, item.val);
                        loglines += $"{item.name}: {item.val}\n";
                    }
                }
            }

            if (useDefaultHeaders && setDefaultUseragent)
            {
                client.Headers.TryAddWithoutValidation("User-Agent", UserAgent);
                loglines += $"User-Agent: {client.Headers.UserAgent}\n";
            }

            InvkEvent.Http(new EventHttpHeaders(url, client, cookie, referer, headers, useDefaultHeaders, Startup.memoryCache));
        }
        #endregion


        #region GetLocation
        async public static Task<string> GetLocation(string url, string referer = null, int timeoutSeconds = 8, List<HeadersModel> headers = null, int httpversion = 1, bool allowAutoRedirect = false, WebProxy proxy = null)
        {
            try
            {
                var handler = Handler(url, proxy);
                handler.AllowAutoRedirect = allowAutoRedirect;

                var client = FrendlyHttp.HttpMessageClient(httpversion == 2 ? "http2" : "base", handler);

                var req = new HttpRequestMessage(HttpMethod.Get, url)
                {
                    Version = httpversion == 1 ? HttpVersion.Version11 : new Version(httpversion, 0)
                };

                DefaultRequestHeaders(url, req, null, referer, headers);

                using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(Math.Max(5, timeoutSeconds))))
                {
                    using (HttpResponseMessage response = await client.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, cts.Token).ConfigureAwait(false))
                    {
                        string location = (int)response.StatusCode == 301 || (int)response.StatusCode == 302 || (int)response.StatusCode == 307 ? response.Headers.Location?.ToString() : response.RequestMessage.RequestUri?.ToString();
                        location = Uri.EscapeUriString(System.Web.HttpUtility.UrlDecode(location ?? ""));

                        return string.IsNullOrWhiteSpace(location) ? null : location;
                    }
                }
            }
            catch
            {
                return null;
            }
        }
        #endregion

        #region ResponseHeaders
        async public static Task<HttpResponseMessage> ResponseHeaders(string url, int timeoutSeconds = 8, List<HeadersModel> headers = null, int httpversion = 1, bool allowAutoRedirect = false, WebProxy proxy = null)
        {
            try
            {
                var handler = Handler(url, proxy);
                handler.AllowAutoRedirect = allowAutoRedirect;

                var client = FrendlyHttp.HttpMessageClient(httpversion == 2 ? "http2" : "base", handler);

                var req = new HttpRequestMessage(HttpMethod.Get, url)
                {
                    Version = httpversion == 1 ? HttpVersion.Version11 : new Version(httpversion, 0)
                };

                DefaultRequestHeaders(url, req, null, null, headers);

                using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(Math.Max(5, timeoutSeconds))))
                    using (HttpResponseMessage response = await client.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, cts.Token).ConfigureAwait(false))
                        return response;
            }
            catch
            {
                return null;
            }
        }
        #endregion


        #region Get
        async public static ValueTask<string> Get(string url, Encoding encoding = default, string cookie = null, string referer = null, int timeoutSeconds = 15, List<HeadersModel> headers = null, long MaxResponseContentBufferSize = 0, WebProxy proxy = null, int httpversion = 1, bool statusCodeOK = true, bool weblog = true, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, HttpContent body = null)
        {
            return (await BaseGetAsync(url, encoding, cookie: cookie, referer: referer, timeoutSeconds: timeoutSeconds, headers: headers, MaxResponseContentBufferSize: MaxResponseContentBufferSize, proxy: proxy, httpversion: httpversion, statusCodeOK: statusCodeOK, weblog: weblog, cookieContainer: cookieContainer, useDefaultHeaders: useDefaultHeaders, body: body).ConfigureAwait(false)).content;
        }
        #endregion

        #region Get<T>
        async public static ValueTask<T> Get<T>(string url, Encoding encoding = default, string cookie = null, string referer = null, long MaxResponseContentBufferSize = 0, int timeoutSeconds = 15, List<HeadersModel> headers = null, bool IgnoreDeserializeObject = false, WebProxy proxy = null, bool statusCodeOK = true, int httpversion = 1, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, bool weblog = true, HttpContent body = null)
        {
            try
            {
                string html = (await BaseGetAsync(url, encoding, cookie: cookie, referer: referer, MaxResponseContentBufferSize: MaxResponseContentBufferSize, timeoutSeconds: timeoutSeconds, headers: headers, proxy: proxy, httpversion: httpversion, statusCodeOK: statusCodeOK, cookieContainer: cookieContainer, useDefaultHeaders: useDefaultHeaders, weblog: weblog, body: body).ConfigureAwait(false)).content;
                if (html == null)
                    return default;

                if (IgnoreDeserializeObject)
                    return JsonConvert.DeserializeObject<T>(html, new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } });

                return JsonConvert.DeserializeObject<T>(html);
            }
            catch
            {
                return default;
            }
        }
        #endregion


        #region BaseGetAsync<T>
        async public static Task<(T content, HttpResponseMessage response)> BaseGetAsync<T>(string url, Encoding encoding = default, string cookie = null, string referer = null, long MaxResponseContentBufferSize = 0, int timeoutSeconds = 15, List<HeadersModel> headers = null, bool IgnoreDeserializeObject = false, WebProxy proxy = null, bool statusCodeOK = true, int httpversion = 1, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, HttpContent body = null)
        {
            try
            {
                var result = await BaseGetAsync(url, encoding, cookie: cookie, referer: referer, MaxResponseContentBufferSize: MaxResponseContentBufferSize, timeoutSeconds: timeoutSeconds, headers: headers, proxy: proxy, httpversion: httpversion, statusCodeOK: statusCodeOK, cookieContainer: cookieContainer, useDefaultHeaders: useDefaultHeaders, body: body).ConfigureAwait(false);
                if (result.content == null)
                    return default;

                JsonSerializerSettings settings = null;

                if (IgnoreDeserializeObject)
                    settings = new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } };

                return (JsonConvert.DeserializeObject<T>(result.content, settings), result.response);
            }
            catch
            {
                return default;
            }
        }
        #endregion

        #region BaseGetAsync
        async public static Task<(string content, HttpResponseMessage response)> BaseGetAsync(string url, Encoding encoding = default, string cookie = null, string referer = null, int timeoutSeconds = 15, long MaxResponseContentBufferSize = 0, List<HeadersModel> headers = null, WebProxy proxy = null, int httpversion = 1, bool statusCodeOK = true, bool weblog = true, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, HttpContent body = null)
        {
            string loglines = string.Empty;

            try
            {
                var handler = Handler(url, proxy, ref loglines, cookieContainer);

                var client = FrendlyHttp.HttpMessageClient(httpversion == 1 ? "base" : $"http{httpversion}", handler, MaxResponseContentBufferSize);

                if (cookieContainer != null)
                {
                    var cookiesString = new StringBuilder();
                    foreach (Cookie c in cookieContainer.GetCookies(new Uri(url)))
                        cookiesString.Append($"{c.Name}={c.Value}; ");

                    if (!string.IsNullOrEmpty(cookiesString.ToString()))
                        loglines += $"Cookie: {cookiesString.ToString().TrimEnd(' ', ';')}\n";
                }

                var req = new HttpRequestMessage(HttpMethod.Get, url)
                {
                    Version = httpversion == 1 ? HttpVersion.Version11 : new Version(httpversion, 0),
                    Content = body
                };

                DefaultRequestHeaders(url, req, cookie, referer, headers, ref loglines, useDefaultHeaders);

                using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(Math.Max(5, timeoutSeconds))))
                {
                    using (HttpResponseMessage response = await client.SendAsync(req, cts.Token).ConfigureAwait(false))
                    {
                        loglines += $"\n\nStatusCode: {(int)response.StatusCode}\n";
                        foreach (var h in response.Headers)
                        {
                            if (h.Key == "Set-Cookie")
                            {
                                foreach (string v in h.Value)
                                    loglines += $"{h.Key}: {v}\n";
                            }
                            else
                                loglines += $"{h.Key}: {string.Join("", h.Value)}\n";
                        }

                        using (HttpContent content = response.Content)
                        {
                            if (encoding != default)
                            {
                                string res = encoding.GetString(await content.ReadAsByteArrayAsync().ConfigureAwait(false));
                                var model = new EventHttpResponse(url, null, client, res, response, Startup.memoryCache);

                                if (string.IsNullOrWhiteSpace(res))
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                loglines += "\n" + res;
                                if (statusCodeOK && response.StatusCode != HttpStatusCode.OK)
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                await InvkEvent.HttpAsync(model);
                                return (res, response);
                            }
                            else
                            {
                                string res = await content.ReadAsStringAsync().ConfigureAwait(false);
                                var model = new EventHttpResponse(url, null, client, res, response, Startup.memoryCache);

                                if (string.IsNullOrWhiteSpace(res))
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                loglines += "\n" + res;
                                if (statusCodeOK && response.StatusCode != HttpStatusCode.OK)
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                await InvkEvent.HttpAsync(model);
                                return (res, response);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                loglines = ex.ToString();

                await InvkEvent.HttpAsync(new EventHttpResponse(url, null, null, ex.ToString(), new HttpResponseMessage()
                {
                    StatusCode = HttpStatusCode.InternalServerError,
                    RequestMessage = new HttpRequestMessage()
                }, Startup.memoryCache));

                return (null, new HttpResponseMessage()
                {
                    StatusCode = HttpStatusCode.InternalServerError,
                    RequestMessage = new HttpRequestMessage()
                });
            }
            finally
            {
                if (weblog)
                    WriteLog(url, "GET", body == null ? null : body.ReadAsStringAsync().Result, loglines);
            }
        }
        #endregion


        #region Post
        public static ValueTask<string> Post(string url, in string data, string cookie = null, int MaxResponseContentBufferSize = 0, int timeoutSeconds = 15, List<HeadersModel> headers = null, WebProxy proxy = null, int httpversion = 1, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, bool removeContentType = false)
        {
            return Post(url, new StringContent(data, Encoding.UTF8, "application/x-www-form-urlencoded"), cookie: cookie, MaxResponseContentBufferSize: MaxResponseContentBufferSize, timeoutSeconds: timeoutSeconds, headers: headers, proxy: proxy, httpversion: httpversion, cookieContainer: cookieContainer, useDefaultHeaders: useDefaultHeaders, removeContentType: removeContentType);
        }

        async public static ValueTask<string> Post(string url, HttpContent data, Encoding encoding = default, string cookie = null, int MaxResponseContentBufferSize = 0, int timeoutSeconds = 15, List<HeadersModel> headers = null, WebProxy proxy = null, int httpversion = 1, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, bool removeContentType = false, bool statusCodeOK = true)
        {
            return (await BasePost(url, data, encoding, cookie, MaxResponseContentBufferSize, timeoutSeconds, headers, proxy, httpversion, cookieContainer, useDefaultHeaders, removeContentType, statusCodeOK).ConfigureAwait(false)).content;
        }
        #endregion

        #region Post<T>
        public static Task<T> Post<T>(string url, in string data, string cookie = null, int timeoutSeconds = 15, List<HeadersModel> headers = null, Encoding encoding = default, WebProxy proxy = null, bool IgnoreDeserializeObject = false, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, int httpversion = 1)
        {
            return Post<T>(url, new StringContent(data, Encoding.UTF8, "application/x-www-form-urlencoded"), cookie: cookie, timeoutSeconds: timeoutSeconds, headers: headers, encoding: encoding, proxy: proxy, IgnoreDeserializeObject: IgnoreDeserializeObject, cookieContainer: cookieContainer, useDefaultHeaders: useDefaultHeaders, httpversion: httpversion);
        }

        async public static Task<T> Post<T>(string url, HttpContent data, string cookie = null, int timeoutSeconds = 15, List<HeadersModel> headers = null, Encoding encoding = default, WebProxy proxy = null, bool IgnoreDeserializeObject = false, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, int httpversion = 1)
        {
            try
            {
                string json = await Post(url, data, cookie: cookie, timeoutSeconds: timeoutSeconds, headers: headers, encoding: encoding, proxy: proxy, cookieContainer: cookieContainer, useDefaultHeaders: useDefaultHeaders, httpversion: httpversion).ConfigureAwait(false);
                if (json == null)
                    return default;

                if (IgnoreDeserializeObject)
                    return JsonConvert.DeserializeObject<T>(json, new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } });

                return JsonConvert.DeserializeObject<T>(json);
            }
            catch
            {
                return default;
            }
        }
        #endregion

        #region BasePost
        async public static Task<(string content, HttpResponseMessage response)> BasePost(string url, HttpContent data, Encoding encoding = default, string cookie = null, int MaxResponseContentBufferSize = 0, int timeoutSeconds = 15, List<HeadersModel> headers = null, WebProxy proxy = null, int httpversion = 1, CookieContainer cookieContainer = null, bool useDefaultHeaders = true, bool removeContentType = false, bool statusCodeOK = true)
        {
            string loglines = string.Empty;

            try
            {
                var handler = Handler(url, proxy, ref loglines, cookieContainer);

                var client = FrendlyHttp.HttpMessageClient(httpversion == 1 ? "base" : $"http{httpversion}", handler, MaxResponseContentBufferSize);

                if (cookieContainer != null)
                {
                    var cookiesString = new StringBuilder();
                    foreach (Cookie c in cookieContainer.GetCookies(new Uri(url)))
                        cookiesString.Append($"{c.Name}={c.Value}; ");

                    if (!string.IsNullOrEmpty(cookiesString.ToString()))
                        loglines += $"Cookie: {cookiesString.ToString().TrimEnd(' ', ';')}\n";
                }

                var req = new HttpRequestMessage(HttpMethod.Post, url)
                {
                    Version = httpversion == 1 ? HttpVersion.Version11 : new Version(httpversion, 0),
                    Content = data
                };

                DefaultRequestHeaders(url, req, cookie, null, headers, ref loglines, useDefaultHeaders);

                if (removeContentType)
                    req.Content.Headers.Remove("Content-Type");

                using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(Math.Max(5, timeoutSeconds))))
                {
                    using (HttpResponseMessage response = await client.SendAsync(req, cts.Token).ConfigureAwait(false))
                    {
                        loglines += $"\n\nStatusCode: {(int)response.StatusCode}\n";
                        foreach (var h in response.Headers)
                        {
                            if (h.Key == "Set-Cookie")
                            {
                                foreach (string v in h.Value)
                                    loglines += $"{h.Key}: {v}\n";
                            }
                            else
                                loglines += $"{h.Key}: {string.Join("", h.Value)}\n";
                        }

                        using (HttpContent content = response.Content)
                        {
                            if (encoding != default)
                            {
                                string res = encoding.GetString(await content.ReadAsByteArrayAsync().ConfigureAwait(false));
                                var model = new EventHttpResponse(url, data, client, res, response, Startup.memoryCache);

                                if (string.IsNullOrWhiteSpace(res))
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                loglines += "\n" + res;
                                if (statusCodeOK && response.StatusCode != HttpStatusCode.OK)
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                await InvkEvent.HttpAsync(model);
                                return (res, response);
                            }
                            else
                            {
                                string res = await content.ReadAsStringAsync().ConfigureAwait(false);
                                var model = new EventHttpResponse(url, data, client, res, response, Startup.memoryCache);

                                if (string.IsNullOrWhiteSpace(res))
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                loglines += "\n" + res;
                                if (statusCodeOK && response.StatusCode != HttpStatusCode.OK)
                                {
                                    await InvkEvent.HttpAsync(model);
                                    return (null, response);
                                }

                                await InvkEvent.HttpAsync(model);
                                return (res, response);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                loglines = ex.ToString();

                await InvkEvent.HttpAsync(new EventHttpResponse(url, data, null, ex.ToString(), new HttpResponseMessage()
                {
                    StatusCode = HttpStatusCode.InternalServerError,
                    RequestMessage = new HttpRequestMessage()
                }, Startup.memoryCache));

                return (null, new HttpResponseMessage()
                {
                    StatusCode = HttpStatusCode.InternalServerError,
                    RequestMessage = new HttpRequestMessage()
                });
            }
            finally
            {
                WriteLog(url, "POST", data.ReadAsStringAsync().Result, loglines);
            }
        }
        #endregion


        #region Download
        async public static Task<byte[]> Download(string url, string cookie = null, string referer = null, int timeoutSeconds = 20, long MaxResponseContentBufferSize = 0, List<HeadersModel> headers = null, WebProxy proxy = null, bool statusCodeOK = true, bool useDefaultHeaders = true)
        {
            return (await BaseDownload(url, cookie, referer, timeoutSeconds, MaxResponseContentBufferSize, headers, proxy, statusCodeOK, useDefaultHeaders).ConfigureAwait(false)).array;
        }
        #endregion

        #region BaseDownload
        async public static Task<(byte[] array, HttpResponseMessage response)> BaseDownload(string url, string cookie = null, string referer = null, int timeoutSeconds = 20, long MaxResponseContentBufferSize = 0, List<HeadersModel> headers = null, WebProxy proxy = null, bool statusCodeOK = true, bool useDefaultHeaders = true)
        {
            try
            {
                var handler = Handler(url, proxy);

                var client = FrendlyHttp.HttpMessageClient("base", handler);

                var req = new HttpRequestMessage(HttpMethod.Get, url)
                {
                    Version = HttpVersion.Version11
                };

                DefaultRequestHeaders(url, req, cookie, referer, headers, useDefaultHeaders);

                using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(Math.Max(20, timeoutSeconds))))
                {
                    using (HttpResponseMessage response = await client.SendAsync(req, cts.Token).ConfigureAwait(false))
                    {
                        if (statusCodeOK && response.StatusCode != HttpStatusCode.OK)
                            return (null, response);

                        using (HttpContent content = response.Content)
                        {
                            byte[] res = await content.ReadAsByteArrayAsync().ConfigureAwait(false);
                            if (res == null || res.Length == 0)
                                return (null, response);

                            return (res, response);
                        }
                    }
                }
            }
            catch
            {
                return (null, new HttpResponseMessage()
                {
                    StatusCode = HttpStatusCode.InternalServerError,
                    RequestMessage = new HttpRequestMessage()
                });
            }
        }
        #endregion

        #region DownloadFile
        async public static Task<bool> DownloadFile(string url, string path, int timeoutSeconds = 20, List<HeadersModel> headers = null, WebProxy proxy = null)
        {
            try
            {
                using (var handler = Handler(url, proxy))
                {
                    using (var client = new HttpClient(handler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(timeoutSeconds);

                        bool setDefaultUseragent = true;

                        if (headers != null)
                        {
                            foreach (var item in headers)
                            {
                                if (item.name.ToLower() == "user-agent")
                                    setDefaultUseragent = false;

                                if (!client.DefaultRequestHeaders.Contains(item.name))
                                    client.DefaultRequestHeaders.Add(item.name, item.val);
                            }
                        }

                        if (setDefaultUseragent)
                            client.DefaultRequestHeaders.Add("User-Agent", UserAgent);

                        using (var stream = await client.GetStreamAsync(url))
                        {
                            using (var fileStream = new FileStream(path, FileMode.Create, FileAccess.Write, FileShare.None))
                            {
                                await stream.CopyToAsync(fileStream);
                                return true;
                            }
                        }
                    }
                }
            }
            catch
            {
                return false;
            }
        }
        #endregion


        #region WriteLog
        static FileStream logFileStream = null;

        public static EventHandler<string> onlog = null;

        static void WriteLog(string url, string method, in string postdata, in string result)
        {
            if (url.Contains("127.0.0.1"))
                return;

            if (!AppInit.conf.filelog && !AppInit.conf.weblog.enable)
                return;

            var log = new StringBuilder();

            log.Append($"{DateTime.Now}\n{method}: {url}\n");

            if (!string.IsNullOrEmpty(postdata))
                log.Append($"{postdata}\n\n");

            log.Append(result);

            onlog?.Invoke(null, log.ToString());

            if (!AppInit.conf.filelog || log.Length > 700_000)
                return;

            string dateLog = DateTime.Today.ToString("dd.MM.yy");
            string patchlog = $"cache/logs/HttpClient_{dateLog}.log";

            if (logFileStream == null || !File.Exists(patchlog))
                logFileStream = new FileStream(patchlog, FileMode.Append, FileAccess.Write, FileShare.Read);

            var buffer = Encoding.UTF8.GetBytes($"\n\n\n################################################################\n\n{log.ToString()}");
            logFileStream.Write(buffer, 0, buffer.Length);
            logFileStream.Flush();
        }
        #endregion
    }
}

```

## File: Shared/Engine/SISI/HQpornerTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class HQpornerTo
    {
        public static ValueTask<string> InvokeHtml(string host, string search, string sort, string c, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = $"{host}/";

            if (!string.IsNullOrWhiteSpace(search))
            {
                url += $"?q={HttpUtility.UrlEncode(search)}&p={pg}";
            }
            else
            {
                if (!string.IsNullOrEmpty(c))
                {
                    url += $"category/{c}";
                }
                else
                {
                    if (!string.IsNullOrEmpty(sort))
                        url += $"top/{sort}";

                    else
                        url += "hdporn";
                }

                url += $"/{pg}";
            }

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("<div class=\"img-container\">");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                var g = Regex.Match(row, "href=\"/([^\"]+)\" class=\"atfi[^\"]+\"><img src=\"//([^\"]+)\"[^>]+ alt=\"([^\"]+)\"").Groups;
                if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                {
                    string duration = new Regex("class=\"fa fa-clock-o\" [^>]+></i>([\n\r\t ]+)?([^<]+)<").Match(row).Groups[2].Value.Trim();

                    var pl = new PlaylistItem()
                    {
                        name = g[3].Value.Trim(),
                        video = $"{uri}?uri={g[1].Value}",
                        picture = "https://" + g[2].Value,
                        time = duration,
                        json = true,
                        bookmark = new Bookmark()
                        {
                            site = "hqr",
                            href = g[1].Value,
                            image = "https://" + g[2].Value
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string sort, string c)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";
            string url = host + "hqr";

            var menu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = url,
                }
            };

            if (string.IsNullOrEmpty(c))
            {
                menu.Add(new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrEmpty(sort) ? "–Ω–æ–≤–∏–Ω–∫–∏" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–°–∞–º—ã–µ –Ω–æ–≤—ã–µ",
                            playlist_url = url + $"?c={c}"
                        },
                        new MenuItem()
                        {
                            title = "–¢–æ–ø –Ω–µ–¥–µ–ª–∏",
                            playlist_url = url + $"?c={c}&sort=week"
                        },
                        new MenuItem()
                        {
                            title = "–¢–æ–ø –º–µ—Å—è—Ü–∞",
                            playlist_url = url + $"?c={c}&sort=month"
                        }
                    }
                });
            }

            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–í—Å–µ",
                        playlist_url = url + $"?sort={sort}"
                    },
                    new MenuItem()
                    {
                        title = "1080p porn",
                        playlist_url = url + $"?sort={sort}&c=1080p-porn"
                    },
                    new MenuItem()
                    {
                        title = "anal",
                        playlist_url = url + $"?sort={sort}&c=anal-sex-hd"
                    },
                    new MenuItem()
                    {
                        title = "4k porn",
                        playlist_url = url + $"?sort={sort}&c=4k-porn"
                    },
                    new MenuItem()
                    {
                        title = "milf",
                        playlist_url = url + $"?sort={sort}&c=milf"
                    },
                    new MenuItem()
                    {
                        title = "lesbian",
                        playlist_url = url + $"?sort={sort}&c=lesbian"
                    },
                    new MenuItem()
                    {
                        title = "60fps",
                        playlist_url = url + $"?sort={sort}&c=60fps-porn"
                    },
                    new MenuItem()
                    {
                        title = "creampie",
                        playlist_url = url + $"?sort={sort}&c=creampie"
                    },
                    new MenuItem()
                    {
                        title = "big tits",
                        playlist_url = url + $"?sort={sort}&c=big-tits"
                    },
                    new MenuItem()
                    {
                        title = "teen porn",
                        playlist_url = url + $"?sort={sort}&c=teen-porn"
                    },
                    new MenuItem()
                    {
                        title = "pov",
                        playlist_url = url + $"?sort={sort}&c=pov"
                    },
                    new MenuItem()
                    {
                        title = "threesome",
                        playlist_url = url + $"?sort={sort}&c=threesome"
                    },
                    new MenuItem()
                    {
                        title = "asian",
                        playlist_url = url + $"?sort={sort}&c=asian"
                    },
                    new MenuItem()
                    {
                        title = "old and young",
                        playlist_url = url + $"?sort={sort}&c=old-and-young"
                    },
                    new MenuItem()
                    {
                        title = "ebony",
                        playlist_url = url + $"?sort={sort}&c=ebony"
                    },
                    new MenuItem()
                    {
                        title = "big ass",
                        playlist_url = url + $"?sort={sort}&c=big-ass"
                    },
                    new MenuItem()
                    {
                        title = "interracial",
                        playlist_url = url + $"?sort={sort}&c=interracial"
                    },
                    new MenuItem()
                    {
                        title = "squirt",
                        playlist_url = url + $"?sort={sort}&c=squirt"
                    },
                    new MenuItem()
                    {
                        title = "mature",
                        playlist_url = url + $"?sort={sort}&c=mature"
                    },
                    new MenuItem()
                    {
                        title = "sex massage",
                        playlist_url = url + $"?sort={sort}&c=porn-massage"
                    },
                    new MenuItem()
                    {
                        title = "amateur",
                        playlist_url = url + $"?sort={sort}&c=amateur"
                    },
                    new MenuItem()
                    {
                        title = "casting",
                        playlist_url = url + $"?sort={sort}&c=casting"
                    },
                    new MenuItem()
                    {
                        title = "gangbang",
                        playlist_url = url + $"?sort={sort}&c=gangbang"
                    },
                    new MenuItem()
                    {
                        title = "stockings",
                        playlist_url = url + $"?sort={sort}&c=stockings"
                    },
                    new MenuItem()
                    {
                        title = "big dick",
                        playlist_url = url + $"?sort={sort}&c=big-dick"
                    },
                    new MenuItem()
                    {
                        title = "babe",
                        playlist_url = url + $"?sort={sort}&c=babe"
                    },
                    new MenuItem()
                    {
                        title = "latina",
                        playlist_url = url + $"?sort={sort}&c=latina"
                    },
                    new MenuItem()
                    {
                        title = "group sex",
                        playlist_url = url + $"?sort={sort}&c=group-sex"
                    },
                    new MenuItem()
                    {
                        title = "russian",
                        playlist_url = url + $"?sort={sort}&c=russian"
                    },
                    new MenuItem()
                    {
                        title = "masturbation",
                        playlist_url = url + $"?sort={sort}&c=masturbation"
                    },
                    new MenuItem()
                    {
                        title = "hairy pussy",
                        playlist_url = url + $"?sort={sort}&c=hairy-pussy"
                    },
                    new MenuItem()
                    {
                        title = "uniforms",
                        playlist_url = url + $"?sort={sort}&c=uniforms"
                    },
                    new MenuItem()
                    {
                        title = "shemale",
                        playlist_url = url + $"?sort={sort}&c=shemale"
                    },
                    new MenuItem()
                    {
                        title = "blonde",
                        playlist_url = url + $"?sort={sort}&c=blonde"
                    },
                    new MenuItem()
                    {
                        title = "orgasm",
                        playlist_url = url + $"?sort={sort}&c=orgasm"
                    },
                    new MenuItem()
                    {
                        title = "pickup",
                        playlist_url = url + $"?sort={sort}&c=pickup"
                    },
                    new MenuItem()
                    {
                        title = "sex party",
                        playlist_url = url + $"?sort={sort}&c=sex-parties"
                    },
                    new MenuItem()
                    {
                        title = "bdsm",
                        playlist_url = url + $"?sort={sort}&c=bdsm"
                    },
                    new MenuItem()
                    {
                        title = "public",
                        playlist_url = url + $"?sort={sort}&c=public"
                    },
                    new MenuItem()
                    {
                        title = "japanese",
                        playlist_url = url + $"?sort={sort}&c=japanese-girls-porn"
                    },
                    new MenuItem()
                    {
                        title = "redhead",
                        playlist_url = url + $"?sort={sort}&c=redhead"
                    },
                    new MenuItem()
                    {
                        title = "orgy",
                        playlist_url = url + $"?sort={sort}&c=orgy"
                    },
                    new MenuItem()
                    {
                        title = "blowjob",
                        playlist_url = url + $"?sort={sort}&c=blowjob"
                    },
                    new MenuItem()
                    {
                        title = "fetish",
                        playlist_url = url + $"?sort={sort}&c=fetish"
                    },
                    new MenuItem()
                    {
                        title = "brunette",
                        playlist_url = url + $"?sort={sort}&c=brunette"
                    },
                    new MenuItem()
                    {
                        title = "small tits",
                        playlist_url = url + $"?sort={sort}&c=small-tits"
                    },
                    new MenuItem()
                    {
                        title = "undressing",
                        playlist_url = url + $"?sort={sort}&c=undressing"
                    },
                    new MenuItem()
                    {
                        title = "cumshot",
                        playlist_url = url + $"?sort={sort}&c=cumshot"
                    },
                    new MenuItem()
                    {
                        title = "outdoor",
                        playlist_url = url + $"?sort={sort}&c=outdoor"
                    },
                    new MenuItem()
                    {
                        title = "deepthroat",
                        playlist_url = url + $"?sort={sort}&c=deepthroat"
                    },
                    new MenuItem()
                    {
                        title = "bondage",
                        playlist_url = url + $"?sort={sort}&c=bondage"
                    },
                    new MenuItem()
                    {
                        title = "shaved pussy",
                        playlist_url = url + $"?sort={sort}&c=shaved-pussy"
                    },
                    new MenuItem()
                    {
                        title = "bisexual",
                        playlist_url = url + $"?sort={sort}&c=bisexual"
                    },
                    new MenuItem()
                    {
                        title = "hentai",
                        playlist_url = url + $"?sort={sort}&c=hentai"
                    },
                    new MenuItem()
                    {
                        title = "handjob",
                        playlist_url = url + $"?sort={sort}&c=handjob"
                    },
                    new MenuItem()
                    {
                        title = "pussy licking",
                        playlist_url = url + $"?sort={sort}&c=pussy-licking"
                    },
                    new MenuItem()
                    {
                        title = "moaning",
                        playlist_url = url + $"?sort={sort}&c=moaning"
                    },
                    new MenuItem()
                    {
                        title = "fisting",
                        playlist_url = url + $"?sort={sort}&c=fisting"
                    },
                    new MenuItem()
                    {
                        title = "vintage",
                        playlist_url = url + $"?sort={sort}&c=vintage"
                    },
                    new MenuItem()
                    {
                        title = "tattooed",
                        playlist_url = url + $"?sort={sort}&c=tattooed"
                    },
                    new MenuItem()
                    {
                        title = "beach",
                        playlist_url = url + $"?sort={sort}&c=beach-porn"
                    },
                    new MenuItem()
                    {
                        title = "vibrator",
                        playlist_url = url + $"?sort={sort}&c=vibrator"
                    },
                    new MenuItem()
                    {
                        title = "fingering",
                        playlist_url = url + $"?sort={sort}&c=fingering"
                    },
                    new MenuItem()
                    {
                        title = "squeezing tits",
                        playlist_url = url + $"?sort={sort}&c=squeezing-tits"
                    },
                    new MenuItem()
                    {
                        title = "long hair",
                        playlist_url = url + $"?sort={sort}&c=long-hair"
                    }
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }

            return menu;
        }

        async public static ValueTask<Dictionary<string, string>> StreamLinks(string host, string uri, Func<string, ValueTask<string>> onresult, Func<string, ValueTask<string>> oniframe)
        {
            if (string.IsNullOrWhiteSpace(uri))
                return null;

            string html = await onresult.Invoke($"{host}/{uri}");
            if (html == null)
                return null;

            string uriframe = Regex.Match(html, "<iframe src=\"//([^/]+/video/[^/]+/)\"").Groups[1].Value;
            if (string.IsNullOrWhiteSpace(uriframe))
                return null;

            string iframeHtml = await oniframe.Invoke($"https://{uriframe}");
            if (iframeHtml == null)
                return null;

            var stream_links = new Dictionary<string, string>();
            var match = new Regex("src=\"//([^\"]+)\" title=\"([^\"]+)\"").Match(iframeHtml.Replace("\\", ""));
            while (match.Success)
            {
                if (!string.IsNullOrWhiteSpace(match.Groups[1].Value) && !string.IsNullOrWhiteSpace(match.Groups[2].Value) && !match.Groups[2].Value.Contains("Default"))
                {
                    string hls = "https://" + match.Groups[1].Value;
                    stream_links.TryAdd(match.Groups[2].Value, hls);
                }

                match = match.NextMatch();
            }

            if (stream_links.Count == 0)
            {
                string jw = Regex.Match(iframeHtml, "\\$\\(\"#jw\"\\)([^;]+)").Groups[1].Value;
                if (jw.Contains("replaceAll"))
                {
                    var grpal = Regex.Match(iframeHtml, "replaceAll\\(\"([^\"]+)\",([^\\+]+)\\+\"pubs/\"\\+([^\\+]+)").Groups;

                    string cdn = Regex.Match(iframeHtml, grpal[2].Value + "=\"([^\"]+)\"").Groups[1].Value;
                    string hash = Regex.Match(iframeHtml, grpal[3].Value + "=\"([^\"]+)\"").Groups[1].Value;

                    if (!string.IsNullOrEmpty(cdn) && !string.IsNullOrEmpty(hash))
                    {
                        match = new Regex("src=\"([^\"]+[0-9]+\\.mp4)\" title=\"([^\"]+)\"").Match(iframeHtml.Replace("\\", ""));
                        while (match.Success)
                        {
                            if (!string.IsNullOrWhiteSpace(match.Groups[1].Value) && !string.IsNullOrWhiteSpace(match.Groups[2].Value) && !match.Groups[2].Value.Contains("Default"))
                            {
                                string hls = match.Groups[1].Value.Replace(grpal[1].Value, $"https:{cdn}pubs/{hash}/");

                                if (hls.StartsWith("https:"))
                                    stream_links.TryAdd(match.Groups[2].Value, hls);
                            }

                            match = match.NextMatch();
                        }
                    }
                }
            }

            return stream_links.Reverse().ToDictionary(k => k.Key, v => v.Value);
        }
    }
}

```

## File: Shared/Engine/SISI/EpornerTo.cs
```
Ôªøusing HtmlAgilityPack;
using Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class EpornerTo
    {
        public static ValueTask<string> InvokeHtml(string host, string search, string sort, string c, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = $"{host}/";

            if (!string.IsNullOrWhiteSpace(search))
            {
                url += $"search/{HttpUtility.UrlEncode(search)}/";

                if (pg > 1)
                    url += $"{pg}/";

                if (!string.IsNullOrEmpty(sort))
                    url += $"{sort}/";
            }
            else
            {
                if (!string.IsNullOrEmpty(c)) 
                {
                    url += $"cat/{c}/";

                    if (pg > 1)
                        url += $"{pg}/";
                }
                else
                {
                    if (pg > 1)
                        url += $"{pg}/";

                    if (!string.IsNullOrEmpty(sort))
                        url += $"{sort}/";
                }
            }

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var doc = new HtmlDocument();
            doc.LoadHtml(html);

            string single = doc.DocumentNode.SelectSingleNode("//*[@id='relateddiv' or @id='vidresults']")?.InnerHtml;
            if (single != null)
                html = single;
            else
            {
                if (html.Contains("class=\"toptopbelinset\""))
                    html = html.Split("class=\"toptopbelinset\"")[1];

                if (html.Contains("class=\"relatedtext\""))
                    html = html.Split("class=\"relatedtext\"")[1];
            }

            var rows = Regex.Split(html, "<div class=\"mb( hdy)?\"");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                var g = Regex.Match(row, "<p class=\"mbtit\"><a href=\"/([^\"]+)\">([^<]+)</a>").Groups;
                string quality = Regex.Match(row, "<div class=\"mvhdico\"([^>]+)?><span>([^\"<]+)").Groups[2].Value;

                if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                {
                    string img = Regex.Match(row, " data-src=\"([^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrWhiteSpace(img))
                        img = Regex.Match(row, "<img src=\"([^\"]+)\"").Groups[1].Value;

                    string dataid = Regex.Match(row, "data-id=\"([^\"]+)\"").Groups[1].Value;
                    string preview = Regex.Replace(img, "/[^/]+$", "") + $"/{dataid}-preview.webm";

                    string duration = Regex.Match(row, "<span class=\"mbtim\"([^>]+)?>([^<]+)</span>").Groups[2].Value.Trim();

                    var pl = new PlaylistItem()
                    {
                        name = g[2].Value,
                        video = $"{uri}?uri={g[1].Value}",
                        picture = img,
                        preview = preview,
                        quality = quality,
                        time = duration,
                        json = true,
                        related = true,
                        bookmark = new Bookmark()
                        {
                            site = "epr",
                            href = g[1].Value,
                            image = img
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string search, string sort, string c)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";
            string url = host + "epr";

            var menu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = url,
                }
            };

            if (!string.IsNullOrEmpty(search))
            {
                string encodesearch = HttpUtility.UrlEncode(search);

                menu.Add(new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrWhiteSpace(sort) ? "–Ω–æ–≤–∏–Ω–∫–∏" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–æ–≤–∏–Ω–∫–∏",
                            playlist_url = url + $"?search={encodesearch}"
                        },
                        new MenuItem()
                        {
                            title = "–¢–æ–ø –ø—Ä–æ—Å–º–æ—Ç—Ä–∞",
                            playlist_url = url + $"?sort=most-viewed&search={encodesearch}"
                        },
                        new MenuItem()
                        {
                            title = "–¢–æ–ø —Ä–µ–π—Ç–∏–Ω–≥–∞",
                            playlist_url = url + $"?sort=top-rated&search={encodesearch}"
                        },
                        new MenuItem()
                        {
                            title = "–î–ª–∏–Ω–Ω—ã–µ —Ä–æ–ª–∏–∫–∏",
                            playlist_url = url + $"?sort=longest&search={encodesearch}"
                        },
                        new MenuItem()
                        {
                            title = "–ö–æ—Ä–æ—Ç–∫–∏–µ —Ä–æ–ª–∏–∫–∏",
                            playlist_url = url + $"?sort=shortest&search={encodesearch}"
                        }
                    }
                });

                return menu;
            }

            if (string.IsNullOrEmpty(c))
            {
                menu.Add(new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrWhiteSpace(sort) ? "–Ω–æ–≤–∏–Ω–∫–∏" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–æ–≤–∏–Ω–∫–∏",
                            playlist_url = url
                        },
                        new MenuItem()
                        {
                            title = "–¢–æ–ø –ø—Ä–æ—Å–º–æ—Ç—Ä–∞",
                            playlist_url = url + "?sort=most-viewed"
                        },
                        new MenuItem()
                        {
                            title = "–¢–æ–ø —Ä–µ–π—Ç–∏–Ω–≥–∞",
                            playlist_url = url + "?sort=top-rated"
                        },
                        new MenuItem()
                        {
                            title = "–î–ª–∏–Ω–Ω—ã–µ —Ä–æ–ª–∏–∫–∏",
                            playlist_url = url + "?sort=longest"
                        },
                        new MenuItem()
                        {
                            title = "–ö–æ—Ä–æ—Ç–∫–∏–µ —Ä–æ–ª–∏–∫–∏",
                            playlist_url = url + "?sort=shortest"
                        }
                    }
                });
            }

            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–í—Å–µ",
                        playlist_url = url
                    },
                    new MenuItem()
                    {
                        title = "4K UHD",
                        playlist_url = url + $"?c=4k-porn"
                    },
                    new MenuItem()
                    {
                        title = "60 FPS",
                        playlist_url = url + $"?c=60fps"
                    },
                    new MenuItem()
                    {
                        title = "Amateur",
                        playlist_url = url + $"?c=amateur"
                    },
                    new MenuItem()
                    {
                        title = "Anal",
                        playlist_url = url + $"?c=anal"
                    },
                    new MenuItem()
                    {
                        title = "Asian",
                        playlist_url = url + $"?c=asian"
                    },
                    new MenuItem()
                    {
                        title = "ASMR",
                        playlist_url = url + $"?c=asmr"
                    },
                    new MenuItem()
                    {
                        title = "BBW",
                        playlist_url = url + $"?c=bbw"
                    },
                    new MenuItem()
                    {
                        title = "BDSM",
                        playlist_url = url + $"?c=bdsm"
                    },
                    new MenuItem()
                    {
                        title = "Big Ass",
                        playlist_url = url + $"?c=big-ass"
                    },
                    new MenuItem()
                    {
                        title = "Big Dick",
                        playlist_url = url + $"?c=big-dick"
                    },
                    new MenuItem()
                    {
                        title = "Big Tits",
                        playlist_url = url + $"?c=big-tits"
                    },
                    new MenuItem()
                    {
                        title = "Bisexual",
                        playlist_url = url + $"?c=bisexual"
                    },
                    new MenuItem()
                    {
                        title = "Blonde",
                        playlist_url = url + $"?c=blonde"
                    },
                    new MenuItem()
                    {
                        title = "Blowjob",
                        playlist_url = url + $"?c=blowjob"
                    },
                    new MenuItem()
                    {
                        title = "Bondage",
                        playlist_url = url + $"?c=bondage"
                    },
                    new MenuItem()
                    {
                        title = "Brunette",
                        playlist_url = url + $"?c=brunette"
                    },
                    new MenuItem()
                    {
                        title = "Bukkake",
                        playlist_url = url + $"?c=bukkake"
                    },
                    new MenuItem()
                    {
                        title = "Creampie",
                        playlist_url = url + $"?c=creampie"
                    },
                    new MenuItem()
                    {
                        title = "Cumshot",
                        playlist_url = url + $"?c=cumshot"
                    },
                    new MenuItem()
                    {
                        title = "Double Penetration",
                        playlist_url = url + $"?c=double-penetration"
                    },
                    new MenuItem()
                    {
                        title = "Ebony",
                        playlist_url = url + $"?c=ebony"
                    },
                    new MenuItem()
                    {
                        title = "Fat",
                        playlist_url = url + $"?c=fat"
                    },
                    new MenuItem()
                    {
                        title = "Fetish",
                        playlist_url = url + $"?c=fetish"
                    },
                    new MenuItem()
                    {
                        title = "Fisting",
                        playlist_url = url + $"?c=fisting"
                    },
                    new MenuItem()
                    {
                        title = "Footjob",
                        playlist_url = url + $"?c=footjob"
                    },
                    new MenuItem()
                    {
                        title = "For Women",
                        playlist_url = url + $"?c=for-women"
                    },
                    new MenuItem()
                    {
                        title = "Gay",
                        playlist_url = url + $"?c=gay"
                    },
                    new MenuItem()
                    {
                        title = "Group Sex",
                        playlist_url = url + $"?c=group-sex"
                    },
                    new MenuItem()
                    {
                        title = "Handjob",
                        playlist_url = url + $"?c=handjob"
                    },
                    new MenuItem()
                    {
                        title = "Hardcore",
                        playlist_url = url + $"?c=hardcore"
                    },
                    new MenuItem()
                    {
                        title = "Hentai",
                        playlist_url = url + $"?c=hentai"
                    },
                    new MenuItem()
                    {
                        title = "Homemade",
                        playlist_url = url + $"?c=homemade"
                    },
                    new MenuItem()
                    {
                        title = "Hotel",
                        playlist_url = url + $"?c=hotel"
                    },
                    new MenuItem()
                    {
                        title = "Housewives",
                        playlist_url = url + $"?c=housewives"
                    },
                    new MenuItem()
                    {
                        title = "Indian",
                        playlist_url = url + $"?c=indian"
                    },
                    new MenuItem()
                    {
                        title = "Interracial",
                        playlist_url = url + $"?c=interracial"
                    },
                    new MenuItem()
                    {
                        title = "Japanese",
                        playlist_url = url + $"?c=japanese"
                    },
                    new MenuItem()
                    {
                        title = "Latina",
                        playlist_url = url + $"?c=latina"
                    },
                    new MenuItem()
                    {
                        title = "Lesbian",
                        playlist_url = url + $"?c=lesbians"
                    },
                    new MenuItem()
                    {
                        title = "Lingerie",
                        playlist_url = url + $"?c=lingerie"
                    },
                    new MenuItem()
                    {
                        title = "Massage",
                        playlist_url = url + $"?c=massage"
                    },
                    new MenuItem()
                    {
                        title = "Masturbation",
                        playlist_url = url + $"?c=masturbation"
                    },
                    new MenuItem()
                    {
                        title = "Mature",
                        playlist_url = url + $"?c=mature"
                    },
                    new MenuItem()
                    {
                        title = "MILF",
                        playlist_url = url + $"?c=milf"
                    },
                    new MenuItem()
                    {
                        title = "Nurses",
                        playlist_url = url + $"?c=nurse"
                    },
                    new MenuItem()
                    {
                        title = "Office",
                        playlist_url = url + $"?c=office"
                    },
                    new MenuItem()
                    {
                        title = "Older Men",
                        playlist_url = url + $"?c=old-man"
                    },
                    new MenuItem()
                    {
                        title = "Orgy",
                        playlist_url = url + $"?c=orgy"
                    },
                    new MenuItem()
                    {
                        title = "Outdoor",
                        playlist_url = url + $"?c=outdoor"
                    },
                    new MenuItem()
                    {
                        title = "Petite",
                        playlist_url = url + $"?c=petite"
                    },
                    new MenuItem()
                    {
                        title = "Pornstar",
                        playlist_url = url + $"?c=pornstar"
                    },
                    new MenuItem()
                    {
                        title = "POV",
                        playlist_url = url + $"?c=pov-porn"
                    },
                    new MenuItem()
                    {
                        title = "Public",
                        playlist_url = url + $"?c=public"
                    },
                    new MenuItem()
                    {
                        title = "Redhead",
                        playlist_url = url + $"?c=redhead"
                    },
                    new MenuItem()
                    {
                        title = "Shemale",
                        playlist_url = url + $"?c=shemale"
                    },
                    new MenuItem()
                    {
                        title = "Sleep",
                        playlist_url = url + $"?c=sleep"
                    },
                    new MenuItem()
                    {
                        title = "Small Tits",
                        playlist_url = url + $"?c=small-tits"
                    },
                    new MenuItem()
                    {
                        title = "Squirt",
                        playlist_url = url + $"?c=squirt"
                    },
                    new MenuItem()
                    {
                        title = "Striptease",
                        playlist_url = url + $"?c=striptease"
                    },
                    new MenuItem()
                    {
                        title = "Students",
                        playlist_url = url + $"?c=students"
                    },
                    new MenuItem()
                    {
                        title = "Swinger",
                        playlist_url = url + $"?c=swingers"
                    },
                    new MenuItem()
                    {
                        title = "Teen",
                        playlist_url = url + $"?c=teens"
                    },
                    new MenuItem()
                    {
                        title = "Threesome",
                        playlist_url = url + $"?c=threesome"
                    },
                    new MenuItem()
                    {
                        title = "Toys",
                        playlist_url = url + $"?c=toys"
                    },
                    new MenuItem()
                    {
                        title = "Uncategorized",
                        playlist_url = url + $"?c=uncategorized"
                    },
                    new MenuItem()
                    {
                        title = "Uniform",
                        playlist_url = url + $"?c=uniform"
                    },
                    new MenuItem()
                    {
                        title = "Vintage",
                        playlist_url = url + $"?c=vintage"
                    },
                    new MenuItem()
                    {
                        title = "Webcam",
                        playlist_url = url + $"?c=webcam"
                    }
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }

            return menu;
        }

        async public static ValueTask<StreamItem> StreamLinks(string uri, string host, string url, Func<string, ValueTask<string>> onresult, Func<string, ValueTask<string>> onjson, Func<string, string> onlog = null)
        {
            if (string.IsNullOrEmpty(url))
                return null;

            string html = await onresult.Invoke($"{host}/{url}");
            if (html == null)
                return null;

            string vid = Regex.Match(html, "vid ?= ?'([^']+)'").Groups[1].Value;
            string hash = Regex.Match(html, "hash ?= ?'([^']+)'").Groups[1].Value;
            if (string.IsNullOrWhiteSpace(vid) || string.IsNullOrWhiteSpace(hash))
                return null;

            string json = await onjson.Invoke($"{host}/xhr/video/{vid}?hash={convertHash(hash)}&domain={Regex.Replace(host, "^https?://", "")}&fallback=false&embed=false&supportedFormats=dash,mp4&_={DateTimeOffset.UtcNow.ToUnixTimeSeconds()}");
            if (json == null)
                return null;

            onlog?.Invoke("json: " + json);

            var stream_links = new Dictionary<string, string>();
            var match = new Regex("\"src\":( +)?\"(https?://[^/]+/[^\"]+-([0-9]+p).mp4)\",").Match(json);
            while (match.Success)
            {
                onlog?.Invoke($"{match.Groups[3].Value} /  {match.Groups[2].Value}");
                stream_links.TryAdd(match.Groups[3].Value, match.Groups[2].Value);
                match = match.NextMatch();
            }

            onlog?.Invoke("stream_links: " + stream_links.Count);

            return new StreamItem()
            {
                qualitys = stream_links,
                recomends = Playlist(uri, html)
            };
        }


        #region convertHash
        static string convertHash(in string h)
        {
            return Base36(h.Substring(0, 8)) + Base36(h.Substring(8, 8)) + Base36(h.Substring(16, 8)) + Base36(h.Substring(24, 8));
        }
        #endregion

        #region Base36
        static string Base36(in string val)
        {
            string result = "";
            ulong value = Convert.ToUInt64(val, 16);

            const int Base = 36;
            const string Chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

            while (value > 0)
            {
                result = Chars[(int)(value % Base)] + result; // use StringBuilder for better performance
                value /= Base;
            }

            return result.ToLower();
        }
        #endregion
    }
}

```

## File: Shared/Engine/SISI/RunetkiTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using System.Text.RegularExpressions;

namespace Shared.Engine.SISI
{
    public static class RunetkiTo
    {
        public static ValueTask<string> InvokeHtml(string host, string sort, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = host + $"/tools/listing_v3.php?livetab={sort ?? "all"}&offset={(pg > 1 ? ((pg-1) * 72) : 0)}&limit=72";

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(in string html, out int total_pages, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            total_pages = 0;

            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("\"gender\"");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                string baba = Regex.Match(row, "\"username\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(baba))
                    continue;

                string esid = Regex.Match(row, "\"esid\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(esid))
                    continue;

                string img = Regex.Match(row, "\"thumb_image\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(img))
                    continue;

                string title = Regex.Match(row, "\"display_name\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(title))
                    title = baba;

                var pl = new PlaylistItem()
                {
                    name = title,
                    quality = Regex.Match(row, "\"vq\":\"([^\"]+)\"").Groups[1].Value,
                    video = $"https://{esid}.bcvcdn.com/hls/stream_{baba}/playlist.m3u8",
                    picture = $"https:{img.Replace("\\", "").Replace("{ext}", "jpg")}"
                };

                if (onplaylist != null)
                    pl = onplaylist.Invoke(pl);

                playlists.Add(pl);
            }

            string total_count = Regex.Match(html, "\"total_count\":([0-9]+),").Groups[1].Value;
            if (int.TryParse(total_count, out int total) && total > 0)
            {
                if (72 >= total)
                    total_pages = 1;
                else
                    total_pages = (total / 72) + 1;
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string sort)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";

            return new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrWhiteSpace(sort) ? "–≤—ã–±—Ä–∞—Ç—å" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–æ–≤—ã–µ",
                            playlist_url = host + "runetki?sort=new"
                        },
                        new MenuItem()
                        {
                            title = "–ü–∞—Ä—ã",
                            playlist_url = host + "runetki?sort=couples"
                        },
                        new MenuItem()
                        {
                            title = "–î–µ–≤—É—à–∫–∏",
                            playlist_url = host + "runetki?sort=female"
                        },
                        new MenuItem()
                        {
                            title = "–ü–∞—Ä–Ω–∏",
                            playlist_url = host + "runetki?sort=male"
                        },
                        new MenuItem()
                        {
                            title = "–¢—Ä–∞–Ω—Å—Å–µ–∫—Å—É–∞–ª—ã",
                            playlist_url = host + "runetki?sort=transsexual"
                        }
                    }
                }
            };
        }
    }
}

```

## File: Shared/Engine/SISI/XhamsterTo.cs
```
Ôªøusing HtmlAgilityPack;
using Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class XhamsterTo
    {
        public static ValueTask<string> InvokeHtml(string host, string plugin, string search, string c, string q, string sort, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url;

            if (!string.IsNullOrWhiteSpace(search))
            {
                url = $"{host}/search/{HttpUtility.UrlEncode(search)}?page={pg}";
            }
            else
            {
                switch (plugin ?? "")
                {
                    case "xmrsml":
                        url = $"{host}/shemale";
                        break;
                    case "xmrgay":
                        url = $"{host}/gay";
                        break;
                    default:
                        url = host;
                        break;
                }

                if (!string.IsNullOrEmpty(c))
                    url += $"/categories/{c}";

                if (!string.IsNullOrEmpty(q))
                    url += $"/{q}";

                switch (sort ?? "")
                {
                    case "newest":
                        url += "/newest";
                        break;
                    case "best":
                        url += "/best";
                        break;
                    default:
                        break;
                }

                if (pg > 0)
                    url += $"/{pg}";
            }

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            string section = html;

            if (html.Contains("mixed-section"))
            {
                var doc = new HtmlDocument();
                doc.LoadHtml(html);
                string single = doc.DocumentNode.SelectSingleNode("//div[contains(@class, 'mixed-section')]")?.InnerHtml;
                if (single != null)
                    section = single;
            }

            var rows = Regex.Split(section, "(<div class=\"thumb-list__item video-thumb|thumb-list-mobile-item)");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                if (string.IsNullOrWhiteSpace(row) || row.Contains("badge_premium"))
                    continue;

                var g = Regex.Match(row, "__nam[^\"]+\" href=\"https?://[^/]+/([^\"]+)\"([^>]+)?>(<!--[^-]+-->)?([^<]+)").Groups;
                string title = g[4].Value;
                string href = g[1].Value;

                if (!string.IsNullOrEmpty(href) && !string.IsNullOrWhiteSpace(title))
                {
                    string duration = Regex.Match(row, "data-role=\"video-duration\"><[^>]+>([^<]+)").Groups[1].Value;
                    if (string.IsNullOrEmpty(duration))
                        duration = Regex.Match(row, "datetime=\"([^\"]+)\"").Groups[1].Value;

                    string img = Regex.Match(row, " srcset=\"([^\"]+)\"").Groups[1].Value;
                    if (!img.StartsWith("http") || img.Contains("(w:16,h:9)"))
                    {
                        img = Regex.Match(row, "thumb-image-container__image\" src=\"([^\"]+)\"").Groups[1].Value;
                        if (!img.StartsWith("http"))
                            img = Regex.Match(row, "<noscript><img src=\"([^\"]+)\"").Groups[1].Value.Trim();
                    }

                    if (!img.StartsWith("http"))
                        continue;

                    var pl = new PlaylistItem()
                    {
                        name = title,
                        video = $"{uri}?uri={href}",
                        picture = img,
                        quality = row.Contains("-hd") ? "HD" : row.Contains("-uhd") ? "4K" : null,
                        preview = Regex.Match(row, "data-previewvideo=\"([^\"]+)\"").Groups[1].Value,
                        time = duration?.Trim(),
                        json = true,
                        related = true,
                        bookmark = new Bookmark()
                        {
                            site = "xmr",
                            href = href,
                            image = img
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string plugin, string c, string q, string sort)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";

            var menu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = host + plugin,
                },
                new MenuItem()
                {
                    title = $"–ö–∞—á–µ—Å—Ç–≤–æ: {(q == "4k" ? "2160p" : "–õ—é–±–æ–µ")}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem("–õ—é–±–æ–µ", host + $"{plugin}?c={c}&sort={sort}"),
                        new MenuItem("2160p", host + $"{plugin}?c={c}&sort={sort}&q=4k")
                    }
                },
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(sort == "newest" ? "–ù–æ–≤–∏–Ω–∫–∏" : sort == "best" ? "–õ—É—á—à–∏–µ" :"–í —Ç—Ä–µ–Ω–¥–µ")}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem("–í —Ç—Ä–µ–Ω–¥–µ", host + $"{plugin}?c={c}&q={q}&sort=trend"),
                        new MenuItem("–°–∞–º—ã–µ –Ω–æ–≤—ã–µ", host + $"{plugin}?c={c}&q={q}&sort=newest"),
                        new MenuItem("–õ—É—á—à–∏–µ –≤–∏–¥–µ–æ", host + $"{plugin}?c={c}&q={q}&sort=best")
                    }
                },
                new MenuItem()
                {
                    title = $"–û—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è: {(plugin == "xmrgay" ? "–ì–µ–∏" : plugin == "xmrsml" ? "–¢—Ä–∞–Ω—Å—ã" :"–ì–µ—Ç–µ—Ä–æ")}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem("–ì–µ—Ç–µ—Ä–æ", host + "xmr"),
                        new MenuItem("–ì–µ–∏", host + "xmrgay"),
                        new MenuItem("–¢—Ä–∞–Ω—Å—ã", host + "xmrsml")
                    }
                }
            };

            if (plugin == "xmr")
            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem("–í—Å–µ", host + $"{plugin}?sort={sort}&q={q}"),
                    new MenuItem("–†—É—Å—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=russian"),
                    new MenuItem("–°–µ–∫—Å –≤—Ç—Ä–æ–µ–º", host + $"{plugin}?sort={sort}&q={q}&c=threesome"),
                    new MenuItem("–ê–∑–∏–∞—Ç—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=asian"),
                    new MenuItem("–ê–Ω–∞–ª", host + $"{plugin}?sort={sort}&q={q}&c=anal"),
                    new MenuItem("–ê—Ä–∞–±—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=arab"),
                    new MenuItem("–ê–°–ú–†", host + $"{plugin}?sort={sort}&q={q}&c=asmr"),
                    new MenuItem("–ë–∞–±–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=granny"),
                    new MenuItem("–ë–î–°–ú", host + $"{plugin}?sort={sort}&q={q}&c=bdsm"),
                    new MenuItem("–ë–∏", host + $"{plugin}?sort={sort}&q={q}&c=bisexual"),
                    new MenuItem("–ë–æ–ª—å—à–∏–µ –∂–æ–ø—ã", host + $"{plugin}?sort={sort}&q={q}&c=big-ass"),
                    new MenuItem("–ë–æ–ª—å—à–∏–µ –∑–∞–¥–Ω–∏—Ü—ã", host + $"{plugin}?sort={sort}&q={q}&c=pawg"),
                    new MenuItem("–ë–æ–ª—å—à–∏–µ —Å–∏—Å—å–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=big-tits"),
                    new MenuItem("–ë–æ–ª—å—à–æ–π —á–ª–µ–Ω", host + $"{plugin}?sort={sort}&q={q}&c=big-cock"),
                    new MenuItem("–ë—Ä–∏—Ç–∞–Ω—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=british"),
                    new MenuItem("–í –≤–æ–∑—Ä–∞—Å—Ç–µ", host + $"{plugin}?sort={sort}&q={q}&c=mature"),
                    new MenuItem("–í–µ–±–∫–∞–º–µ—Ä–∞", host + $"{plugin}?sort={sort}&q={q}&c=webcam"),
                    new MenuItem("–í–∏–Ω—Ç–∞–∂", host + $"{plugin}?sort={sort}&q={q}&c=vintage"),
                    new MenuItem("–í–æ–ª–æ—Å–∞—Ç—ã–µ", host + $"{plugin}?sort={sort}&q={q}&c=hairy"),
                    new MenuItem("–ì–æ–ª—ã–µ –º—É–∂—á–∏–Ω—ã –æ–¥–µ—Ç—ã–µ –∂–µ–Ω—â–∏–Ω—ã", host + $"{plugin}?sort={sort}&q={q}&c=cfnm"),
                    new MenuItem("–ì—Ä—É–ø–ø–æ–≤–æ–π —Å–µ–∫—Å", host + $"{plugin}?sort={sort}&q={q}&c=group-sex"),
                    new MenuItem("–ì—ç–Ω–≥–±—ç–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=gangbang"),
                    new MenuItem("–î–∏–ª–¥–æ", host + $"{plugin}?sort={sort}&q={q}&c=dildo"),
                    new MenuItem("–î–æ–º–∞—à–Ω–µ–µ –ø–æ—Ä–Ω–æ", host + $"{plugin}?sort={sort}&q={q}&c=homemade"),
                    new MenuItem("–î—Ä–æ—á–∫–∞ —Å—Ç—É–ø–Ω—è–º–∏", host + $"{plugin}?sort={sort}&q={q}&c=footjob"),
                    new MenuItem("–ñ–µ–Ω—Å–∫–æ–µ –¥–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ", host + $"{plugin}?sort={sort}&q={q}&c=femdom"),
                    new MenuItem("–ñ–∏—Ä–æ–±–∞—Å–∏–Ω–∞", host + $"{plugin}?sort={sort}&q={q}&c=ssbbw"),
                    new MenuItem("–ñ–æ–ø–∞", host + $"{plugin}?sort={sort}&q={q}&c=ass"),
                    new MenuItem("–ó–∞—Å—Ç—Ä—è–ª–∞", host + $"{plugin}?sort={sort}&q={q}&c=stuck"),
                    new MenuItem("–ó–Ω–∞–º–µ–Ω–∏—Ç–æ—Å—Ç—å", host + $"{plugin}?sort={sort}&q={q}&c=celebrity"),
                    new MenuItem("–ò–≥—Ä–∞", host + $"{plugin}?sort={sort}&q={q}&c=game"),
                    new MenuItem("–ò—Å—Ç–æ—Ä–∏—è", host + $"{plugin}?sort={sort}&q={q}&c=story"),
                    new MenuItem("–ö–∞—Å—Ç–∏–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=casting"),
                    new MenuItem("–ö–æ–º–∏—á–µ—Å–∫–∏–π", host + $"{plugin}?sort={sort}&q={q}&c=comic"),
                    new MenuItem("–ö–æ–Ω—á–∏–Ω–∞", host + $"{plugin}?sort={sort}&q={q}&c=cumshot"),
                    new MenuItem("–ö—Ä–µ–º–æ–≤—ã–π –ø–∏—Ä–æ–≥", host + $"{plugin}?sort={sort}&q={q}&c=creampie"),
                    new MenuItem("–õ–∞—Ç–∏–Ω–∞", host + $"{plugin}?sort={sort}&q={q}&c=latina"),
                    new MenuItem("–õ–µ—Å–±–∏—è–Ω–∫–∞", host + $"{plugin}?sort={sort}&q={q}&c=lesbian"),
                    new MenuItem("–õ–∏–∑–∞—Ç—å –∫–∏—Å–∫—É", host + $"{plugin}?sort={sort}&q={q}&c=eating-pussy"),
                    new MenuItem("–õ—é–±–∏—Ç–µ–ª—å—Å–∫–æ–µ –ø–æ—Ä–Ω–æ", host + $"{plugin}?sort={sort}&q={q}&c=amateur"),
                    new MenuItem("–ú–∞—Å—Å–∞–∂", host + $"{plugin}?sort={sort}&q={q}&c=massage"),
                    new MenuItem("–ú–µ–¥—Å–µ—Å—Ç—Ä–∞", host + $"{plugin}?sort={sort}&q={q}&c=nurse"),
                    new MenuItem("–ú–µ–∂—Ä–∞—Å–æ–≤—ã–π —Å–µ–∫—Å", host + $"{plugin}?sort={sort}&q={q}&c=interracial"),
                    new MenuItem("–ú–ò–õ–§", host + $"{plugin}?sort={sort}&q={q}&c=milf"),
                    new MenuItem("–ú–∏–ª—ã–µ", host + $"{plugin}?sort={sort}&q={q}&c=cute"),
                    new MenuItem("–ú–∏–Ω–µ—Ç", host + $"{plugin}?sort={sort}&q={q}&c=blowjob"),
                    new MenuItem("–ú–∏–Ω–∏–∞—Ç—é—Ä–Ω–∞—è", host + $"{plugin}?sort={sort}&q={q}&c=petite"),
                    new MenuItem("–ú–∏—Å—Å–∏–æ–Ω–µ—Ä—Å–∫–∞—è –ø–æ–∑–∞", host + $"{plugin}?sort={sort}&q={q}&c=missionary"),
                    new MenuItem("–ú–æ–Ω–∞—Ö–∏–Ω—è", host + $"{plugin}?sort={sort}&q={q}&c=nun"),
                    new MenuItem("–ú—É–ª—å—Ç—Ñ–∏–ª—å–º—ã", host + $"{plugin}?sort={sort}&q={q}&c=cartoon"),
                    new MenuItem("–ù–µ–≥—Ä–∏—Ç—è–Ω–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=black"),
                    new MenuItem("–ù–µ–º–µ—Ü–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=german"),
                    new MenuItem("–û—Ñ–∏—Å", host + $"{plugin}?sort={sort}&q={q}&c=office"),
                    new MenuItem("–ü–µ—Ä–≤—ã–π —Ä–∞–∑", host + $"{plugin}?sort={sort}&q={q}&c=first-time"),
                    new MenuItem("–ü–ª—è–∂", host + $"{plugin}?sort={sort}&q={q}&c=beach"),
                    new MenuItem("–ü–æ—Ä–Ω–æ –¥–ª—è –∂–µ–Ω—â–∏–Ω", host + $"{plugin}?sort={sort}&q={q}&c=porn-for-women"),
                    new MenuItem("–†–µ—Å–ª–∏–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=wrestling"),
                    new MenuItem("–†–æ–≥–æ–Ω–æ—Å—Ü—ã", host + $"{plugin}?sort={sort}&q={q}&c=cuckold"),
                    new MenuItem("–†–æ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π", host + $"{plugin}?sort={sort}&q={q}&c=romantic"),
                    new MenuItem("–°–≤–∏–Ω–≥–µ—Ä—ã", host + $"{plugin}?sort={sort}&q={q}&c=swingers"),
                    new MenuItem("–°–∫–≤–∏—Ä—Ç", host + $"{plugin}?sort={sort}&q={q}&c=squirting"),
                    new MenuItem("–°—Ç–∞—Ä–∏–∫", host + $"{plugin}?sort={sort}&q={q}&c=old-man"),
                    new MenuItem("–°—Ç–∞—Ä—ã–µ —Å –º–æ–ª–æ–¥—ã–º–∏", host + $"{plugin}?sort={sort}&q={q}&c=old-young"),
                    new MenuItem("–¢–∏–Ω–µ–π–¥–∂–µ—Ä—ã (18+)", host + $"{plugin}?sort={sort}&q={q}&c=teen"),
                    new MenuItem("–¢–æ–ª—Å—Ç—É—à–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=bbw"),
                    new MenuItem("–¢—Ä–µ–Ω–∞–∂–µ—Ä–Ω—ã–π –∑–∞–ª", host + $"{plugin}?sort={sort}&q={q}&c=gym"),
                    new MenuItem("–£–∑–∫–∞—è –∫–∏—Å–∫–∞", host + $"{plugin}?sort={sort}&q={q}&c=tight-pussy"),
                    new MenuItem("–§—Ä–∞–Ω—Ü—É–∑—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=french"),
                    new MenuItem("–§—É—Ç–∞–Ω–∞—Ä–∏", host + $"{plugin}?sort={sort}&q={q}&c=futanari"),
                    new MenuItem("–•–∞—Ä–¥–∫–æ—Ä", host + $"{plugin}?sort={sort}&q={q}&c=hardcore"),
                    new MenuItem("–•–µ–Ω–¥–∂–æ–±", host + $"{plugin}?sort={sort}&q={q}&c=handjob"),
                    new MenuItem("–•–µ–Ω—Ç–∞–π", host + $"{plugin}?sort={sort}&q={q}&c=hentai"),
                    new MenuItem("–Ø–ø–æ–Ω—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=japanese")
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }
            else if (plugin == "xmrgay")
            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem("–í—Å–µ", host + $"{plugin}?sort={sort}&q={q}"),
                    new MenuItem("Russian", host + $"{plugin}?sort={sort}&q={q}&c=russian"),
                    new MenuItem("Threesome", host + $"{plugin}?sort={sort}&q={q}&c=threesome"),
                    new MenuItem("–ê–∑–∏–∞—Ç—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=asian"),
                    new MenuItem("–ë–î–°–ú", host + $"{plugin}?sort={sort}&q={q}&c=bdsm"),
                    new MenuItem("–ë–µ–∑ –ø—Ä–µ–∑–µ—Ä–≤–∞—Ç–∏–≤–∞", host + $"{plugin}?sort={sort}&q={q}&c=bareback"),
                    new MenuItem("–ë–æ–ª—å—à–∏–µ –¥—ã—Ä–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=gaping"),
                    new MenuItem("–ë–æ–ª—å—à–æ–π —á–ª–µ–Ω", host + $"{plugin}?sort={sort}&q={q}&c=big-cock"),
                    new MenuItem("–ë—É–∫–∫–∞–∫–µ", host + $"{plugin}?sort={sort}&q={q}&c=bukkake"),
                    new MenuItem("–í–µ–±–∫–∞–º–µ—Ä–∞", host + $"{plugin}?sort={sort}&q={q}&c=webcam"),
                    new MenuItem("–í–∏–Ω—Ç–∞–∂", host + $"{plugin}?sort={sort}&q={q}&c=vintage"),
                    new MenuItem("–ì–ª–æ—Ä–∏—Ö–æ–ª", host + $"{plugin}?sort={sort}&q={q}&c=glory-hole"),
                    new MenuItem("–ì—Ä—É–ø–ø–æ–≤–æ–π —Å–µ–∫—Å", host + $"{plugin}?sort={sort}&q={q}&c=group-sex"),
                    new MenuItem("–ì—ç–Ω–≥–±—ç–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=gangbang"),
                    new MenuItem("–î–µ–¥—É—à–∫–∞", host + $"{plugin}?sort={sort}&q={q}&c=grandpa"),
                    new MenuItem("–î–∏–ª–¥–æ", host + $"{plugin}?sort={sort}&q={q}&c=dildo"),
                    new MenuItem("–ö–æ–Ω—á–∞—Ç—å –Ω–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏", host + $"{plugin}?sort={sort}&q={q}&c=cum-tribute"),
                    new MenuItem("–ö–æ–Ω—á–∏–Ω–∞", host + $"{plugin}?sort={sort}&q={q}&c=cumshot"),
                    new MenuItem("–ö—Ä–∞—Å–∞–≤—á–∏–∫", host + $"{plugin}?sort={sort}&q={q}&c=hunk"),
                    new MenuItem("–ö—Ä–µ–º–æ–≤—ã–π –ø–∏—Ä–æ–≥", host + $"{plugin}?sort={sort}&q={q}&c=creampie"),
                    new MenuItem("–ú–∞–ª–µ–Ω—å–∫–∏–π —á–ª–µ–Ω", host + $"{plugin}?sort={sort}&q={q}&c=small-cock"),
                    new MenuItem("–ú–∞—Å—Å–∞–∂", host + $"{plugin}?sort={sort}&q={q}&c=massage"),
                    new MenuItem("–ú–∞—Å—Ç—É—Ä–±–∞—Ü–∏—è", host + $"{plugin}?sort={sort}&q={q}&c=masturbation"),
                    new MenuItem("–ú–µ–¥–≤–µ–¥—å", host + $"{plugin}?sort={sort}&q={q}&c=bear"),
                    new MenuItem("–ú–µ–∂—Ä–∞—Å–æ–≤—ã–π —Å–µ–∫—Å", host + $"{plugin}?sort={sort}&q={q}&c=interracial"),
                    new MenuItem("–ú–∏–Ω–µ—Ç", host + $"{plugin}?sort={sort}&q={q}&c=blowjob"),
                    new MenuItem("–ú–æ–ª–æ–¥—ã–µ", host + $"{plugin}?sort={sort}&q={q}&c=young"),
                    new MenuItem("–ù–∞ –ø—Ä–∏—Ä–æ–¥–µ", host + $"{plugin}?sort={sort}&q={q}&c=outdoor"),
                    new MenuItem("–ù–µ–≥—Ä—ã", host + $"{plugin}?sort={sort}&q={q}&c=black"),
                    new MenuItem("–ü–∞–ø–æ—á–∫–∞", host + $"{plugin}?sort={sort}&q={q}&c=daddy"),
                    new MenuItem("–ü–ª—è–∂", host + $"{plugin}?sort={sort}&q={q}&c=beach"),
                    new MenuItem("–ü—É—Ö–ª—è—à", host + $"{plugin}?sort={sort}&q={q}&c=chubby"),
                    new MenuItem("–†–∞–∑–¥–µ–≤–∞–ª–∫–∞", host + $"{plugin}?sort={sort}&q={q}&c=locker-room"),
                    new MenuItem("–†–µ—Å—Ç–ª–∏–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=wrestling"),
                    new MenuItem("–°–µ–∫—Å –∏–≥—Ä—É—à–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=sex-toy"),
                    new MenuItem("–°–ª–∞–¥–∫–∏–π –º–∞–ª—å—á–∏–∫", host + $"{plugin}?sort={sort}&q={q}&c=twink"),
                    new MenuItem("–°–æ–ª–æ", host + $"{plugin}?sort={sort}&q={q}&c=solo"),
                    new MenuItem("–°–ø–∞–Ω–∫–∏–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=spanking"),
                    new MenuItem("–°—Ç–∞—Ä—ã–µ —Å –º–æ–ª–æ–¥—ã–º–∏", host + $"{plugin}?sort={sort}&q={q}&c=old-young"),
                    new MenuItem("–°—Ç—Ä–∏–ø—Ç–∏–∑", host + $"{plugin}?sort={sort}&q={q}&c=striptease"),
                    new MenuItem("–¢–æ–ª—Å—Ç—ã–µ", host + $"{plugin}?sort={sort}&q={q}&c=fat"),
                    new MenuItem("–¢—Ä–∞–Ω—Å–≤–µ—Å—Ç–∏—Ç—ã", host + $"{plugin}?sort={sort}&q={q}&c=crossdresser"),
                    new MenuItem("–§–∏—Å—Ç–∏–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=fisting"),
                    new MenuItem("–•–µ–Ω–¥–∂–æ–±", host + $"{plugin}?sort={sort}&q={q}&c=handjob"),
                    new MenuItem("–•–µ–Ω—Ç–∞–π", host + $"{plugin}?sort={sort}&q={q}&c=hentai"),
                    new MenuItem("–≠–º–æ–±–æ–π", host + $"{plugin}?sort={sort}&q={q}&c=emo")
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }
            else if (plugin == "xmrsml")
            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem("–í—Å–µ", host + $"{plugin}?sort={sort}&q={q}"),
                    new MenuItem("Russian", host + $"{plugin}?sort={sort}&q={q}&c=russian"),
                    new MenuItem("Cuckold", host + $"{plugin}?sort={sort}&q={q}&c=cuckold"),
                    new MenuItem("–ê–∑–∏–∞—Ç—Å–∫–æ–µ", host + $"{plugin}?sort={sort}&q={q}&c=asian"),
                    new MenuItem("–ë–î–°–ú", host + $"{plugin}?sort={sort}&q={q}&c=bdsm"),
                    new MenuItem("–ë–µ–∑ –ø—Ä–µ–∑–µ—Ä–≤–∞—Ç–∏–≤–∞", host + $"{plugin}?sort={sort}&q={q}&c=bareback"),
                    new MenuItem("–ë–ª–æ–Ω–¥–∏–Ω–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=blonde"),
                    new MenuItem("–ë–æ–ª—å—à–∏–µ –∂–æ–ø—ã", host + $"{plugin}?sort={sort}&q={q}&c=big-ass"),
                    new MenuItem("–ë–æ–ª—å—à–æ–π —á–ª–µ–Ω", host + $"{plugin}?sort={sort}&q={q}&c=big-cock"),
                    new MenuItem("–í–µ–±–∫–∞–º–µ—Ä–∞", host + $"{plugin}?sort={sort}&q={q}&c=webcam"),
                    new MenuItem("–í–∏–Ω—Ç–∞–∂", host + $"{plugin}?sort={sort}&q={q}&c=vintage"),
                    new MenuItem("–ì—Ä—É–ø–ø–æ–≤–æ–π —Å–µ–∫—Å", host + $"{plugin}?sort={sort}&q={q}&c=group-sex"),
                    new MenuItem("–ì—ç–Ω–≥–±—ç–Ω–≥", host + $"{plugin}?sort={sort}&q={q}&c=gangbang"),
                    new MenuItem("–î–æ–º–∞—à–Ω–µ–µ", host + $"{plugin}?sort={sort}&q={q}&c=homemade"),
                    new MenuItem("–ó–æ–ª–æ—Ç–æ–π –¥–æ–∂–¥—å", host + $"{plugin}?sort={sort}&q={q}&c=pissing"),
                    new MenuItem("–ö—Ä–µ–º–æ–≤—ã–π –ø–∏—Ä–æ–≥", host + $"{plugin}?sort={sort}&q={q}&c=creampie"),
                    new MenuItem("–õ–∞—Ç–µ–∫—Å", host + $"{plugin}?sort={sort}&q={q}&c=latex"),
                    new MenuItem("–õ–∞—Ç–∏–Ω–∞", host + $"{plugin}?sort={sort}&q={q}&c=latina"),
                    new MenuItem("–õ–µ–¥–∏–±–æ–π", host + $"{plugin}?sort={sort}&q={q}&c=ladyboy"),
                    new MenuItem("–õ–æ–≤—É—à–∫–∞", host + $"{plugin}?sort={sort}&q={q}&c=trap"),
                    new MenuItem("–õ—é–±–∏—Ç–µ–ª—å—Å–∫–æ–µ –ø–æ—Ä–Ω–æ", host + $"{plugin}?sort={sort}&q={q}&c=amateur"),
                    new MenuItem("–ú–∞–ª–µ–Ω—å–∫–∏–µ —Å–∏—Å—å–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=small-tits"),
                    new MenuItem("–ú–∞—Å—Ç—É—Ä–±–∞—Ü–∏—è", host + $"{plugin}?sort={sort}&q={q}&c=masturbation"),
                    new MenuItem("–ú–µ–∂—Ä–∞—Å–æ–≤—ã–π —Å–µ–∫—Å", host + $"{plugin}?sort={sort}&q={q}&c=interracial"),
                    new MenuItem("–ú–∏–Ω–µ—Ç", host + $"{plugin}?sort={sort}&q={q}&c=blowjob"),
                    new MenuItem("–ú–∏–Ω–∏–∞—Ç—é—Ä–Ω–∞—è", host + $"{plugin}?sort={sort}&q={q}&c=petite"),
                    new MenuItem("–ù–∞ –ø—Ä–∏—Ä–æ–¥–µ", host + $"{plugin}?sort={sort}&q={q}&c=outdoor"),
                    new MenuItem("–ù–∏–∂–Ω–µ–µ –±–µ–ª—å–µ", host + $"{plugin}?sort={sort}&q={q}&c=lingerie"),
                    new MenuItem("–û—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞", host + $"{plugin}?sort={sort}&q={q}&c=pov"),
                    new MenuItem("–ü–∞—Ä–µ–Ω—å —Ç—Ä–∞—Ö–∞–µ—Ç —Ç—Ä–∞–Ω—Å–∞", host + $"{plugin}?sort={sort}&q={q}&c=guy-fucks-shemale"),
                    new MenuItem("–ü–æ–¥—Ä–æ—Å—Ç–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=teen"),
                    new MenuItem("–†—ã–∂–∏–µ", host + $"{plugin}?sort={sort}&q={q}&c=redhead"),
                    new MenuItem("–°–µ–∫—Å –≤—Ç—Ä–æ–µ–º", host + $"{plugin}?sort={sort}&q={q}&c=threesome"),
                    new MenuItem("–°–µ–∫—Å –∏–≥—Ä—É—à–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=sex-toy"),
                    new MenuItem("–°–æ–ª–æ", host + $"{plugin}?sort={sort}&q={q}&c=solo"),
                    new MenuItem("–¢–∞—Ç—É–∏—Ä–æ–≤–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=tattoo"),
                    new MenuItem("–¢–æ–ª—Å—Ç—É—à–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=bbw"),
                    new MenuItem("–¢—Ä–∞–Ω—Å —Ç—Ä–∞—Ö–∞–µ—Ç –¥–µ–≤—É—à–∫—É", host + $"{plugin}?sort={sort}&q={q}&c=shemale-fucks-girl"),
                    new MenuItem("–¢—Ä–∞–Ω—Å —Ç—Ä–∞—Ö–∞–µ—Ç –ø–∞—Ä–Ω—è", host + $"{plugin}?sort={sort}&q={q}&c=shemale-fucks-guy"),
                    new MenuItem("–¢—Ä–∞–Ω—Å —Ç—Ä–∞—Ö–∞–µ—Ç —Ç—Ä–∞–Ω—Å–∞", host + $"{plugin}?sort={sort}&q={q}&c=shemale-fucks-shemale"),
                    new MenuItem("–¢—Ä–∞–Ω—Å–≤–µ—Å—Ç–∏—Ç", host + $"{plugin}?sort={sort}&q={q}&c=transgender"),
                    new MenuItem("–§–µ—Ç–∏—à", host + $"{plugin}?sort={sort}&q={q}&c=fetish"),
                    new MenuItem("–•–∞—Ä–¥–∫–æ—Ä", host + $"{plugin}?sort={sort}&q={q}&c=hardcore"),
                    new MenuItem("–•–µ–Ω–¥–∂–æ–±", host + $"{plugin}?sort={sort}&q={q}&c=handjob"),
                    new MenuItem("–•–µ–Ω—Ç–∞–π", host + $"{plugin}?sort={sort}&q={q}&c=hentai"),
                    new MenuItem("–•–æ—Ä–æ—à–µ–Ω—å–∫–∞—è", host + $"{plugin}?sort={sort}&q={q}&c=pretty"),
                    new MenuItem("–ß–µ—Ä–Ω–æ–∫–æ–∂–∏–µ", host + $"{plugin}?sort={sort}&q={q}&c=black"),
                    new MenuItem("–ß—É–ª–∫–∏", host + $"{plugin}?sort={sort}&q={q}&c=stockings"),
                    new MenuItem("–Ø–ø–æ–Ω—Å–∫–æ–µ –ø–æ—Ä–Ω–æ", host + $"{plugin}?sort={sort}&q={q}&c=japanese")
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }

            return menu;
        }

        async public static ValueTask<StreamItem> StreamLinks(string uri, string host, string url, Func<string, ValueTask<string>> onresult)
        {
            if (string.IsNullOrEmpty(url))
                return null;

            string html = await onresult.Invoke($"{host}/{url}");
            if (html == null)
                return null;

            string stream_link = Regex.Match(html, "rel=\"preload\" href=\"([^\"]+)\"").Groups[1].Value.Replace("\\", "");
            if (!stream_link.Contains(".m3u"))
                return null;

            if (stream_link.StartsWith("/"))
                stream_link = host + stream_link;

            return new StreamItem()
            {
                qualitys = new Dictionary<string, string>()
                {
                    ["auto"] = stream_link
                },
                recomends = Playlist(uri, html)
            };
        }
    }
}

```

## File: Shared/Engine/SISI/EbalovoTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class EbalovoTo
    {
        public static ValueTask<string> InvokeHtml(string host, string search, string sort, string c, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = $"{host}/";

            if (!string.IsNullOrWhiteSpace(search))
            {
                url += $"search/{HttpUtility.UrlEncode(search)}/";
            }
            else
            {
                if (!string.IsNullOrEmpty(c))
                {
                    url += $"porno/{c}";

                    if (sort is "porno-online" or "xxx-top")
                        url += $"-rating";

                    url += "/";
                }
                else
                {
                    if (!string.IsNullOrEmpty(sort))
                        url += $"{sort}/";
                }
            }

            if (pg > 1)
                url += $"{pg}/";

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("<div class=\"item\">");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows)
            {
                if (!row.Contains("<div class=\"item-info\">"))
                    continue;

                string link = Regex.Match(row, "<a href=\"https?://[^/]+/(video/[^\"]+)\"").Groups[1].Value;
                string title = Regex.Match(row, "<div class=\"item-title\">([^<]+)</div>").Groups[1].Value;

                if (!string.IsNullOrWhiteSpace(title) && !string.IsNullOrWhiteSpace(link))
                {
                    string duration = Regex.Match(row, " data-eb=\"([^;\"]+);").Groups[1].Value.Trim();
                    var img = Regex.Match(row, "( )src=\"(([^\"]+)/[0-9]+.jpg)\"").Groups;
                    if (string.IsNullOrWhiteSpace(img[3].Value) || img[2].Value.Contains("load.png"))
                        img = Regex.Match(row, "(data-srcset|data-src|srcset)=\"([^\"]+/[0-9]+.jpg)\"").Groups;

                    var pl = new PlaylistItem()
                    {
                        name = title.Trim(),
                        video = $"{uri}?uri={link}",
                        picture = img[2].Value,
                        time = duration,
                        json = true,
                        related = true,
                        bookmark = new Bookmark()
                        {
                            site = "elo",
                            href = link,
                            image = img[2].Value
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string sort, string c)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";
            string url = host + "elo";

            var menu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = url,
                },
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrEmpty(sort) ? "–Ω–æ–≤–∏–Ω–∫–∏" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–æ–≤–∏–Ω–∫–∏",
                            playlist_url = url + $"?c={c}"
                        },
                        new MenuItem()
                        {
                            title = "–õ—É—á—à–µ–µ",
                            playlist_url = url + $"?c={c}&sort=porno-online"
                        },
                        new MenuItem()
                        {
                            title = "–ü–æ–ø—É–ª—è—Ä–Ω–æ–µ",
                            playlist_url = url + $"?c={c}&sort=xxx-top"
                        }
                    }
                }
            };


            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–í—Å–µ",
                        playlist_url = url + $"?sort={sort}"
                    },
                    new MenuItem()
                    {
                        title = "CFNM",
                        playlist_url = url + $"?sort={sort}&c=cfnm"
                    },
                    new MenuItem()
                    {
                        title = "pov",
                        playlist_url = url + $"?sort={sort}&c=pov"
                    },
                    new MenuItem()
                    {
                        title = "–ê–Ω–∞–ª",
                        playlist_url = url + $"?sort={sort}&c=anal-videos"
                    },
                    new MenuItem()
                    {
                        title = "–ê–Ω–∞–ª—å–Ω–∞—è –¥—ã—Ä–∞",
                        playlist_url = url + $"?sort={sort}&c=gape"
                    },
                    new MenuItem()
                    {
                        title = "–ê–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–±–∫–∞",
                        playlist_url = url + $"?sort={sort}&c=butt-plug-porn"
                    },
                    new MenuItem()
                    {
                        title = "–ë–î–°–ú",
                        playlist_url = url + $"?sort={sort}&c=bdsm-porn"
                    },
                    new MenuItem()
                    {
                        title = "–ë–ª–æ–Ω–¥–∏–Ω–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=blonde"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ –∂–æ–ø—ã",
                        playlist_url = url + $"?sort={sort}&c=big-ass"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ —Å–∏—Å—å–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=big-tits"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ —á–ª–µ–Ω—ã",
                        playlist_url = url + $"?sort={sort}&c=big-cock"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–æ–π —á—ë—Ä–Ω—ã–π —á–ª–µ–Ω",
                        playlist_url = url + $"?sort={sort}&c=bbc"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–Ω–¥–∞–∂",
                        playlist_url = url + $"?sort={sort}&c=bondage"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ—Å—Å",
                        playlist_url = url + $"?sort={sort}&c=boss"
                    },
                    new MenuItem()
                    {
                        title = "–ë—Ä–∏—Ç—ã–µ –ø–∏—Å—å–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=shaved-pussy"
                    },
                    new MenuItem()
                    {
                        title = "–ë—Ä—é–Ω–µ—Ç–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=a1-brunette"
                    },
                    new MenuItem()
                    {
                        title = "–ë—É–∫–∫–∞–∫–µ",
                        playlist_url = url + $"?sort={sort}&c=bukkake"
                    },
                    new MenuItem()
                    {
                        title = "–í –≥–æ–ª—å—Ñ–∞—Ö",
                        playlist_url = url + $"?sort={sort}&c=knee-socks"
                    },
                    new MenuItem()
                    {
                        title = "–í –∫–ª—É–±–µ",
                        playlist_url = url + $"?sort={sort}&c=club"
                    },
                    new MenuItem()
                    {
                        title = "–í –∫—Ä–∞—Å–∏–≤–æ–º –±–µ–ª—å–µ",
                        playlist_url = url + $"?sort={sort}&c=lingerie"
                    },
                    new MenuItem()
                    {
                        title = "–í –º–∞–π–∫–µ",
                        playlist_url = url + $"?sort={sort}&c=shirt"
                    },
                    new MenuItem()
                    {
                        title = "–í –º–∞—Å–ª–µ",
                        playlist_url = url + $"?sort={sort}&c=oiled"
                    },
                    new MenuItem()
                    {
                        title = "–í –º–∞—à–∏–Ω–µ",
                        playlist_url = url + $"?sort={sort}&c=car-porn"
                    },
                    new MenuItem()
                    {
                        title = "–í –æ—á–∫–∞—Ö",
                        playlist_url = url + $"?sort={sort}&c=glasses"
                    },
                    new MenuItem()
                    {
                        title = "–í –ø—Ä–µ–∑–µ—Ä–≤–∞—Ç–∏–≤–µ",
                        playlist_url = url + $"?sort={sort}&c=condom"
                    },
                    new MenuItem()
                    {
                        title = "–í —Å–ø–∞–ª—å–Ω–µ",
                        playlist_url = url + $"?sort={sort}&c=bedroom"
                    },
                    new MenuItem()
                    {
                        title = "–í —Å–ø–æ—Ä—Ç–∑–∞–ª–µ",
                        playlist_url = url + $"?sort={sort}&c=gym-porn"
                    },
                    new MenuItem()
                    {
                        title = "–í —á—É–ª–∫–∞—Ö",
                        playlist_url = url + $"?sort={sort}&c=stockings"
                    },
                    new MenuItem()
                    {
                        title = "–í–µ–±–∫–∞–º–µ—Ä–∞",
                        playlist_url = url + $"?sort={sort}&c=webcam"
                    },
                    new MenuItem()
                    {
                        title = "–í–æ–ª–æ—Å–∞—Ç–∞—è –ø–∏–∑–¥–∞",
                        playlist_url = url + $"?sort={sort}&c=hairy"
                    },
                    new MenuItem()
                    {
                        title = "–ì–∏–±–∫–∏–µ",
                        playlist_url = url + $"?sort={sort}&c=flexible"
                    },
                    new MenuItem()
                    {
                        title = "–ì–ª–æ—Ç–∞–µ—Ç —Å–ø–µ—Ä–º—É",
                        playlist_url = url + $"?sort={sort}&c=cum-swallow"
                    },
                    new MenuItem()
                    {
                        title = "–ì–æ—Ä–Ω–∏—á–Ω–∞—è",
                        playlist_url = url + $"?sort={sort}&c=maid"
                    },
                    new MenuItem()
                    {
                        title = "–ì–æ—Å–ø–æ–∂–∞",
                        playlist_url = url + $"?sort={sort}&c=mistress"
                    },
                    new MenuItem()
                    {
                        title = "–ì—Ä—É–ø–ø–æ–≤—É—Ö–∞",
                        playlist_url = url + $"?sort={sort}&c=group-porno"
                    },
                    new MenuItem()
                    {
                        title = "–î–∏–ª–¥–æ",
                        playlist_url = url + $"?sort={sort}&c=dildo"
                    },
                    new MenuItem()
                    {
                        title = "–î–ª–∏–Ω–Ω—ã–µ –≤–æ–ª–æ—Å—ã",
                        playlist_url = url + $"?sort={sort}&c=long-hair"
                    },
                    new MenuItem()
                    {
                        title = "–î–æ–∫—Ç–æ—Ä",
                        playlist_url = url + $"?sort={sort}&c=doctor"
                    },
                    new MenuItem()
                    {
                        title = "–î–æ–º–∞—à–Ω–µ–µ –ø–æ—Ä–Ω–æ",
                        playlist_url = url + $"?sort={sort}&c=amateur"
                    },
                    new MenuItem()
                    {
                        title = "–î—Ä–æ—á–∏—Ç –ø–∞—Ä–Ω—é",
                        playlist_url = url + $"?sort={sort}&c=handjob"
                    },
                    new MenuItem()
                    {
                        title = "–ï–≤—Ä–æ",
                        playlist_url = url + $"?sort={sort}&c=a1-europe"
                    },
                    new MenuItem()
                    {
                        title = "–ñ–µ—Å—Ç—å",
                        playlist_url = url + $"?sort={sort}&c=fun"
                    },
                    new MenuItem()
                    {
                        title = "–ñ–ú–ñ",
                        playlist_url = url + $"?sort={sort}&c=a1-threesome"
                    },
                    new MenuItem()
                    {
                        title = "–ò–∑–º–µ–Ω–∞",
                        playlist_url = url + $"?sort={sort}&c=cheating"
                    },
                    new MenuItem()
                    {
                        title = "–ò–Ω—Ç–∏–º–Ω—ã–µ —Å—Ç—Ä–∏–∂–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=intimate-haircut"
                    },
                    new MenuItem()
                    {
                        title = "–ö–ª—è–ø –≤ —Ä–æ—Ç",
                        playlist_url = url + $"?sort={sort}&c=gag"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ—Ä–æ—Ç–∫–∏–µ –≤–æ–ª–æ—Å—ã",
                        playlist_url = url + $"?sort={sort}&c=short-hair"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ—Å–∏—á–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=braids"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä–∞—Å–∏–≤–∞—è –≥—Ä—É–¥—å",
                        playlist_url = url + $"?sort={sort}&c=nice-tits-porn"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä–∞—Å–∏–≤—ã–µ",
                        playlist_url = url + $"?sort={sort}&c=a1-babe"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä–∞—Å–∏–≤—ã–µ –ø–æ–ø–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=ass"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä–∞—Å–∏–≤—ã–π —Å–µ–∫—Å",
                        playlist_url = url + $"?sort={sort}&c=beautiful"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä—É–ø–Ω—ã–º –ø–ª–∞–Ω–æ–º",
                        playlist_url = url + $"?sort={sort}&c=closeup"
                    },
                    new MenuItem()
                    {
                        title = "–ö—É–∫–æ–ª–¥",
                        playlist_url = url + $"?sort={sort}&c=cuckold"
                    },
                    new MenuItem()
                    {
                        title = "–ö—É–Ω–∏",
                        playlist_url = url + $"?sort={sort}&c=cunni"
                    },
                    new MenuItem()
                    {
                        title = "–õ–µ—Å–±–∏",
                        playlist_url = url + $"?sort={sort}&c=lesbi-porno"
                    },
                    new MenuItem()
                    {
                        title = "–õ–∏–∂–µ—Ç –ø–æ–ø—É",
                        playlist_url = url + $"?sort={sort}&c=ass-licking-porn"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞—Å—Å–∞–∂",
                        playlist_url = url + $"?sort={sort}&c=massage"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞—Å—Ç—É—Ä–±–∞—Ü–∏—è",
                        playlist_url = url + $"?sort={sort}&c=a1-masturbation"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞—á–µ—Ö–∞",
                        playlist_url = url + $"?sort={sort}&c=a1-stepmom"
                    },
                    new MenuItem()
                    {
                        title = "–ú–µ–¥—Å–µ—Å—Ç—Ä–∞",
                        playlist_url = url + $"?sort={sort}&c=nurse"
                    },
                    new MenuItem()
                    {
                        title = "–ú–µ–∂–¥—É —Å–∏—Å–µ–∫",
                        playlist_url = url + $"?sort={sort}&c=tits-fuck"
                    },
                    new MenuItem()
                    {
                        title = "–ú–µ–∂—Ä–∞—Å—Å–æ–≤–æ–µ",
                        playlist_url = url + $"?sort={sort}&c=interracial"
                    },
                    new MenuItem()
                    {
                        title = "–ú–ñ–ú",
                        playlist_url = url + $"?sort={sort}&c=2man-woman"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∏–Ω–µ—Ç",
                        playlist_url = url + $"?sort={sort}&c=blowjob"
                    },
                    new MenuItem()
                    {
                        title = "–ú–æ–ª–æ–¥—ã–µ",
                        playlist_url = url + $"?sort={sort}&c=teen"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞ –∫–∞–±–ª—É–∫–∞—Ö",
                        playlist_url = url + $"?sort={sort}&c=heels"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞ –ø–ª—è–∂–µ",
                        playlist_url = url + $"?sort={sort}&c=beach"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞ –ø—Ä–∏—Ä–æ–¥–µ",
                        playlist_url = url + $"?sort={sort}&c=outdoor-sex"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞ –ø—É–±–ª–∏–∫–µ",
                        playlist_url = url + $"?sort={sort}&c=a1-public"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞ —Å—Ç–æ–ª–µ",
                        playlist_url = url + $"?sort={sort}&c=table"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞–µ–∑–¥–Ω–∏—Ü–∞",
                        playlist_url = url + $"?sort={sort}&c=cowgirl"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞—Ä—É—á–Ω–∏–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=handcuffs"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞—Ç—É—Ä–∞–ª—å–Ω—ã–µ —Å–∏—Å—å–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=a1-natural-tits"
                    },
                    new MenuItem()
                    {
                        title = "–ù–µ–≥—Ä–∏—Ç—è–Ω–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=black-girl"
                    },
                    new MenuItem()
                    {
                        title = "–ù–µ–≥—Ä—ã",
                        playlist_url = url + $"?sort={sort}&c=black"
                    },
                    new MenuItem()
                    {
                        title = "–ù–µ–≥—Ä—ã —Å –±–ª–æ–Ω–¥–∏–Ω–∫–∞–º–∏",
                        playlist_url = url + $"?sort={sort}&c=blacks-on-blondes"
                    },
                    new MenuItem()
                    {
                        title = "–ù–µ–∫—Ä–∞—Å–∏–≤–∞—è –≥—Ä—É–¥—å",
                        playlist_url = url + $"?sort={sort}&c=ugly-tits"
                    },
                    new MenuItem()
                    {
                        title = "–ù—è–Ω—è",
                        playlist_url = url + $"?sort={sort}&c=babysitter"
                    },
                    new MenuItem()
                    {
                        title = "–ü–∏—Å–∞–µ—Ç",
                        playlist_url = url + $"?sort={sort}&c=pissing"
                    },
                    new MenuItem()
                    {
                        title = "–ü–ª—ë—Ç–∫–∞",
                        playlist_url = url + $"?sort={sort}&c=whip"
                    },
                    new MenuItem()
                    {
                        title = "–ü–æ–¥ –≤–æ–¥–æ–π",
                        playlist_url = url + $"?sort={sort}&c=underwater"
                    },
                    new MenuItem()
                    {
                        title = "–ü–æ–¥—á–∏–Ω–µ–Ω–∏–µ",
                        playlist_url = url + $"?sort={sort}&c=submission"
                    },
                    new MenuItem()
                    {
                        title = "–ü–æ–∑–∞ 69",
                        playlist_url = url + $"?sort={sort}&c=69"
                    },
                    new MenuItem()
                    {
                        title = "–ü–æ—Ä–Ω–æ –∑—Ä–µ–ª—ã—Ö",
                        playlist_url = url + $"?sort={sort}&c=milfs"
                    },
                    new MenuItem()
                    {
                        title = "–†–µ—Å–ª–∏–Ω–≥",
                        playlist_url = url + $"?sort={sort}&c=wrestling"
                    },
                    new MenuItem()
                    {
                        title = "–†—É—Å—Å–∫–æ–µ –¥–æ–º–∞—à–Ω–µ–µ –ø–æ—Ä–Ω–æ",
                        playlist_url = url + $"?sort={sort}&c=russian-amateur"
                    },
                    new MenuItem()
                    {
                        title = "–†—É—Å—Å–∫–æ–µ –ø–æ—Ä–Ω–æ",
                        playlist_url = url + $"?sort={sort}&c=ruporn"
                    },
                    new MenuItem()
                    {
                        title = "–†—ã–∂–∏–µ",
                        playlist_url = url + $"?sort={sort}&c=redhead"
                    },
                    new MenuItem()
                    {
                        title = "–° –ª–∞—Ç–∏–Ω–∫–∞–º–∏",
                        playlist_url = url + $"?sort={sort}&c=latina-sex"
                    },
                    new MenuItem()
                    {
                        title = "–° –Ω–µ–≤–µ—Å—Ç–æ–π",
                        playlist_url = url + $"?sort={sort}&c=bride"
                    },
                    new MenuItem()
                    {
                        title = "–° —Ç—Ä–µ–Ω–µ—Ä–æ–º",
                        playlist_url = url + $"?sort={sort}&c=couch-porn"
                    },
                    new MenuItem()
                    {
                        title = "–°–≤–∏–Ω–≥–µ—Ä—ã",
                        playlist_url = url + $"?sort={sort}&c=swingers"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Ä–µ—Ç–∞—Ä—à–∞",
                        playlist_url = url + $"?sort={sort}&c=secretary-porn"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å –≤ –æ–±—â–∞–≥–µ",
                        playlist_url = url + $"?sort={sort}&c=dorm-porn"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å –≤ –æ—Ñ–∏—Å–µ",
                        playlist_url = url + $"?sort={sort}&c=office-sex"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å –Ω–∞ –∫—É—Ö–Ω–µ",
                        playlist_url = url + $"?sort={sort}&c=kitchen"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å —Å –±—ã–≤—à–µ–π",
                        playlist_url = url + $"?sort={sort}&c=exgfs"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å-–∏–≥—Ä—É—à–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=sex-toys"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å-–º–∞—à–∏–Ω–∞",
                        playlist_url = url + $"?sort={sort}&c=sex-machines"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å-—Ä–∞–±—ã–Ω—è",
                        playlist_url = url + $"?sort={sort}&c=slave"
                    },
                    new MenuItem()
                    {
                        title = "–°–∏–ª–∏–∫–æ–Ω–æ–≤—ã–µ —Å–∏—Å—å–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=silicone-tits"
                    },
                    new MenuItem()
                    {
                        title = "–°–∫–≤–∏—Ä—Ç",
                        playlist_url = url + $"?sort={sort}&c=squirting"
                    },
                    new MenuItem()
                    {
                        title = "–°–æ–ª–æ",
                        playlist_url = url + $"?sort={sort}&c=a1-solo"
                    },
                    new MenuItem()
                    {
                        title = "–°–ø–µ—Ä–º–∞ –≤—ã—Ç–µ–∫–∞–µ—Ç",
                        playlist_url = url + $"?sort={sort}&c=creampie"
                    },
                    new MenuItem()
                    {
                        title = "–°–ø–µ—Ä–º–∞ –Ω–∞ –≥—Ä—É–¥–∏",
                        playlist_url = url + $"?sort={sort}&c=cum-on-tits"
                    },
                    new MenuItem()
                    {
                        title = "–°–ø–µ—Ä–º–∞ –Ω–∞ –ª–∏—Ü–µ",
                        playlist_url = url + $"?sort={sort}&c=facial"
                    },
                    new MenuItem()
                    {
                        title = "–°–ø–µ—Ä–º–∞ –Ω–∞ –Ω–æ–≥–∞—Ö",
                        playlist_url = url + $"?sort={sort}&c=sperma-na-nogah"
                    },
                    new MenuItem()
                    {
                        title = "–°–ø–µ—Ä–º–∞ –Ω–∞ –ø–∏–∑–¥–µ",
                        playlist_url = url + $"?sort={sort}&c=cum-on-pussy"
                    },
                    new MenuItem()
                    {
                        title = "–°–ø–µ—Ä–º–∞ –Ω–∞ –ø–æ–ø–µ",
                        playlist_url = url + $"?sort={sort}&c=cum-on-ass"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç–∞—Ä—ã–µ —Å –º–æ–ª–æ–¥—ã–º–∏",
                        playlist_url = url + $"?sort={sort}&c=old-and-young"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç—Ä–∞–ø–æ–Ω",
                        playlist_url = url + $"?sort={sort}&c=strapon"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç—Ä–∏–ø—Ç–∏–∑",
                        playlist_url = url + $"?sort={sort}&c=strip"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç—É–¥–µ–Ω—Ç–∫–∞",
                        playlist_url = url + $"?sort={sort}&c=schoolgirls"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç—É–¥–µ–Ω—Ç—ã",
                        playlist_url = url + $"?sort={sort}&c=students"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç—é–∞—Ä–¥–µ—Å—Å–∞",
                        playlist_url = url + $"?sort={sort}&c=styuardessa"
                    },
                    new MenuItem()
                    {
                        title = "–¢—Ä–∞—Ö",
                        playlist_url = url + $"?sort={sort}&c=trah"
                    },
                    new MenuItem()
                    {
                        title = "–£—á–∏—Ç —Ç—Ä–∞—Ö–∞—Ç—å—Å—è",
                        playlist_url = url + $"?sort={sort}&c=teaching"
                    },
                    new MenuItem()
                    {
                        title = "–£—á–∏—Ç–µ–ª—å",
                        playlist_url = url + $"?sort={sort}&c=teacher"
                    },
                    new MenuItem()
                    {
                        title = "–£—á–∏—Ç–µ–ª—å–Ω–∏—Ü–∞",
                        playlist_url = url + $"?sort={sort}&c=teacher-milf"
                    },
                    new MenuItem()
                    {
                        title = "–§—É—Ç—Ñ–µ—Ç–∏—à",
                        playlist_url = url + $"?sort={sort}&c=foot-fetish"
                    },
                    new MenuItem()
                    {
                        title = "–•—É–¥—ã–µ",
                        playlist_url = url + $"?sort={sort}&c=skinny-porn"
                    },
                    new MenuItem()
                    {
                        title = "–ß–µ—à—Å–∫–æ–µ –ø–æ—Ä–Ω–æ",
                        playlist_url = url + $"?sort={sort}&c=czech-porn"
                    },
                    new MenuItem()
                    {
                        title = "–ß–ª–µ–Ω –∏–∑ –¥—ã—Ä–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=gloryhole-porn"
                    },
                    new MenuItem()
                    {
                        title = "–≠—Ä–æ—Ç–∏–∫–∞",
                        playlist_url = url + $"?sort={sort}&c=erotic"
                    }
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }

            return menu;
        }

        async public static ValueTask<StreamItem> StreamLinks(string uri, string host, string url, Func<string, ValueTask<string>> onresult, Func<string, ValueTask<string>> onlocation = null)
        {
            if (string.IsNullOrEmpty(url))
                return null;

            string html = await onresult.Invoke($"{host}/{url}");
            if (html == null)
                return null;

            string stream_link = null;

            foreach (string q in new string[] { "video_alt_url", "video_url" })
            {
                stream_link = Regex.Match(html, $"{q}:([\t ]+)?('|\")(?<link>[^\"']+)").Groups["link"].Value;
                if (!string.IsNullOrEmpty(stream_link))
                    break;
            }

            if (string.IsNullOrEmpty(stream_link))
                return null;

            if (onlocation != null)
            {
                string location = await onlocation.Invoke(stream_link);
                if (location == null || stream_link == location || location.Contains("_file/"))
                    return null;

                stream_link = location;
            }

            return new StreamItem()
            {
                qualitys = new Dictionary<string, string>()
                {
                    ["auto"] = stream_link
                },
                recomends = Playlist(uri, html)
            };
        }
    }
}

```

## File: Shared/Engine/SISI/PornHubTo.cs
```
Ôªøusing HtmlAgilityPack;
using Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class PornHubTo
    {
        public static ValueTask<string> InvokeHtml(string host, string plugin, string search, string model, string sort, int c, string hd, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = $"{host}/";

            if (!string.IsNullOrEmpty(search))
            {
                url += $"video/search?search={HttpUtility.UrlEncode(search)}";

                if (!string.IsNullOrEmpty(sort))
                    url += $"&o={sort}";
            }
            else if (!string.IsNullOrEmpty(model))
            {
                if (model.StartsWith("pornstar/"))
                    url += $"{model}/videos/upload";
                else
                    url += $"model/{model}/videos";
            }
            else
            {
                switch (plugin ?? "")
                {
                    case "phubgay":
                        url += "gay/video";
                        break;
                    case "phubsml":
                        url += "transgender";
                        break;
                    default:
                        url += "video";
                        break;
                }

                if (!string.IsNullOrEmpty(sort))
                    url += $"?o={sort}";

                if (!string.IsNullOrEmpty(hd))
                    url += (url.Contains("?") ? "&" : "?") + $"hd={hd}";

                if (c > 0)
                    url += (url.Contains("?") ? "&" : "?") + $"c={c}";
            }

            if (pg > 1)
                url += $"{(url.Contains("?") ? "&" : "?")}page={pg}";

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string video_uri, string list_uri, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null, bool related = false, bool prem = false, bool IsModel_page = false)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            string videoCategory = null;

            var doc = new HtmlDocument();
            doc.LoadHtml(html);
            var node = doc.DocumentNode;

            if (related)
            {
                videoCategory = node.SelectSingleNode("//*[@id='relatedVideosListing' or @id='relatedVideos']")?.InnerHtml;
            }
            else if (html.Contains("id=\"videoCategory\""))
            {
                videoCategory = node.SelectSingleNode("//*[@id='videoCategory']")?.InnerHtml;
            }
            else if (html.Contains("videoList clearfix browseVideo-tabSplit"))
            {
                var ids = html.Split("videoList clearfix browseVideo-tabSplit");
                if (ids.Length > 1)
                    videoCategory = ids[1].Split("<h2>Languages</h2>")[0].Split("pageHeader")[0];
            }
            else
            {
                videoCategory = node.SelectSingleNode("//*[@id='videoSearchResult' or @id='mostRecentVideosSection' or @id='moreData' or @id='content-tv-container' or @id='lazyVids']")?.InnerHtml;
            }

            if (videoCategory == null)
                return new List<PlaylistItem>();

            ModelItem model = null;
            if (IsModel_page) 
            {
                string name = Regex.Match(html, "itemprop=\"name\">([\r\n\t ]+)?([^<]+)</h1>").Groups[2].Value.Trim();
                string href = Regex.Match(html, "rel=\"canonical\" href=\"(https?://[^/]+)?/model/([^/]+)/").Groups[2].Value;

                if (!string.IsNullOrEmpty(name) && !string.IsNullOrEmpty(href))
                {
                    model = new ModelItem()
                    {
                        name = name,
                        uri = list_uri + (list_uri.Contains("?") ? "&" : "?") + $"model={href}",
                    };
                }
            }

            string splitkey = videoCategory.Contains("pcVideoListItem ") ? "pcVideoListItem " : videoCategory.Contains("data-video-segment") ? "data-video-segment" : videoCategory.Contains("<li data-id=") ? "<li data-id=" : "<li id=";

            var rows = videoCategory.Split(splitkey);
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                if (row.Contains("brand__badge") || row.Contains("private-vid-title"))
                    continue;

                string m(string pattern, int index = 1)
                {
                    string res = Regex.Match(row, pattern).Groups[index].Value;
                    if (string.IsNullOrWhiteSpace(res))
                        return null;

                    return res;
                }

                string vkey = m("(-|_)vkey=\"([^\"]+)\"", 2) ?? m("viewkey=([^\"]+)\"");
                if (vkey == null)
                    continue;

                string title = m("href=\"/[^\"]+\" title=\"([^\"]+)\"") ?? m("class=\"videoTitle\">([^<]+)<") ?? m("href=\"/view_[^\"]+\" onclick=[^>]+>([^<]+)<");
                if (title == null)
                    continue;

                string img = m("data-mediumthumb=\"(https?://[^\"]+)\"") ?? m("data-path=\"(https?://[^\"]+)\"")?.Replace("{index}", "3") ?? m("<img src=\"([^\"]+)\"");
                if (img == null)
                    continue;

                if (!IsModel_page)
                {
                    model = null;
                    var gmodel = Regex.Match(row, "href=\"/model/([^\"]+)\"[^>]+>([^<]+)<");
                    if (string.IsNullOrEmpty(gmodel.Groups[1].Value))
                        gmodel = Regex.Match(row, "href=\"/(pornstar/[^\"]+)\"[^>]+>([^<]+)<");

                    if (!string.IsNullOrEmpty(gmodel.Groups[1].Value))
                    {
                        model = new ModelItem()
                        {
                            name = gmodel.Groups[2].Value,
                            uri = list_uri + (list_uri.Contains("?") ? "&" : "?") + $"model={gmodel.Groups[1].Value}",
                        };
                    }
                }

                var pl = new PlaylistItem()
                {
                    name = title,
                    video = $"{video_uri}?vkey={vkey}",
                    model = model,
                    picture = img,
                    preview = m("data-mediabook=\"(https?://[^\"]+)\"") ?? m("data-webm=\"(https?://[^\"]+)\""),
                    time = m("<var class=\"duration\">([^<]+)</var>") ?? m("class=\"time\">([^<]+)<") ?? m("class=\"videoDuration floatLeft\">([^<]+)<") ?? m("time\">([^<]+)<"),
                    json = true,
                    related = true,
                    bookmark = new Bookmark()
                    {
                        site = prem ? "phubprem" : "phub",
                        href = vkey,
                        image = img
                    }
                };

                if (onplaylist != null)
                    pl = onplaylist.Invoke(pl);

                playlists.Add(pl);
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string plugin, string search, string sort, int c, string hd = null)
        {
            #region getSortName
            string getSortName(string sort, string emptyName)
            {
                if (string.IsNullOrWhiteSpace(sort))
                    return emptyName;

                switch (sort)
                {
                    case "mr":
                    case "cm":
                        return "–Ω–æ–≤–µ–π—à–µ–µ";

                    case "ht":
                        return "—Å–∞–º—ã–µ –≥–æ—Ä—è—á–∏–µ";

                    case "vi":
                    case "mv":
                        return "–±–æ–ª—å—à–µ –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤";

                    case "ra":
                    case "tr":
                        return "–ª—É—á—à–∏–µ";

                    default:
                        return emptyName;
                }
            }
            #endregion

            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";
            string url = host + plugin;

            if (!string.IsNullOrEmpty(search))
            {
                string encodesearch = HttpUtility.UrlEncode(search);

                return new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–ü–æ–∏—Å–∫",
                        search_on = "search_on",
                        playlist_url = url,
                    },
                    new MenuItem()
                    {
                        title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {getSortName(sort, "–ù–∞–∏–±–æ–ª–µ–µ –∞–∫—Ç—É–∞–ª—å–Ω–æ–µ")}",
                        playlist_url = "submenu",
                        submenu = new List<MenuItem>()
                        {
                            new MenuItem()
                            {
                                title = "–ù–∞–∏–±–æ–ª–µ–µ –∞–∫—Ç—É–∞–ª—å–Ω–æ–µ",
                                playlist_url = url + $"?search={encodesearch}"
                            },
                            new MenuItem()
                            {
                                title = "–ù–æ–≤–µ–π—à–µ–µ",
                                playlist_url = url + $"?search={encodesearch}&sort=mr"
                            },
                            new MenuItem()
                            {
                                title = "–õ—É—á—à–∏–µ",
                                playlist_url = url + $"?search={encodesearch}&sort=tr"
                            },
                            new MenuItem()
                            {
                                title = "–ë–æ–ª—å—à–µ –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤",
                                playlist_url = url + $"?search={encodesearch}&sort=mv"
                            }
                        }
                    }
                };
            }

            var menu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = url,
                },
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {getSortName(sort, "–ù–µ–¥–∞–≤–Ω–æ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–º")}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–µ–¥–∞–≤–Ω–æ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–º",
                            playlist_url = url + $"?hd={hd}&c={c}"
                        },
                        new MenuItem()
                        {
                            title = "–ù–æ–≤–µ–π—à–µ–µ",
                            playlist_url = url + $"?hd={hd}&c={c}&sort=cm"
                        },
                        new MenuItem()
                        {
                            title = "–°–∞–º—ã–µ –≥–æ—Ä—è—á–∏–µ",
                            playlist_url = url + $"?hd={hd}&c={c}&sort=ht"
                        },
                        new MenuItem()
                        {
                            title = "–õ—É—á—à–∏–µ",
                            playlist_url = url + $"?hd={hd}&c={c}&sort=tr"
                        }
                    }
                }
            };

            if (plugin == "pornhubpremium" || plugin == "phubprem")
            {
                menu.Insert(1, new MenuItem()
                {
                    title = $"–ö–∞—á–µ—Å—Ç–≤–æ: {(hd == "2" ? "1080p" : hd == "3" ? "1440p" : hd == "4" ? "2160p" : "–≤—Å–µ")}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–í—Å–µ",
                            playlist_url = url + $"?sort={sort}&c={c}"
                        },
                        new MenuItem()
                        {
                            title = "2160p",
                            playlist_url = url + $"?sort={sort}&c={c}&hd=4"
                        },
                        new MenuItem()
                        {
                            title = "1440p",
                            playlist_url = url + $"?sort={sort}&c={c}&hd=3"
                        },
                        new MenuItem()
                        {
                            title = "1080p",
                            playlist_url = url + $"?sort={sort}&c={c}&hd=2"
                        }
                    }
                });
            }
            else
            {
                menu.Add(new MenuItem()
                {
                    title = $"–û—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è: {(plugin == "phubgay" ? "–ì–µ–∏" : plugin == "phubsml" ? "–¢—Ä–∞–Ω—Å—ã" : "–ì–µ—Ç–µ—Ä–æ")}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ì–µ—Ç–µ—Ä–æ",
                            playlist_url = host + "phub",
                        },
                        new MenuItem()
                        {
                            title = "–ì–µ–∏",
                            playlist_url = host + "phubgay",
                        },
                        new MenuItem()
                        {
                            title = "–¢—Ä–∞–Ω—Å—ã",
                            playlist_url = host + "phubsml",
                        }
                    }
                });
            }

            if (plugin == "phubgay")
            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–í—Å–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}"
                    },
                    new MenuItem()
                    {
                        title = "–ê–∑–∏–∞—Ç—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=48"
                    },
                    new MenuItem()
                    {
                        title = "–ë–µ–∑ –ø—Ä–µ–∑–µ—Ä–≤–∞—Ç–∏–≤–∞",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=40"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ —á–ª–µ–Ω—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=58"
                    },
                    new MenuItem()
                    {
                        title = "–í–µ–±-–∫–∞–º–µ—Ä–∞",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=342"
                    },
                    new MenuItem()
                    {
                        title = "–ì–æ–Ω–∑–æ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=372"
                    },
                    new MenuItem()
                    {
                        title = "–ì—Ä—É–±—ã–π —Å–µ–∫—Å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=312"
                    },
                    new MenuItem()
                    {
                        title = "–î—Ä–æ—á–∏—Ç",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=262"
                    },
                    new MenuItem()
                    {
                        title = "–ñ–µ—Ä–µ–±—Ü—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=70"
                    },
                    new MenuItem()
                    {
                        title = "–ó—Ä–µ–ª—ã–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=332"
                    },
                    new MenuItem()
                    {
                        title = "–ö–∞—Å—Ç–∏–Ω–≥–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=362"
                    },
                    new MenuItem()
                    {
                        title = "–ö–∞—á–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=322"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ–ª–ª–µ–¥–∂",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=68"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ–Ω—á–∞—é—Ç",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=352"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä–µ–º–ø–∞–π",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=71"
                    },
                    new MenuItem()
                    {
                        title = "–õ–∞—Ç–∏–Ω–æ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=50"
                    },
                    new MenuItem()
                    {
                        title = "–õ—é–±–∏—Ç–µ–ª—å—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=252"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞—Å—Å–∞–∂",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=45"
                    },
                    new MenuItem()
                    {
                        title = "–ú–µ–¥–≤–µ–¥—å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=66"
                    },
                    new MenuItem()
                    {
                        title = "–ú–µ–∂—Ä–∞—Å—Å–æ–≤—ã–π –°–µ–∫—Å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=64"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∏–Ω–µ—Ç",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=56"
                    },
                    new MenuItem()
                    {
                        title = "–ú–æ–ª–æ–¥–µ–Ω—å–∫–∏–µ –≥–µ–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=49"
                    },
                    new MenuItem()
                    {
                        title = "–ú—É–ª—å—Ç–∏–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=422"
                    },
                    new MenuItem()
                    {
                        title = "–ú—É—Å–∫—É–ª–∏—Å—Ç—ã–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=51"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞ –ø—É–±–ª–∏–∫–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=84"
                    },
                    new MenuItem()
                    {
                        title = "–ù–µ –æ–±—Ä–µ–∑–∞–Ω–Ω—ã–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=272"
                    },
                    new MenuItem()
                    {
                        title = "–ù–µ–≥—Ä—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=44"
                    },
                    new MenuItem()
                    {
                        title = "–ù–æ–≥–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=412"
                    },
                    new MenuItem()
                    {
                        title = "–ü–∞–ø–∏–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=47"
                    },
                    new MenuItem()
                    {
                        title = "–ü–∞—Ä–Ω–∏ (—Å–æ–ª–æ)",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=54"
                    },
                    new MenuItem()
                    {
                        title = "–ü—É—Ö–ª–µ–Ω—å–∫–∏–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=392"
                    },
                    new MenuItem()
                    {
                        title = "–†–µ—Ç—Ä–æ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=77"
                    },
                    new MenuItem()
                    {
                        title = "–¢–∞—Ç—É–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ú—É–∂—á–∏–Ω—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=552"
                    },
                    new MenuItem()
                    {
                        title = "–§–µ—Ç–∏—à",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=52"
                    }
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }
            else if (plugin == "phub" || plugin == "phubprem")
            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–í—Å–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}"
                    },
                    new MenuItem()
                    {
                        title = "–ñ–µ–Ω—Å–∫–∏–π –í—ã–±–æ—Ä",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=73"
                    },
                    new MenuItem()
                    {
                        title = "–†—É—Å—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=99"
                    },
                    new MenuItem()
                    {
                        title = "–ù–µ–º–µ—Ü–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=95"
                    },
                    new MenuItem()
                    {
                        title = "60FPS",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=105"
                    },
                    new MenuItem()
                    {
                        title = "–ê–∑–∏–∞—Ç–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=1"
                    },
                    new MenuItem()
                    {
                        title = "–ê–Ω–∞–ª—å–Ω—ã–π —Å–µ–∫—Å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=35"
                    },
                    new MenuItem()
                    {
                        title = "–ê—Ä–∞–±—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=98"
                    },
                    new MenuItem()
                    {
                        title = "–ë–î–°–ú",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=10"
                    },
                    new MenuItem()
                    {
                        title = "–ë–µ–∑–æ–±–∏–¥–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=221"
                    },
                    new MenuItem()
                    {
                        title = "–ë–∏—Å–µ–∫—Å—É–∞–ª—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=76"
                    },
                    new MenuItem()
                    {
                        title = "–ë–ª–æ–Ω–¥–∏–Ω–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=9"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∞—è –≥—Ä—É–¥—å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=8"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ —á–ª–µ–Ω—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=7"
                    },
                    new MenuItem()
                    {
                        title = "–ë—Ä–∞–∑–∏–ª—å—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=102"
                    },
                    new MenuItem()
                    {
                        title = "–ë—Ä–∏—Ç–∞–Ω—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=96"
                    },
                    new MenuItem()
                    {
                        title = "–ë—Ä—ã–∑–≥–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=69"
                    },
                    new MenuItem()
                    {
                        title = "–ë—Ä—é–Ω–µ—Ç–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=11"
                    },
                    new MenuItem()
                    {
                        title = "–ë—É–∫–∫–∞–∫–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=14"
                    },
                    new MenuItem()
                    {
                        title = "–í —à–∫–æ–ª–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=88"
                    },
                    new MenuItem()
                    {
                        title = "–í–µ–±-–∫–∞–º–µ—Ä–∞",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=61"
                    },
                    new MenuItem()
                    {
                        title = "–í–µ—á–µ—Ä–∏–Ω–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=53"
                    },
                    new MenuItem()
                    {
                        title = "–ì–æ–Ω–∑–æ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=41"
                    },
                    new MenuItem()
                    {
                        title = "–ì—Ä—É–±—ã–π —Å–µ–∫—Å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=67"
                    },
                    new MenuItem()
                    {
                        title = "–ì—Ä—É–ø–ø–æ–≤—É—Ö–∞",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=80"
                    },
                    new MenuItem()
                    {
                        title = "–î–≤–æ–π–Ω–æ–µ –ø—Ä–æ–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=72"
                    },
                    new MenuItem()
                    {
                        title = "–î–µ–≤—É—à–∫–∏ (—Å–æ–ª–æ)",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=492"
                    },
                    new MenuItem()
                    {
                        title = "–î—Ä–æ—á–∏—Ç",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=20"
                    },
                    new MenuItem()
                    {
                        title = "–ï–≤—Ä–æ–ø–µ–π—Ü—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=55"
                    },
                    new MenuItem()
                    {
                        title = "–ñ–µ–Ω—Å–∫–∏–π –æ—Ä–≥–∞–∑–º",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=502"
                    },
                    new MenuItem()
                    {
                        title = "–ñ–µ—Å—Ç–∫–∏–π —Å–µ–∫—Å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=21"
                    },
                    new MenuItem()
                    {
                        title = "–ó–∞ –∫–∞–¥—Ä–æ–º",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=141"
                    },
                    new MenuItem()
                    {
                        title = "–ó–≤–µ–∑–¥—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=12"
                    },
                    new MenuItem()
                    {
                        title = "–ó–æ–ª–æ—Ç–æ–π –¥–æ–∂–¥—å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=211"
                    },
                    new MenuItem()
                    {
                        title = "–ó—Ä–µ–ª—ã–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=28"
                    },
                    new MenuItem()
                    {
                        title = "–ò–≥—Ä—É—à–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=23"
                    },
                    new MenuItem()
                    {
                        title = "–ò–Ω–¥–∏–π—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=101"
                    },
                    new MenuItem()
                    {
                        title = "–ò—Ç–∞–ª—å—è–Ω—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=97"
                    },
                    new MenuItem()
                    {
                        title = "–ö–∞—Å—Ç–∏–Ω–≥–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=90"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ–ª–ª–µ–¥–∂",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=79"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ–Ω—á–∞—é—Ç",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=16"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ—Ä–µ–π—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=103"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ—Å–ø–ª–µ–π",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=241"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä–∞—Å–æ—Ç–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=5"
                    },
                    new MenuItem()
                    {
                        title = "–ö—Ä–µ–º–ø–∞–π",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=15"
                    },
                    new MenuItem()
                    {
                        title = "–ö—É–Ω–∏–ª–∏–Ω–≥—É—Å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=131"
                    },
                    new MenuItem()
                    {
                        title = "–ö—É—Ä—è—â–∏–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=91"
                    },
                    new MenuItem()
                    {
                        title = "–õ–∞—Ç–∏–Ω–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=26"
                    },
                    new MenuItem()
                    {
                        title = "–õ—é–±–∏—Ç–µ–ª—å—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=3"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞–ª–µ–Ω—å–∫–∞—è –≥—Ä—É–¥—å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=59"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞–º–æ—á–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=29"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞—Å—Å–∞–∂",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=78"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞—Å—Ç—É—Ä–±–∞—Ü–∏—è",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=22"
                    },
                    new MenuItem()
                    {
                        title = "–ú–µ–∂—Ä–∞—Å—Å–æ–≤—ã–π –°–µ–∫—Å",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=25"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∏–Ω–µ—Ç",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=13"
                    },
                    new MenuItem()
                    {
                        title = "–ú—É–ª–∞—Ç—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=17"
                    },
                    new MenuItem()
                    {
                        title = "–ú—É–ª—å—Ç–∏–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=86"
                    },
                    new MenuItem()
                    {
                        title = "–ú—É—Å–∫—É–ª–∏—Å—Ç—ã–µ –ú—É–∂—á–∏–Ω—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=512"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∞ –ø—É–±–ª–∏–∫–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=24"
                    },
                    new MenuItem()
                    {
                        title = "–ù–æ–≥–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=93"
                    },
                    new MenuItem()
                    {
                        title = "–ù—è–Ω–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=89"
                    },
                    new MenuItem()
                    {
                        title = "–ü–∞—Ä–æ–¥–∏—è",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=201"
                    },
                    new MenuItem()
                    {
                        title = "–ü–µ–Ω—Å–∏–æ–Ω–µ—Ä—ã / –ø–æ–¥—Ä–æ—Å—Ç–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=181"
                    },
                    new MenuItem()
                    {
                        title = "–ü–æ–¥—Ä–æ—Å—Ç–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=37"
                    },
                    new MenuItem()
                    {
                        title = "–ü–æ–ø–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=4"
                    },
                    new MenuItem()
                    {
                        title = "–ü—Ä–∏–∫–æ–ª—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=32"
                    },
                    new MenuItem()
                    {
                        title = "–†–µ—Ç—Ä–æ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=43"
                    },
                    new MenuItem()
                    {
                        title = "–†–æ–≥–æ–Ω–æ—Å—Ü—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=242"
                    },
                    new MenuItem()
                    {
                        title = "–†–æ–ª–µ–≤—ã–µ –ò–≥—Ä—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=81"
                    },
                    new MenuItem()
                    {
                        title = "–†–æ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=522"
                    },
                    new MenuItem()
                    {
                        title = "–†—ã–∂–∏–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=42"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å –≤—Ç—Ä–æ–µ–º",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=65"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–∫—Å-–æ—Ä–≥–∏—è",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=2"
                    },
                    new MenuItem()
                    {
                        title = "–°–µ–º–µ–π–Ω—ã–µ —Ñ–∞–Ω—Ç–∞–∑–∏–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=444"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç—Ä–∞–ø–æ–Ω",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=542"
                    },
                    new MenuItem()
                    {
                        title = "–°—Ç—Ä–∏–ø—Ç–∏–∑",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=33"
                    },
                    new MenuItem()
                    {
                        title = "–¢–∞—Ç—É–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ñ–µ–Ω—â–∏–Ω—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=562"
                    },
                    new MenuItem()
                    {
                        title = "–¢–æ–ª—Å—Ç—É—à–∫–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=6"
                    },
                    new MenuItem()
                    {
                        title = "–¢—Ä–∞–Ω—Å–≤–µ—Å—Ç–∏—Ç—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=83"
                    },
                    new MenuItem()
                    {
                        title = "–£–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–µ–Ω–∏–µ –ø–∞–ª—å—Ü–∞–º–∏",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=592"
                    },
                    new MenuItem()
                    {
                        title = "–§–µ—Ç–∏—à",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=18"
                    },
                    new MenuItem()
                    {
                        title = "–§–∏—Å—Ç–∏–Ω–≥",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=19"
                    },
                    new MenuItem()
                    {
                        title = "–§—Ä–∞–Ω—Ü—É–∑—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=94"
                    },
                    new MenuItem()
                    {
                        title = "–•–µ–Ω—Ç–∞–π",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=36"
                    },
                    new MenuItem()
                    {
                        title = "–ß–µ—à—Å–∫–æ–µ",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=100"
                    },
                    new MenuItem()
                    {
                        title = "–Ø–ø–æ–Ω—Ü—ã",
                        playlist_url = url + $"?hd={hd}&sort={sort}&c=111"
                    }
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }

            return menu;
        }

        async public static ValueTask<StreamItem> StreamLinks(string video_uri, string list_uri, string host, string vkey, Func<string, ValueTask<string>> onresult)
        {
            if (string.IsNullOrEmpty(vkey))
                return null;

            string html = await onresult.Invoke($"{host}/view_video.php?viewkey={vkey}");
            if (html == null)
                return null;

            var qualitys = new Dictionary<string, string>();

            foreach (string q in new string[] { "1080", "720", "480", "240" })
            {
                string video = Regex.Match(html, $"\"videoUrl\":\"([^\"]+)\",\"quality\":\"{q}\"").Groups[1].Value;
                if (!string.IsNullOrEmpty(video))
                    qualitys.TryAdd($"{q}p", video.Replace("\\", "").Replace("///", "//"));
            }

            if (qualitys.Count == 0)
                return null;

            return new StreamItem()
            {
                qualitys = qualitys,
                recomends = Playlist(video_uri, list_uri, html, related: true)
            };
        }


        public static int Pages(in string html)
        { 
            if (string.IsNullOrEmpty(html))
                return 0;

            if (!html.Contains("class=\"page_number\""))
                return 1;

            int maxpage = 0;
            foreach (Match match in new Regex("class=\"page_number\"><a [^>]+>([0-9]+)<").Matches(html))
            {
                if (int.TryParse(match.Groups[1].Value, out int page) && page > maxpage)
                    maxpage = page;
            }

            // –º–æ–¥–µ–ª—å 6, –Ω–∞–≤–∏–≥–∞—Ü–∏—è 5
            if (4 >= maxpage)
                return maxpage;

            return 0;
        }


        #region getDirectLinks
        static string getDirectLinks(in string pageCode)
        {
            var vars = new List<(string name, string param)>();

            string mainParamBody = Regex.Match(pageCode, "var player_mp4_seek = \"[^\"]+\";[\n\r\t ]+(// var[^\n\r]+[\n\r\t ]+)?([^\n\r]+)").Groups[2].Value;
            mainParamBody = Regex.Replace(mainParamBody, "/\\*.*?\\*/", "");
            mainParamBody = mainParamBody.Replace("\" + \"", "");

            foreach (Match currVar in Regex.Matches(mainParamBody, "var ([^=]+)=([^;]+);"))
                vars.Add((currVar.Groups[1].Value, currVar.Groups[2].Value.Replace("\"", "").Replace(" + ", "")));

            string mediapattern = /*mainParamBody.Contains("var media_4=") && mainParamBody.Contains("var media_5=") ? "var media_(4)=(.*?);" : */"var media_([0-9]+)=(.*?);";
            foreach (Match m in Regex.Matches(mainParamBody, mediapattern, RegexOptions.Singleline))
            {
                string link = "";
                foreach (string curr in m.Groups[2].Value.Replace(" ", "").Split('+'))
                {
                    string param = vars.Find(x => x.name == curr).param;
                    if (param == null)
                        continue;

                    link += param;
                }

                if (link.Contains("urlset/master.m3u8"))
                    return link;
            }

            return null;
        }
        #endregion
    }
}

```

## File: Shared/Engine/SISI/BongaCamsTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using System.Text.RegularExpressions;

namespace Shared.Engine.SISI
{
    public static class BongaCamsTo
    {
        public static ValueTask<string> InvokeHtml(string host, string sort, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = host + $"/tools/listing_v3.php?livetab={sort ?? "all"}&offset={(pg > 1 ? ((pg-1) * 72) : 0)}&limit=72";

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(in string html, out int total_pages, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            total_pages = 0;

            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("\"gender\"");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                string baba = Regex.Match(row, "\"username\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(baba))
                    continue;

                string esid = Regex.Match(row, "\"esid\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(esid))
                    continue;

                string img = Regex.Match(row, "\"thumb_image\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(img))
                    continue;

                string title = Regex.Match(row, "\"display_name\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(title))
                    title = baba;

                var pl = new PlaylistItem()
                {
                    name = title,
                    quality = Regex.Match(row, "\"vq\":\"([^\"]+)\"").Groups[1].Value,
                    video = $"https://{esid}.bcvcdn.com/hls/stream_{baba}/public-aac/stream_{baba}/chunks.m3u8",
                    picture = $"https:{img.Replace("\\", "").Replace("{ext}", "jpg")}"
                };

                if (onplaylist != null)
                    pl = onplaylist.Invoke(pl);

                playlists.Add(pl);
            }

            string total_count = Regex.Match(html, "\"total_count\":([0-9]+),").Groups[1].Value;
            if (int.TryParse(total_count, out int total) && total > 0)
            {
                if (72 >= total)
                    total_pages = 1;
                else
                    total_pages = (total / 72) + 1;
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string sort)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";

            return new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrWhiteSpace(sort) ? "–≤—ã–±—Ä–∞—Ç—å" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–æ–≤—ã–µ",
                            playlist_url = host + "bgs?sort=new"
                        },
                        new MenuItem()
                        {
                            title = "–ü–∞—Ä—ã",
                            playlist_url = host + "bgs?sort=couples"
                        },
                        new MenuItem()
                        {
                            title = "–î–µ–≤—É—à–∫–∏",
                            playlist_url = host + "bgs?sort=female"
                        },
                        new MenuItem()
                        {
                            title = "–†—É—Å—Å–∫–∏–µ –º–æ–¥–µ–ª–∏",
                            playlist_url = host + "bgs?sort=female/tags/russian"
                        },
                        new MenuItem()
                        {
                            title = "–ü–∞—Ä–Ω–∏",
                            playlist_url = host + "bgs?sort=male"
                        },
                        new MenuItem()
                        {
                            title = "–¢—Ä–∞–Ω—Å—Å–µ–∫—Å—É–∞–ª—ã",
                            playlist_url = host + "bgs?sort=transsexual"
                        }
                    }
                }
            };
        }
    }
}

```

## File: Shared/Engine/SISI/SpankbangTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class SpankbangTo
    {
        public static ValueTask<string> InvokeHtml(string host, string search, string sort, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = $"{host}/";

            if (!string.IsNullOrWhiteSpace(search))
            {
                url += $"s/{HttpUtility.UrlEncode(search)}/{pg}/";
            }
            else
            {
                url += $"{sort ?? "new_videos"}/{pg}/";

                if (sort == "most_popular")
                    url += "?p=m";
            }

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            if (html.Contains("class=\"main-container\""))
                html = html.Split("class=\"main-container\"")[1];

            var nodes = HtmlParse.Nodes(html, "//div[@data-testid='video-item']");
            var playlists = new List<PlaylistItem>(nodes.Count);

            foreach (var node in nodes)
            {
                var g = Regex.Match(node.row.InnerHtml, "<a href=\"/(?<link>[^\"]+)\" title=\"(?<title>[^\"]+)\"").Groups;
                if (!string.IsNullOrWhiteSpace(g["link"].Value) && !string.IsNullOrWhiteSpace(g["title"].Value))
                {
                    #region image
                    string img = node.Regex("([\n\r\t ]+)src=\"([^\"]+)\"", 2);
                    if (!img.Contains("/w:"))
                        img = node.Regex("data-src=\"([^\"]+)\"");

                    img = Regex.Replace(img, "/w:[0-9]00/", "/w:300/");
                    #endregion

                    string preview = node.Regex("data-preview=\"([^\"]+)\"");
                    if (string.IsNullOrEmpty(preview))
                        preview = node.Regex("<source data-src=\"([^\"]+)\"");

                    var pl = new PlaylistItem()
                    {
                        name = g["title"].Value,
                        video = $"{uri}?uri={g["link"].Value}",
                        quality = node.SelectText(".//*[@data-testid='video-item-resolution']"),
                        picture = img,
                        preview = preview,
                        time = node.SelectText(".//*[@data-testid='video-item-length']"),
                        json = true,
                        related = true,
                        bookmark = new Bookmark()
                        {
                            site = "sbg",
                            href = g["link"].Value,
                            image = img
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string sort)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";

            return new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = host + "sbg",
                },
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrWhiteSpace(sort) ? "–Ω–æ–≤–æ–µ" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–æ–≤–æ–µ",
                            playlist_url = host + "sbg"
                        },
                        new MenuItem()
                        {
                            title = "–¢—Ä–µ–Ω–¥–æ–≤–æ–µ",
                            playlist_url = host + "sbg?sort=trending_videos"
                        },
                        new MenuItem()
                        {
                            title = "–ü–æ–ø—É–ª—è—Ä–Ω–æ–µ",
                            playlist_url = host + "sbg?sort=most_popular"
                        }
                    }
                }
            };
        }

        async public static ValueTask<StreamItem> StreamLinks(string uri, string host, string url, Func<string, ValueTask<string>> onresult)
        {
            if (string.IsNullOrEmpty(url))
                return null;

            string html = await onresult.Invoke($"{host}/{url}");
            if (string.IsNullOrEmpty(html))
                return null;

            var stream_links = new Dictionary<int, string>();

            var match = new Regex("'([0-9]+)(p|k)': ?\\[\'(https?://[^']+)\'").Match(html);
            while (match.Success)
            {
                int q = $"{match.Groups[1].Value}{match.Groups[2].Value}" == "4k" ? 2160 : int.Parse(match.Groups[1].Value);
                stream_links.TryAdd(q, match.Groups[3].Value);
                match = match.NextMatch();
            }

            return new StreamItem()
            {
                qualitys = stream_links.OrderByDescending(i => i.Key).ToDictionary(k => $"{k.Key}p", v => v.Value),
                recomends = Playlist(uri, html)
            };
        }
    }
}

```

## File: Shared/Engine/SISI/ChaturbateTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using System.Text.RegularExpressions;

namespace Shared.Engine.SISI
{
    public static class ChaturbateTo
    {
        public static ValueTask<string> InvokeHtml(string host, string sort, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = host + "/api/ts/roomlist/room-list/?enable_recommendations=false&limit=90";

            if (!string.IsNullOrWhiteSpace(sort))
                url += $"&genders={sort}";

            if (pg > 1)
                url += $"&offset={pg * 90}";

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("display_age");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                if (!row.Contains("\"current_show\":\"public\""))
                    continue;

                string baba = Regex.Match(row, "\"username\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrWhiteSpace(baba))
                    continue;

                string img = Regex.Match(row, "\"img\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(img))
                    continue;

                var pl = new PlaylistItem()
                {
                    name = baba.Trim(),
                    //quality = row.Contains(">HD+</div>") ? "HD+" : row.Contains(">HD</div>") ? "HD" : null,
                    video = $"{uri}?baba={baba}",
                    picture = img.Replace("\\", ""),
                    json = true
                };

                if (onplaylist != null)
                    pl = onplaylist.Invoke(pl);

                playlists.Add(pl);
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string sort)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";

            var sortmenu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–õ—É—á—à–∏–µ",
                    playlist_url = host + "chu"
                },
                new MenuItem()
                {
                    title = "–î–µ–≤—É—à–∫–∏",
                    playlist_url = host + "chu?sort=f"
                },
                new MenuItem()
                {
                    title = "–ü–∞—Ä—ã",
                    playlist_url = host + "chu?sort=c"
                },
                new MenuItem()
                {
                    title = "–ü–∞—Ä–Ω–∏",
                    playlist_url = host + "chu?sort=m"
                },
                new MenuItem()
                {
                    title = "–¢—Ä–∞–Ω—Å—Å–µ–∫—Å—É–∞–ª—ã",
                    playlist_url = host + "chu?sort=t"
                }
            };

            return new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {sortmenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"={sort}")).title ?? "–õ—É—á—à–∏–µ" }",
                    playlist_url = "submenu",
                    submenu = sortmenu
                }
            };
        }

        async public static ValueTask<Dictionary<string, string>> StreamLinks(string host, string baba, Func<string, ValueTask<string>> onresult)
        {
            if (string.IsNullOrWhiteSpace(baba))
                return null;

            string html = await onresult.Invoke($"{host}/{baba}/");
            string hls = new Regex("(https?://[^ ]+/playlist\\.m3u8)").Match(html ?? "").Groups[1].Value;
            if (string.IsNullOrWhiteSpace(hls))
                return null;

            return new Dictionary<string, string>()
            {
                ["auto"] = hls.Replace("\\u002D", "-").Replace("\\", "")
            };
        }
    }
}

```

## File: Shared/Engine/SISI/XnxxTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using Shared.Models.SISI.Xvideos;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class XnxxTo
    {
        public static ValueTask<string> InvokeHtml(string host, string search, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = $"{host}/best/{DateTime.Today.AddMonths(-1):yyyy-MM}/{pg}";
            if (!string.IsNullOrWhiteSpace(search))
                url = $"{host}/search/{HttpUtility.UrlEncode(search)}/{pg}";

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("<div id=\"video_");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                var g = Regex.Match(row, "<a href=\"/(video-[^\"]+)\" title=\"([^\"]+)\"").Groups;
                string quality = Regex.Match(row, "<span class=\"superfluous\"> - </span>([^<]+)</span>").Groups[1].Value;

                if (!string.IsNullOrEmpty(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                {
                    string duration = Regex.Match(row, "</span>([^<]+)<span class=\"video-hd\">").Groups[1].Value.Trim();
                    string img = Regex.Match(row, "data-src=\"([^\"]+)\"").Groups[1].Value.Replace(".THUMBNUM.", ".1.");

                    // https://cdn77-pic.xvideos-cdn.com/videos/thumbs169ll/5a/6d/4f/5a6d4f718214eebf73225ec96b670f62-2/5a6d4f718214eebf73225ec96b670f62.27.jpg
                    // https://cdn77-pic.xvideos-cdn.com/videos/videopreview/5a/6d/4f/5a6d4f718214eebf73225ec96b670f62_169.mp4
                    string preview = Regex.Replace(img, "/thumbs[^/]+/", "/videopreview/");
                    preview = Regex.Replace(preview, "/[^/]+$", "");
                    preview = Regex.Replace(preview, "-[0-9]+$", "");

                    var pl = new PlaylistItem()
                    {
                        name = g[2].Value,
                        video = $"{uri}?uri={g[1].Value}",
                        picture = img,
                        preview = preview + "_169.mp4",
                        time = duration,
                        quality = string.IsNullOrWhiteSpace(quality) ? null : quality,
                        json = true,
                        related = true,
                        bookmark = new Bookmark()
                        {
                            site = "xnx",
                            href = g[1].Value,
                            image = img
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";

            return new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = host + "xnx",
                }
            };
        }

        async public static ValueTask<StreamItem> StreamLinks(string uri, string host, string url, Func<string, ValueTask<string>> onresult, Func<string, ValueTask<string>> onm3u = null)
        {
            if (string.IsNullOrWhiteSpace(url))
                return null;

            string html = await onresult.Invoke($"{host}/{Regex.Replace(url ?? string.Empty, "^([^/]+)/.*", "$1/_")}");
            if (html == null)
                return null;

            string stream_link = new Regex("html5player\\.setVideoHLS\\('([^']+)'\\);").Match(html).Groups[1].Value;
            if (string.IsNullOrWhiteSpace(stream_link))
                return null;

            #region getRelated
            List<PlaylistItem> getRelated()
            {
                var related = new List<PlaylistItem>();

                string json = Regex.Match(html!, "video_related=([^\n\r]+);window").Groups[1].Value;
                if (string.IsNullOrWhiteSpace(json) || !json.StartsWith("[") || !json.EndsWith("]"))
                    return related;

                try
                {
                    foreach (var r in JsonSerializer.Deserialize<List<Related>>(json))
                    {
                        if (string.IsNullOrEmpty(r.tf) || string.IsNullOrEmpty(r.u) || string.IsNullOrEmpty(r.i))
                            continue;

                        related.Add(new PlaylistItem()
                        {
                            name = r.tf,
                            video = $"{uri}?uri={r.u.Remove(0, 1)}",
                            picture = r.i,
                            json = true,
                            related = true,
                            bookmark = new Bookmark()
                            {
                                site = "xnx",
                                href = r.u.Remove(0, 1),
                                image = r.i
                            }
                        });
                    }
                }
                catch { }

                return related;
            }
            #endregion

            string m3u8 = onm3u == null ? null : await onm3u.Invoke(stream_link);
            if (m3u8 == null)
            {
                return new StreamItem()
                {
                    qualitys = new Dictionary<string, string>()
                    {
                        ["auto"] = stream_link
                    },
                    recomends = getRelated()
                };
            }

            var stream_links = new Dictionary<int, string>();
            foreach (Match m in Regex.Matches(m3u8, "(hls-(2160|1440|1080|720|480|360)p[^\n\r\t ]+)"))
            {
                string hls = m.Groups[1].Value;
                if (string.IsNullOrEmpty(hls))
                    continue;

                hls = $"{Regex.Replace(stream_link, "/hls\\.m3u.*", "")}/{hls}".Replace("https:", "http:");
                stream_links.Add(int.Parse(m.Groups[2].Value), hls);
            }

            return new StreamItem()
            {
                qualitys = stream_links.OrderByDescending(i => i.Key).ToDictionary(k => $"{k.Key}p", v => v.Value),
                recomends = getRelated()
            };
        }
    }
}

```

## File: Shared/Engine/SISI/PorntrexTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class PorntrexTo
    {
        public static ValueTask<string> InvokeHtml(string host, string search, string sort, string c, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url = $"{host}/";

            if (!string.IsNullOrWhiteSpace(search))
            {
                url = $"{host}/search/{HttpUtility.UrlEncode(search)}/";

                if (!string.IsNullOrEmpty(sort))
                    url += $"{sort}/";

                url += $"?from_videos={pg}";
            }
            else
            {
                if (!string.IsNullOrEmpty(c))
                {
                    url += $"categories/{c}/";

                    if (sort == "most-popular")
                        url += $"top-rated/";

                    url += $"?from4={pg}";
                }
                else
                {
                    if (string.IsNullOrEmpty(sort))
                    {
                        url += $"latest-updates/{pg}/";
                    }
                    else
                    {
                        url += $"{sort}/weekly/?from4={pg}";
                    }
                }
            }

            return onresult.Invoke(url);
        }

        public static List<PlaylistItem> Playlist(string uri, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null)
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("<div class=\"video-preview-screen");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                if (row.Contains("<span class=\"line-private\">"))
                    continue;

                var g = Regex.Match(row, "<a href=\"https?://[^/]+/(video/[^\"]+)\" title=\"([^\"]+)\"").Groups;

                if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                {
                    string quality = Regex.Match(row, "<span class=\"quality\">([^<]+)</span>").Groups[1].Value;
                    string duration = Regex.Match(row, "<i class=\"fa fa-clock-o\"></i>([^<]+)</div>").Groups[1].Value.Trim();
                    var img = Regex.Match(row, "data-src=\"(https?:)?//(((ptx|statics)\\.cdntrex\\.com/contents/videos_screenshots/[0-9]+/[0-9]+)[^\"]+)").Groups;

                    var pl = new PlaylistItem()
                    {
                        video = $"{uri}?uri={g[1].Value}",
                        name = g[2].Value,
                        picture = $"https://{img[2].Value}",
                        quality = !string.IsNullOrEmpty(quality) ? quality : null,
                        time = duration,
                        json = true,
                        bookmark = new Bookmark()
                        {
                            site = "ptx",
                            href = g[1].Value,
                            image = $"https://{img[2].Value}"
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }

        public static List<MenuItem> Menu(string host, string search, string sort, string c)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";
            string url = host + "ptx";

            if (!string.IsNullOrEmpty(search))
            {
                string encodesearch = HttpUtility.UrlEncode(search);

                return new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–ü–æ–∏—Å–∫",
                        search_on = "search_on",
                        playlist_url = url,
                    },
                    new MenuItem()
                    {
                        title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrEmpty(sort) ? "Most Relevant" : sort)}",
                        playlist_url = "submenu",
                        submenu = new List<MenuItem>()
                        {
                            new MenuItem()
                            {
                                title = "Most Relevant",
                                playlist_url = url + $"?c={c}&search={encodesearch}"
                            },
                            new MenuItem()
                            {
                                title = "–ù–æ–≤–∏–Ω–∫–∏",
                                playlist_url = url + $"?c={c}&sort=latest-updates&search={encodesearch}"
                            },
                            new MenuItem()
                            {
                                title = "–¢–æ–ø –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤",
                                playlist_url = url + $"?c={c}&sort=most-popular&search={encodesearch}"
                            }
                        }
                    }
                };
            }

            var menu = new List<MenuItem>()
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = url,
                },
                new MenuItem()
                {
                    title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(string.IsNullOrEmpty(sort) ? "–Ω–æ–≤–∏–Ω–∫–∏" : sort)}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ù–æ–≤–∏–Ω–∫–∏",
                            playlist_url = url + $"?c={c}"
                        },
                        new MenuItem()
                        {
                            title = "–¢–æ–ø –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤",
                            playlist_url = url + $"?c={c}&sort=most-popular"
                        }
                    }
                }
            };

            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–í—Å–µ",
                        playlist_url = url + $"?sort={sort}"
                    },
                    new MenuItem()
                    {
                        title = "4K UHD",
                        playlist_url = url + $"?sort={sort}&c=4k-porn"
                    },
                    new MenuItem()
                    {
                        title = "Anal",
                        playlist_url = url + $"?sort={sort}&c=anal"
                    },
                    new MenuItem()
                    {
                        title = "Arab",
                        playlist_url = url + $"?sort={sort}&c=arab"
                    },
                    new MenuItem()
                    {
                        title = "Asian",
                        playlist_url = url + $"?sort={sort}&c=asian"
                    },
                    new MenuItem()
                    {
                        title = "Ass licking",
                        playlist_url = url + $"?sort={sort}&c=ass-licking"
                    },
                    new MenuItem()
                    {
                        title = "Ass to mouth (ATM)",
                        playlist_url = url + $"?sort={sort}&c=ass-to-mouth"
                    },
                    new MenuItem()
                    {
                        title = "Babe",
                        playlist_url = url + $"?sort={sort}&c=babe"
                    },
                    new MenuItem()
                    {
                        title = "Babysitter",
                        playlist_url = url + $"?sort={sort}&c=babysitter"
                    },
                    new MenuItem()
                    {
                        title = "BBW",
                        playlist_url = url + $"?sort={sort}&c=bbw"
                    },
                    new MenuItem()
                    {
                        title = "Big Ass",
                        playlist_url = url + $"?sort={sort}&c=big-ass"
                    },
                    new MenuItem()
                    {
                        title = "Big Tits",
                        playlist_url = url + $"?sort={sort}&c=big-tits"
                    },
                    new MenuItem()
                    {
                        title = "Black",
                        playlist_url = url + $"?sort={sort}&c=black"
                    },
                    new MenuItem()
                    {
                        title = "Blonde",
                        playlist_url = url + $"?sort={sort}&c=blonde"
                    },
                    new MenuItem()
                    {
                        title = "Blowjob",
                        playlist_url = url + $"?sort={sort}&c=blowjob"
                    },
                    new MenuItem()
                    {
                        title = "Bondage",
                        playlist_url = url + $"?sort={sort}&c=bondage"
                    },
                    new MenuItem()
                    {
                        title = "Brunette",
                        playlist_url = url + $"?sort={sort}&c=brunette"
                    },
                    new MenuItem()
                    {
                        title = "Bukkake",
                        playlist_url = url + $"?sort={sort}&c=bukkake"
                    },
                    new MenuItem()
                    {
                        title = "Busty",
                        playlist_url = url + $"?sort={sort}&c=busty"
                    },
                    new MenuItem()
                    {
                        title = "Casting",
                        playlist_url = url + $"?sort={sort}&c=casting"
                    },
                    new MenuItem()
                    {
                        title = "Celebrities",
                        playlist_url = url + $"?sort={sort}&c=celebrities"
                    },
                    new MenuItem()
                    {
                        title = "College",
                        playlist_url = url + $"?sort={sort}&c=college"
                    },
                    new MenuItem()
                    {
                        title = "Compilation",
                        playlist_url = url + $"?sort={sort}&c=compilation"
                    },
                    new MenuItem()
                    {
                        title = "Creampie",
                        playlist_url = url + $"?sort={sort}&c=creampie"
                    },
                    new MenuItem()
                    {
                        title = "Cuckold",
                        playlist_url = url + $"?sort={sort}&c=cuckold"
                    },
                    new MenuItem()
                    {
                        title = "Cum-swap",
                        playlist_url = url + $"?sort={sort}&c=cum-swapping"
                    },
                    new MenuItem()
                    {
                        title = "Cumshots",
                        playlist_url = url + $"?sort={sort}&c=cumshots"
                    },
                    new MenuItem()
                    {
                        title = "Czech",
                        playlist_url = url + $"?sort={sort}&c=czech"
                    },
                    new MenuItem()
                    {
                        title = "Czech Massage",
                        playlist_url = url + $"?sort={sort}&c=czech-massage"
                    },
                    new MenuItem()
                    {
                        title = "Deepthroat",
                        playlist_url = url + $"?sort={sort}&c=deepthroat"
                    },
                    new MenuItem()
                    {
                        title = "Doggystyle",
                        playlist_url = url + $"?sort={sort}&c=doggystyle"
                    },
                    new MenuItem()
                    {
                        title = "Double Penetration (DP)",
                        playlist_url = url + $"?sort={sort}&c=double-penetration"
                    },
                    new MenuItem()
                    {
                        title = "Ebony",
                        playlist_url = url + $"?sort={sort}&c=ebony"
                    },
                    new MenuItem()
                    {
                        title = "Fantasy",
                        playlist_url = url + $"?sort={sort}&c=fantasy"
                    },
                    new MenuItem()
                    {
                        title = "Fetish",
                        playlist_url = url + $"?sort={sort}&c=fetish"
                    },
                    new MenuItem()
                    {
                        title = "Fingering",
                        playlist_url = url + $"?sort={sort}&c=fingering"
                    },
                    new MenuItem()
                    {
                        title = "Fisting",
                        playlist_url = url + $"?sort={sort}&c=fisting"
                    },
                    new MenuItem()
                    {
                        title = "Footjob",
                        playlist_url = url + $"?sort={sort}&c=footjob"
                    },
                    new MenuItem()
                    {
                        title = "Foursome",
                        playlist_url = url + $"?sort={sort}&c=foursome"
                    },
                    new MenuItem()
                    {
                        title = "Gangbang",
                        playlist_url = url + $"?sort={sort}&c=gangbang"
                    },
                    new MenuItem()
                    {
                        title = "Gangbang Creampie",
                        playlist_url = url + $"?sort={sort}&c=gangbang-creampie"
                    },
                    new MenuItem()
                    {
                        title = "Gaping",
                        playlist_url = url + $"?sort={sort}&c=gaping"
                    },
                    new MenuItem()
                    {
                        title = "Gay",
                        playlist_url = url + $"?sort={sort}&c=gay"
                    },
                    new MenuItem()
                    {
                        title = "German",
                        playlist_url = url + $"?sort={sort}&c=german"
                    },
                    new MenuItem()
                    {
                        title = "Gloryhole",
                        playlist_url = url + $"?sort={sort}&c=gloryhole"
                    },
                    new MenuItem()
                    {
                        title = "Hairy",
                        playlist_url = url + $"?sort={sort}&c=hairy"
                    },
                    new MenuItem()
                    {
                        title = "Handjob",
                        playlist_url = url + $"?sort={sort}&c=handjob"
                    },
                    new MenuItem()
                    {
                        title = "Hardcore",
                        playlist_url = url + $"?sort={sort}&c=hardcore"
                    },
                    new MenuItem()
                    {
                        title = "Hentai",
                        playlist_url = url + $"?sort={sort}&c=hentai"
                    },
                    new MenuItem()
                    {
                        title = "Homemade",
                        playlist_url = url + $"?sort={sort}&c=homemade"
                    },
                    new MenuItem()
                    {
                        title = "Hungarian",
                        playlist_url = url + $"?sort={sort}&c=hungarian"
                    },
                    new MenuItem()
                    {
                        title = "Indian",
                        playlist_url = url + $"?sort={sort}&c=indian"
                    },
                    new MenuItem()
                    {
                        title = "Interracial",
                        playlist_url = url + $"?sort={sort}&c=interracial"
                    },
                    new MenuItem()
                    {
                        title = "Japanese",
                        playlist_url = url + $"?sort={sort}&c=japanese"
                    },
                    new MenuItem()
                    {
                        title = "Latina",
                        playlist_url = url + $"?sort={sort}&c=latina"
                    },
                    new MenuItem()
                    {
                        title = "Lesbian",
                        playlist_url = url + $"?sort={sort}&c=lesbian"
                    },
                    new MenuItem()
                    {
                        title = "Lingerie",
                        playlist_url = url + $"?sort={sort}&c=lingerie"
                    },
                    new MenuItem()
                    {
                        title = "Massage",
                        playlist_url = url + $"?sort={sort}&c=massage"
                    },
                    new MenuItem()
                    {
                        title = "Masturbation",
                        playlist_url = url + $"?sort={sort}&c=masturbation"
                    },
                    new MenuItem()
                    {
                        title = "Mature",
                        playlist_url = url + $"?sort={sort}&c=mature"
                    },
                    new MenuItem()
                    {
                        title = "Milf",
                        playlist_url = url + $"?sort={sort}&c=milf"
                    },
                    new MenuItem()
                    {
                        title = "Office",
                        playlist_url = url + $"?sort={sort}&c=office"
                    },
                    new MenuItem()
                    {
                        title = "Old and Young",
                        playlist_url = url + $"?sort={sort}&c=old-and-young"
                    },
                    new MenuItem()
                    {
                        title = "Orgy",
                        playlist_url = url + $"?sort={sort}&c=orgy"
                    },
                    new MenuItem()
                    {
                        title = "Outdoor",
                        playlist_url = url + $"?sort={sort}&c=outdoor"
                    },
                    new MenuItem()
                    {
                        title = "Petite",
                        playlist_url = url + $"?sort={sort}&c=petite"
                    },
                    new MenuItem()
                    {
                        title = "POV",
                        playlist_url = url + $"?sort={sort}&c=pov"
                    },
                    new MenuItem()
                    {
                        title = "Public",
                        playlist_url = url + $"?sort={sort}&c=public"
                    },
                    new MenuItem()
                    {
                        title = "Pussy licking",
                        playlist_url = url + $"?sort={sort}&c=pussy-licking"
                    },
                    new MenuItem()
                    {
                        title = "Red Head",
                        playlist_url = url + $"?sort={sort}&c=red-head"
                    },
                    new MenuItem()
                    {
                        title = "Riding",
                        playlist_url = url + $"?sort={sort}&c=riding"
                    },
                    new MenuItem()
                    {
                        title = "Russian",
                        playlist_url = url + $"?sort={sort}&c=russian"
                    },
                    new MenuItem()
                    {
                        title = "School Girl",
                        playlist_url = url + $"?sort={sort}&c=school-girl"
                    },
                    new MenuItem()
                    {
                        title = "Shemale",
                        playlist_url = url + $"?sort={sort}&c=shemale"
                    },
                    new MenuItem()
                    {
                        title = "Skinny",
                        playlist_url = url + $"?sort={sort}&c=skinny"
                    },
                    new MenuItem()
                    {
                        title = "Small tits",
                        playlist_url = url + $"?sort={sort}&c=small-tits"
                    },
                    new MenuItem()
                    {
                        title = "Solo",
                        playlist_url = url + $"?sort={sort}&c=solo"
                    },
                    new MenuItem()
                    {
                        title = "Squirt",
                        playlist_url = url + $"?sort={sort}&c=squirt"
                    },
                    new MenuItem()
                    {
                        title = "Strap-on",
                        playlist_url = url + $"?sort={sort}&c=strap-on"
                    },
                    new MenuItem()
                    {
                        title = "Swallow",
                        playlist_url = url + $"?sort={sort}&c=swallow"
                    },
                    new MenuItem()
                    {
                        title = "Teen",
                        playlist_url = url + $"?sort={sort}&c=teen"
                    },
                    new MenuItem()
                    {
                        title = "Threesome",
                        playlist_url = url + $"?sort={sort}&c=threesome"
                    },
                    new MenuItem()
                    {
                        title = "Titfuck",
                        playlist_url = url + $"?sort={sort}&c=titfuck"
                    },
                    new MenuItem()
                    {
                        title = "Toys",
                        playlist_url = url + $"?sort={sort}&c=toys"
                    },
                    new MenuItem()
                    {
                        title = "Uniform",
                        playlist_url = url + $"?sort={sort}&c=uniform"
                    },
                    new MenuItem()
                    {
                        title = "Vintage",
                        playlist_url = url + $"?sort={sort}&c=vintage"
                    },
                    new MenuItem()
                    {
                        title = "Webcam",
                        playlist_url = url + $"?sort={sort}&c=webcam"
                    },
                    new MenuItem()
                    {
                        title = "Wife",
                        playlist_url = url + $"?sort={sort}&c=wife"
                    }
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"&c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }

            return menu;
        }

        async public static ValueTask<Dictionary<string, string>> StreamLinks(string host, string uri, Func<string, ValueTask<string>> onresult)
        {
            if (string.IsNullOrWhiteSpace(uri))
                return null;

            string html = await onresult.Invoke($"{host}/{uri}");
            if (html == null)
                return null;

            var stream_links = new Dictionary<string, string>();
            var match = new Regex("(https?://[^/]+/get_file/[^\\.]+_([0-9]+p)\\.mp4)").Match(html);
            while (match.Success)
            {
                stream_links.TryAdd(match.Groups[2].Value, match.Groups[1].Value);
                match = match.NextMatch();
                //break;
            }

            if (stream_links.Count == 0)
            {
                string link = Regex.Match(html, "(https?://[^/]+/get_file/[^\\.]+\\.mp4)").Groups[1].Value;
                if (!string.IsNullOrWhiteSpace(link))
                    stream_links.TryAdd("auto", link);
            }

            return stream_links.Reverse().ToDictionary(k => k.Key, v => v.Value);
        }
    }
}

```

## File: Shared/Engine/SISI/XvideosTo.cs
```
Ôªøusing Shared.Models.SISI.Base;
using Shared.Models.SISI.OnResult;
using Shared.Models.SISI.Xvideos;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.SISI
{
    public static class XvideosTo
    {
        public static ValueTask<string> InvokeHtml(string host, string plugin, string search, string sort, string c, int pg, Func<string, ValueTask<string>> onresult)
        {
            string url;

            if (!string.IsNullOrWhiteSpace(search))
            {
                url = $"{host}/?k={HttpUtility.UrlEncode(search)}&p={pg}";
            }
            else
            {
                if (!string.IsNullOrEmpty(c))
                {
                    url = $"{host}/c/s:{(sort == "top"  ? "rating" : "uploaddate")}/{c}/{pg}";
                }
                else
                {
                    if (sort == "top")
                    {
                        url = $"{host}/{(plugin == "xdsgay" ? "best-of-gay" : plugin == "xdssml" ? "best-of-shemale" : "best")}/{DateTime.Today.AddMonths(-1):yyyy-MM}";
                    }
                    else
                    {
                        url = plugin == "xdsgay" ? $"{host}/gay" : plugin == "xdssml" ? $"{host}/shemale" : $"{host}/new";
                    }

                    url += $"/{pg}";
                }
            }

            return onresult.Invoke(url);
        }


        public static List<PlaylistItem> Playlist(string uri, string uri_star, in string html, Func<PlaylistItem, PlaylistItem> onplaylist = null, string site = "xds")
        {
            if (string.IsNullOrEmpty(html))
                return new List<PlaylistItem>();

            var rows = html.Split("<div id=\"video_");
            var playlists = new List<PlaylistItem>(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                // <a href="/video.ucmdacd450a/_" title="–ì–æ—Ä–Ω–∏—á–Ω–∞—è –ø—Ä–∏—Ö–æ–¥–∏—Ç –Ω–∞ —Ä–∞–±–æ—Ç—É –≤ –∫–æ—Ä–æ—Ç–∫–æ–º –ø–ª–∞—Ç—å–µ (–ª–µ—Å–±—É—Ö–∞ –ª—é–±–∏—Ç —á–ª–µ–Ω)">
                var g = Regex.Match(row, "<a href=\"/(video[^\"]+|search-video/[^\"]+)\" title=\"([^\"]+)\"").Groups;
                if (string.IsNullOrEmpty(g[1].Value) || string.IsNullOrEmpty(g[2].Value))
                {
                    // <a href="/video.ohpbioo5118/_." target="_blank">–Ø –¥—É–º–∞–ª, —á—Ç–æ –Ω–µ –ø–µ—Ä–µ–∂–∏–≤—É –µ–≥–æ –Ω–∞–∫–∞–∑–∞–Ω–∏—è.</a>
                    g = Regex.Match(row, "<a href=\"\\/(video[^\"]+)\"[^>]+>([^<]+)").Groups;
                }

                if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                {
                    string qmark = Regex.Match(row, "<span class=\"video-hd-mark\">([^<]+)</span>").Groups[1].Value;
                    string duration = Regex.Match(row, "<span class=\"duration\">([^<]+)</span>").Groups[1].Value.Trim();

                    string img = Regex.Match(row, "data-src=\"([^\"]+)\"").Groups[1].Value;
                    img = Regex.Replace(img, "/videos/thumbs([0-9]+)/", "/videos/thumbs$1lll/");
                    img = Regex.Replace(img, "\\.THUMBNUM\\.(jpg|png)$", ".1.$1", RegexOptions.IgnoreCase);

                    // https://cdn77-pic.xvideos-cdn.com/videos/thumbs169ll/5a/6d/4f/5a6d4f718214eebf73225ec96b670f62-2/5a6d4f718214eebf73225ec96b670f62.27.jpg
                    // https://cdn77-pic.xvideos-cdn.com/videos/videopreview/5a/6d/4f/5a6d4f718214eebf73225ec96b670f62_169.mp4
                    string preview = Regex.Replace(img, "/thumbs[^/]+/", "/videopreview/");
                    preview = Regex.Replace(preview, "/[^/]+$", "");
                    preview = Regex.Replace(preview, "-[0-9]+$", "");

                    img = img.Replace("thumbs169l/", "thumbs169lll/").Replace("thumbs169ll/", "thumbs169lll/");

                    var gm = Regex.Match(row, "href=\"/([^\"]+)\"><span class=\"name\">([^<]+)<").Groups;
                    var model = string.IsNullOrEmpty(gm[1].Value) || string.IsNullOrEmpty(gm[2].Value) ? default : new ModelItem()
                    {
                        name = gm[2].Value,
                        uri = $"{uri_star}?uri=" + (gm[1].Value.Contains("/") ? gm[1].Value : $"channels/{gm[1].Value}"),
                    };

                    var pl = new PlaylistItem()
                    {
                        name = g[2].Value,
                        video = $"{uri}?uri={g[1].Value}",
                        picture = img,
                        preview = preview + "_169.mp4",
                        quality = string.IsNullOrWhiteSpace(qmark) ? null : qmark,
                        time = duration,
                        json = true,
                        related = true,
                        model = model,
                        bookmark = new Bookmark()
                        {
                            site = site,
                            href = g[1].Value,
                            image = img
                        }
                    };

                    if (onplaylist != null)
                        pl = onplaylist.Invoke(pl);

                    playlists.Add(pl);
                }
            }

            return playlists;
        }


        async public static ValueTask<List<PlaylistItem>> Pornstars(string uri_video, string uri_star, string host, string plugin, string uri, string sort, int pg, Func<string, ValueTask<string>> onresult)
        {
            if (string.IsNullOrEmpty(uri))
                return null;

            sort = string.IsNullOrEmpty(sort) ? "new" : sort;
            string url = plugin == "xdsgay" ? $"{host}/{uri}/videos/{sort}/gay" : plugin == "xdssml" ? $"{host}/{uri}/videos/{sort}/shemale" : $"{host}/{uri}/videos/{sort}";

            url += $"/{pg}";

            string json = await onresult.Invoke(url);
            if (json == null || (!json.StartsWith("{") && !json.StartsWith("[")))
                return null;

            try
            {
                var jsonObj = JsonSerializer.Deserialize<JsonObject>(json);
                if (jsonObj == null || !jsonObj.ContainsKey("videos"))
                    return null;

                var videos = jsonObj["videos"]?.Deserialize<List<Related>>();
                if (videos == null)
                    return null;

                var playlists = new List<PlaylistItem>(videos.Count);

                foreach (var r in videos)
                {
                    if (string.IsNullOrEmpty(r.tf) || string.IsNullOrEmpty(r.u) || string.IsNullOrEmpty(r.@if))
                        continue;

                    string preview = Regex.Replace(r.@if, "/thumbs[^/]+/", "/videopreview/");
                    preview = Regex.Replace(preview, "/[^/]+$", "");
                    preview = Regex.Replace(preview, "-[0-9]+$", "");

                    var model = string.IsNullOrEmpty(r.p) || string.IsNullOrEmpty(r.pn) ? default : new ModelItem()
                    {
                        name = r.pn,
                        uri = $"{uri_star}?uri=" + (r.ch ? "channels/" : "pornstars/") + r.p,
                    };

                    playlists.Add(new PlaylistItem()
                    {
                        name = r.tf,
                        video = $"{uri_video}?uri={r.u.Remove(0, 1)}",
                        picture = r.@if,
                        preview = preview + "_169.mp4",
                        time = r.d,
                        json = true,
                        related = true,
                        model = model,
                        bookmark = new Bookmark()
                        {
                            site = "xds",
                            href = r.u.Remove(0, 1),
                            image = r.@if
                        }
                    });
                }

                return playlists;
            }
            catch 
            {
                return null;
            }
        }


        public static List<MenuItem> Menu(string host, string plugin, string sort, string c)
        {
            host = string.IsNullOrWhiteSpace(host) ? string.Empty : $"{host}/";
            string url = host + plugin;

            var menu = new List<MenuItem>(4)
            {
                new MenuItem()
                {
                    title = "–ü–æ–∏—Å–∫",
                    search_on = "search_on",
                    playlist_url = url,
                }
            };

            var menusort = new MenuItem()
            {
                title = $"–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: {(sort == "like" ? "–ü–æ–Ω—Ä–∞–≤–∏–≤—à–∏–µ—Å—è" : sort == "top" ? "–õ—É—á—à–∏–µ" : "–ù–æ–≤–æ–µ")}",
                playlist_url = "submenu",
                submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–ù–æ–≤–æ–µ",
                        playlist_url = url + $"?c={c}"
                    },
                    new MenuItem()
                    {
                        title = "–õ—É—á—à–∏–µ",
                        playlist_url = url + $"?c={c}&sort=top"
                    }
                }
            };

            if (plugin == "xdsred" && string.IsNullOrEmpty(c))
            {
                menusort.submenu.Add(new MenuItem()
                {
                    title = "–ü–æ–Ω—Ä–∞–≤–∏–≤—à–∏–µ—Å—è",
                    playlist_url = url + $"?c={c}&sort=like"
                });
            }

            if (plugin != "xdsred" && sort != "like")
            {
                menu.Add(new MenuItem()
                {
                    title = $"–û—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è: {(plugin == "xdsgay" ? "–ì–µ–∏" : plugin == "xdssml" ? "–¢—Ä–∞–Ω—Å—ã" : "–ì–µ—Ç–µ—Ä–æ")}",
                    playlist_url = "submenu",
                    submenu = new List<MenuItem>()
                    {
                        new MenuItem()
                        {
                            title = "–ì–µ—Ç–µ—Ä–æ",
                            playlist_url = host + "xds",
                        },
                        new MenuItem()
                        {
                            title = "–ì–µ–∏",
                            playlist_url = host + "xdsgay",
                        },
                        new MenuItem()
                        {
                            title = "–¢—Ä–∞–Ω—Å—ã",
                            playlist_url = host + "xdssml",
                        }
                    }
                });
            }

            if (sort != "like" && (plugin == "xds" || plugin == "xdsred"))
            {
                var submenu = new List<MenuItem>()
                {
                    new MenuItem()
                    {
                        title = "–í—Å–µ",
                        playlist_url = url
                    },
                    new MenuItem()
                    {
                        title = "–ê–∑–∏–∞—Ç",
                        playlist_url = url + $"?sort={sort}&c=Asian_Woman-32"
                    },
                    new MenuItem()
                    {
                        title = "–ê–Ω–∞–ª",
                        playlist_url = url + $"?sort={sort}&c=Anal-12"
                    },
                    new MenuItem()
                    {
                        title = "–ê—Ä–∞–±–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Arab-159"
                    },
                    new MenuItem()
                    {
                        title = "–ë–∏—Å–µ–∫—Å—É–∞–ª—ã",
                        playlist_url = url + $"?sort={sort}&c=Bi_Sexual-62"
                    },
                    new MenuItem()
                    {
                        title = "–ë–ª–æ–Ω–¥–∏–Ω–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Blonde-20"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ –ü–æ–ø—ã",
                        playlist_url = url + $"?sort={sort}&c=Big_Ass-24"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ –°–∏—Å—å–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Big_Tits-23"
                    },
                    new MenuItem()
                    {
                        title = "–ë–æ–ª—å—à–∏–µ —è–π—Ü–∞",
                        playlist_url = url + $"?sort={sort}&c=Big_Cock-34"
                    },
                    new MenuItem()
                    {
                        title = "–ë—Ä—é–Ω–µ—Ç–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Brunette-25"
                    },
                    new MenuItem()
                    {
                        title = "–í –º–∞—Å–ª–µ",
                        playlist_url = url + $"?sort={sort}&c=Oiled-22"
                    },
                    new MenuItem()
                    {
                        title = "–í–µ–± –∫–∞–º–µ—Ä—ã",
                        playlist_url = url + $"?sort={sort}&c=Cam_Porn-58"
                    },
                    new MenuItem()
                    {
                        title = "–ì—ç–Ω–≥–±—ç–Ω–≥",
                        playlist_url = url + $"?sort={sort}&c=Gangbang-69"
                    },
                    new MenuItem()
                    {
                        title = "–ó–∏—è—é—â–∏–µ –æ—Ç–≤–µ—Ä—Å—Ç–∏—è",
                        playlist_url = url + $"?sort={sort}&c=Gapes-167"
                    },
                    new MenuItem()
                    {
                        title = "–ó—Ä–µ–ª—ã–µ",
                        playlist_url = url + $"?sort={sort}&c=Mature-38"
                    },
                    new MenuItem()
                    {
                        title = "–ò–Ω–¥–∏–π—Å–∫–∏–π",
                        playlist_url = url + $"?sort={sort}&c=Indian-89"
                    },
                    new MenuItem()
                    {
                        title = "–ò—Å–ø–æ—Ä—á–µ–Ω–Ω–∞—è —Å–µ–º—å—è",
                        playlist_url = url + $"?sort={sort}&c=Fucked_Up_Family-81"
                    },
                    new MenuItem()
                    {
                        title = "–ö–æ–Ω—á–∞–µ—Ç –≤–Ω—É—Ç—Ä—å",
                        playlist_url = url + $"?sort={sort}&c=Creampie-40"
                    },
                    new MenuItem()
                    {
                        title = "–ö—É–∫–æ–ª–¥ / –ì–æ—Ä—è—á–∞—è –ñ–µ–Ω–∞",
                        playlist_url = url + $"?sort={sort}&c=Cuckold-237"
                    },
                    new MenuItem()
                    {
                        title = "–õ–∞—Ç–∏–Ω–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Latina-16"
                    },
                    new MenuItem()
                    {
                        title = "–õ–µ—Å–±–∏—è–Ω–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Lesbian-26"
                    },
                    new MenuItem()
                    {
                        title = "–õ—é–±–∏—Ç–µ–ª—å—Å–∫–æ–µ –ø–æ—Ä–Ω–æ",
                        playlist_url = url + $"?sort={sort}&c=Amateur-65"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∞–º–æ—á–∫–∏. –ú–ò–õ–§",
                        playlist_url = url + $"?sort={sort}&c=Milf-19"
                    },
                    new MenuItem()
                    {
                        title = "–ú–µ–∂—Ä–∞—Å—Å–æ–≤—ã–µ",
                        playlist_url = url + $"?sort={sort}&c=Interracial-27"
                    },
                    new MenuItem()
                    {
                        title = "–ú–∏–Ω–µ—Ç",
                        playlist_url = url + $"?sort={sort}&c=Blowjob-15"
                    },
                    new MenuItem()
                    {
                        title = "–ù–∏–∂–Ω–µ–µ –±–µ–ª—å—ë",
                        playlist_url = url + $"?sort={sort}&c=Lingerie-83"
                    },
                    new MenuItem()
                    {
                        title = "–ü–æ–ø–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Ass-14"
                    },
                    new MenuItem()
                    {
                        title = "–†—ã–∂–∏–µ",
                        playlist_url = url + $"?sort={sort}&c=Redhead-31"
                    },
                    new MenuItem()
                    {
                        title = "–°–∫–≤–∏—Ä—Ç–∏–Ω–≥",
                        playlist_url = url + $"?sort={sort}&c=Squirting-56"
                    },
                    new MenuItem()
                    {
                        title = "–°–æ–ª–æ",
                        playlist_url = url + $"?sort={sort}&c=Solo_and_Masturbation-33"
                    },
                    new MenuItem()
                    {
                        title = "–°–ø–µ—Ä–º–∞",
                        playlist_url = url + $"?sort={sort}&c=Cumshot-18"
                    },
                    new MenuItem()
                    {
                        title = "–¢–∏–Ω–µ–π–¥–∂–µ—Ä—ã",
                        playlist_url = url + $"?sort={sort}&c=Teen-13"
                    },
                    new MenuItem()
                    {
                        title = "–§–µ–º–¥–æ–º",
                        playlist_url = url + $"?sort={sort}&c=Femdom-235"
                    },
                    new MenuItem()
                    {
                        title = "–§–∏—Å—Ç–∏–Ω–≥",
                        playlist_url = url + $"?sort={sort}&c=Fisting-165"
                    },
                    new MenuItem()
                    {
                        title = "–ß–µ—Ä–Ω—ã–µ –ñ–µ–Ω—â–∏–Ω—ã",
                        playlist_url = url + $"?sort={sort}&c=bbw-51"
                    },
                    new MenuItem()
                    {
                        title = "–ß–µ—Ä–Ω—ã–π",
                        playlist_url = url + $"?sort={sort}&c=Black_Woman-30"
                    },
                    new MenuItem()
                    {
                        title = "–ß—É–ª–∫–∏,–∫–æ–ª–≥–æ—Ç–∫–∏",
                        playlist_url = url + $"?sort={sort}&c=Stockings-28"
                    },
                    new MenuItem()
                    {
                        title = "ASMR",
                        playlist_url = url + $"?sort={sort}&c=ASMR-229"
                    }
                };

                menu.Add(new MenuItem()
                {
                    title = $"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {submenu.FirstOrDefault(i => i.playlist_url!.EndsWith($"c={c}")).title ?? "–≤—Å–µ"}",
                    playlist_url = "submenu",
                    submenu = submenu
                });
            }

            menu.Insert(1, menusort);

            return menu;
        }


        async public static ValueTask<StreamItem> StreamLinks(string uri, string uri_star, string host, string url, Func<string, ValueTask<string>> onresult, Func<string, ValueTask<string>> onm3u = null)
        {
            if (string.IsNullOrWhiteSpace(url))
                return null;

            //string? html = await onresult.Invoke($"{host}/{Regex.Replace(url ?? "", "^([^/]+)/.*", "$1/_")}");
            string html = await onresult.Invoke($"{host}/{url}");
            if (html == null)
                return null;

            string stream_link = new Regex("html5player\\.setVideoHLS\\('([^']+)'\\);").Match(html).Groups[1].Value;
            if (string.IsNullOrWhiteSpace(stream_link))
                return null;

            #region getRelated
            List<PlaylistItem> getRelated()
            {
                var related = new List<PlaylistItem>();

                string json = Regex.Match(html!, "video_related=([^\n\r]+);window").Groups[1].Value;
                if (string.IsNullOrWhiteSpace(json) || !json.StartsWith("[") || !json.EndsWith("]"))
                    return related;

                try
                {
                    foreach (var r in JsonSerializer.Deserialize<List<Related>>(json))
                    {
                        if (string.IsNullOrEmpty(r.tf) || string.IsNullOrEmpty(r.u) || string.IsNullOrEmpty(r.@if))
                            continue;

                        string preview = Regex.Replace(r.i, "/thumbs[^/]+/", "/videopreview/");
                        preview = Regex.Replace(preview, "/[^/]+$", "");
                        preview = Regex.Replace(preview, "-[0-9]+$", "");

                        var model = string.IsNullOrEmpty(r.p) || string.IsNullOrEmpty(r.pn) ? default : new ModelItem()
                        {
                            name = r.pn,
                            uri = $"{uri_star}?uri=" + (r.ch ? "channels/" : "pornstars/") + r.p,
                        };

                        related.Add(new PlaylistItem()
                        {
                            name = r.tf,
                            video = $"{uri}?uri={r.u.Remove(0, 1)}",
                            picture = r.@if,
                            preview = preview + "_169.mp4",
                            time = r.d,
                            json = true,
                            related = true,
                            model = model,
                            bookmark = new Bookmark()
                            {
                                site = "xds",
                                href = r.u.Remove(0, 1),
                                image = r.@if
                            }
                        });
                    }
                }
                catch { }

                return related;
            }
            #endregion

            string m3u8 = onm3u == null ? null : await onm3u.Invoke(stream_link);
            if (m3u8 == null)
            {
                return new StreamItem()
                {
                    qualitys = new Dictionary<string, string>()
                    {
                        ["auto"] = stream_link
                    },
                    recomends = getRelated()
                };
            }

            var stream_links = new Dictionary<int, string>();

            foreach (string line in m3u8.Split('\n'))
            {
                if (string.IsNullOrWhiteSpace(line) || !line.StartsWith("hls-"))
                    continue;

                string _q = new Regex("hls-([0-9]+)p").Match(line).Groups[1].Value;

                if (int.TryParse(_q, out int q) && q > 0)
                    stream_links.TryAdd(q, $"{Regex.Replace(stream_link, "/hls.m3u8.*", "")}/{line}");
            }

            return new StreamItem()
            {
                qualitys = stream_links.OrderByDescending(i => i.Key).ToDictionary(k => $"{k.Key}p", v => v.Value),
                recomends = getRelated()
            };
        }
    }
}

```

## File: Shared/Engine/JacRed/tParse.cs
```
Ôªøusing System.Globalization;
using System.Text.RegularExpressions;

namespace Shared.Engine.JacRed
{
    public static class tParse
    {
        #region BytesToString
        public static string BytesToString(long byteCount)
        {
            string[] suf = { "Byt", "KB", "MB", "GB", "TB", "PB", "EB" };
            if (byteCount == 0)
                return "0 " + suf[0];
            long bytes = Math.Abs(byteCount);
            int place = Convert.ToInt32(Math.Floor(Math.Log(bytes, 1024)));
            double num = Math.Round(bytes / Math.Pow(1024, place), 1);
            return (Math.Sign(byteCount) * num).ToString().Replace(",", ".") + " " + suf[place];
        }
        #endregion

        #region ParseCreateTime
        public static DateTime ParseCreateTime(string line, string format)
        {
            line = Regex.Replace(line, " —è–Ω–≤\\.? ", ".01.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " —Ñ–µ–≤—Ä?\\.? ", ".02.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –º–∞—Ä—Ç?\\.? ", ".03.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∞–ø—Ä\\.? ", ".04.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –º–∞–π\\.? ", ".05.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∏—é–Ω—å?\\.? ", ".06.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∏—é–ª—å?\\.? ", ".07.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∞–≤–≥\\.? ", ".08.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " —Å–µ–Ω—Ç?\\.? ", ".09.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –æ–∫—Ç\\.? ", ".10.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –Ω–æ—è–±?\\.? ", ".11.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –¥–µ–∫\\.? ", ".12.", RegexOptions.IgnoreCase);

            line = Regex.Replace(line, " —è–Ω–≤(–∞—Ä—è?)? ", ".01.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " —Ñ–µ–≤(—Ä–∞–ª—è?)? ", ".02.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –º–∞—Ä—Ç–∞? ", ".03.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∞–ø—Ä(–µ–ª—è?)? ", ".04.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –º–∞(–π|—è)? ", ".05.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∏—é–Ω(—å|—è)? ", ".06.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∏—é–ª(—å|—è)? ", ".07.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∞–≤–≥(—É—Å—Ça?)? ", ".08.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " —Å–µ–Ω—Ç(—è–±—Ä(—è|—å)?)? ", ".09.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –æ–∫—Ç(—è–±—Ä(—è|—å)?)? ", ".10.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –Ω–æ—è(–±—Ä(—è|—å)?)? ", ".11.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –¥–µ–∫(–∞–±—Ä(—è|—å)?)? ", ".12.", RegexOptions.IgnoreCase);

            line = Regex.Replace(line, " —è–Ω–≤–∞—Ä(—å|—è)?\\.? ", ".01.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " —Ñ–µ–≤—Ä–∞–ª(—å|—è)?\\.? ", ".02.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –º–∞—Ä—Ç–∞?\\.? ", ".03.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∞–ø—Ä–µ–ª(—å|—è)?\\.? ", ".04.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –º–∞–π?—è?\\.? ", ".05.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∏—é–Ω(—å|—è)?\\.? ", ".06.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∏—é–ª(—å|—è)?\\.? ", ".07.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –∞–≤–≥—É—Å—Ç–∞?\\.? ", ".08.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " —Å–µ–Ω—Ç—è–±—Ä(—å|—è)?\\.? ", ".09.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –æ–∫—Ç—è–±—Ä(—å|—è)?\\.? ", ".10.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –Ω–æ—è–±—Ä(—å|—è)?\\.? ", ".11.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " –¥–µ–∫–∞–±—Ä(—å|—è)?\\.? ", ".12.", RegexOptions.IgnoreCase);

            line = Regex.Replace(line, " Jan ", ".01.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Feb ", ".02.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Mar ", ".03.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Apr ", ".04.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " May ", ".05.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Jun ", ".06.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Jul ", ".07.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Aug ", ".08.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Sep ", ".09.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Oct ", ".10.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Nov ", ".11.", RegexOptions.IgnoreCase);
            line = Regex.Replace(line, " Dec ", ".12.", RegexOptions.IgnoreCase);

            if (Regex.IsMatch(line, "^[0-9]\\."))
                line = $"0{line}";

            DateTime.TryParseExact(line.ToLower(), format, new CultureInfo("ru-RU"), DateTimeStyles.None, out DateTime createTime);
            return createTime;
        }
        #endregion
    }
}

```

## File: Shared/Engine/JacRed/BencodeTo.cs
```
Ôªøusing BencodeNET.Parsing;
using BencodeNET.Torrents;
using System.Text.RegularExpressions;

namespace Shared.Engine.JacRed
{
    public static class BencodeTo
    {
        #region Magnet
        public static string Magnet(in byte[] torrent)
        {
            try
            {
                if (torrent == null)
                    return null;

                var parser = new BencodeParser();
                var res = parser.Parse<Torrent>(torrent);

                string magnet = res.GetMagnetLink();
                if (res.OriginalInfoHash != null)
                    magnet = Regex.Replace(magnet, @"urn:btih:[\w0-9]+", $"urn:btih:{res.OriginalInfoHash.ToLower()}", RegexOptions.IgnoreCase);

                return magnet;
            }
            catch 
            {
                return null;
            }
        }
        #endregion

        #region SizeName
        public static string SizeName(in byte[] torrent)
        {
            try
            {
                if (torrent == null)
                    return null;

                var parser = new BencodeParser();
                var res = parser.Parse<Torrent>(torrent);

                string FormatBytes(long bytes)
                {
                    string[] Suffix = { "B", "KB", "MB", "GB", "TB" };
                    int i;
                    double dblSByte = bytes;
                    for (i = 0; i < Suffix.Length && bytes >= 1024; i++, bytes /= 1024)
                    {
                        dblSByte = bytes / 1024.0;
                    }

                    return String.Format("{0:N2} {1}", dblSByte, Suffix[i]).Replace(",", ".");
                }

                return FormatBytes(res.TotalSize);
            }
            catch
            {
                return null;
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Collaps.cs
```
Ôªøusing Shared.Models;
using Shared.Models.Base;
using Shared.Models.Online.Collaps;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct CollapsInvoke
    {
        #region CollapsInvoke
        string host;
        string apihost;
        bool dash;
        Func<string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Action requesterror;

        public CollapsInvoke(string host, string apihost, bool dash, Func<string, ValueTask<string>> onget, Func<string, string> onstreamfile, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.dash = dash;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        public async ValueTask<EmbedModel?> Embed(string imdb_id, long kinopoisk_id, long orid)
        {
            string uri = $"{apihost}/embed/imdb/{imdb_id}";
            if (kinopoisk_id > 0)
                uri = $"{apihost}/embed/kp/{kinopoisk_id}";
            if (orid > 0)
                uri = $"{apihost}/embed/movie/{orid}";

            string content = await onget.Invoke(uri);
            if (string.IsNullOrEmpty(content))
            {
                requesterror?.Invoke();
                return null;
            }

            if (!content.Contains("seasons:"))
                return new EmbedModel() { content = content };

            RootObject[] root = null;

            try
            {
                root = JsonSerializer.Deserialize<RootObject[]>(Regex.Match(content, "seasons:([^\n\r]+)").Groups[1].Value);
                if (root == null || root.Length == 0)
                    return null;
            }
            catch { return null; }

            return new EmbedModel() { serial = root };
        }
        #endregion

        #region Html
        public string Html(EmbedModel md, string imdb_id, long kinopoisk_id, long orid, string title, string original_title, int s, bool rjson = false, List<HeadersModel> headers = null, VastConf vast = null)
        {
            if (md == null)
                return string.Empty;

            if (md.content != null)
            {
                #region –§–∏–ª—å–º
                string stream = Regex.Match(md.content, "hls: +\"(https?://[^\"]+\\.m3u[^\"]+)\"").Groups[1].Value;

                if (dash)
                {
                    string _dash = Regex.Match(md.content, "dasha?: +\"(https?://[^\"]+\\.mp[^\"]+)\"").Groups[1].Value;
                    if (!string.IsNullOrEmpty(_dash))
                        stream = _dash;
                }

                if (string.IsNullOrEmpty(stream))
                    return string.Empty;

                var mtpl = new MovieTpl(title, original_title, 1);

                string name = Regex.Match(md.content, "audio: +\\{\"names\":\\[\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrWhiteSpace(name))
                    name = "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é";

                #region subtitle
                SubtitleTpl? subtitles = null;

                try
                {
                    var subs = JsonSerializer.Deserialize<List<Cc>>(Regex.Match(md.content, "cc: +(\\[[^\n\r]+\\]),").Groups[1].Value);
                    if (subs != null)
                    {
                        subtitles = new SubtitleTpl(subs.Count);
                        foreach (var cc in subs)
                        {
                            if (cc.url != null)
                                subtitles.Value.Append(cc.name, onstreamfile.Invoke(cc.url));
                        }
                    }
                }
                catch { }
                #endregion

                string voicename = Regex.Match(md.content, "audio: +\\{\"names\":\\[\"([^\\]]+)\\]").Groups[1].Value;
                voicename = voicename.Replace("\"", "").Replace("delete", "").Replace(",", ", ");
                voicename = Regex.Replace(voicename, "[, ]+$", "");

                mtpl.Append(name, onstreamfile.Invoke(stream.Replace("\u0026", "&")), subtitles: subtitles, voice_name: voicename, headers: headers, vast: vast);

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                try
                {
                    if (s == -1)
                    {
                        var tpl = new SeasonTpl(md.serial.Length);

                        foreach (var season in md.serial.OrderBy(i => i.season))
                        {
                            string link = host + $"lite/collaps?rjson={rjson}&kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&orid={orid}&title={enc_title}&original_title={enc_original_title}&s={season.season}";
                            tpl.Append($"{season.season} —Å–µ–∑–æ–Ω", link, season.season);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        var episodes = md.serial.FirstOrDefault(i => i.season == s).episodes;
                        if (episodes == null)
                            return string.Empty;

                        var etpl = new EpisodeTpl(episodes.Length);
                        string sArch = s.ToString();

                        foreach (var episode in episodes)
                        {
                            string stream = episode.hls ?? episode.dasha ?? episode.dash;
                            if (dash && (episode.dasha ?? episode.dash) != null)
                                stream = episode.dasha ?? episode.dash;

                            if (string.IsNullOrEmpty(stream) || string.IsNullOrEmpty(episode.episode))
                                continue;

                            #region voicename
                            string voicename = string.Empty;

                            if (episode.audio.names != null)
                                voicename = Regex.Replace(string.Join(", ", episode.audio.names), "[, ]+$", "");
                            #endregion

                            #region subtitle
                            var subtitles = new SubtitleTpl(episode.cc?.Length ?? 0);

                            if (episode.cc != null && episode.cc.Length > 0)
                            {
                                foreach (var cc in episode.cc)
                                {
                                    if (cc.url != null)
                                        subtitles.Append(cc.name, onstreamfile.Invoke(cc.url));
                                }
                            }
                            #endregion

                            string file = onstreamfile.Invoke(stream.Replace("\u0026", "&"));
                            etpl.Append($"{episode.episode} —Å–µ—Ä–∏—è", title ?? original_title, sArch, episode.episode, file, subtitles: subtitles, voice_name: voicename, headers: headers, vast: vast);
                        }

                        return rjson ? etpl.ToJson() : etpl.ToHtml();
                    }
                }
                catch
                {
                    return string.Empty;
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/iRemux.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.iRemux;
using Shared.Models.Templates;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct iRemuxInvoke
    {
        #region iRemuxInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public iRemuxInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.onpost = onpost;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        async public ValueTask<EmbedModel> Embed(string title, string original_title, int year, string link)
        {
            var result = new EmbedModel();

            if (string.IsNullOrEmpty(link))
            {
                string search = await onget($"{apihost}/index.php?do=search&subaction=search&from_page=0&story={HttpUtility.UrlEncode(title ?? original_title)}");
                if (search == null)
                {
                    requesterror?.Invoke();
                    return null;
                }

                string stitle = title?.ToLower();
                string sorigtitle = original_title?.ToLower();

                foreach (string row in search.Split("item--announce").Skip(1))
                {
                    var g = Regex.Match(row, "class=\"item__title( [^\"]+)?\"><a href=\"(?<link>https?://[^\"]+)\">(?<name>[^<]+)</a>").Groups;

                    string name = g["name"].Value.ToLower();
                    if (name.Contains("—Å–µ–∑–æ–Ω") || name.Contains("—Å–µ—Ä–∏–∏") || name.Contains("—Å–µ—Ä–∏—è"))
                        continue;

                    if ((!string.IsNullOrEmpty(stitle) && name.Contains(stitle)) || (!string.IsNullOrEmpty(sorigtitle) && name.Contains(sorigtitle)))
                    {
                        if (string.IsNullOrEmpty(g["link"].Value))
                            continue;

                        if (name.Contains($"({year}/"))
                        {
                            result.similars.Add(new Similar()
                            {
                                title = name,
                                year = year.ToString(),
                                href = g["link"].Value
                            });
                        }
                    }
                }

                if (result.similars.Count == 0)
                {
                    if (search.Contains(">–ü–æ–∏—Å–∫ –ø–æ —Å–∞–π—Ç—É<"))
                        return new EmbedModel() { IsEmpty = true };

                    return null;
                }

                if (result.similars.Count > 1)
                    return result;

                link = result.similars[0].href;
            }

            string news = await onget(link);
            if (news == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string content = news.Split("page__desc")[1].Split("page__dl")[0];
            if (!content.Contains("cloud.mail.ru/public/"))
                return null;

            result.content = content.Replace("<!--colorend--></span><!--/colorend-->", "");
            return result;
        }
        #endregion

        #region Html
        public string Html(EmbedModel result, string title, string original_title, int year, bool rjson = false)
        {
            if (result == null || result.IsEmpty)
                return string.Empty;

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            #region similar
            if (result.content == null)
            {
                if (result.similars != null && result.similars.Count > 0)
                {
                    var stpl = new SimilarTpl(result.similars.Count);

                    foreach (var similar in result.similars)
                    {
                        string link = host + $"lite/remux?title={enc_title}&original_title={enc_original_title}&year={year}&href={HttpUtility.UrlEncode(similar.href)}";

                        stpl.Append(similar.title, similar.year, string.Empty, link);
                    }

                    return rjson ? stpl.ToJson() : stpl.ToHtml();
                }

                return string.Empty;
            }
            #endregion

            var mtpl = new MovieTpl(title, original_title, 4);

            foreach (Match m in Regex.Matches(result.content, $">([^<]+)(<[^>]+>)?<a href=\"https?://cloud.mail.ru/public/([^\"]+)\""))
            {
                string linkid = m.Groups[3].Value;
                if (string.IsNullOrEmpty(linkid))
                    continue;

                foreach (string q in new string[] { "2160p", "1080p", "720p", "480p" })
                {
                    string _qs = q == "480p" ? "1400" : q;
                    if (m.Groups[1].Value.Contains(_qs))
                    {
                        mtpl.Append(q, host + $"lite/remux/movie?linkid={linkid}&quality={q}&title={enc_title}&original_title={enc_original_title}", "call");
                        break;
                    }
                }
            }

            return rjson ? mtpl.ToJson(reverse: true) : mtpl.ToHtml(reverse: true);
        }
        #endregion


        #region Weblink
        async public ValueTask<string> Weblink(string linkid)
        {
            string html = await onget($"https://cloud.mail.ru/public/{linkid}");
            if (html == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string weblinkRow = StringConvert.FindLastText(html, "\"weblink_get\"", "}");
            if (weblinkRow == null)
                return null;

            string location = Regex.Match(weblinkRow, "\"url\": ?\"(https?://[^/]+)").Groups[1].Value;
            if (string.IsNullOrEmpty(location))
                return null;

            return $"{location}/weblink/view/{linkid}";
        }
        #endregion

        #region Movie
        public string Movie(in string weblink, in string quality, in string title, in string original_title, VastConf vast = null)
        {
            return VideoTpl.ToJson("play", onstreamfile?.Invoke(weblink), (title ?? original_title), quality: quality, vast: vast);
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/VideoDB.cs
```
Ôªøusing Shared.Models;
using Shared.Models.Online.VideoDB;
using Shared.Models.Templates;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct VideoDBInvoke
    {
        #region VideoDBInvoke
        string host;
        string apihost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Func<string, List<HeadersModel>, ValueTask<string>> onget;

        public VideoDBInvoke(string host, string apihost, Func<string, List<HeadersModel>, ValueTask<string>> onget, Func<string, string> onstreamfile, Func<string, string> onlog = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost!;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.onget = onget;
        }
        #endregion

        #region Embed
        public async ValueTask<EmbedModel> Embed(long kinopoisk_id)
        {
            string html = await onget.Invoke($"{apihost}/embed/AN?kinopoisk_id={kinopoisk_id}", null);

            if (html == null)
            {
                onlog?.Invoke("VideoDB: html null");
                return null;
            }

            return Embed(html);
        }

        public EmbedModel Embed(in string html)
        {
            if (string.IsNullOrEmpty(html))
                return null;

            string decodePlayer(in string _html)
            {
                try
                {
                    string base64 = Regex.Match(_html, "new Player\\(\"([^\n\r]+)\"\\);").Groups[1].Value.Remove(0, 73);
                    base64 = Regex.Replace(base64, "//[^=]+=", "");
                    string json = Encoding.UTF8.GetString(Convert.FromBase64String(base64));
                    //json = json.Split("\"player\",\"file\":")[1].Split(",\"hls\":")[0];

                    return json;
                }
                catch 
                {
                    return null;
                }
            }

            string file = decodePlayer(html);
            if (file == null)
            {
                onlog?.Invoke("VideoDB: file null");
                return null;
            }

            onlog?.Invoke("VideoDB: file OK");

            var pl = JsonNode.Parse(file)?["file"]?.Deserialize<RootObject[]>();
            if (pl == null || pl.Length == 0)
            {
                onlog?.Invoke("VideoDB: pl null");
                return null;
            }

            onlog?.Invoke("VideoDB: pl OK");

            string quality = file.Contains("2160p") ? "2160p" : file.Contains("1080p") ? "1080p" : file.Contains("720p") ? "720p" : "480p";
            return new EmbedModel() { pl = pl, movie = !file.Contains("\"folder\":"), quality = quality };
        }
        #endregion

        #region Html
        public string Html(EmbedModel root, string args, long kinopoisk_id, string title, string original_title, string t, int s, int sid, bool rjson, bool bwa = false, bool rhub = false)
        {
            if (root?.pl == null || root.pl.Length == 0)
                return string.Empty;

            if (!string.IsNullOrEmpty(args))
                args = $"&{args.Remove(0, 1)}";

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            if (root.movie)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, root.pl.Length);

                foreach (var pl in root.pl)
                {
                    string name = pl.title;
                    string file = pl.file;

                    if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(file))
                        continue;

                    #region streams
                    var streams = new List<(string link, string quality)>(7);

                    foreach (Match m in Regex.Matches(file, $"\\[(–ê–≤—Ç–æ|2160|1440|1080|720|480|360)p?\\]([^\"\\,\\[ ]+)"))
                    {
                        string link = m.Groups[2].Value;
                        if (string.IsNullOrEmpty(link))
                            continue;

                        string quality = file.Contains("2160p") ? "2160" : file.Contains("1080p") ? "1080" : file.Contains("720p") ? "720" : "480";
                        streams.Add((host + $"lite/videodb/manifest.m3u8?link={HttpUtility.UrlEncode(link)}{args}", quality));
                    }

                    if (streams.Count == 0)
                        continue;

                    streams.Reverse();
                    #endregion

                    #region subtitle (off)
                    //var subtitles = new SubtitleTpl();

                    //try
                    //{
                    //    int subx = 1;
                    //    var subs = pl.subtitle;
                    //    if (subs != null)
                    //    {
                    //        foreach (string cc in subs.Split(","))
                    //        {
                    //            if (string.IsNullOrWhiteSpace(cc) || !cc.EndsWith(".srt"))
                    //                continue;

                    //            subtitles.Append($"sub #{subx}", onstreamfile.Invoke(cc));
                    //            subx++;
                    //        }
                    //    }
                    //}
                    //catch { }
                    #endregion

                    if (bwa || rhub)
                    {
                        mtpl.Append(name, streams[0].link.Replace("/manifest.m3u8", "/manifest"), "call");
                    }
                    else
                    {
                        mtpl.Append(name, streams[0].link, quality: streams[0].quality);
                    }
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                if (s == -1)
                {
                    var tpl = new SeasonTpl(root.quality, root.pl.Length);

                    for(int i = 0; i < root.pl.Length; i++)
                    {
                        string name = root.pl?[i].title;
                        if (name == null)
                            continue;

                        string season = Regex.Match(name, "^([0-9]+)").Groups[1].Value;
                        if (string.IsNullOrEmpty(season))
                            continue;

                        tpl.Append(name, host + $"lite/videodb?rjson={rjson}&kinopoisk_id={kinopoisk_id}&rjson={rjson}&title={enc_title}&original_title={enc_original_title}&s={season}&sid={i}", season);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                }
                else
                {
                    var season = root.pl[sid].folder;
                    if (season == null)
                        return string.Empty;

                    var vtpl = new VoiceTpl();
                    var etpl = new EpisodeTpl();

                    var hashvoices = new HashSet<string>();

                    string sArhc = s.ToString();

                    foreach (var episode in season)
                    {
                        var episodes = episode.folder;
                        if (episodes == null || episodes.Length == 0)
                            continue;

                        foreach (var pl in episodes)
                        {
                            // MVO | LostFilm
                            string perevod = Regex.Replace(pl.title ?? "", "^[a-zA-Z]{3} \\| ", "");
                            if (!string.IsNullOrEmpty(perevod) && string.IsNullOrEmpty(t))
                                t = perevod;

                            #region –ü–µ—Ä–µ–≤–æ–¥—ã
                            if (!hashvoices.Contains(perevod))
                            {
                                hashvoices.Add(perevod);
                                string link = host + $"lite/videodb?rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&s={s}&sid={sid}&t={HttpUtility.UrlEncode(perevod)}";

                                vtpl.Append(perevod, t == perevod, link);
                            }
                            #endregion

                            if (perevod != t)
                                continue;

                            // 1 —ç–ø–∏–∑–æ–¥ 
                            string name = episode.title;
                            string file = pl.file;

                            if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(file))
                                continue;

                            var streamquality = new StreamQualityTpl();

                            foreach (Match m in Regex.Matches(file, $"\\[(1080|720|480|360)p?\\]([^\"\\,\\[ ]+)"))
                            {
                                string link = m.Groups[2].Value;
                                if (string.IsNullOrEmpty(link))
                                    continue;

                                streamquality.Insert(host + $"lite/videodb/manifest.m3u8?serial=true&link={HttpUtility.UrlEncode(link)}{args}", $"{m.Groups[1].Value}p");
                            }

                            if (!streamquality.Any())
                                continue;

                            if (bwa || rhub)
                            {
                                string streamlink = rhub ? streamquality.Firts().link : null;
                                etpl.Append(name, title ?? original_title, sArhc, Regex.Match(name, "^([0-9]+)").Groups[1].Value, streamquality.Firts().link.Replace("/manifest.m3u8", "/manifest"), "call", streamlink: streamlink);
                            }
                            else
                            {
                                etpl.Append(name, title ?? original_title, sArhc, Regex.Match(name, "^([0-9]+)").Groups[1].Value, streamquality.Firts().link, streamquality: streamquality);
                            }
                        }
                    }

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/FilmixTV.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.Filmix;
using Shared.Models.Online.FilmixTV;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Web;

namespace Shared.Engine.Online
{
    public class FilmixTVInvoke
    {
        #region FilmixTVInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;
        bool rjson;

        public FilmixTVInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null, bool rjson = false)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onpost = onpost;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
            this.rjson = rjson;
        }
        #endregion

        #region Search
        async public ValueTask<SearchResult> Search(string title, string original_title, int clarification, int year, bool similar)
        {
            if (string.IsNullOrWhiteSpace(title ?? original_title))
                return null;

            string uri = $"{apihost}/api-fx/list?search={HttpUtility.UrlEncode(clarification == 1 ? title : (original_title ?? title))}&limit=48";
            onlog?.Invoke(uri);

            string json = await onget.Invoke(uri);
            if (string.IsNullOrEmpty(json) || !json.Contains("\"status\":\"ok\""))
                return await Search2(title, original_title, year, clarification);

            List<SearchModel> root = null;

            try
            {
                root = JsonNode.Parse(json)?["items"]?.Deserialize<List<SearchModel>>();
            }
            catch { }

            if (root == null || root.Count == 0)
                return await Search2(title, original_title, year, clarification);

            var ids = new List<int>(root.Count);
            var stpl = new SimilarTpl(root.Count);

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            foreach (var item in root)
            {
                if (item == null)
                    continue;

                string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.original_name) ? $"{item.title} / {item.original_name}" : (item.title ?? item.original_name);

                stpl.Append(name, item.year.ToString(), string.Empty, host + $"lite/filmixtv?postid={item.id}&title={enc_title}&original_title={enc_original_title}", PosterApi.Size(item.poster));

                if ((!string.IsNullOrEmpty(stitle) && StringConvert.SearchName(item.title) == stitle) ||
                    (!string.IsNullOrEmpty(sorigtitle) && StringConvert.SearchName(item.original_name) == sorigtitle))
                {
                    if (item.year == year)
                        ids.Add(item.id);
                }
            }

            onlog?.Invoke("ids: " + ids.Count);

            if (ids.Count == 1 && !similar)
                return new SearchResult() { id = ids[0] };

            return new SearchResult() { similars = stpl };
        }
        #endregion

        #region Search2
        async ValueTask<SearchResult> Search2(string title, string original_title, int year, int clarification)
        {
            async Task<List<SearchModel>> gosearch(string story)
            {
                if (string.IsNullOrEmpty(story))
                    return null;

                string uri = $"http://filmixapp.cyou/api/v2/search?story={HttpUtility.UrlEncode(story)}&user_dev_apk=2.0.1&user_dev_id=&user_dev_name=Xiaomi&user_dev_os=11&user_dev_token=&user_dev_vendor=Xiaomi";
                onlog?.Invoke(uri);

                string json = await onget.Invoke(uri);
                if (json == null)
                    return null;

                List<SearchModel> root = null;

                try
                {
                    root = JsonSerializer.Deserialize<List<SearchModel>>(json);
                }
                catch { }

                if (root == null || root.Count == 0)
                    return null;

                return root;
            }

            var result = await gosearch(clarification == 1 ? original_title : title);
            if (result == null)
                result = await gosearch(clarification == 1 ? title : original_title);

            if (result == null)
                return null;

            var ids = new List<int>(result.Count);
            var stpl = new SimilarTpl(result.Count);

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            foreach (var item in result)
            {
                if (item == null)
                    continue;

                string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.original_title) ? $"{item.title} / {item.original_title}" : (item.title ?? item.original_title);

                stpl.Append(name, item.year.ToString(), string.Empty, host + $"lite/filmixtv?postid={item.id}&title={enc_title}&original_title={enc_original_title}", PosterApi.Size(item.poster));

                if ((!string.IsNullOrEmpty(stitle) && StringConvert.SearchName(item.title) == stitle) ||
                    (!string.IsNullOrEmpty(sorigtitle) && StringConvert.SearchName(item.original_title) == sorigtitle))
                {
                    if (item.year == year)
                        ids.Add(item.id);
                }
            }

            onlog?.Invoke("ids: " + ids.Count);

            if (ids.Count == 1)
                return new SearchResult() { id = ids[0] };

            return new SearchResult() { similars = stpl };
        }
        #endregion

        #region Post
        public Models.Online.FilmixTV.RootObject Post(in string json)
        {
            if (string.IsNullOrWhiteSpace(json))
            {
                requesterror?.Invoke();
                return null;
            }

            try
            {
                var rootMs = new Models.Online.FilmixTV.RootObject();

                if (JsonDocument.Parse(json).RootElement.ValueKind == JsonValueKind.Array)
                {
                    rootMs.Movies = JsonSerializer.Deserialize<MovieTV[]>(json);
                }
                else
                {
                    rootMs.SerialVoice = JsonSerializer.Deserialize<Dictionary<string, Dictionary<string, Season>>>(json);
                }

                return rootMs;
            }
            catch { return null; }
        }
        #endregion

        #region Html
        public string Html(Models.Online.FilmixTV.RootObject root, bool pro, int postid, string title, string original_title, int t, int? s, VastConf vast = null)
        {
            if (root == null)
                return string.Empty;

            #region –°–µ—Ä–∏–∞–ª
            if (root.SerialVoice != null)
            {
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                if (s == null)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    var maxQuality = root.SerialVoice.SelectMany(i => i.Value)
                        .SelectMany(season => season.Value.episodes)
                        .SelectMany(episode => episode.Value.files)
                        .Max(file => file.quality);

                    var tpl = new SeasonTpl($"{maxQuality}p");
                    var temp = new HashSet<int>();

                    foreach (var translation in root.SerialVoice)
                    {
                        foreach (var season in translation.Value)
                        {
                            if (temp.Contains(season.Value.season))
                                continue;

                            temp.Add(season.Value.season);

                            var link = $"{host}lite/filmixtv?rjson={rjson}&postid={postid}&title={enc_title}&original_title={enc_original_title}&s={season.Value.season}";
                            tpl.Append($"{season.Value.season} —Å–µ–∑–æ–Ω", link, season.Value.season);
                        }
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                    #endregion
                }
                else
                {
                    #region –ü–µ—Ä–µ–≤–æ–¥ 
                    int indexTranslate = 0;
                    var vtpl = new VoiceTpl();

                    foreach (var translation in root.SerialVoice)
                    {
                        foreach (var season in translation.Value)
                        {
                            if (season.Value.season == s)
                            {
                                string link = host + $"lite/filmixtv?rjson={rjson}&postid={postid}&title={enc_title}&original_title={enc_original_title}&s={s}&t={indexTranslate}";
                                bool active = t == indexTranslate;

                                if (t == -1)
                                    t = indexTranslate;

                                vtpl.Append(translation.Key, active, link);
                            }
                        }

                        indexTranslate++;
                    }
                    #endregion

                    var selectedSeason = root.SerialVoice.ElementAt(t).Value.FirstOrDefault(x => x.Value.season == s);

                    if (selectedSeason.Value.episodes == null)
                        return string.Empty;

                    var etpl = new EpisodeTpl(selectedSeason.Value.episodes.Count);

                    foreach (var episode in selectedSeason.Value.episodes)
                    {
                        var streamquality = new StreamQualityTpl();

                        var sortedFiles = episode.Value.files
                            .Where(file => pro || file.quality <= 720)
                            .OrderByDescending(file => file.quality);

                        foreach (var file in sortedFiles)
                            streamquality.Append(onstreamfile.Invoke(file.url), $"{file.quality}p");

                        if (!streamquality.Any())
                            continue;

                        etpl.Append($"{episode.Key.TrimStart('e')} —Å–µ—Ä–∏—è", title ?? original_title, selectedSeason.Value.season.ToString(), episode.Key.TrimStart('e'), streamquality.Firts().link, streamquality: streamquality, vast: vast);
                    }

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                }
            }
            #endregion

            #region –§–∏–ª—å–º
            else if (root.Movies != null)
            {
                var mtpl = new MovieTpl(title, original_title, root.Movies.Length);

                foreach (var item in root.Movies)
                {
                    var streamquality = new StreamQualityTpl();

                    foreach (var file in item.files)
                    {
                        if (!pro)
                        {
                            if (pro && file.quality > 480)
                                continue;

                            if (file.quality > 720)
                                continue;
                        }

                        streamquality.Append(onstreamfile.Invoke(file.url), $"{file.quality}p");
                    }

                    if (!streamquality.Any())
                        continue;

                    mtpl.Append(item.voiceover, streamquality.Firts().link, streamquality: streamquality, vast: vast);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
            }
            #endregion

            return string.Empty;
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Lumex.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.Lumex;
using Shared.Models.Online.Settings;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct LumexInvoke
    {
        #region LumexInvoke
        string host, scheme;
        bool hls;
        string apihost;
        string token;
        Func<string, string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public string onstream(string stream)
        {
            if (onstreamfile == null)
                return stream;

            return onstreamfile.Invoke(stream);
        }

        public LumexInvoke(LumexSettings init, Func<string, string, ValueTask<string>> onget, Func<string, string> onstreamfile, string host = null, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.scheme = init.scheme ?? "http";
            this.hls = init.hls;
            this.apihost = init.cors(init.apihost);
            this.token = init!.token;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
        }
        #endregion

        #region Search
        public async ValueTask<SimilarTpl> Search(string title, string original_title, int serial, int clarification, IEnumerable<DatumDB> database = null)
        {
            if (string.IsNullOrWhiteSpace(title ?? original_title))
                return default;

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            if (!string.IsNullOrEmpty(token))
            {
                #region api/short
                string uri = $"{apihost}/api/short?api_token={token}&title={HttpUtility.UrlEncode(clarification == 1 ? title : (original_title ?? title))}";

                string json = await onget.Invoke(uri, apihost);
                if (json == null)
                {
                    requesterror?.Invoke();
                    return default;
                }

                SearchRoot root = null;

                try
                {
                    root = JsonSerializer.Deserialize<SearchRoot>(json);
                    if (root?.data == null || root.data.Length == 0)
                        return default;
                }
                catch { return default; }

                var stpl = new SimilarTpl(root.data.Length);

                foreach (var item in root.data)
                {
                    if (serial != -1)
                    {
                        if ((serial == 0 && item.content_type != "movie") || (serial == 1 && item.content_type == "movie"))
                            continue;
                    }

                    if (clarification != 1)
                    {
                        bool isok = title != null && title.Length > 3 && item.title != null && item.title.ToLower().Contains(title.ToLower());
                        isok = isok ? true : original_title != null && original_title.Length > 3 && item.orig_title != null && item.orig_title.ToLower().Contains(original_title.ToLower());

                        if (!isok)
                            continue;
                    }

                    string year = item.add?.Split("-")?[0] ?? string.Empty;
                    string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.orig_title) ? $"{item.title} / {item.orig_title}" : (item.title ?? item.orig_title);

                    string details = $"imdb: {item.imdb_id} {stpl.OnlineSplit} kinopoisk: {item.kp_id}";

                    string img = PosterApi.Find(item.kp_id, item.imdb_id);
                    stpl.Append(name, year, details, host + $"lite/lumex?title={enc_title}&original_title={enc_original_title}&content_type={item.content_type}&content_id={item.id}&clarification={clarification}", img);
                }

                return stpl;
                #endregion
            }
            else if (database != null)
            {
                #region database
                int capacity = 100;
                if (database is ICollection<DatumDB> collection)
                    capacity = collection.Count > 100 ? 100 : collection.Count;

                var stpl = new SimilarTpl(capacity);

                foreach (var item in database)
                {
                    if (stpl.data.Count >= 100)
                        break;

                    if (item.kinopoisk_id == 0 && string.IsNullOrEmpty(item.imdb_id))
                        continue;

                    if (serial != -1)
                    {
                        if ((serial == 0 && item.content_type != "movie") || (serial == 1 && item.content_type == "movie"))
                            continue;
                    }

                    bool isok = false;

                    if (StringConvert.SearchName(original_title) != null)
                    {
                        if (StringConvert.SearchName(item.orig_title) == StringConvert.SearchName(original_title))
                            isok = true;
                    }

                    string stitle = StringConvert.SearchName(title);
                    if (!isok && stitle != null)
                    {
                        if (!string.IsNullOrEmpty(item.ru_title))
                        {
                            if (StringConvert.SearchName(item.ru_title, string.Empty)!.Contains(stitle))
                                isok = true;
                        }

                        if (!isok && StringConvert.SearchName(item.orig_title) != null && stitle != null)
                        {
                            if (StringConvert.SearchName(item.orig_title)!.Contains(stitle))
                                isok = true;
                        }
                    }

                    if (!isok)
                        continue;

                    string year = item.year?.Split("-")?[0] ?? string.Empty;
                    string name = !string.IsNullOrEmpty(item.ru_title) && !string.IsNullOrEmpty(item.orig_title) ? $"{item.ru_title} / {item.orig_title}" : (item.ru_title ?? item.orig_title);

                    string details = $"imdb: {item.imdb_id} {stpl.OnlineSplit} kinopoisk: {item.kinopoisk_id}";

                    string img = PosterApi.Find(item.kinopoisk_id, item.imdb_id);
                    stpl.Append(name, year, details, host + $"lite/lumex?title={enc_title}&original_title={enc_original_title}&content_type={item.content_type}&content_id={item.id}&clarification={clarification}", img);
                }

                return stpl;
                #endregion
            }

            return default;
        }
        #endregion

        #region Html
        public string Html(EmbedModel result, string args, long content_id, string content_type, string imdb_id, long kinopoisk_id, string title, string original_title, int clarification, string t, int s, bool rjson = false, bool bwa = false)
        {
            if (result?.media == null || result.media.Length == 0)
                return string.Empty;

            if (!string.IsNullOrEmpty(args))
                args = $"&{args.Remove(0, 1)}";

            if (result.content_type is "movie" or "anime")
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, result.media.Length);

                foreach (var media in result.media)
                {
                    var subtitles = new SubtitleTpl(media.subtitles?.Length ?? 0);
                    if (media.subtitles != null && media.subtitles.Length > 0)
                    {
                        foreach (string srt in media.subtitles)
                        {
                            string name = Regex.Match(srt, "/([^\\.\\/]+)\\.srt").Groups[1].Value;
                            subtitles.Append(name, onstream($"{scheme}:{srt}"));
                        }
                    }

                    string link = host + $"lite/lumex/video.m3u8?playlist={HttpUtility.UrlEncode(media.playlist)}&csrf={result.csrf}&max_quality={media.max_quality}{args}";

                    if (bwa || !hls)
                    {
                        mtpl.Append(media.translation_name, link.Replace(".m3u8", ""), "call", subtitles: subtitles, quality: media.max_quality?.ToString());
                    }
                    else
                    {
                        mtpl.Append(media.translation_name, link, subtitles: subtitles, quality: media.max_quality?.ToString());
                    }
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                try
                {
                    if (s == -1)
                    {
                        var tpl = new SeasonTpl(result.media.Length);

                        foreach (var media in result.media.OrderBy(s => s.season_id))
                        {
                            string link = host + $"lite/lumex?content_id={content_id}&content_type={content_type}&kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&rjson={rjson}&title={enc_title}&original_title={enc_original_title}&clarification={clarification}&s={media.season_id}{args}";    

                            tpl.Append($"{media.season_id} —Å–µ–∑–æ–Ω", link, media.season_id);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();
                        var tmpVoice = new HashSet<int>();

                        foreach (var media in result.media)
                        {
                            if (media.season_id != s)
                                continue;

                            foreach (var episode in media.episodes)
                            {
                                foreach (var voice in episode.media)
                                {
                                    if (tmpVoice.Contains(voice.translation_id))
                                        continue;

                                    tmpVoice.Add(voice.translation_id);

                                    if (string.IsNullOrEmpty(t))
                                        t = voice.translation_id.ToString();

                                    vtpl.Append(voice.translation_name, t == voice.translation_id.ToString(), host + $"lite/lumex?content_id={content_id}&content_type={content_type}&kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&rjson={rjson}&title={enc_title}&original_title={enc_original_title}&clarification={clarification}&s={s}&t={voice.translation_id}");
                                }
                            }
                        }
                        #endregion

                        if (string.IsNullOrEmpty(t))
                            t = "0";

                        var etpl = new EpisodeTpl();
                        string sArhc = s.ToString();

                        foreach (var media in result.media)
                        {
                            if (media.season_id != s)
                                continue;

                            foreach (var episode in media.episodes)
                            {
                                foreach (var voice in episode.media)
                                {
                                    if (voice.translation_id.ToString() != t)
                                        continue;

                                    var subtitles = new SubtitleTpl(media.subtitles?.Length ?? 0);
                                    if (media.subtitles != null && media.subtitles.Length > 0)
                                    {
                                        foreach (string srt in media.subtitles)
                                        {
                                            string name = Regex.Match(srt, "/([^\\.\\/]+)\\.srt").Groups[1].Value;
                                            subtitles.Append(name, onstream($"{scheme}:{srt}"));
                                        }
                                    }

                                    string link = host + $"lite/lumex/video.m3u8?playlist={HttpUtility.UrlEncode(voice.playlist)}&csrf={result.csrf}&max_quality={voice.max_quality}{args}";

                                    if (bwa || !hls)
                                    {
                                        etpl.Append($"{episode.episode_id} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.episode_id.ToString(), link.Replace(".m3u8", ""), "call", subtitles: subtitles);
                                    }
                                    else
                                    {
                                        etpl.Append($"{episode.episode_id} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.episode_id.ToString(), link, subtitles: subtitles);
                                    }
                                }
                            }
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                }
                catch
                {
                    return string.Empty;
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/CDNmovies.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;
using Shared.Models.Online.CDNmovies;

namespace Shared.Engine.Online
{
    public struct CDNmoviesInvoke
    {
        #region CDNmoviesInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Action requesterror;

        public CDNmoviesInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string> onstreamfile, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        public async ValueTask<Voice[]> Embed(long kinopoisk_id)
        {
            string html = await onget.Invoke($"{apihost}/serial/kinopoisk/{kinopoisk_id}");
            if (html == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string file = Regex.Match(html, "file:'([^\n\r]+)'").Groups[1].Value;
            if (string.IsNullOrEmpty(file))
                return null;

            Voice[] content;

            try
            {
                content = JsonSerializer.Deserialize<Voice[]>(file);
            }
            catch { return null; }

            if (content == null || content.Length == 0)
                return null;

            return content;
        }
        #endregion

        #region Html
        public string Html(Voice[] voices, long kinopoisk_id, string title, string original_title, int t, int s, int sid, VastConf vast = null, bool rjson = false)
        {
            if (voices == null || voices.Length == 0)
                return string.Empty;

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            #region –ü–µ—Ä–µ–≤–æ–¥ html
            var vtpl = new VoiceTpl(voices.Length);

            for (int i = 0; i < voices.Length; i++)
            {
                string link = host + $"lite/cdnmovies?rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&t={i}";
                vtpl.Append(voices[i].title, t == i, link);
            }
            #endregion

            if (s == -1)
            {
                #region –°–µ–∑–æ–Ω—ã
                var tpl = new SeasonTpl(voices[t].folder.Length);

                for (int i = 0; i < voices[t].folder.Length; i++)
                {
                    string season = Regex.Match(voices[t].folder[i].title, "([0-9]+)$").Groups[1].Value;
                    if (string.IsNullOrEmpty(season))
                        continue;

                    string link = host + $"lite/cdnmovies?rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&t={t}&s={season}&sid={i}";
                    tpl.Append($"{season} —Å–µ–∑–æ–Ω", link, season);
                }

                return rjson ? tpl.ToJson(vtpl) : (vtpl.ToHtml() + tpl.ToHtml());
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∏
                var etpl = new EpisodeTpl();
                string sArhc = s.ToString();

                foreach (var item in voices[t].folder[sid].folder)
                {
                    var streamquality = new StreamQualityTpl();

                    foreach (Match m in Regex.Matches(item.file, "\\[(360|240)p?\\]([^\\[\\|,\n\r\t ]+\\.(mp4|m3u8))"))
                    {
                        string link = m.Groups[2].Value;
                        if (string.IsNullOrEmpty(link))
                            continue;

                        streamquality.Insert(onstreamfile.Invoke(link), $"{m.Groups[1].Value}p");
                    }

                    string episode = Regex.Match(item.title, "([0-9]+)$").Groups[1].Value;
                    etpl.Append($"{episode} c–µ—Ä–∏—è", title ?? original_title, sArhc, episode, streamquality.Firts().link, streamquality: streamquality, vast: vast);
                }

                if (rjson)
                    return etpl.ToJson(vtpl);

                return vtpl.ToHtml() + etpl.ToHtml();
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Filmix.cs
```
Ôªøusing Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models;
using Shared.Models.Base;
using Shared.Models.Online.Filmix;
using Shared.Models.Online.Settings;
using Shared.Models.Templates;
using System.Collections.Concurrent;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public class FilmixInvoke
    {
        static ConcurrentDictionary<string, string> user_dev_ids = new ConcurrentDictionary<string, string>();

        #region FilmixInvoke
        FilmixSettings init;

        public bool disableSphinxSearch, reserve;

        public string token;
        string host, args;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string, List<HeadersModel>, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;
        bool rjson;

        public FilmixInvoke(FilmixSettings init, string host, string token, Func<string, ValueTask<string>> onget, Func<string, string, List<HeadersModel>, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null, bool rjson = false)
        {
            this.init = init;
            apihost = init.corsHost();
            reserve = init.reserve;
            this.token = token;
            this.host = host != null ? $"{host}/" : null;
            this.onget = onget;
            this.onpost = onpost;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
            this.rjson = rjson;

            string user_dev_id = user_dev_ids.GetOrAdd(token ?? string.Empty, (k) => UnicTo.Code(16));

            args = $"app_lang=ru_RU&user_dev_apk=2.2.10.0&user_dev_id={user_dev_id}&user_dev_name=Xiaomi+24069PC21G&user_dev_os=14&user_dev_token={token}&user_dev_vendor=Xiaomi";
        }
        #endregion

        #region Search
        async public Task<SearchResult> Search(string title, string original_title, int clarification, int year, bool similar)
        {
            if (string.IsNullOrWhiteSpace(title ?? original_title))
                return null;

            string uri = $"{apihost}/api/v2/search?story={HttpUtility.UrlEncode(clarification == 1 ? title : (original_title ?? title))}&{args}";
            onlog?.Invoke(uri);
            
            string json = await onget.Invoke(uri);
            if (json == null)
                return await Search2(title, original_title, clarification, year);

            List<SearchModel> root = null;

            try
            {
                root = JsonConvert.DeserializeObject<List<SearchModel>>(json);
            }
            catch { }

            if (root == null || root.Count == 0)
                return await Search2(title, original_title, clarification, year);

            var ids = new List<int>(root.Count);
            var stpl = new SimilarTpl(root.Count);

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            foreach (var item in root)
            {
                if (item == null)
                    continue;

                string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.original_title) ? $"{item.title} / {item.original_title}"  : (item.title ?? item.original_title);

                stpl.Append(name, item.year.ToString(), string.Empty, host + $"lite/filmix?postid={item.id}&title={enc_title}&original_title={enc_original_title}", PosterApi.Size(item.poster)); 

                if ((!string.IsNullOrEmpty(stitle) && StringConvert.SearchName(item.title) == stitle) ||
                    (!string.IsNullOrEmpty(sorigtitle) && StringConvert.SearchName(item.original_title) == sorigtitle))
                {
                    if (item.year == year)
                        ids.Add(item.id);
                }
            }

            onlog?.Invoke("ids: " + ids.Count);

            if (ids.Count == 1 && !similar)
                return new SearchResult() { id = ids[0] };

            return new SearchResult() { similars = stpl };
        }
        #endregion

        #region Search2
        async Task<SearchResult> Search2(string title, string original_title, int clarification, int year)
        {
            async Task<List<SearchModel>> gosearch(string story)
            {
                if (string.IsNullOrEmpty(story))
                    return null;

                string uri = $"https://api.filmix.tv/api-fx/list?search={HttpUtility.UrlEncode(story)}&limit=48";
                onlog?.Invoke(uri);

                string json = await onget.Invoke(uri);
                if (string.IsNullOrEmpty(json) || !json.Contains("\"status\":\"ok\""))
                    return null;

                List<SearchModel> root = null;

                try
                {
                    root = JObject.Parse(json)?["items"]?.ToObject<List<SearchModel>>();
                }
                catch { }

                if (root == null || root.Count == 0)
                    return null;

                return root;
            }

            var result = await gosearch(clarification == 1 ? original_title : title);
            if (result == null)
                result = await gosearch(clarification == 1 ? title : original_title);

            if (result == null)
                return await Search3(title, original_title, clarification, year);

            var ids = new List<int>(result.Count);
            var stpl = new SimilarTpl(result.Count);

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            foreach (var item in result)
            {
                if (item == null)
                    continue;

                string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.original_name) ? $"{item.title} / {item.original_name}" : (item.title ?? item.original_name);

                stpl.Append(name, item.year.ToString(), string.Empty, host + $"lite/filmix?postid={item.id}&title={enc_title}&original_title={enc_original_title}");

                if ((!string.IsNullOrEmpty(stitle) && StringConvert.SearchName(item.title) == stitle) ||
                    (!string.IsNullOrEmpty(sorigtitle) && StringConvert.SearchName(item.original_name) == sorigtitle))
                {
                    if (item.year == year)
                        ids.Add(item.id);
                }
            }

            onlog?.Invoke("ids: " + ids.Count);

            if (ids.Count == 1)
                return new SearchResult() { id = ids[0] };

            return new SearchResult() { similars = stpl };
        }
        #endregion

        #region Search3
        async Task<SearchResult> Search3(string title, string original_title, int clarification, int year)
        {
            return null;

            if (disableSphinxSearch)
            {
                requesterror?.Invoke();
                return null;
            }

            onlog?.Invoke("Search3");

            string html = await onpost.Invoke("https://filmix.my/engine/ajax/sphinx_search.php", $"scf=fx&story={HttpUtility.UrlEncode(clarification == 1 ? title : (original_title ?? title))}&search_start=0&do=search&subaction=search&years_ot=1902&years_do={DateTime.Today.Year}&kpi_ot=1&kpi_do=10&imdb_ot=1&imdb_do=10&sort_name=&undefined=asc&sort_date=&sort_favorite=&simple=1", HeadersModel.Init( 
                ("Origin", "https://filmix.my"),
                ("Referer", "https://filmix.my/search/"),
                ("X-Requested-With", "XMLHttpRequest"),
                ("Sec-Fetch-Site", "same-origin"),
                ("Sec-Fetch-Mode", "cors"),
                ("Sec-Fetch-Dest", "empty"),
                ("Cookie", "x-a-key=sinatra; FILMIXNET=2g5orcue70hmbkugbr7vi431l0; _ga_GYLWSWSZ3C=GS1.1.1703578122.1.0.1703578122.0.0.0; _ga=GA1.1.1855910641.1703578123")
            ));

            if (html == null)
            {
                requesterror?.Invoke();
                return null;
            }

            var rows = html.Split("</article>");

            var ids = new List<int>(rows.Length);
            var stpl = new SimilarTpl(rows.Length);

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            string stitle = title?.ToLower();
            string sorigtitle = original_title?.ToLower();

            foreach (string row in rows)
            {
                string ftitle = Regex.Match(row, "itemprop=\"name\" content=\"([^\"]+)\"").Groups[1].Value;
                string ftitle_orig = Regex.Match(row, "itemprop=\"alternativeHeadline\" content=\"([^\"]+)\"").Groups[1].Value;
                string fyear = Regex.Match(row, "itemprop=\"copyrightYear\"[^>]+>([0-9]{4})").Groups[1].Value;
                string fid = Regex.Match(row, "data-id=\"([0-9]+)\"").Groups[1].Value;

                if (int.TryParse(fid, out int id) && id > 0)
                {
                    string name = !string.IsNullOrEmpty(ftitle) && !string.IsNullOrEmpty(ftitle_orig) ? $"{ftitle} / {ftitle_orig}" : (ftitle ?? ftitle_orig);

                    stpl.Append(name, fyear, string.Empty, host + $"lite/filmix?postid={id}&title={enc_title}&original_title={enc_original_title}");

                    if ((!string.IsNullOrEmpty(stitle) && ftitle.ToLower() == stitle) ||
                        (!string.IsNullOrEmpty(sorigtitle) && ftitle_orig.ToLower() == sorigtitle))
                    {
                        if (fyear == year.ToString())
                            ids.Add(id);
                    }
                }
            }

            onlog?.Invoke("ids: " + ids.Count);

            if (ids.Count == 1)
                return new SearchResult() { id = ids[0] };

            return new SearchResult() { similars = stpl };
        }
        #endregion

        #region Post
        async public Task<RootObject> Post(int postid)
        {
            string uri = $"{apihost}/api/v2/post/{postid}?{args}";
            onlog?.Invoke(uri);

            string json = await onget.Invoke(uri);
            if (json == null)
            {
                requesterror?.Invoke();
                return null;
            }

            try
            {
                var root = JsonConvert.DeserializeObject<RootObject>(json.Replace("\"playlist\":[],", "\"playlist\":null,"), new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } });

                if (root?.player_links == null)
                    return null;

                return root;
            }
            catch { return null; }
        }
        #endregion

        #region Html
        public string Html(RootObject root, bool pro, int postid, string title, string original_title, int t, int? s, VastConf vast = null)
        {
            var player_links = root.player_links;
            if (player_links.movie == null && player_links.playlist == null)
                return string.Empty;

            int filmixservtime = DateTime.UtcNow.AddHours(2).Hour;
            bool hidefree720 = string.IsNullOrEmpty(token) /*&& filmixservtime >= 19 && filmixservtime <= 23*/;

            if (player_links.movie != null && player_links.movie.Length > 0)
            {
                #region –§–∏–ª—å–º
                if (player_links.movie.Length == 1 && player_links.movie[0].translation.ToLower().StartsWith("–∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ "))
                    return string.Empty;

                var cdns = reserve ? player_links.movie
                        .Select(e => Regex.Match(e.link, "^(https?://[^/]+)").Groups[1].Value)
                        .ToHashSet() : null;

                var mtpl = new MovieTpl(title, original_title, player_links.movie.Length);

                foreach (var v in player_links.movie)
                {
                    var streamquality = new StreamQualityTpl();

                    foreach (int q in new int[] { 2160, 1440, 1080, 720, 480 })
                    {
                        if (!pro)
                        {
                            if (hidefree720 && q > 480)
                                continue;

                            if (q > 720)
                                continue;
                        }

                        if (!v.link.Contains($"{q},"))
                            continue;

                        string l = Regex.Replace(v.link, "_\\[[0-9,]+\\]\\.mp4", $"_{q}.mp4");

                        if (init.hls && !Regex.IsMatch(l, "/(HDR10p?|HEVC)/"))
                        {
                            var m = Regex.Match(l, "^(https?://[^/]+)/s/([^/]+)/(.*)");
                            if (m.Success)
                                l = $"{m.Groups[1].Value}/hls/{m.Groups[3].Value}/index.m3u8?hash={m.Groups[2].Value}";
                        }

                        if (reserve)
                        {
                            foreach (string cdn in cdns)
                            {
                                if (!l.Contains(cdn))
                                {
                                    l += " or " + Regex.Replace(l, "^https?://[^/]+", cdn);
                                    break;
                                }
                            }
                        }

                        streamquality.Append(onstreamfile.Invoke(l), $"{q}p");
                    }

                    mtpl.Append(v.translation, streamquality.Firts().link, streamquality: streamquality, vast: vast);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                if (player_links.playlist == null || player_links.playlist.Count == 0)
                    return string.Empty;

                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                if (s == null)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    var tpl = new SeasonTpl(!string.IsNullOrEmpty(root?.quality) ? $"{root.quality.Replace("+", "")}p" : null, player_links.playlist.Count);

                    foreach (var season in player_links.playlist)
                    {
                        string link = host + $"lite/filmix?rjson={rjson}&postid={postid}&title={enc_title}&original_title={enc_original_title}&s={season.Key}";
                        tpl.Append($"{season.Key.Replace("-1", "1")} —Å–µ–∑–æ–Ω", link, season.Key);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                    #endregion
                }
                else
                {
                    string sArch = s?.ToString();

                    if (sArch == null)
                        return string.Empty;

                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var voices = player_links.playlist[sArch];

                    int indexTranslate = 0;
                    var vtpl = new VoiceTpl(voices.Count);

                    foreach (var translation in voices)
                    {
                        string link = host + $"lite/filmix?rjson={rjson}&postid={postid}&title={enc_title}&original_title={enc_original_title}&s={s}&t={indexTranslate}";
                        bool active = t == indexTranslate;

                        indexTranslate++;
                        vtpl.Append(translation.Key, active, link);
                    }
                    #endregion

                    #region Deserialize
                    Dictionary<string, Movie> episodes = null;

                    try
                    {
                        episodes = player_links.playlist[sArch].ElementAt(t).Value.ToObject<Dictionary<string, Movie>>();
                    }
                    catch
                    {
                        try
                        {
                            int episod_id = 0;
                            episodes = new Dictionary<string, Movie>();

                            foreach (var item in player_links.playlist[sArch].ElementAt(t).Value.ToObject<List<Movie>>())
                            {
                                episod_id++;
                                episodes.Add(episod_id.ToString(), item);
                            }
                        }
                        catch { }
                    }

                    if (episodes == null || episodes.Count == 0)
                        return string.Empty;
                    #endregion

                    var cdns = reserve ? episodes
                        .Select(e => Regex.Match(e.Value.link, "^(https?://[^/]+)").Groups[1].Value)
                        .ToHashSet() : null;

                    #region –°–µ—Ä–∏–∏
                    var etpl = new EpisodeTpl(episodes.Count);

                    foreach (var episode in episodes)
                    {
                        var streamquality = new StreamQualityTpl();

                        foreach (var lq in episode.Value.qualities.OrderByDescending(i => i))
                        {
                            if (!pro)
                            {
                                if (hidefree720 && lq > 480)
                                    continue;

                                if (lq > 720)
                                    continue;
                            }

                            string l = episode.Value.link.Replace("_%s.mp4", $"_{lq}.mp4");

                            if (init.hls && !Regex.IsMatch(l, "/(HDR10p?|HEVC)/"))
                            {
                                var m = Regex.Match(l, "^(https?://[^/]+)/s/([^/]+)/(.*)");
                                if (m.Success)
                                    l = $"{m.Groups[1].Value}/hls/{m.Groups[3].Value}/index.m3u8?hash={m.Groups[2].Value}";
                            }

                            if (reserve)
                            {
                                foreach (string cdn in cdns)
                                {
                                    if (!l.Contains(cdn))
                                    {
                                        l += " or " + Regex.Replace(l, "^https?://[^/]+", cdn);
                                        break;
                                    }
                                }
                            }

                            streamquality.Append(onstreamfile.Invoke(l), $"{lq}p");
                        }

                        int fis = s == -1 ? 1 : (s ?? 1);

                        etpl.Append($"{episode.Key} —Å–µ—Ä–∏—è", title ?? original_title, fis.ToString(), episode.Key, streamquality.Firts().link, streamquality: streamquality, vast: vast);
                    }
                    #endregion

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/VideoCDN.cs
```
Ôªøusing Org.BouncyCastle.Utilities.IO;
using Shared.Models.Online.Settings;
using Shared.Models.Online.VideoCDN;
using Shared.Models.Templates;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct VideoCDNInvoke
    {
        #region VideoCDNInvoke
        string host, scheme;
        string iframeapihost;
        string apihost;
        string token;
        bool usehls;
        Func<string, string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public string onstream(string stream)
        {
            if (onstreamfile == null)
                return stream;

            return onstreamfile.Invoke(stream);
        }

        public VideoCDNInvoke(OnlinesSettings init, Func<string, string, ValueTask<string>> onget, Func<string, string> onstreamfile, string host = null, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.scheme = init.scheme;
            this.iframeapihost = init.corsHost();
            this.apihost = init.cors(init.apihost);
            this.token = init!.token;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            usehls = init.hls;
            this.requesterror = requesterror;
        }
        #endregion

        #region Search
        public async ValueTask<SimilarTpl?> Search(string title, string original_title, int serial)
        {
            if (string.IsNullOrWhiteSpace(title ?? original_title))
                return null;

            string uri = $"{apihost}/api/short?api_token={token}&title={HttpUtility.UrlEncode(original_title ?? title)}";

            string json = await onget.Invoke(uri, apihost);
            if (json == null)
            {
                requesterror?.Invoke();
                return null;
            }

            SearchRoot root = null;

            try
            {
                root = JsonSerializer.Deserialize<SearchRoot>(json);
                if (root?.data == null || root.data.Length == 0)
                    return null;
            }
            catch { return null; }

            var stpl = new SimilarTpl(root.data.Length);

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            foreach (var item in root.data)
            {
                if (item.kp_id == 0 && string.IsNullOrEmpty(item.imdb_id))
                    continue;

                if (serial != -1)
                {
                    if ((serial == 0 && item.content_type != "movie") || (serial == 1 && item.content_type == "movie"))
                        continue;
                }

                bool isok = title != null && title.Length > 3 && item.title != null && item.title.ToLower().Contains(title.ToLower());
                isok = isok ? true : original_title != null && original_title.Length > 3 && item.orig_title != null && item.orig_title.ToLower().Contains(original_title.ToLower());

                if (!isok)
                    continue;

                string year = item.add?.Split("-")?[0] ?? string.Empty;
                string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.orig_title) ? $"{item.title} / {item.orig_title}" : (item.title ?? item.orig_title);

                string details = $"imdb: {item.imdb_id} {stpl.OnlineSplit} kinopoisk: {item.kp_id}";

                stpl.Append(name, year, details, host + $"lite/vcdn?title={enc_title}&original_title={enc_original_title}&kinopoisk_id={item.kp_id}&imdb_id={item.imdb_id}");
            }

            return stpl;
        }
        #endregion

        #region Embed
        public async ValueTask<EmbedModel> Embed(long kinopoisk_id, string imdb_id)
        {
            string args = kinopoisk_id > 0 ? $"kp_id={kinopoisk_id}&imdb_id={imdb_id}" : $"imdb_id={imdb_id}";
            string content = await onget.Invoke($"{iframeapihost}?{args}", "https://kinogo.ec/113447-venom-3-poslednij-tanec.html");
            if (content == null)
            {
                requesterror?.Invoke();
                return null;
            }

            var result = new EmbedModel();
            result.type = Regex.Match(content, "id=\"videoType\" value=\"([^\"]+)\"").Groups[1].Value;
            result.voices = new Dictionary<string, string>();

            if (content.Contains("</option>"))
            {
                result.voices.TryAdd("0", "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é");

                var match = new Regex("<option +value=\"([0-9]+)\"[^>]+>([^<]+)</option>").Match(Regex.Replace(content, "[\n\r\t]+", ""));
                while (match.Success)
                {
                    string translation_id = match.Groups[1].Value;
                    string translation = match.Groups[2].Value.Trim();

                    if (!string.IsNullOrEmpty(translation_id) && !string.IsNullOrEmpty(translation))
                        result.voices.TryAdd(translation_id, translation);

                    match = match.NextMatch();
                }
            }

            string Decode(string pass, string src)
            {
                try
                {
                    int passLen = pass.Length;
                    int srcLen = src.Length;
                    byte[] passArr = new byte[passLen];

                    for (int i = 0; i < passLen; i++)
                    {
                        passArr[i] = (byte)pass[i];
                    }

                    StringBuilder res = new StringBuilder();

                    for (int i = 0; i < srcLen; i += 2)
                    {
                        string hex = src.Substring(i, 2);
                        int code = Convert.ToInt32(hex, 16);
                        byte secret = (byte)(passArr[(i / 2) % passLen] % 255);
                        res.Append((char)(code ^ secret));
                    }

                    return res.ToString();
                }
                catch { return null; }
            }

            string files = null;
            string client_id = Regex.Match(content, "id=\"client_id\" value=\"([^\"]+)\"").Groups[1].Value;

            var m = Regex.Match(content, "<input type=\"hidden\" id=\"[^\"]+\" value=('|\")([^\"']+)");
            while (m.Success)
            {
                string sentry_id = m.Groups[2].Value;
                if (200 > sentry_id.Length || sentry_id.StartsWith("{"))
                {
                    m = m.NextMatch();
                    continue;
                }

                files = Decode(client_id, sentry_id);
                if (!string.IsNullOrEmpty(files))
                    break;

                m = m.NextMatch();
            }

            if (string.IsNullOrEmpty(files))
            {
                files = Regex.Match(content, "value='(\\{\"[0-9]+\"[^\']+)'").Groups[1].Value;
                if (string.IsNullOrEmpty(files))
                    return null;
            }    

            result.quality = files.Contains("1080p") ? "1080p" : files.Contains("720p") ? "720p" : "480p";

            try
            {
                if (result.type is "movie" or "anime")
                {
                    result.movie = JsonSerializer.Deserialize<Dictionary<string, string>>(files);
                    if (result.movie == null)
                        return null;
                }
                else
                {
                    result.serial = JsonSerializer.Deserialize<Dictionary<string, List<Season>>>(files);
                    if (result.serial == null)
                        return null;

                    #region voiceSeasons
                    result.voiceSeasons = new Dictionary<string, HashSet<int>>();

                    foreach (var voice in result.serial.OrderByDescending(k => k.Key == "0"))
                    {
                        if (result.voices.TryGetValue(voice.Key, out string name) && name != null)
                        {
                            foreach (var season in voice.Value)
                            {
                                if (result.voiceSeasons.TryGetValue(voice.Key, out HashSet<int> _s))
                                {
                                    _s.Add(season.id);
                                }
                                else
                                {
                                    result.voiceSeasons.TryAdd(voice.Key, new HashSet<int>() { season.id });
                                }
                            }
                        }
                    }
                    #endregion
                }
            }
            catch { return null; }

            return result;
        }
        #endregion

        #region Html
        public string Html(EmbedModel result, string imdb_id, long kinopoisk_id, string title, string original_title, string t, int s, bool rjson = false)
        {
            if (result == null)
                return string.Empty;

            if (result.type is "movie" or "anime")
            {
                #region –§–∏–ª—å–º
                if (result.movie == null || result.movie.Count == 0)
                    return string.Empty;

                var mtpl = new MovieTpl(title, original_title, result.movie.Count);

                foreach (var voice in result.movie)
                {
                    result.voices.TryGetValue(voice.Key, out string name);
                    if (string.IsNullOrEmpty(name))
                    {
                        if (result.movie.Count > 1)
                            continue;

                        name = "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é";
                    }

                    var streamquality = new StreamQualityTpl();

                    foreach (Match m in Regex.Matches(voice.Value, $"\\[(1080|720|480|360)p?\\]([^\\[\\|,\n\r\t ]+\\.(mp4|m3u8))"))
                    {
                        string link = m.Groups[2].Value;
                        if (string.IsNullOrEmpty(link))
                            continue;

                        if (usehls && !link.Contains(".m3u"))
                            link += ":hls:manifest.m3u8";
                        else if (!usehls && link.Contains(".m3u"))
                            link = link.Replace(":hls:manifest.m3u8", "");

                        streamquality.Insert(onstream($"{scheme}:{link}"), $"{m.Groups[1].Value}p");
                    }

                    mtpl.Append(name, streamquality.Firts().link, streamquality: streamquality);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                try
                {
                    if (result.serial == null || result.serial.Count == 0)
                        return string.Empty;

                    if (s == -1)
                    {
                        var seasons = new HashSet<int>();

                        foreach (var voice in result.serial)
                        {
                            foreach (var season in voice.Value)
                                seasons.Add(season.id);
                        }

                        var tpl = new SeasonTpl(result.quality, seasons.Count);

                        foreach (int id in seasons.OrderBy(s => s))
                        {
                            string link = host + $"lite/vcdn?kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&rjson={rjson}&title={enc_title}&original_title={enc_original_title}&s={id}";
                            tpl.Append($"{id} —Å–µ–∑–æ–Ω", link, id);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();

                        foreach (var voice in result.voiceSeasons)
                        {
                            if (!voice.Value.Contains(s))
                                continue;

                            if (result.voices.TryGetValue(voice.Key, out string name) && name != null)
                            {
                                if (string.IsNullOrEmpty(t))
                                    t = voice.Key;

                                vtpl.Append(name, t == voice.Key, host + $"lite/vcdn?kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&rjson={rjson}&title={enc_title}&original_title={enc_original_title}&s={s}&t={voice.Key}");
                            }
                        }
                        #endregion

                        if (string.IsNullOrEmpty(t))
                            t = "0";

                        var season = result.serial[t].First(i => i.id == s);
                        if (season.folder == null)
                            return string.Empty;

                        string sArhc = s.ToString();
                        var etpl = new EpisodeTpl(season.folder.Length);

                        foreach (var episode in season.folder)
                        {
                            var streamquality = new StreamQualityTpl();

                            foreach (Match m in Regex.Matches(episode.file ?? "", $"\\[(1080|720|480|360)p?\\]([^\\[\\|,\n\r\t ]+\\.(mp4|m3u8))"))
                            {
                                string link = m.Groups[2].Value;
                                if (string.IsNullOrEmpty(link))
                                    continue;

                                if (usehls && !link.Contains(".m3u"))
                                    link += ":hls:manifest.m3u8";
                                else if (!usehls && link.Contains(".m3u"))
                                    link = link.Replace(":hls:manifest.m3u8", "");

                                streamquality.Insert(onstream($"{scheme}:{link}"), $"{m.Groups[1].Value}p");
                            }

                            string e = episode.id.Split("_")[1];

                            etpl.Append($"{e} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, e, streamquality.Firts().link, streamquality: streamquality);
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                }
                catch
                {
                    return string.Empty;
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/FanCDN.cs
```
Ôªøusing Shared.Models;
using Shared.Models.Base;
using Shared.Models.Online.FanCDN;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct FanCDNInvoke
    {
        #region FanCDNInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;

        public FanCDNInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string> onstreamfile, Func<string, string> onlog = null)
        {
            this.host = host != null ? $"{host}/" : null; this.apihost = apihost;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
        }
        #endregion

        #region EmbedSearch
        async public ValueTask<EmbedModel> EmbedSearch(string title, string original_title, int year, int serial)
        {
            if (serial == 1)
            {
                return null;
            }
            else
            {
                if (string.IsNullOrEmpty(title) || year == 0)
                    return null;

                string search = await onget($"{apihost}/?do=search&subaction=search&story={HttpUtility.UrlEncode(title)}");
                if (string.IsNullOrEmpty(search))
                    return null;

                string href = null;

                foreach (string itemsearch in search.Split("item-search-serial"))
                {
                    string info = itemsearch.Split("torrent-link")?[0];
                    if (!string.IsNullOrEmpty(info) && (info.Contains($"({year - 1}") || info.Contains($"({year}") || info.Contains($"({year + 1}")))
                    {
                        string _info = StringConvert.SearchName(info);
                        if (_info.Contains(StringConvert.SearchName(title)) || (!string.IsNullOrEmpty(original_title) && _info.Contains(StringConvert.SearchName(original_title))))
                        {
                            href = Regex.Match(info, "<a href=\"(https?://[^\"]+\\.html)\"").Groups[1].Value;
                            break;
                        }
                    }
                }

                if (string.IsNullOrEmpty(href))
                    return null;

                string html = await onget(href);
                if (string.IsNullOrEmpty(html))
                    return null;


                string iframe_url = null;

                foreach (Match match in Regex.Matches(html, "(https?://fancdn\\.[^\"\n\r\t ]+)\""))
                {
                    string cdn = match.Groups[1].Value;
                    if (cdn.Contains("kinopoisk=") && cdn.Contains("key="))
                        iframe_url = cdn;
                }


                if (string.IsNullOrEmpty(iframe_url))
                    return null;

                return await Embed(iframe_url);
            }
        }
        #endregion

        #region EmbedToken
        async public ValueTask<EmbedModel> EmbedToken(long kinopoisk_id, string token)
        {
            if (kinopoisk_id == 0)
                return null;

            return await Embed($"https://fancdn.net/iframe/?kinopoisk={kinopoisk_id}&key={token}");
        }
        #endregion

        #region Embed
        async public ValueTask<EmbedModel> Embed(string iframe_url)
        {
            if (string.IsNullOrEmpty(iframe_url))
                return null;

            string iframe = await onget(iframe_url);
            if (string.IsNullOrEmpty(iframe))
                return null;

            iframe = Regex.Replace(iframe, "[\n\r\t]+", "").Replace("var ", "\n");

            string playlist = Regex.Match(iframe, "playlist ?= ?(\\[[^\n\r]+\\]);").Groups[1].Value;
            if (string.IsNullOrEmpty(playlist))
                return null;

            try
            {
                if (iframe.Contains("\"folder\""))
                {
                    var serial = JsonSerializer.Deserialize<Voice[]>(playlist);
                    if (serial == null || serial.Length == 0)
                        return null;

                    return new EmbedModel() { serial = serial };
                }
                else
                {
                    var movies = JsonSerializer.Deserialize<Episode[]>(playlist);
                    if (movies == null || movies.Length == 0)
                        return null;

                    return new EmbedModel() { movies = movies };
                }
            }
            catch { }

            return null;
        }
        #endregion

        #region Html
        public string Html(EmbedModel root, string imdb_id, long kinopoisk_id, string title, string original_title, int t = -1, int s = -1, bool rjson = false, VastConf vast = null, List<HeadersModel> headers = null)
        {
            if (root == null)
                return string.Empty;

            if (root.movies != null)
            {
                var mtpl = new MovieTpl(title, original_title, root.movies.Length);

                foreach (var m in root.movies)
                {
                    if (string.IsNullOrEmpty(m.file))
                        continue;

                    #region subtitle
                    var subtitles = new SubtitleTpl();

                    if (!string.IsNullOrEmpty(m.subtitles))
                    {
                        // [rus]rus1.srt,[eng]eng2.srt,[eng]eng3.srt
                        var match = new Regex("\\[([^\\]]+)\\]([^\\,]+)").Match(m.subtitles);
                        while (match.Success)
                        {
                            string srt = m.file.Replace("/hls.m3u8", "/") + match.Groups[2].Value;
                            subtitles.Append(match.Groups[1].Value, onstreamfile.Invoke(srt));
                            match = match.NextMatch();
                        }
                    }
                    #endregion

                    mtpl.Append(m.title, onstreamfile.Invoke(m.file), subtitles: subtitles, vast: vast, headers: headers);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                if (s == -1)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    var tpl = new SeasonTpl();
                    var hash = new HashSet<int>();

                    foreach (var voice in root.serial.OrderBy(i => i.seasons))
                    {
                        if (hash.Contains(voice.seasons))
                            continue;

                        hash.Add(voice.seasons);

                        string link = host + $"lite/fancdn?rjson={rjson}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&s={voice.seasons}";
                        tpl.Append($"{voice.seasons} —Å–µ–∑–æ–Ω", link, voice.seasons);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                    #endregion
                }
                else
                {
                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var vtpl = new VoiceTpl();

                    foreach (var voice in root.serial)
                    {
                        if (s != voice.seasons)
                            continue;

                        if (t == -1)
                            t = voice.id;

                        string link = host + $"lite/fancdn?rjson={rjson}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&s={s}&t={voice.id}";
                        bool active = t == voice.id;

                        vtpl.Append(voice.title, active, link);
                    }
                    #endregion

                    var episodes = root.serial.First(i => i.id == t).folder[s.ToString()].folder;

                    var etpl = new EpisodeTpl(episodes.Count);
                    string sArhc = s.ToString();

                    foreach (var episode in episodes)
                        etpl.Append($"{episode.Key} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.Key, onstreamfile.Invoke(episode.Value.file), vast: vast, headers: headers);

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/VoKino.cs
```
Ôªøusing Newtonsoft.Json.Linq;
using Shared.Models.Base;
using Shared.Models.Online.Settings;
using Shared.Models.Online.VoKino;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct VoKinoInvoke
    {
        #region VoKinoInvoke
        string host;
        string apihost;
        string token;
        Func<string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public VoKinoInvoke(string host, string apihost, string token, Func<string, ValueTask<string>> onget, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.token = token;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
        }
        #endregion

        public static void SendOnline(VokinoSettings init, List<(dynamic init, string name, string url, string plugin, int index)> online, JObject view)
        {
            var on = init.online;

            void send(string name, int x)
            {
                string url = "{localhost}/lite/vokino?balancer=" + name.ToLower();

                string displayname = $"{init.displayname ?? "VoKino"}";
                if (name != "VoKino")
                    displayname = $"{name} ({init.displayname ?? "VoKino"})";

                if (init.onlyBalancerName)
                    displayname = name;

                online.Add((init, displayname, url, (name == "VoKino" ? "vokino" : $"vokino-{name.ToLower()}"), init.displayindex > 0 ? (init.displayindex + x) : online.Count));
            }

            if (on.vokino && (view == null || view.ContainsKey("Vokino")))
                send("VoKino", 1);

            if (on.filmix && (view == null || view.ContainsKey("Filmix")))
                send("Filmix", 2);

            if (on.alloha && (view == null || view.ContainsKey("Alloha")))
                send("Alloha", 3);

            if (on.vibix && (view == null || view.ContainsKey("Vibix")))
                send("Vibix", 4);

            if (on.monframe && (view == null || view.ContainsKey("MonFrame")))
                send("MonFrame", 5);

            if (on.remux && (view == null || view.ContainsKey("Remux")))
                send("Remux", 6);

            if (on.ashdi && (view == null || view.ContainsKey("Ashdi")))
                send("Ashdi", 7);

            if (on.hdvb && (view == null || view.ContainsKey("Hdvb")))
                send("HDVB", 8);
        }

        #region Embed
        public async ValueTask<EmbedModel> Embed(string origid, long kinopoisk_id, string balancer, string t)
        {
            try
            {
                if (string.IsNullOrEmpty(balancer))
                {
                    string json = await onget($"{apihost}/v2/view/{origid ?? kinopoisk_id.ToString()}?token={token}");
                    if (json == null)
                    {
                        requesterror?.Invoke();
                        return null;
                    }

                    if (json.Contains("not found"))
                        return new EmbedModel() { IsEmpty = true };

                    var similars = new List<Similar>(10);

                    foreach (var item in JsonSerializer.Deserialize<JsonElement>(json).GetProperty("online").EnumerateObject())
                    {
                        string playlistUrl = item.Value.GetProperty("playlist_url").GetString();
                        if (string.IsNullOrEmpty(playlistUrl))
                            continue;

                        var model = new Similar()
                        {
                            title = item.Name,
                            balancer = Regex.Match(playlistUrl, "/v2/online/([^/]+)/").Groups[1].Value
                        };

                        if (item.Name == "Vokino")
                            similars.Insert(0, model);
                        else
                            similars.Add(model);
                    }

                    return new EmbedModel() { similars = similars };
                }
                else
                {
                    string uri = $"{apihost}/v2/online/{balancer}/{origid ?? kinopoisk_id.ToString()}?token={token}";
                    if (!string.IsNullOrEmpty(t))
                        uri += $"&{t}";

                    string json = await onget(uri);
                    if (json == null)
                    {
                        requesterror?.Invoke();
                        return null;
                    }

                    if (json.Contains("not found"))
                        return new EmbedModel() { IsEmpty = true };

                    var root = JsonSerializer.Deserialize<RootObject>(json);
                    if (root?.channels == null || root.channels.Length == 0)
                        return null;

                    return new EmbedModel() { menu = root.menu, channels = root.channels };
                }
            }
            catch { }

            return null;
        }
        #endregion

        #region Html
        public string Html(EmbedModel result, string origid, long kinopoisk_id, string title, string original_title, string balancer, string t, int s, VastConf vast = null, bool rjson = false)
        {
            if (result == null || result.IsEmpty)
                return string.Empty;

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            #region similar
            if (result.similars != null)
            {
                var stpl = new SimilarTpl(result.similars.Count);

                foreach (var similar in result.similars)
                {
                    string link = host + $"lite/vokino?rjson={rjson}&origid={origid}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&balancer={similar.balancer}";

                    stpl.Append(similar.title, string.Empty, string.Empty, link);
                }

                return rjson ? stpl.ToJson() : stpl.ToHtml();
            }
            #endregion

            if (result?.channels == null || result.channels.Length == 0)
                return string.Empty;

            #region –ü–µ—Ä–µ–≤–æ–¥—ã
            var voices = result?.menu?.FirstOrDefault(i => i.title == "–ü–µ—Ä–µ–≤–æ–¥")?.submenu;
            var vtpl = new VoiceTpl(voices != null ? voices.Length : 0);

            if (voices != null && voices.Length > 0)
            {
                foreach (var translation in voices)
                {
                    if (translation.playlist_url != null && translation.playlist_url.Contains("?"))
                    {
                        string _t = HttpUtility.UrlEncode(translation.playlist_url.Split("?")[1]);
                        vtpl.Append(translation.title, translation.selected, host + $"lite/vokino?rjson={rjson}&origid={origid}&kinopoisk_id={kinopoisk_id}&balancer={balancer}&title={enc_title}&original_title={enc_original_title}&t={_t}&s={s}");
                    }
                }
            }
            #endregion

            if (result!.channels.First().playlist_url == "submenu")
            {
                if (s == -1)
                {
                    var tpl = new SeasonTpl(quality: result.channels[0].quality_full?.Replace("2160p.", "4K "), result.channels.Length);

                    foreach (var ch in result.channels)
                    {
                        string sname = Regex.Match(ch.title, "^([0-9]+)").Groups[1].Value;
                        if (string.IsNullOrEmpty(sname))
                            sname = Regex.Match(ch.title, "([0-9]+)$").Groups[1].Value;

                        tpl.Append(ch.title, host + $"lite/vokino?rjson={rjson}&origid={origid}&kinopoisk_id={kinopoisk_id}&balancer={balancer}&title={enc_title}&original_title={enc_original_title}&t={t}&s={sname}", sname);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                }
                else
                {
                    var series = result.channels.First(i => i.title.StartsWith($"{s} ") || i.title.EndsWith($" {s}")).submenu;

                    var tpl = new EpisodeTpl(series.Length);

                    string sArhc = s.ToString();

                    foreach (var e in series)
                    {
                        string ename = Regex.Match(e.ident, "([0-9]+)$").Groups[1].Value;
                        tpl.Append(e.title, title ?? original_title, sArhc, ename, onstreamfile(e.stream_url), vast: vast);
                    }

                    if (rjson)
                        return tpl.ToJson(vtpl);

                    return vtpl.ToHtml() + tpl.ToHtml();
                }
            }
            else
            {
                var mtpl = new MovieTpl(title, original_title, result.channels.Length);

                foreach (var ch in result!.channels)
                {
                    string name = ch.quality_full;
                    if (!string.IsNullOrWhiteSpace(name.Replace("2160p.", "")))
                    {
                        name = name.Replace("2160p.", "4K ");

                        if (ch.extra != null && ch.extra.TryGetValue("size", out string size) && !string.IsNullOrEmpty(size))
                            name += $" - {size}";
                    }

                    mtpl.Append(name, onstreamfile(ch.stream_url), vast: vast);
                }

                if (rjson)
                    return mtpl.ToJson(vtpl: vtpl);

                return vtpl.ToHtml() + mtpl.ToHtml();
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Zetflix.cs
```
Ôªøusing Shared.Models;
using Shared.Models.Base;
using Shared.Models.Online.Zetflix;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct ZetflixInvoke
    {
        #region ZetflixInvoke
        string host, apihost;
        bool usehls;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Func<string, List<HeadersModel>, ValueTask<string>> onget;

        public ZetflixInvoke(string host, string apihost, bool hls, Func<string, List<HeadersModel>, ValueTask<string>> onget, Func<string, string> onstreamfile, Func<string, string> onlog = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.onget = onget;
            usehls = hls;
        }
        #endregion

        #region Embed
        public async ValueTask<EmbedModel> Embed(long kinopoisk_id, int s)
        {
            string html = await onget.Invoke($"{apihost}/iplayer/videodb.php?kp={kinopoisk_id}" + (s > 0 ? $"&season={s}" : ""), HeadersModel.Init(
                ("dnt", "1"),
                ("pragma", "no-cache"),
                ("referer", "https://www.google.com/"),
                ("upgrade-insecure-requests", "1")
            ));

            return Embed(html);
        }

        public EmbedModel Embed(in string html)
        {
            onlog?.Invoke(html ?? "html null");

            if (html == null)
                return null;

            string quality = html.Contains("1080p") ? "1080p" : html.Contains("720p") ? "720p" : "480p";
            string check_url = Regex.Match(html, "(https?://[^\\[\\|,\n\r\t ]+\\.mp4)").Groups[1].Value;

            string file = Regex.Match(html, "file:(\\[[^\n\r]+\\])(,|}\\) ;)").Groups[1].Value;
            if (string.IsNullOrWhiteSpace(file))
            {
                file = Regex.Match(html, "file:\"([^\"]+)\"").Groups[1].Value;
                if (!string.IsNullOrWhiteSpace(file))
                    return new EmbedModel() { pl = new List<RootObject>() { new RootObject() { file = file, title = "–î—É–±–ª—è–∂" } }, movie = true, quality = quality, check_url = check_url };

                return null;
            }

            file = Regex.Replace(file.Trim(), "(\\{|, )([a-z]+): ?", "$1\"$2\":")
                        .Replace("},]", "}]");

            List<RootObject> pl = null;

            try
            {
                pl = JsonSerializer.Deserialize<List<RootObject>>(file);
                if (pl == null || pl.Count == 0)
                    return null;
            }
            catch { return null; }

            return new EmbedModel() { pl = pl, movie = !file.Contains("\"comment\":"), quality = quality, check_url = check_url };
        }
        #endregion

        #region number_of_seasons
        public async ValueTask<int> number_of_seasons(long id)
        {
            int number_of_seasons = 1;
            string themoviedb = await onget.Invoke($"https://tmdb.mirror-kurwa.men/3/tv/{id}?api_key=4ef0d7355d9ffb5151e987764708ce96", null);

            if (themoviedb != null)
            {
                try
                {
                    var root = JsonSerializer.Deserialize<JsonObject>(themoviedb);
                    number_of_seasons = root["number_of_seasons"].GetValue<int>();
                    if (1 > number_of_seasons)
                        number_of_seasons = 1;
                }
                catch { }
            }

            if (0 >= number_of_seasons)
                number_of_seasons = 1;

            return number_of_seasons;
        }
        #endregion

        #region Html
        public string Html(EmbedModel root, int number_of_seasons, long kinopoisk_id, string title, string original_title, string t, int s, bool isbwa = false, bool rjson = false, VastConf vast = null)
        {
            if (root?.pl == null || root.pl.Count == 0)
                return string.Empty;

            if (root.movie)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, root.pl.Count);

                foreach (var pl in root.pl)
                {
                    string name = pl.title;
                    string file = pl.file;

                    if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(file))
                        continue;

                    var streamquality = new StreamQualityTpl();

                    foreach (Match m in Regex.Matches(file, $"\\[(1080|720|480|360)p?\\]([^\\[\\|,\n\r\t ]+\\.(mp4|m3u8))"))
                    {
                        string link = m.Groups[2].Value;
                        if (string.IsNullOrEmpty(link))
                            continue;

                        if (usehls && !link.Contains(".m3u"))
                            link += ":hls:manifest.m3u8";
                        else if (!usehls && link.Contains(".m3u"))
                            link = link.Replace(":hls:manifest.m3u8", "");

                        if (isbwa)
                            link = Regex.Replace(link, "/([0-9]+)\\.(m3u8|mp4)", $"/{m.Groups[1].Value}.$2");

                        streamquality.Insert(onstreamfile.Invoke(link), $"{m.Groups[1].Value}p");
                    }

                    mtpl.Append(name, streamquality.Firts().link, streamquality: streamquality, vast: vast);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                if (s == -1)
                {
                    var tpl = new SeasonTpl(root.quality);

                    for (int i = 1; i <= number_of_seasons; i++)
                    {
                        string link = host + $"lite/zetflix?rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&s={i}";
                        tpl.Append($"{i} —Å–µ–∑–æ–Ω", link, i);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                }
                else
                {
                    var vtpl = new VoiceTpl();
                    var etpl = new EpisodeTpl();
                    var hashvoices = new HashSet<string>();

                    string sArhc = s.ToString();

                    foreach (var episode in root.pl.AsEnumerable().Reverse())
                    {
                        var episodes = episode.folder;
                        if (episodes == null || episodes.Length == 0)
                            continue;

                        string perevod = episode.title;
                        if (perevod != null && string.IsNullOrEmpty(t))
                            t = perevod;

                        #region –ü–µ—Ä–µ–≤–æ–¥—ã
                        if (perevod != null && !hashvoices.Contains(perevod))
                        {
                            hashvoices.Add(perevod);
                            string link = host + $"lite/zetflix?rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&s={s}&t={HttpUtility.UrlEncode(perevod)}";

                            vtpl.Append(perevod, t == perevod, link);
                        }
                        #endregion

                        if (perevod != t)
                            continue;

                        foreach (var pl in episodes)
                        {
                            string name = pl.comment;
                            string file = pl.file;

                            if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(file))
                                continue;

                            var streamquality = new StreamQualityTpl();

                            foreach (Match m in Regex.Matches(file, $"\\[(1080|720|480|360)p?\\]([^\\[\\|,\n\r\t ]+\\.(mp4|m3u8))"))
                            {
                                string link = m.Groups[2].Value;
                                if (string.IsNullOrEmpty(link))
                                    continue;

                                if (usehls && !link.Contains(".m3u"))
                                    link += ":hls:manifest.m3u8";
                                else if (!usehls && link.Contains(".m3u"))
                                    link = link.Replace(":hls:manifest.m3u8", "");

                                if (isbwa)
                                    link = Regex.Replace(link, "/([0-9]+)\\.(m3u8|mp4)", $"/{m.Groups[1].Value}.$2");

                                streamquality.Insert(onstreamfile.Invoke(link), $"{m.Groups[1].Value}p");
                            }

                            etpl.Append(name, title ?? original_title, sArhc, Regex.Match(name, "^([0-9]+)").Groups[1].Value, streamquality.Firts().link, streamquality: streamquality, vast: vast);
                        }
                    }

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/KinoPub.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.KinoPub;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public class KinoPubInvoke
    {
        #region KinoPubInvoke
        string host, token;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public KinoPubInvoke(string host, string apihost, string token, Func<string, ValueTask<string>> onget, Func<string, string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.token = token;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
        }
        #endregion

        #region Search
        async public Task<SearchResult> Search(string title, string original_title, int year, int clarification, string imdb_id, long kinopoisk_id)
        {
            if (string.IsNullOrEmpty(title ?? original_title))
                return null;

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            #region goSearch
            async Task<SearchResult> goSearch(string q)
            {
                if (string.IsNullOrEmpty(q))
                    return null;

                string json = await onget($"{apihost}/v1/items/search?q={HttpUtility.UrlEncode(q)}&access_token={token}&field=title&perpage=200");
                if (json == null)
                {
                    requesterror?.Invoke();
                    return null;
                }

                try
                {
                    var items = JsonSerializer.Deserialize<SearchObject>(json)?.items;
                    if (items != null)
                    {
                        var ids = new List<int>(items.Length);
                        var result = new SearchResult() { similars = new SimilarTpl(items.Length) };

                        string _q = StringConvert.SearchName(q);

                        foreach (var item in items)
                        {
                            string img = PosterApi.Size(item.posters?.Skip(1)?.First().Value);
                            result.similars.Value.Append(item.title, item.year.ToString(), item.voice, host + $"lite/kinopub?postid={item.id}&title={enc_title}&original_title={enc_original_title}", img);

                            if ((item.kinopoisk > 0 && item.kinopoisk == kinopoisk_id) || $"tt{item.imdb}" == imdb_id)
                            {
                                if (item.type != "3d")
                                    result.id = item.id;
                            }
                            else
                            {
                                if (item.year == year || (item.year == year - 1) || (item.year == year + 1))
                                {
                                    string _t = StringConvert.SearchName(item.title);

                                    if (!string.IsNullOrEmpty(_t) && !string.IsNullOrEmpty(_q))
                                    {
                                        if (_t.StartsWith(_q) || _t.EndsWith(_q))
                                            ids.Add(item.id);
                                    }
                                }
                            }
                        }

                        if (ids.Count == 1 && result.id == 0)
                            result.id = ids[0];

                        return result;
                    }
                }
                catch { }

                return null;
            }
            #endregion

            if (clarification == 1)
                return await goSearch(title);

            return (await goSearch(original_title)) ?? (await goSearch(title));
        }
        #endregion

        #region Post
        async public Task<RootObject> Post(int postid)
        {
            string json = await onget($"{apihost}/v1/items/{postid}?access_token={token}");
            if (json == null)
            {
                requesterror?.Invoke();
                return null;
            }

            try
            {
                var root = JsonSerializer.Deserialize<RootObject>(json);
                if (root?.item.seasons == null && root?.item.videos == null)
                    return null;

                return root;
            }
            catch { return null; }
        }
        #endregion

        #region Html
        public string Html(RootObject root, string filetype, string title, string original_title, int postid, int s = -1, int t = -1, string codec = null, VastConf vast = null, bool rjson = false)
        {
            if (root == null)
                return string.Empty;

            if (root?.item.videos != null)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, root.item.videos.Length);

                if (filetype == "hls")
                {
                    foreach (var a in root.item.videos[0].audios)
                    {
                        var streamquality = new StreamQualityTpl();

                        foreach (var f in root.item.videos[0].files)
                        {
                            if (!string.IsNullOrEmpty(f.url.hls))
                                streamquality.Append(onstreamfile(f.url.hls.Replace("a1.m3u8", $"a{a.index}.m3u8"), null), f.quality);
                        }

                        if (!streamquality.Any())
                            continue;

                        string voice = a.type?.title ?? a.lang ?? "–æ—Ä–∏–≥–∏–Ω–∞–ª";
                        if (!string.IsNullOrEmpty(a?.author?.title))
                            voice += $" ({a.author.title})";

                        #region subtitle
                        var subtitles = new SubtitleTpl(root.item.videos[0]?.subtitles?.Length ?? 0);

                        if (root.item.videos[0].subtitles != null)
                        {
                            foreach (var sub in root.item.videos[0].subtitles)
                            {
                                if (sub.url != null)
                                    subtitles.Append(sub.lang, onstreamfile(sub.url, null));
                            }
                        }

                        string subtitles_call = null;
                        if (subtitles.IsEmpty())
                            subtitles_call = host + $"lite/kinopub/subtitles.json?mid={root.item.videos[0].id}";
                        #endregion

                        mtpl.Append(voice, streamquality.Firts().link, streamquality: streamquality, subtitles: subtitles, subtitles_call: subtitles_call, voice_name: a.codec, vast: vast);
                    }
                }
                else
                {
                    foreach (var v in root.item.videos)
                    {
                        #region voicename
                        string voicename = string.Empty;

                        if (v.audios != null)
                        {
                            foreach (var audio in v.audios)
                            {
                                if (audio.lang == "eng")
                                {
                                    if (!voicename.Contains(audio.lang))
                                        voicename += "eng, ";
                                }
                                else
                                {
                                    string a = audio?.author?.title ?? audio?.type?.title;
                                    if (a != null)
                                    {
                                        a = $"{a} ({audio.lang})";
                                        if (!voicename.Contains(a))
                                            voicename += $"{a}, ";
                                    }
                                }
                            }

                            voicename = Regex.Replace(voicename, "[, ]+$", "");
                        }
                        #endregion

                        if (filetype == "hls4")
                        {
                            if (v.files[0].url.hls4 != null)
                                mtpl.Append(v.files[0].quality, onstreamfile(v.files[0].url.hls4, null), voice_name: voicename, vast: vast);
                        }
                        else
                        {
                            if (v.files[0].url.http == null)
                                continue;

                            #region subtitle
                            var subtitles = new SubtitleTpl(v.subtitles?.Length ?? 0);

                            if (v.subtitles != null)
                            {
                                foreach (var sub in v.subtitles)
                                {
                                    if (sub.url != null)
                                        subtitles.Append(sub.lang, onstreamfile(sub.url, null));
                                }
                            }

                            string subtitles_call = null;
                            if (subtitles.IsEmpty())
                                subtitles_call = host + $"lite/kinopub/subtitles.json?mid={v.id}";
                            #endregion

                            var streamquality = new StreamQualityTpl(v.files.Select(f => (onstreamfile(f.url.http, f.file), f.quality)));
                            var first = streamquality.Firts();

                            mtpl.Append(first.quality, first.link, subtitles: subtitles, subtitles_call: subtitles_call, voice_name: voicename, streamquality: streamquality, vast: vast);
                        }
                    }
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                if (root?.item.seasons == null || root.item.seasons.Length == 0)
                    return string.Empty;

                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                if (s == -1)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    var tpl = new SeasonTpl(root.item.quality > 0 ? $"{root.item.quality}p" : null, root.item.seasons.Length);

                    foreach (var season in root.item.seasons)
                    {
                        string link = host + $"lite/kinopub?rjson={rjson}&postid={postid}&title={enc_title}&original_title={enc_original_title}&s={season.number}";
                        tpl.Append($"{season.number} —Å–µ–∑–æ–Ω", link, season.number);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∏
                    string sArhc = s.ToString();

                    if (filetype == "hls")
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();
                        var hash = new HashSet<string>();

                        foreach (var a in root.item.seasons.First(i => i.number == s).episodes[0].audios)
                        {
                            string voice = a?.author?.title ?? a?.type?.title;

                            int? idt = a?.author?.id;
                            if (idt == null)
                                idt = a?.type?.id ?? null;

                            if (idt == null)
                            {
                                if (a.lang == "eng")
                                {
                                    idt = 6;
                                    voice = "–û—Ä–∏–≥–∏–Ω–∞–ª";
                                }
                                else
                                {
                                    idt = 1;
                                    voice = "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é";
                                }
                            }

                            if (string.IsNullOrEmpty(voice))
                                continue;

                            if (t == -1)
                            {
                                t = (int)idt;
                                codec = a.codec;
                            }

                            if (!hash.Contains($"{voice}:{a.codec}"))
                            {
                                hash.Add($"{voice}:{a.codec}");

                                string link = host + $"lite/kinopub?rjson={rjson}&postid={postid}&title={enc_title}&original_title={enc_original_title}&s={s}&t={idt}&codec={a.codec}";
                                bool active = t == idt && (codec == null || codec == a.codec);

                                vtpl.Append($"{voice} ({a.codec})", active, link);
                            }
                            }
                            #endregion

                        #region –°–µ—Ä–∏–∏
                        var etpl = new EpisodeTpl();

                        foreach (var episode in root.item.seasons.First(i => i.number == s).episodes)
                        {
                            int voice_index = -1;
                            if (t == 1)
                            {
                                voice_index = t;
                            }
                            else
                            {
                                foreach (var a in episode.audios)
                                {
                                    int? idt = a?.author?.id;
                                    if (idt == null)
                                        idt = a?.type?.id;

                                    if ((idt != null && t == (int)idt && (codec == null || codec == a.codec)) ||
                                        (t == 6 && a.lang == "eng"))
                                    {
                                        voice_index = a!.index;
                                        break;
                                    }
                                }

                                if (voice_index == -1)
                                    break;
                            }

                            var streamquality = new StreamQualityTpl();

                            foreach (var f in episode.files)
                            {
                                if (!string.IsNullOrEmpty(f.url.hls))
                                    streamquality.Append(onstreamfile(f.url.hls.Replace("a1.m3u8", $"a{voice_index}.m3u8"), null), f.quality);
                            }

                            #region subtitle
                            var subtitles = new SubtitleTpl(episode.subtitles?.Length ?? 0);

                            if (episode.subtitles != null)
                            {
                                foreach (var sub in episode.subtitles)
                                {
                                    if (sub.url != null)
                                        subtitles.Append(sub.lang, onstreamfile(sub.url, null));
                                }
                            }

                            string subtitles_call = null;
                            if (subtitles.IsEmpty())
                                subtitles_call = host + $"lite/kinopub/subtitles.json?mid={episode.id}";
                            #endregion

                            etpl.Append($"{episode.number} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.number.ToString(), streamquality.Firts().link, streamquality: streamquality, subtitles: subtitles, subtitles_call: subtitles_call, vast: vast);
                        }
                        #endregion

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                    else
                    {
                        var episodes = root.item.seasons.First(i => i.number == s).episodes;

                        var etpl = new EpisodeTpl(episodes.Length);

                        foreach (var episode in episodes)
                        {
                            #region voicename
                            string voicename = string.Empty;

                            if (episode.audios != null)
                            {
                                foreach (var audio in episode.audios)
                                {
                                    string a = audio.author?.title ?? audio.lang;
                                    if (a != null && !voicename.Contains(a) && a != "rus")
                                        voicename += $"{a}, ";
                                }

                                voicename = Regex.Replace(voicename, "[, ]+$", "");
                            }
                            #endregion

                            if (filetype == "hls4")
                            {
                                if (episode.files[0].url.hls4 == null)
                                    continue;

                                etpl.Append($"{episode.number} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.number.ToString(), onstreamfile(episode.files[0].url.hls4, null), voice_name: voicename, vast: vast);
                            }
                            else
                            {
                                if (episode.files[0].url.http == null)
                                    continue;

                                #region subtitle
                                var subtitles = new SubtitleTpl(episode.subtitles?.Length ?? 0);

                                if (episode.subtitles != null)
                                {
                                    foreach (var sub in episode.subtitles)
                                    {
                                        if (sub.url != null)
                                            subtitles.Append(sub.lang, onstreamfile(sub.url, null));
                                    }
                                }

                                string subtitles_call = null;
                                if (subtitles.IsEmpty())
                                    subtitles_call = host + $"lite/kinopub/subtitles.json?mid={episode.id}";
                                #endregion

                                #region streams
                                var streamquality = new StreamQualityTpl();

                                foreach (var f in episode.files)
                                {
                                    if (f.url.http != null)
                                        streamquality.Append(onstreamfile(f.url.http, f.file), f.quality);
                                }
                                #endregion

                                etpl.Append($"{episode.number} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.number.ToString(), streamquality.Firts().link, subtitles: subtitles, subtitles_call: subtitles_call, voice_name: voicename, streamquality: streamquality, vast: vast);
                            }
                        }

                        return rjson ? etpl.ToJson() : etpl.ToHtml();
                    }
                    #endregion
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Redheadsound.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.Redheadsound;
using Shared.Models.Templates;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct RedheadsoundInvoke
    {
        #region RedheadsoundInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public RedheadsoundInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.onpost = onpost;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        async public Task<EmbedModel> Embed(string title, int year)
        {
            if (string.IsNullOrEmpty(title))
                return null;

            string mainHtml = await onget(apihost);
            string user_hash = Regex.Match(mainHtml ?? "", "var dle_login_hash([\t ]+)?=([\t ]+)?'(?<hash>[a-f0-9]+)'").Groups["hash"].Value;
            if (string.IsNullOrEmpty(user_hash))
                return null;

            string search = await onpost($"{apihost}/engine/ajax/controller.php?mod=search", $"query={HttpUtility.UrlEncode(title)}&skin=rhs_new&user_hash={user_hash}");
            if (search == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string link = null, reservedlink = null;
            foreach (var node in HtmlParse.Nodes(search, "//div[@class='move-item']"))
            {
                string rowTitle = StringConvert.SearchName(node.SelectText(".//h4[@class='title']//a"));
                if (rowTitle == null)
                    continue;

                if (rowTitle.Contains(StringConvert.SearchName(title)))
                {
                    string rlnk = node.SelectText(".//a[@class='move-item__img']", "href");
                    if (rlnk == null)
                        continue;

                    reservedlink = rlnk;

                    if (node.SelectText(".//span[contains(@class, 'year')]//a") == year.ToString())
                    {
                        link = reservedlink;
                        break;
                    }
                }
            }

            if (string.IsNullOrEmpty(link))
            {
                if (string.IsNullOrEmpty(reservedlink))
                {
                    if (search.Contains("notfound"))
                        return new EmbedModel() { IsEmpty = true };

                    return null;
                }

                link = reservedlink;
            }

            string news = await onget(link);
            if (news == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string iframeUri = Regex.Match(news, "videoUrl([\t ]+)?=([\t ]+)?'(?<uri>https?://[^']+)'").Groups["uri"].Value;
            if (string.IsNullOrEmpty(iframeUri))
                return null;

            string iframe = await onget(iframeUri);
            if (string.IsNullOrEmpty(iframe))
            {
                requesterror?.Invoke();
                return null;
            }

            string contentUrl = Regex.Match(iframe, "\"contentUrl\": ?\"([^\"]+)\"").Groups[1].Value;
            if (string.IsNullOrEmpty(contentUrl))
                return null;

            return new EmbedModel() { iframe = contentUrl };
        }
        #endregion

        #region Html
        public string Html(EmbedModel content, string title, VastConf vast = null, bool rjson = false)
        {
            if (content == null || content.IsEmpty)
                return string.Empty;

            var mtpl = new MovieTpl(title, null, 1);

            mtpl.Append("1080p", onstreamfile(content.iframe.Replace("&amp;", "&")));

            return rjson ? mtpl.ToJson() : mtpl.ToHtml();
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Kinoukr.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.Eneyida;
using Shared.Models.Templates;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct KinoukrInvoke
    {
        #region unic
        static string ArrayList => "qwertyuioplkjhgfdsazxcvbnm";
        static string ArrayListToNumber => "1234567890";
        public static string unic(int size = 8, bool IsNumberCode = false)
        {
            StringBuilder array = new StringBuilder();
            for (int i = 0; i < size; i++)
            {
                array.Append(IsNumberCode ? ArrayListToNumber[Random.Shared.Next(0, ArrayListToNumber.Length)] : ArrayList[Random.Shared.Next(0, ArrayList.Length)]);
            }

            return array.ToString();
        }
        #endregion

        #region KinoukrInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public KinoukrInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onpost = onpost;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        public async ValueTask<EmbedModel> Embed(string original_title, int year, string href)
        {
            if (string.IsNullOrWhiteSpace(href) && (string.IsNullOrWhiteSpace(original_title) || year == 0))
                return null;

            return null;

            string link = href;
            var result = new EmbedModel();

            if (string.IsNullOrWhiteSpace(link))
            {
                onlog?.Invoke("search start");
                //string? search = await onget.Invoke($"{apihost}/index.php?do=search&subaction=search&from_page=0&story={HttpUtility.UrlEncode(original_title)}");

                // $"{apihost}/index.php?do=search"
                string search = await onpost.Invoke($"{apihost}/{unic(4, true)}-{unic(Random.Shared.Next(4, 8))}-{unic(Random.Shared.Next(5, 10))}.html", $"do=search&subaction=search&story={HttpUtility.UrlEncode(original_title)}");
                if (search == null)
                {
                    requesterror?.Invoke();
                    return null;
                }

                onlog?.Invoke("search ok");

                foreach (string row in search.Split("\"short clearfix with-mask\"").Skip(1))
                {
                    if (row.Contains(">–ê–Ω–æ–Ω—Å</div>") || row.Contains(">–¢—Ä–µ–π–ª–µ—Ä</div>"))
                        continue;

                    string newslink = Regex.Match(row, "href=\"(https?://[^/]+/[^\"]+\\.html)\"").Groups[1].Value;
                    if (string.IsNullOrWhiteSpace(newslink))
                        continue;

                    string name = Regex.Match(row, "class=\"short-title\" [^>]+>([^<]+)<").Groups[1].Value;
                    if (result.similars == null)
                        result.similars = new List<Similar>();

                    result.similars.Add(new Similar() 
                    {
                        title = name,
                        href = newslink
                    });
                }

                if (result.similars == null || result.similars.Count == 0)
                {
                    if (search.Contains(">–ü–æ—à—É–∫ –ø–æ —Å–∞–π—Ç—É<"))
                        return new EmbedModel() { IsEmpty = true };

                    return null;
                }

                if (result.similars.Count > 1)
                    return result;

                link = result.similars[0].href;
            }

            onlog?.Invoke("link: " + link);
            string news = await onget.Invoke(link);
            if (news == null)
            {
                requesterror?.Invoke();
                return null;
            }

            result.quel = Regex.Match(news, "class=\"m-meta m-qual\">([^<]+)<").Groups[1].Value;

            string iframeUri = Regex.Match(news, "src=\"(https?://tortuga\\.[a-z]+/[^\"]+)\"").Groups[1].Value;
            if (string.IsNullOrEmpty(iframeUri))
            {
                iframeUri = Regex.Match(news, "src=\"(https?://ashdi\\.vip/[^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(iframeUri))
                    return null;
            }

            onlog?.Invoke("iframeUri: " + iframeUri);
            string content = await onget.Invoke(iframeUri);
            if (content == null || !content.Contains("file:"))
            {
                requesterror?.Invoke();
                return null;
            }

            string player = StringConvert.FindLastText(content, "new Playerjs", "</script>");
            if (player == null)
                return null;

            if (Regex.IsMatch(content, "file: ?'\\["))
            {
                Models.Online.Tortuga.Voice[] root = null;

                try
                {
                    root = JsonSerializer.Deserialize<Models.Online.Tortuga.Voice[]>(Regex.Match(content, "file: ?'([^\n\r]+)',").Groups[1].Value);
                    if (root == null || root.Length == 0)
                        return null;
                }
                catch { return null; }

                result.serial = root;
            }
            else
            {
                result.content = player;
                onlog?.Invoke("content: " + result.content);
            }

            return result;
        }
        #endregion

        #region EmbedKurwa
        public async ValueTask<EmbedModel> EmbedKurwa(int clarification, string title, string original_title, int year, string href)
        {
            string iframeUri = href;
            var result = new EmbedModel();

            if (string.IsNullOrEmpty(iframeUri))
            {
                string arg = clarification == 1 || string.IsNullOrWhiteSpace(original_title) 
                    ? $"name={HttpUtility.UrlEncode(title)}" 
                    : $"eng_name={HttpUtility.UrlEncode(original_title)}";

                string json = await onget.Invoke("http://194.246.82.144/ukr?" + arg);
                if (json == null)
                {
                    requesterror?.Invoke();
                    return null;
                }

                result.similars = new List<Similar>();

                try
                {
                    foreach (var item in JsonSerializer.Deserialize<BobrKurwa[]>(json))
                    {
                        var model = new Similar()
                        {
                            href = item.tortuga ?? item.ashdi,
                            title = $"{item.name} / {item.eng_name}",
                            year = item.year
                        };

                        if (item.year == year.ToString())
                            result.similars.Insert(0, model);
                        else
                            result.similars.Add(model);
                    }
                }
                catch { }

                if (result.similars.Count == 0)
                    return new EmbedModel() { IsEmpty = true };

                if (result.similars.Count > 1 && result.similars[0].year != year.ToString())
                    return result;

                iframeUri = result.similars[0].href;
            }

            onlog?.Invoke("iframeUri: " + iframeUri);
            string content = await onget.Invoke(iframeUri);
            if (content == null || !content.Contains("file:"))
            {
                requesterror?.Invoke();
                return null;
            }

            if (iframeUri.Contains("ashdi"))
            {
                result.source_type = "ashdi";

                if (Regex.IsMatch(content, "file: ?'\\["))
                {
                    Models.Online.Ashdi.Voice[] root = null;

                    try
                    {
                        root = JsonSerializer.Deserialize<Models.Online.Ashdi.Voice[]>(Regex.Match(content, "file: ?'([^\n\r]+)',").Groups[1].Value);
                        if (root == null || root.Length == 0)
                            return null;
                    }
                    catch { return null; }

                    result.serial_ashdi = root;
                }
                else
                {
                    result.content = content;
                    onlog?.Invoke("content: " + result.content);
                }

                return result;
            }
            else
            {
                result.source_type = "tortuga";

                if (Regex.IsMatch(content, "file: ?'"))
                {
                    Models.Online.Tortuga.Voice[] root = null;

                    try
                    {
                        string file = Regex.Match(content, "file: ?'([^\n\r]+)',").Groups[1].Value;
                        if (file.EndsWith("=="))
                        {
                            file = Regex.Replace(file, "==$", "");
                            file = string.Join("", CrypTo.DecodeBase64(file).Reverse());
                        }

                        root = JsonSerializer.Deserialize<Models.Online.Tortuga.Voice[]>(file);
                        if (root == null || root.Length == 0)
                            return null;
                    }
                    catch { return null; }

                    result.serial = root;
                }
                else
                {
                    string player = StringConvert.FindLastText(content, "new TortugaCore", "</script>");

                    result.content = player ?? content;
                    onlog?.Invoke("content: " + result.content);
                }
            }

            return result;
        }
        #endregion

        #region getIframeSource
        public async ValueTask<string> getIframeSource(string link)
        {
            if (string.IsNullOrWhiteSpace(link))
                return null;

            string news = await onget.Invoke(link);
            if (news == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string iframeUri = Regex.Match(news, "src=\"(https?://tortuga\\.[a-z]+/[^\"]+)\"").Groups[1].Value;
            if (string.IsNullOrEmpty(iframeUri))
            {
                iframeUri = Regex.Match(news, "src=\"(https?://ashdi\\.vip/[^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(iframeUri))
                    return null;
            }

            return iframeUri;
        }
        #endregion

        #region Html
        public string Html(EmbedModel result, int clarification, string title, string original_title, int year, string t, int s, string href, VastConf vast = null, bool rjson = false)
        {
            if (result == null || result.IsEmpty)
                return string.Empty;

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);
            string enc_href = HttpUtility.UrlEncode(href);

            #region similar
            if (result.content == null && result.serial == null && result.serial_ashdi == null)
            {
                if (string.IsNullOrWhiteSpace(href) && result.similars != null && result.similars.Count > 0)
                {
                    var stpl = new SimilarTpl(result.similars.Count);

                    foreach (var similar in result.similars)
                    {
                        string link = host + $"lite/kinoukr?rjson={rjson}&clarification={clarification}&title={enc_title}&original_title={enc_original_title}&year={year}&href={HttpUtility.UrlEncode(similar.href)}";

                        stpl.Append(similar.title, similar.year, string.Empty, link);
                    }

                    return rjson ? stpl.ToJson() : stpl.ToHtml();
                }

                return string.Empty;
            }
            #endregion

            if (result.source_type == "ashdi")
            {
                var invk = new AshdiInvoke(host, apihost, onget, onstreamfile, onlog: onlog, requesterror: requesterror);
                int.TryParse(t, out int _t);

                var md = new Models.Online.Ashdi.EmbedModel()
                {
                    content = result.content,
                    serial = result.serial_ashdi
                };

                return invk.Html(md, 0, title, original_title, _t, s, vast, rjson, host + $"lite/kinoukr?rjson={rjson}&clarification={clarification}&title={enc_title}&original_title={enc_original_title}&year={year}&href={enc_href}");
            }

            if (result.content != null)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, 1);

                string hls = Regex.Match(result.content, "file: ?(\"|')(?<hls>https?://[^\"']+/index\\.m3u8)(\"|')").Groups["hls"].Value;
                if (string.IsNullOrWhiteSpace(hls))
                {
                    string base64 = Regex.Match(result.content, "file: ?(\"|')(?<base64>[^\"']+)(\"|')").Groups["base64"].Value;
                           base64 = Regex.Replace(base64, "==$", "");

                    hls = string.Join("", CrypTo.DecodeBase64(base64).Reverse());

                    if (string.IsNullOrWhiteSpace(hls))
                        return string.Empty;
                }

                #region subtitle
                var subtitles = new SubtitleTpl();
                string subtitle = new Regex("\"subtitle\": ?\"([^\"]+)\"").Match(result.content).Groups[1].Value;

                if (!string.IsNullOrEmpty(subtitle))
                {
                    var match = new Regex("\\[([^\\]]+)\\](https?://[^\\,]+)").Match(subtitle);
                    while (match.Success)
                    {
                        subtitles.Append(match.Groups[1].Value, onstreamfile.Invoke(match.Groups[2].Value));
                        match = match.NextMatch();
                    }
                }
                #endregion

                mtpl.Append(string.IsNullOrEmpty(result.quel) ? "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é" : result.quel, onstreamfile.Invoke(hls), subtitles: subtitles, vast: vast);

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                try
                {
                    if (s == -1)
                    {
                        #region –°–µ–∑–æ–Ω—ã
                        var tpl = new SeasonTpl();

                        foreach (var season in result.serial)
                        {
                            string link = host + $"lite/kinoukr?rjson={rjson}&clarification={clarification}&title={enc_title}&original_title={enc_original_title}&year={year}&href={enc_href}&s={season.season}";

                            tpl.Append(season.title, link, season.season);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                        #endregion
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();
                        var hashVoice = new HashSet<string>();

                        foreach (var season in result.serial)
                        {
                            foreach (var episode in season.folder)
                            {
                                foreach (var voice in episode.folder)
                                {
                                    if (hashVoice.Contains(voice.title))
                                        continue;
                                    hashVoice.Add(voice.title);

                                    if (string.IsNullOrEmpty(t))
                                        t = voice.title;

                                    string link = host + $"lite/kinoukr?rjson={rjson}&clarification={clarification}&title={enc_title}&original_title={enc_original_title}&year={year}&href={enc_href}&s={s}&t={voice.title}";
                                    vtpl.Append(voice.title, t == voice.title, link);
                                }
                            }
                        }
                        #endregion

                        string sArhc = s.ToString();
                        var episodes = result.serial.First(i => i.season == sArhc).folder;
                        var etpl = new EpisodeTpl(episodes.Length);

                        foreach (var episode in episodes)
                        {
                            var video = episode.folder.FirstOrDefault(i => i.title == t);
                            if (video.file == null)
                                continue;

                            #region subtitle
                            var subtitles = new SubtitleTpl();

                            if (!string.IsNullOrEmpty(video.subtitle))
                            {
                                var match = new Regex("\\[([^\\]]+)\\](https?://[^\\,]+)").Match(video.subtitle);
                                while (match.Success)
                                {
                                    subtitles.Append(match.Groups[1].Value, onstreamfile.Invoke(match.Groups[2].Value));
                                    match = match.NextMatch();
                                }
                            }
                            #endregion

                            string file = onstreamfile.Invoke(video.file);
                            etpl.Append(episode.title, title ?? original_title, sArhc, episode.number, file, subtitles: subtitles, vast: vast);
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                }
                catch
                {
                    return string.Empty;
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Ashdi.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.Ashdi;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct AshdiInvoke
    {
        #region AshdiInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public AshdiInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        public async ValueTask<EmbedModel> Embed(long kinopoisk_id)
        {
            string product = await onget.Invoke($"{apihost}/api/product/read_api.php?kinopoisk={kinopoisk_id}");
            if (product == null)
            {
                requesterror?.Invoke();
                return null;
            }

            if (product.Contains("Product does not exist"))
                return new EmbedModel() { IsEmpty = true };

            string iframeuri = Regex.Match(product, "src=\"(https?://[^\"]+)\"").Groups[1].Value;
            if (string.IsNullOrWhiteSpace(iframeuri))
            {
                requesterror?.Invoke();
                return null;
            }

            string content = await onget.Invoke(iframeuri);
            if (content == null || !content.Contains("Playerjs"))
            {
                requesterror?.Invoke();
                return null;
            }

            if (!Regex.IsMatch(content, "file:([\t ]+)?'\\[\\{"))
                return new EmbedModel() { content = content };

            Voice[] root = null;

            try
            {
                root = JsonSerializer.Deserialize<Voice[]>(Regex.Match(content, "file:([\t ]+)?'([^\n\r]+)',").Groups[2].Value);
                if (root == null || root.Length == 0)
                    return null;
            }
            catch { return null; }

            return new EmbedModel() { serial = root };
        }
        #endregion

        #region Html
        public string Html(EmbedModel md, long kinopoisk_id, string title, string original_title, int t, int s, VastConf vast = null, bool rjson = false, string mybaseurl = null)
        {
            if (md == null || md.IsEmpty || (string.IsNullOrEmpty(md.content) && md.serial == null))
                return string.Empty;

            string fixStream(string _l) => _l.Replace("0yql3tj", "oyql3tj");

            if (md.content != null)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, 1);

                string hls = Regex.Match(md.content, "file:([\t ]+)?(\"|')([\t ]+)?(?<hls>https?://[^\"'\n\r\t ]+/index.m3u8)").Groups["hls"].Value;
                if (string.IsNullOrEmpty(hls))
                    return string.Empty;

                #region subtitle
                SubtitleTpl? subtitles = null;
                string subtitle = new Regex("subtitle(\")?:\"([^\"]+)\"").Match(md.content).Groups[2].Value;

                if (!string.IsNullOrEmpty(subtitle))
                {
                    var match = new Regex("\\[([^\\]]+)\\](https?://[^\\,]+)").Match(subtitle);
                    subtitles = new SubtitleTpl(match.Length);

                    while (match.Success)
                    {
                        subtitles.Value.Append(match.Groups[1].Value, onstreamfile.Invoke(fixStream(match.Groups[2].Value)));
                        match = match.NextMatch();
                    }
                }
                #endregion

                mtpl.Append("–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é", onstreamfile.Invoke(fixStream(hls)), subtitles: subtitles, vast: vast);

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                try
                {
                    if (s == -1)
                    {
                        var tpl = new SeasonTpl();
                        var hashseason = new HashSet<string>();

                        foreach (var voice in md.serial)
                        {
                            foreach (var season in voice.folder)
                            {
                                if (hashseason.Contains(season.title))
                                    continue;

                                hashseason.Add(season.title);
                                string numberseason = Regex.Match(season.title, "([0-9]+)$").Groups[1].Value;
                                if (string.IsNullOrEmpty(numberseason))
                                    continue;

                                string baseUrl = mybaseurl ?? (host + $"lite/ashdi?rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}");
                                string link = $"{baseUrl}&s={numberseason}";

                                tpl.Append(season.title, link, numberseason);
                            }
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();

                        for (int i = 0; i < md.serial.Length; i++)
                        {
                            if (md.serial[i].folder.FirstOrDefault(i => i.title.EndsWith($" {s}")).title == null)
                                continue;

                            if (t == -1)
                                t = i;

                            string baseUrl = mybaseurl ?? (host + $"lite/ashdi?rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}");
                            string link = $"{baseUrl}&s={s}&t={i}";

                            vtpl.Append(md.serial[i].title, t == i, link);
                        }
                        #endregion

                        string sArch = s.ToString();
                        var episodes = md.serial[t].folder.First(i => i.title.EndsWith($" {s}")).folder;

                        var etpl = new EpisodeTpl(episodes.Length);

                        foreach (var episode in episodes)
                        {
                            #region subtitle
                            SubtitleTpl? subtitles = null;

                            if (!string.IsNullOrEmpty(episode.subtitle))
                            {
                                var match = new Regex("\\[([^\\]]+)\\](https?://[^\\,]+)").Match(episode.subtitle);
                                subtitles = new SubtitleTpl(match.Length);

                                while (match.Success)
                                {
                                    subtitles.Value.Append(match.Groups[1].Value, onstreamfile.Invoke(fixStream(match.Groups[2].Value)));
                                    match = match.NextMatch();
                                }
                            }
                            #endregion

                            string file = onstreamfile.Invoke(fixStream(episode.file));
                            etpl.Append(episode.title, title ?? original_title, sArch, Regex.Match(episode.title, "([0-9]+)$").Groups[1].Value, file, subtitles: subtitles, vast: vast);
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                }
                catch
                {
                    return string.Empty;
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Eneyida.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.Eneyida;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct EneyidaInvoke
    {
        #region EneyidaInvoke
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public EneyidaInvoke(string host, string apihost, Func<string, ValueTask<string>> onget, Func<string, string, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onpost = onpost;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        public async ValueTask<EmbedModel> Embed(string original_title, int year, string href, bool similar)
        {
            if (string.IsNullOrWhiteSpace(href) && (string.IsNullOrWhiteSpace(original_title) || year == 0))
                return null;

            string link = href;
            var result = new EmbedModel();

            if (string.IsNullOrEmpty(link))
            {
                onlog?.Invoke("search start");
                string search = await onpost.Invoke($"{apihost}/index.php?do=search", $"do=search&subaction=search&search_start=0&result_from=1&story={HttpUtility.UrlEncode(original_title)}");
                if (search == null)
                {
                    requesterror?.Invoke();
                    return null;
                }

                onlog?.Invoke("search ok");

                var rows = search.Split("<article ");
                string stitle = StringConvert.SearchName(original_title?.ToLower());

                foreach (string row in rows.Skip(1))
                {
                    if (row.Contains(">–ê–Ω–æ–Ω—Å</div>") || row.Contains(">–¢—Ä–µ–π–ª–µ—Ä</div>"))
                        continue;

                    string newslink = Regex.Match(row, "href=\"(https?://[^/]+/[^\"]+\\.html)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(newslink))
                        continue;

                    // <div class="short_subtitle"><a href="https://eneyida.tv/xfsearch/year/2025/">2025</a> &bull; Thunderbolts</div>
                    var g = Regex.Match(row, "class=\"short_subtitle\">(<a [^>]+>([0-9]{4})</a>)?([^<]+)</div>").Groups;

                    string name = g[3].Value.Replace("&bull;", "").Trim();
                    if (string.IsNullOrEmpty(name))
                        continue;

                    if (result.similars == null)
                        result.similars = new List<Similar>(rows.Length);

                    string uaname = Regex.Match(row, "id=\"short_title\"[^>]+>([^<]+)<").Groups[1].Value;
                    string img = Regex.Match(row, "data-src=\"/([^\"]+)\"").Groups[1].Value;

                    result.similars.Add(new Similar()
                    {
                        title = $"{uaname} / {name}",
                        year = g[2].Value,
                        href = newslink,
                        img = string.IsNullOrEmpty(img) ? null : $"{apihost}/{img}"
                    });

                    if (StringConvert.SearchName(name) == stitle && g[2].Value == year.ToString())
                    {
                        link = newslink;
                        break;
                    }
                }

                if (similar)
                    return result;

                if (string.IsNullOrEmpty(link))
                {
                    if (result.similars.Count > 0)
                        return result;

                    if (search.Contains(">–ü–æ—à—É–∫ –ø–æ —Å–∞–π—Ç—É<"))
                        return new EmbedModel() { IsEmpty = true };

                    return null;
                }
            }

            onlog?.Invoke("link: " + link);
            string news = await onget.Invoke(link);
            if (news == null)
            {
                requesterror?.Invoke();
                return null;
            }

            if (news.Contains("full_content fx_row"))
                result.quel = Regex.Match(news.Split("full_content fx_row")[1].Split("full__favourite")[0], " (1080p|720p|480p)</div>").Groups[1].Value;

            string iframeUri = Regex.Match(news, "<iframe width=\"100%\" height=\"400\" src=\"(https?://[^/]+/[^\"]+/[0-9]+)\"").Groups[1].Value;
            if (string.IsNullOrEmpty(iframeUri))
                return null;

            onlog?.Invoke("iframeUri: " + iframeUri);
            string content = await onget.Invoke(iframeUri);
            if (content == null || !content.Contains("file:"))
            {
                requesterror?.Invoke();
                return null;
            }

            if (Regex.IsMatch(content, "file: ?'\\["))
            {
                Models.Online.Tortuga.Voice[] root = null;

                try
                {
                    root = JsonSerializer.Deserialize<Models.Online.Tortuga.Voice[]>(Regex.Match(content, "file: ?'([^\n\r]+)',").Groups[1].Value);
                    if (root == null || root.Length == 0)
                        return null;
                }
                catch { return null; }

                result.serial = root;
            }
            else
            {
                result.content = content;
            }

            return result;
        }
        #endregion

        #region Html
        public string Html(EmbedModel result, int clarification, string title, string original_title, int year, int t, int s, string href, VastConf vast = null, bool rjson = false)
        {
            if (result == null || result.IsEmpty)
                return string.Empty;

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            #region similar
            if (result.content == null && result.serial == null)
            {
                if (string.IsNullOrWhiteSpace(href) && result.similars != null && result.similars.Count > 0)
                {
                    var stpl = new SimilarTpl(result.similars.Count);

                    foreach (var similar in result.similars)
                    {
                        string link = host + $"lite/eneyida?clarification={clarification}&title={enc_title}&original_title={enc_original_title}&year={year}&href={HttpUtility.UrlEncode(similar.href)}";

                        stpl.Append(similar.title, similar.year, string.Empty, link, PosterApi.Size(similar.img));
                    }

                    return rjson ? stpl.ToJson() : stpl.ToHtml();
                }

                return string.Empty;
            }
            #endregion

            if (result.content != null)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title);

                string hls = Regex.Match(result.content, "file: ?\"(https?://[^\"]+/index.m3u8)\"").Groups[1].Value;
                if (string.IsNullOrWhiteSpace(hls))
                    return string.Empty;

                #region subtitle
                SubtitleTpl subtitles = new SubtitleTpl();
                string subtitle = new Regex("subtitle: ?\"([^\"]+)\"").Match(result.content).Groups[1].Value;

                if (!string.IsNullOrEmpty(subtitle))
                {
                    var match = new Regex("\\[([^\\]]+)\\](https?://[^\\,]+)").Match(subtitle);
                    while (match.Success)
                    {
                        subtitles.Append(match.Groups[1].Value, onstreamfile.Invoke(match.Groups[2].Value));
                        match = match.NextMatch();
                    }
                }
                #endregion

                mtpl.Append(string.IsNullOrEmpty(result.quel) ? "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é" : result.quel, onstreamfile.Invoke(hls), subtitles: subtitles, vast: vast);

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_href = HttpUtility.UrlEncode(href);

                try
                {
                    if (s == -1)
                    {
                        #region –°–µ–∑–æ–Ω—ã
                        var tpl = new SeasonTpl();

                        foreach (var season in result.serial)
                        {
                            string numberseason = Regex.Match(season.title, "^([0-9]+)").Groups[1].Value;
                            if (string.IsNullOrEmpty(numberseason))
                                continue;

                            string link = host + $"lite/eneyida?rjson={rjson}&clarification={clarification}&title={enc_title}&original_title={enc_original_title}&year={year}&href={enc_href}&s={numberseason}";

                            tpl.Append(season.title, link, numberseason);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                        #endregion
                    }
                    else
                    {
                        var season = result.serial.First(i => i.title.StartsWith($"{s} "));

                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();

                        for (int i = 0; i < season.folder.Length; i++)
                        {
                            if (t == -1)
                                t = i;

                            string link = host + $"lite/eneyida?rjson={rjson}&clarification={clarification}&title={enc_title}&original_title={enc_original_title}&year={year}&href={enc_href}&s={s}&t={i}";

                            vtpl.Append(season.folder[i].title, t == i, link);
                        }
                        #endregion

                        string sArch = s.ToString();
                        var episodes = season.folder[t].folder;

                        var etpl = new EpisodeTpl(episodes.Length);

                        foreach (var episode in episodes)
                        {
                            #region subtitle
                            SubtitleTpl? subtitles = null;

                            if (!string.IsNullOrEmpty(episode.subtitle))
                            {
                                var match = new Regex("\\[([^\\]]+)\\](https?://[^\\,]+)").Match(episode.subtitle);
                                subtitles = new SubtitleTpl(match.Length);

                                while (match.Success)
                                {
                                    subtitles.Value.Append(match.Groups[1].Value, onstreamfile.Invoke(match.Groups[2].Value));
                                    match = match.NextMatch();
                                }
                            }
                            #endregion

                            string file = onstreamfile.Invoke(episode.file);
                            etpl.Append(episode.title, title ?? original_title, sArch, Regex.Match(episode.title, "^([0-9]+)").Groups[1].Value, file, subtitles: subtitles, vast: vast);
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                }
                catch
                {
                    return string.Empty;
                }
                #endregion
            }
        }
        #endregion
    }
}
```

## File: Shared/Engine/Online/Kodik.cs
```
Ôªøusing HtmlAgilityPack;
using Shared.Models;
using Shared.Models.Base;
using Shared.Models.Online.Kodik;
using Shared.Models.Templates;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct KodikInvoke
    {
        #region KodikInvoke
        static Dictionary<string, string> psingles = new Dictionary<string, string>();
        static readonly HybridCache hybridCache = new HybridCache();
        readonly IEnumerable<Result> fallbackDatabase;

        string host;
        string apihost, token, videopath;
        bool usehls, cdn_is_working;
        Func<string, List<HeadersModel>, ValueTask<string>> onget;
        Func<string, string, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public KodikInvoke(string host, string apihost, string token, bool hls, bool cdn_is_working, string videopath, IEnumerable<Result> fallbackDatabase, Func<string, List<HeadersModel>, ValueTask<string>> onget, Func<string, string, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.token = token;
            this.videopath = videopath;
            this.fallbackDatabase = fallbackDatabase;
            this.onget = onget;
            this.onpost = onpost;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.usehls = hls;
            this.cdn_is_working = cdn_is_working;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        async public ValueTask<List<Result>> Embed(string imdb_id, long kinopoisk_id, int s)
        {
            if (string.IsNullOrEmpty(imdb_id) && kinopoisk_id == 0)
                return null;

            string json = null;
            List<Result> results = null;

            if (!string.IsNullOrWhiteSpace(token))
            {
                string url = $"{apihost}/search?token={token}&limit=100&with_episodes=true";
                if (kinopoisk_id > 0)
                    url += $"&kinopoisk_id={kinopoisk_id}";

                if (!string.IsNullOrWhiteSpace(imdb_id))
                    url += $"&imdb_id={imdb_id}";

                if (s > 0)
                    url += $"&season={s}";

                try
                {
                    json = await onget(url, null);

                    if (string.IsNullOrWhiteSpace(json))
                    {
                        requesterror?.Invoke();
                    }
                    else
                    {
                        var root = JsonSerializer.Deserialize<RootObject>(json);
                        if (root?.results != null)
                            results = root.results;
                        else
                            requesterror?.Invoke();
                    }
                }
                catch
                {
                    requesterror?.Invoke();
                }
            }

            if (json == null || json.Contains("–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω—ã–π —Ç–æ–∫–µ–Ω"))
            {
                if (results == null)
                    results = FallbackByIds(imdb_id, kinopoisk_id, s);
            }

            return results;
        }


        public async ValueTask<EmbedModel> Embed(string title, string original_title, int clarification)
        {
            try
            {
                if (string.IsNullOrEmpty(title) && string.IsNullOrEmpty(original_title))
                    return null;

                string json = null;
                List<Result> results = null;

                if (!string.IsNullOrWhiteSpace(token))
                {
                    string url = $"{apihost}/search?token={token}&limit=100&title={HttpUtility.UrlEncode(original_title ?? title)}&with_episodes=true&with_material_data=true";

                    try
                    {
                        json = await onget(url, null);

                        if (string.IsNullOrWhiteSpace(json))
                        {
                            requesterror?.Invoke();
                        }
                        else
                        {
                            var root = JsonSerializer.Deserialize<RootObject>(json);
                            if (root?.results != null)
                                results = root.results;
                            else
                                requesterror?.Invoke();
                        }
                    }
                    catch
                    {
                        requesterror?.Invoke();
                    }
                }

                if (json == null || json.Contains("–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω—ã–π —Ç–æ–∫–µ–Ω"))
                {
                    if (results == null)
                        results = FallbackByTitle(title, original_title);
                }

                if (results == null)
                    return null;

                var hash = new HashSet<string>();
                var stpl = new SimilarTpl(results.Count);
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                foreach (var similar in results)
                {
                    string pick = similar.title?.ToLower()?.Trim();
                    if (string.IsNullOrEmpty(pick))
                        continue;

                    if (hash.Contains(pick))
                        continue;

                    hash.Add(pick);

                    string name = !string.IsNullOrEmpty(similar.title) && !string.IsNullOrEmpty(similar.title_orig) ? $"{similar.title} / {similar.title_orig}" : (similar.title ?? similar.title_orig);

                    string details = similar.translation.title;
                    if (similar.last_season > 0)
                        details += $"{stpl.OnlineSplit} {similar.last_season}–π —Å–µ–∑–æ–Ω";

                    var matd = similar.material_data;
                    string img = PosterApi.Size(matd.anime_poster_url ?? matd.drama_poster_url ?? matd.poster_url);
                    stpl.Append(name, similar.year?.ToString(), details, host + $"lite/kodik?title={enc_title}&original_title={enc_original_title}&clarification={clarification}&pick={HttpUtility.UrlEncode(pick)}", img);
                }

                return new EmbedModel()
                {
                    stpl = stpl,
                    result = results
                };
            }
            catch { return null; }
        }

        public List<Result> Embed(List<Result> results, string pick)
        {
            var content = new List<Result>(results.Count);

            foreach (var i in results)
            {
                if (i.title == null || i.title.ToLower().Trim() != pick)
                    continue;

                content.Add(i);
            }

            return content;
        }
        #endregion

        #region Html
        public async ValueTask<string> Html(List<Result> results, string args, string imdb_id, long kinopoisk_id, string title, string original_title, int clarification, string pick, string kid, int s, bool showstream, bool rjson)
        {
            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            if (results[0].type is "foreign-movie" or "soviet-cartoon" or "foreign-cartoon" or "russian-cartoon" or "anime" or "russian-movie")
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, results.Count);

                foreach (var data in results)
                {
                    string url = host + $"lite/kodik/video?title={enc_title}&original_title={enc_original_title}&link={HttpUtility.UrlEncode(data.link)}";

                    string streamlink = null;
                    if (showstream)
                    {
                        streamlink = usehls ? $"{url.Replace("/video", $"/{videopath}.m3u8")}&play=true" : $"{url.Replace("/video", $"/{videopath}")}&play=true";

                        if (!string.IsNullOrEmpty(args))
                            streamlink += $"&{args.Remove(0, 1)}";
                    }

                    mtpl.Append(data.translation.title, url, "call", streamlink);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_pick = HttpUtility.UrlEncode(pick);

                if (s == -1)
                {
                    var tpl = new SeasonTpl(results.Count);
                    var hash = new HashSet<int>();

                    foreach (var item in results.AsEnumerable().Reverse())
                    {
                        int season = item.last_season;
                        string link = host + $"lite/kodik?rjson={rjson}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&clarification={clarification}&pick={enc_pick}&s={season}";

                        if (hash.Contains(season))
                            continue;

                        hash.Add(season);
                        tpl.Append($"{season} —Å–µ–∑–æ–Ω", link, season);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                }
                else
                {
                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var vtpl = new VoiceTpl();
                    HashSet<string> hash = new HashSet<string>();

                    foreach (var item in results)
                    {
                        string id = item.id;
                        if (string.IsNullOrEmpty(id))
                            continue;

                        string name = item.translation.title ?? "–æ—Ä–∏–≥–∏–Ω–∞–ª";
                        if (hash.Contains(name))
                            continue;

                        if (item.last_season != s)
                        {
                            if (item.seasons == null || !item.seasons.ContainsKey(s.ToString()))
                                continue;
                        }

                        hash.Add(name);

                        if (string.IsNullOrEmpty(kid))
                            kid = id;

                        string link = host + $"lite/kodik?rjson={rjson}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&title={enc_title}&original_title={enc_original_title}&clarification={clarification}&pick={enc_pick}&s={s}&kid={id}";

                        vtpl.Append(name, kid == id, link);
                    }
                    #endregion

                    var selected = results.FirstOrDefault(i => i.id == kid);
                    if (string.IsNullOrEmpty(selected.id))
                        selected = results[0];

                    var series = await ResolveEpisodesAsync(selected, s);
                    if (series == null || series.Count == 0)
                        return string.Empty;

                    var etpl = new EpisodeTpl(series.Count);

                    string sArhc = s.ToString();

                    foreach (var episode in series)
                    {
                        string url = host + $"lite/kodik/video?title={enc_title}&original_title={enc_original_title}&link={HttpUtility.UrlEncode(episode.Value)}&episode={episode.Key}";

                        string streamlink = null;
                        if (showstream)
                        {
                            streamlink = usehls ? $"{url.Replace("/video", $"/{videopath}.m3u8")}&play=true" : $"{url.Replace("/video", $"/{videopath}")}&play=true";

                            if (!string.IsNullOrEmpty(args))
                                streamlink += $"&{args.Remove(0, 1)}";
                        }

                        etpl.Append($"{episode.Key} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.Key, url, "call", streamlink: streamlink);
                    }

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                }
                #endregion
            }
        }
        #endregion


        #region VideoParse
        async public ValueTask<List<StreamModel>> VideoParse(string linkhost, string link)
        {
            string iframe = await onget($"https:{link}", null);
            if (iframe == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string uri = null;
            string player_single = Regex.Match(iframe, "src=\"/(assets/js/app\\.player_[^\"]+\\.js)\"").Groups[1].Value;
            if (!string.IsNullOrEmpty(player_single))
            {
                if (!psingles.TryGetValue(player_single, out uri))
                {
                    string playerjs = await onget($"{linkhost}/{player_single}", null);

                    if (playerjs == null)
                    {
                        requesterror?.Invoke();
                        return null;
                    }

                    uri = DecodeUrlBase64(Regex.Match(playerjs, "type:\"POST\",url:atob\\(\"([^\"]+)\"\\)").Groups[1].Value);
                    if (!string.IsNullOrEmpty(uri))
                        psingles.TryAdd(player_single, uri);
                }
            }

            if (string.IsNullOrEmpty(uri))
                return null;

            string _frame = Regex.Replace(iframe.Split("advertDebug")[1].Split("preview-icons")[0], "[\n\r\t ]+", "");
            string domain = Regex.Match(_frame, "domain=\"([^\"]+)\"").Groups[1].Value;
            string d_sign = Regex.Match(_frame, "d_sign=\"([^\"]+)\"").Groups[1].Value;
            string pd = Regex.Match(_frame, "pd=\"([^\"]+)\"").Groups[1].Value;
            string pd_sign = Regex.Match(_frame, "pd_sign=\"([^\"]+)\"").Groups[1].Value;
            string ref_domain = Regex.Match(_frame, "ref=\"([^\"]+)\"").Groups[1].Value;
            string ref_sign = Regex.Match(_frame, "ref_sign=\"([^\"]+)\"").Groups[1].Value;
            string type = Regex.Match(_frame, "videoInfo.type='([^']+)'").Groups[1].Value;
            string hash = Regex.Match(_frame, "videoInfo.hash='([^']+)'").Groups[1].Value;
            string id = Regex.Match(_frame, "videoInfo.id='([^']+)'").Groups[1].Value;

            string json = await onpost($"{linkhost + uri}", $"d={domain}&d_sign={d_sign}&pd={pd}&pd_sign={pd_sign}&ref={ref_domain}&ref_sign={ref_sign}&bad_user=false&cdn_is_working={cdn_is_working.ToString().ToLower()}&type={type}&hash={hash}&id={id}&info=%7B%7D");
            if (json == null || !json.Contains("\"src\":\""))
            {
                requesterror?.Invoke();
                return null;
            }

            var streams = new List<StreamModel>(4);

            var match = new Regex("\"([0-9]+)p?\":\\[\\{\"src\":\"([^\"]+)", RegexOptions.IgnoreCase).Match(json);
            while (match.Success)
            {
                if (!string.IsNullOrWhiteSpace(match.Groups[2].Value))
                {
                    string m3u = match.Groups[2].Value;
                    if (!m3u.Contains("manifest.m3u8"))
                    {
                        int zCharCode = Convert.ToInt32('Z');

                        string src = Regex.Replace(match.Groups[2].Value, "[a-zA-Z]", e =>
                        {
                            int eCharCode = Convert.ToInt32(e.Value[0]);
                            return ((eCharCode <= zCharCode ? 90 : 122) >= (eCharCode = eCharCode + 18) ? (char)eCharCode : (char)(eCharCode - 26)).ToString();
                        });

                        m3u = DecodeUrlBase64(src);
                    }

                    if (m3u.StartsWith("//"))
                        m3u = $"https:{m3u}";

                    if (!usehls && m3u.Contains(".m3u"))
                        m3u = m3u.Replace(":hls:manifest.m3u8", "");

                    streams.Add(new StreamModel() { q = $"{match.Groups[1].Value}p", url = m3u });
                }

                match = match.NextMatch();
            }

            if (streams.Count == 0)
                return null;

            streams.Reverse();

            return streams;
        }

        public string VideoParse(List<StreamModel> streams, string title, string original_title, int episode, bool play, VastConf vast = null)
        {
            if (streams == null || streams.Count == 0)
                return string.Empty;

            if (play)
                return onstreamfile(streams[0].url);

            string name = title ?? original_title ?? "auto";
            if (episode > 0)
                name += $" ({episode} —Å–µ—Ä–∏—è)";

            var streamquality = new StreamQualityTpl();
            foreach (var l in streams)
                streamquality.Append(onstreamfile(l.url), l.q);

            return VideoTpl.ToJson("play", onstreamfile(streams[0].url), name, streamquality: streamquality, vast: vast);
        }
        #endregion

        #region DecodeUrlBase64
        static string DecodeUrlBase64(string s)
        {
            return Encoding.UTF8.GetString(Convert.FromBase64String(s.Replace('-', '+').Replace('_', '/').PadRight(4 * ((s.Length + 3) / 4), '=')));
        }
        #endregion


        #region [Codex AI]
        List<Result> FallbackByIds(string imdb_id, long kinopoisk_id, int season)
        {
            var data = fallbackDatabase;
            if (data == null)
                return null;

            bool requireImdb = !string.IsNullOrEmpty(imdb_id);
            bool requireKinopoisk = kinopoisk_id > 0;

            var matches = data.Where(item =>
            {
                bool imdbMatch = !requireImdb || string.Equals(item.imdb_id, imdb_id, StringComparison.OrdinalIgnoreCase);
                bool kinopoiskMatch = !requireKinopoisk || item.kinopoisk_id == kinopoisk_id.ToString();
                return imdbMatch && kinopoiskMatch;
            }).ToList();

            if (matches.Count == 0)
                return null;

            return matches.Count == 0 ? null : matches;
        }

        List<Result> FallbackByTitle(string title, string originalTitle)
        {
            var data = fallbackDatabase;
            if (data == null)
                return null;

            bool hasTitle = !string.IsNullOrWhiteSpace(title);
            bool hasOriginal = !string.IsNullOrWhiteSpace(originalTitle);

            var strictMatches = new List<Result>();
            List<Result> fallbackMatches = (hasTitle || hasOriginal) ? new List<Result>() : null;

            foreach (var item in data)
            {
                bool titleMatch = !hasTitle || TitleMatches(item.title, title) || TitleMatches(item.title_orig, title);
                bool originalMatch = !hasOriginal || TitleMatches(item.title, originalTitle) || TitleMatches(item.title_orig, originalTitle);

                if (titleMatch && originalMatch)
                {
                    strictMatches.Add(item);
                    continue;
                }

                if (fallbackMatches == null)
                    continue;

                if (TitleMatches(item.title, title) ||
                    TitleMatches(item.title_orig, title) ||
                    TitleMatches(item.title, originalTitle) ||
                    TitleMatches(item.title_orig, originalTitle))
                {
                    fallbackMatches.Add(item);
                }
            }

            var matches = strictMatches.Count > 0 ? strictMatches : fallbackMatches;

            return matches == null || matches.Count == 0 ? null : matches;
        }

        static bool TitleMatches(string source, string target)
        {
            if (string.IsNullOrWhiteSpace(source) || string.IsNullOrWhiteSpace(target))
                return false;

            string normalizedSource = StringConvert.SearchName(source);
            string normalizedTarget = StringConvert.SearchName(target);

            if (string.IsNullOrWhiteSpace(normalizedSource) || string.IsNullOrWhiteSpace(normalizedTarget))
                return false;

            return normalizedSource.Contains(normalizedTarget);
        }

        async ValueTask<Dictionary<string, string>> ResolveEpisodesAsync(Result selected, int season)
        {
            if (season <= 0)
                return null;

            string seasonKey = season.ToString();

            if (selected.seasons != null &&
                selected.seasons.TryGetValue(seasonKey, out var seasonInfo) &&
                seasonInfo.episodes != null &&
                seasonInfo.episodes.Count > 0)
            {
                return seasonInfo.episodes;
            }

            var seasonsFromHtml = await LoadSeasonsFromHtml(selected);
            if (seasonsFromHtml != null &&
                seasonsFromHtml.TryGetValue(seasonKey, out seasonInfo) &&
                seasonInfo.episodes != null &&
                seasonInfo.episodes.Count > 0)
            {
                return seasonInfo.episodes;
            }

            return null;
        }

        async ValueTask<Dictionary<string, Season>> LoadSeasonsFromHtml(Result selected)
        {
            if (string.IsNullOrWhiteSpace(selected.id) || string.IsNullOrWhiteSpace(selected.link) || onget == null)
                return null;

            string cacheKey = $"kodik:series:{selected.id}";
            if (hybridCache.TryGetValue(cacheKey, out Dictionary<string, Season> cached))
                return cached;

            try
            {
                string html = await onget($"https:{selected.link}", null);
                if (string.IsNullOrWhiteSpace(html))
                {
                    requesterror?.Invoke();
                    return null;
                }

                var doc = new HtmlDocument();
                doc.LoadHtml(html);

                var optionsRoot = doc.DocumentNode.SelectSingleNode("//div[contains(@class,'series-options')]");
                if (optionsRoot == null)
                    return null;

                var seasons = new Dictionary<string, Season>();

                var seasonNodes = optionsRoot.SelectNodes(".//div[contains(@class,'season-')]");
                if (seasonNodes == null)
                    return null;

                foreach (var seasonNode in seasonNodes)
                {
                    string classes = seasonNode.GetAttributeValue("class", string.Empty);
                    var match = Regex.Match(classes, "season-([0-9]+)");
                    if (!match.Success)
                        continue;

                    string seasonKey = match.Groups[1].Value;
                    if (string.IsNullOrEmpty(seasonKey))
                        continue;

                    var options = seasonNode.SelectNodes(".//option");
                    if (options == null || options.Count == 0)
                        continue;

                    var episodes = new Dictionary<string, string>();

                    foreach (var option in options)
                    {
                        string episodeNumber = option.GetAttributeValue("value", null) ?? option.InnerText;
                        episodeNumber = episodeNumber?.Trim();
                        if (string.IsNullOrEmpty(episodeNumber))
                            continue;

                        string episodeLink = BuildEpisodeLink(option);
                        if (string.IsNullOrEmpty(episodeLink))
                            continue;

                        if (!episodes.ContainsKey(episodeNumber))
                            episodes[episodeNumber] = episodeLink;
                    }

                    if (episodes.Count > 0)
                    {
                        seasons[seasonKey] = new Season
                        {
                            link = selected.link,
                            episodes = episodes
                        };
                    }
                }

                if (seasons.Count == 0)
                    return null;

                hybridCache.Set(cacheKey, seasons, TimeSpan.FromMinutes(20));
                return seasons;
            }
            catch
            {
                return null;
            }
        }

        static string BuildEpisodeLink(HtmlNode option)
        {
            string dataId = option.GetAttributeValue("data-id", null);
            string dataHash = option.GetAttributeValue("data-hash", null);

            if (string.IsNullOrWhiteSpace(dataId) || string.IsNullOrWhiteSpace(dataHash))
                return null;

            return $"//kodik.info/seria/{dataId}/{dataHash}/720p";
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/AniLibria.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.AniLibria;
using Shared.Models.Templates;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct AniLibriaInvoke
    {
        #region AniLibriaInvoke
        string host;
        string apihost;
        Func<string, ValueTask<List<RootObject>>> onget;
        Func<string, string> onstreamfile;
        Action requesterror;

        public AniLibriaInvoke(string host, string apihost, Func<string, ValueTask<List<RootObject>>> onget, Func<string, string> onstreamfile, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.apihost = apihost;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.requesterror = requesterror;
        }
        #endregion

        #region Embed
        public async ValueTask<List<RootObject>> Embed(string title)
        {
            List<RootObject> search = await onget($"{apihost}/v2/searchTitles?search=" + HttpUtility.UrlEncode(title));
            if (search == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string stitle = StringConvert.SearchName(title);

            var result = new List<RootObject>(search.Count);

            foreach (var item in search)
            {
                if (item.names.ru != null && StringConvert.SearchName(item.names.ru).StartsWith(stitle))
                    result.Add(item);
                else if (item.names.en != null && StringConvert.SearchName(item.names.en).StartsWith(stitle))
                    result.Add(item);
            }

            if (result.Count == 0)
                return search;

            return result;
        }
        #endregion

        #region Html
        public string Html(List<RootObject> result, string title, string code, int year, bool rjson = false, VastConf vast = null, bool similar = false)
        {
            if (result == null || result.Count == 0)
                return string.Empty;

            string stitle = StringConvert.SearchName(title);

            if (!similar && (!string.IsNullOrEmpty(code) || (result.Count == 1 && result[0].season.year == year && (StringConvert.SearchName(result[0].names.ru) == stitle || StringConvert.SearchName(result[0].names.en) == stitle))))
            {
                #region –°–µ—Ä–∏–∏
                var root = string.IsNullOrEmpty(code) ? result[0] : result.Find(i => i.code == code);
                var episodes = root.player.playlist.Select(i => i.Value);

                var etpl = new EpisodeTpl(episodes.Count());

                foreach (var episode in episodes)
                {
                    var streamquality = new StreamQualityTpl();

                    foreach (var f in new List<(string quality, string url)> { ("1080p", episode.hls.fhd), ("720p", episode.hls.hd), ("480p", episode.hls.sd) })
                    {
                        if (string.IsNullOrWhiteSpace(f.url))
                            continue;

                        streamquality.Append(onstreamfile($"https://{root.player.host}{f.url}"), f.quality);
                    }

                    string season = StringConvert.SearchName(root.names.ru) == stitle || StringConvert.SearchName(root.names.en) == stitle ? "1" : "0";
                    if (season == "0")
                    {
                        season = Regex.Match(code ?? "", "-([0-9]+)(nd|th)").Groups[1].Value;
                        if (string.IsNullOrEmpty(season))
                        {
                            season = Regex.Match(code ?? "", "season-([0-9]+)").Groups[1].Value;
                            if (string.IsNullOrEmpty(season))
                                season = string.IsNullOrEmpty(code) ? "0" : "1";
                        }
                    }

                    etpl.Append($"{episode.serie} —Å–µ—Ä–∏—è", title, season, episode.serie.ToString(), streamquality.Firts().link, streamquality: streamquality, vast: vast);
                }

                return rjson ? etpl.ToJson() : etpl.ToHtml();
                #endregion
            }
            else
            {
                #region –ü–æ–∏—Å–∫
                var stpl = new SimilarTpl(result.Count);
                string enc_title = HttpUtility.UrlEncode(title);

                foreach (var root in result)
                {
                    string name = !string.IsNullOrEmpty(root.names.ru) && !string.IsNullOrEmpty(root.names.en) ? $"{root.names.ru} / {root.names.en}" : (root.names.ru ?? root.names.en);

                    string img = root.posters.original.url;
                    if (!string.IsNullOrEmpty(img))
                        img = "https://anilibria.tv" + img;

                    stpl.Append(name, root.season.year.ToString(), string.Empty, host + $"lite/anilibria?title={enc_title}&code={root.code}", PosterApi.Size(img));
                }

                return rjson ? stpl.ToJson() : stpl.ToHtml();
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Kinobase.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.Kinobase;
using Shared.Models.Online.Settings;
using Shared.Models.Templates;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct KinobaseInvoke
    {
        #region KinobaseInvoke
        KinobaseSettings init;
        string host;
        string apihost;
        Func<string, ValueTask<string>> onget;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public KinobaseInvoke(string host, KinobaseSettings init, Func<string, ValueTask<string>> onget, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.init = init;
            this.host = host != null ? $"{host}/" : null;
            apihost = init.host;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.requesterror = requesterror;
        }
        #endregion

        #region Search
        async public Task<SearchModel> Search(string title, int year)
        {
            if (string.IsNullOrEmpty(title))
                return null;

            string content = await onget($"{apihost}/search?query={HttpUtility.UrlEncode(title)}");
            if (content == null)
            {
                requesterror?.Invoke();
                return null;
            }

            var rows = content.Split("<li class=\"item\">");
            string link = null;

            var similar = new SimilarTpl(rows.Length);

            foreach (string row in rows.Skip(1))
            {
                if (row.Contains(">–¢—Ä–µ–π–ª–µ—Ä</span>"))
                    continue;

                string name = Regex.Match(row, "<div class=\"title\"><[^>]+>([^<]+)").Groups[1].Value;
                string _year = Regex.Match(row, "<span class=\"year\">([0-9]+)").Groups[1].Value;
                string img = Regex.Match(row, "<img src=\"/([^\"]+)\"").Groups[1].Value;
                if (!string.IsNullOrEmpty(img))
                    img = $"{apihost}/{img}";

                string rlnk = Regex.Match(row, "href=\"/([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(rlnk) || string.IsNullOrEmpty(name))
                    continue;

                string uri = host + $"lite/kinobase?href={HttpUtility.UrlEncode(rlnk)}";
                similar.Append(name, _year, string.Empty, uri, PosterApi.Size(img));

                if (StringConvert.SearchName(name) == StringConvert.SearchName(title) && _year == year.ToString())
                {
                    if (string.IsNullOrEmpty(link))
                        link = rlnk;
                }
            }

            if (string.IsNullOrEmpty(link))
            {
                if (!content.Contains(">–ü–æ –∑–∞–ø—Ä–æ—Å—É") && similar.data.Count == 0)
                {
                    requesterror?.Invoke();
                    return null;
                }
            }

            return new SearchModel() 
            {
                link = link,
                similar = similar
            };
        }
        #endregion

        #region Embed
        async public Task<EmbedModel> Embed(string link, bool playerjs)
        {
            if (string.IsNullOrEmpty(link))
                return null;

            string news = await onget($"{apihost}/{link}");
            if (string.IsNullOrEmpty(news))
            {
                requesterror?.Invoke();
                return null;
            }

            if (playerjs)
            {
                try
                {
                    string video = Regex.Match(news, "id=\"playerjsfile\">([^<]+)<").Groups[1].Value;
                    if (string.IsNullOrEmpty(video))
                    {
                        if (news.Contains("<div class=\"alert\""))
                        {
                            var h3Match = Regex.Match(news, "<div class=\"alert\">\\s*<h3>([^<]+)</h3>");
                            return new EmbedModel() { IsEmpty = true, errormsg = h3Match.Success ? h3Match.Groups[1].Value.Trim() : "–û—à–∏–±–∫–∞ alert" };
                        }

                        return null;
                    }

                    if (video.EndsWith("]"))
                    {
                        var res = JsonSerializer.Deserialize<Season[]>(video);
                        if (res == null || res.Length == 0)
                            return null;

                        return new EmbedModel()
                        {
                            serial = res,
                            quality = (video.Contains("2160.") || video.Contains("2160_")) ? "2160p" : (video.Contains("1440.") || video.Contains("1440_")) ? "1440p" : (video.Contains("1080.") || video.Contains("1080_")) ? "1080p" : video.Contains("720.") ? "720p" : video.Contains("480.") ? "480p" : "360p"
                        };
                    }
                    else
                    {
                        return new EmbedModel() { content = video };
                    }
                }
                catch { return null; }
            }
            else
            {
                #region uppod.js
                if (news.Contains("id=\"playlists\""))
                {
                    try
                    {
                        string video = Regex.Match(news, "id=\"playlists\">([^<]+)<").Groups[1].Value;
                        if (string.IsNullOrEmpty(video))
                        {
                            requesterror?.Invoke();
                            return null;
                        }

                        var res = JsonSerializer.Deserialize<Season[]>(video);
                        if (res == null || res.Length == 0)
                            return null;

                        return new EmbedModel()
                        {
                            serial = res,
                            quality = video.Contains("1080.") ? "1080p" : video.Contains("720.") ? "720p" : video.Contains("480.") ? "480p" : "360p"
                        };
                    }
                    catch { return null; }
                }
                else
                {
                    string video = StringConvert.FindLastText(news, "id=\"videoplayer\"", "</div>");
                    if (string.IsNullOrEmpty(video))
                    {
                        requesterror?.Invoke();
                        return null;
                    }

                    return new EmbedModel() { content = video };
                }
                #endregion
            }
        }
        #endregion

        #region Html
        public string Html(EmbedModel md, string title, string href, int s, string t, bool rjson = false)
        {
            if (md == null || md.IsEmpty)
                return string.Empty;

            if (md.content != null)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title);

                if (init.playerjs)
                {
                    if (md.content.Contains("{"))
                    {
                        var voices = md.content.Split("{");
                        var hash = new HashSet<string>();

                        foreach (string line in voices)
                        {
                            string voice = Regex.Match(line, "([^\\}]+)\\}").Groups[1].Value.Trim();
                            if (!string.IsNullOrEmpty(voice) && !hash.Contains(voice))
                            {
                                hash.Add(voice);

                                var streamquality = new StreamQualityTpl();

                                foreach (string q in new string[] { "2160", "1440", "1080", "720", "480", "360" })
                                {
                                    foreach (var line2 in voices)
                                    {
                                        if (line2.Contains(voice) && (line2.Contains($"_{q}") || line2.Contains($"_{q}")))
                                        {
                                            string links = Regex.Match(line2, "\\}([^\\[,;]+)").Groups[1].Value;
                                            if (string.IsNullOrEmpty(links))
                                                continue;

                                            streamquality.Append(onstreamfile.Invoke(links), $"{q}p");
                                        }
                                    }
                                }
                                
                                mtpl.Append(voice, streamquality.Firts().link, streamquality: streamquality);
                            }
                        }
                    }
                    else
                    {
                        var streamquality = new StreamQualityTpl();

                        foreach (string q in new string[] { "2160", "1440", "1080", "720", "480", "360" })
                        {
                            string link = Regex.Match(md.content, $"\\[{q}p\\]([^\\[,; ]+)").Groups[1].Value;
                            if (string.IsNullOrEmpty(link))
                                continue;

                            streamquality.Append(onstreamfile.Invoke(link), $"{q}p");
                        }

                        mtpl.Append("–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é", streamquality.Firts().link, streamquality: streamquality);
                    }
                }
                else
                {
                    var streamquality = new StreamQualityTpl();

                    foreach (string q in new string[] { "1080", "720", "480", "360" })
                    {
                        string link = Regex.Match(md.content, $"(https?://[^\"\\[\\|,;\n\r\t ]+_{q}(_10)?.(mp4|m3u8))").Groups[1].Value;
                        if (string.IsNullOrEmpty(link))
                            continue;

                        streamquality.Append(onstreamfile.Invoke(link), $"{q}p");
                    }

                    var first = streamquality.Firts();
                    mtpl.Append(first.quality, first.link, streamquality: streamquality);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string sArhc = s.ToString();

                if (init.playerjs)
                {
                    if (md.serial.First().folder == null)
                    {
                        if (s == -1)
                        {
                            var tpl = new SeasonTpl(md.quality);
                            string link = host + $"lite/kinobase?title={enc_title}&href={HttpUtility.UrlEncode(href)}&t={HttpUtility.UrlEncode(t)}&s=1";
                            tpl.Append("1 —Å–µ–∑–æ–Ω", link, 1);

                            return rjson ? tpl.ToJson() : tpl.ToHtml();
                        }
                        else
                        {
                            return renderSeason(md.serial, host, onstreamfile);
                        }
                    }
                    else
                    {
                        if (s == -1)
                        {
                            var tpl = new SeasonTpl(md.quality);

                            foreach (var item in md.serial)
                            {
                                string season = Regex.Match(item.title.Trim(), "^([0-9]+)").Groups[1].Value;
                                string link = host + $"lite/kinobase?title={enc_title}&href={HttpUtility.UrlEncode(href)}&t={HttpUtility.UrlEncode(t)}&s={season}";
                                tpl.Append($"{season} —Å–µ–∑–æ–Ω", link, season);
                            }

                            return rjson ? tpl.ToJson() : tpl.ToHtml();
                        }
                        else
                        {
                            return renderSeason(md.serial.First(i => i.title.StartsWith($"{s} ")).folder, host, onstreamfile);
                        }
                    }

                    string renderSeason(Season[] episodes, string host, Func<string, string> onstreamfile)
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();

                        {
                            var hash_voices = new HashSet<string>();
                            var m = Regex.Match(episodes.First().file, "\\{([^\\}]+)");
                            while (m.Success)
                            {
                                string voice = m.Groups[1].Value.Trim();
                                if (!hash_voices.Contains(voice))
                                {
                                    hash_voices.Add(voice);

                                    if (string.IsNullOrEmpty(t))
                                        t = voice;

                                    string link = host + $"lite/kinobase?title={enc_title}&href={HttpUtility.UrlEncode(href)}&t={HttpUtility.UrlEncode(voice)}&s={s}";
                                    bool active = t == voice;

                                    vtpl.Append(voice, active, link);
                                }

                                m = m.NextMatch();
                            }
                        }
                        #endregion

                        var etpl = new EpisodeTpl(episodes.Length);

                        foreach (var episode in episodes)
                        {
                            if (string.IsNullOrEmpty(episode.file) || (t != null && !episode.file.Contains(t)))
                                continue;

                            var streamquality = new StreamQualityTpl();

                            foreach (string quality in new List<string> { "2160", "1440", "1080", "720", "480", "360" })
                            {
                                string qline = Regex.Match(episode.file, $"\\[{quality}p( [^\\]]+)?\\]([^\\[]+)").Groups[2].Value;
                                if (string.IsNullOrEmpty(qline))
                                    continue;

                                if (string.IsNullOrEmpty(t))
                                {
                                    string links = Regex.Match(qline, "({[^\\}]+})?([^\\}\\{\\[,;]+)").Groups[2].Value;
                                    if (string.IsNullOrEmpty(links))
                                        continue;

                                    streamquality.Append(onstreamfile.Invoke(links), $"{quality}p");
                                }
                                else
                                {
                                    string links = Regex.Match(qline, "{" + Regex.Escape(t) + "}" + "([^,;]+)").Groups[1].Value;
                                    if (string.IsNullOrEmpty(links))
                                        continue;

                                    streamquality.Append(onstreamfile.Invoke(links), $"{quality}p");
                                }
                            }

                            #region subtitle
                            var subtitles = new SubtitleTpl();

                            if (!string.IsNullOrEmpty(episode.subtitle))
                            {
                                var m = Regex.Match(episode.subtitle, "\\[([^\\]]+)\\]([^\t ]+)");
                                while (m.Success)
                                {
                                    subtitles.Append(m.Groups[1].Value, onstreamfile.Invoke(m.Groups[2].Value));

                                    m = m.NextMatch();
                                }
                            }
                            #endregion

                            etpl.Append(episode.title, title, sArhc, Regex.Match(episode.title, "^([0-9]+)").Groups[1].Value, streamquality.Firts().link, subtitles: subtitles, streamquality: streamquality);
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                }
                else
                {
                    #region uppod.js
                    string finEpisode(Season[] data, Func<string, string> onstreamfile)
                    {
                        var etpl = new EpisodeTpl(data.Length);

                        foreach (var episode in data)
                        {
                            if (string.IsNullOrEmpty(episode.file))
                                continue;

                            var streamquality = new StreamQualityTpl();

                            foreach (string quality in new List<string> { "1080", "720", "480", "360" })
                            {
                                string link = Regex.Match(episode.file, $"(https?://[^\"\\[\\|,;\n\r\t ]+_{quality}.(mp4|m3u8))").Groups[1].Value;
                                if (string.IsNullOrEmpty(link))
                                    continue;

                                streamquality.Append(onstreamfile.Invoke(link), $"{quality}p");
                            }

                            etpl.Append(episode.title, title, sArhc, Regex.Match(episode.title, "^([0-9]+)").Groups[1].Value, streamquality.Firts().link, streamquality: streamquality);
                        }

                        return rjson ? etpl.ToJson() : etpl.ToHtml();
                    }

                    if (md.serial.First().folder == null)
                    {
                        if (s == -1)
                        {
                            var tpl = new SeasonTpl(md.quality);
                            string link = host + $"lite/kinobase?title={enc_title}&href={HttpUtility.UrlEncode(href)}&s=1";
                            tpl.Append("1 —Å–µ–∑–æ–Ω", link, 1);

                            return rjson ? tpl.ToJson() : tpl.ToHtml();
                        }
                        else
                        {
                            return finEpisode(md.serial, onstreamfile);
                        }
                    }
                    else
                    {
                        if (s == -1)
                        {
                            var tpl = new SeasonTpl(md.quality);

                            foreach (var item in md.serial)
                            {
                                string season = Regex.Match(item.title.Trim(), "^([0-9]+)").Groups[1].Value;
                                string link = host + $"lite/kinobase?title={enc_title}&href={HttpUtility.UrlEncode(href)}&s={season}";
                                tpl.Append($"{season} —Å–µ–∑–æ–Ω", link, season);
                            }

                            return rjson ? tpl.ToJson() : tpl.ToHtml();
                        }
                        else
                        {
                            return finEpisode(md.serial.First(i => i.title.StartsWith($"{s} ")).folder, onstreamfile);
                        }
                    }
                    #endregion
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/VDBmovies.cs
```
Ôªøusing Shared.Models.Base;
using Shared.Models.Online.VDBmovies;
using Shared.Models.Templates;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public struct VDBmoviesInvoke
    {
        #region VDBmoviesInvoke
        string host;
        bool usehls;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;

        public VDBmoviesInvoke(string host, bool hls, Func<string, string> onstreamfile, Func<string, string> onlog = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            usehls = hls;
        }
        #endregion

        #region EvalCode
        public string EvalCode(in string file)
        {
            return @"(function () {
                    var enc = function enc(str) {
	                return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p1) {
	                    return String.fromCharCode('0x' + p1);
	                }));
                    };

                    var dec = function dec(str) {
	                return decodeURIComponent(atob(str).split('').map(function (c) {
	                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
	                }).join(''));
                    };

                    var trashList = ['wNp2wBTNcPRQvTC0_CpxCsq_8T1u9Q', 'md-Od2G9RWOgSa5HoBSSbWrCyIqQyY', 'kzuOYQqB_QSOL-xzN_Kz3kkgkHhHit', '6-xQWMh7ertLp8t_M9huUDk1M0VrYJ', 'RyTwtf15_GLEsXxnpU4Ljjd0ReY-VH'];
                    var x = '" + file + @"'.substring(2);
                    trashList.forEach(function (trash) {
	                x = x.replace('//' + enc(trash), '');
                    });

                    try {
	                x = dec(x);
                    } catch (e) {
	                x = '';
                    }

                    return x;
                })();
            ";
        }
        #endregion

        #region DecodeEval
        public string DecodeEval(in string file)
        {
            Func<string, string> enc = str =>
            {
                var bytes = Encoding.UTF8.GetBytes(str);
                return Convert.ToBase64String(bytes);
            };

            Func<string, string> dec = str =>
            {
                var bytes = Convert.FromBase64String(str);
                return Encoding.UTF8.GetString(bytes);
            };

            List<string> trashList = new List<string>
            {
                "wNp2wBTNcPRQvTC0_CpxCsq_8T1u9Q",
                "md-Od2G9RWOgSa5HoBSSbWrCyIqQyY",
                "kzuOYQqB_QSOL-xzN_Kz3kkgkHhHit",
                "6-xQWMh7ertLp8t_M9huUDk1M0VrYJ",
                "RyTwtf15_GLEsXxnpU4Ljjd0ReY-VH"
            };

            string x = file.Substring(2);

            foreach (var trash in trashList)
                x = x.Replace("//" + enc(trash), "");

            try
            {
                x = dec(x);
            }
            catch
            {
                x = string.Empty;
            }

            return x;
        }
        #endregion

        #region Embed
        public EmbedModel Embed(in string json)
        {
            if (string.IsNullOrEmpty(json))
                return null;

            string quality = json.Contains("1080p") ? "1080p" : json.Contains("720p") ? "720p" : json.Contains("480p") ? "480p" : "360p";

            try
            {
                if (json.Contains("\"folder\""))
                {
                    var serial = JsonSerializer.Deserialize<Models.Online.CDNmovies.Voice[]>(json);
                    if (serial == null || serial.Length == 0)
                        return null;

                    return new EmbedModel() { serial = serial, quality = quality };
                }
                else
                {
                    var movies = JsonSerializer.Deserialize<Episode[]>(json);
                    if (movies == null || movies.Length == 0)
                        return null;

                    return new EmbedModel() { movies = movies, quality = quality };
                }
            }
            catch { return null; }
        }
        #endregion

        #region Html
        public string Html(EmbedModel root, string orid, string imdb_id, long kinopoisk_id, string title, string original_title, string t, int s, int sid, VastConf vast = null, bool rjson = false)
        {
            if (root == null)
                return string.Empty;

            if (root.movies != null)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, root.movies.Length);

                foreach (var m in root.movies)
                {
                    #region subtitle
                    var subtitles = new SubtitleTpl();

                    if (!string.IsNullOrEmpty(m.subtitle))
                    {
                        var match = new Regex("\\[([^\\]]+)\\](https?://[^\\,]+)").Match(m.subtitle);
                        while (match.Success)
                        {
                            subtitles.Append(match.Groups[1].Value, match.Groups[2].Value);
                            match = match.NextMatch();
                        }
                    }
                    #endregion

                    if (string.IsNullOrEmpty(m.file))
                        continue;

                    var streamquality = new StreamQualityTpl();

                    foreach (Match mf in Regex.Matches(m.file, "\\[([^\\]]+)\\](https?://[^\\[\\|,\n\r\t ]+\\.m3u8)"))
                    {
                        string link = mf.Groups[2].Value;
                        if (!usehls)
                            link = link.Replace(":hls:manifest.m3u8", "");

                        streamquality.Insert(onstreamfile.Invoke(link), mf.Groups[1].Value);
                    }

                    mtpl.Append(m.title, streamquality.Firts().link, subtitles: subtitles, streamquality: streamquality, vast: vast);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                if (s == -1)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    var tpl = new SeasonTpl(root.quality, root.serial.Length);

                    for (int i = 0; i < root.serial.Length; i++)
                    {
                        string season = Regex.Match(root.serial[i].title, "^([0-9]+)").Groups[1].Value;
                        if (string.IsNullOrEmpty(season))
                            continue;

                        tpl.Append($"{season} —Å–µ–∑–æ–Ω", host + $"lite/vdbmovies?orid={orid}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&rjson={rjson}&title={enc_title}&original_title={enc_original_title}&s={season}&sid={i}", season);
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∏
                    var vtpl = new VoiceTpl();
                    var etpl = new EpisodeTpl();

                    var hashvoices = new HashSet<string>();

                    string sArhc = s.ToString();

                    foreach (var episode in root.serial[sid].folder)
                    {
                        string ename = Regex.Match(episode.title, "^([0-9]+)").Groups[1].Value;

                        foreach (var voice in episode.folder)
                        {
                            string perevod = voice.title;
                            if (string.IsNullOrEmpty(t))
                                t = perevod;

                            if (!hashvoices.Contains(perevod))
                            {
                                hashvoices.Add(perevod);
                                vtpl.Append(perevod, t == perevod, host + $"lite/vdbmovies?orid={orid}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&rjson={rjson}&title={enc_title}&original_title={enc_original_title}&s={s}&sid={sid}&t={HttpUtility.UrlEncode(perevod)}");
                            }

                            if (perevod != t)
                                continue;

                            var streamquality = new StreamQualityTpl();

                            foreach (Match mf in Regex.Matches(voice.file, "\\[([^\\]]+)\\](https?://[^\\[\\|,\n\r\t ]+\\.m3u8)"))
                            {
                                string link = mf.Groups[2].Value;
                                if (!usehls)
                                    link = link.Replace(":hls:manifest.m3u8", "");

                                streamquality.Insert(onstreamfile.Invoke(link), mf.Groups[1].Value);
                            }

                            etpl.Append($"{ename} c–µ—Ä–∏—è", title ?? original_title, sArhc, ename, streamquality.Firts().link, streamquality: streamquality, vast: vast);
                        }
                    }

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                    #endregion
                }
                #endregion
            }
        }
        #endregion
    }
}

```

## File: Shared/Engine/Online/Rezka.cs
```
Ôªøusing Shared.Models;
using Shared.Models.Base;
using Shared.Models.Online;
using Shared.Models.Online.Rezka;
using Shared.Models.Online.Settings;
using Shared.Models.Templates;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Web;

namespace Shared.Engine.Online
{
    public class RezkaInvoke
    {
        #region RezkaInvoke
        RezkaSettings init;
        string host, scheme;
        string apihost;
        bool usehls, userprem, usereserve;
        Func<string, List<HeadersModel>, ValueTask<string>> onget;
        Func<string, string, List<HeadersModel>, ValueTask<string>> onpost;
        Func<string, string> onstreamfile;
        Func<string, string> onlog;
        Action requesterror;

        public string requestlog = string.Empty;

        static Dictionary<long, string> basereferer = new Dictionary<long, string>();

        void log(string msg)
        {
            return;
            requestlog += $"{msg}\n\n===========================================\n\n\n";
            onlog?.Invoke($"rezka: {msg}\n");
        }

        public RezkaInvoke(string host, RezkaSettings init, Func<string, List<HeadersModel>, ValueTask<string>> onget, Func<string, string, List<HeadersModel>, ValueTask<string>> onpost, Func<string, string> onstreamfile, Func<string, string> onlog = null, Action requesterror = null)
        {
            this.host = host != null ? $"{host}/" : null;
            this.init = init;
            apihost = init.corsHost();
            scheme = init.scheme;
            this.onget = onget;
            this.onstreamfile = onstreamfile;
            this.onlog = onlog;
            this.onpost = onpost;
            usehls = init.hls;
            usereserve = init.reserve;
            userprem = init.premium;
            this.requesterror = requesterror;

            if (apihost.Contains("="))
            {
                char[] buffer = apihost.ToCharArray();
                for (int i = 0; i < buffer.Length; i++)
                {
                    char letter = buffer[i];
                    letter = (char)(letter - 3);
                    buffer[i] = letter;
                }

                apihost = new string(buffer);
            }
        }
        #endregion

        #region Search
        async public Task<SearchModel> Search(string title, string original_title, int clarification, int year)
        {
            var result = new SearchModel();
            string reservedlink = null;

            var base_headers = HeadersModel.Init(init.headers,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("cache-control", "no-cache"),
                ("dnt", "1"),
                ("pragma", "no-cache"),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-mode", "navigate"),
                ("sec-fetch-site", "same-origin"),
                ("sec-fetch-user", "?1"),
                ("upgrade-insecure-requests", "1")
            );

            result.search_uri = $"{apihost}/search/?do=search&subaction=search&q={HttpUtility.UrlEncode(clarification == 1 ? title : (original_title ?? title))}";

            string search = await onget(result.search_uri, HeadersModel.Join(base_headers, HeadersModel.Init(("referer", $"{apihost}/"))));
            if (search == null)
            {
                log("search error");
                requesterror?.Invoke();
                return null;
            }

            if (search.Contains("class=\"error-code\"") && search.ToLower().Contains("–æ—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞"))
            {
                if (search.Contains("(105)") || search.Contains(">105<") || search.Contains("(403)") || search.Contains(">403<"))
                    return new SearchModel() { IsEmpty = true, content = "–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ (105)<br>IP-–∞–¥—Ä–µ—Å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω<br><br>" };

                if (search.Contains("(101)") || search.Contains(">101<"))
                    return new SearchModel() { IsEmpty = true, content = "–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ (101)<br>–ê–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω<br><br>" };

                var accessError = Regex.Match(search, "–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞[ \t]+\\(([0-9]+)\\)", RegexOptions.IgnoreCase).Groups;
                return new SearchModel() { IsEmpty = true, content = $"–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ ({accessError[1].Value})" };
            }

            log("search OK");

            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            var rows = search.Split("\"b-content__inline_item\"");
            foreach (string row in rows.Skip(1))
            {
                var g = Regex.Match(row, "href=\"https?://[^/]+/([^\"]+)\">([^<]+)</a> ?<div>([0-9]{4})").Groups;

                if (string.IsNullOrEmpty(g[1].Value))
                    continue;

                string name = g[2].Value.Trim();
                if (string.IsNullOrEmpty(name))
                    continue;

                if (result.similar == null)
                    result.similar = new List<SimilarModel>(rows.Length);

                string img = Regex.Match(row, "<img src=\"([^\"]+)\"").Groups[1].Value;
                result.similar.Add(new SimilarModel(name, g[3].Value, g[1].Value, img));

                if ((stitle != null && (name.Contains(" / ") && StringConvert.SearchName(name).Contains(stitle) || StringConvert.SearchName(name) == stitle)) || 
                    (sorigtitle != null && (name.Contains(" / ") && StringConvert.SearchName(name).Contains(sorigtitle) || StringConvert.SearchName(name) == sorigtitle)))
                {
                    reservedlink = g[1].Value;

                    if (string.IsNullOrEmpty(result.href) && year > 0 && g[3].Value == year.ToString())
                        result.href = reservedlink;
                }
            }

            if (string.IsNullOrEmpty(result.href))
            {
                if (string.IsNullOrEmpty(reservedlink))
                {
                    if (result?.similar != null && result.similar.Count > 0)
                        return result;

                    if (search.Contains("–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞"))
                        return new SearchModel() { IsEmpty = true };

                    log("link null");
                    return null;
                }

                result.href = reservedlink;
            }

            return result;
        }
        #endregion

        #region Embed
        async public ValueTask<EmbedModel> Embed(string href, string search_uri)
        {
            if (!href.StartsWith("http"))
                href = $"{apihost}/{href}";

            var result = new EmbedModel();

            var base_headers = HeadersModel.Init(init.headers,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("cache-control", "no-cache"),
                ("dnt", "1"),
                ("pragma", "no-cache"),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-mode", "navigate"),
                ("sec-fetch-site", "same-origin"),
                ("sec-fetch-user", "?1"),
                ("upgrade-insecure-requests", "1")
            );

            result.id = Regex.Match(href, "/([0-9]+)-[^/]+\\.html").Groups[1].Value;
            if (long.TryParse(result.id, out long id) && id > 0)
                basereferer.TryAdd(id, href);

            if (!string.IsNullOrEmpty(search_uri))
                base_headers.Add(new HeadersModel("referer", search_uri));

            result.content = await onget(href, base_headers);
            if (result.content == null || string.IsNullOrEmpty(result.id))
            {
                if (result.content == null)
                    requesterror?.Invoke();

                log($"content {href}\nNullOrEmpty");
                return null;
            }

            log($"content {href}\nOK");
            return result;
        }
        #endregion

        #region EmbedID
        async public Task<EmbedModel> EmbedID(long kinopoisk_id, string imdb_id)
        {
            string search = await onpost($"{apihost}/engine/ajax/search.php", "q=%2B" + (!string.IsNullOrEmpty(imdb_id) ? imdb_id : kinopoisk_id.ToString()), null);
            if (search == null)
            {
                requesterror?.Invoke();
                return null;
            }

            string link = null;
            var result = new EmbedModel();

            foreach (string row in search.Split("<li>").Skip(1))
            {
                string href = Regex.Match(row, "href=\"(https?://[^\"]+)\"").Groups[1].Value;
                string name = Regex.Match(row, "<span class=\"enty\">([^<]+)</span>").Groups[1].Value;
                string year = Regex.Match(row, ", ([0-9]{4})(\\)| -)").Groups[1].Value;

                if (string.IsNullOrEmpty(href) || string.IsNullOrEmpty(name))
                    continue;

                if (result.similar == null)
                    result.similar = new List<SimilarModel>();

                result.similar.Add(new SimilarModel(name, year, href, null));
                link = href;
            }

            if (result?.similar != null && result.similar.Count > 1)
                return result;

            if (string.IsNullOrEmpty(link))
            {
                if (search.Contains("b-search__section_title"))
                    return new EmbedModel() { IsEmpty = true };

                return null;
            }

            result!.id = Regex.Match(link, "/([0-9]+)-[^/]+\\.html").Groups[1].Value;
            result.content = await onget(link, null);
            if (result.content == null || string.IsNullOrEmpty(result.id))
            {
                if (result.content == null)
                    requesterror?.Invoke();

                return null;
            }

            return result;
        }
        #endregion

        #region Html
        public string Html(EmbedModel result, string args, string title, string original_title, int s, string href, bool showstream, bool rjson = false)
        {
            if (result == null || result.IsEmpty || result.content == null)
                return string.Empty;

            if (!string.IsNullOrEmpty(args))
                args = $"&{args.Remove(0, 1)}";

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);
            string enc_href = HttpUtility.UrlEncode(href);

            if (!result.content.Contains("data-season_id="))
            {
                #region –§–∏–ª—å–º
                var match = new Regex("<[^>]+ data-translator_id=\"([0-9]+)\"([^>]+)?>(?<voice>[^<]+)(<img title=\"(?<imgname>[^\"]+)\" [^>]+/>)?").Match(result.content);

                var mtpl = new MovieTpl(title, original_title, match.Length);

                if (match.Success)
                {
                    while (match.Success)
                    {
                        if (!string.IsNullOrEmpty(match.Groups[1].Value) && !string.IsNullOrEmpty(match.Groups["voice"].Value))
                        {
                            if (!userprem && match.Groups[0].Value.Contains("prem_translator"))
                            {
                                match = match.NextMatch();
                                continue;
                            }

                            string favs = Regex.Match(result.content, "id=\"ctrl_favs\" value=\"([^\"]+)\"").Groups[1].Value;
                            string link = host + $"lite/rezka/movie?title={enc_title}&original_title={enc_original_title}&id={result.id}&t={match.Groups[1].Value}&favs={favs}";

                            string voice_href = Regex.Match(match.Groups[0].Value, "href=\"(https?://[^/]+)?/([^\"]+)\"").Groups[2].Value;
                            if (!string.IsNullOrEmpty(voice_href))
                                link += $"&voice={HttpUtility.UrlEncode(voice_href)}";

                            #region voice
                            string voice = match.Groups["voice"].Value.Trim();

                            if (!string.IsNullOrEmpty(match.Groups["imgname"].Value) && !voice.ToLower().Contains(match.Groups["imgname"].Value.ToLower().Trim()))
                                voice += $" ({match.Groups["imgname"].Value.Trim()})";

                            if (voice == "-" || string.IsNullOrEmpty(voice))
                                voice = "–û—Ä–∏–≥–∏–Ω–∞–ª";
                            #endregion

                            if (match.Groups[2].Value.Contains("data-director=\"1\""))
                                link += "&director=1";

                            string stream = null;
                            if (showstream)
                            {
                                stream = usehls ? $"{link.Replace("/movie", "/movie.m3u8")}&play=true" : $"{link}&play=true";
                                stream += args;
                            }

                            mtpl.Append(voice, link, "call", stream);
                        }

                        match = match.NextMatch();
                    }
                }
                else
                {
                    var links = getStreamLink(Regex.Match(result.content, "\"id\":\"cdnplayer\",\"streams\":\"([^\"]+)\"").Groups[1].Value.Replace("\\", ""));
                    if (links.Count == 0)
                        return string.Empty;

                    var streamquality = new StreamQualityTpl(links.Select(l => (onstreamfile(l.stream_url!), l.title!)));
                    var first = streamquality.Firts();

                    mtpl.Append(first.quality, onstreamfile(first.link), streamquality: streamquality);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string trs = new Regex("\\.initCDNSeriesEvents\\([0-9]+, ([0-9]+),").Match(result.content).Groups[1].Value;
                if (string.IsNullOrWhiteSpace(trs))
                    return string.Empty;

                #region –ü–µ—Ä–µ–≤–æ–¥
                var vtpl = new VoiceTpl();

                if (result.content.Contains("data-translator_id="))
                {
                    var match = new Regex("<[a-z]+ [^>]+ data-translator_id=\"(?<translator>[0-9]+)\"([^>]+)?>(?<name>[^<]+)(<img title=\"(?<imgname>[^\"]+)\" [^>]+/>)?").Match(result.content);
                    while (match.Success)
                    {
                        if (!userprem && match.Groups[0].Value.Contains("prem_translator"))
                        {
                            match = match.NextMatch();
                            continue;
                        }

                        string name = match.Groups["name"].Value.Trim();
                        if (!string.IsNullOrEmpty(match.Groups["imgname"].Value) && !name.ToLower().Contains(match.Groups["imgname"].Value.ToLower().Trim()))
                            name += $" ({match.Groups["imgname"].Value})";

                        string link = host + $"lite/rezka/serial?rjson={rjson}&title={enc_title}&original_title={enc_original_title}&href={enc_href}&id={result.id}&t={match.Groups["translator"].Value}";

                        string voice_href = Regex.Match(match.Groups[0].Value, "href=\"(https?://[^/]+)?/([^\"]+)\"").Groups[2].Value;
                        if (!string.IsNullOrEmpty(voice_href) && init.ajax != null && init.ajax.Value == false)
                        {
                            string voice = HttpUtility.UrlEncode(voice_href);
                            link = host + $"lite/rezka?rjson={rjson}&title={enc_title}&original_title={enc_original_title}&href={voice}&id={result.id}&t={match.Groups["translator"].Value}";
                        }

                        vtpl.Append(name, match.Groups["translator"].Value == trs, link);

                        match = match.NextMatch();
                    }
                }
                #endregion

                var tpl = new SeasonTpl();
                var etpl = new EpisodeTpl();
                HashSet<string> eshash = new HashSet<string>();

                string sArhc = s.ToString();

                var m = Regex.Match(result.content, "data-cdn_url=\"(?<cdn>[^\"]+)\" [^>]+ data-season_id=\"(?<season>[0-9]+)\" data-episode_id=\"(?<episode>[0-9]+)\"([^>]+)?>(?<name>[^>]+)</[a-z]+>");
                while (m.Success)
                {
                    if (s == -1)
                    {
                        #region –°–µ–∑–æ–Ω—ã
                        string sname = $"{m.Groups["season"].Value} —Å–µ–∑–æ–Ω";
                        if (!string.IsNullOrEmpty(m.Groups["season"].Value) && !eshash.Contains(sname))
                        {
                            eshash.Add(sname);
                            string link = host + $"lite/rezka?rjson={rjson}&title={enc_title}&original_title={enc_original_title}&href={enc_href}&t={trs}&s={m.Groups["season"].Value}";

                            tpl.Append(sname, link, m.Groups["season"].Value);
                        }
                        #endregion
                    }
                    else
                    {
                        #region –°–µ—Ä–∏–∏
                        if (m.Groups["season"].Value == s.ToString() && !eshash.Contains(m.Groups["name"].Value))
                        {
                            eshash.Add(m.Groups["name"].Value);
                            string link = host + $"lite/rezka/movie?title={enc_title}&original_title={enc_original_title}&id={result.id}&t={trs}&s={s}&e={m.Groups["episode"].Value}";

                            string voice_href = Regex.Match(m.Groups[0].Value, "href=\"(https?://[^/]+)?/([^\"]+)\"").Groups[2].Value;
                            if (!string.IsNullOrEmpty(voice_href))
                                link += $"&voice={HttpUtility.UrlEncode(voice_href)}";

                            string stream = null;
                            if (showstream)
                            {
                                stream = usehls ? $"{link.Replace("/movie", "/movie.m3u8")}&play=true" : $"{link}&play=true";
                                stream += args;
                            }

                            etpl.Append(m.Groups["name"].Value, title ?? original_title, sArhc, m.Groups["episode"].Value, link, "call", streamlink: stream);
                        }
                        #endregion
                    }

                    m = m.NextMatch();
                }

                if (rjson)
                    return s == -1 ? tpl.ToJson(vtpl) : etpl.ToJson(vtpl);

                if (s == -1)
                    return vtpl.ToHtml() + tpl.ToHtml();

                return vtpl.ToHtml() + etpl.ToHtml();
                #endregion
            }
        }
        #endregion


        #region Serial
        async public ValueTask<Episodes> SerialEmbed(long id, int t)
        {
            string uri = $"{apihost}/ajax/get_cdn_series/?t={((DateTimeOffset)DateTime.Now).ToUnixTimeSeconds()}{Random.Shared.Next(101, 999)}";
            string data = $"id={id}&translator_id={t}&action=get_episodes";

            Episodes root = null;

            try
            {
                var headers = HeadersModel.Init(init.headers,
                    ("accept", "application/json, text/javascript, */*; q=0.01"),
                    ("cache-control", "no-cache"),
                    ("dnt", "1"),
                    ("origin", apihost),
                    ("pragma", "no-cache"),
                    ("sec-fetch-dest", "empty"),
                    ("sec-fetch-mode", "cors"),
                    ("sec-fetch-site", "same-origin"),
                    ("x-requested-with", "XMLHttpRequest")
                );

                if (basereferer.TryGetValue(id, out string referer) && !string.IsNullOrEmpty(referer))
                    headers = HeadersModel.Join(headers, HeadersModel.Init(("referer", referer)));

                string json = await onpost(uri, data, headers);
                if (json == null)
                {
                    log("json null");
                    requesterror?.Invoke();
                    return null;
                }

                root = JsonSerializer.Deserialize<Episodes>(json);
            }
            catch { }

            if (root == null)
            {
                log("root null");
                return null;
            }

            log("root OK");

            string episodes = root.episodes;
            if (string.IsNullOrWhiteSpace(episodes) || episodes.ToLower() == "false")
            {
                log("episodes null");
                return null;
            }

            return root;
        }

        public string Serial(Episodes root, EmbedModel result, string args, string title, string original_title, string href, long id, int t, int s, bool showstream, bool rjson = false)
        {
            if (root == null || result == null)
                return string.Empty;

            if (!string.IsNullOrEmpty(args))
                args = $"&{args.Remove(0, 1)}";

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);
            string enc_href = HttpUtility.UrlEncode(href);

            #region –ü–µ—Ä–µ–≤–æ–¥
            var vtpl = new VoiceTpl();

            {
                if (string.IsNullOrWhiteSpace(href))
                    return string.Empty;

                if (result?.content != null)
                {
                    if (result.content.Contains("data-translator_id="))
                    {
                        var match = new Regex("<[a-z]+ [^>]+ data-translator_id=\"(?<translator>[0-9]+)\"([^>]+)?>(?<name>[^<]+)(<img title=\"(?<imgname>[^\"]+)\" [^>]+/>)?").Match(result.content);
                        while (match.Success)
                        {
                            if (!userprem && match.Groups[0].Value.Contains("prem_translator"))
                            {
                                match = match.NextMatch();
                                continue;
                            }

                            string name = match.Groups["name"].Value.Trim() + (string.IsNullOrWhiteSpace(match.Groups["imgname"].Value) ? "" : $" ({match.Groups["imgname"].Value})");
                            string link = host + $"lite/rezka/serial?rjson={rjson}&title={enc_title}&original_title={enc_original_title}&href={enc_href}&id={id}&t={match.Groups["translator"].Value}";

                            vtpl.Append(name, match.Groups["translator"].Value == t.ToString(), link);

                            match = match.NextMatch();
                        }
                    }
                }
            }
            #endregion

            if (s == -1)
            {
                #region –°–µ–∑–æ–Ω—ã
                var tpl = new SeasonTpl(root.seasons.Length);

                var match = new Regex("data-tab_id=\"(?<season>[0-9]+)\"([^>]+)?>(?<name>[^<]+)</[a-z]+>").Match(root.seasons);
                while (match.Success)
                {
                    string link = host + $"lite/rezka/serial?rjson={rjson}&title={enc_title}&original_title={enc_original_title}&href={enc_href}&id={id}&t={t}&s={match.Groups["season"].Value}";

                    tpl.Append($"{match.Groups["season"].Value} —Å–µ–∑–æ–Ω", link, match.Groups["season"].Value);

                    match = match.NextMatch();
                }

                return rjson ? tpl.ToJson(vtpl) : tpl.ToHtml(vtpl);
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∏
                var etpl = new EpisodeTpl();

                string sArhc = s.ToString();

                var m = new Regex($"data-season_id=\"{s}\" data-episode_id=\"(?<episode>[0-9]+)\"([^>]+)?>(?<name>[^<]+)</li>").Match(root.episodes);
                while (m.Success)
                {
                    if (!string.IsNullOrEmpty(m.Groups["episode"].Value) && !string.IsNullOrEmpty(m.Groups["name"].Value))
                    {
                        string link = host + $"lite/rezka/movie?title={enc_title}&original_title={enc_original_title}&id={id}&t={t}&s={s}&e={m.Groups["episode"].Value}";

                        string voice_href = Regex.Match(m.Groups[0].Value, "href=\"(https?://[^/]+)?/([^\"]+)\"").Groups[2].Value;
                        if (!string.IsNullOrEmpty(voice_href))
                            link += $"&voice={HttpUtility.UrlEncode(voice_href)}";

                        string stream = usehls ? $"{link.Replace("/movie", "/movie.m3u8")}&play=true" : $"{link}&play=true";

                        etpl.Append(m.Groups["name"].Value, title ?? original_title, sArhc, m.Groups["episode"].Value, link, "call", streamlink: (showstream ? $"{stream}{args}" : null));
                    }

                    m = m.NextMatch();
                }

                if (rjson)
                    return etpl.ToJson(vtpl);

                return vtpl.ToHtml() + etpl.ToHtml();
                #endregion
            }
        }
        #endregion

        #region Movie
        async public ValueTask<MovieModel> Movie(long id, int t, int director, int s, int e, string favs)
        {
            string data = null;
            string uri = $"{apihost}/ajax/get_cdn_series/?t={((DateTimeOffset)DateTime.Now).ToUnixTimeSeconds()}{Random.Shared.Next(101, 999)}";

            if (s == -1)
            {
                data = $"id={id}&translator_id={t}&is_camrip=0&is_ads=0&is_director={director}&favs={favs}&action=get_movie";
            }
            else
            {
                data = $"id={id}&translator_id={t}&season={s}&episode={e}&favs={favs}&action=get_stream";
            }

            var headers = HeadersModel.Init(init.headers,
                ("accept", "application/json, text/javascript, */*; q=0.01"),
                ("cache-control", "no-cache"),
                ("dnt", "1"),
                ("origin", apihost),
                ("pragma", "no-cache"),
                ("sec-fetch-dest", "empty"),
                ("sec-fetch-mode", "cors"),
                ("sec-fetch-site", "same-origin"),
                ("x-requested-with", "XMLHttpRequest")
            );

            if (basereferer.TryGetValue(id, out string referer) && !string.IsNullOrEmpty(referer))
                headers = HeadersModel.Join(headers, HeadersModel.Init(("referer", referer)));

            string json = await onpost(uri, data, headers);
            if (string.IsNullOrEmpty(json))
            {
                log("json null");
                requesterror?.Invoke();
                return null;
            }

            log("json OK");

            Dictionary<string, object> root = null;

            try
            {
                root = JsonSerializer.Deserialize<Dictionary<string, object>>(json);
            }
            catch
            {
                log("Deserialize error");
                requesterror?.Invoke();
                return null;
            }

            string url = root.ContainsKey("url") ? root["url"]?.ToString() : null;
            if (string.IsNullOrEmpty(url) || url.ToLower() == "false")
            {
                log("url null");
                requesterror?.Invoke();
                return null;
            }

            var links = getStreamLink(url);
            if (links.Count == 0)
            {
                log("links null");
                return null;
            }

            string subtitlehtml = null;

            try
            {
                subtitlehtml = root?["subtitle"]?.ToString();
            }
            catch { }

            return new MovieModel() { links = links, subtitlehtml = subtitlehtml };
        }

        async public ValueTask<MovieModel> Movie(string href)
        {
            var headers = HeadersModel.Init(init.headers,
                ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                ("cache-control", "no-cache"),
                ("dnt", "1"),
                ("pragma", "no-cache"),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-mode", "navigate"),
                ("sec-fetch-site", "same-origin"),
                ("sec-fetch-user", "?1"),
                ("upgrade-insecure-requests", "1")
            );

            string html = await onget($"{apihost}/{href}", headers);
            if (string.IsNullOrEmpty(html))
            {
                requesterror?.Invoke();
                return null;
            }

            string url = Regex.Match(html, "\"streams\"\\s*:\\s*\"(.*?)\"\\s*,").Groups[1].Value;
            if (string.IsNullOrEmpty(url) || url.ToLower() == "false")
            {
                requesterror?.Invoke();
                return null;
            }

            var links = getStreamLink(url.Replace("\\", ""));
            if (links.Count == 0)
                return null;

            return new MovieModel() 
            { 
                links = links,
                subtitlehtml = Regex.Match(html, "\"subtitle\":\"([^\"]+)\"").Groups[1].Value 
            };
        }

        public string Movie(MovieModel md, string title, string original_title, bool play, VastConf vast = null)
        {
            if (play)
                return onstreamfile(md.links[0].stream_url!);

            #region subtitles
            var subtitles = new SubtitleTpl();

            try
            {
                if (!string.IsNullOrWhiteSpace(md.subtitlehtml))
                {
                    var m = Regex.Match(md.subtitlehtml, "\\[([^\\]]+)\\](https?://[^\n\r,']+\\.vtt)");
                    while (m.Success)
                    {
                        if (!string.IsNullOrEmpty(m.Groups[1].Value) && !string.IsNullOrEmpty(m.Groups[2].Value))
                            subtitles.Append(m.Groups[1].Value, onstreamfile(m.Groups[2].Value));

                        m = m.NextMatch();
                    }
                }
            }
            catch { }
            #endregion

            var streamquality = new StreamQualityTpl();
            foreach (var l in md.links)
                streamquality.Append(onstreamfile(l.stream_url!), l.title);

            return VideoTpl.ToJson("play", onstreamfile(md.links[0].stream_url!), (title ?? original_title ?? "auto"), 
                streamquality: streamquality, 
                subtitles: subtitles, 
                vast: vast, 
                hls_manifest_timeout: (int)TimeSpan.FromSeconds(20).TotalMilliseconds
            );
        }
        #endregion


        #region decodeBase64
        static string decodeBase64(in string data)
        {
            if (data.StartsWith("#"))
            {
                try
                {
                    string[] trashList = ["JCQhIUAkJEBeIUAjJCRA", "QEBAQEAhIyMhXl5e", "IyMjI14hISMjIUBA", "Xl5eIUAjIyEhIyM=", "JCQjISFAIyFAIyM="];

                    string _data = data.Remove(0, 2);

                    foreach (string trash in trashList)
                        _data = _data.Replace($"//_//{trash}", "");

                    try
                    {
                        return Encoding.UTF8.GetString(Convert.FromBase64String(_data));
                    }
                    catch
                    {
                        _data = Regex.Replace(_data, "//[^/]+_//", "").Replace("//_//", "");
                        _data = Encoding.UTF8.GetString(Convert.FromBase64String(_data));

                        return _data;
                    }
                }
                catch
                {
                    string[] trashList = ["QEA=", "QCM=", "QCE=", "QF4=", "QCQ=", "I0A=", "IyM=", "IyE=", "I14=", "IyQ=", "IUA=", "ISM=", "ISE=", "IV4=", "ISQ=", "XkA=", "XiM=", "XiE=", "Xl4=", "XiQ=", "JEA=", "JCM=", "JCE=", "JF4=", "JCQ=", "QEBA", "QEAj", "QEAh", "QEBe", "QEAk", "QCNA", "QCMj", "QCMh", "QCNe", "QCMk", "QCFA", "QCEj", "QCEh", "QCFe", "QCEk", "QF5A", "QF4j", "QF4h", "QF5e", "QF4k", "QCRA", "QCQj", "QCQh", "QCRe", "QCQk", "I0BA", "I0Aj", "I0Ah", "I0Be", "I0Ak", "IyNA", "IyMj", "IyMh", "IyNe", "IyMk", "IyFA", "IyEj", "IyEh", "IyFe", "IyEk", "I15A", "I14j", "I14h", "I15e", "I14k", "IyRA", "IyQj", "IyQh", "IyRe", "IyQk", "IUBA", "IUAj", "IUAh", "IUBe", "IUAk", "ISNA", "ISMj", "ISMh", "ISNe", "ISMk", "ISFA", "ISEj", "ISEh", "ISFe", "ISEk", "IV5A", "IV4j", "IV4h", "IV5e", "IV4k", "ISRA", "ISQj", "ISQh", "ISRe", "ISQk", "XkBA", "XkAj", "XkAh", "XkBe", "XkAk", "XiNA", "XiMj", "XiMh", "XiNe", "XiMk", "XiFA", "XiEj", "XiEh", "XiFe", "XiEk", "Xl5A", "Xl4j", "Xl4h", "Xl5e", "Xl4k", "XiRA", "XiQj", "XiQh", "XiRe", "XiQk", "JEBA", "JEAj", "JEAh", "JEBe", "JEAk", "JCNA", "JCMj", "JCMh", "JCNe", "JCMk", "JCFA", "JCEj", "JCEh", "JCFe", "JCEk", "JF5A", "JF4j", "JF4h", "JF5e", "JF4k", "JCRA", "JCQj", "JCQh", "JCRe", "JCQk"];

                    string _data = data.Remove(0, 2).Replace("//_//", "");

                    foreach (string trash in trashList)
                        _data = _data.Replace(trash, "");

                    _data = Regex.Replace(_data, "//[^/]+_//", "").Replace("//_//", "");
                    _data = Encoding.UTF8.GetString(Convert.FromBase64String(_data));

                    return _data;
                }
            }

            return data;
        }
        #endregion

        #region getStreamLink
        List<ApiModel> getStreamLink(in string _data)
        {
            string data = decodeBase64(_data);
            var links = new List<ApiModel>(6);

            #region getLink
            string getLink(string _q)
            {
                string qline = Regex.Match(data, $"\\[({_q}|[^\\]]+{_q}[^\\]]+)\\]([^,\\[]+)").Groups[2].Value;
                if (!qline.Contains(".mp4") && !qline.Contains(".m3u8"))
                    return null;

                if (usereserve && qline.Contains(" or "))
                {
                    return string.Join(" or ", qline.Split(" or ").Select(i =>
                    {
                        string l = Regex.Match(i, "(https?://[^\\[\n\r, ]+)").Groups[1].Value;
                        if (usehls)
                        {
                            if (l.EndsWith(".m3u8"))
                                return l;

                            return l + ":hls:manifest.m3u8";
                        }

                        return l.Replace(":hls:manifest.m3u8", "");
                    }));
                }
                else
                {
                    string link = Regex.Match(qline, "(https?://[^\\[\n\r, ]+)").Groups[1].Value;
                    if (string.IsNullOrEmpty(link))
                        return null;

                    if (usehls)
                    {
                        if (link.EndsWith(".m3u8"))
                            return link;

                        return link + ":hls:manifest.m3u8";
                    }

                    return link.Replace(":hls:manifest.m3u8", "");
                }
            }
            #endregion

            #region –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ—Å—Ç—É–ø–Ω–æ–µ
            var qualities = new List<string> { "2160p", "1440p", "1080p", "720p", "480p" };
            if (userprem)
                qualities.InsertRange(2, new List<string> { "1080p Ultra" });

            foreach (string q in qualities)
            {
                string link = null;

                switch (q)
                {
                    case "2160p":
                        link = getLink("4K") ?? getLink(q);
                        break;
                    case "1440p":
                        link = getLink("2K") ?? getLink(q);
                        break;
                    case "1080p":
                        link = userprem ? getLink(q) : (getLink(q) ?? getLink("1080p Ultra"));
                        break;
                    default:
                        link = getLink(q);
                        break;
                }

                if (string.IsNullOrEmpty(link))
                    continue;

                if (scheme == "http")
                    link = link.Replace("https:", "http:");

                string realq = q;

                switch (q)
                {
                    case "1080p Ultra":
                        realq = "1080p";
                        break;
                    case "1080p":
                        realq = "720p";
                        break;
                    case "720p":
                        realq = "480p";
                        break;
                    case "480p":
                        realq = "360p";
                        break;
                }

                links.Add(new ApiModel()
                {
                    title = realq,
                    stream_url = link
                });
            }
            #endregion

            return links;
        }
        #endregion


        #region fixcdn
        public static string fixcdn(string country, string uacdn, string link)
        {
            if (uacdn != null && country == "UA" && !link.Contains(".vtt"))
                return Regex.Replace(link, "https?://[^/]+", uacdn);

            return link;
        }
        #endregion

        #region StreamProxyHeaders
        public static List<HeadersModel> StreamProxyHeaders(RezkaSettings init) => HeadersModel.Init(init.headers,
            ("accept", "*/*"),
            ("cache-control", "no-cache"),
            ("dnt", "1"),
            ("origin", init.host),
            ("pragma", "no-cache"),
            ("referer", $"{init.host}/"),
            ("sec-fetch-dest", "empty"),
            ("sec-fetch-mode", "cors"),
            ("sec-fetch-site", "cross-site")
        );
        #endregion
    }
}

```

## File: JacRed/ApiController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Jackett;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;

namespace JacRed.Controllers
{
    public class ApiController : JacBaseController
    {
        #region Conf
        [Route("api/v1.0/conf")]
        public JsonResult JacConf(string apikey)
        {
            return Json(new
            {
                apikey = string.IsNullOrWhiteSpace(AppInit.conf.apikey) || apikey == AppInit.conf.apikey
            });
        }
        #endregion

        #region Indexers
        [Route("/api/v2.0/indexers/{status}/results")]
        async public Task<ActionResult> Indexers(string apikey, string query, string title, string title_original, int year, Dictionary<string, string> category, int is_serial = -1)
        {
            if (string.IsNullOrEmpty(ModInit.conf.typesearch))
                return Content("typesearch == null");

            #region –ó–∞–ø—Ä–æ—Å —Å NUM
            bool rqnum = !HttpContext.Request.QueryString.Value.Contains("&is_serial=") && HttpContext.Request.Headers.UserAgent.ToString() == "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36";

            if (rqnum && query != null)
            {
                var mNum = Regex.Match(query, "^([^a-z-A-Z]+) ([^–∞-—è-–ê-–Ø]+) ([0-9]{4})$");

                if (mNum.Success)
                {
                    if (Regex.IsMatch(mNum.Groups[2].Value, "[a-zA-Z0-9]{2}"))
                    {
                        var g = mNum.Groups;
                        title = g[1].Value;
                        title_original = g[2].Value;
                        year = int.Parse(g[3].Value);
                    }
                }
                else
                {
                    if (Regex.IsMatch(query, "^([^a-z-A-Z]+) ((19|20)[0-9]{2})$"))
                        return Content(JsonConvert.SerializeObject(new { Results = new List<object>(), jacred = ModInit.conf.typesearch == "red" }), "application/json; charset=utf-8");

                    mNum = Regex.Match(query, "^([^a-z-A-Z]+) ([^–∞-—è-–ê-–Ø]+)$");

                    if (mNum.Success)
                    {
                        if (Regex.IsMatch(mNum.Groups[2].Value, "[a-zA-Z0-9]{2}"))
                        {
                            var g = mNum.Groups;
                            title = g[1].Value;
                            title_original = g[2].Value;
                        }
                    }
                }
            }
            #endregion

            if (!HttpContext.Request.QueryString.Value.ToLower().Contains("&category[]="))
                category = null;

            IEnumerable<TorrentDetails> torrents = null;

            if (ModInit.conf.typesearch == "red")
            {
                #region red
                string memoryKey = $"{ModInit.conf.typesearch}:{query}:{rqnum}:{title}:{title_original}:{year}:{is_serial}";
                if (!hybridCache.TryGetValue(memoryKey, out List<TorrentDetails> _redCache, inmemory: false))
                {
                    var res = RedApi.Indexers(rqnum, apikey, query, title, title_original, year, is_serial, category);

                    _redCache = res.torrents.ToList();

                    if (res.setcache && !red.evercache.enable)
                        hybridCache.Set(memoryKey, _redCache, DateTime.Now.AddMinutes(5), inmemory: false);
                }

                if (ModInit.conf.merge == "jackett")
                {
                    torrents = mergeTorrents
                    (
                        _redCache,
                        await JackettApi.Indexers(host, query, title, title_original, year, is_serial, category)
                    );
                }
                else
                { 
                    torrents = _redCache;
                }
                #endregion
            }
            else if (ModInit.conf.typesearch == "webapi")
            {
                #region webapi
                if (ModInit.conf.merge == "jackett")
                {
                    var t1 = WebApi.Indexers(query, title, title_original, year, is_serial, category);
                    var t2 = JackettApi.Indexers(host, query, title, title_original, year, is_serial, category);

                    await Task.WhenAll(t1, t2);

                    torrents = mergeTorrents(t1.Result, t2.Result);
                }
                else
                {
                    torrents = await WebApi.Indexers(query, title, title_original, year, is_serial, category);
                }
                #endregion
            }
            else if (ModInit.conf.typesearch == "jackett")
            {
                torrents = await JackettApi.Indexers(host, query, title, title_original, year, is_serial, category);
            }

            return Content(JsonConvert.SerializeObject(new
            {
                Results = torrents.OrderByDescending(i => i.createTime).Take(2_000).Select(i => new
                {
                    Tracker = i.trackerName,
                    Details = i.url != null && i.url.StartsWith("http") ? i.url : null,
                    Title = i.title,
                    Size = (long)(0 >= i.size ? getSizeInfo(i.sizeName) : i.size),
                    PublishDate = i.createTime,
                    Category = getCategoryIds(i, out string categoryDesc),
                    CategoryDesc = categoryDesc,
                    Seeders = i.sid,
                    Peers = i.pir,
                    MagnetUri = i.magnet,
                    Link = i.parselink != null ? $"{i.parselink}&apikey={apikey}" : null,
                    Info = ModInit.conf.typesearch != "red" || rqnum ? null : new
                    {
                        i.name,
                        i.originalname,
                        i.relased,
                        i.quality,
                        i.videotype,
                        i.sizeName,
                        i.voices,
                        seasons = i.seasons != null && i.seasons.Count > 0 ? i.seasons : null,
                        i.types
                    },
                    languages = !rqnum && i.languages != null && i.languages.Count > 0 ? i.languages : null,
                    ffprobe = rqnum ? null : i.ffprobe
                }),
                jacred = ModInit.conf.typesearch == "red"

            }, new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }), "application/json; charset=utf-8");
        }
        #endregion

        #region Api
        [Route("/api/v1.0/torrents")]
        async public Task<ActionResult> Api(string apikey, string search, string altname, bool exact, string type, string sort, string tracker, string voice, string videotype, long relased, long quality, long season)
        {
            if (string.IsNullOrEmpty(ModInit.conf.typesearch))
                return Content("typesearch == null");

            #region search kp/imdb
            if (!string.IsNullOrWhiteSpace(search) && Regex.IsMatch(search.Trim(), "^(tt|kp)[0-9]+$"))
            {
                string memkey = $"api/v1.0/torrents:{search}";
                if (!hybridCache.TryGetValue(memkey, out (string original_name, string name) cache, inmemory: false))
                {
                    search = search.Trim();
                    string uri = $"&imdb={search}";
                    if (search.StartsWith("kp"))
                        uri = $"&kp={search.Remove(0, 2)}";

                    var root = await Http.Get<JObject>("https://api.alloha.tv/?token=04941a9a3ca3ac16e2b4327347bbc1" + uri, timeoutSeconds: 10);
                    cache.original_name = root?.Value<JObject>("data")?.Value<string>("original_name");
                    cache.name = root?.Value<JObject>("data")?.Value<string>("name");

                    hybridCache.Set(memkey, cache, DateTime.Now.AddDays(1), inmemory: false);
                }

                if (!string.IsNullOrWhiteSpace(cache.name) && !string.IsNullOrWhiteSpace(cache.original_name))
                {
                    search = cache.original_name;
                    altname = cache.name;
                }
                else
                {
                    search = cache.original_name ?? cache.name;
                }
            }
            #endregion

            IEnumerable<TorrentDetails> torrents = null;

            if (ModInit.conf.typesearch == "red")
            {
                #region red
                torrents = RedApi.Api(search, altname, exact, type, sort, tracker, voice, videotype, relased, quality, season);

                if (ModInit.conf.merge == "jackett")
                {
                    torrents = mergeTorrents
                    (
                        torrents,
                        await JackettApi.Api(host, search)
                    );
                }
                #endregion
            }
            else if (ModInit.conf.typesearch == "webapi")
            {
                #region webapi
                if (ModInit.conf.merge == "jackett")
                {
                    var t1 = WebApi.Api(search);
                    var t2 = JackettApi.Api(host, search);

                    await Task.WhenAll(t1, t2);

                    torrents = mergeTorrents(t1.Result, t2.Result);
                }
                else
                {
                    torrents = await WebApi.Api(search);
                }
                #endregion
            }
            else if (ModInit.conf.typesearch == "jackett")
            {
                torrents = await JackettApi.Api(host, search);
            }

            return Content(JsonConvert.SerializeObject(torrents.Take(2_000).Select(i => new
            {
                tracker = i.trackerName,
                url = i.url != null && i.url.StartsWith("http") ? i.url : null,
                i.title,
                size = 0 > i.size ? getSizeInfo(i.sizeName) : i.size,
                i.sizeName,
                i.createTime,
                i.sid,
                i.pir,
                magnet = i.magnet ?? $"{i.parselink}&apikey={apikey}",
                i.name,
                i.originalname,
                i.relased,
                i.videotype,
                i.quality,
                i.voices,
                i.seasons,
                i.types

            }), new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }), "application/json; charset=utf-8");
        }
        #endregion


        #region getSizeInfo
        long getSizeInfo(string sizeName)
        {
            if (string.IsNullOrWhiteSpace(sizeName))
                return 0;

            try
            {
                double size = 0.1;
                var gsize = Regex.Match(sizeName, "([0-9\\.,]+) (Mb|–ú–ë|GB|–ì–ë|TB|–¢–ë)", RegexOptions.IgnoreCase).Groups;
                if (!string.IsNullOrWhiteSpace(gsize[2].Value))
                {
                    if (double.TryParse(gsize[1].Value.Replace(",", "."), NumberStyles.Any, CultureInfo.InvariantCulture, out size) && size != 0)
                    {
                        if (gsize[2].Value.ToLower() is "gb" or "–≥–±")
                            size *= 1024;

                        if (gsize[2].Value.ToLower() is "tb" or "—Ç–±")
                            size *= 1048576;

                        return (long)(size * 1048576);
                    }
                }
            }
            catch { }

            return 0;
        }
        #endregion

        #region getCategoryIds
        HashSet<int> getCategoryIds(TorrentDetails t, out string categoryDesc)
        {
            categoryDesc = null;
            HashSet<int> categoryIds = new HashSet<int>();

            if (t.types == null)
                return categoryIds;

            foreach (string type in t.types)
            {
                switch (type)
                {
                    case "movie":
                        categoryDesc = "Movies";
                        categoryIds.Add(2000);
                        break;

                    case "serial":
                        categoryDesc = "TV";
                        categoryIds.Add(5000);
                        break;

                    case "documovie":
                    case "docuserial":
                        categoryDesc = "TV/Documentary";
                        categoryIds.Add(5080);
                        break;

                    case "tvshow":
                        categoryDesc = "TV/Foreign";
                        categoryIds.Add(5020);
                        categoryIds.Add(2010);
                        break;

                    case "anime":
                        categoryDesc = "TV/Anime";
                        categoryIds.Add(5070);
                        break;
                }
            }

            return categoryIds;
        }
        #endregion

        #region mergeTorrents
        static IEnumerable<TorrentDetails> mergeTorrents(IEnumerable<TorrentDetails> red, IEnumerable<TorrentDetails> jac)
        {
            if (red == null && jac == null)
                return new List<TorrentDetails>();

            if (red == null || !red.Any())
                return jac;

            if (jac == null || !jac.Any())
                return red;

            var torrents = new Dictionary<string, TorrentDetails>();

            foreach (var i in red.Concat(jac))
            {
                if (string.IsNullOrEmpty(i.url) || !i.url.StartsWith("http"))
                    continue;

                void add(string url) { torrents.TryAdd(Regex.Replace(url, "^https?://[^/]+/", ""), (TorrentDetails)i.Clone()); }

                if (i.urls != null && i.urls.Count > 0)
                {
                    foreach (string u in i.urls)
                        add(u);
                }
                else
                {
                    add(i.url);
                }
            }

            return torrents.Values;
        }
        #endregion
    }
}

```

## File: JacRed/ModInit.cs
```
Ôªøusing JacRed.Models.AppConf;
using Newtonsoft.Json;
using System.Threading;

namespace Jackett
{
    public class ModInit
    {
        #region ModInit
        static (ModInit, DateTime) cacheconf = default;

        public static ModInit conf
        {
            get
            {
                if (cacheconf.Item1 == null)
                {
                    if (!File.Exists("module/JacRed.conf"))
                        return new ModInit();
                }

                var lastWriteTime = File.GetLastWriteTime("module/JacRed.conf");

                if (cacheconf.Item2 != lastWriteTime)
                {
                    var jss = new JsonSerializerSettings { Error = (se, ev) => 
                    { 
                        ev.ErrorContext.Handled = true; 
                        Console.WriteLine("module/JacRed.conf - " + ev.ErrorContext.Error + "\n\n"); 
                    }};

                    string json = File.ReadAllText("module/JacRed.conf");
                    if (!json.TrimStart().StartsWith("{"))
                        json = "{"+json+"}";

                    cacheconf.Item1 = JsonConvert.DeserializeObject<ModInit>(json, jss);
                    cacheconf.Item2 = lastWriteTime;
                }

                return cacheconf.Item1;
            }
        }
        #endregion

        public static void loaded()
        {
            Directory.CreateDirectory("cache/jacred");
            File.WriteAllText("module/JacRed.current.conf", JsonConvert.SerializeObject(conf, Formatting.Indented));

            ThreadPool.QueueUserWorkItem(async _ => await SyncCron.Run());
            ThreadPool.QueueUserWorkItem(async _ => await FileDB.Cron());
            ThreadPool.QueueUserWorkItem(async _ => await FileDB.CronFast());


            ThreadPool.QueueUserWorkItem(async _ =>
            {
                while (true)
                {
                    await Task.Delay(TimeSpan.FromMinutes(5));

                    try
                    {
                        if (conf.typesearch == "jackett" || conf.merge == "jackett")
                        {
                            async ValueTask<bool> showdown(string name, TrackerSettings settings)
                            {
                                if (!settings.monitor_showdown)
                                    return false;

                                var proxyManager = new ProxyManager(name, settings);
                                string html = await Http.Get($"{settings.host}", timeoutSeconds: conf.Jackett.timeoutSeconds, proxy: proxyManager.Get(), weblog: false);
                                return html == null;
                            }

                            conf.Jackett.Rutor.showdown = await showdown("rutor", conf.Jackett.Rutor);
                            conf.Jackett.Megapeer.showdown = await showdown("megapeer", conf.Jackett.Megapeer);
                            conf.Jackett.TorrentBy.showdown = await showdown("torrentby", conf.Jackett.TorrentBy);
                            conf.Jackett.Kinozal.showdown = await showdown("kinozal", conf.Jackett.Kinozal);
                            conf.Jackett.NNMClub.showdown = await showdown("nnmclub", conf.Jackett.NNMClub);
                            conf.Jackett.Bitru.showdown = await showdown("bitru", conf.Jackett.Bitru);
                            conf.Jackett.Toloka.showdown = await showdown("toloka", conf.Jackett.Toloka);
                            conf.Jackett.Rutracker.showdown = await showdown("rutracker", conf.Jackett.Rutracker);
                            conf.Jackett.BigFanGroup.showdown = await showdown("bigfangroup", conf.Jackett.BigFanGroup);
                            conf.Jackett.Selezen.showdown = await showdown("selezen", conf.Jackett.Selezen);
                            conf.Jackett.Lostfilm.showdown = await showdown("lostfilm", conf.Jackett.Lostfilm);
                            conf.Jackett.Anilibria.showdown = await showdown("anilibria", conf.Jackett.Anilibria);
                            conf.Jackett.Animelayer.showdown = await showdown("animelayer", conf.Jackett.Animelayer);
                            conf.Jackett.Anifilm.showdown = await showdown("anifilm", conf.Jackett.Anifilm);
                        }
                    }
                    catch { }
                }
            });
        }


        /// <summary>
        /// red
        /// jackett
        /// webapi
        /// </summary>
        public string typesearch = "webapi";

        public string merge = "jackett";

        public string webApiHost = "http://redapi.cfhttp.top";

        public string filter { get; set; }

        public string filter_ignore { get; set; }


        public RedConf Red = new RedConf();

        public JacConf Jackett = new JacConf();
    }
}

```

## File: JacRed/GlobalUsings.cs
```
Ôªøglobal using System;
global using System.Web;
global using System.Threading.Tasks;
global using System.Collections.Generic;
global using System.Text.RegularExpressions;
global using System.Collections.Concurrent;
global using System.Globalization;
global using System.IO;
global using System.Linq;
global using HtmlAgilityPack;
global using Shared;
global using Shared.Models;
global using Shared.Engine;
global using JacRed.Engine;
global using Shared.Engine.JacRed;
global using Shared.Models.JacRed;
```

## File: JacRed/Models/WriteTaskModel.cs
```
Ôªønamespace JacRed.Models
{
    public class WriteTaskModel
    {
        public FileDB db { get; set; }

        public int openconnection { get; set; }

        public int countread { get; set; }

        public DateTime lastread { get; set; }

        public DateTime create { get; set; } = DateTime.Now;
    }
}

```

## File: JacRed/Models/AniLibria/RootObject.cs
```
Ôªønamespace JacRed.Models.AniLibria
{
    public class RootObject
    {
        public Names names { get; set; }

        public string code { get; set; }

        public Torrents torrents { get; set; }

        public Season season { get; set; }

        public long updated { get; set; }

        public long last_change { get; set; }
    }
}

```

## File: JacRed/Models/AniLibria/Torrent.cs
```
Ôªønamespace JacRed.Models.AniLibria
{
    public class Torrent
    {
        public Series series { get; set; }

        public Quality quality { get; set; }

        public int leechers { get; set; }

        public int seeders { get; set; }

        public string url { get; set; }

        public long total_size { get; set; }
    }
}

```

## File: JacRed/Models/AniLibria/Series.cs
```
Ôªønamespace JacRed.Models.AniLibria
{
    public class Series
    {
        public string @string { get; set; }
    }
}

```

## File: JacRed/Models/AniLibria/Quality.cs
```
Ôªønamespace JacRed.Models.AniLibria
{
    public class Quality
    {
        public string @string { get; set; }

        public int resolution { get; set; }

        public string encoder { get; set; }
    }
}

```

## File: JacRed/Models/AniLibria/Torrents.cs
```
Ôªønamespace JacRed.Models.AniLibria
{
    public class Torrents
    {
        public List<Torrent> list { get; set; }
    }
}

```

## File: JacRed/Models/AniLibria/Names.cs
```
Ôªønamespace JacRed.Models.AniLibria
{
    public class Names
    {
        public string ru { get; set; }

        public string en { get; set; }
    }
}

```

## File: JacRed/Models/AniLibria/Season.cs
```
Ôªønamespace JacRed.Models.AniLibria
{
    public class Season
    {
        public int year { get; set; }

        public int code { get; set; }
    }
}

```

## File: JacRed/Models/AppConf/JacConf.cs
```
Ôªønamespace JacRed.Models.AppConf
{
    public class JacConf
    {
        public int cacheToMinutes = 5;

        public string search_lang = "query";

        public int timeoutSeconds = 8;


        public TrackerSettings Rutor = new TrackerSettings("https://rutor.info"/*, priority: "torrent"*/);

        public TrackerSettings Megapeer = new TrackerSettings("https://megapeer.vip", enable: false);

        public TrackerSettings TorrentBy = new TrackerSettings("https://torrent.by"/*, priority: "torrent"*/);

        public TrackerSettings Kinozal = new TrackerSettings("https://kinozal.tv");

        public TrackerSettings NNMClub = new TrackerSettings("https://nnmclub.to");

        public TrackerSettings Bitru = new TrackerSettings("https://bitru.org");

        public TrackerSettings Toloka = new TrackerSettings("https://toloka.to");

        public TrackerSettings Rutracker = new TrackerSettings("https://rutracker.org"/*, priority: "torrent"*/);

        public TrackerSettings BigFanGroup = new TrackerSettings("https://bigfangroup.org");

        public TrackerSettings Selezen = new TrackerSettings("https://open.selezen.org"/*, priority: "torrent"*/);

        public TrackerSettings Lostfilm = new TrackerSettings("https://www.lostfilm.tv");

        public TrackerSettings Anilibria = new TrackerSettings("https://www.anilibria.tv");

        public TrackerSettings Animelayer = new TrackerSettings("http://animelayer.ru");

        public TrackerSettings Anifilm = new TrackerSettings("https://anifilm.pro");
    }
}

```

## File: JacRed/Models/AppConf/TrackerSettings.cs
```
Ôªøusing Shared.Models.Base;

namespace JacRed.Models.AppConf
{
    public class TrackerSettings : Iproxy
    {
        public TrackerSettings(string host, bool enable = true, bool useproxy = false, LoginSettings login = null, string priority = null)
        {
            this.host = host;
            this.enable = enable;
            this.useproxy = useproxy;

            if (login != null)
                this.login = login;

            this.priority = priority;
        }


        public string host { get; set; }

        public bool enable { get; set; }

        public bool showdown { get; set; }

        public bool monitor_showdown { get; set; } = true;

        public string priority { get; set; }

        public LoginSettings login { get; set; } = new LoginSettings();

        public string cookie { get; set; }


        public bool useproxy { get; set; }

        public bool useproxystream { get; set; }

        public string globalnameproxy { get; set; }

        public ProxySettings proxy { get; set; }
    }
}

```

## File: JacRed/Models/AppConf/Evercache.cs
```
Ôªønamespace JacRed.Models.AppConf
{
    public class Evercache
    {
        public bool enable = false;

        public int validHour = 1;

        public int maxOpenWriteTask { get; set; } = 1000;

        public int dropCacheTake { get; set; } = 100;
    }
}

```

## File: JacRed/Models/AppConf/RedConf.cs
```
Ôªønamespace JacRed.Models.AppConf
{
    public class RedConf
    {
        public string syncapi = "http://redapi.cfhttp.top";

        public int syntime = 60;

        public string[] trackers = new string[] { "rutracker", "rutor", "kinozal", "nnmclub", "megapeer", "bitru", "toloka", "lostfilm", "baibako", "torrentby", "hdrezka", "selezen", "animelayer", "anilibria", "anifilm" };

        public int maxreadfile = 300;

        public bool mergeduplicates = true;

        public bool mergenumduplicates = true;

        public Evercache evercache = new Evercache();
    }
}

```

## File: JacRed/Models/AppConf/LoginSettings.cs
```
Ôªønamespace JacRed.Models.AppConf
{
    public class LoginSettings
    {
        public string u { get; set; }

        public string p { get; set; }
    }
}

```

## File: JacRed/Models/Sync/RootObject.cs
```
Ôªønamespace JacRed.Models.Sync
{
    public class RootObject
    {
        public bool nextread { get; set; }

        public List<Collection> collections { get; set; }
    }
}

```

## File: JacRed/Models/Sync/Value.cs
```
Ôªønamespace JacRed.Models.Sync
{
    public class Value
    {
        public DateTime time { get; set; }

        public long fileTime { get; set; }

        public Dictionary<string, TorrentDetails> torrents { get; set; }
    }
}

```

## File: JacRed/Models/Sync/Collection.cs
```
Ôªønamespace JacRed.Models.Sync
{
    public class Collection
    {
        public string Key { get; set; }

        public Value Value { get; set; }
    }
}

```

## File: JacRed/Controllers/KinozalController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;

namespace JacRed.Controllers
{
    [Route("kinozal/[action]")]
    public class KinozalController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string[] cats)
        {
            if (!jackett.Kinozal.enable || jackett.Kinozal.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cats));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string id)
        {
            if (!jackett.Kinozal.enable)
                return Content("disable");

            var proxyManager = new ProxyManager("kinozal", jackett.Kinozal);

            #region Download
            if (jackett.Kinozal.cookie != null || Cookie != null)
            {
                var _t = await Http.Download("http://dl.kinozal.tv/download.php?id=" + id, proxy: proxyManager.Get(), cookie: jackett.Kinozal.cookie ?? Cookie, referer: jackett.Kinozal.host, timeoutSeconds: 10);
                if (_t != null && BencodeTo.Magnet(_t) != null)
                    return File(_t, "application/x-bittorrent");
            }
            #endregion

            string srv_details = await Http.Post($"{jackett.Kinozal.host}/get_srv_details.php?id={id}&action=2", $"id={id}&action=2", "__cfduid=d476ac2d9b5e18f2b67707b47ebd9b8cd1560164391; uid=20520283; pass=ouV5FJdFCd;", proxy: proxyManager.Get(), timeoutSeconds: 10);
            if (srv_details != null)
            {
                string torrentHash = new Regex("<ul><li>–ò–Ω—Ñ–æ —Ö–µ—à: +([^<]+)</li>").Match(srv_details).Groups[1].Value;
                if (!string.IsNullOrEmpty(torrentHash))
                    return Redirect($"magnet:?xt=urn:btih:{torrentHash}");
            }

            proxyManager.Refresh();
            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string[] cats)
        {
            var torrents = new List<TorrentDetails>();
            var proxyManager = new ProxyManager("kinozal", jackett.Kinozal);

            string html = await Http.Get($"{jackett.Kinozal.host}/browse.php?s={HttpUtility.UrlEncode(query)}&g=0&c=0&v=0&d=0&w=0&t=0&f=0", proxy: proxyManager.Get(), timeoutSeconds: jackett.timeoutSeconds);

            if (html != null && html.Contains("–ö–∏–Ω–æ–∑–∞–ª.–¢–í</title>"))
            {
                if (!html.Contains(">–í—ã—Ö–æ–¥</a>") && !string.IsNullOrWhiteSpace(jackett.Kinozal.login.u) && !string.IsNullOrWhiteSpace(jackett.Kinozal.login.p))
                    TakeLogin();
            }
            else if (html == null)
            {
                consoleErrorLog("kinozal");
                proxyManager.Refresh();
                return null;
            }

            foreach (string row in Regex.Split(html, "<tr class=('first bg'|bg)>").Skip(1))
            {
                if (string.IsNullOrWhiteSpace(row))
                    continue;

                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string pattern, int index = 1)
                {
                    string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim());
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è
                DateTime createTime = default;

                if (row.Contains("<td class='s'>—Å–µ–≥–æ–¥–Ω—è"))
                {
                    createTime = DateTime.Today;
                }
                else if (row.Contains("<td class='s'>–≤—á–µ—Ä–∞"))
                {
                    createTime = DateTime.Today.AddDays(-1);
                }
                else
                {
                    createTime = tParse.ParseCreateTime(Match("<td class='s'>([0-9]{2}.[0-9]{2}.[0-9]{4}) –≤ [0-9]{2}:[0-9]{2}"), "dd.MM.yyyy");
                }
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                string url = Match("href=\"/(details.php\\?id=[0-9]+)\"");
                string tracker = Match("src=\"/pic/cat/([0-9]+)\\.gif\"");
                string title = Match("class=\"r[0-9]+\">([^<]+)");
                string _sid = Match("<td class='sl_s'>([0-9]+)");
                string _pir = Match("<td class='sl_p'>([0-9]+)");
                string sizeName = Match("<td class='s'>([0-9\\.,]+ (–ú–ë|–ì–ë))");

                if (string.IsNullOrWhiteSpace(url) || string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(tracker))
                    continue;
                #endregion

                // Id –Ω–æ–≤–æ—Å—Ç–∏
                string id = Match("href=\"/details.php\\?id=([0-9]+)\"");
                if (string.IsNullOrEmpty(id))
                    continue;

                #region types
                string[] types = new string[] { };
                switch (tracker)
                {
                    case "1002":
                    case "8":
                    case "6":
                    case "15":
                    case "17":
                    case "35":
                    case "39":
                    case "13":
                    case "14":
                    case "24":
                    case "11":
                    case "10":
                    case "9":
                    case "47":
                    case "18":
                    case "37":
                    case "12":
                    case "7":
                    case "16":
                        types = new string[] { "movie" };
                        break;
                    case "45":
                    case "46":
                        types = new string[] { "serial" };
                        break;
                    case "21":
                    case "22":
                        types = new string[] { "multfilm", "multserial" };
                        break;
                    case "20":
                        types = new string[] { "anime" };
                        break;
                    case "1006":
                    case "48":
                    case "49":
                    case "50":
                    case "38":
                        types = new string[] { "tvshow" };
                        break;
                }

                if (cats != null)
                {
                    if (types == null)
                        continue;

                    bool isok = false;
                    foreach (string cat in cats)
                    {
                        if (types.Contains(cat))
                            isok = true;
                    }

                    if (!isok)
                        continue;
                }
                #endregion

                int.TryParse(_sid, out int sid);
                int.TryParse(_pir, out int pir);

                torrents.Add(new TorrentDetails()
                {
                    types = types,
                    url = $"{jackett.Kinozal.host}/{url}",
                    title = title,
                    sid = sid,
                    pir = pir,
                    sizeName = sizeName,
                    createTime = createTime,
                    parselink = $"{host}/kinozal/parsemagnet?id={id}"
                });
            }

            return torrents;
        }
        #endregion


        #region Cookie / TakeLogin
        static string Cookie;

        async static void TakeLogin()
        {
            string authKey = "kinozal:TakeLogin()";
            if (Startup.memoryCache.TryGetValue(authKey, out _))
                return;

            Startup.memoryCache.Set(authKey, 0, AppInit.conf.multiaccess ? TimeSpan.FromMinutes(2) : TimeSpan.FromSeconds(20));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(jackett.timeoutSeconds);
                        client.MaxResponseContentBufferSize = 2000000; // 2MB
                        client.DefaultRequestHeaders.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36");
                        client.DefaultRequestHeaders.Add("cache-control", "no-cache");
                        client.DefaultRequestHeaders.Add("dnt", "1");
                        client.DefaultRequestHeaders.Add("origin", jackett.Kinozal.host);
                        client.DefaultRequestHeaders.Add("pragma", "no-cache");
                        client.DefaultRequestHeaders.Add("referer", $"{jackett.Kinozal.host}/");
                        client.DefaultRequestHeaders.Add("upgrade-insecure-requests", "1");

                        var postParams = new Dictionary<string, string>
                    {
                        { "username", jackett.Kinozal.login.u },
                        { "password", jackett.Kinozal.login.p },
                        { "returnto", "" }
                    };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync($"{jackett.Kinozal.host}/takelogin.php", postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string uid = null, pass = null;
                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrWhiteSpace(line))
                                            continue;

                                        if (line.Contains("uid="))
                                            uid = new Regex("uid=([0-9]+)").Match(line).Groups[1].Value;

                                        if (line.Contains("pass="))
                                            pass = new Regex("pass=([^;]+)(;|$)").Match(line).Groups[1].Value;
                                    }

                                    if (!string.IsNullOrWhiteSpace(uid) && !string.IsNullOrWhiteSpace(pass))
                                        Cookie = $"uid={uid}; pass={pass};";
                                }
                            }
                        }
                    }
                }
            }
            catch { }
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/RutrackerController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;

namespace JacRed.Controllers
{
    [Route("rutracker/[action]")]
    public class RutrackerController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string[] cats)
        {
            if (!jackett.Rutracker.enable || string.IsNullOrEmpty(jackett.Rutracker.cookie ?? jackett.Rutracker.login.u) || jackett.Rutracker.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cats));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string id)
        {
            if (!jackett.Rutracker.enable)
                return Content("disable");

            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
                return Content("cookie == null");

            var proxyManager = new ProxyManager("rutracker", jackett.Rutracker);

            #region Download
            if (jackett.Rutracker.priority == "torrent")
            {
                var _t = await Http.Download($"{jackett.Rutracker.host}/forum/dl.php?t={id}", proxy: proxyManager.Get(), cookie: cookie, referer: jackett.Rutracker.host);
                if (_t != null && BencodeTo.Magnet(_t) != null)
                    return File(_t, "application/x-bittorrent");
            }
            #endregion

            #region Magnet
            var fullNews = await Http.Get($"{jackett.Rutracker.host}/forum/viewtopic.php?t=" + id, proxy: proxyManager.Get(), cookie: cookie);
            if (fullNews != null)
            {
                string magnet = Regex.Match(fullNews, "href=\"(magnet:[^\"]+)\" class=\"(med )?med magnet-link\"").Groups[1].Value;
                if (!string.IsNullOrWhiteSpace(magnet))
                    return Redirect(magnet);
            }
            #endregion

            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string[] cats)
        {
            var torrents = new List<TorrentDetails>();
            var proxyManager = new ProxyManager("rutracker", jackett.Rutracker);

            #region –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
            {
                consoleErrorLog("rutracker");
                return null;
            }
            #endregion

            #region –ö–µ—à html
            string html = await Http.Get($"{jackett.Rutracker.host}/forum/tracker.php?nm=" + HttpUtility.UrlEncode(query), proxy: proxyManager.Get(), cookie: cookie, timeoutSeconds: jackett.timeoutSeconds);

            if (html != null)
            {
                if (!html.Contains("id=\"logged-in-username\""))
                {
                    consoleErrorLog("rutracker");
                    return null;
                }
            }
            #endregion

            foreach (string row in html.Split("class=\"tCenter hl-tr\"").Skip(1))
            {
                if (string.IsNullOrWhiteSpace(row))
                    continue;

                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string pattern, int index = 1)
                {
                    string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim());
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                string title = Match("href=\"viewtopic.php\\?t=[0-9]+\">([^\n\r]+)</a>");
                title = Regex.Replace(title, "<[^>]+>", "");

                DateTime createTime = tParse.ParseCreateTime(Match("<p>([0-9]{2}-[^-<]+-[0-9]{2})</p>").Replace("-", " "), "dd.MM.yy");
                string viewtopic = Match("href=\"viewtopic.php\\?t=([0-9]+)\"");
                string tracker = Match("href=\"tracker.php\\?f=([0-9]+)");
                string _sid = Match("class=\"seedmed\">([0-9]+)");
                string _pir = Match("title=\"–õ–∏—á–∏\">([0-9]+)");
                string sizeName = Match("href=\"dl.php\\?t=[0-9]+\">([^<]+) &#8595;</a>").Replace("&nbsp;", " ");

                if (string.IsNullOrWhiteSpace(viewtopic) || string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(tracker))
                    continue;
                #endregion

                #region types
                string[] types = null;
                switch (tracker)
                {
                    case "22":
                    case "1666":
                    case "941":
                    case "1950":
                    case "2090":
                    case "2221":
                    case "2091":
                    case "2092":
                    case "2093":
                    case "2200":
                    case "2540":
                    case "934":
                    case "505":
                    case "124":
                    case "1457":
                    case "2199":
                    case "313":
                    case "312":
                    case "1247":
                    case "2201":
                    case "2339":
                    case "140":
                    case "252":
                    case "2198":
                        types = new string[] { "movie" };
                        break;
                    case "2343":
                    case "930":
                    case "2365":
                    case "208":
                    case "539":
                    case "209":
                        types = new string[] { "multfilm" };
                        break;
                    case "921":
                    case "815":
                    case "1460":
                        types = new string[] { "multserial" };
                        break;
                    case "842":
                    case "235":
                    case "242":
                    case "819":
                    case "1531":
                    case "721":
                    case "1102":
                    case "1120":
                    case "1214":
                    case "489":
                    case "387":
                    case "9":
                    case "81":
                    case "119":
                    case "1803":
                    case "266":
                    case "193":
                    case "1690":
                    case "1459":
                    case "825":
                    case "1248":
                    case "1288":
                    case "325":
                    case "534":
                    case "694":
                    case "704":
                    case "915":
                    case "1939":
                        types = new string[] { "serial" };
                        break;
                    case "1105":
                    case "2491":
                    case "1389":
                        types = new string[] { "anime" };
                        break;
                    case "709":
                        types = new string[] { "documovie" };
                        break;
                    case "46":
                    case "671":
                    case "2177":
                    case "2538":
                    case "251":
                    case "98":
                    case "97":
                    case "851":
                    case "2178":
                    case "821":
                    case "2076":
                    case "56":
                    case "2123":
                    case "876":
                    case "2139":
                    case "1467":
                    case "1469":
                    case "249":
                    case "552":
                    case "500":
                    case "2112":
                    case "1327":
                    case "1468":
                    case "2168":
                    case "2160":
                    case "314":
                    case "1281":
                    case "2110":
                    case "979":
                    case "2169":
                    case "2164":
                    case "2166":
                    case "2163":
                        types = new string[] { "docuserial", "documovie" };
                        break;
                    case "24":
                    case "1959":
                    case "939":
                    case "1481":
                    case "113":
                    case "115":
                    case "882":
                    case "1482":
                    case "393":
                    case "2537":
                    case "532":
                    case "827":
                        types = new string[] { "tvshow" };
                        break;
                    case "2103":
                    case "2522":
                    case "2485":
                    case "2486":
                    case "2479":
                    case "2089":
                    case "1794":
                    case "845":
                    case "2312":
                    case "343":
                    case "2111":
                    case "1527":
                    case "2069":
                    case "1323":
                    case "2009":
                    case "2000":
                    case "2010":
                    case "2006":
                    case "2007":
                    case "2005":
                    case "259":
                    case "2004":
                    case "1999":
                    case "2001":
                    case "2002":
                    case "283":
                    case "1997":
                    case "2003":
                    case "1608":
                    case "1609":
                    case "2294":
                    case "1229":
                    case "1693":
                    case "2532":
                    case "136":
                    case "592":
                    case "2533":
                    case "1952":
                    case "1621":
                    case "2075":
                    case "1668":
                    case "1613":
                    case "1614":
                    case "1623":
                    case "1615":
                    case "1630":
                    case "2425":
                    case "2514":
                    case "1616":
                    case "2014":
                    case "1442":
                    case "1491":
                    case "1987":
                    case "1617":
                    case "1620":
                    case "1998":
                    case "1343":
                    case "751":
                    case "1697":
                    case "255":
                    case "260":
                    case "261":
                    case "256":
                    case "1986":
                    case "660":
                    case "1551":
                    case "626":
                    case "262":
                    case "1326":
                    case "978":
                    case "1287":
                    case "1188":
                    case "1667":
                    case "1675":
                    case "257":
                    case "875":
                    case "263":
                    case "2073":
                    case "550":
                    case "2124":
                    case "1470":
                    case "528":
                    case "486":
                    case "854":
                    case "2079":
                    case "1336":
                    case "2171":
                    case "1339":
                    case "2455":
                    case "1434":
                    case "2350":
                    case "1472":
                    case "2068":
                    case "2016":
                        types = new string[] { "sport" };
                        break;
                }

                if (cats != null)
                {
                    if (types == null)
                        continue;

                    bool isok = false;
                    foreach (string cat in cats)
                    {
                        if (types.Contains(cat))
                            isok = true;
                    }

                    if (!isok)
                        continue;
                }
                #endregion

                int.TryParse(_sid, out int sid);
                int.TryParse(_pir, out int pir);

                torrents.Add(new TorrentDetails()
                {
                    types = types,
                    url = $"{jackett.Rutracker.host}/forum/viewtopic.php?t={viewtopic}",
                    title = title,
                    sid = sid,
                    pir = pir,
                    sizeName = sizeName,
                    createTime = createTime,
                    parselink = $"{host}/rutracker/parsemagnet?id={viewtopic}"
                });
            }

            return torrents;
        }
        #endregion


        #region getCookie
        async static ValueTask<string> getCookie()
        {
            if (!string.IsNullOrEmpty(jackett.Rutracker.cookie))
                return jackett.Rutracker.cookie;

            string authKey = "Rutracker:TakeLogin()";
            if (Startup.memoryCache.TryGetValue(authKey, out string _cookie))
                return _cookie;

            if (Startup.memoryCache.TryGetValue($"{authKey}:error", out _))
                return null;

            Startup.memoryCache.Set($"{authKey}:error", 0, TimeSpan.FromSeconds(20));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(jackett.timeoutSeconds);
                        client.MaxResponseContentBufferSize = 2000000; // 2MB
                        client.DefaultRequestHeaders.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36");

                        var postParams = new Dictionary<string, string>
                    {
                        { "login_username", jackett.Rutracker.login.u },
                        { "login_password", jackett.Rutracker.login.p },
                        { "login", "–í—Ö–æ–¥" }
                    };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync($"{jackett.Rutracker.host}/forum/login.php", postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string session = null;
                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrWhiteSpace(line))
                                            continue;

                                        if (line.Contains("bb_session="))
                                            session = new Regex("bb_session=([^;]+)(;|$)").Match(line).Groups[1].Value;
                                    }

                                    if (!string.IsNullOrWhiteSpace(session))
                                    {
                                        string cookie = $"bb_ssl=1; bb_session={session};";
                                        Startup.memoryCache.Set(authKey, cookie, DateTime.Today.AddDays(1));
                                        return cookie;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch { }

            return null;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/RutorController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace JacRed.Controllers
{
    [Route("rutor/[action]")]
    public class RutorController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string cat, bool isua = false, string parsecat = null)
        {
            if (!jackett.Rutor.enable || jackett.Rutor.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cat, isua, parsecat));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(int id, string magnet)
        {
            if (!jackett.Rutor.enable || jackett.Rutor.priority != "torrent")
                return Content("disable");

            var proxyManager = new ProxyManager("rutor", jackett.Rutor);

            byte[] _t = await Http.Download($"{Regex.Replace(jackett.Rutor.host, "^(https?:)//", "$1//d.")}/download/{id}", referer: jackett.Rutor.host, proxy: proxyManager.Get());
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            proxyManager.Refresh();

            if (string.IsNullOrEmpty(magnet))
                return Content("empty");

            return Redirect(magnet);
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string cat, bool isua, string parsecat)
        {
            // fix search
            query = query.Replace("\"", " ").Replace("'", " ").Replace("?", " ").Replace("&", " ");

            var proxyManager = new ProxyManager("rutor", jackett.Rutor);

            string html = await Http.Get($"{jackett.Rutor.host}/search" + (cat == "0" ? $"/{HttpUtility.UrlEncode(query)}" : $"/0/{cat}/000/0/{HttpUtility.UrlEncode(query)}"), proxy: proxyManager.Get(), timeoutSeconds: jackett.timeoutSeconds);

            if (html == null || !html.Contains("id=\"logo\""))
            {
                consoleErrorLog("rutor");
                proxyManager.Refresh();
                return null;
            }

            var doc = new HtmlDocument();
            doc.LoadHtml(html.Replace("&nbsp;", " ").Replace("¬†", " ")); // –ú–µ–Ω—è–µ–º –Ω–µ–ø–æ–Ω—è—Ç–Ω—ã–π —Å–∏–º–≤–æ–ª –ø–æ—Ö–æ–∂–∏–π –Ω–∞ –ø—Ä–æ–±–ª–µ–ª, –Ω–∞ –æ–±—ã—á–Ω—ã–π –ø—Ä–æ–±–ª–µ–ª

            var nodes = doc.DocumentNode.SelectNodes("//tr[@class='gai' or @class='tum']");
            if (nodes == null || nodes.Count == 0)
                return null;

            var torrents = new List<TorrentDetails>();

            foreach (var row in nodes)
            {
                var hc = new HtmlCommon(row);

                string url = hc.Match("href=\"/(torrent/[^\"]+)\"");
                string viewtopic = Regex.Match(url, "torrent/([0-9]+)").Groups[1].Value;

                string title = hc.NodeValue(".//a[contains(@href, '/torrent/')]");
                string sid = hc.NodeValue(".//span[@class='green']", removeChild: ".//img");
                string pir = hc.NodeValue(".//span[@class='red']");
                string sizeName = hc.NodeValue(".//td[@align='right' and contains(text(), 'GB') or contains(text(), 'MB')]");
                string createTime = hc.NodeValue(".//td");
                string magnet = hc.Match("href=\"(magnet:\\?xt=[^\"]+)\"");

                if (string.IsNullOrEmpty(title) || string.IsNullOrEmpty(magnet) || title.ToLower().Contains("—Ç—Ä–µ–π–ª–µ—Ä"))
                    continue;

                if (isua && !title.Contains(" UKR"))
                    continue;

                torrents.Add(new TorrentDetails()
                {
                    url = $"{jackett.Rutor.host}/{url}",
                    title = title,
                    sid = HtmlCommon.Integer(sid),
                    pir = HtmlCommon.Integer(pir),
                    sizeName = sizeName,
                    magnet = jackett.Rutor.priority == "torrent" ? null : magnet,
                    parselink = jackett.Rutor.priority == "torrent" ? $"{host}/rutor/parsemagnet?id={viewtopic}&magnet={HttpUtility.UrlEncode(magnet)}" : null,
                    createTime = tParse.ParseCreateTime(createTime, "dd.MM.yy")
                });
            }

            return torrents;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/MegapeerController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using System.Text;

namespace JacRed.Controllers
{
    [Route("megapeer/[action]")]
    public class MegapeerController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string cat)
        {
            if (!jackett.Megapeer.enable || jackett.Megapeer.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cat));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string id)
        {
            if (!jackett.Megapeer.enable)
                return Content("disable");

            var proxyManager = new ProxyManager("megapeer", jackett.Megapeer);

            byte[] _t = await Http.Download($"{jackett.Megapeer.host}/download/{id}", referer: jackett.Megapeer.host, proxy: proxyManager.Get());
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            proxyManager.Refresh();
            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string cat)
        {
            #region html
            var proxyManager = new ProxyManager("megapeer", jackett.Megapeer);

            string html = await Http.Get($"{jackett.Megapeer.host}/browse.php?search={HttpUtility.UrlEncode(query, Encoding.GetEncoding(1251))}&cat={cat}", encoding: Encoding.GetEncoding(1251), proxy: proxyManager.Get(), timeoutSeconds: jackett.timeoutSeconds, headers: HeadersModel.Init(
                ("dnt", "1"),
                ("pragma", "no-cache"),
                ("referer", $"{jackett.Megapeer.host}"),
                ("sec-fetch-dest", "document"),
                ("sec-fetch-mode", "navigate"),
                ("sec-fetch-site", "same-origin"),
                ("sec-fetch-user", "?1"),
                ("upgrade-insecure-requests", "1")
            ));

            if (html == null || !html.Contains("id=\"logo\"") || html.Contains("<H1>–†–∞–∑–¥–∞—á–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ"))
            {
                consoleErrorLog("megapeer");
                proxyManager.Refresh();
                return null;
            }
            #endregion

            var doc = new HtmlDocument();
            doc.LoadHtml(html.Replace("&nbsp;", " "));

            var nodes = doc.DocumentNode.SelectNodes("//tr[@class='table_fon']");
            if (nodes == null || nodes.Count == 0)
                return null;

            var torrents = new List<TorrentDetails>();

            foreach (var row in nodes)
            {
                var hc = new HtmlCommon(row);

                string url = hc.Match("href=\"/(torrent/[^\"]+)\"");
                string title = hc.NodeValue(".//a[@class='url']");
                title = Regex.Replace(title, "<[^>]+>", "");

                string sizeName = hc.NodeValue(".//td[@align='right' and contains(text(), 'GB') or contains(text(), 'MB')]");
                string downloadid = hc.Match("href=\"/?download/([0-9]+)\"");
                string createTime = hc.NodeValue(".//td");

                if (string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(downloadid))
                    continue;

                torrents.Add(new TorrentDetails()
                {
                    url = $"{jackett.Megapeer.host}/{url}",
                    title = title,
                    sid = HtmlCommon.Integer(hc.NodeValue(".//font[@color='#008000']")),
                    pir = HtmlCommon.Integer(hc.NodeValue(".//font[@color='#8b0000']")),
                    sizeName = sizeName,
                    parselink = $"{host}/megapeer/parsemagnet?id={downloadid}",
                    createTime = tParse.ParseCreateTime(createTime, "dd.MM.yy")
                });
            }

            return torrents;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/AnimeLayerController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;

namespace JacRed.Controllers
{
    [Route("animelayer/[action]")]
    public class AnimeLayerController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query)
        {
            if (!jackett.Animelayer.enable || string.IsNullOrEmpty(jackett.Animelayer.cookie ?? jackett.Animelayer.login.u) || jackett.Animelayer.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string url)
        {
            if (!jackett.Animelayer.enable)
                return Content("disable");

            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
                return Content("cookie == null");

            var proxyManager = new ProxyManager("animelayer", jackett.Animelayer);

            byte[] _t = await Http.Download($"{url}download/", proxy: proxyManager.Get(), cookie: cookie, referer: jackett.Animelayer.host);
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query)
        {
            #region –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
            {
                consoleErrorLog("animelayer");
                return null;
            }
            #endregion

            var torrents = new List<TorrentDetails>();
            var proxyManager = new ProxyManager("animelayer", jackett.Animelayer);

            #region html
            string html = await Http.Get($"{jackett.Animelayer.host}/torrents/anime/?q={HttpUtility.UrlEncode(query)}", proxy: proxyManager.Get(), cookie: cookie, timeoutSeconds: jackett.timeoutSeconds);

            if (html != null && html.Contains("id=\"wrapper\""))
            {
                if (!html.Contains($">{jackett.Animelayer.login.u}<"))
                {
                    consoleErrorLog("animelayer");
                    return null;
                }
            }
            else if (html == null)
            {
                consoleErrorLog("animelayer");
                return null;
            }
            #endregion

            foreach (string row in html.Split("class=\"torrent-item torrent-item-medium panel\"").Skip(1))
            {
                if (string.IsNullOrWhiteSpace(row))
                    continue;

                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string pattern, int index = 1)
                {
                    string res = new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim();
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è
                DateTime createTime = default;

                if (Regex.IsMatch(row, "(–î–æ–±–∞–≤–ª|–û–±–Ω–æ–≤–ª)[^<]+</span>(&nbsp;)?[0-9]+ [^ ]+ [0-9]{4}"))
                {
                    createTime = tParse.ParseCreateTime(Match(">(–î–æ–±–∞–≤–ª|–û–±–Ω–æ–≤–ª)[^<]+</span>(&nbsp;)?([0-9]+ [^ ]+ [0-9]{4})", 3), "dd.MM.yyyy");
                }
                else
                {
                    string date = Match("(–î–æ–±–∞–≤–ª|–û–±–Ω–æ–≤–ª)[^<]+</span>([^\n]+) –≤", 2);
                    if (!string.IsNullOrWhiteSpace(date))
                        createTime = tParse.ParseCreateTime($"{date} {DateTime.Today.Year}", "dd.MM.yyyy");
                }
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                var gurl = Regex.Match(row, "<a href=\"/(torrent/[a-z0-9]+)/?\">([^<]+)</a>").Groups;

                string url = gurl[1].Value;
                string title = gurl[2].Value;

                string _sid = Match("class=\"icon s-icons-upload\"></i>(&nbsp;)?([0-9]+)", 2);
                string _pir = Match("class=\"icon s-icons-download\"></i>(&nbsp;)?([0-9]+)", 2);
                string sizeName = Match("<i class=\"icon s-icons-download\"></i>[^<]+<span class=\"gray\">[^<]+</span>[\n\r\t ]+([^\n\r<]+)").Trim();

                if (string.IsNullOrWhiteSpace(url) || string.IsNullOrWhiteSpace(title))
                    continue;

                if (Regex.IsMatch(row, "–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ: ?</strong>1920x1080"))
                    title += " [1080p]";
                else if (Regex.IsMatch(row, "–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ: ?</strong>1280x720"))
                    title += " [720p]";
                #endregion

                int.TryParse(_sid, out int sid);
                int.TryParse(_pir, out int pir);

                torrents.Add(new TorrentDetails()
                {
                    types = new string[] { "anime" },
                    url = $"{jackett.Animelayer.host}/{url}/",
                    title = title,
                    sid = sid,
                    pir = pir,
                    sizeName = sizeName,
                    createTime = createTime,
                    parselink = $"{host}/animelayer/parsemagnet?url={HttpUtility.UrlEncode(url)}"
                });
            }

            return torrents;
        }
        #endregion


        #region getCookie
        async static ValueTask<string> getCookie()
        {
            if (!string.IsNullOrEmpty(jackett.Animelayer.cookie))
                return jackett.Animelayer.cookie;

            string authKey = "Animelayer:TakeLogin()";
            if (Startup.memoryCache.TryGetValue(authKey, out string _cookie))
                return _cookie;

            if (Startup.memoryCache.TryGetValue($"{authKey}:error", out _))
                return null;

            Startup.memoryCache.Set($"{authKey}:error", 0, TimeSpan.FromSeconds(20));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(jackett.timeoutSeconds);
                        client.MaxResponseContentBufferSize = 2000000; // 2MB
                        client.DefaultRequestHeaders.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36");

                        var postParams = new Dictionary<string, string>
                    {
                        { "login", jackett.Animelayer.login.u },
                        { "password", jackett.Animelayer.login.p }
                    };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync($"{jackett.Animelayer.host}/auth/login/", postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string layer_id = null, layer_hash = null, PHPSESSID = null;
                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrWhiteSpace(line))
                                            continue;

                                        if (line.Contains("layer_id="))
                                            layer_id = new Regex("layer_id=([^;]+)(;|$)").Match(line).Groups[1].Value;

                                        if (line.Contains("layer_hash="))
                                            layer_hash = new Regex("layer_hash=([^;]+)(;|$)").Match(line).Groups[1].Value;

                                        if (line.Contains("PHPSESSID="))
                                            PHPSESSID = new Regex("PHPSESSID=([^;]+)(;|$)").Match(line).Groups[1].Value;
                                    }

                                    if (!string.IsNullOrWhiteSpace(layer_id) && !string.IsNullOrWhiteSpace(layer_hash) && !string.IsNullOrWhiteSpace(PHPSESSID))
                                    {
                                        string cookie = $"layer_id={layer_id}; layer_hash={layer_hash}; PHPSESSID={PHPSESSID};";
                                        Startup.memoryCache.Set(authKey, cookie, DateTime.Today.AddDays(1));
                                        return cookie;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch { }

            return null;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/TolokaController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;

namespace JacRed.Controllers
{
    [Route("toloka/[action]")]
    public class TolokaController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string[] cats)
        {
            if (!jackett.Toloka.enable || string.IsNullOrEmpty(jackett.Toloka.cookie ?? jackett.Toloka.login.u) || jackett.Toloka.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cats));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string id)
        {
            if (!jackett.Toloka.enable)
                return Content("disable");

            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
                return Content("cookie == null");

            var proxyManager = new ProxyManager("toloka", jackett.Toloka);

            byte[] _t = await Http.Download($"{jackett.Toloka.host}/download.php?id={id}", proxy: proxyManager.Get(), cookie: cookie, referer: jackett.Toloka.host);
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string[] cats)
        {
            #region –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
            {
                consoleErrorLog("toloka");
                return null;
            }
            #endregion

            #region html
            var proxyManager = new ProxyManager("toloka", jackett.Toloka);

            string html = await Http.Get($"{jackett.Toloka.host}/tracker.php?prev_sd=0&prev_a=0&prev_my=0&prev_n=0&prev_shc=0&prev_shf=1&prev_sha=1&prev_cg=0&prev_ct=0&prev_at=0&prev_nt=0&prev_de=0&prev_nd=0&prev_tcs=1&prev_shs=0&f%5B%5D=-1&o=1&s=2&tm=-1&shf=1&sha=1&tcs=1&sns=-1&sds=-1&nm={HttpUtility.UrlEncode(query)}&pn=&send=%D0%9F%D0%BE%D1%88%D1%83%D0%BA", proxy: proxyManager.Get(), cookie: cookie, timeoutSeconds: jackett.timeoutSeconds);

            if (html != null && html.Contains("<html lang=\"uk\""))
            {
                if (!html.Contains(">–í–∏—Ö—ñ–¥"))
                {
                    consoleErrorLog("toloka");
                    return null;
                }
            }
            #endregion

            var torrents = new List<TorrentDetails>();

            foreach (string row in html.Split("</tr>"))
            {
                if (string.IsNullOrWhiteSpace(row) || Regex.IsMatch(row, "–ó–±—ñ—Ä –∫–æ—à—Ç—ñ–≤", RegexOptions.IgnoreCase))
                    continue;

                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string pattern, int index = 1)
                {
                    string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim());
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è
                string _createTime = Match("class=\"gensmall\">([0-9]{4}-[0-9]{2}-[0-9]{2})").Replace("-", ".");
                DateTime.TryParse(_createTime, out DateTime createTime);
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                string url = Match("class=\"topictitle genmed\"><a class=\"[^\"]+\" href=\"(t[0-9]+)\"");
                string title = Match("class=\"topictitle genmed\"><a [^>]+><b>([^<]+)</b></a>");
                string downloadid = Match("href=\"download.php\\?id=([0-9]+)\"");
                string tracker = Match("class=\"gen\" href=\"tracker.php\\?f=([0-9]+)");
                string _sid = Match("class=\"seedmed\"><b>([0-9]+)");
                string _pir = Match("class=\"leechmed\"><b>([0-9]+)");
                string sizeName = Match("class=\"gensmall\">([0-9\\.]+ (MB|GB))</td>");

                if (string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(downloadid) || string.IsNullOrWhiteSpace(tracker) || sizeName == "0 B")
                    continue;
                #endregion

                #region –ü–∞—Ä—Å–∏–º —Ä–∞–∑–¥–∞—á–∏
                int relased = 0;
                string name = null, originalname = null;

                if (tracker is "16" or "96" or "19" or "139" or "12" or "131" or "84" or "42")
                {
                    #region –§–∏–ª—å–º—ã
                    // –ù–µ–∑–≤–æ—Ä–æ—Ç–Ω—ñ—Å—Ç—å / Irr√©versible / Irreversible (2002) AVC Ukr/Fre | Sub Eng
                    var g = Regex.Match(title, "^([^/\\(\\[]+)/[^/\\(\\[]+/([^/\\(\\[]+) \\(([0-9]{4})(\\)|-)").Groups;
                    if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value) && !string.IsNullOrWhiteSpace(g[3].Value))
                    {
                        name = g[1].Value.Trim();
                        originalname = g[2].Value.Trim();

                        if (int.TryParse(g[3].Value, out int _yer))
                            relased = _yer;
                    }
                    else
                    {
                        // –ú—ñ–π —Ä—ñ–∫ —É –ù—å—é-–ô–æ—Ä–∫—É / My Salinger Year (2020) Ukr/Eng
                        g = Regex.Match(title, "^([^/\\(\\[]+)/([^/\\(\\[]+) \\(([0-9]{4})(\\)|-)").Groups;
                        if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value) && !string.IsNullOrWhiteSpace(g[3].Value))
                        {
                            name = g[1].Value.Trim();
                            originalname = g[2].Value.Trim();

                            if (int.TryParse(g[3].Value, out int _yer))
                                relased = _yer;
                        }
                        else
                        {
                            // –•—Ä–æ–Ω—ñ–∫–∞ –Ω–∞–¥—ñ–π —Ç–∞ —ñ–ª—é–∑—ñ–π. –î–∑–µ—Ä–∫–∞–ª–æ —ñ—Å—Ç–æ—Ä—ñ—ó. (83 —Å–µ—Ä—ñ—ó) (2001-2003) PDTVRip
                            g = Regex.Match(title, "^([^/\\(\\[]+) \\([^\\)]+\\) \\(([0-9]{4})(\\)|-)").Groups;
                            if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                            {
                                name = g[1].Value;

                                if (int.TryParse(g[2].Value, out int _yer))
                                    relased = _yer;
                            }
                            else
                            {
                                // –ë–µ—Ä–µ—Å—Ç–µ—á–∫–æ. –ë–∏—Ç–≤–∞ –∑–∞ –£–∫—Ä–∞—ó–Ω—É (2015-2016) DVDRip-AVC
                                g = Regex.Match(title, "^([^/\\(\\[]+) \\(([0-9]{4})(\\)|-)").Groups;
                                if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                                {
                                    name = g[1].Value;

                                    if (int.TryParse(g[2].Value, out int _yer))
                                        relased = _yer;
                                }
                            }
                        }
                    }
                    #endregion
                }
                else if (tracker is "32" or "173" or "174" or "44" or "230" or "226" or "227" or "228" or "229" or "127" or "124" or "125" or "132")
                {
                    #region –°–µ—Ä–∏–∞–ª—ã
                    // –ê—Ç–∞–∫–∞ —Ç–∏—Ç–∞–Ω—ñ–≤ (Attack on Titan) (–°–µ–∑–æ–Ω 1) / Shingeki no Kyojin (Season 1) (2013) BDRip 720—Ä
                    var g = Regex.Match(title, "^([^/\\(\\[]+) \\([^\\)]+\\) \\([^\\)]+\\) ?/([^/\\(\\[]+) \\([^\\)]+\\) \\(([0-9]{4})(\\)|-)").Groups;
                    if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value) && !string.IsNullOrWhiteSpace(g[3].Value))
                    {
                        name = g[1].Value.Trim();
                        originalname = g[2].Value.Trim();

                        if (int.TryParse(g[3].Value, out int _yer))
                            relased = _yer;
                    }
                    else
                    {
                        // –î—ñ–º –∑ –ø—Ä–∏—Å–ª—É–≥–æ—é (–°–µ–∑–æ–Ω 2, —Å–µ—Ä—ñ—ó 1-8) / Servant (Season 2, episodes 1-8) (2021) WEB-DLRip-AVC Ukr/Eng
                        g = Regex.Match(title, "^([^/\\(\\[]+) \\([^\\)]+\\) ?/([^/\\(\\[]+) \\([^\\)]+\\) \\(([0-9]{4})(\\)|-)").Groups;
                        if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value) && !string.IsNullOrWhiteSpace(g[3].Value))
                        {
                            name = g[1].Value.Trim();
                            originalname = g[2].Value.Trim();

                            if (int.TryParse(g[3].Value, out int _yer))
                                relased = _yer;
                        }
                        else
                        {
                            // –î–µ—Ç–µ–∫—Ç–∏–≤–Ω–µ –∞–≥–µ–Ω—Ç—Å—Ç–≤–æ –ø—Ä–µ–∫—Ä–∞—Å–Ω–∏—Ö —Ö–ª–æ–ø—á–∏–∫—ñ–≤ (08 –∑ 12) / Bishounen Tanteidan (2021) BDRip 1080p Ukr/Jap | Ukr Sub
                            g = Regex.Match(title, "^([^/\\(\\[]+) (\\(|\\[)[^\\)\\]]+(\\)|\\]) ?/([^/\\(\\[]+) \\(([0-9]{4})(\\)|-)").Groups;
                            if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[4].Value) && !string.IsNullOrWhiteSpace(g[5].Value))
                            {
                                name = g[1].Value.Trim();
                                originalname = g[4].Value.Trim();

                                if (int.TryParse(g[5].Value, out int _yer))
                                    relased = _yer;
                            }
                            else
                            {
                                // –Ø–π—Ü—è –î—Ä–∞–∫–æ–Ω–∞ / Dragon Ball (01-31 –∑ 153) (1986-1989) BDRip 1080p H.265
                                // –¢–æ–º–æ ‚Äî –¥—ñ–≤—á–∏–Ω–∞! / Tomo-chan wa Onnanoko! (–°–µ–∑–æ–Ω 1, —Å–µ—Ä—ñ—ó 01-02 –∑ 13) (2023) WEBDL 1080p H.265 Ukr/Jap | sub Ukr
                                g = Regex.Match(title, "^([^/\\(\\[]+)/([^/\\(\\[]+) \\([^\\)]+\\) \\(([0-9]{4})(\\)|-)").Groups;
                                if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value) && !string.IsNullOrWhiteSpace(g[3].Value))
                                {
                                    name = g[1].Value.Trim();
                                    originalname = g[2].Value.Trim();

                                    if (int.TryParse(g[3].Value, out int _yer))
                                        relased = _yer;
                                }
                                else
                                {
                                    // –õ—é–¥–∏–Ω–∞-–±–µ–Ω–∑–æ–ø–∏–ª–∞ / „ÉÅ„Çß„É≥„ÇΩ„Éº„Éû„É≥ /Chainsaw Man (—Å–µ–∑–æ–Ω 1, —Å–µ—Ä—ñ—ó 8 –∑ 12) (2022) WEBRip 1080p
                                    g = Regex.Match(title, "^([^/\\(\\[]+)/[^/\\(\\[]+/([^/\\(\\[]+) \\([^\\)]+\\) \\(([0-9]{4})(\\)|-)").Groups;
                                    if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value) && !string.IsNullOrWhiteSpace(g[3].Value))
                                    {
                                        name = g[1].Value.Trim();
                                        originalname = g[2].Value.Trim();

                                        if (int.TryParse(g[3].Value, out int _yer))
                                            relased = _yer;
                                    }
                                    else
                                    {
                                        // –ú–∞—Å—Ç–µ—Ä–®–µ—Ñ. 10 —Å–µ–∑–æ–Ω (1-18 –µ–ø—ñ–∑–æ–¥–∏) (2020) IPTVRip 400p
                                        g = Regex.Match(title, "^([^/\\(\\[]+) \\([^\\)]+\\) \\(([0-9]{4})(\\)|-)").Groups;
                                        if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                                        {
                                            name = g[1].Value.Trim();

                                            if (int.TryParse(g[2].Value, out int _yer))
                                                relased = _yer;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    #endregion
                }
                #endregion

                #region types
                string[] types = null;
                switch (tracker)
                {
                    case "16":
                    case "96":
                    case "42":
                        types = new string[] { "movie" };
                        break;
                    case "19":
                    case "139":
                    case "84":
                        types = new string[] { "multfilm" };
                        break;
                    case "32":
                    case "173":
                    case "124":
                        types = new string[] { "serial" };
                        break;
                    case "174":
                    case "44":
                    case "125":
                        types = new string[] { "multserial" };
                        break;
                    case "226":
                    case "227":
                    case "228":
                    case "229":
                    case "230":
                    case "12":
                    case "131":
                        types = new string[] { "docuserial", "documovie" };
                        break;
                    case "127":
                        types = new string[] { "anime" };
                        break;
                    case "132":
                        types = new string[] { "tvshow" };
                        break;
                }

                if (cats != null)
                {
                    if (types == null)
                        continue;

                    bool isok = false;
                    foreach (string cat in cats)
                    {
                        if (types.Contains(cat))
                            isok = true;
                    }

                    if (!isok)
                        continue;
                }
                #endregion

                int.TryParse(_sid, out int sid);
                int.TryParse(_pir, out int pir);

                torrents.Add(new TorrentDetails()
                {
                    types = types,
                    url = $"{jackett.Toloka.host}/{url}",
                    title = title,
                    sid = sid,
                    pir = pir,
                    sizeName = sizeName,
                    createTime = createTime,
                    parselink = $"{host}/toloka/parsemagnet?id={downloadid}",
                    name = name,
                    originalname = originalname,
                    relased = relased
                });
            }

            return torrents;
        }
        #endregion


        #region getCookie
        async static ValueTask<string> getCookie()
        {
            if (!string.IsNullOrEmpty(jackett.Toloka.cookie))
                return jackett.Toloka.cookie;

            string authKey = "Toloka:TakeLogin()";
            if (Startup.memoryCache.TryGetValue(authKey, out string _cookie))
                return _cookie;

            if (Startup.memoryCache.TryGetValue($"{authKey}:error", out _))
                return null;

            Startup.memoryCache.Set($"{authKey}:error", 0, TimeSpan.FromSeconds(20));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(jackett.timeoutSeconds);
                        client.MaxResponseContentBufferSize = 2000000; // 2MB
                        client.DefaultRequestHeaders.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36");

                        var postParams = new Dictionary<string, string>
                    {
                        { "username", jackett.Toloka.login.u },
                        { "password", jackett.Toloka.login.p },
                        { "autologin", "on" },
                        { "ssl", "on" },
                        { "redirect", "index.php?" },
                        { "login", "–í—Ö—ñ–¥" }
                    };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync($"{jackett.Toloka.host}/login.php", postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string toloka_sid = null, toloka_data = null;
                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrWhiteSpace(line))
                                            continue;

                                        if (line.Contains("toloka_sid="))
                                            toloka_sid = new Regex("toloka_sid=([^;]+)(;|$)").Match(line).Groups[1].Value;

                                        if (line.Contains("toloka_data="))
                                            toloka_data = new Regex("toloka_data=([^;]+)(;|$)").Match(line).Groups[1].Value;
                                    }

                                    if (!string.IsNullOrWhiteSpace(toloka_sid) && !string.IsNullOrWhiteSpace(toloka_data))
                                    {
                                        string cookie = $"toloka_sid={toloka_sid}; toloka_ssl=1; toloka_data={toloka_data};";
                                        Startup.memoryCache.Set(authKey, cookie, DateTime.Today.AddDays(1));
                                        return cookie;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch { }

            return null;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/NNMClubController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using System.Text;

namespace JacRed.Controllers
{
    [Route("nnmclub/[action]")]
    public class NNMClubController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string[] cats)
        {
            if (!jackett.NNMClub.enable || jackett.NNMClub.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cats));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string id)
        {
            if (!jackett.NNMClub.enable)
                return Content("disable");

            var proxyManager = new ProxyManager("nnmclub", jackett.NNMClub);

            #region html
            string html = await Http.Get($"{jackett.NNMClub.host}/forum/viewtopic.php?t=" + id, proxy: proxyManager.Get());
            string magnet = new Regex("href=\"(magnet:[^\"]+)\" title=\"–ü—Ä–∏–º–∞–≥–Ω–∏—Ç–∏—Ç—å—Å—è\"").Match(html ?? string.Empty).Groups[1].Value;

            if (html == null)
            {
                proxyManager.Refresh();
                return Content("error");
            }
            #endregion

            #region download torrent
            if (jackett.NNMClub.cookie != null || Cookie != null)
            {
                string downloadid = new Regex("href=\"download\\.php\\?id=([0-9]+)\"").Match(html).Groups[1].Value;
                if (!string.IsNullOrWhiteSpace(downloadid))
                {
                    byte[] _t = await Http.Download($"{jackett.NNMClub.host}/forum/download.php?id={downloadid}", proxy: proxyManager.Get(), cookie: jackett.NNMClub.cookie ?? Cookie, referer: jackett.NNMClub.host);
                    if (_t != null && BencodeTo.Magnet(_t) != null)
                        return File(_t, "application/x-bittorrent");
                }
            }
            #endregion

            if (string.IsNullOrEmpty(magnet))
            {
                proxyManager.Refresh();
                return Content("error");
            }

            return Redirect(magnet);
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string[] cats)
        {
            var torrents = new List<TorrentDetails>();
            var proxyManager = new ProxyManager("nnmclub", jackett.NNMClub);

            #region html
            string data = $"prev_sd=0&prev_a=0&prev_my=0&prev_n=0&prev_shc=0&prev_shf=1&prev_sha=1&prev_shs=0&prev_shr=0&prev_sht=0&o=1&s=2&tm=-1&shf=1&sha=1&ta=-1&sns=-1&sds=-1&nm={HttpUtility.UrlEncode(query, Encoding.GetEncoding(1251))}&pn=&submit=%CF%EE%E8%F1%EA";
            string html = await Http.Post($"{jackett.NNMClub.host}/forum/tracker.php", new System.Net.Http.StringContent(data, Encoding.UTF8, "application/x-www-form-urlencoded"), encoding: Encoding.GetEncoding(1251), proxy: proxyManager.Get(), timeoutSeconds: jackett.timeoutSeconds);

            if (html != null && html.Contains("NNM-Club</title>"))
            {
                if (!html.Contains(">–í—ã—Ö–æ–¥") && !string.IsNullOrWhiteSpace(jackett.NNMClub.login.u) && !string.IsNullOrWhiteSpace(jackett.NNMClub.login.p))
                    TakeLogin();
            }
            else if (html == null)
            {
                consoleErrorLog("nnmclub");
                proxyManager.Refresh();
                return null;
            }
            #endregion

            foreach (string row in html.Split("</tr>"))
            {
                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string pattern, int index = 1)
                {
                    string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim());
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                string url = Match("href=\"(viewtopic.php\\?t=[0-9]+)\"");
                string viewtopic = Match("href=\"viewtopic.php\\?t=([0-9]+)\"");
                string tracker = Match("class=\"gen\" href=\"tracker.php\\?f=([0-9]+)");

                string title = Match("class=\"genmed topictitle\" [^>]+><b>([^<]+)</b>");
                string _sid = Match("class=\"seedmed\"><b>([0-9]+)</b><");
                string _pir = Match("class=\"leechmed\"><b>([0-9]+)</b></td>");
                string sizeName = Match("class=\"gensmall\"><u>[^<]+</u> ([^<]+)</td>");

                if (string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(url) || string.IsNullOrWhiteSpace(viewtopic) || string.IsNullOrWhiteSpace(tracker))
                    continue;

                if (tracker == "913" && !title.Contains("UKR"))
                    continue;
                #endregion

                #region types
                string[] types = null;
                switch (tracker)
                {
                    case "270":
                    case "221":
                    case "882":
                    case "225":
                    case "227":
                    case "913":
                    case "218":
                    case "954":
                    case "1293":
                    case "1296":
                    case "1299":
                    case "682":
                    case "884":
                    case "693":
                        types = new string[] { "movie" };
                        break;
                    case "769":
                    case "768":
                        types = new string[] { "serial" };
                        break;
                    case "713":
                    case "576":
                    case "610":
                        types = new string[] { "docuserial", "documovie" };
                        break;
                    case "731":
                    case "733":
                    case "1329":
                    case "1330":
                    case "1331":
                    case "1332":
                    case "1336":
                    case "1337":
                    case "1338":
                    case "1339":
                        types = new string[] { "multfilm" };
                        break;
                    case "658":
                    case "232":
                        types = new string[] { "multserial" };
                        break;
                    case "623":
                    case "622":
                    case "621":
                    case "632":
                    case "627":
                    case "626":
                    case "625":
                    case "644":
                        types = new string[] { "anime" };
                        break;
                }

                if (cats != null)
                {
                    if (types == null)
                        continue;

                    bool isok = false;
                    foreach (string cat in cats)
                    {
                        if (types.Contains(cat))
                            isok = true;
                    }

                    if (!isok)
                        continue;
                }
                #endregion

                int.TryParse(_sid, out int sid);
                int.TryParse(_pir, out int pir);

                torrents.Add(new TorrentDetails()
                {
                    types = types,
                    url = $"{jackett.NNMClub.host}/{url}",
                    title = title,
                    sid = sid,
                    pir = pir,
                    sizeName = sizeName,
                    parselink = $"{host}/nnmclub/parsemagnet?id={viewtopic}",
                    createTime = tParse.ParseCreateTime(Match("title=\"–î–æ–±–∞–≤–ª–µ–Ω–æ\" class=\"gensmall\"><u>[0-9]+</u> ([0-9]{2}-[0-9]{2}-[0-9]{4}<br>[^<]+)</td>").Replace("<br>", " "), "dd-MM-yyyy HH:mm")
                });
            }

            return torrents;
        }
        #endregion


        #region Cookie / TakeLogin
        static string Cookie;

        async static void TakeLogin()
        {
            string authKey = "nnmclub:TakeLogin()";
            if (Startup.memoryCache.TryGetValue(authKey, out _))
                return;

            Startup.memoryCache.Set(authKey, 0, AppInit.conf.multiaccess ? TimeSpan.FromMinutes(2) : TimeSpan.FromSeconds(20));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(jackett.timeoutSeconds);
                        client.MaxResponseContentBufferSize = 2000000; // 2MB
                        client.DefaultRequestHeaders.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36");
                        client.DefaultRequestHeaders.Add("cache-control", "no-cache");
                        client.DefaultRequestHeaders.Add("dnt", "1");
                        client.DefaultRequestHeaders.Add("origin", jackett.NNMClub.host);
                        client.DefaultRequestHeaders.Add("pragma", "no-cache");
                        client.DefaultRequestHeaders.Add("referer", $"{jackett.NNMClub.host}/");
                        client.DefaultRequestHeaders.Add("upgrade-insecure-requests", "1");

                        var postParams = new Dictionary<string, string>
                    {
                        { "redirect", "%2F" },
                        { "username", jackett.NNMClub.login.u },
                        { "password", jackett.NNMClub.login.p },
                        { "autologin", "on" },
                        { "login", "%C2%F5%EE%E4" }
                    };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync($"{jackett.NNMClub.host}/forum/login.php", postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string data = null, sid = null;
                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrWhiteSpace(line))
                                            continue;

                                        if (line.Contains("phpbb2mysql_4_data="))
                                            data = new Regex("phpbb2mysql_4_data=([^;]+)(;|$)").Match(line).Groups[1].Value;

                                        if (line.Contains("phpbb2mysql_4_sid="))
                                            sid = new Regex("phpbb2mysql_4_sid=([^;]+)(;|$)").Match(line).Groups[1].Value;
                                    }

                                    if (!string.IsNullOrWhiteSpace(data) && !string.IsNullOrWhiteSpace(sid))
                                        Cookie = $"phpbb2mysql_4_data={data}; phpbb2mysql_4_sid={sid};";
                                }
                            }
                        }
                    }
                }
            }
            catch { }
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/BitruController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace JacRed.Controllers
{
    [Route("bitru/[action]")]
    public class BitruController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string[] cats)
        {
            if (!jackett.Bitru.enable || jackett.Bitru.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cats));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string id, bool usecache)
        {
            if (!jackett.Bitru.enable)
                return Content("disable");

            var proxyManager = new ProxyManager("bitru", jackett.Bitru);

            byte[] _t = await Http.Download($"{jackett.Bitru.host}/download.php?id={id}", referer: $"{jackett.Bitru}/details.php?id={id}", proxy: proxyManager.Get());
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            proxyManager.Refresh();
            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string[] cats)
        {
            #region html
            var proxyManager = new ProxyManager("bitru", jackett.Bitru);

            string html = await Http.Get($"{jackett.Bitru.host}/browse.php?s={HttpUtility.HtmlEncode(query)}&sort=&tmp=&cat=&subcat=&year=&country=&sound=&soundtrack=&subtitles=#content", proxy: proxyManager.Get(), timeoutSeconds: jackett.timeoutSeconds);

            if (html == null || !html.Contains("id=\"logo\""))
            {
                consoleErrorLog("bitru");
                proxyManager.Refresh();
                return null;
            }
            #endregion

            var torrents = new List<TorrentDetails>();

            foreach (string row in html.Split("<div class=\"b-title\"").Skip(1))
            {
                if (string.IsNullOrWhiteSpace(row) || row.Contains(">–ê–Ω–∏–º–µ</a>"))
                    continue;

                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string pattern, int index = 1)
                {
                    string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim());
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è
                DateTime createTime = default;

                if (row.Contains("<span>–°–µ–≥–æ–¥–Ω—è"))
                {
                    createTime = DateTime.Today;
                }
                else if (row.Contains("<span>–í—á–µ—Ä–∞"))
                {
                    createTime = DateTime.Today.AddDays(-1);
                }
                else
                {
                    createTime = tParse.ParseCreateTime(Match("<div class=\"ellips\">(<i [^>]+></i>)?<span>([0-9]{2} [^ ]+ [0-9]{4}) –≤ [0-9]{2}:[0-9]{2} –æ—Ç <a", 2), "dd.MM.yyyy");
                }
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                string url = Match("href=\"(details.php\\?id=[0-9]+)\"");
                string newsid = Match("href=\"details.php\\?id=([0-9]+)\"");
                string cat = Match("<a href=\"browse.php\\?tmp=(movie|serial)&");

                string title = Match("<div class=\"it-title\">([^<]+)</div>");
                string _sid = Match("<span class=\"b-seeders\">([0-9]+)");
                string _pir = Match("<span class=\"b-leechers\">([0-9]+)");
                string sizeName = Match("title=\"–†–∞–∑–º–µ—Ä\">([^<]+)</td>");

                if (string.IsNullOrWhiteSpace(cat) || string.IsNullOrWhiteSpace(newsid) || string.IsNullOrWhiteSpace(title))
                    continue;

                if (!title.ToLower().Contains(query.ToLower()))
                    continue;
                #endregion

                #region types
                string[] types = null;
                switch (cat)
                {
                    case "movie":
                        types = new string[] { "movie" };
                        break;
                    case "serial":
                        types = new string[] { "serial" };
                        break;
                }

                if (cats != null)
                {
                    if (types == null)
                        continue;

                    bool isok = false;
                    foreach (string c in cats)
                    {
                        if (types.Contains(c))
                            isok = true;
                    }

                    if (!isok)
                        continue;
                }
                #endregion

                int.TryParse(_sid, out int sid);
                int.TryParse(_pir, out int pir);

                torrents.Add(new TorrentDetails()
                {
                    types = types,
                    url = $"{jackett.Bitru.host}/{url}",
                    title = title,
                    sid = sid,
                    pir = pir,
                    sizeName = sizeName,
                    createTime = createTime,
                    parselink = $"{host}/bitru/parsemagnet?id={newsid}"
                });
            }

            return torrents;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/LostfilmController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;

namespace JacRed.Controllers
{
    [Route("lostfilm/[action]")]
    public class LostfilmController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query)
        {
            if (!jackett.Lostfilm.enable || string.IsNullOrEmpty(jackett.Lostfilm.cookie ?? jackett.Lostfilm.login.u) || jackett.Lostfilm.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string episodeid)
        {
            if (!jackett.Lostfilm.enable)
                return Content("disable");

            var _t = await getTorrent(episodeid);
            if (_t != null)
                return File(_t, "application/x-bittorrent");

            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query)
        {
            var proxyManager = new ProxyManager("lostfilm", jackett.Lostfilm);

            #region html
            bool validrq = false;
            string html = await Http.Get($"{jackett.Lostfilm.host}/search/?q={HttpUtility.UrlEncode(query)}", timeoutSeconds: jackett.timeoutSeconds, proxy: proxyManager.Get());

            if (html != null && html.Contains("onClick=\"FollowSerial("))
            {
                string serie = Regex.Match(html, "href=\"/series/([^\"]+)\" class=\"no-decoration\"").Groups[1].Value;
                if (!string.IsNullOrWhiteSpace(serie))
                {
                    html = await Http.Get($"{jackett.Lostfilm.host}/series/{serie}/seasons/", timeoutSeconds: jackett.timeoutSeconds);
                    if (html != null && html.Contains("LostFilm.TV"))
                        validrq = true;
                }
            }

            if (!validrq)
            {
                consoleErrorLog("lostfilm");
                return null;
            }
            #endregion

            var torrents = new List<TorrentDetails>();

            foreach (string row in html.Split("<tr>").Skip(1))
            {
                if (string.IsNullOrWhiteSpace(row))
                    continue;

                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string val, string pattern, int index = 1)
                {
                    string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(val).Groups[index].Value.Trim());
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                DateTime createTime = tParse.ParseCreateTime(Match(row, "data-released=\"([0-9]{2}\\.[0-9]{2}\\.[0-9]{4})\">([^<]+)</span>"), "dd.MM.yyyy");

                string url = Match(html, "href=\"/(series/[^/]+/seasons)\" class=\"item  active\">–ì–∏–¥ –ø–æ —Å–µ—Ä–∏—è–º</a>");
                string sinfo = Match(row, "title=\"–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–µ—Ä–∏–∏\">([^<]+)</td>");
                string name = Match(html, "<h1 class=\"title-ru\" itemprop=\"name\">([^<]+)</h1>");
                string originalname = Match(html, "<h2 class=\"title-en\" itemprop=\"alternativeHeadline\">([^<]+)</h2>");

                if (string.IsNullOrWhiteSpace(url) || string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(originalname) || string.IsNullOrWhiteSpace(sinfo))
                    continue;
                #endregion

                string episodeid = Match(row, "onclick=\"PlayEpisode\\('([0-9]+)'\\)\"");
                if (string.IsNullOrWhiteSpace(episodeid))
                    continue;

                torrents.Add(new TorrentDetails()
                {
                    types = new string[] { "serial" },
                    url = $"{jackett.Lostfilm.host}/{url}",
                    title = $"{name} / {originalname} / {sinfo} [{createTime.Year}, 1080p]",
                    sid = 1,
                    createTime = createTime,
                    parselink = $"{host}/lostfilm/parsemagnet?episodeid={episodeid}",
                    name = name,
                    originalname = originalname,
                    relased = createTime.Year
                });
            }

            return torrents;
        }
        #endregion


        #region getTorrent
        async Task<byte[]> getTorrent(string episodeid)
        {
            try
            {
                string cookie = await getCookie();
                if (string.IsNullOrEmpty(cookie))
                    return null;

                var proxyManager = new ProxyManager("lostfilm", jackett.Lostfilm);
                var proxy = proxyManager.Get();

                // –ü–æ–ª—É—á–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –ø–æ–∏—Å–∫
                string v_search = await Http.Get($"{jackett.Lostfilm.host}/v_search.php?a={episodeid}", proxy: proxy, cookie: cookie);
                string retreSearchUrl = new Regex("url=(\")?(https?://[^/]+/[^\"]+)").Match(v_search ?? "").Groups[2].Value.Trim();
                if (!string.IsNullOrWhiteSpace(retreSearchUrl))
                {
                    // –ó–∞–≥—Ä—É–∂–∞–µ–º HTML –ø–æ–∏—Å–∫–∞
                    string shtml = await Http.Get(retreSearchUrl, proxy: proxy, cookie: cookie);
                    if (!string.IsNullOrWhiteSpace(shtml))
                    {
                        var match = new Regex("<div class=\"inner-box--link main\"><a href=\"([^\"]+)\">([^<]+)</a></div>").Match(Regex.Replace(shtml, "[\n\r\t]+", ""));
                        while (match.Success)
                        {
                            if (Regex.IsMatch(match.Groups[2].Value, "(2160p|2060p|1440p|1080p|720p)", RegexOptions.IgnoreCase))
                            {
                                string torrentFile = match.Groups[1].Value;
                                string quality = Regex.Match(match.Groups[2].Value, "(2160p|2060p|1440p|1080p|720p)").Groups[1].Value;

                                if (!string.IsNullOrWhiteSpace(torrentFile) && !string.IsNullOrWhiteSpace(quality))
                                {
                                    byte[] torrent = await Http.Download(torrentFile, referer: $"{jackett.Lostfilm.host}/", proxy: proxy, cookie: cookie);
                                    if (BencodeTo.Magnet(torrent) != null)
                                        return torrent;
                                }
                            }

                            match = match.NextMatch();
                        }
                    }
                }
            }
            catch { }

            return null;
        }
        #endregion

        #region getCookie
        async static ValueTask<string> getCookie()
        {
            if (!string.IsNullOrEmpty(jackett.Lostfilm.cookie))
                return jackett.Lostfilm.cookie;

            string authKey = "Lostfilm:TakeLogin()";
            if (Startup.memoryCache.TryGetValue(authKey, out string _cookie))
                return _cookie;

            if (Startup.memoryCache.TryGetValue($"{authKey}:error", out _))
                return null;

            Startup.memoryCache.Set($"{authKey}:error", 0, TimeSpan.FromSeconds(20));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(jackett.timeoutSeconds);
                        client.MaxResponseContentBufferSize = 2000000; // 2MB
                        client.DefaultRequestHeaders.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36");

                        var postParams = new Dictionary<string, string>
                    {
                        { "act", "users" },
                        { "type", "login" },
                        { "mail", jackett.Lostfilm.login.u },
                        { "pass", jackett.Lostfilm.login.p },
                        { "need_captcha", "" },
                        { "captcha", "" },
                        { "rem", "1" }
                    };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync($"{jackett.Lostfilm.host}/ajaxik.users.php", postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string cookie = string.Empty;
                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrWhiteSpace(line))
                                            continue;

                                        cookie += " " + line;
                                    }

                                    if (cookie.Contains("lf_session=") && cookie.Contains("lnk_uid="))
                                    {
                                        cookie = Regex.Replace(cookie.Trim(), ";$", "");
                                        Startup.memoryCache.Set(authKey, cookie, DateTime.Today.AddDays(1));
                                        return cookie;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch { }

            return null;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/SelezenController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;

namespace JacRed.Controllers
{
    [Route("selezen/[action]")]
    public class SelezenController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query)
        {
            if (!jackett.Selezen.enable || string.IsNullOrEmpty(jackett.Selezen.cookie ?? jackett.Selezen.login.u) || jackett.Selezen.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string url)
        {
            if (!jackett.Selezen.enable)
                return Content("disable");

            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
                return Content("cookie == null");

            var proxyManager = new ProxyManager("selezen", jackett.Selezen);

            string html = await Http.Get(url, cookie: cookie, proxy: proxyManager.Get());
            string magnet = new Regex("href=\"(magnet:[^\"]+)\"").Match(html ?? string.Empty).Groups[1].Value;

            if (html == null)
                return Content("error");

            #region Download
            if (jackett.Selezen.priority == "torrent")
            {
                string id = new Regex("href=\"/index.php\\?do=download&id=([0-9]+)").Match(html).Groups[1].Value;
                if (!string.IsNullOrWhiteSpace(id))
                {
                    var _t = await Http.Download($"{jackett.Selezen.host}/index.php?do=download&id={id}", cookie: cookie, referer: jackett.Selezen.host, timeoutSeconds: 10);
                    if (_t != null && BencodeTo.Magnet(_t) != null)
                        return File(_t, "application/x-bittorrent");
                }
            }
            #endregion

            if (string.IsNullOrWhiteSpace(magnet))
                return Content("error");

            return Redirect(magnet);
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query)
        {
            #region –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
            string cookie = await getCookie();
            if (string.IsNullOrEmpty(cookie))
            {
                consoleErrorLog("selezen");
                return null;
            }
            #endregion

            #region html
            var proxyManager = new ProxyManager("selezen", jackett.Selezen);

            string html = await Http.Post($"{jackett.Selezen.host}/index.php?do=search", $"do=search&subaction=search&search_start=0&full_search=0&result_from=1&story={HttpUtility.UrlEncode(query)}&titleonly=0&searchuser=&replyless=0&replylimit=0&searchdate=0&beforeafter=after&sortby=date&resorder=desc&showposts=0&catlist%5B%5D=9", proxy: proxyManager.Get(), cookie: cookie, timeoutSeconds: jackett.timeoutSeconds);

            if (html != null && html.Contains("dle_root"))
            {
                if (!html.Contains($">{jackett.Selezen.login.u}<"))
                {
                    consoleErrorLog("selezen");
                    return null;
                }
            }
            #endregion

            var torrents = new List<TorrentDetails>();

            foreach (string row in html.Split("class=\"card radius-10 overflow-hidden\"").Skip(1))
            {
                if (string.IsNullOrWhiteSpace(row) || row.Contains(">–ê–Ω–∏–º–µ</a>") || row.Contains(" [S0"))
                    continue;

                #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                string Match(string pattern, int index = 1)
                {
                    string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim());
                    res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                    return res.Trim();
                }
                #endregion

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                var g = Regex.Match(row, "<a href=\"(https?://[^<]+)\"><h4 class=\"card-title\">([^<]+)</h4>").Groups;
                string url = g[1].Value;
                string title = g[2].Value;

                string _sid = Match("<i class=\"bx bx-chevrons-up\"></i>([0-9 ]+)").Trim();
                string _pir = Match("<i class=\"bx bx-chevrons-down\"></i>([0-9 ]+)").Trim();
                string sizeName = Match("<span class=\"bx bx-download\"></span>([^<]+)</a>").Trim();
                DateTime createTime = tParse.ParseCreateTime(Match("class=\"bx bx-calendar\"></span> ?([0-9]{2}\\.[0-9]{2}\\.[0-9]{4} [0-9]{2}:[0-9]{2})</a>"), "dd.MM.yyyy HH:mm");

                if (string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(url))
                    continue;
                #endregion

                #region types
                string[] types = new string[] { "movie" };
                if (row.Contains(">–ú—É–ª—å—Ç") || row.Contains(">–º—É–ª—å—Ç"))
                    types = new string[] { "multfilm" };
                #endregion

                int.TryParse(_sid, out int sid);
                int.TryParse(_pir, out int pir);

                torrents.Add(new TorrentDetails()
                {
                    types = types,
                    url = url,
                    title = title,
                    sid = sid,
                    pir = pir,
                    sizeName = sizeName,
                    createTime = createTime,
                    parselink = $"{host}/selezen/parsemagnet?url={HttpUtility.UrlEncode(url)}"
                });
            }

            return torrents;
        }
        #endregion


        #region getCookie
        async static ValueTask<string> getCookie()
        {
            if (!string.IsNullOrEmpty(jackett.Selezen.cookie))
                return jackett.Selezen.cookie;

            string authKey = "selezen:TakeLogin()";
            if (Startup.memoryCache.TryGetValue(authKey, out string _cookie))
                return _cookie;

            if (Startup.memoryCache.TryGetValue($"{authKey}:error", out _))
                return null;

            Startup.memoryCache.Set($"{authKey}:error", 0, TimeSpan.FromSeconds(20));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(jackett.timeoutSeconds);
                        client.MaxResponseContentBufferSize = 2000000; // 2MB
                        client.DefaultRequestHeaders.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36");

                        var postParams = new Dictionary<string, string>
                    {
                        { "login_name", jackett.Selezen.login.u },
                        { "login_password", jackett.Selezen.login.p },
                        { "login_not_save", "1" },
                        { "login", "submit" }
                    };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync(jackett.Selezen.host, postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string PHPSESSID = null;
                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrWhiteSpace(line))
                                            continue;

                                        if (line.Contains("PHPSESSID="))
                                            PHPSESSID = new Regex("PHPSESSID=([^;]+)(;|$)").Match(line).Groups[1].Value;
                                    }

                                    if (!string.IsNullOrWhiteSpace(PHPSESSID))
                                    {
                                        string cookie = $"PHPSESSID={PHPSESSID}; _ym_isad=2;";
                                        Startup.memoryCache.Set(authKey, cookie, DateTime.Today.AddDays(1));
                                        return cookie;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch { }

            return null;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/AniLibriaController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using JacRed.Models.AniLibria;

namespace JacRed.Controllers
{
    [Route("anilibria/[action]")]
    public class AniLibriaController : JacBaseController
    {
        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string url, string code)
        {
            if (!jackett.Anilibria.enable || jackett.Anilibria.showdown)
                return Content("disable");

            var proxyManager = new ProxyManager("anilibria", jackett.Anilibria);

            byte[] _t = await Http.Download($"{jackett.Anilibria.host}/{url}", referer: $"{jackett.Anilibria.host}/release/{code}.html", proxy: proxyManager.Get());
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            proxyManager.Refresh();
            return Content("error");
        }
        #endregion

        #region parsePage
        async public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query)
        {
            if (!jackett.Anilibria.enable)
                return false;

            var proxyManager = new ProxyManager("anilibria", jackett.Anilibria);

            var roots = await Http.Get<List<RootObject>>("https://api.anilibria.tv/v2/searchTitles?search=" + HttpUtility.UrlEncode(query), timeoutSeconds: jackett.timeoutSeconds, proxy: proxyManager.Get(), IgnoreDeserializeObject: true);
            if (roots == null || roots.Count == 0)
            {
                consoleErrorLog("anilibria");
                proxyManager.Refresh();
                return false;
            }

            foreach (var root in roots)
            {
                DateTime createTime = new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(root.last_change > root.updated ? root.last_change : root.updated);

                foreach (var torrent in root.torrents.list)
                {
                    if (string.IsNullOrWhiteSpace(root.code) || 480 >= torrent.quality.resolution && string.IsNullOrWhiteSpace(torrent.quality.encoder) && string.IsNullOrWhiteSpace(torrent.url))
                        continue;

                    torrents.Add(new TorrentDetails()
                    {
                        trackerName = "anilibria.tv",
                        types = new string[] { "anime" },
                        url = $"{jackett.Anilibria.host}/release/{root.code}.html",
                        title = $"{root.names.ru} / {root.names.en} {root.season.year} (s{root.season.code}, e{torrent.series.@string}) [{torrent.quality.@string}]",
                        sid = torrent.seeders,
                        pir = torrent.leechers,
                        createTime = createTime,
                        parselink = $"{host}/anilibria/parsemagnet?url={HttpUtility.UrlEncode(torrent.url)}&code={root.code}",
                        sizeName = tParse.BytesToString(torrent.total_size),
                        name = root.names.ru,
                        originalname = root.names.en,
                        relased = root.season.year
                    });
                }
            }


            return true;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/TorrentByController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace JacRed.Controllers
{
    [Route("torrentby/[action]")]
    public class TorrentByController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string cat)
        {
            if (!jackett.TorrentBy.enable || jackett.TorrentBy.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cat));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(int id, string magnet)
        {
            if (!jackett.TorrentBy.enable || jackett.TorrentBy.priority != "torrent")
                return Content("disable");

            var proxyManager = new ProxyManager("torrentby", jackett.TorrentBy);

            var _t = await Http.Download($"{jackett.TorrentBy.host}/d.php?id={id}", referer: jackett.TorrentBy.host, proxy: proxyManager.Get());
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            proxyManager.Refresh();

            if (string.IsNullOrEmpty(magnet))
                return Content("empty");

            return Redirect(magnet);
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string cat)
        {
            #region html
            var proxyManager = new ProxyManager("torrentby", jackett.TorrentBy);

            string html = await Http.Get($"{jackett.TorrentBy.host}/search/?search={HttpUtility.UrlEncode(query)}&category={cat}", proxy: proxyManager.Get(), timeoutSeconds: jackett.timeoutSeconds);

            if (html == null || !html.Contains("id=\"find\""))
            {
                consoleErrorLog("torrentby");
                proxyManager.Refresh();
                return null;
            }
            #endregion

            var doc = new HtmlDocument();
            doc.LoadHtml(html.Replace("&nbsp;", " "));

            var nodes = doc.DocumentNode.SelectNodes("//tr[contains(@class, 'ttable_col')]");
            if (nodes == null || nodes.Count == 0)
                return null;

            var torrents = new List<TorrentDetails>();

            foreach (var row in nodes)
            {
                var hc = new HtmlCommon(row);

                #region –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è
                DateTime createTime = default;

                if (row.InnerHtml.Contains("–°–µ–≥–æ–¥–Ω—è"))
                {
                    createTime = DateTime.Today;
                }
                else if (row.InnerHtml.Contains("–í—á–µ—Ä–∞"))
                {
                    createTime = DateTime.Today.AddDays(-1);
                }
                else
                {
                    string _createTime = hc.Match(">([0-9]{4}-[0-9]{2}-[0-9]{2})</td>").Replace("-", " ");
                    DateTime.TryParseExact(_createTime, "yyyy MM dd", new CultureInfo("ru-RU"), DateTimeStyles.None, out createTime);
                }
                #endregion

                string url = hc.NodeValue(".//a[@name='search_select']", "href");
                string viewtopic = Regex.Match(url, "^/([0-9]+)").Groups[1].Value;

                string title = hc.NodeValue(".//a[@name='search_select']");
                title = Regex.Replace(title, "<[^>]+>", "");

                string magnet = hc.Match("href=\"(magnet:\\?xt=[^\"]+)\"");

                if (string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(magnet))
                    continue;

                torrents.Add(new TorrentDetails()
                {
                    url = $"{jackett.TorrentBy.host}/{url.Remove(0, 1)}",
                    title = title,
                    sid = HtmlCommon.Integer(hc.NodeValue(".//font[@color='green']")),
                    pir = HtmlCommon.Integer(hc.NodeValue(".//font[@color='red']")),
                    sizeName = hc.NodeValue(".//td[contains(text(), 'GB') or contains(text(), 'MB')]"),
                    magnet = jackett.TorrentBy.priority == "torrent" ? null : magnet,
                    parselink = jackett.TorrentBy.priority == "torrent" ? $"{host}/torrentby/parsemagnet?id={viewtopic}&magnet={HttpUtility.UrlEncode(magnet)}" : null,
                    createTime = createTime
                });
            }

            return torrents;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/AnifilmController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace JacRed.Controllers
{
    [Route("anifilm/[action]")]
    public class AnifilmController : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query)
        {
            if (!jackett.Anifilm.enable || jackett.Anifilm.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string url)
        {
            if (!jackett.Anifilm.enable)
                return Content("disable");

            var proxyManager = new ProxyManager("anifilm", jackett.Anifilm);

            var fullNews = await Http.Get($"{jackett.Anifilm.host}/{url}", proxy: proxyManager.Get());
            if (fullNews == null)
                return Content("error");

            string tid = null;
            string[] releasetorrents = fullNews.Split("<li class=\"release__torrents-item\">");

            string _rnews = releasetorrents.FirstOrDefault(i => i.Contains("href=\"/releases/download-torrent/") && i.Contains(" 1080p "));
            if (!string.IsNullOrWhiteSpace(_rnews))
                tid = Regex.Match(_rnews, "href=\"/(releases/download-torrent/[0-9]+)\">—Å–∫–∞—á–∞—Ç—å</a>").Groups[1].Value;

            if (string.IsNullOrWhiteSpace(tid))
                tid = Regex.Match(fullNews, "href=\"/(releases/download-torrent/[0-9]+)\">—Å–∫–∞—á–∞—Ç—å</a>").Groups[1].Value;

            if (!string.IsNullOrWhiteSpace(tid))
            {
                var _t = await Http.Download($"{jackett.Anifilm.host}/{tid}", referer: $"{jackett.Anifilm.host}/", proxy: proxyManager.Get());
                if (_t != null && BencodeTo.Magnet(_t) != null)
                    return File(_t, "application/x-bittorrent");
            }

            proxyManager.Refresh();
            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query)
        {
            #region html
            var proxyManager = new ProxyManager("anifilm", jackett.Anifilm);

            string html = await Http.Get($"{jackett.Anifilm.host}/releases?title={HttpUtility.UrlEncode(query)}", timeoutSeconds: jackett.timeoutSeconds, proxy: proxyManager.Get());

            if (html == null || !html.Contains("id=\"ui-components\""))
            {
                consoleErrorLog("anifilm");
                proxyManager.Refresh();
                return null;
            }
            #endregion

            var torrents = new List<TorrentDetails>();

            if (html.Contains("class=\"releases__item\""))
            {
                foreach (string row in html.Split("class=\"releases__item\"").Skip(1))
                {
                    if (string.IsNullOrWhiteSpace(row))
                        continue;

                    #region –õ–æ–∫–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ - Match
                    string Match(string pattern, int index = 1)
                    {
                        string res = HttpUtility.HtmlDecode(new Regex(pattern, RegexOptions.IgnoreCase).Match(row).Groups[index].Value.Trim());
                        res = Regex.Replace(res, "[\n\r\t¬†]+", " ");
                        return res.Trim();
                    }
                    #endregion

                    #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                    string url = Match("<a href=\"/(releases/[^\"]+)\"");
                    string name = Match("<a class=\"releases__title-russian\" [^>]+>([^<]+)</a>");
                    string originalname = Match("<span class=\"releases__title-original\">([^<]+)</span>");
                    string episodes = Match("([0-9]+(-[0-9]+)?) –∏–∑ [0-9]+ —ç–ø.,");

                    if (string.IsNullOrWhiteSpace(url) || string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(originalname))
                        continue;

                    int.TryParse(Match("<a href=\"/releases/releases/[^\"]+\">([0-9]{4})</a> –≥\\."), out int relased);

                    string title = $"{name} / {originalname}";

                    if (!string.IsNullOrWhiteSpace(episodes))
                        title += $" ({episodes})";

                    var createTime = DateTime.Now.AddYears(-1);

                    if (relased > 0)
                    {
                        title += $" [{relased}]";
                        createTime = tParse.ParseCreateTime($"01.01.{relased}", "dd.MM.yyyy");
                    }
                    #endregion

                    torrents.Add(new TorrentDetails()
                    {
                        types = new string[] { "anime" },
                        url = $"{jackett.Anifilm.host}/{url}",
                        title = title,
                        sid = 1,
                        createTime = createTime,
                        parselink = $"{host}/anifilm/parsemagnet?url={HttpUtility.UrlEncode(url)}",
                        name = name,
                        originalname = originalname,
                        relased = relased
                    });
                }
            }
            else
            {
                string url = Regex.Match(html, "property=\"og:url\" content=\"https?://[^/]+/([^\"]+)\"").Groups[1].Value;
                string name = Regex.Match(html, "itemprop=\"name\">([^<]+)").Groups[1].Value;
                string alternative = Regex.Match(html, "itemprop=\"alternativeHeadline\">([^<]+)").Groups[1].Value;

                if (!string.IsNullOrEmpty(name))
                {
                    torrents.Add(new TorrentDetails()
                    {
                        types = new string[] { "anime" },
                        url = $"{jackett.Anifilm.host}/{url}",
                        title = name + (!string.IsNullOrEmpty(alternative) ? $" / {alternative}" : ""),
                        sid = 1,
                        parselink = $"{host}/anifilm/parsemagnet?url={HttpUtility.UrlEncode(url)}"
                    });
                }
            }

            return torrents;
        }
        #endregion
    }
}

```

## File: JacRed/Controllers/BigFanGroup.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace JacRed.Controllers
{
    [Route("bigfangroup/[action]")]
    public class BigFanGroup : JacBaseController
    {
        #region search
        public static Task<bool> search(string host, ConcurrentBag<TorrentDetails> torrents, string query, string[] cats)
        {
            if (!jackett.BigFanGroup.enable || jackett.BigFanGroup.showdown)
                return Task.FromResult(false);

            return Joinparse(torrents, () => parsePage(host, query, cats));
        }
        #endregion


        #region parseMagnet
        async public Task<ActionResult> parseMagnet(string id)
        {
            if (!jackett.BigFanGroup.enable)
                return Content("disable");

            var proxyManager = new ProxyManager("bigfangroup", jackett.BigFanGroup);

            var _t = await Http.Download($"{jackett.BigFanGroup.host}/download.php?id={id}", proxy: proxyManager.Get(), referer: jackett.BigFanGroup.host);
            if (_t != null && BencodeTo.Magnet(_t) != null)
                return File(_t, "application/x-bittorrent");

            return Content("error");
        }
        #endregion

        #region parsePage
        async static ValueTask<List<TorrentDetails>> parsePage(string host, string query, string[] cats)
        {
            var torrents = new List<TorrentDetails>();
            var proxyManager = new ProxyManager("bigfangroup", jackett.BigFanGroup);

            #region –ö–µ—à html
            string html = await Http.Get($"{jackett.BigFanGroup.host}/browse.php?search=" + HttpUtility.UrlEncode(query), proxy: proxyManager.Get(), timeoutSeconds: jackett.timeoutSeconds);

            if (html == null || !html.Contains("id=\"searchinput\""))
            {
                consoleErrorLog("bigfangroup");
                return null;
            }
            #endregion

            var doc = new HtmlDocument();
            doc.LoadHtml(html.Replace("&nbsp;", " "));

            var nodes = doc.DocumentNode.SelectNodes("//tbody//tr");
            if (nodes == null || nodes.Count == 0)
                return null;

            foreach (var row in nodes)
            {
                var hc = new HtmlCommon(row);

                #region –î–∞–Ω–Ω—ã–µ —Ä–∞–∑–¥–∞—á–∏
                string title = hc.NodeValue(".//a//b");

                DateTime createTime = tParse.ParseCreateTime(hc.NodeValue(".//img[@src='pic/time.png']", "title").Split(" –≤")[0], "dd.MM.yyyy");
                string viewtopic = hc.Match("href=\"details.php\\?id=([0-9]+)");
                string tracker = hc.Match("href=\"browse.php\\?cat=([0-9]+)");
                string sid = hc.NodeValue(".//font[@color='#000000']");
                string pir = hc.Match("todlers=[0-9]+\">([0-9]+)</a>");
                string sizeName = hc.NodeValue(".//td[contains(text(), 'GB') or contains(text(), 'MB')]");

                if (string.IsNullOrEmpty(viewtopic) || string.IsNullOrEmpty(tracker) || string.IsNullOrEmpty(title) || title.Contains(" | –ö–ü–ö"))
                    continue;
                #endregion

                #region types
                string[] types = null;
                switch (tracker)
                {
                    case "13":
                    case "52":
                    case "33":
                    case "48":
                    case "21":
                    case "39":
                    case "18":
                    case "24":
                    case "36":
                    case "53":
                    case "19":
                    case "31":
                    case "29":
                    case "27":
                    case "22":
                    case "26":
                    case "23":
                    case "30":
                        types = new string[] { "movie" };
                        break;
                    case "12":
                    case "20":
                    case "47":
                        types = new string[] { "multfilm" };
                        types = new string[] { "multserial" };
                        break;
                    case "11":
                        types = new string[] { "serial" };
                        break;
                    case "49":
                    case "32":
                    case "28":
                        types = new string[] { "docuserial", "documovie" };
                        break;
                    case "25":
                        types = new string[] { "tvshow" };
                        break;
                }

                if (cats != null)
                {
                    if (types == null)
                        continue;

                    bool isok = false;
                    foreach (string cat in cats)
                    {
                        if (types.Contains(cat))
                            isok = true;
                    }

                    if (!isok)
                        continue;
                }
                #endregion

                torrents.Add(new TorrentDetails()
                {
                    types = types,
                    url = $"{jackett.BigFanGroup.host}/forum/viewtopic.php?t={viewtopic}",
                    title = title,
                    sid = HtmlCommon.Integer(sid),
                    pir = HtmlCommon.Integer(pir),
                    sizeName = sizeName,
                    createTime = createTime,
                    parselink = $"{host}/bigfangroup/parsemagnet?id={viewtopic}"
                });
            }

            return torrents;
        }
        #endregion
    }
}

```

## File: JacRed/Engine/JacBaseController.cs
```
Ôªøusing Jackett;
using JacRed.Models.AppConf;

namespace JacRed.Engine
{
    public class JacBaseController : BaseController
    {
        public static RedConf red => ModInit.conf.Red;

        public static JacConf jackett => ModInit.conf.Jackett;


        async public static Task<bool> Joinparse(ConcurrentBag<TorrentDetails> torrents, Func<ValueTask<List<TorrentDetails>>> parse)
        {
            var result = await parse();

            if (result != null && result.Count > 0)
            {
                foreach (TorrentDetails torrent in result)
                    torrents.Add(torrent);

                return true;
            }

            return false;
        }

        public static void consoleErrorLog(string plugin)
        {
            Console.WriteLine($"JacRed: InternalServerError - {plugin}");
        }
    }
}

```

## File: JacRed/Engine/JsonStream.cs
```
Ôªøusing Newtonsoft.Json;
using System.IO.Compression;

namespace JacRed.Engine.CORE
{
    public static class JsonStream
    {
        #region Read
        public static T Read<T>(string path)
        {
            try
            {
                var settings = new JsonSerializerSettings
                {
                    Error = (se, ev) => { ev.ErrorContext.Handled = true; }
                };

                var serializer = JsonSerializer.Create(settings);

                using (Stream file = new GZipStream(File.OpenRead(path), CompressionMode.Decompress))
                {
                    using (var sr = new StreamReader(file))
                    {
                        using (var jsonTextReader = new JsonTextReader(sr))
                        {
                            return serializer.Deserialize<T>(jsonTextReader);
                        }
                    }
                }
            }
            catch { return default; }
        }
        #endregion

        #region Write
        public static void Write(string path, object db)
        {
            try
            {
                //var settings = new JsonSerializerSettings()
                //{
                //    Formatting = Formatting.Indented
                //};

                var serializer = JsonSerializer.Create(); // settings

                using (var sw = new StreamWriter(new GZipStream(File.OpenWrite(path), CompressionMode.Compress)))
                {
                    using (var jsonTextWriter = new JsonTextWriter(sw))
                    {
                        serializer.Serialize(jsonTextWriter, db);
                    }
                }
            }
            catch { }
        }
        #endregion
    }
}

```

## File: JacRed/Engine/WebApi.cs
```
Ôªøusing Jackett;
using Newtonsoft.Json.Linq;
using System.Text;
using Shared.Models.JacRed.Tracks;

namespace JacRed.Engine
{
    public static class WebApi
    {
        #region Indexers
        async public static Task<List<TorrentDetails>> Indexers(string query, string title, string title_original, int year, int is_serial, Dictionary<string, string> category)
        {
            var queryString = new StringBuilder();

            if (!string.IsNullOrEmpty(title))
                queryString.Append($"&title={HttpUtility.UrlEncode(title)}");

            if (!string.IsNullOrEmpty(title_original))
                queryString.Append($"&title_original={HttpUtility.UrlEncode(title_original)}");

            if (year > 0)
                queryString.Append($"&year={year}");

            if (is_serial > 0)
                queryString.Append($"&is_serial={is_serial}");

            if (category != null && category.Count > 0)
                queryString.Append($"&category[]={category.First().Value}");

            var root = await Http.Get<JObject>($"{ModInit.conf.webApiHost}/api/v2.0/indexers/all/results?query={HttpUtility.UrlEncode(query)}" + queryString.ToString(), timeoutSeconds: 8);
            if (root == null)
                return new List<TorrentDetails>();

            var results = root.GetValue("Results")?.ToObject<JArray>();
            if (results == null || results.Count == 0)
                return new List<TorrentDetails>();

            var torrents = new List<TorrentDetails>(results.Count);

            foreach (var torrent in results)
            {
                try
                {
                    string name = torrent.Value<string>("Title");
                    string tracker = torrent.Value<string>("Tracker");

                    if (ModInit.conf.Red.trackers != null)
                    {
                        if (!tracker.Contains(","))
                        {
                            if (!ModInit.conf.Red.trackers.Contains(tracker))
                                continue;
                        }
                        else
                        {
                            /*
                             * –≠—Ç–æ—Ç –∫–æ–¥ —Ñ–∏–ª—å—Ç—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤ –ø–æ —Å–ø–∏—Å–∫—É —Ä–∞–∑—Ä–µ—à—ë–Ω–Ω—ã—Ö —Ç—Ä–µ–∫–µ—Ä–æ–≤, –∫–æ—Ç–æ—Ä—ã–π —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ ModInit.conf.Red.trackers. 
                             * –ï—Å–ª–∏ —É —Ç–æ—Ä—Ä–µ–Ω—Ç–∞ –≤ –ø–æ–ª–µ Tracker —É–∫–∞–∑–∞–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç—Ä–µ–∫–µ—Ä–æ–≤ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, —Ç–æ –æ–Ω –±—É–¥–µ—Ç –¥–æ–ø—É—â–µ–Ω —Ç–æ–ª—å–∫–æ –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –∏–∑ —ç—Ç–∏—Ö —Ç—Ä–µ–∫–µ—Ä–æ–≤ –µ—Å—Ç—å –≤ —Ä–∞–∑—Ä–µ—à—ë–Ω–Ω–æ–º —Å–ø–∏—Å–∫–µ.
                             */
                            var trackers = tracker.Split(',');
                            if (!ModInit.conf.Red.trackers.Any(t => trackers.Contains(t)))
                                continue;
                        }
                    }

                    if (!string.IsNullOrEmpty(ModInit.conf.filter) && !Regex.IsMatch(name, ModInit.conf.filter, RegexOptions.IgnoreCase))
                        continue;

                    if (!string.IsNullOrEmpty(ModInit.conf.filter_ignore) && Regex.IsMatch(name, ModInit.conf.filter_ignore, RegexOptions.IgnoreCase))
                        continue;

                    torrents.Add(new TorrentDetails()
                    {
                        trackerName = tracker,
                        url = torrent.Value<string>("Details"),
                        title = name,
                        sid = torrent.Value<int>("Seeders"),
                        pir = torrent.Value<int>("Peers"),
                        size = torrent.Value<double>("Size"),
                        magnet = torrent.Value<string>("MagnetUri"),
                        createTime = torrent.Value<DateTime>("PublishDate"),
                        ffprobe = torrent["ffprobe"]?.ToObject<List<ffStream>>()
                    });
                }
                catch { }
            }

            return torrents;
        }
        #endregion

        #region Api
        public static Task<List<TorrentDetails>> Api(string search)
        {
            return Indexers(search, null, null, 0, 0, null);
        }
        #endregion
    }
}

```

## File: JacRed/Engine/SyncCron.cs
```
Ôªøusing Jackett;
using JacRed.Models.Sync;

namespace JacRed.Engine
{
    public static class SyncCron
    {
        static long lastsync = -1;

        async public static Task Run()
        {
            bool reset = true;
            await Task.Delay(TimeSpan.FromMinutes(2));

            DateTime lastSave = DateTime.Now;

            while (true)
            {
                try
                {
                    if (File.Exists(@"C:\ProgramData\lampac\disablesync"))
                        break;

                    if (ModInit.conf.typesearch == "red" && !string.IsNullOrWhiteSpace(ModInit.conf.Red.syncapi))
                    {
                        if (lastsync == -1 && File.Exists("cache/jacred/lastsync.txt"))
                            lastsync = long.Parse(File.ReadAllText("cache/jacred/lastsync.txt"));

                        var root = await Http.Get<RootObject>($"{ModInit.conf.Red.syncapi}/sync/fdb/torrents?time={lastsync}", timeoutSeconds: 300, MaxResponseContentBufferSize: 100_000_000, weblog: false);

                        if (root?.collections == null)
                        {
                            if (reset)
                            {
                                reset = false;
                                await Task.Delay(TimeSpan.FromMinutes(1));
                                continue;
                            }
                        }
                        else if (root.collections.Count > 0)
                        {
                            reset = true;
                            foreach (var collection in root.collections)
                            {
                                bool updateMasterDb = false;

                                using (var fdb = FileDB.Open(collection.Key, empty: true))
                                {
                                    foreach (var torrent in collection.Value.torrents)
                                    {
                                        if (torrent.Value.types == null || torrent.Value.types.Contains("sport"))
                                            continue;

                                        fdb.Database.AddOrUpdate(torrent.Key, torrent.Value, (k, v) => torrent.Value);
                                        updateMasterDb = true;
                                    }
                                }

                                if (updateMasterDb)
                                {
                                    if (FileDB.masterDb.ContainsKey(collection.Key))
                                    {
                                        FileDB.masterDb[collection.Key] = collection.Value.time;
                                    }
                                    else
                                    {
                                        FileDB.masterDb.TryAdd(collection.Key, collection.Value.time);
                                    }
                                }
                            }

                            lastsync = root.collections.Last().Value.fileTime;

                            if (root.nextread)
                            {
                                if (DateTime.Now > lastSave.AddMinutes(5))
                                {
                                    lastSave = DateTime.Now;
                                    FileDB.SaveChangesToFile();
                                    File.WriteAllText("cache/jacred/lastsync.txt", lastsync.ToString());
                                }

                                continue;
                            }
                        }

                        FileDB.SaveChangesToFile();
                        File.WriteAllText("cache/jacred/lastsync.txt", lastsync.ToString());
                    }
                    else
                    {
                        await Task.Delay(TimeSpan.FromMinutes(1));
                        continue;
                    }
                }
                catch
                {
                    try
                    {
                        if (lastsync > 0)
                        {
                            FileDB.SaveChangesToFile();
                            File.WriteAllText("cache/jacred/lastsync.txt", lastsync.ToString());
                        }
                    }
                    catch { }
                }

                await Task.Delay(1000 * Random.Shared.Next(60, 300));
                await Task.Delay(1000 * 60 * (20 > ModInit.conf.Red.syntime ? 20 : ModInit.conf.Red.syntime));

                reset = true;
                lastSave = DateTime.Now;
            }
        }
    }
}

```

## File: JacRed/Engine/RedApi.cs
```
Ôªøusing MonoTorrent;
using JacRed.Models.AppConf;
using Jackett;

namespace JacRed.Engine
{
    public static class RedApi
    {
        static RedConf red => ModInit.conf.Red;

        #region Indexers
        public static (IEnumerable<TorrentDetails> torrents, bool setcache) Indexers(bool rqnum, string apikey, string query, string title, string title_original, int year, int is_serial, Dictionary<string, string> category)
        {
            bool setcache = false;
            var torrents = new Dictionary<string, TorrentDetails>();

            #region category
            if (is_serial == 0 && category != null)
            {
                string cat = category.FirstOrDefault().Value;
                if (cat != null)
                {
                    if (cat.Contains("5020") || cat.Contains("2010"))
                        is_serial = 3; // tvshow
                    else if (cat.Contains("5080"))
                        is_serial = 4; // –¥–æ–∫
                    else if (cat.Contains("5070"))
                        is_serial = 5; // –∞–Ω–∏–º–µ
                    else if (is_serial == 0)
                    {
                        if (cat.StartsWith("20"))
                            is_serial = 1; // —Ñ–∏–ª—å–º
                        else if (cat.StartsWith("50"))
                            is_serial = 2; // —Å–µ—Ä–∏–∞–ª
                    }
                }
            }
            #endregion

            #region AddTorrents
            void AddTorrents(TorrentDetails t)
            {
                if (t.url == null)
                    return;

                if (!string.IsNullOrEmpty(ModInit.conf.filter) && !Regex.IsMatch(t.title, ModInit.conf.filter, RegexOptions.IgnoreCase))
                    return;

                if (!string.IsNullOrEmpty(ModInit.conf.filter_ignore) && Regex.IsMatch(t.title, ModInit.conf.filter_ignore, RegexOptions.IgnoreCase))
                    return;

                if (InvkEvent.conf.RedApi?.AddTorrents != null)
                {
                    if (!InvkEvent.RedApi("addtorrent", t))
                        return;
                }
                else
                {
                    EventListener.RedApiAddTorrents?.Invoke(t);
                }

                if (torrents.TryGetValue(t.url, out TorrentDetails val))
                {
                    if (t.updateTime > val.updateTime)
                        torrents[t.url] = t;
                }
                else
                {
                    torrents.TryAdd(t.url, t);
                }
            }
            #endregion

            if (!string.IsNullOrWhiteSpace(title) || !string.IsNullOrWhiteSpace(title_original))
            {
                #region –¢–æ—á–Ω—ã–π –ø–æ–∏—Å–∫
                setcache = true;

                string _n = StringConvert.SearchName(title);
                string _o = StringConvert.SearchName(title_original);

                // –ë—ã—Å—Ç—Ä–∞—è –≤—ã–±–æ—Ä–∫–∞ –ø–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—é –∫–ª—é—á–∞ –≤ –∏–º–µ–Ω–∏
                var mdb = FileDB.masterDb.Where(i => _n != null && i.Key.StartsWith($"{_n}:") || _o != null && i.Key.EndsWith($":{_o}"));
                if (!red.evercache.enable || red.evercache.validHour > 0)
                    mdb = mdb.Take(red.maxreadfile);

                foreach (var val in mdb)
                {
                    using (var fdb = FileDB.Open(val.Key))
                    {
                        foreach (var t in fdb.Database.Values)
                        {
                            if (t.types == null || t.title.Contains(" –ö–ü–ö"))
                                continue;

                            string name = StringConvert.SearchName(t.name);
                            string originalname = StringConvert.SearchName(t.originalname);

                            // –¢–æ—á–Ω–∞—è –≤—ã–±–æ—Ä–∫–∞ –ø–æ name –∏–ª–∏ originalname
                            if (_n != null && _n == name || _o != null && _o == originalname)
                            {
                                if (is_serial == 1)
                                {
                                    #region –§–∏–ª—å–º
                                    if (t.types.Contains("movie") || t.types.Contains("multfilm") || t.types.Contains("anime") || t.types.Contains("documovie"))
                                    {
                                        if (Regex.IsMatch(t.title, " (—Å–µ–∑–æ–Ω|—Å–µ—Ä–∏(–∏|—è|–π))", RegexOptions.IgnoreCase))
                                            continue;

                                        if (year > 0)
                                        {
                                            if (t.relased == year || t.relased == year - 1 || t.relased == year + 1)
                                                AddTorrents(t);
                                        }
                                        else
                                        {
                                            AddTorrents(t);
                                        }
                                    }
                                    #endregion
                                }
                                else if (is_serial == 2)
                                {
                                    #region –°–µ—Ä–∏–∞–ª
                                    if (t.types.Contains("serial") || t.types.Contains("multserial") || t.types.Contains("anime") || t.types.Contains("docuserial") || t.types.Contains("tvshow"))
                                    {
                                        if (year > 0)
                                        {
                                            if (t.relased >= year - 1)
                                                AddTorrents(t);
                                        }
                                        else
                                        {
                                            AddTorrents(t);
                                        }
                                    }
                                    #endregion
                                }
                                else if (is_serial == 3)
                                {
                                    #region tvshow
                                    if (t.types.Contains("tvshow"))
                                    {
                                        if (year > 0)
                                        {
                                            if (t.relased >= year - 1)
                                                AddTorrents(t);
                                        }
                                        else
                                        {
                                            AddTorrents(t);
                                        }
                                    }
                                    #endregion
                                }
                                else if (is_serial == 4)
                                {
                                    #region docuserial / documovie
                                    if (t.types.Contains("docuserial") || t.types.Contains("documovie"))
                                    {
                                        if (year > 0)
                                        {
                                            if (t.relased >= year - 1)
                                                AddTorrents(t);
                                        }
                                        else
                                        {
                                            AddTorrents(t);
                                        }
                                    }
                                    #endregion
                                }
                                else if (is_serial == 5)
                                {
                                    #region anime
                                    if (t.types.Contains("anime"))
                                    {
                                        if (year > 0)
                                        {
                                            if (t.relased >= year - 1)
                                                AddTorrents(t);
                                        }
                                        else
                                        {
                                            AddTorrents(t);
                                        }
                                    }
                                    #endregion
                                }
                                else
                                {
                                    #region –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ
                                    if (year > 0)
                                    {
                                        if (t.types.Contains("movie") || t.types.Contains("multfilm") || t.types.Contains("documovie"))
                                        {
                                            if (t.relased == year || t.relased == year - 1 || t.relased == year + 1)
                                                AddTorrents(t);
                                        }
                                        else
                                        {
                                            if (t.relased >= year - 1)
                                                AddTorrents(t);
                                        }
                                    }
                                    else
                                    {
                                        AddTorrents(t);
                                    }
                                    #endregion
                                }
                            }
                        }
                    }
                }
                #endregion
            }
            else if (!string.IsNullOrWhiteSpace(query) && query.Length > 1)
            {
                #region –û–±—ã—á–Ω—ã–π –ø–æ–∏—Å–∫
                string _s = StringConvert.SearchName(query);

                #region torrentsSearch
                void torrentsSearch(bool exact)
                {
                    var mdb = FileDB.masterDb.Where(i => i.Key.Contains(_s));
                    if (!red.evercache.enable || red.evercache.validHour > 0)
                        mdb = mdb.Take(red.maxreadfile);

                    foreach (var val in mdb)
                    {
                        using (var fdb = FileDB.Open(val.Key))
                        {
                            foreach (var t in fdb.Database.Values)
                            {
                                if (exact)
                                {
                                    if (StringConvert.SearchName(t.name) != _s && StringConvert.SearchName(t.originalname) != _s)
                                        continue;
                                }

                                if (t.types == null || t.title.Contains(" –ö–ü–ö"))
                                    continue;

                                if (is_serial == 1)
                                {
                                    if (t.types.Contains("movie") || t.types.Contains("multfilm") || t.types.Contains("anime") || t.types.Contains("documovie"))
                                        AddTorrents(t);
                                }
                                else if (is_serial == 2)
                                {
                                    if (t.types.Contains("serial") || t.types.Contains("multserial") || t.types.Contains("anime") || t.types.Contains("docuserial") || t.types.Contains("tvshow"))
                                        AddTorrents(t);
                                }
                                else if (is_serial == 3)
                                {
                                    if (t.types.Contains("tvshow"))
                                        AddTorrents(t);
                                }
                                else if (is_serial == 4)
                                {
                                    if (t.types.Contains("docuserial") || t.types.Contains("documovie"))
                                        AddTorrents(t);
                                }
                                else if (is_serial == 5)
                                {
                                    if (t.types.Contains("anime"))
                                        AddTorrents(t);
                                }
                                else
                                {
                                    AddTorrents(t);
                                }
                            }
                        }

                    }
                }
                #endregion

                if (is_serial == -1)
                    torrentsSearch(exact: false);
                else
                {
                    torrentsSearch(exact: true);
                    if (torrents.Count == 0)
                        torrentsSearch(exact: false);
                }
                #endregion
            }

            #region –û–±—ä–µ–¥–∏–Ω–∏—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã
            IEnumerable<TorrentDetails> tsort = null;

            if (ModInit.conf.typesearch == "red" && ((!rqnum && red.mergeduplicates) || (rqnum && red.mergenumduplicates)))
            {
                var temp = new Dictionary<string, (TorrentDetails torrent, string title, string Name, List<string> AnnounceUrls)>();

                foreach (var torrent in torrents.Values
                                                .Where(i => red.trackers == null || red.trackers.Contains(i.trackerName))
                                                .OrderByDescending(i => i.createTime)
                                                .ThenBy(i => i.trackerName == "selezen").ToList())
                {
                    if (torrent.magnet == null)
                        continue;

                    var magnetLink = MagnetLink.Parse(torrent.magnet);
                    string hex = magnetLink.InfoHashes.V1.ToHex();

                    if (!temp.TryGetValue(hex, out _))
                    {
                        temp.TryAdd(hex, ((TorrentDetails)torrent.Clone(), torrent.trackerName == "kinozal" ? torrent.title : null, magnetLink.Name, magnetLink.AnnounceUrls?.ToList() ?? new List<string>()));
                    }
                    else
                    {
                        var t = temp[hex];
                        t.torrent.trackerName += $", {torrent.trackerName}";

                        #region urls
                        if (t.torrent.urls == null)
                            t.torrent.urls = new HashSet<string> { t.torrent.url };

                        t.torrent.urls.Add(torrent.url);
                        #endregion

                        #region UpdateMagnet
                        void UpdateMagnet()
                        {
                            string magnet = $"magnet:?xt=urn:btih:{hex.ToLower()}";

                            if (!string.IsNullOrWhiteSpace(t.Name))
                                magnet += $"&dn={HttpUtility.UrlEncode(t.Name)}";

                            if (t.AnnounceUrls != null && t.AnnounceUrls.Count > 0)
                            {
                                foreach (string announce in t.AnnounceUrls)
                                {
                                    string tr = announce.Contains("/") || announce.Contains(":") ? HttpUtility.UrlEncode(announce) : announce;

                                    if (!magnet.Contains(tr))
                                        magnet += $"&tr={tr}";
                                }
                            }

                            t.torrent.magnet = magnet;
                        }
                        #endregion

                        if (string.IsNullOrWhiteSpace(t.Name) && !string.IsNullOrWhiteSpace(magnetLink.Name))
                        {
                            t.Name = magnetLink.Name;
                            temp[hex] = t;
                            UpdateMagnet();
                        }

                        if (magnetLink.AnnounceUrls != null && magnetLink.AnnounceUrls.Count > 0)
                        {
                            t.AnnounceUrls.AddRange(magnetLink.AnnounceUrls);
                            UpdateMagnet();
                        }

                        #region UpdateTitle
                        void UpdateTitle()
                        {
                            if (string.IsNullOrWhiteSpace(t.title))
                                return;

                            string title = t.title;

                            if (t.torrent.voices != null && t.torrent.voices.Count > 0)
                                title += $" | {string.Join(" | ", t.torrent.voices)}";

                            t.torrent.title = title;
                        }

                        if (torrent.trackerName == "kinozal")
                        {
                            t.title = torrent.title;
                            temp[hex] = t;
                            UpdateTitle();
                        }

                        if (torrent.voices != null && torrent.voices.Count > 0)
                        {
                            if (t.torrent.voices == null)
                            {
                                t.torrent.voices = torrent.voices;
                            }
                            else
                            {
                                foreach (var v in torrent.voices)
                                    t.torrent.voices.Add(v);
                            }

                            UpdateTitle();
                        }
                        #endregion

                        if (torrent.trackerName != "selezen")
                        {
                            if (torrent.sid > t.torrent.sid)
                                t.torrent.sid = torrent.sid;

                            if (torrent.pir > t.torrent.pir)
                                t.torrent.pir = torrent.pir;
                        }

                        if (torrent.createTime > t.torrent.createTime)
                            t.torrent.createTime = torrent.createTime;

                        if (torrent.voices != null && torrent.voices.Count > 0)
                        {
                            if (t.torrent.voices == null)
                                t.torrent.voices = new HashSet<string>();

                            foreach (var v in torrent.voices)
                                t.torrent.voices.Add(v);
                        }

                        if (torrent.languages != null && torrent.languages.Count > 0)
                        {
                            if (t.torrent.languages == null)
                                t.torrent.languages = new HashSet<string>();

                            foreach (var v in torrent.languages)
                                t.torrent.languages.Add(v);
                        }

                        if (t.torrent.ffprobe == null)
                            t.torrent.ffprobe = torrent.ffprobe;
                    }
                }

                tsort = temp.Select(i => i.Value.torrent);
            }
            else
            {
                tsort = torrents.Values.Where(i => red.trackers == null || red.trackers.Contains(i.trackerName));
            }
            #endregion

            if (apikey == "rus")
                return (tsort.Where(i => i.languages != null && i.languages.Contains("rus") || i.types != null && (i.types.Contains("sport") || i.types.Contains("tvshow") || i.types.Contains("docuserial"))), setcache);

            return (tsort, setcache);
        }
        #endregion

        #region Api
        public static IEnumerable<TorrentDetails> Api(string search, string altname, bool exact, string type, string sort, string tracker, string voice, string videotype, long relased, long quality, long season)
        {
            var torrents = new Dictionary<string, TorrentDetails>();

            #region AddTorrents
            void AddTorrents(TorrentDetails t)
            {
                if (torrents.TryGetValue(t.url, out TorrentDetails val))
                {
                    if (t.updateTime > val.updateTime)
                        torrents[t.url] = t;
                }
                else
                {
                    torrents.TryAdd(t.url, t);
                }
            }
            #endregion

            if (string.IsNullOrWhiteSpace(search) || search.Length == 1)
                return new List<TorrentDetails>();

            string _s = StringConvert.SearchName(search);
            string _altsearch = StringConvert.SearchName(altname);

            if (exact)
            {
                #region –¢–æ—á–Ω—ã–π –ø–æ–∏—Å–∫
                foreach (var mdb in FileDB.masterDb.Where(i => i.Key.StartsWith($"{_s}:") || i.Key.EndsWith($":{_s}") || _altsearch != null && i.Key.Contains(_altsearch)))
                {
                    using (var fdb = FileDB.Open(mdb.Key))
                    {
                        foreach (var t in fdb.Database.Values)
                        {
                            if (t.types == null)
                                continue;

                            if (string.IsNullOrWhiteSpace(type) || t.types.Contains(type))
                            {
                                string _n = StringConvert.SearchName(t.name);
                                string _o = StringConvert.SearchName(t.originalname);

                                if (_n == _s || _o == _s || _altsearch != null && (_n == _altsearch || _o == _altsearch))
                                    AddTorrents(t);
                            }
                        }
                    }
                }
                #endregion
            }
            else
            {
                #region –ü–æ–∏—Å–∫ –ø–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—é –∫–ª—é—á–∞ –≤ –∏–º–µ–Ω–∏
                var mdb = FileDB.masterDb.Where(i => i.Key.Contains(_s) || _altsearch != null && i.Key.Contains(_altsearch));
                if (!red.evercache.enable || red.evercache.validHour > 0)
                    mdb = mdb.Take(red.maxreadfile);

                foreach (var val in mdb)
                {
                    using (var fdb = FileDB.Open(val.Key))
                    {
                        foreach (var t in fdb.Database.Values)
                        {
                            if (t.types == null)
                                continue;

                            if (string.IsNullOrWhiteSpace(type) || t.types.Contains(type))
                                AddTorrents(t);
                        }
                    }
                }
                #endregion
            }

            if (torrents.Count == 0)
                return new List<TorrentDetails>();

            IEnumerable<TorrentDetails> query = torrents.Values;

            #region sort
            switch (sort ?? string.Empty)
            {
                case "sid":
                    query = query.OrderByDescending(i => i.sid);
                    break;
                case "pir":
                    query = query.OrderByDescending(i => i.pir);
                    break;
                case "size":
                    query = query.OrderByDescending(i => i.size);
                    break;
                default:
                    query = query.OrderByDescending(i => i.createTime);
                    break;
            }
            #endregion

            if (!string.IsNullOrWhiteSpace(tracker))
                query = query.Where(i => i.trackerName == tracker);

            if (relased > 0)
                query = query.Where(i => i.relased == relased);

            if (quality > 0)
                query = query.Where(i => i.quality == quality);

            if (!string.IsNullOrWhiteSpace(videotype))
                query = query.Where(i => i.videotype == videotype);

            if (!string.IsNullOrWhiteSpace(voice))
                query = query.Where(i => i.voices.Contains(voice));

            if (season > 0)
                query = query.Where(i => i.seasons.Contains((int)season));

            return query.Where(i => red.trackers == null || red.trackers.Contains(i.trackerName));
        }
        #endregion
    }
}

```

## File: JacRed/Engine/JackettApi.cs
```
Ôªøusing Jackett;
using JacRed.Controllers;
using JacRed.Models.AppConf;
using System.Reflection;

namespace JacRed.Engine
{
    public static class JackettApi
    {
        static JacConf jackett => ModInit.conf.Jackett;

        #region Indexers
        async public static Task<List<TorrentDetails>> Indexers(string host, string query, string title, string title_original, int year, int is_serial, Dictionary<string, string> category)
        {
            var hybridCache = new HybridCache();

            string mkey = $"JackettApi:{query}:{title}:{year}:{is_serial}";
            if (hybridCache.TryGetValue(mkey, out List<TorrentDetails> cache, inmemory: false))
                return cache;

            var torrents = new ConcurrentBag<TorrentDetails>();

            #region search
            string search = jackett.search_lang == "query" ? query : jackett.search_lang == "title" ? title : title_original;

            if (string.IsNullOrWhiteSpace(search))
            {
                search = query ?? title ?? title_original;
                if (string.IsNullOrWhiteSpace(search))
                    return torrents.ToList();
            }
            #endregion

            #region category
            if (category != null)
            {
                string cat = category.FirstOrDefault().Value;
                if (cat != null)
                {
                    if (cat.Contains("5020") || cat.Contains("2010"))
                        is_serial = 3; // tvshow
                    else if (cat.Contains("5080"))
                        is_serial = 4; // –¥–æ–∫
                    else if (cat.Contains("5070"))
                        is_serial = 5; // –∞–Ω–∏–º–µ
                    else if (is_serial == 0)
                    {
                        if (cat.StartsWith("20"))
                            is_serial = 1; // —Ñ–∏–ª—å–º
                        else if (cat.StartsWith("50"))
                            is_serial = 2; // —Å–µ—Ä–∏–∞–ª
                    }
                }
            }
            #endregion

            #region modpars
            void modpars(List<Task> tasks, string cat)
            {
                if (AppInit.modules != null && AppInit.modules.Count > 0)
                {
                    foreach (var item in AppInit.modules)
                    {
                        foreach (var mod in item.jac)
                        {
                            if (mod.enable)
                            {
                                try
                                {
                                    if (item.assembly.GetType(mod.@namespace) is Type t && t.GetMethod("parsePage") is MethodInfo m)
                                    {
                                        var task = (Task)m.Invoke(null, new object[] { host, torrents, search, cat });
                                        if (task != null)
                                            tasks.Add(task);
                                    }
                                }
                                catch { }
                            }
                        }
                    }
                }
            }
            #endregion

            #region –ü–∞—Ä—Å–∏–º —Ç–æ—Ä—Ä–µ–Ω—Ç—ã
            if (is_serial == 1)
            {
                #region –§–∏–ª—å–º
                var tasks = new List<Task>
                {
                    RutorController.search(host, torrents, search, "1"),  // movie
                    RutorController.search(host, torrents, search, "5"),  // movie
                    RutorController.search(host, torrents, search, "7"),  // multfilm
                    RutorController.search(host, torrents, search, "12"), // documovie
                    RutorController.search(host, torrents, search, "17", true, "1"), // UKR

                    MegapeerController.search(host, torrents, search, "79"),  // –ù–∞—à–∏ —Ñ–∏–ª—å–º—ã
                    MegapeerController.search(host, torrents, search, "80"),  // –ó–∞—Ä—É–±–µ–∂–Ω—ã–µ —Ñ–∏–ª—å–º—ã
                    MegapeerController.search(host, torrents, search, "76"),  // –ú—É–ª—å—Ç–∏–ø–ª–∏–∫–∞—Ü–∏—è

                    TorrentByController.search(host, torrents, search, "1"), // movie
                    TorrentByController.search(host, torrents, search, "2"), // movie
                    TorrentByController.search(host, torrents, search, "5"), // multfilm

                    KinozalController.search(host, torrents, search, new string[] { "movie", "multfilm", "tvshow" }),
                    NNMClubController.search(host, torrents, search, new string[] { "movie", "multfilm", "documovie" }),
                    TolokaController.search(host, torrents, search, new string[] { "movie", "multfilm", "documovie" }),
                    RutrackerController.search(host, torrents, search, new string[] { "movie", "multfilm", "documovie" }),
                    BitruController.search(host, torrents, search, new string[] { "movie" }),
                    SelezenController.search(host, torrents, search),
                    BigFanGroup.search(host, torrents, search, new string[] { "movie", "multfilm", "documovie" })
                };

                modpars(tasks, "movie");

                await Task.WhenAll(tasks);
                #endregion
            }
            else if (is_serial == 2)
            {
                #region –°–µ—Ä–∏–∞–ª
                var tasks = new List<Task>
                {
                    RutorController.search(host, torrents, search, "4"),  // serial
                    RutorController.search(host, torrents, search, "16"), // serial
                    RutorController.search(host, torrents, search, "7"),  // multserial
                    RutorController.search(host, torrents, search, "12"), // docuserial
                    RutorController.search(host, torrents, search, "6"),  // tvshow
                    RutorController.search(host, torrents, search, "17", true, "4"), // UKR

                    MegapeerController.search(host, torrents, search, "5"),  // serial
                    MegapeerController.search(host, torrents, search, "6"),  // serial
                    MegapeerController.search(host, torrents, search, "55"), // docuserial
                    MegapeerController.search(host, torrents, search, "57"), // tvshow
                    MegapeerController.search(host, torrents, search, "76"), // multserial

                    TorrentByController.search(host, torrents, search, "3"),  // serial
                    TorrentByController.search(host, torrents, search, "5"),  // multserial
                    TorrentByController.search(host, torrents, search, "4"),  // tvshow
                    TorrentByController.search(host, torrents, search, "12"), // tvshow

                    KinozalController.search(host, torrents, search, new string[] { "serial", "multserial", "tvshow" }),
                    NNMClubController.search(host, torrents, search, new string[] { "serial", "multserial", "docuserial" }),
                    TolokaController.search(host, torrents, search, new string[] { "serial", "multserial", "docuserial" }),
                    RutrackerController.search(host, torrents, search, new string[] { "serial", "multserial", "docuserial" }),
                    BitruController.search(host, torrents, search, new string[] { "serial" }),
                    LostfilmController.search(host, torrents, search),
                    BigFanGroup.search(host, torrents, search, new string[] { "serial", "multserial", "docuserial", "tvshow" })
                };

                modpars(tasks, "serial");

                await Task.WhenAll(tasks);
                #endregion
            }
            else if (is_serial == 3)
            {
                #region tvshow
                var tasks = new List<Task>
                {
                    RutorController.search(host, torrents, search, "6"),
                    MegapeerController.search(host, torrents, search, "57"),
                    TorrentByController.search(host, torrents, search, "4"),
                    TorrentByController.search(host, torrents, search, "12"),
                    KinozalController.search(host, torrents, search, new string[] { "tvshow" }),
                    NNMClubController.search(host, torrents, search, new string[] { "docuserial", "documovie" }),
                    TolokaController.search(host, torrents, search, new string[] { "docuserial", "documovie" }),
                    RutrackerController.search(host, torrents, search, new string[] { "tvshow" }),
                    BigFanGroup.search(host, torrents, search, new string[] { "tvshow" })
                };

                modpars(tasks, "tvshow");

                await Task.WhenAll(tasks);
                #endregion
            }
            else if (is_serial == 4)
            {
                #region docuserial / documovie
                var tasks = new List<Task>
                {
                    RutorController.search(host, torrents, search, "12"),
                    MegapeerController.search(host, torrents, search, "55"),
                    NNMClubController.search(host, torrents, search, new string[] { "docuserial", "documovie" }),
                    TolokaController.search(host, torrents, search, new string[] { "docuserial", "documovie" }),
                    RutrackerController.search(host, torrents, search, new string[] { "docuserial", "documovie" }),
                    BigFanGroup.search(host, torrents, search, new string[] { "docuserial", "documovie" })
                };

                modpars(tasks, "documental");

                await Task.WhenAll(tasks);
                #endregion
            }
            else if (is_serial == 5)
            {
                #region anime
                string animesearch = title ?? query;

                var tasks = new List<Task>
                {
                    RutorController.search(host, torrents, animesearch, "10"),
                    TorrentByController.search(host, torrents, animesearch, "6"),
                    KinozalController.search(host, torrents, animesearch, new string[] { "anime" }),
                    NNMClubController.search(host, torrents, animesearch, new string[] { "anime" }),
                    RutrackerController.search(host, torrents, animesearch, new string[] { "anime" }),
                    TolokaController.search(host, torrents, search, new string[] { "anime" }),
                    AniLibriaController.search(host, torrents, animesearch),
                    AnimeLayerController.search(host, torrents, animesearch),
                    AnifilmController.search(host, torrents, animesearch)
                };

                modpars(tasks, "anime");

                await Task.WhenAll(tasks);
                #endregion
            }
            else
            {
                #region –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ
                var tasks = new List<Task>
                {
                    RutorController.search(host, torrents, search, "0"),
                    MegapeerController.search(host, torrents, search, "0"),
                    TorrentByController.search(host, torrents, search, "0"),
                    KinozalController.search(host, torrents, search, null),
                    NNMClubController.search(host, torrents, search, null),
                    BitruController.search(host, torrents, search, null),
                    RutrackerController.search(host, torrents, search, null),
                    TolokaController.search(host, torrents, search, null),
                    AniLibriaController.search(host, torrents, search),
                    AnimeLayerController.search(host, torrents, search),
                    AnifilmController.search(host, torrents, search),
                    SelezenController.search(host, torrents, search),
                    LostfilmController.search(host, torrents, search),
                    BigFanGroup.search(host, torrents, search, null)
                };

                modpars(tasks, "search");

                await Task.WhenAll(tasks);
                #endregion
            }
            #endregion

            var hash = new HashSet<string>();
            var finaly = new List<TorrentDetails>(torrents.Count);

            foreach (var t in torrents)
            {
                if (t.trackerName == null)
                    t.trackerName = Regex.Match(t.url, "https?://([^/]+)").Groups[1].Value;

                if (!string.IsNullOrEmpty(ModInit.conf.filter) && !Regex.IsMatch(t.title, ModInit.conf.filter, RegexOptions.IgnoreCase))
                    continue;

                if (!string.IsNullOrEmpty(ModInit.conf.filter_ignore) && Regex.IsMatch(t.title, ModInit.conf.filter_ignore, RegexOptions.IgnoreCase))
                    continue;

                if (!hash.Contains(t.url))
                {
                    hash.Add(t.url);
                    finaly.Add(t);
                }
            }

            var result = finaly.AsEnumerable();

            if (is_serial == 1 && year > 0)
                result = result.Where(i => i.title.Contains(year.ToString()) || i.title.Contains($"{year+1}") || i.title.Contains($"{year-1}"));

            if (ModInit.conf.Jackett.cacheToMinutes > 0)
                hybridCache.Set(mkey, result.ToList(), DateTime.Now.AddMinutes(ModInit.conf.Jackett.cacheToMinutes), inmemory: false);

            return result.ToList();
        }
        #endregion

        #region Api
        public static Task<List<TorrentDetails>> Api(string host, string search)
        {
            return Indexers(host, search, null, null, 0, 0, null);
        }
        #endregion
    }
}

```

## File: JacRed/Engine/FileDB/staticDB.cs
```
Ôªøusing Jackett;
using JacRed.Engine.CORE;
using JacRed.Models;

namespace JacRed.Engine
{
    public partial class FileDB : IDisposable
    {
        #region FileDB
        /// <summary>
        /// $"{search_name}:{search_originalname}"
        /// –í–µ—Ä—Ö–Ω–µ–µ –≤—Ä–µ–º—è –∏–∑–º–µ–Ω–µ–Ω–∏—è 
        /// </summary>
        public static ConcurrentDictionary<string, DateTime> masterDb = new ConcurrentDictionary<string, DateTime>();

        static ConcurrentDictionary<string, WriteTaskModel> openWriteTask = new ConcurrentDictionary<string, WriteTaskModel>();

        static FileDB()
        {
            if (File.Exists("cache/jacred/masterDb.bz"))
                masterDb = JsonStream.Read<ConcurrentDictionary<string, DateTime>>("cache/jacred/masterDb.bz");

            if (masterDb == null)
            {
                if (File.Exists($"cache/jacred/masterDb_{DateTime.Today:dd-MM-yyyy}.bz"))
                    masterDb = JsonStream.Read<ConcurrentDictionary<string, DateTime>>($"cache/jacred/masterDb_{DateTime.Today:dd-MM-yyyy}.bz");

                if (masterDb == null && File.Exists($"cache/jacred/masterDb_{DateTime.Today.AddDays(-1):dd-MM-yyyy}.bz"))
                    masterDb = JsonStream.Read<ConcurrentDictionary<string, DateTime>>($"cache/jacred/masterDb_{DateTime.Today.AddDays(-1):dd-MM-yyyy}.bz");

                if (masterDb == null)
                    masterDb = new ConcurrentDictionary<string, DateTime>();

                if (File.Exists("cache/jacred/lastsync.txt"))
                    File.Delete("cache/jacred/lastsync.txt");
            }
        }
        #endregion

        #region pathDb
        static string pathDb(string key)
        {
            string md5key = CrypTo.md5(key);

            Directory.CreateDirectory($"cache/jacred/fdb/{md5key.Substring(0, 2)}");
            return $"cache/jacred/fdb/{md5key.Substring(0, 2)}/{md5key.Substring(2)}";
        }
        #endregion

        #region Open
        public static FileDB Open(string key, bool empty = false)
        {
            if (empty)
            {
                openWriteTask.TryRemove(key, out _);
                return new FileDB(key, empty: empty);
            }

            if (openWriteTask.TryGetValue(key, out WriteTaskModel val))
            {
                val.countread++;
                val.openconnection += 1;
                val.lastread = DateTime.UtcNow;
                return val.db;
            }
            else
            {
                var fdb = new FileDB(key);
                openWriteTask.TryAdd(key, new WriteTaskModel() { db = fdb, openconnection = 1, countread = 1, lastread = DateTime.UtcNow });
                return fdb;
            }
        }
        #endregion

        #region SaveChangesToFile
        public static void SaveChangesToFile()
        {
            try
            {
                JsonStream.Write("cache/jacred/masterDb.bz", masterDb);

                if (!File.Exists($"cache/jacred/masterDb_{DateTime.Today:dd-MM-yyyy}.bz"))
                    File.Copy("cache/jacred/masterDb.bz", $"cache/jacred/masterDb_{DateTime.Today:dd-MM-yyyy}.bz");

                if (File.Exists($"cache/jacred/masterDb_{DateTime.Today.AddDays(-2):dd-MM-yyyy}.bz"))
                    File.Delete($"cache/jacred/masterDb_{DateTime.Today.AddDays(-2):dd-MM-yyyy}.bz");
            }
            catch { }
        }
        #endregion


        #region Cron
        async public static Task Cron()
        {
            while (true)
            {
                await Task.Delay(TimeSpan.FromMinutes(10));

                if (!ModInit.conf.Red.evercache.enable || 0 >= ModInit.conf.Red.evercache.validHour)
                    continue;

                try
                {
                    var deleteKeys = openWriteTask
                        .Where(i => DateTime.UtcNow > i.Value.lastread.AddHours(ModInit.conf.Red.evercache.validHour))
                        .Select(i => i.Key)
                        .ToArray();

                    foreach (string key in deleteKeys) 
                        openWriteTask.TryRemove(key, out _);
                }
                catch { }
            }
        }

        async public static Task CronFast()
        {
            while (true)
            {
                await Task.Delay(TimeSpan.FromSeconds(20));

                if (!ModInit.conf.Red.evercache.enable || 0 >= ModInit.conf.Red.evercache.validHour)
                    continue;

                try
                {
                    if (openWriteTask.Count > ModInit.conf.Red.evercache.maxOpenWriteTask)
                    {
                        var deleteKeys = openWriteTask
                            .Where(i => DateTime.Now > i.Value.create.AddMinutes(10))
                            .OrderBy(i => i.Value.countread).ThenBy(i => i.Value.lastread)
                            .Take(ModInit.conf.Red.evercache.dropCacheTake)
                            .Select(i => i.Key)
                            .ToArray();

                        foreach (string key in deleteKeys)
                            openWriteTask.TryRemove(key, out _);
                    }
                }
                catch { }
            }
        }
        #endregion
    }
}

```

## File: JacRed/Engine/FileDB/FileDB.cs
```
Ôªøusing Jackett;
using JacRed.Engine.CORE;
using JacRed.Models;

namespace JacRed.Engine
{
    public partial class FileDB : IDisposable
    {
        string fdbkey;

        public ConcurrentDictionary<string, TorrentDetails> Database = new ConcurrentDictionary<string, TorrentDetails>();

        FileDB(string key, bool empty = false)
        {
            fdbkey = key;
            string fdbpath = pathDb(key);
             
            if (!empty && File.Exists(fdbpath))
                Database = JsonStream.Read<ConcurrentDictionary<string, TorrentDetails>>(fdbpath) ?? new ConcurrentDictionary<string, TorrentDetails>();
        }
        

        public void Dispose()
        {
            if (Database.Count > 0)
                JsonStream.Write(pathDb(fdbkey), Database);

            if (openWriteTask.TryGetValue(fdbkey, out WriteTaskModel val))
            {
                val.openconnection -= 1;
                if (0 >= val.openconnection)
                {
                    if (!ModInit.conf.Red.evercache.enable || (ModInit.conf.Red.evercache.enable && ModInit.conf.Red.evercache.validHour > 0))
                        openWriteTask.TryRemove(fdbkey, out _);
                }
            }
        }
    }
}

```

## File: Lampac/Startup.cs
```
using Lampac.Engine;
using Lampac.Engine.Middlewares;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.HttpOverrides;
using Microsoft.AspNetCore.Mvc.ApplicationParts;
using Microsoft.AspNetCore.Mvc.Infrastructure;
using Microsoft.AspNetCore.ResponseCompression;
using Microsoft.AspNetCore.StaticFiles;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.DependencyModel;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Http;
using Newtonsoft.Json;
using Shared;
using Shared.Engine;
using Shared.Models.Module;
using Shared.Models.Module.Entrys;
using Shared.PlaywrightCore;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Reflection;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac
{
    public class Startup
    {
        #region Startup
        static IApplicationBuilder _app = null;

        public static bool IsShutdown { get; private set; }

        public IConfiguration Configuration { get; }

        public static IServiceCollection serviceCollection { get; private set; }

        public static IMemoryCache memoryCache { get; private set; }

        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }
        #endregion

        #region ConfigureServices
        public void ConfigureServices(IServiceCollection services)
        {
            serviceCollection = services;

            #region IHttpClientFactory
            services.AddHttpClient("proxy").ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = false,
                AutomaticDecompression = DecompressionMethods.None,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                UseCookies = false
            });

            services.AddHttpClient("proxyimg").ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = true,
                AutomaticDecompression = DecompressionMethods.None,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                UseCookies = false
            });

            services.AddHttpClient("base").ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = true,
                AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                UseCookies = false
            });

            services.AddHttpClient("baseNoRedirect").ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = false,
                AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                UseCookies = false
            });

            services.AddHttpClient("http2", client =>
            {
                client.DefaultRequestVersion = HttpVersion.Version20;
                client.DefaultVersionPolicy = HttpVersionPolicy.RequestVersionOrLower;
            })
            .ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = true,
                AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                EnableMultipleHttp2Connections = true,
                UseCookies = false
            });

            services.AddHttpClient("http2proxyimg", client =>
            {
                client.DefaultRequestVersion = HttpVersion.Version20;
                client.DefaultVersionPolicy = HttpVersionPolicy.RequestVersionOrLower;
            })
            .ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = true,
                AutomaticDecompression = DecompressionMethods.None,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                EnableMultipleHttp2Connections = true,
                UseCookies = false
            });

            services.AddHttpClient("http2NoRedirect", client =>
            {
                client.DefaultRequestVersion = HttpVersion.Version20;
                client.DefaultVersionPolicy = HttpVersionPolicy.RequestVersionOrLower;
            })
            .ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = false,
                AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                EnableMultipleHttp2Connections = true,
                UseCookies = false
            });

            services.AddHttpClient("http3", client =>
            {
                client.DefaultRequestVersion = HttpVersion.Version30;
                client.DefaultVersionPolicy = HttpVersionPolicy.RequestVersionOrLower;
            })
            .ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
            {
                AllowAutoRedirect = true,
                AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate,
                SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
                PooledConnectionLifetime = TimeSpan.FromMinutes(30),
                EnableMultipleHttp2Connections = true,
                UseCookies = false
            });

            services.RemoveAll<IHttpMessageHandlerBuilderFilter>();
            #endregion

            services.Configure<CookiePolicyOptions>(options =>
            {
                options.CheckConsentNeeded = context => true;
                options.MinimumSameSitePolicy = SameSiteMode.None;
            });

            if (AppInit.conf.listen.compression)
            {
                services.AddResponseCompression(options =>
                {
                    options.MimeTypes = ResponseCompressionDefaults.MimeTypes.Concat(["image/svg+xml"]);
                });
            }

            services.AddSignalR(o =>
            {
                o.EnableDetailedErrors = true;
                o.MaximumParallelInvocationsPerClient = 2;
                o.MaximumReceiveMessageSize = 1024 * 1024 * 10; // 10MB
                o.StreamBufferCapacity = 1024 * 1024;           // 1MB
            });

            services.AddSingleton<IActionDescriptorChangeProvider>(DynamicActionDescriptorChangeProvider.Instance);
            services.AddSingleton(DynamicActionDescriptorChangeProvider.Instance);

            IMvcBuilder mvcBuilder = services.AddControllersWithViews();

            mvcBuilder.AddJsonOptions(options => {
                //options.JsonSerializerOptions.IgnoreNullValues = true;
                options.JsonSerializerOptions.DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault;
            });

            #region module/references
            string referencesPath = Path.Combine(Environment.CurrentDirectory, "module", "references");
            if (Directory.Exists(referencesPath))
            {
                var current = AppDomain.CurrentDomain.GetAssemblies();
                foreach (string dllFile in Directory.GetFiles(referencesPath, "*.dll", SearchOption.AllDirectories))
                {
                    try
                    {
                        string loadedName = Path.GetFileNameWithoutExtension(dllFile);
                        if (current.Any(a => string.Equals(a.GetName().Name, loadedName, StringComparison.OrdinalIgnoreCase)))
                            continue;

                        Assembly loadedAssembly = Assembly.LoadFrom(dllFile);
                        mvcBuilder.AddApplicationPart(loadedAssembly);
                        Console.WriteLine($"load reference: {Path.GetFileName(dllFile)}");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Failed to load reference {dllFile}: {ex.Message}");
                    }
                }
            }
            #endregion

            ModuleRepository.Configuration(mvcBuilder);

            #region compilation modules
            if (AppInit.modules != null)
            {
                // mod.dll
                foreach (var mod in AppInit.modules)
                {
                    try
                    {
                        Console.WriteLine("load module: " + mod.dll);
                        mvcBuilder.AddApplicationPart(mod.assembly);
                    }
                    catch (Exception ex) { Console.WriteLine(ex.Message + "\n"); }
                }
            }

            //  dll  source
            if (File.Exists("module/manifest.json"))
            {
                var jss = new JsonSerializerSettings
                {
                    Error = (se, ev) =>
                    {
                        ev.ErrorContext.Handled = true;
                        Console.WriteLine("module/manifest.json - " + ev.ErrorContext.Error + "\n\n");
                    }
                };

                var mods = JsonConvert.DeserializeObject<List<RootModule>>(File.ReadAllText("module/manifest.json"), jss);
                if (mods == null)
                    return;

                #region CompilationMod
                List<PortableExecutableReference> references = null;

                void CompilationMod(RootModule mod)
                {
                    if (!mod.enable || AppInit.modules.FirstOrDefault(i => i.dll == mod.dll) != null)
                        return;

                    if (mod.dll.EndsWith(".dll"))
                    {
                        try
                        {
                            mod.assembly = Assembly.LoadFrom(mod.dll);

                            AppInit.modules.Add(mod);
                            mvcBuilder.AddApplicationPart(mod.assembly);
                            Console.WriteLine($"load module: {Path.GetFileName(mod.dll)}");
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"Failed to load reference {mod.dll}: {ex.Message}");
                        }

                        return;
                    }

                    string path = Directory.Exists(mod.dll) ? mod.dll : $"{Environment.CurrentDirectory}/module/{mod.dll}";
                    if (Directory.Exists(path))
                    {
                        var syntaxTree = new List<SyntaxTree>();

                        foreach (string file in Directory.GetFiles(path, "*.cs", SearchOption.AllDirectories))
                        {
                            string _file = file.Replace("\\", "/").Replace(path.Replace("\\", "/"), "").Replace(Environment.CurrentDirectory.Replace("\\", "/"), "");
                            if (Regex.IsMatch(_file, "(\\.vs|bin|obj|Properties)/", RegexOptions.IgnoreCase))
                                continue;

                            syntaxTree.Add(CSharpSyntaxTree.ParseText(File.ReadAllText(file)));
                        }

                        if (references == null)
                        {
                            var dependencyContext = DependencyContext.Default;
                            var assemblies = dependencyContext.RuntimeLibraries
                                .SelectMany(library => library.GetDefaultAssemblyNames(dependencyContext))
                                .Select(Assembly.Load)
                                .ToList();

                            references = assemblies.Select(assembly => MetadataReference.CreateFromFile(assembly.Location)).ToList();
                        }

                        if (mod.references != null)
                        {
                            foreach (string refns in mod.references)
                            {
                                string dlrns = Path.Combine(Environment.CurrentDirectory, "module", "references", refns);
                                if (!File.Exists(dlrns))
                                    dlrns = Path.Combine(Environment.CurrentDirectory, "module", mod.dll, refns);

                                if (File.Exists(dlrns) && references.FirstOrDefault(a => Path.GetFileName(a.FilePath) == refns) == null)
                                {
                                    var assembly = Assembly.LoadFrom(dlrns);
                                    references.Add(MetadataReference.CreateFromFile(assembly.Location));
                                }
                            }
                        }

                        CSharpCompilation compilation = CSharpCompilation.Create(Path.GetFileName(mod.dll), syntaxTree, references: references, options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

                        using (var ms = new MemoryStream())
                        {
                            var result = compilation.Emit(ms);

                            if (!result.Success)
                            {
                                Console.WriteLine($"\ncompilation error: {mod.dll}");
                                foreach (var diagnostic in result.Diagnostics)
                                {
                                    if (diagnostic.Severity == DiagnosticSeverity.Error)
                                        Console.WriteLine(diagnostic);
                                }
                                Console.WriteLine();
                            }
                            else
                            {
                                ms.Seek(0, SeekOrigin.Begin);
                                mod.assembly = Assembly.Load(ms.ToArray());

                                Console.WriteLine("compilation module: " + mod.dll);
                                mod.index = mod.index != 0 ? mod.index : (100 + AppInit.modules.Count);
                                AppInit.modules.Add(mod);
                                mvcBuilder.AddApplicationPart(mod.assembly);
                                WatchersDynamicModule(null, mvcBuilder, mod, path);
                            }
                        }
                    }
                }
                #endregion

                foreach (var mod in mods)
                    CompilationMod(mod);

                foreach (string folderMod in Directory.GetDirectories("module/"))
                {
                    string manifest = $"{Environment.CurrentDirectory}/{folderMod}/manifest.json";
                    if (!File.Exists(manifest))
                        continue;

                    var mod = JsonConvert.DeserializeObject<RootModule>(File.ReadAllText(manifest), jss);
                    if (mod != null)
                    {
                        if (mod.dll == null)
                            mod.dll = folderMod.Split("/")[1];
                        else if (mod.dll.EndsWith(".dll"))
                            mod.dll = Path.Combine(folderMod, mod.dll);

                        CompilationMod(mod);
                    }
                }

                if (references != null)
                    CSharpEval.appReferences = references;
            }

            if (AppInit.modules != null)
                AppInit.modules = AppInit.modules.OrderBy(i => i.index).ToList();

            Console.WriteLine();
            #endregion
        }
        #endregion


        public void Configure(IApplicationBuilder app, IWebHostEnvironment env, IMemoryCache memory, IHttpClientFactory httpClientFactory, IHostApplicationLifetime applicationLifetime)
        {
            _app = app;
            memoryCache = memory;
            Shared.Startup.Configure(app, memory);
            HybridCache.Configure(memory);
            ProxyManager.Configure(memory);
            Http.httpClientFactory = httpClientFactory;

            #region modules loaded
            if (AppInit.modules != null)
            {
                foreach (var mod in AppInit.modules)
                {
                    try
                    {
                        if (mod.dll == "DLNA.dll")
                            mod.initspace = "DLNA.ModInit";

                        if (mod.dll == "SISI.dll")
                            mod.initspace = "SISI.ModInit";

                        if (mod.dll == "Tracks.dll" || mod.dll == "TorrServer.dll")
                            mod.version = 2;

                        LoadedModule(app, mod);
                    }
                    catch (Exception ex) { Console.WriteLine($"Module {mod.NamespacePath(mod.initspace)}: {ex.Message}\n\n"); }
                }
            }
            #endregion

            if (!AppInit.conf.multiaccess)
                app.UseDeveloperExceptionPage();

            applicationLifetime.ApplicationStopping.Register(OnShutdown);

            applicationLifetime.ApplicationStarted.Register(() =>
            {
                if (!string.IsNullOrEmpty(AppInit.conf.listen.sock))
                    _ = Bash.Run($"while [ ! -S /var/run/{AppInit.conf.listen.sock}.sock ]; do sleep 1; done && chmod 666 /var/run/{AppInit.conf.listen.sock}.sock").ConfigureAwait(false);
            });

            #region UseForwardedHeaders
            var forwarded = new ForwardedHeadersOptions
            {
                ForwardLimit = null,
                ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto
            };

            if (AppInit.conf.KnownProxies != null && AppInit.conf.KnownProxies.Count > 0)
            {
                foreach (var k in AppInit.conf.KnownProxies)
                    forwarded.KnownNetworks.Add(new Microsoft.AspNetCore.HttpOverrides.IPNetwork(IPAddress.Parse(k.ip), k.prefixLength));
            }

            app.UseForwardedHeaders(forwarded);
            #endregion

            app.UseWebSockets();
            app.UseRouting();

            if (AppInit.conf.listen.compression)
                app.UseResponseCompression();

            app.UseModHeaders();
            app.UseRequestStatistics();
            app.UseRequestInfo();
            app.UseAnonymousRequest();

            app.UseAlwaysRjson();
            app.UseModule(first: true);
            app.UseOverrideResponse(first: true);

            #region UseStaticFiles
            app.UseStaticFiles(new StaticFileOptions
            {
                ServeUnknownFileTypes = true,
                DefaultContentType = "application/octet-stream",
                ContentTypeProvider = new FileExtensionContentTypeProvider() 
                {
                    Mappings =
                    {
                        [".m4s"]  = "video/mp4",
                        [".ts"]   = "video/mp2t",
                        [".mp4"]  = "video/mp4",
                        [".mkv"]  = "video/x-matroska",
                        [".m3u"]  = "application/x-mpegURL",
                        [".m3u8"] = "application/vnd.apple.mpegurl",
                        [".webm"] = "video/webm",
                        [".mov"]  = "video/quicktime",
                        [".avi"]  = "video/x-msvideo",
                        [".wmv"]  = "video/x-ms-wmv",
                        [".flv"]  = "video/x-flv",
                        [".ogv"]  = "video/ogg",
                        [".m2ts"] = "video/MP2T",
                        [".vob"]  = "video/x-ms-vob",

                        [".apk"]  = "application/vnd.android.package-archive",
                        [".aab"]  = "application/vnd.android.appbundle",
                        [".xapk"]  = "application/vnd.android.package-archive",
                        [".apkm"]  = "application/vnd.android.package-archive",
                        [".obb"]  = "application/octet-stream",

                        [".exe"]  = "application/vnd.microsoft.portable-executable",
                        [".msi"]  = "application/x-msi",
                        [".bat"]  = "application/x-msdownload",
                        [".cmd"]  = "application/x-msdownload",
                        [".msix"]        = "application/msix",
                        [".msixbundle"]  = "application/msixbundle",
                        [".appx"]        = "application/appx",
                        [".appxbundle"]  = "application/appxbundle",

                        [".deb"]  = "application/vnd.debian.binary-package",
                        [".rpm"]  = "application/x-rpm",
                        [".sh"]   = "application/x-sh",
                        [".bin"]  = "application/octet-stream",
                        [".run"]  = "application/x-msdownload",
                        [".appimage"] = "application/octet-stream",

                        [".pkg"]  = "application/octet-stream",
                        [".dmg"]  = "application/x-apple-diskimage",

                        [".zip"] = "application/zip",
                        [".rar"] = "application/vnd.rar",
                        [".7z"]  = "application/x-7z-compressed",
                        [".gz"]  = "application/gzip",
                        [".tar"] = "application/x-tar",
                        [".tgz"] = "application/gzip",

                        [".iso"] = "application/x-iso9660-image"
                    }
                }
            });
            #endregion

            app.UseWAF();
            app.UseAccsdb();

            app.MapWhen(context => context.Request.Path.Value.StartsWith("/proxy/") || context.Request.Path.Value.StartsWith("/proxy-dash/"), proxyApp =>
            {
                proxyApp.UseProxyAPI();
            });

            app.MapWhen(context => context.Request.Path.Value.StartsWith("/proxyimg"), proxyApp =>
            {
                proxyApp.UseProxyIMG();
            });

            app.MapWhen(context => context.Request.Path.Value.StartsWith("/cub/"), proxyApp =>
            {
                proxyApp.UseProxyCub();
            });

            app.MapWhen(context => context.Request.Path.Value.StartsWith("/tmdb/"), proxyApp =>
            {
                proxyApp.UseProxyTmdb();
            });

            app.UseModule(first: false);
            app.UseOverrideResponse(first: false);

            app.Map("/nws", builder =>
            {
                builder.Run(nws.HandleWebSocketAsync);
            });

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapHub<soks>("/ws");
                endpoints.MapControllers();
            });
        }


        #region OnShutdown
        void OnShutdown()
        {
            if (Program._reload)
                return;

            IsShutdown = true;
            Shared.Startup.IsShutdown = true;

            Chromium.FullDispose();
            Firefox.FullDispose();
            nws.FullDispose();
            soks.FullDispose();

            DisposeModule(null);
        }
        #endregion

        #region WatchRebuildModule
        static readonly Dictionary<string, FileSystemWatcher> moduleWatchers = new();

        static readonly object moduleWatcherLock = new object();

        void WatchersDynamicModule(IApplicationBuilder app, IMvcBuilder mvcBuilder, RootModule mod, string path)
        {
            if (!mod.dynamic)
                return;

            path = Path.GetFullPath(path);

            lock (moduleWatcherLock)
            {
                if (moduleWatchers.ContainsKey(path))
                    return;

                var watcher = new FileSystemWatcher(path)
                {
                    IncludeSubdirectories = true,
                    NotifyFilter = NotifyFilters.FileName | NotifyFilters.LastWrite | NotifyFilters.Size
                };

                watcher.Filters.Add("*.cs");
                watcher.Filters.Add("manifest.json");

                CancellationTokenSource debounceCts = null;
                object debounceLock = new object();

                void Recompile(object sender, FileSystemEventArgs e)
                {
                    string _file = e.FullPath.Replace("\\", "/").Replace(path.Replace("\\", "/"), "").Replace(Environment.CurrentDirectory.Replace("\\", "/"), "");
                    if (Regex.IsMatch(_file, "(\\.vs|bin|obj|Properties)/", RegexOptions.IgnoreCase))
                        return;

                    CancellationTokenSource cts;

                    lock (debounceLock)
                    {
                        debounceCts?.Cancel();
                        debounceCts = new CancellationTokenSource();
                        cts = debounceCts;
                    }

                    _ = Task.Run(async () =>
                    {
                        await Task.Delay(TimeSpan.FromSeconds(2), cts.Token);

                        if (cts.IsCancellationRequested)
                            return;

                        watcher.EnableRaisingEvents = false;

                        try
                        {
                            var parts = mvcBuilder.PartManager.ApplicationParts
                                .OfType<AssemblyPart>()
                                .Where(p => p.Assembly == mod.assembly)
                                .ToList();

                            #region update manifest.json
                            string manifestPath = Path.Combine(path, "manifest.json");
                            RootModule manifestMod = null;

                            if (File.Exists(manifestPath))
                            {
                                try
                                {
                                    manifestMod = JsonConvert.DeserializeObject<RootModule>(File.ReadAllText(manifestPath));

                                    var excludedProperties = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
                                    {
                                        nameof(RootModule.dynamic),
                                        nameof(RootModule.index),
                                        nameof(RootModule.dll),
                                        nameof(RootModule.assembly),
                                        nameof(RootModule.initspace)
                                    };

                                    foreach (var property in typeof(RootModule).GetProperties(BindingFlags.Public | BindingFlags.Instance))
                                    {
                                        if (!property.CanRead || !property.CanWrite || excludedProperties.Contains(property.Name))
                                            continue;

                                        property.SetValue(mod, property.GetValue(manifestMod));
                                    }
                                }
                                catch (Exception manifestEx)
                                {
                                    Console.WriteLine($"Failed to update manifest for {mod.dll}: {manifestEx.Message}");
                                }
                            }
                            #endregion

                            var assembly = CSharpEval.Compilation(mod);
                            if (assembly != null)
                            {
                                DisposeModule(mod);

                                foreach (var part in parts)
                                    mvcBuilder.PartManager.ApplicationParts.Remove(part);

                                if (manifestMod != null)
                                    mod.initspace = manifestMod.initspace;

                                mod.assembly = assembly;
                                LoadedModule(app, mod);

                                mvcBuilder.PartManager.ApplicationParts.Add(new AssemblyPart(mod.assembly));
                                DynamicActionDescriptorChangeProvider.Instance.NotifyChanges();

                                MiddlewaresModuleEntry.EnsureCache(forced: true);
                                OnlineModuleEntry.EnsureCache(forced: true);
                                SisiModuleEntry.EnsureCache(forced: true);

                                Console.WriteLine("rebuild module: " + mod.dll);
                            }
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"Failed to rebuild module {mod.dll}: {ex.Message}");
                        }
                        finally
                        {
                            watcher.EnableRaisingEvents = true;
                        }
                    });
                }

                watcher.Changed += Recompile;
                watcher.Created += Recompile;
                watcher.Deleted += Recompile;
                watcher.Renamed += Recompile;

                watcher.EnableRaisingEvents = true;
                moduleWatchers[path] = watcher;
            }
        }
        #endregion

        #region LoadedModule
        void LoadedModule(IApplicationBuilder app, RootModule mod)
        {
            if (mod == null)
                return;

            if (mod.initspace != null && mod.assembly.GetType(mod.NamespacePath(mod.initspace)) is Type t && t.GetMethod("loaded") is MethodInfo m)
            {
                if (mod.version >= 2)
                {
                    m.Invoke(null, [
                        new InitspaceModel()
                        {
                            path = $"module/{mod.dll}",
                            soks = new soks(),
                            nws = new nws(),
                            memoryCache = memoryCache,
                            configuration = Configuration,
                            services = serviceCollection,
                            app = app ?? _app
                        }
                    ]);
                }
                else
                    m.Invoke(null, []);
            }
        }
        #endregion

        #region DisposeModule
        void DisposeModule(RootModule module)
        {
            if (AppInit.modules == null)
                return;

            if (module != null)
            {
                try
                {
                    if (module.initspace != null && module.assembly.GetType(module.NamespacePath(module.initspace)) is Type t && t.GetMethod("Dispose") is MethodInfo m)
                        m.Invoke(null, []);
                }
                catch { }
            }
            else
            {
                foreach (var mod in AppInit.modules)
                {
                    try
                    {
                        if (mod.initspace != null && mod.assembly.GetType(mod.NamespacePath(mod.initspace)) is Type t && t.GetMethod("Dispose") is MethodInfo m)
                            m.Invoke(null, []);
                    }
                    catch { }
                }
            }
        }
        #endregion
    }
}

```

## File: Lampac/Program.cs
```
using Lampac.Engine;
using Lampac.Engine.CRON;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.SignalR;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Hosting;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Models.Base;
using Shared.Models.SISI.Base;
using Shared.Models.SQL;
using Shared.PlaywrightCore;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Runtime.Loader;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace Lampac
{
    public class Program
    {
        #region static
        public static bool _reload = true;

        static IHost _host;

        public static List<(IPAddress prefix, int prefixLength)> cloudflare_ips = new List<(IPAddress prefix, int prefixLength)>();

        static Timer _usersTimer, _kitTimer;
        #endregion

        #region Main
        public static void Main(string[] args)
        {
            var assemblies = AppDomain.CurrentDomain.GetAssemblies();

            bool IsAssemblyLoaded(AssemblyName assemblyName)
            {
                foreach (var assembly in assemblies)
                {
                    if (assembly.GetName().Name == assemblyName.Name)
                        return true;
                }

                return false;
            }

            foreach (string dllPath in Directory.GetFiles(Path.Combine(AppContext.BaseDirectory, "runtimes", "references"), "*.dll"))
            {
                try
                {
                    AssemblyName assemblyName = AssemblyName.GetAssemblyName(dllPath);
                    if (!IsAssemblyLoaded(assemblyName))
                        Assembly.LoadFrom(dllPath);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Failed to load {dllPath}: {ex.Message}");
                }
            }


            AssemblyLoadContext.Default.Resolving += (context, assemblyName) =>
            {
                foreach (string name in new string[] { $"ru/{assemblyName.Name}", assemblyName.Name })
                {
                    string assemblyPath = Path.Combine(AppContext.BaseDirectory, "runtimes", "references", name);
                    if (File.Exists(assemblyPath))
                        return context.LoadFromAssemblyPath(assemblyPath);
                }

                return null;
            };

            Run(args);
        }
        #endregion

        #region Run
        static void Run(string[] args)
        {
            CultureInfo.CurrentCulture = new CultureInfo("ru-RU");
            Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);

            #region GC
            var gc = AppInit.conf.GC;
            if (gc != null && gc.enable && (gc.aggressive || AppInit.conf.multiaccess == false))
            {
                if (gc.Concurrent.HasValue)
                    AppContext.SetSwitch("System.GC.Concurrent", gc.Concurrent.Value);

                if (gc.ConserveMemory.HasValue)
                    AppContext.SetData("System.GC.ConserveMemory", gc.ConserveMemory.Value);

                if (gc.HighMemoryPercent.HasValue)
                    AppContext.SetData("System.GC.HighMemoryPercent", gc.HighMemoryPercent.Value);

                if (gc.RetainVM.HasValue)
                    AppContext.SetSwitch("System.GC.RetainVM", gc.RetainVM.Value);
            }
            #endregion

            Http.onlog += (e, log) =>
            {
                nws.SendLog(log, "http");
                soks.SendLog(log, "http");
            };

            RchClient.hub += (e, req) =>
            {
                _ = nws.SendRchRequestAsync(req.connectionId, req.rchId, req.url, req.data, req.headers, req.returnHeaders).ConfigureAwait(false);
                _ = soks.hubClients?.Client(req.connectionId)?.SendAsync("RchClient", req.rchId, req.url, req.data, req.headers, req.returnHeaders)?.ConfigureAwait(false);
            };

            string init = JsonConvert.SerializeObject(AppInit.conf, Formatting.Indented, new JsonSerializerSettings()
            {
                NullValueHandling = NullValueHandling.Ignore
            });

            Console.WriteLine(init + "\n");
            File.WriteAllText("current.conf", JsonConvert.SerializeObject(AppInit.conf, Formatting.Indented));

            ThreadPool.GetMinThreads(out int workerThreads, out int completionPortThreads);
            ThreadPool.SetMinThreads(Math.Max(4096, workerThreads), Math.Max(1024, completionPortThreads));

            #region passwd
            if (!File.Exists("passwd"))
            {
                AppInit.rootPasswd = Guid.NewGuid().ToString();
                File.WriteAllText("passwd", AppInit.rootPasswd);
            }
            else
            {
                AppInit.rootPasswd = File.ReadAllText("passwd");
                AppInit.rootPasswd = Regex.Replace(AppInit.rootPasswd, "[\n\r\t ]+", "").Trim();
            }
            #endregion

            #region vers.txt
            if (!File.Exists("data/vers.txt"))
                File.WriteAllText("data/vers.txt", BaseController.appversion);

            if (!File.Exists("data/vers-minor.txt"))
                File.WriteAllText("data/vers-minor.txt", "1");
            #endregion

            #region SQL
            ExternalidsContext.Initialization();
            HybridCacheContext.Initialization();
            SisiContext.Initialization();
            ProxyLinkContext.Initialization();
            PlaywrightContext.Initialization();
            SyncUserContext.Initialization();
            #endregion

            #region migration
            if (Directory.Exists("cache/storage") || Directory.Exists("cache/bookmarks/sisi"))
            {
                Console.WriteLine("run migration");

                #region cache/storage
                if (Directory.Exists("cache/storage"))
                {
                    string sourceDir = "cache/storage";
                    string targetDir = "database/storage";

                    void CopyAll(string source, string target)
                    {
                        Directory.CreateDirectory(target);

                        foreach (string file in Directory.GetFiles(source))
                        {
                            string destFile = Path.Combine(target, Path.GetFileName(file));
                            File.Copy(file, destFile, true);
                        }

                        foreach (string dir in Directory.GetDirectories(source))
                        {
                            string destDir = Path.Combine(target, Path.GetFileName(dir));
                            CopyAll(dir, destDir);
                        }
                    }

                    CopyAll(sourceDir, targetDir);

                    Directory.Move("cache/storage", "cache/storage.bak");
                }
                #endregion

                #region cache/bookmarks/sisi
                if (Directory.Exists("cache/bookmarks/sisi"))
                {
                    using (var sqlDb = new SisiContext())
                    {
                        var existing = new HashSet<string>(
                            sqlDb.bookmarks
                                 .AsNoTracking()
                                 .Select(i => $"{i.user}:{i.uid}")
                        );

                        foreach (string folder in Directory.GetDirectories("cache/bookmarks/sisi"))
                        {
                            string folderName = Path.GetFileName(folder);

                            foreach (string file in Directory.GetFiles(folder))
                            {
                                try
                                {
                                    string md5user = folderName + Path.GetFileName(file);
                                    var bookmarks = JsonConvert.DeserializeObject<List<PlaylistItem>>(File.ReadAllText(file));

                                    if (bookmarks == null || bookmarks.Count == 0)
                                        continue;

                                    DateTime now = DateTime.UtcNow;

                                    for (int i = 0; i < bookmarks.Count; i++)
                                    {
                                        var pl = bookmarks[i];

                                        if (pl?.bookmark == null || string.IsNullOrEmpty(pl.bookmark.uid))
                                            continue;

                                        if (!existing.Add($"{md5user}:{pl.bookmark.uid}"))
                                            continue;

                                        sqlDb.bookmarks.Add(new SisiBookmarkSqlModel
                                        {
                                            user = md5user,
                                            uid = pl.bookmark.uid,
                                            created = now.AddSeconds(-i),
                                            json = JsonConvert.SerializeObject(pl),
                                            name = pl.name,
                                            model = pl.model?.name
                                        });
                                    }
                                }
                                catch { }
                            }
                        }

                        sqlDb.SaveChanges();
                    }

                    Directory.Move("cache/bookmarks/sisi", "cache/bookmarks/sisi.bak");
                }
                #endregion
            }
            #endregion

            #region Playwright
            if (AppInit.conf.chromium.enable || AppInit.conf.firefox.enable)
            {
                if (!AppInit.conf.multiaccess)
                    Environment.SetEnvironmentVariable("NODE_OPTIONS", "--max-old-space-size=256");

                ThreadPool.QueueUserWorkItem(async _ =>
                {
                    if (await PlaywrightBase.InitializationAsync())
                    {
                        if (AppInit.conf.chromium.enable)
                            _ = Chromium.CreateAsync().ConfigureAwait(false);

                        if (AppInit.conf.firefox.enable)
                            _ = Firefox.CreateAsync().ConfigureAwait(false);
                    }
                });

                Chromium.CronStart();
                Firefox.CronStart();
            }
            #endregion

            #region cloudflare_ips
            ThreadPool.QueueUserWorkItem(async _ => 
            {
                string ips = await Http.Get("https://www.cloudflare.com/ips-v4");
                if (ips == null || !ips.Contains("173.245."))
                    ips = File.Exists("data/cloudflare/ips-v4.txt") ? File.ReadAllText("data/cloudflare/ips-v4.txt") : null;

                if (ips != null)
                {
                    string ips_v6 = await Http.Get("https://www.cloudflare.com/ips-v6");
                    if (ips_v6 == null || !ips_v6.Contains("2400:cb00"))
                        ips_v6 = File.Exists("data/cloudflare/ips-v6.txt") ? File.ReadAllText("data/cloudflare/ips-v6.txt") : null;

                    if (ips_v6 != null)
                    {
                        foreach (string ip in (ips + "\n" + ips_v6).Split('\n'))
                        {
                            if (string.IsNullOrEmpty(ip) || !ip.Contains("/"))
                                continue;

                            try
                            {
                                string[] ln = ip.Split('/');
                                cloudflare_ips.Add((IPAddress.Parse(ln[0].Trim()), int.Parse(ln[1].Trim())));
                            }
                            catch { }
                        }
                    }
                }

                Console.WriteLine($"cloudflare_ips: {cloudflare_ips.Count}");
            });
            #endregion

            #region fix update.sh
            if (File.Exists("update.sh"))
            {
                var olds = new string[] 
                {
                    "02a7e97392e63b7e9e35a39ce475d6f8",
                    "6354eab8b101af90cb247fc8c977dd6b",
                    "b94b42ff158682661761a0b50a808a3b",
                    "97b0d657786b14e6a2faf7186de0556c",
                    "6b60a4d2173e99b11ecf4e792a24f598",
                    "cae6f0e79bbb2e6832922f25614d83a1",
                    "97b0d657786b14e6a2faf7186de0556c",
                    "cae6f0e79bbb2e6832922f25614d83a1",
                    "587794ca93c8d0318332858cf0e71e98",
                    "174ac2b94c5aa0e5ac086f843fd086a6",
                    "9c258d50e9eb06316efdf33de8b66dc3",
                    "bb4d6f2ba74b6a25dc3e4638c7f5282a",
                    "9607ae5805eaf5d06220298581a99beb",
                    "30078b973188c696273e10d6ef0ebbb2",
                    "92f5e2e03d2cc2697f2ee00becdb4696",
                    "b565c7e163485b8f8cc258b95f2891b6",
                    "ec6659f1f91f1f6ec0c734ff2111c7d7"
                };

                try
                {
                    if (olds.Contains(CrypTo.md5(File.ReadAllText("update.sh"))))
                    {
                        ThreadPool.QueueUserWorkItem(async _ => 
                        {
                            string new_update = await Http.Get("https://raw.githubusercontent.com/immisterio/Lampac/refs/heads/main/update.sh");
                            if (new_update != null && new_update.Contains("DEST=\"/home/lampac\""))
                                File.WriteAllText("update.sh", new_update);
                        });
                    }
                }
                catch { }
            }
            #endregion

            CacheCron.Run();
            KurwaCron.Run();
            PluginsCron.Run();
            SyncCron.Run();
            TrackersCron.Run();
            LampaCron.Run();

            _usersTimer = new Timer(UpdateUsersDb, null, TimeSpan.Zero, TimeSpan.FromSeconds(1));
            _kitTimer = new Timer(UpdateKitDb, null, TimeSpan.Zero, TimeSpan.FromSeconds(Math.Max(5, AppInit.conf.kit.cacheToSeconds)));

            while (_reload)
            {
                _host = CreateHostBuilder(args).Build();
                _reload = false;
                _host.Run();
            }
        }
        #endregion


        #region Reload
        public static void Reload()
        {
            _reload = true;
            _host.StopAsync();

            AppInit.LoadModules();
        }
        #endregion

        #region CreateHostBuilder
        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseKestrel(op =>
                    {
                        op.AddServerHeader = false;

                        if (AppInit.conf.listen.keepalive.HasValue && AppInit.conf.listen.keepalive.Value > 0)
                            op.Limits.KeepAliveTimeout = TimeSpan.FromSeconds(AppInit.conf.listen.keepalive.Value);

                        op.ConfigureEndpointDefaults(endpointOptions =>
                        {
                            if (AppInit.conf.listen.endpointDefaultsProtocols.HasValue)
                                endpointOptions.Protocols = AppInit.conf.listen.endpointDefaultsProtocols.Value;
                        });

                        if (string.IsNullOrEmpty(AppInit.conf.listen.sock) && string.IsNullOrEmpty(AppInit.conf.listen.ip))
                        {
                            op.Listen(IPAddress.Parse("127.0.0.1"), 9118);
                        }
                        else
                        {
                            if (!string.IsNullOrEmpty(AppInit.conf.listen.sock))
                            {
                                if (File.Exists($"/var/run/{AppInit.conf.listen.sock}.sock"))
                                    File.Delete($"/var/run/{AppInit.conf.listen.sock}.sock");

                                op.ListenUnixSocket($"/var/run/{AppInit.conf.listen.sock}.sock");
                            }

                            if (!string.IsNullOrEmpty(AppInit.conf.listen.ip))
                                op.Listen(AppInit.conf.listen.ip == "any" ? IPAddress.Any : AppInit.conf.listen.ip == "broadcast" ? IPAddress.Broadcast : IPAddress.Parse(AppInit.conf.listen.ip), AppInit.conf.listen.port);
                        }
                    })
                    .UseStartup<Startup>();
                });
        #endregion


        #region UpdateUsersDb
        static bool _updateUsersDb = false;
        static string _usersKeyUpdate = string.Empty;

        static void UpdateUsersDb(object state)
        {
            if (_updateUsersDb)
                return;

            try
            {
                _updateUsersDb = true;

                if (File.Exists("users.json"))
                {
                    var lastWriteTime = File.GetLastWriteTime("users.json");

                    string keyUpdate = $"{AppInit.conf?.guid}:{AppInit.conf?.accsdb?.users?.Count ?? 0}:{lastWriteTime}";
                    if (keyUpdate == _usersKeyUpdate)
                        return;

                    foreach (var user in JsonConvert.DeserializeObject<List<AccsUser>>(File.ReadAllText("users.json")))
                    {
                        try
                        {
                            var find = AppInit.conf.accsdb.findUser(user.id ?? user.ids?.First());
                            if (find != null)
                            {
                                find.id = user.id;
                                find.ids = user.ids;
                                find.group = user.group;
                                find.IsPasswd = user.IsPasswd;
                                find.expires = user.expires;
                                find.ban = user.ban;
                                find.ban_msg = user.ban_msg;
                                find.comment = user.comment;
                                find.@params = user.@params;
                            }
                            else
                            {
                                AppInit.conf.accsdb.users.Add(user);
                            }
                        }
                        catch { }
                    }

                    _usersKeyUpdate = keyUpdate;
                }
            }
            catch { }
            finally
            {
                _updateUsersDb = false;
            }
        }
        #endregion

        #region UpdateKitDb
        static bool _updateKitDb = false;

        async static void UpdateKitDb(object state)
        {
            if (_updateKitDb)
                return;

            try
            {
                _updateKitDb = true;

                if (AppInit.conf.kit.enable && AppInit.conf.kit.IsAllUsersPath && !string.IsNullOrEmpty(AppInit.conf.kit.path))
                {
                    var users = await Http.Get<Dictionary<string, JObject>>(AppInit.conf.kit.path);
                    if (users != null)
                        AppInit.conf.kit.allUsers = users;
                }
            }
            catch { }
            finally
            {
                _updateKitDb = false;
            }
        }
        #endregion
    }
}

```

## File: Lampac/Controllers/ApiController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.CodeAnalysis.Scripting;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Models.CSharpGlobals;
using Shared.Models.Events;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO.Compression;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Web;
using IO = System.IO;

namespace Lampac.Controllers
{
    public class ApiController : BaseController
    {
        #region Index
        [AllowAnonymous]
        [Route("/")]
        public ActionResult Index()
        {
            if (string.IsNullOrWhiteSpace(AppInit.conf.LampaWeb.index))
                return Content("api work", contentType: "text/plain; charset=utf-8");

            if (AppInit.conf.LampaWeb.basetag && Regex.IsMatch(AppInit.conf.LampaWeb.index, "/[^\\./]+\\.html$"))
            {
                if (!memoryCache.TryGetValue($"LampaWeb.index:{AppInit.conf.LampaWeb.index}", out string html))
                {
                    html = IO.File.ReadAllText($"wwwroot/{AppInit.conf.LampaWeb.index}");
                    html = html.Replace("<head>", $"<head><base href=\"/{Regex.Match(AppInit.conf.LampaWeb.index, "^([^/]+)/").Groups[1].Value}/\" />");

                    memoryCache.Set($"LampaWeb.index:{AppInit.conf.LampaWeb.index}", html, DateTime.Now.AddMinutes(1));
                }

                return Content(html, contentType: "text/html; charset=utf-8");
            }

            return LocalRedirect($"/{AppInit.conf.LampaWeb.index}");
        }
        #endregion

        #region Extensions
        [AllowAnonymous]
        [Route("/extensions")]
        public ActionResult Extensions()
        {
            return ContentTo(FileCache.ReadAllText("plugins/extensions.json").Replace("{localhost}", host).Replace("\n", "").Replace("\r", ""));
        }
        #endregion

        #region Version / Headers / geo / myip / reqinfo / personal.lampa
        [AllowAnonymous]
        [Route("/version")]
        public ActionResult Version() => Content($"{appversion}.{minorversion}");

        [AllowAnonymous]
        [Route("/ping")]
        public ActionResult PingPong() => Content("pong");

        [AllowAnonymous]
        [Route("/headers")]
        public ActionResult Headers() => Json(HttpContext.Request.Headers);

        [AllowAnonymous]
        [Route("/geo")]
        public ActionResult Geo(string select, string ip)
        {
            if (select == "ip")
                return Content(ip ?? requestInfo.IP);

            string country = requestInfo.Country;
            if (ip != null)
                country = GeoIP2.Country(ip);

            if (select == "country")
                return Content(country);

            return Json(new
            { 
                ip = ip ?? requestInfo.IP,
                country
            });
        }

        [AllowAnonymous]
        [Route("/myip")]
        public ActionResult MyIP() => Content(requestInfo.IP);

        [Route("/reqinfo")]
        public ActionResult Reqinfo() => ContentTo(JsonConvert.SerializeObject(requestInfo, new JsonSerializerSettings()
        {
            NullValueHandling = NullValueHandling.Ignore,
            DefaultValueHandling = DefaultValueHandling.Ignore
        }));

        [AllowAnonymous]
        [Route("/personal.lampa")]
        [Route("/lampa-main/personal.lampa")]
        [Route("/{myfolder}/personal.lampa")]
        public ActionResult PersonalLampa(string myfolder) => StatusCode(200);
        #endregion

        #region testaccsdb
        [Route("/testaccsdb")]
        public ActionResult TestAccsdb(string account_email, string uid) 
        {
            if (!string.IsNullOrEmpty(AppInit.conf.accsdb.shared_passwd) && uid == AppInit.conf.accsdb.shared_passwd)
                return ContentTo("{\"accsdb\": true, \"newuid\": true}");

            if (!string.IsNullOrEmpty(uid) && !string.IsNullOrEmpty(account_email) && account_email == AppInit.conf.accsdb.shared_passwd)
            {
                try
                {
                    string file = "users.json";

                    JArray arr = new JArray();

                    if (IO.File.Exists(file))
                    {
                        var txt = IO.File.ReadAllText(file);
                        if (!string.IsNullOrWhiteSpace(txt))
                            try { arr = JArray.Parse(txt); } catch { arr = new JArray(); }
                    }

                    bool exists = arr.Children<JObject>().Any(o =>
                        (o.Value<string>("id") != null && o.Value<string>("id").Equals(uid, StringComparison.OrdinalIgnoreCase)) ||
                        (o["ids"] != null && o["ids"].Any(t => t.ToString().Equals(uid, StringComparison.OrdinalIgnoreCase)))
                    );

                    if (exists)
                        return ContentTo("{\"accsdb\": false}");

                    var obj = new JObject();
                    obj["id"] = uid;
                    obj["expires"] = DateTime.Now.AddDays(Math.Max(1, AppInit.conf.accsdb.shared_daytime));

                    arr.Add(obj);

                    IO.File.WriteAllText(file, arr.ToString(Formatting.Indented));

                    return ContentTo("{\"accsdb\": false, \"success\": true, \"uid\": \"" + uid + "\"}");
                }
                catch { return ContentTo("{\"accsdb\": true}"); }
            }

            return ContentTo("{\"accsdb\": false, \"success\": true}");
        }
        #endregion

        #region Sync
        [Route("/api/sync")]
        public ActionResult Sync()
        {
            var sync = AppInit.conf.sync;
            if (!requestInfo.IsLocalRequest || !sync.enable || sync.type != "master")
                return Content("error");

            if (sync.initconf == "current")
                return Content(JsonConvert.SerializeObject(AppInit.conf), "application/json; charset=utf-8");

            var init = new AppInit();

            string confile = "sync.conf";
            if (sync.override_conf != null && sync.override_conf.TryGetValue(requestInfo.IP, out string _conf))
                confile = _conf;

            if (IO.File.Exists(confile))
                init = JsonConvert.DeserializeObject<AppInit>(IO.File.ReadAllText(confile));

            init.accsdb.users = AppInit.conf.accsdb.users;

            string json = JsonConvert.SerializeObject(init);
            json = json.Replace("{server_ip}", requestInfo.IP);

            return Content(json, "application/json; charset=utf-8");
        }
        #endregion


        #region app.min.js
        [AllowAnonymous]
        [Route("/app.min.js")]
        [Route("{type}/app.min.js")]
        public ContentResult LampaApp(string type)
        {
            if (string.IsNullOrEmpty(type))
            {
                if (AppInit.conf.LampaWeb.path != null)
                {
                    type = AppInit.conf.LampaWeb.path;
                }
                else
                {
                    if (AppInit.conf.LampaWeb.index == null || !AppInit.conf.LampaWeb.index.Contains("/"))
                        return Content(string.Empty, "application/javascript; charset=utf-8");

                    type = AppInit.conf.LampaWeb.index.Split("/")[0];
                }
            }

            bool usecubproxy = AppInit.conf.cub.enabled(requestInfo.Country);
            var apr = AppInit.conf.LampaWeb.appReplace ?? InvkEvent.conf?.Controller?.AppReplace?.appjs?.regex;

            string memKey = $"ApiController:{type}:{host}:{usecubproxy}:{apr?.Count ?? 0}:app.min.js";
            if (!memoryCache.TryGetValue(memKey, out string file))
            {
                file = IO.File.ReadAllText($"wwwroot/{type}/app.min.js");

                #region appReplace
                if (apr != null)
                {
                    foreach (var r in apr)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        val = val.Replace("{localhost}", host).Replace("{host}", Regex.Replace(host, "^https?://", ""));
                        file = Regex.Replace(file, r.Key, val, RegexOptions.IgnoreCase);
                    }
                }

                if (InvkEvent.conf?.Controller?.AppReplace?.appjs?.list != null)
                {
                    foreach (var r in InvkEvent.conf.Controller.AppReplace.appjs.list)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        val = val.Replace("{localhost}", host).Replace("{host}", Regex.Replace(host, "^https?://", ""));
                        file = file.Replace(r.Key, val);
                    }
                }
                #endregion

                string playerinner = FileCache.ReadAllText("plugins/player-inner.js", saveCache: false)
                       .Replace("{useplayer}", (!string.IsNullOrEmpty(AppInit.conf.playerInner)).ToString().ToLower())
                       .Replace("{notUseTranscoding}", (AppInit.conf.transcoding.enable == false).ToString().ToLower());

                var bulder = new StringBuilder(file);

                bulder = bulder.Replace("Player.play(element);", playerinner);

                if (usecubproxy)
                {
                    bulder = bulder.Replace("protocol + mirror + '/api/checker'", $"'{host}/cub/api/checker'");
                    bulder = bulder.Replace("Utils$1.protocol() + 'tmdb.' + object$2.cub_domain + '/' + u,", $"'{host}/cub/tmdb./' + u,");
                    bulder = bulder.Replace("Utils$2.protocol() + 'tmdb.' + object$2.cub_domain + '/' + u,", $"'{host}/cub/tmdb./' + u,");
                    bulder = bulder.Replace("Utils$1.protocol() + object$2.cub_domain", $"'{host}/cub/red'");
                    bulder = bulder.Replace("Utils$2.protocol() + object$2.cub_domain", $"'{host}/cub/red'");
                    bulder = bulder.Replace("object$2.cub_domain", $"'{AppInit.conf.cub.mirror}'");
                }

                bulder = bulder.Replace("http://lite.lampa.mx", $"{host}/{type}");
                bulder = bulder.Replace("https://yumata.github.io/lampa-lite", $"{host}/{type}");

                bulder = bulder.Replace("http://lampa.mx", $"{host}/{type}");
                bulder = bulder.Replace("https://yumata.github.io/lampa", $"{host}/{type}");

                bulder = bulder.Replace("window.lampa_settings.dcma = dcma;", "window.lampa_settings.fixdcma = true;");
                bulder = bulder.Replace("Storage.get('vpn_checked_ready', 'false')", "true");

                bulder = bulder.Replace("status$1 = false;", "status$1 = true;"); // local apk to personal.lampa
                bulder = bulder.Replace("return status$1;", "return true;"); // –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∫–ª–∞–º—ã
                bulder = bulder.Replace("if (!Storage.get('metric_uid', ''))", "return;"); // metric
                bulder = bulder.Replace("function log(data) {", "function log(data) { return;");
                bulder = bulder.Replace("function stat$1(method, name) {", "function stat$1(method, name) { return;");
                bulder = bulder.Replace("if (domain) {", "if (false) {");

                bulder = bulder.Replace("{localhost}", host);

                file = bulder.ToString();

                if (AppInit.conf.mikrotik == false)
                    memoryCache.Set(memKey, file, DateTime.Now.AddMinutes(1));
            }

            if (InvkEvent.conf?.Controller?.AppReplace?.appjs?.eval != null)
                file = InvkEvent.AppReplace("appjs", new EventAppReplace(file, null, type, host, requestInfo, HttpContext.Request, hybridCache));

            return Content(file, "application/javascript; charset=utf-8");
        }
        #endregion

        #region app.css
        [AllowAnonymous]
        [Route("/css/app.css")]
        [Route("{type}/css/app.css")]
        public ContentResult LampaAppCss(string type)
        {
            if (string.IsNullOrEmpty(type))
            {
                if (AppInit.conf.LampaWeb.path != null)
                {
                    type = AppInit.conf.LampaWeb.path;
                }
                else
                {
                    if (AppInit.conf.LampaWeb.index == null || !AppInit.conf.LampaWeb.index.Contains("/"))
                        return Content(string.Empty, "application/javascript; charset=utf-8");

                    type = AppInit.conf.LampaWeb.index.Split("/")[0];
                }
            }

            var apr = AppInit.conf.LampaWeb.cssReplace ?? InvkEvent.conf?.Controller?.AppReplace?.appcss?.regex;

            string memKey = $"ApiController:css/app.css:{type}:{host}:{apr?.Count ?? 0}";
            if (!memoryCache.TryGetValue(memKey, out string css))
            {
                css = IO.File.ReadAllText($"wwwroot/{type}/css/app.css");

                #region appReplace
                if (apr != null)
                {
                    foreach (var r in apr)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        val = val.Replace("{localhost}", host).Replace("{host}", Regex.Replace(host, "^https?://", ""));
                        css = Regex.Replace(css, r.Key, val, RegexOptions.IgnoreCase);
                    }
                }

                if (InvkEvent.conf?.Controller?.AppReplace?.appcss?.list != null)
                {
                    foreach (var r in InvkEvent.conf.Controller.AppReplace.appcss.list)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        val = val.Replace("{localhost}", host).Replace("{host}", Regex.Replace(host, "^https?://", ""));
                        css = css.Replace(r.Key, val);
                    }
                }
                #endregion

                memoryCache.Set(memKey, css, DateTime.Now.AddMinutes(AppInit.conf.multiaccess ? 5 : 1));
            }

            if (InvkEvent.conf?.Controller?.AppReplace?.appcss?.eval != null)
                css = InvkEvent.AppReplace("appcss", new EventAppReplace(css, null, type, host, requestInfo, HttpContext.Request, hybridCache));

            return Content(css, "text/css; charset=utf-8");
        }
        #endregion


        #region samsung.wgt
        [HttpGet]
        [AllowAnonymous]
        [Route("samsung.wgt")]
        public ActionResult SamsWgt(string overwritehost)
        {
            string folder = "data/widgets";

            if (!IO.File.Exists($"{folder}/samsung/loader.js"))
                return Content(string.Empty);

            string wgt = $"{folder}/{CrypTo.md5(overwritehost ?? host + "v3")}.wgt";
            if (IO.File.Exists(wgt))
                return File(IO.File.OpenRead(wgt), "application/octet-stream");

            string index = IO.File.ReadAllText($"{folder}/samsung/index.html");
            IO.File.WriteAllText($"{folder}/samsung/publish/index.html", index.Replace("{localhost}", overwritehost ?? host));

            string loader = IO.File.ReadAllText($"{folder}/samsung/loader.js");
            IO.File.WriteAllText($"{folder}/samsung/publish/loader.js", loader.Replace("{localhost}", overwritehost ?? host));

            string app = IO.File.ReadAllText($"{folder}/samsung/app.js");
            IO.File.WriteAllText($"{folder}/samsung/publish/app.js", app.Replace("{localhost}", overwritehost ?? host));

            IO.File.Copy($"{folder}/samsung/icon.png", $"{folder}/samsung/publish/icon.png", overwrite: true);
            IO.File.Copy($"{folder}/samsung/logo_appname_fg.png", $"{folder}/samsung/publish/logo_appname_fg.png", overwrite: true);
            IO.File.Copy($"{folder}/samsung/config.xml", $"{folder}/samsung/publish/config.xml", overwrite: true);

            string gethash(string file)
            {
                using (SHA512 sha = SHA512.Create())
                {
                    return Convert.ToBase64String(sha.ComputeHash(IO.File.ReadAllBytes(file)));
                    //digestValue = hash.Remove(76) + "\n" + hash.Remove(0, 76);
                }
            }

            string indexhashsha512 = gethash($"{folder}/samsung/publish/index.html");
            string loaderhashsha512 = gethash($"{folder}/samsung/publish/loader.js");
            string apphashsha512 = gethash($"{folder}/samsung/publish/app.js");
            string confighashsha512 = gethash($"{folder}/samsung/publish/config.xml");
            string iconhashsha512 = gethash($"{folder}/samsung/publish/icon.png");
            string logohashsha512 = gethash($"{folder}/samsung/publish/logo_appname_fg.png");

            string author_sigxml = IO.File.ReadAllText($"{folder}/samsung/author-signature.xml");
            author_sigxml = author_sigxml.Replace("loaderhashsha512", loaderhashsha512).Replace("apphashsha512", apphashsha512)
                                         .Replace("iconhashsha512", iconhashsha512).Replace("logohashsha512", logohashsha512)
                                         .Replace("confighashsha512", confighashsha512)
                                         .Replace("indexhashsha512", indexhashsha512);
            IO.File.WriteAllText($"{folder}/samsung/publish/author-signature.xml", author_sigxml);

            string authorsignaturehashsha512 = gethash($"{folder}/samsung/publish/author-signature.xml");
            string sigxml1 = IO.File.ReadAllText($"{folder}/samsung/signature1.xml");
            sigxml1 = sigxml1.Replace("loaderhashsha512", loaderhashsha512).Replace("apphashsha512", apphashsha512)
                             .Replace("confighashsha512", confighashsha512).Replace("authorsignaturehashsha512", authorsignaturehashsha512)
                             .Replace("iconhashsha512", iconhashsha512).Replace("logohashsha512", logohashsha512).Replace("indexhashsha512", indexhashsha512);
            IO.File.WriteAllText($"{folder}/samsung/publish/signature1.xml", sigxml1);

            ZipFile.CreateFromDirectory($"{folder}/samsung/publish/", wgt);

            return File(IO.File.OpenRead(wgt), "application/octet-stream");
        }
        #endregion

        #region MSX
        [HttpGet]
        [AllowAnonymous]
        [Route("msx/start.json")]
        public ActionResult MSX()
        {
            return Content(FileCache.ReadAllText("msx.json").Replace("{localhost}", host), "application/json; charset=utf-8");
        }
        #endregion

        #region startpage.js
        [HttpGet]
        [AllowAnonymous]
        [Route("startpage.js")]
        public ActionResult StartPage()
        {
            return Content(FileCache.ReadAllText("plugins/startpage.js").Replace("{localhost}", host), "application/javascript; charset=utf-8");
        }
        #endregion

        #region lampainit.js
        [HttpGet]
        [AllowAnonymous]
        [Route("lampainit.js")]
        public ActionResult LamInit(bool lite)
        {
            string initiale = string.Empty;
            var sb = new StringBuilder(FileCache.ReadAllText($"plugins/{(lite ? "liteinit" : "lampainit")}.js"));

            if (AppInit.modules != null)
            {
                if (lite)
                {
                    if (AppInit.conf.LampaWeb.initPlugins.online && AppInit.modules.FirstOrDefault(i => i.dll == "Online.dll" && i.enable) != null)
                        initiale += "\"{localhost}/lite.js\",";

                    if (AppInit.conf.LampaWeb.initPlugins.sisi && AppInit.modules.FirstOrDefault(i => i.dll == "SISI.dll" && i.enable) != null)
                        initiale += "\"{localhost}/sisi.js?lite=true\",";

                    if (AppInit.conf.LampaWeb.initPlugins.sync)
                        initiale += "\"{localhost}/sync.js?lite=true\",";
                }
                else
                {
                    if (AppInit.conf.LampaWeb.initPlugins.dlna && AppInit.modules.FirstOrDefault(i => i.dll == "DLNA.dll" && i.enable) != null)
                        initiale += "{\"url\": \"{localhost}/dlna.js\",\"status\": 1,\"name\": \"DLNA\",\"author\": \"lampac\"},";

                    if (AppInit.modules.FirstOrDefault(i => i.dll == "Tracks.dll" && i.enable) != null)
                    {
                        if (AppInit.conf.LampaWeb.initPlugins.tracks)
                            initiale += "{\"url\": \"{localhost}/tracks.js\",\"status\": 1,\"name\": \"Tracks.js\",\"author\": \"lampac\"},";

                        if (AppInit.conf.LampaWeb.initPlugins.transcoding && AppInit.conf.transcoding.enable)
                            initiale += "{\"url\": \"{localhost}/transcoding.js\",\"status\": 1,\"name\": \"Transcoding video\",\"author\": \"lampac\"},";
                    }

                    if (AppInit.conf.LampaWeb.initPlugins.tmdbProxy)
                        initiale += "{\"url\": \"{localhost}/tmdbproxy.js\",\"status\": 1,\"name\": \"TMDB Proxy\",\"author\": \"lampac\"},";

                    if (AppInit.conf.LampaWeb.initPlugins.online && AppInit.modules.FirstOrDefault(i => i.dll == "Online.dll" && i.enable) != null)
                        initiale += "{\"url\": \"{localhost}/online.js\",\"status\": 1,\"name\": \"–û–Ω–ª–∞–π–Ω\",\"author\": \"lampac\"},";

                    if (AppInit.conf.LampaWeb.initPlugins.catalog && AppInit.modules.FirstOrDefault(i => i.dll == "Catalog.dll" && i.enable) != null)
                        initiale += "{\"url\": \"{localhost}/catalog.js\",\"status\": 1,\"name\": \"–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –∫–∞—Ç–∞–ª–æ–≥–∞\",\"author\": \"lampac\"},";

                    if (AppInit.conf.LampaWeb.initPlugins.sisi && AppInit.modules.FirstOrDefault(i => i.dll == "SISI.dll" && i.enable) != null)
                    {
                        initiale += "{\"url\": \"{localhost}/sisi.js\",\"status\": 1,\"name\": \"–ö–ª—É–±–Ω–∏—á–∫–∞\",\"author\": \"lampac\"},";
                        initiale += "{\"url\": \"{localhost}/startpage.js\",\"status\": 1,\"name\": \"–°—Ç–∞—Ä—Ç–æ–≤–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞\",\"author\": \"lampac\"},";
                    }

                    if (AppInit.conf.LampaWeb.initPlugins.sync)
                        initiale += "{\"url\": \"{localhost}/sync.js\",\"status\": 1,\"name\": \"–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è\",\"author\": \"lampac\"},";

                    if (AppInit.conf.LampaWeb.initPlugins.timecode)
                        initiale += "{\"url\": \"{localhost}/timecode.js\",\"status\": 1,\"name\": \"–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Ç–∞–π–º-–∫–æ–¥–æ–≤\",\"author\": \"lampac\"},";

                    if (AppInit.conf.LampaWeb.initPlugins.bookmark)
                        initiale += "{\"url\": \"{localhost}/bookmark.js\",\"status\": 1,\"name\": \"–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–∫–ª–∞–¥–æ–∫\",\"author\": \"lampac\"},";

                    if (AppInit.conf.LampaWeb.initPlugins.torrserver && AppInit.modules.FirstOrDefault(i => i.dll == "TorrServer.dll" && i.enable) != null)
                        initiale += "{\"url\": \"{localhost}/ts.js\",\"status\": 1,\"name\": \"TorrServer\",\"author\": \"lampac\"},";

                    if (AppInit.conf.LampaWeb.initPlugins.backup)
                        initiale += "{\"url\": \"{localhost}/backup.js\",\"status\": 1,\"name\": \"Backup\",\"author\": \"lampac\"},";

                    if (AppInit.conf.pirate_store)
                        sb = sb.Replace("{pirate_store}", FileCache.ReadAllText("plugins/pirate_store.js"));

                    if (AppInit.conf.accsdb.enable)
                        sb = sb.Replace("{deny}", FileCache.ReadAllText("plugins/deny.js").Replace("{cubMesage}", AppInit.conf.accsdb.authMesage));
                }
            }

            sb = sb.Replace("{lampainit-invc}", FileCache.ReadAllText("plugins/lampainit-invc.js"));
            sb = sb.Replace("{initiale}", Regex.Replace(initiale, ",$", ""));

            sb = sb.Replace("{country}", requestInfo.Country);
            sb = sb.Replace("{localhost}", host);
            sb = sb.Replace("{deny}", string.Empty);
            sb = sb.Replace("{pirate_store}", string.Empty);

            sb = sb.Replace("{ major: 0, minor: 0 }", $"{{major: {appversion}, minor: {minorversion}}}");

            if (AppInit.modules != null && AppInit.modules.FirstOrDefault(i => i.dll == "JacRed.dll" && i.enable) != null)
                sb = sb.Replace("{jachost}", Regex.Replace(host, "^https?://", ""));
            else
                sb = sb.Replace("{jachost}", "redapi.apn.monster");

            #region full_btn_priority_hash
            string online_version = Regex.Match(FileCache.ReadAllText("plugins/online.js"), "version: '([^']+)'").Groups[1].Value;

            string LampaUtilshash(string input)
            {
                if (!AppInit.conf.online.version)
                    input = input.Replace($"v{online_version}", "");

                string str = (input ?? string.Empty);
                int hash = 0;

                if (str.Length == 0) return hash.ToString();

                for (int i = 0; i < str.Length; i++)
                {
                    int _char = str[i];

                    hash = (hash << 5) - hash + _char;
                    hash = hash & hash; // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ 32-–±–∏—Ç–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ
                }

                return Math.Abs(hash).ToString();
            }

            string full_btn_priority_hash = LampaUtilshash($"<div class=\"full-start__button selector view--online lampac--button\" data-subtitle=\"{AppInit.conf.online.name} v{online_version}\">\n        <svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 392.697 392.697\" xml:space=\"preserve\">\n            <path d=\"M21.837,83.419l36.496,16.678L227.72,19.886c1.229-0.592,2.002-1.846,1.98-3.209c-0.021-1.365-0.834-2.592-2.082-3.145\n                L197.766,0.3c-0.903-0.4-1.933-0.4-2.837,0L21.873,77.036c-1.259,0.559-2.073,1.803-2.081,3.18\n                C19.784,81.593,20.584,82.847,21.837,83.419z\" fill=\"currentColor\"></path>\n            <path d=\"M185.689,177.261l-64.988-30.01v91.617c0,0.856-0.44,1.655-1.167,2.114c-0.406,0.257-0.869,0.386-1.333,0.386\n                c-0.368,0-0.736-0.082-1.079-0.244l-68.874-32.625c-0.869-0.416-1.421-1.293-1.421-2.256v-92.229L6.804,95.5\n                c-1.083-0.496-2.344-0.406-3.347,0.238c-1.002,0.645-1.608,1.754-1.608,2.944v208.744c0,1.371,0.799,2.615,2.045,3.185\n                l178.886,81.768c0.464,0.211,0.96,0.315,1.455,0.315c0.661,0,1.318-0.188,1.892-0.555c1.002-0.645,1.608-1.754,1.608-2.945\n                V180.445C187.735,179.076,186.936,177.831,185.689,177.261z\" fill=\"currentColor\"></path>\n            <path d=\"M389.24,95.74c-1.002-0.644-2.264-0.732-3.347-0.238l-178.876,81.76c-1.246,0.57-2.045,1.814-2.045,3.185v208.751\n                c0,1.191,0.606,2.302,1.608,2.945c0.572,0.367,1.23,0.555,1.892,0.555c0.495,0,0.991-0.104,1.455-0.315l178.876-81.768\n                c1.246-0.568,2.045-1.813,2.045-3.185V98.685C390.849,97.494,390.242,96.384,389.24,95.74z\" fill=\"currentColor\"></path>\n            <path d=\"M372.915,80.216c-0.009-1.377-0.823-2.621-2.082-3.18l-60.182-26.681c-0.938-0.418-2.013-0.399-2.938,0.045\n                l-173.755,82.992l60.933,29.117c0.462,0.211,0.958,0.316,1.455,0.316s0.993-0.105,1.455-0.316l173.066-79.092\n                C372.122,82.847,372.923,81.593,372.915,80.216z\" fill=\"currentColor\"></path>\n        </svg>\n\n        <span>–û–Ω–ª–∞–π–Ω</span>\n    </div>");

            sb = sb.Replace("{full_btn_priority_hash}", full_btn_priority_hash)
                   .Replace("{btn_priority_forced}", AppInit.conf.online.btn_priority_forced.ToString().ToLower());
            #endregion

            #region domain token
            if (!string.IsNullOrEmpty(AppInit.conf.accsdb.domainId_pattern))
            {
                string token = Regex.Match(HttpContext.Request.Host.Host, AppInit.conf.accsdb.domainId_pattern).Groups[1].Value;
                sb = sb.Replace("{token}", token);
            }
            else { sb = sb.Replace("{token}", string.Empty); }
            #endregion

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        #region on.js
        [HttpGet]
        [AllowAnonymous]
        [Route("on.js")]
        [Route("on/js/{token}")]
        [Route("on/h/{token}")]
        [Route("on/{token}")]
        public ActionResult LamOnInit(string token, bool adult = true)
        {
            if (adult && HttpContext.Request.Path.Value.StartsWith("/on/h/"))
                adult = false;

            var plugins = new List<string>(10);
            var sb = new StringBuilder(FileCache.ReadAllText("plugins/on.js"));

            if (AppInit.modules != null)
            {
                void send(string name, bool worktoken)
                {
                    if (worktoken && !string.IsNullOrEmpty(token))
                    {
                        plugins.Add($"\"{{localhost}}/{name}/js/{HttpUtility.UrlEncode(token)}\"");
                    }
                    else
                    {
                        plugins.Add($"\"{{localhost}}/{name}.js\"");
                    }
                }

                if (AppInit.conf.LampaWeb.initPlugins.dlna && AppInit.modules.FirstOrDefault(i => i.dll == "DLNA.dll" && i.enable) != null)
                    send("dlna", true);

                if (AppInit.modules.FirstOrDefault(i => i.dll == "Tracks.dll" && i.enable) != null)
                {
                    if (AppInit.conf.LampaWeb.initPlugins.tracks)
                        send("tracks", true);

                    if (AppInit.conf.LampaWeb.initPlugins.transcoding && AppInit.conf.transcoding.enable)
                        send("transcoding", true);
                }

                if (AppInit.conf.LampaWeb.initPlugins.tmdbProxy)
                    send("tmdbproxy", true);

                if (AppInit.conf.LampaWeb.initPlugins.online && AppInit.modules.FirstOrDefault(i => i.dll == "Online.dll" && i.enable) != null)
                    send("online", true);

                if (adult)
                {
                    if (AppInit.conf.LampaWeb.initPlugins.sisi && AppInit.modules.FirstOrDefault(i => i.dll == "SISI.dll" && i.enable) != null)
                    {
                        send("sisi", true);
                        send("startpage", false);
                    }
                }

                if (AppInit.conf.LampaWeb.initPlugins.sync)
                    send("sync", true);

                if (AppInit.conf.LampaWeb.initPlugins.timecode)
                    send("timecode", true);

                if (AppInit.conf.LampaWeb.initPlugins.bookmark)
                    send("bookmark", true);

                if (AppInit.conf.LampaWeb.initPlugins.torrserver && AppInit.modules.FirstOrDefault(i => i.dll == "TorrServer.dll" && i.enable) != null)
                    send("ts", true);

                if (AppInit.conf.LampaWeb.initPlugins.backup)
                    send("backup", true);
            }

            if (plugins.Count == 0)
                sb = sb.Replace("{plugins}", string.Empty);
            else
            {
                sb = sb.Replace("{plugins}", string.Join(",", plugins));
            }

            sb = sb.Replace("{country}", requestInfo.Country)
                   .Replace("{localhost}", host);

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        #region privateinit.js
        [HttpGet]
        [Route("privateinit.js")]
        public ActionResult PrivateInit()
        {
            var user = requestInfo.user;
            if (user == null || user.ban || DateTime.UtcNow > user.expires)
                return Content(string.Empty, "application/javascript; charset=utf-8");

            var sb = new StringBuilder(FileCache.ReadAllText("plugins/privateinit.js"));

            sb = sb.Replace("{country}", requestInfo.Country)
                   .Replace("{localhost}", host);

            if (AppInit.modules != null && AppInit.modules.FirstOrDefault(i => i.dll == "JacRed.dll" && i.enable) != null)
                sb = sb.Replace("{jachost}", Regex.Replace(host, "^https?://", ""));
            else
                sb = sb.Replace("{jachost}", "redapi.apn.monster");

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion


        #region backup.js
        [HttpGet]
        [AllowAnonymous]
        [Route("backup.js")]
        [Route("backup/js/{token}")]
        public ActionResult Backup(string token)
        {
            if (!AppInit.conf.storage.enable)
                return Content(string.Empty, "application/javascript; charset=utf-8");

            var sb = new StringBuilder(FileCache.ReadAllText("plugins/backup.js"));

            sb.Replace("{localhost}", host)
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        #region sync.js
        [HttpGet]
        [AllowAnonymous]
        [Route("sync.js")]
        [Route("sync/js/{token}")]
        public ActionResult SyncJS(string token, bool lite)
        {
            if (!AppInit.conf.storage.enable)
                return Content(string.Empty, "application/javascript; charset=utf-8");

            StringBuilder sb;

            if (lite || AppInit.conf.sync_user.version == 1)
            {
                sb = new StringBuilder(FileCache.ReadAllText($"plugins/{(lite ? "sync_lite" : "sync")}.js"));
            }
            else
            {
                sb = new StringBuilder(FileCache.ReadAllText("plugins/sync_v2/sync.js"));
            }

            sb.Replace("{sync-invc}", FileCache.ReadAllText("plugins/sync-invc.js"))
              .Replace("{localhost}", host)
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        #region invc-ws.js
        [HttpGet]
        [AllowAnonymous]
        [Route("invc-ws.js")]
        [Route("invc-ws/js/{token}")]
        public ActionResult InvcSyncJS(string token)
        {
            StringBuilder sb;

            if (AppInit.conf.sync_user.version == 1)
            {
                sb = new StringBuilder(FileCache.ReadAllText("plugins/invc-ws.js"));
            }    
            else
            {
                sb = new StringBuilder(FileCache.ReadAllText("plugins/sync_v2/invc-ws.js"));
            }

            sb.Replace("{invc-rch}", FileCache.ReadAllText("plugins/invc-rch.js"))
              .Replace("{invc-rch_nws}", FileCache.ReadAllText("plugins/invc-rch_nws.js"))
              .Replace("{localhost}", host)
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        #region invc-rch.js
        [HttpGet]
        [AllowAnonymous]
        [Route("invc-rch.js")]
        public ActionResult InvcRchJS()
        {
            string source = FileCache.ReadAllText("plugins/invc-rch.js").Replace("{localhost}", host);

            source = $"(function(){{'use strict'; {source} }})();";

            return Content(source, "application/javascript; charset=utf-8");
        }
        #endregion


        #region PlayerInner
        [HttpGet]
        [Route("player-inner/{*uri}")]
        public void PlayerInner(string uri)
        {
            if (string.IsNullOrEmpty(AppInit.conf.playerInner))
                return;

            // —É–±–∏—Ä–∞–µ–º –º—É—Å–æ—Ä –≤ —Å—Å—ã–ª–∫–µ
            uri = Regex.Replace(uri, "[^a-z0-9_:\\-\\/\\.\\=\\?\\&\\%\\@]+", "", RegexOptions.IgnoreCase);
            uri = uri + HttpContext.Request.QueryString.Value;

            if (!Uri.TryCreate(uri, UriKind.Absolute, out var stream) || 
                (stream.Scheme != Uri.UriSchemeHttp && stream.Scheme != Uri.UriSchemeHttps))
                return;

            Process.Start(new ProcessStartInfo()
            {
                FileName = AppInit.conf.playerInner,
                Arguments = stream.AbsoluteUri
            });
        }
        #endregion

        #region CMD
        [HttpGet]
        [Route("cmd/{key}/{*comand}")]
        async public Task CMD(string key, string comand)
        {
            if (!AppInit.conf.cmd.TryGetValue(key, out var cmd))
                return;

            if (!string.IsNullOrEmpty(cmd.eval))
            {
                var options = ScriptOptions.Default
                    .AddReferences(typeof(HttpRequest).Assembly).AddImports("Microsoft.AspNetCore.Http")
                    .AddReferences(typeof(Task).Assembly).AddImports("System.Threading.Tasks")
                    .AddReferences(CSharpEval.ReferenceFromFile("Newtonsoft.Json.dll")).AddImports("Newtonsoft.Json").AddImports("Newtonsoft.Json.Linq")
                    .AddReferences(CSharpEval.ReferenceFromFile("Shared.dll")).AddImports("Shared.Engine").AddImports("Shared.Models")
                    .AddReferences(typeof(IO.File).Assembly).AddImports("System.IO")
                    .AddReferences(typeof(Process).Assembly).AddImports("System.Diagnostics");

                var model = new CmdEvalModel(key, comand, requestInfo, HttpContext.Request, hybridCache, memoryCache);

                await CSharpEval.ExecuteAsync(cmd.eval, model, options);
            }
            else
            {
                Process.Start(new ProcessStartInfo()
                {
                    FileName = cmd.path,
                    Arguments = cmd.arguments.Replace("{value}", comand + HttpContext.Request.QueryString.Value)
                });
            }
        }
        #endregion
    }
}
```

## File: Lampac/Controllers/CorseuController.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Newtonsoft.Json;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Base;
using Shared.PlaywrightCore;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Controllers
{
    public class CorseuController : BaseController
    {
        #region Routes
        [HttpGet]
        [Route("/corseu/{token}/{*url}")]
        public Task<IActionResult> Get(string token, string url)
        {
            return ExecuteAsync(new CorseuRequest
            {
                url = url + HttpContext.Request.QueryString.Value,
                auth_token = token
            });
        }

        [HttpGet]
        [Route("/corseu")]
        public Task<IActionResult> Get(string auth_token, string method, string url, string data, string headers, string browser, int? httpversion, int? timeout, string encoding, bool? defaultHeaders, bool? autoredirect, string proxy, string proxy_name, bool? headersOnly)
        {
            return ExecuteAsync(new CorseuRequest
            {
                url = url,
                method = method,
                data = data,
                browser = browser,
                httpversion = httpversion,
                timeout = timeout,
                encoding = encoding,
                defaultHeaders = defaultHeaders,
                autoredirect = autoredirect,
                proxy = proxy,
                proxy_name = proxy_name,
                headersOnly = headersOnly,
                auth_token = auth_token,
                headers = ParseHeaders(headers)
            });
        }

        [HttpPost]
        [Route("/corseu")]
        async public Task<IActionResult> Post()
        {
            try
            {
                using (var reader = new StreamReader(HttpContext.Request.Body, Encoding.UTF8, leaveOpen: true))
                {
                    string body = await reader.ReadToEndAsync().ConfigureAwait(false);

                    if (string.IsNullOrWhiteSpace(body))
                        return BadRequest("Empty body");

                    var model = JsonConvert.DeserializeObject<CorseuRequest>(body);
                    if (model == null)
                        return BadRequest("Invalid body");

                    return await ExecuteAsync(model);
                }
            }
            catch (JsonException)
            {
                return BadRequest("Invalid JSON");
            }
        }
        #endregion

        #region Execute
        async Task<IActionResult> ExecuteAsync(CorseuRequest model)
        {
            var init = AppInit.conf.—Åorseu;

            if (init?.tokens == null || init.tokens.Length == 0)
                return StatusCode((int)HttpStatusCode.Forbidden);

            if (string.IsNullOrEmpty(model?.auth_token) || !init.tokens.Contains(model.auth_token))
                return StatusCode((int)HttpStatusCode.Forbidden);

            if (string.IsNullOrWhiteSpace(model?.url))
                return BadRequest("url is empty");

            string method = string.IsNullOrWhiteSpace(model.method) ? "GET" : model.method.ToUpperInvariant();
            string browser = string.IsNullOrWhiteSpace(model.browser) ? "http" : model.browser.ToLowerInvariant();

            var headers = model.headers != null
                ? new Dictionary<string, string>(model.headers, StringComparer.OrdinalIgnoreCase)
                : new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            bool useDefaultHeaders = model.defaultHeaders ?? true;
            bool autoRedirect = model.autoredirect ?? true;
            bool headersOnly = model.headersOnly ?? false;
            int timeout = model.timeout.HasValue && model.timeout.Value > 5 ? model.timeout.Value : 15;
            int httpVersion = model.httpversion ?? 1;

            string contentType = null;
            if (headers.TryGetValue("content-type", out string ct))
            {
                contentType = ct;
                headers.Remove("content-type");
            }

            if (headers.ContainsKey("content-length"))
                headers.Remove("content-length");

            if (browser is "chromium" or "playwright")
                return await SendWithChromiumAsync(method, model.url, model.data, headers, contentType, timeout, autoRedirect, headersOnly, model.proxy, model.proxy_name);

            return await SendWithHttpClientAsync(method, model.url, model.data, headers, contentType, timeout, httpVersion, useDefaultHeaders, autoRedirect, headersOnly, model.proxy, model.proxy_name, model.encoding);
        }
        #endregion

        #region HttpClient
        async Task<IActionResult> SendWithHttpClientAsync(
            string method, string url, string data, Dictionary<string, string> headers, 
            string contentType, int timeout, int httpVersion, bool useDefaultHeaders, bool autoRedirect, bool headersOnly, string encodingName, 
            string proxyValue, string proxyName)
        {
            var proxyManager = CreateProxy(url, proxyValue, proxyName);

            try
            {
                var handler = Http.Handler(url, proxyManager.Get());
                handler.AllowAutoRedirect = autoRedirect;

                var client = FrendlyHttp.HttpMessageClient(httpVersion == 2 ? "http2" : "base", handler);

                using (var request = new HttpRequestMessage(new HttpMethod(method), url))
                {
                    request.Version = httpVersion == 2 ? HttpVersion.Version20 : HttpVersion.Version11;

                    if (!string.IsNullOrEmpty(data))
                    {
                        var encoding = string.IsNullOrEmpty(encodingName) 
                            ? Encoding.UTF8 
                            : Encoding.GetEncoding(encodingName);

                        var content = new StringContent(data, encoding);

                        if (!string.IsNullOrEmpty(contentType))
                            content.Headers.ContentType = MediaTypeHeaderValue.Parse(contentType);

                        request.Content = content;
                    }

                    var headersModel = headers.Count > 0 ? HeadersModel.Init(headers) : null;
                    string log = string.Empty;
                    Http.DefaultRequestHeaders(url, request, null, null, headersModel, ref log, useDefaultHeaders);

                    using (var cts = CancellationTokenSource.CreateLinkedTokenSource(HttpContext.RequestAborted))
                    {
                        cts.CancelAfter(TimeSpan.FromSeconds(Math.Max(5, timeout)));

                        using (var response = await client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cts.Token).ConfigureAwait(false))
                        {
                            proxyManager.Success();

                            await CopyResponseAsync(response, headersOnly).ConfigureAwait(false);
                            return new EmptyResult();
                        }
                    }
                }
            }
            catch (OperationCanceledException)
            {
                proxyManager.Refresh();
                return StatusCode((int)HttpStatusCode.RequestTimeout);
            }
            catch (Exception ex)
            {
                proxyManager.Refresh();
                return StatusCode((int)HttpStatusCode.BadGateway, ex.Message);
            }
        }
        #endregion

        #region Chromium
        async Task<IActionResult> SendWithChromiumAsync(
            string method, string url, string data, Dictionary<string, string> headers, 
            string contentType, int timeout, bool autoRedirect, bool headersOnly, 
            string proxyValue, string proxyName)
        {
            var proxyManager = CreateProxy(url, proxyValue, proxyName);
            var proxy = proxyManager.BaseGet();

            try
            {
                if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                    return StatusCode((int)HttpStatusCode.BadGateway, "PlaywrightStatus disabled");

                var contextHeaders = new Dictionary<string, string>(headers, StringComparer.OrdinalIgnoreCase);
                var requestHeaders = new Dictionary<string, string>(headers, StringComparer.OrdinalIgnoreCase);

                if (!string.IsNullOrEmpty(contentType))
                {
                    if (!requestHeaders.ContainsKey("content-type"))
                    {
                        requestHeaders["content-type"] = contentType;
                        contextHeaders["content-type"] = contentType;
                    }
                }

                var contextOptions = new APIRequestNewContextOptions
                {
                    IgnoreHTTPSErrors = true,
                    ExtraHTTPHeaders = contextHeaders,
                    Timeout = timeout * 1000,
                    UserAgent = requestHeaders.TryGetValue("user-agent", out string _useragent) ? _useragent : Http.UserAgent
                };

                var requestOptions = new APIRequestContextOptions
                {
                    Method = method,
                    Headers = requestHeaders,
                    Timeout = timeout * 1000
                };

                if (!string.IsNullOrEmpty(data))
                    requestOptions.DataString = data;

                if (!autoRedirect)
                    requestOptions.MaxRedirects = 0;

                if (proxy.proxy != null)
                {
                    contextOptions.Proxy = new Proxy
                    {
                        Server = proxy.data.ip,
                        Username = proxy.data.username,
                        Password = proxy.data.password
                    };
                }

                await using (var requestContext = await Chromium.playwright.APIRequest.NewContextAsync(contextOptions).ConfigureAwait(false))
                {
                    var response = await requestContext.FetchAsync(url, requestOptions).ConfigureAwait(false);

                    try
                    {
                        HttpContext.Response.StatusCode = response.Status;

                        foreach (var header in response.HeadersArray)
                        {
                            var headerName = header.Name.ToLowerInvariant();

                            if (ShouldSkipHeader(headerName))
                                continue;

                            if (headerName == "content-type")
                                HttpContext.Response.ContentType = header.Value;

                            HttpContext.Response.Headers[header.Name] = header.Value;
                        }

                        if (headersOnly)
                        {
                            proxyManager.Success();
                            await HttpContext.Response.CompleteAsync().ConfigureAwait(false);
                            return new EmptyResult();
                        }

                        var body = await response.BodyAsync().ConfigureAwait(false);
                        if (body?.Length > 0)
                            await HttpContext.Response.Body.WriteAsync(body, 0, body.Length, HttpContext.RequestAborted).ConfigureAwait(false);

                        proxyManager.Success();
                        return new EmptyResult();
                    }
                    finally
                    {
                        await response.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
            catch (OperationCanceledException)
            {
                proxyManager.Refresh();
                return StatusCode((int)HttpStatusCode.RequestTimeout);
            }
            catch (Exception ex)
            {
                proxyManager.Refresh();
                return StatusCode((int)HttpStatusCode.BadGateway, ex.Message);
            }
        }
        #endregion

        #region Helpers
        Dictionary<string, string> ParseHeaders(string headers)
        {
            try
            {
                if (!string.IsNullOrEmpty(headers))
                    return JsonConvert.DeserializeObject<Dictionary<string, string>>(headers);
            }
            catch { }

            return new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        }

        ProxyManager CreateProxy(string url, string proxyValue, string proxyName)
        {
            var model = new BaseSettings()
            {
                plugin = $"corseu:{Regex.Match(url, "https?://([^/]+)")}"
            };

            if (!string.IsNullOrEmpty(proxyValue))
            {
                model.proxy = new ProxySettings();
                model.proxy.list = [proxyValue];
            }
            else if (!string.IsNullOrEmpty(proxyName))
            {
                if (AppInit.conf.globalproxy != null)
                {
                    var settings = AppInit.conf.globalproxy.FirstOrDefault(i => i.name == proxyName);
                    if (settings?.list != null && settings.list.Length > 0)
                        model.proxy = settings;
                }
            }

            if (model.proxy != null)
                model.useproxy = true;

            return new ProxyManager(model);
        }

        async Task CopyResponseAsync(HttpResponseMessage response, bool headersOnly)
        {
            var httpResponse = HttpContext.Response;
            httpResponse.StatusCode = (int)response.StatusCode;

            foreach (var header in response.Headers)
            {
                if (ShouldSkipHeader(header.Key))
                    continue;

                httpResponse.Headers[header.Key] = string.Join(", ", header.Value);
            }

            foreach (var header in response.Content.Headers)
            {
                if (string.Equals(header.Key, "Content-Type", StringComparison.OrdinalIgnoreCase))
                {
                    httpResponse.ContentType = response.Content.Headers.ContentType?.ToString();
                    continue;
                }

                if (ShouldSkipHeader(header.Key))
                    continue;

                httpResponse.Headers[header.Key] = string.Join(", ", header.Value);
            }

            if (headersOnly)
            {
                await httpResponse.CompleteAsync().ConfigureAwait(false);
                return;
            }

            using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                await responseStream.CopyToAsync(httpResponse.Body, HttpContext.RequestAborted).ConfigureAwait(false);
        }

        bool ShouldSkipHeader(string header)
        {
            string key = header.ToLowerInvariant();

            return key switch
            {
                "content-length" => true,
                "transfer-encoding" => true,
                "connection" => true,
                "keep-alive" => true,
                "content-disposition" => true,
                "content-encoding" => true,
                "content-security-policy" => true,
                "vary" => true,
                "alt-svc" => true,
                _ when key.StartsWith("access-control") => true,
                _ when key.StartsWith("x-") => true,
                _ => false
            };
        }
        #endregion
    }
}
```

## File: Lampac/Controllers/TimecodeController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.SQL;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Web;

namespace Lampac.Controllers
{
    public class TimecodeController : BaseController
    {
        #region timecode.js
        [HttpGet]
        [AllowAnonymous]
        [Route("timecode.js")]
        [Route("timecode/js/{token}")]
        public ActionResult timecode(string token)
        {
            string file = FileCache.ReadAllText("plugins/timecode.js").Replace("{localhost}", host);
            file = file.Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(file, contentType: "application/javascript; charset=utf-8");
        }
        #endregion

        [Route("/timecode/all")]
        public ActionResult Get(string card_id)
        {
            if (string.IsNullOrEmpty(card_id))
                return Json(new { });

            string userId = getUserid(requestInfo, HttpContext);

            Dictionary<string, string> timecodes = null;

            using (var sqlDb = new SyncUserContext())
            {
                timecodes = sqlDb.timecodes
                    .AsNoTracking()
                    .Where(i => i.user == userId && i.card == card_id)
                    .ToDictionary(i => i.item, i => i.data);
            }

            if (timecodes == null || timecodes.Count == 0)
                return Json(new { });

            return Json(timecodes);
        }

        [HttpPost]
        [Route("/timecode/add")]
        async public Task<ActionResult> Set([FromQuery] string card_id, [FromForm] string id, [FromForm] string data)
        {
            if (string.IsNullOrEmpty(id) || string.IsNullOrEmpty(data))
                return ContentTo("{\"success\": false}");

            if (string.IsNullOrEmpty(card_id))
                return ContentTo("{\"success\": false}");

            string userId = getUserid(requestInfo, HttpContext);

            bool success = false;

            try
            {
                await SyncUserContext.semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                using (var sqlDb = new SyncUserContext())
                {
                    sqlDb.timecodes
                        .Where(i => i.user == userId && i.card == card_id && i.item == id)
                        .ExecuteDelete();

                    sqlDb.timecodes.Add(new SyncUserTimecodeSqlModel
                    {
                        user = userId,
                        card = card_id,
                        item = id,
                        data = data,
                        updated = DateTime.UtcNow
                    });

                    success = sqlDb.SaveChanges() > 0;
                }
            }
            catch { }
            finally
            {
                SyncUserContext.semaphore.Release();
            }

            return ContentTo($"{{\"success\": {success.ToString().ToLower()}}}");
        }


        static string getUserid(RequestModel requestInfo, HttpContext httpContext)
        {
            string user_id = requestInfo.user_uid;

            if (httpContext.Request.Query.TryGetValue("profile_id", out var profile_id) && !string.IsNullOrEmpty(profile_id) && profile_id != "0")
                return $"{user_id}_{profile_id}";

            return user_id;
        }
    }
}
```

## File: Lampac/Controllers/ChromiumController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Shared;

namespace Lampac.Controllers
{
    public class ChromiumController : BaseController
    {
        [AllowAnonymous]
        [Route("/api/chromium/ping")]
        public string Ping() => "pong";


        [AllowAnonymous]
        [Route("/api/chromium/iframe")]
        public ActionResult RenderIframe(string src)
        {
            return ContentTo($@"<html lang=""ru"">
                <head>
                    <meta charset=""UTF-8"">
                    <meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
                    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"">
                    <title>chromium iframe</title>
                </head>
                <body>
                    <iframe width=""560"" height=""400"" src=""{src}"" frameborder=""0"" allow=""*"" allowfullscreen></iframe>
                </body>
            </html>");
        }
    }
}
```

## File: Lampac/Controllers/RchApi.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Shared;
using Shared.Engine;
using System.IO;
using System.IO.Compression;
using System.Text;
using System.Threading.Tasks;

namespace Lampac.Controllers
{
    public class RchApi : BaseController
    {
        [HttpGet]
        [AllowAnonymous]
        [Route("rch/check/connected")]
        public ActionResult –°heck–°onnected()
        {
            var rch = new RchClient(HttpContext, host, new Shared.Models.Base.BaseSettings() { rhub = true }, requestInfo);
            if (rch.IsNotConnected())
                return ContentTo(rch.connectionMsg);

            var info = rch.InfoConnected() ?? new RchClientInfo();
            return Json(new { info.version, info.apkVersion, info.rchtype });
        }

        [HttpPost]
        [AllowAnonymous]
        [Route("rch/result")]
        public ActionResult WriteResult([FromForm]string id, [FromForm]string value)
        {
            if (string.IsNullOrEmpty(id))
            {
                HttpContext.Response.StatusCode = 401;
                return Content(string.Empty);
            }

            if (!RchClient.rchIds.TryGetValue(id, out var tcs))
            {
                HttpContext.Response.StatusCode = 400;
                return Content(string.Empty);
            }

            tcs.SetResult(value ?? string.Empty);
            return Ok();
        }

        [HttpPost]
        [AllowAnonymous]
        [Route("rch/gzresult")]
        async public Task<ActionResult> WriteZipResult([FromQuery]string id)
        {
            if (string.IsNullOrEmpty(id))
            {
                HttpContext.Response.StatusCode = 401;
                return Content(string.Empty);
            }

            if (!RchClient.rchIds.TryGetValue(id, out var tcs))
            {
                HttpContext.Response.StatusCode = 400;
                return Content(string.Empty);
            }

            try
            {
                using (var gzip = new GZipStream(Request.Body, CompressionMode.Decompress, leaveOpen: true))
                {
                    using (var reader = new StreamReader(gzip, Encoding.UTF8))
                    {
                        var text = await reader.ReadToEndAsync();
                        tcs.SetResult(text ?? string.Empty);
                    }
                }
            }
            catch { }

            return Ok();
        }
    }
}

```

## File: Lampac/Controllers/StorageController.cs
```
Ôªøusing Lampac.Engine;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using IO = System.IO;

namespace Lampac.Controllers
{
    public class StorageController : BaseController
    {
        #region StorageController
        static StorageController()
        {
            Directory.CreateDirectory("database/storage");
            Directory.CreateDirectory("database/storage/temp");
        }
        #endregion

        #region Get
        [Route("/storage/get")]
        public ActionResult Get(string path, string pathfile, bool responseInfo)
        {
            string outFile = getFilePath(path, pathfile, false);
            if (outFile == null || !IO.File.Exists(outFile))
                return Content("{\"success\": false, \"msg\": \"outFile\"}", "application/json; charset=utf-8");

            var file = new FileInfo(outFile);
            var fileInfo = new { file.Name, path = outFile, file.Length, changeTime = new DateTimeOffset(file.LastWriteTimeUtc).ToUnixTimeMilliseconds() };

            if (responseInfo)
                return Json(new { success = true, uid = requestInfo.user_uid, fileInfo });

            string data = AppInit.conf.storage.brotli ? BrotliTo.Decompress(outFile) : IO.File.ReadAllText(outFile);

            return Json(new { success = true, uid = requestInfo.user_uid, fileInfo, data });
        }
        #endregion

        #region Set
        [HttpPost]
        [Route("/storage/set")]
        async public Task<ActionResult> Set([FromQuery]string path, [FromQuery]string pathfile, [FromQuery]string connectionId, [FromQuery]string events)
        {
            if (!AppInit.conf.storage.enable)
                return ContentTo("{\"success\": false, \"msg\": \"disabled\"}");

            if (HttpContext.Request.ContentLength > AppInit.conf.storage.max_size)
                return ContentTo("{\"success\": false, \"msg\": \"max_size\"}");

            string outFile = getFilePath(path, pathfile, true);
            if (outFile == null)
                return ContentTo("{\"success\": false, \"msg\": \"outFile\"}");

            byte[] array = null;
            using (var memoryStream = new MemoryStream()) 
            {
                try
                {
                    await HttpContext.Request.Body.CopyToAsync(memoryStream);
                    array = memoryStream.ToArray();
                }
                catch 
                {
                    HttpContext.Response.StatusCode = 500;
                    return ContentTo("{\"success\": false, \"msg\": \"Request.Body.CopyToAsync\"}");
                }
            }

            var semaphore = new SemaphorManager(outFile, TimeSpan.FromMinutes(1));

            try
            {
                await semaphore.WaitAsync();

                if (AppInit.conf.storage.brotli)
                    BrotliTo.Compress(outFile, array);
                else
                {
                    using (var fileStream = new FileStream(outFile, FileMode.Create, FileAccess.Write, FileShare.None))
                        fileStream.Write(array, 0, array.Length);
                }
            }
            catch
            {
                HttpContext.Response.StatusCode = 500;
                return ContentTo("{\"success\": false, \"msg\": \"fileLock\"}");
            }
            finally
            {
                semaphore.Release();
            }

            #region events
            if (!string.IsNullOrEmpty(events))
            {
                try
                {
                    var json = JsonConvert.DeserializeObject<JObject>(CrypTo.DecodeBase64(events));
                    _ = soks.SendEvents(json.Value<string>("connectionId"), requestInfo.user_uid, json.Value<string>("name"), json.Value<string>("data")).ConfigureAwait(false);
                    _ = nws.SendEvents(json.Value<string>("connectionId"), requestInfo.user_uid, json.Value<string>("name"), json.Value<string>("data")).ConfigureAwait(false);
                }
                catch { }
            }
            else
            {
                string edata = JsonConvert.SerializeObject(new { path, pathfile });
                _ = nws.SendEvents(connectionId, requestInfo.user_uid, "storage", edata).ConfigureAwait(false);
            }
            #endregion

            var inf = new FileInfo(outFile);

            return Json(new 
            { 
                success = true,
                uid = requestInfo.user_uid,
                fileInfo = new { inf.Name, path = outFile, inf.Length, changeTime = new DateTimeOffset(inf.LastWriteTimeUtc).ToUnixTimeMilliseconds() }
            });
        }
        #endregion

        #region TempGet
        [HttpGet]
        [Route("/storage/temp/{key}")]
        public ActionResult TempGet(string key, bool responseInfo)
        {
            string outFile = getFilePath("temp", null, false, user_uid: key);
            if (outFile == null || !IO.File.Exists(outFile))
                return Content("{\"success\": false, \"msg\": \"outFile\"}", "application/json; charset=utf-8");

            var file = new FileInfo(outFile);
            var fileInfo = new { file.Name, path = outFile, file.Length, changeTime = new DateTimeOffset(file.LastWriteTimeUtc).ToUnixTimeMilliseconds() };

            if (responseInfo)
                return Json(new { success = true, uid = requestInfo.user_uid, fileInfo });

            string data = AppInit.conf.storage.brotli ? BrotliTo.Decompress(outFile) : IO.File.ReadAllText(outFile);

            return Json(new { success = true, uid = requestInfo.user_uid, fileInfo, data });
        }
        #endregion

        #region TempSet
        [HttpPost]
        [Route("/storage/temp/{key}")]
        async public Task<ActionResult> TempSet(string key)
        {
            if (!AppInit.conf.storage.enable)
                return ContentTo("{\"success\": false, \"msg\": \"disabled\"}");

            if (HttpContext.Request.ContentLength > AppInit.conf.storage.max_size)
                return ContentTo("{\"success\": false, \"msg\": \"max_size\"}");

            string outFile = getFilePath("temp", null, true, user_uid: key);
            if (outFile == null)
                return ContentTo("{\"success\": false, \"msg\": \"outFile\"}");

            byte[] array = null;
            using (var memoryStream = new MemoryStream())
            {
                try
                {
                    await HttpContext.Request.Body.CopyToAsync(memoryStream);
                    array = memoryStream.ToArray();
                }
                catch 
                {
                    HttpContext.Response.StatusCode = 500;
                    return ContentTo("{\"success\": false, \"msg\": \"Request.Body.CopyToAsync\"}");
                }
            }

            var semaphore = new SemaphorManager(outFile, TimeSpan.FromMinutes(1));

            try
            {
                await semaphore.WaitAsync();

                if (AppInit.conf.storage.brotli)
                    BrotliTo.Compress(outFile, array);
                else
                {
                    using (var fileStream = new FileStream(outFile, FileMode.Create, FileAccess.Write, FileShare.None))
                        fileStream.Write(array, 0, array.Length);
                }
            }
            catch
            {
                HttpContext.Response.StatusCode = 500;
                return ContentTo("{\"success\": false, \"msg\": \"fileLock\"}");
            }
            finally
            {
                semaphore.Release();
            }

            var inf = new FileInfo(outFile);

            return Json(new
            {
                success = true,
                uid = requestInfo.user_uid,
                fileInfo = new { inf.Name, path = outFile, inf.Length, changeTime = new DateTimeOffset(inf.LastWriteTimeUtc).ToUnixTimeMilliseconds() }
            });
        }
        #endregion


        #region getFilePath
        string getFilePath(string path, string pathfile, bool createDirectory, string user_uid = null)
        {
            if (path == "temp" && string.IsNullOrEmpty(user_uid))
                return null;

            string id = user_uid ?? requestInfo.user_uid;
            if (string.IsNullOrEmpty(id))
                return null;

            id += pathfile;
            string md5key = AppInit.conf.storage.md5name ? CrypTo.md5(id) : Regex.Replace(id, "(\\@|_)", "");

            if (path == "temp")
            {
                return $"database/storage/{path}/{md5key}";
            }
            else
            {
                if (createDirectory)
                    Directory.CreateDirectory($"database/storage/{path}/{md5key.Substring(0, 2)}");

                return $"database/storage/{path}/{md5key.Substring(0, 2)}/{md5key.Substring(2)}";
            }
        }
        #endregion
    }
}
```

## File: Lampac/Controllers/BookmarkController.cs
```
using Lampac.Engine;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.SQL;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Web;

namespace Lampac.Controllers
{
    public class BookmarkController : BaseController
    {
        #region bookmark.js
        [HttpGet]
        [Route("bookmark.js")]
        [Route("bookmark/js/{token}")]
        public ActionResult BookmarkJS(string token)
        {
            if (!AppInit.conf.storage.enable)
                return Content(string.Empty, "application/javascript; charset=utf-8");

            var sb = new StringBuilder(FileCache.ReadAllText("plugins/bookmark.js"));

            sb.Replace("{localhost}", host)
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion

        static readonly string[] BookmarkCategories = {
            "history",
            "like",
            "watch",
            "wath",
            "book",
            "look",
            "viewed",
            "scheduled",
            "continued",
            "thrown"
        };


        #region List
        [HttpGet]
        [Route("/bookmark/list")]
        public async Task<ActionResult> List(string filed)
        {
            if (!AppInit.conf.sync_user.enable)
                return ContentTo("{}");

            string userUid = getUserid(requestInfo, HttpContext);

            #region migration storage to sql
            if (AppInit.conf.sync_user.version != 1 && !string.IsNullOrEmpty(requestInfo.user_uid))
            {
                string profile_id = getProfileid(requestInfo, HttpContext);
                string id = requestInfo.user_uid + profile_id;

                string md5key = AppInit.conf.storage.md5name ? CrypTo.md5(id) : Regex.Replace(id, "(\\@|_)", "");
                string storageFile = $"database/storage/sync_favorite/{md5key.Substring(0, 2)}/{md5key.Substring(2)}";

                if (System.IO.File.Exists(storageFile) && !System.IO.File.Exists($"{storageFile}.migration"))
                {
                    try
                    {
                        await SyncUserContext.semaphore.WaitAsync(TimeSpan.FromSeconds(40));

                        if (System.IO.File.Exists(storageFile) && !System.IO.File.Exists($"{storageFile}.migration"))
                        {
                            var content = System.IO.File.ReadAllText(storageFile);
                            if (!string.IsNullOrWhiteSpace(content))
                            {
                                var root = JsonConvert.DeserializeObject<JObject>(content);

                                var favorite = (JObject)root["favorite"];

                                using (var sqlDb = new SyncUserContext())
                                {
                                    var (entity, loaded) = LoadBookmarks(sqlDb, userUid, createIfMissing: true);
                                    bool changed = false;

                                    EnsureDefaultArrays(loaded);

                                    #region migrate card objects
                                    if (favorite["card"] is JArray srcCards)
                                    {
                                        foreach (var c in srcCards.Children<JObject>())
                                        {
                                            changed |= EnsureCard(loaded, c, c?["id"]?.ToString(), insert: false);
                                        }
                                    }
                                    #endregion

                                    #region migrate categories
                                    foreach (var prop in favorite.Properties())
                                    {
                                        var name = prop.Name.Trim().ToLowerInvariant();

                                        if (string.Equals(name, "card", StringComparison.OrdinalIgnoreCase))
                                            continue;

                                        var srcValue = prop.Value;

                                        if (BookmarkCategories.Contains(name))
                                        {
                                            if (srcValue is JArray srcArray)
                                            {
                                                var dest = GetCategoryArray(loaded, name);
                                                foreach (var t in srcArray)
                                                {
                                                    var idStr = t?.ToString();
                                                    if (string.IsNullOrWhiteSpace(idStr))
                                                        continue;

                                                    if (dest.Any(dt => dt.ToString() == idStr) == false)
                                                    {
                                                        if (long.TryParse(idStr, out long _id) && _id > 0)
                                                            dest.Add(_id);
                                                        else
                                                            dest.Add(idStr);

                                                        changed = true;
                                                    }
                                                }
                                            }
                                        }
                                        else
                                        {
                                            var existing = loaded[name];
                                            if (existing == null || !JToken.DeepEquals(existing, srcValue))
                                            {
                                                loaded[name] = srcValue;
                                                changed = true;
                                            }
                                        }
                                    }
                                    #endregion

                                    if (changed)
                                        Save(sqlDb, entity, loaded);
                                }

                                System.IO.File.Create($"{storageFile}.migration");
                            }
                        }
                    }
                    catch { }
                    finally
                    {
                        SyncUserContext.semaphore.Release();
                    }
                }
            }
            #endregion

            using (var sqlDb = new SyncUserContext())
            {
                bool IsDbInitialization = sqlDb.bookmarks.AsNoTracking().FirstOrDefault(i => i.user == userUid) != null;
                if (!IsDbInitialization)
                    return Json(new { dbInNotInitialization = true });

                var data = GetBookmarksForResponse(sqlDb);
                if (!string.IsNullOrEmpty(filed))
                    return ContentTo(data[filed].ToString(Formatting.None));

                return ContentTo(data.ToString(Formatting.None));
            }
        }
        #endregion

        #region Set
        [HttpPost]
        [Route("/bookmark/set")]
        public async Task<ActionResult> Set(string connectionId)
        {
            if (string.IsNullOrEmpty(requestInfo.user_uid) || !AppInit.conf.sync_user.enable)
                return JsonFailure();

            using (var reader = new StreamReader(Request.Body, Encoding.UTF8, detectEncodingFromByteOrderMarks: false, leaveOpen: true))
            {
                string body = await reader.ReadToEndAsync();
                if (string.IsNullOrWhiteSpace(body))
                    return JsonFailure();

                var token = JsonConvert.DeserializeObject<JToken>(body);
                if (token == null)
                    return JsonFailure();

                var jobs = new List<JObject>();
                if (token.Type == JTokenType.Array)
                {
                    foreach (var obj in token.Children<JObject>())
                        jobs.Add(obj);
                }
                else if (token is JObject singleJob)
                {
                    jobs.Add(singleJob);
                }

                bool IsDbInitialization = false;

                try
                {
                    await SyncUserContext.semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                    using (var sqlDb = new SyncUserContext())
                    {
                        string userUid = getUserid(requestInfo, HttpContext);

                        IsDbInitialization = sqlDb.bookmarks.AsNoTracking().FirstOrDefault(i => i.user == userUid) != null;

                        var (entity, data) = LoadBookmarks(sqlDb, userUid, createIfMissing: true);

                        foreach (var job in jobs)
                        {
                            string where = job.Value<string>("where")?.Trim()?.ToLowerInvariant();
                            if (string.IsNullOrWhiteSpace(where))
                                return JsonFailure();

                            if (IsDbInitialization && AppInit.conf.sync_user.fullset == false)
                            {
                                if (where == "card" || BookmarkCategories.Contains(where))
                                    return JsonFailure("enable sync_user.fullset in init.conf");
                            }

                            if (!job.TryGetValue("data", out var dataValue))
                                return JsonFailure();

                            data[where] = dataValue;
                        }

                        EnsureDefaultArrays(data);

                        Save(sqlDb, entity, data);
                    }
                }
                catch 
                {
                    return JsonFailure();
                }
                finally
                {
                    SyncUserContext.semaphore.Release();
                }

                if (IsDbInitialization)
                {
                    _ = nws.SendEvents(connectionId, requestInfo.user_uid, "bookmark", JsonConvert.SerializeObject(new
                    {
                        type = "set",
                        data = token,
                        profile_id = getProfileid(requestInfo, HttpContext)
                    })).ConfigureAwait(false);
                }

                return JsonSuccess();
            }
        }

        #endregion

        #region Add/Added
        [HttpPost]
        [Route("/bookmark/add")]
        [Route("/bookmark/added")]
        public async Task<ActionResult> Add(string connectionId)
        {
            if (string.IsNullOrEmpty(requestInfo.user_uid) || !AppInit.conf.sync_user.enable)
                return JsonFailure();

            var readBody = await ReadPayloadAsync();

            if (readBody.payloads.Count == 0)
                return JsonFailure();

            bool isAddedRequest = HttpContext?.Request?.Path.Value?.StartsWith("/bookmark/added", StringComparison.OrdinalIgnoreCase) == true;

            try
            {
                await SyncUserContext.semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                using (var sqlDb = new SyncUserContext())
                {
                    var (entity, data) = LoadBookmarks(sqlDb, getUserid(requestInfo, HttpContext), createIfMissing: true);
                    bool changed = false;

                    foreach (var payload in readBody.payloads)
                    {
                        var cardId = payload.ResolveCardId();
                        if (cardId == null)
                            continue;

                        changed |= EnsureCard(data, payload.Card, cardId);

                        if (payload.Where != null)
                            changed |= AddToCategory(data, payload.Where, cardId);

                        if (isAddedRequest)
                            changed |= MoveIdToFrontInAllCategories(data, cardId);
                    }

                    if (changed)
                    {
                        Save(sqlDb, entity, data);

                        if (readBody.token != null)
                        {
                            string edata = JsonConvert.SerializeObject(new
                            {
                                type = isAddedRequest ? "added" : "add",
                                profile_id = getProfileid(requestInfo, HttpContext),
                                data = readBody.token
                            });

                            _ = nws.SendEvents(connectionId, requestInfo.user_uid, "bookmark", edata).ConfigureAwait(false);
                        }
                    }
                }

                return JsonSuccess();
            }
            catch 
            {
                return JsonFailure();
            }
            finally
            {
                SyncUserContext.semaphore.Release();
            }
        }
        #endregion

        #region Remove
        [HttpPost]
        [Route("/bookmark/remove")]
        public async Task<ActionResult> Remove(string connectionId)
        {
            if (string.IsNullOrEmpty(requestInfo.user_uid) || !AppInit.conf.sync_user.enable)
                return JsonFailure();

            var readBody = await ReadPayloadAsync();

            if (readBody.payloads.Count == 0)
                return JsonFailure();

            try
            {
                await SyncUserContext.semaphore.WaitAsync(TimeSpan.FromSeconds(30));

                using (var sqlDb = new SyncUserContext())
                {
                    var (entity, data) = LoadBookmarks(sqlDb, getUserid(requestInfo, HttpContext), createIfMissing: false);
                    if (entity == null)
                        return JsonSuccess();

                    bool changed = false;

                    foreach (var payload in readBody.payloads)
                    {
                        var cardId = payload.ResolveCardId();
                        if (cardId == null)
                            continue;

                        if (payload.Where != null)
                            changed |= RemoveFromCategory(data, payload.Where, cardId);

                        if (payload.Method == "card")
                        {
                            changed |= RemoveIdFromAllCategories(data, cardId);
                            changed |= RemoveCard(data, cardId);
                        }
                    }

                    if (changed)
                    {
                        Save(sqlDb, entity, data);

                        if (readBody.token != null)
                        {
                            string edata = JsonConvert.SerializeObject(new
                            {
                                type = "remove",
                                profile_id = getProfileid(requestInfo, HttpContext),
                                data = readBody.token
                            });

                            _ = nws.SendEvents(connectionId, requestInfo.user_uid, "bookmark", edata).ConfigureAwait(false);
                        }
                    }
                }

                return JsonSuccess();
            }
            catch 
            {
                return JsonFailure();
            }
            finally
            {
                SyncUserContext.semaphore.Release();
            }
        }
        #endregion


        #region static
        static string getUserid(RequestModel requestInfo, HttpContext httpContext)
        {
            string user_id = requestInfo.user_uid;
            string profile_id = getProfileid(requestInfo, httpContext);

            if (!string.IsNullOrEmpty(profile_id))
                return $"{user_id}_{profile_id}";

            return user_id;
        }

        static string getProfileid(RequestModel requestInfo, HttpContext httpContext)
        {
            if (httpContext.Request.Query.TryGetValue("profile_id", out var profile_id) && !string.IsNullOrEmpty(profile_id) && profile_id != "0")
                return profile_id;

            return string.Empty;
        }

        JObject GetBookmarksForResponse(SyncUserContext sqlDb)
        {
            if (string.IsNullOrEmpty(requestInfo.user_uid))
                return CreateDefaultBookmarks();

            string user_id = getUserid(requestInfo, HttpContext);
            var entity = sqlDb.bookmarks.AsNoTracking().FirstOrDefault(i => i.user == user_id);
            var data = entity != null ? DeserializeBookmarks(entity.data) : CreateDefaultBookmarks();
            EnsureDefaultArrays(data);
            return data;
        }

        static (SyncUserBookmarkSqlModel entity, JObject data) LoadBookmarks(SyncUserContext sqlDb, string userUid, bool createIfMissing)
        {
            JObject data = CreateDefaultBookmarks();
            SyncUserBookmarkSqlModel entity = null;

            if (!string.IsNullOrEmpty(userUid))
            {
                entity = sqlDb.bookmarks.FirstOrDefault(i => i.user == userUid);
                if (entity != null && !string.IsNullOrEmpty(entity.data))
                    data = DeserializeBookmarks(entity.data);
            }

            EnsureDefaultArrays(data);

            if (entity == null && createIfMissing && !string.IsNullOrEmpty(userUid))
                entity = new SyncUserBookmarkSqlModel { user = userUid };

            return (entity, data);
        }

        static JObject DeserializeBookmarks(string json)
        {
            if (string.IsNullOrWhiteSpace(json))
                return CreateDefaultBookmarks();

            try
            {
                var job = JsonConvert.DeserializeObject<JObject>(json) ?? new JObject();
                EnsureDefaultArrays(job);
                return job;
            }
            catch
            {
                return CreateDefaultBookmarks();
            }
        }

        static JObject CreateDefaultBookmarks()
        {
            var obj = new JObject
            {
                ["card"] = new JArray()
            };

            foreach (var category in BookmarkCategories)
                obj[category] = new JArray();

            return obj;
        }

        static void EnsureDefaultArrays(JObject root)
        {
            if (root == null)
                return;

            if (root["card"] is not JArray)
                root["card"] = new JArray();

            foreach (var category in BookmarkCategories)
            {
                if (root[category] is not JArray)
                    root[category] = new JArray();
            }
        }

        static bool EnsureCard(JObject data, JObject card, string idStr, bool insert = true)
        {
            if (data == null || card == null || string.IsNullOrWhiteSpace(idStr))
                return false;

            var cardArray = GetCardArray(data);
            var newCard = (JObject)card.DeepClone();

            foreach (var existing in cardArray.Children<JObject>().ToList())
            {
                var token = existing["id"];
                if (token != null && token.ToString() == idStr)
                {
                    if (!JToken.DeepEquals(existing, newCard))
                    {
                        existing.Replace(newCard);
                        return true;
                    }

                    return false;
                }
            }

            if (insert)
                cardArray.Insert(0, newCard);
            else
                cardArray.Add(newCard);

            return true;
        }

        static bool AddToCategory(JObject data, string category, string idStr)
        {
            var array = GetCategoryArray(data, category);

            foreach (var token in array)
            {
                if (token.ToString() == idStr)
                    return false;
            }

            if (long.TryParse(idStr, out long _id) && _id > 0)
                array.Insert(0, _id);
            else
                array.Insert(0, idStr);

            return true;
        }

        static bool MoveIdToFrontInAllCategories(JObject data, string idStr)
        {
            bool changed = false;

            foreach (var prop in data.Properties())
            {
                if (string.Equals(prop.Name, "card", StringComparison.OrdinalIgnoreCase))
                    continue;

                if (prop.Value is JArray array)
                    changed |= MoveIdToFront(array, idStr);
            }

            return changed;
        }

        static bool MoveIdToFront(JArray array, string idStr)
        {
            if (array == null)
                return false;

            for (int i = 0; i < array.Count; i++)
            {
                var token = array[i];
                if (token?.ToString() == idStr)
                {
                    if (i == 0)
                        return false;

                    token.Remove();
                    array.Insert(0, token);
                    return true;
                }
            }

            return false;
        }

        static bool RemoveFromCategory(JObject data, string category, string idStr)
        {
            if (data[category] is not JArray array)
                return false;

            return RemoveFromArray(array, idStr);
        }

        static bool RemoveIdFromAllCategories(JObject data, string idStr)
        {
            bool changed = false;

            foreach (var property in data.Properties().ToList())
            {
                if (property.Name == "card")
                    continue;

                if (property.Value is JArray array && RemoveFromArray(array, idStr))
                    changed = true;
            }

            return changed;
        }

        static bool RemoveCard(JObject data, string idStr)
        {
            if (data["card"] is JArray cardArray)
            {
                foreach (var card in cardArray.Children<JObject>().ToList())
                {
                    var token = card["id"];
                    if (token != null && token.ToString() == idStr)
                    {
                        card.Remove();
                        return true;
                    }
                }
            }

            return false;
        }

        static JArray GetCardArray(JObject data)
        {
            if (data["card"] is JArray array)
                return array;

            array = new JArray();
            data["card"] = array;
            return array;
        }

        static JArray GetCategoryArray(JObject data, string category)
        {
            if (data[category] is JArray array)
                return array;

            array = new JArray();
            data[category] = array;
            return array;
        }

        static bool RemoveFromArray(JArray array, string idStr)
        {
            foreach (var token in array.ToList())
            {
                if (token.ToString() == idStr)
                {
                    token.Remove();
                    return true;
                }
            }

            return false;
        }

        static void Save(SyncUserContext sqlDb, SyncUserBookmarkSqlModel entity, JObject data)
        {
            if (entity == null)
                return;

            entity.data = data.ToString(Formatting.None);
            entity.updated = DateTime.UtcNow;

            if (entity.Id == 0)
                sqlDb.bookmarks.Add(entity);
            else
                sqlDb.bookmarks.Update(entity);

            sqlDb.SaveChanges();
        }

        JsonResult JsonSuccess() => Json(new { success = true });

        ActionResult JsonFailure(string message = null) => ContentTo(JsonConvert.SerializeObject(new { success = false, message }));

        async Task<(IReadOnlyList<BookmarkEventPayload> payloads, JToken token)> ReadPayloadAsync()
        {
            JToken token = null;
            var payloads = new List<BookmarkEventPayload>();

            using (var reader = new StreamReader(Request.Body, Encoding.UTF8, detectEncodingFromByteOrderMarks: false, bufferSize: 1024, leaveOpen: true))
            {
                try
                {
                    string json = await reader.ReadToEndAsync();

                    if (string.IsNullOrWhiteSpace(json))
                        return (payloads, token);

                    token = JsonConvert.DeserializeObject<JToken>(json);
                    if (token == null)
                        return (payloads, token);

                    if (token.Type == JTokenType.Array)
                    {
                        foreach (var obj in token.Children<JObject>())
                            payloads.Add(ParsePayload(obj));
                    }
                    else if (token is JObject job)
                    {
                        payloads.Add(ParsePayload(job));
                    }
                }
                catch { }
            }

            return (payloads, token);
        }

        static BookmarkEventPayload ParsePayload(JObject job)
        {
            var payload = new BookmarkEventPayload
            {
                Method = job.Value<string>("method"),
                CardIdRaw = job.Value<string>("id") ?? job.Value<string>("card_id")
            };

            payload.Where = (job.Value<string>("where") ?? job.Value<string>("list"))?.Trim()?.ToLowerInvariant();
            if (string.IsNullOrEmpty(payload.Where) || payload.Where == "card")
                payload.Where = null;

            if (job.TryGetValue("card", out var cardToken) && cardToken is JObject cardObj)
                payload.Card = cardObj;

            return payload;
        }
        #endregion

        #region BookmarkEventPayload
        sealed class BookmarkEventPayload
        {
            public string Method { get; set; }

            public string Where { get; set; }

            public JObject Card { get; set; }

            public string CardIdRaw { get; set; }

            public string ResolveCardId()
            {
                if (!string.IsNullOrWhiteSpace(CardIdRaw))
                    return CardIdRaw.Trim().ToLowerInvariant();

                var token = Card?["id"];
                if (token != null)
                {
                    if (token.Type == JTokenType.Integer)
                        return token.Value<long>().ToString();

                    string _id = token.ToString();
                    if (string.IsNullOrWhiteSpace(_id))
                        return null;

                    return _id.Trim().ToLowerInvariant();
                }

                return null;
            }
        }
        #endregion
    }
}

```

## File: Lampac/Controllers/MediaController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Base;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;

namespace Lampac.Controllers
{
    public class MediaController : BaseController
    {
        #region Routes
        [HttpGet]
        [Route("/media/rsize/{token}/{width}/{height}/{*url}")]
        public ActionResult Get(string token, int width, int height, string url)
        {
            return GetLocation(url + HttpContext.Request.QueryString.Value, new MediaRequestBase
            {
                type = "img",
                auth_token = token,
                width = width,
                height = height
            }, null, null);
        }

        [HttpGet]
        [Route("/media/{type}/{token}/{*url}")]
        public ActionResult Get(string type, string token, string url)
        {
            return GetLocation(url + HttpContext.Request.QueryString.Value, new MediaRequestBase
            {
                auth_token = token,
                type = type
            }, null, null);
        }

        [HttpGet]
        [Route("/media")]
        public ActionResult Get(string url, string headers, [FromQuery] MediaRequestBase request)
        {
            var webProxy = CreateProxy(request?.proxy, request?.proxy_name);
            var headerList = HeadersModel.Init(ParseHeaders(headers));

            return GetLocation(url, request, headerList, webProxy);
        }

        [HttpPost]
        [Route("/media")]
        public ActionResult Post([FromBody] MediaRequest request)
        {
            if (!TryValidateBase(request, out ActionResult errorResult))
                return errorResult;

            if (request.urls == null || request.urls.Count == 0)
                return JsonError("invalid urls", 400);

            var webProxy = CreateProxy(request.proxy, request.proxy_name);
            var headerList = HeadersModel.Init(request.headers);
            var streamSettings = CreateStreamSettings(request);

            var result = new List<string>(request.urls.Count);

            foreach (string source in request.urls)
            {
                string proxied = request.type == "img"
                    ? CreateImageProxy(source, request.width, request.height, headerList, webProxy)
                    : HostStreamProxy(streamSettings, source, headerList, webProxy);

                result.Add(proxied);
            }

            return Json(new
            {
                success = true,
                urls = result
            });
        }
        #endregion

        #region Helpers
        ActionResult GetLocation(string url, MediaRequestBase request, List<HeadersModel> headers, WebProxy proxy)
        {
            if (string.IsNullOrEmpty(url))
                return JsonError("invalid url", 400);

            if (!TryValidateBase(request, out ActionResult errorResult))
                return errorResult;

            string location = request.type == "img"
                ? CreateImageProxy(url, request.width, request.height, headers, proxy)
                : HostStreamProxy(CreateStreamSettings(request), url, headers, proxy);

            return Redirect(location);
        }

        BaseSettings CreateStreamSettings(MediaRequestBase request)
        {
            return new BaseSettings
            {
                plugin = "media",
                streamproxy = true,
                apnstream = request.apnstream,
                useproxystream = request.useproxystream
            };
        }

        bool TryValidateBase(MediaRequestBase request, out ActionResult errorResult)
        {
            errorResult = null;
            var init = AppInit.conf.media;

            if (request == null)
            {
                errorResult = JsonError("invalid request", 400);
                return false;
            }

            if (string.IsNullOrEmpty(request.auth_token) || init?.tokens == null || !init.tokens.Any(t => t == request.auth_token))
            {
                errorResult = JsonError("unauthorized", 401);
                return false;
            }

            return true;
        }

        Dictionary<string, string> ParseHeaders(string headers)
        {
            try
            {
                if (!string.IsNullOrEmpty(headers))
                    return JsonConvert.DeserializeObject<Dictionary<string, string>>(headers);
            }
            catch { }

            return null;
        }

        WebProxy CreateProxy(string proxyValue, string proxyName)
        {
            ProxySettings proxySettings = null;

            if (!string.IsNullOrEmpty(proxyValue))
            {
                proxySettings = new ProxySettings
                {
                    list = [proxyValue]
                };
            }
            else if (!string.IsNullOrEmpty(proxyName) && AppInit.conf.globalproxy != null)
            {
                var settings = AppInit.conf.globalproxy.FirstOrDefault(i => i.name == proxyName);
                if (settings?.list != null && settings.list.Length > 0)
                    proxySettings = settings;
            }

            if (proxySettings == null)
                return null;

            return ProxyManager.ConfigureWebProxy(proxySettings, proxySettings.list.First()).proxy;
        }

        string CreateImageProxy(string url, int? width, int? height, List<HeadersModel> headers, WebProxy proxy)
        {
            if (!AppInit.conf.serverproxy.enable)
                return url;

            string encrypted = ProxyLink.Encrypt(url, requestInfo.IP, headers, proxy, "posterapi", verifyip: false);

            if (AppInit.conf.accsdb.enable && !AppInit.conf.serverproxy.encrypt)
                encrypted = AccsDbInvk.Args(encrypted, HttpContext);

            int normalizedWidth = Math.Max(0, width ?? 0);
            int normalizedHeight = Math.Max(0, height ?? 0);

            if (normalizedWidth > 0 || normalizedHeight > 0)
                return $"{host}/proxyimg:{normalizedWidth}:{normalizedHeight}/{encrypted}";

            return $"{host}/proxyimg/{encrypted}";
        }

        ActionResult JsonError(string message, int statusCode)
        {
            HttpContext.Response.StatusCode = statusCode;
            return ContentTo(JsonConvert.SerializeObject(new
            {
                success = false,
                error = message
            }));
        }
        #endregion
    }
}
```

## File: Lampac/Controllers/AdminController.cs
```
Ôªøusing Shared.Models.Module;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Linq;
using IO = System.IO;
using Shared;
using System.Threading.Tasks;
using Shared.Engine;

namespace Lampac.Controllers
{
    public class AdminController : BaseController
    {
        #region admin / auth
        [Route("admin")]
        [Route("admin/auth")]
        public ActionResult Authorization([FromForm]string parol)
        {
			if (AppInit.rootPasswd == "termux")
			{
                HttpContext.Response.Cookies.Append("passwd", "termux");
                return renderAdmin();
            }

            if (!string.IsNullOrEmpty(parol))
			{
                string ipKey = $"Accsdb:auth:IP:{requestInfo.IP}";
                if (!memoryCache.TryGetValue(ipKey, out HashSet<string> passwds))
                    passwds = new HashSet<string>();

                passwds.Add(parol);
                memoryCache.Set(ipKey, passwds, DateTime.Today.AddDays(1));

                if (passwds.Count > 5)
                    return Content("Too many attempts, try again tomorrow.");

                if (AppInit.rootPasswd == parol.Trim())
				{
					HttpContext.Response.Cookies.Append("passwd", parol.Trim());
					return Redirect("/admin");
				}
            }

			if (HttpContext.Request.Cookies.TryGetValue("passwd", out string passwd) && passwd == AppInit.rootPasswd)
				return renderAdmin();

            string html = @"
<!DOCTYPE html>
<html>
<head>
	<title>Authorization</title>
</head>
<body>

<style type=""text/css"">
	* {
	    box-sizing: border-box;
	    outline: none;
	}
	body{
		padding: 40px;
		font-family: sans-serif;
	}
	label{
		display: block;
		font-weight: 700;
		margin-bottom: 8px;
	}
	input,
	textarea,
	select{
		width: 340px;
		padding: 8px;
	}
	button{
		padding: 10px;
	}
	form > * + *{
		margin-top: 20px;
	}
</style>

<form method=""post"" action=""/admin/auth"" id=""form"">
	<div>
		<input type=""text"" name=""parol"" placeholder=""–ø–∞—Ä–æ–ª—å –∏–∑ —Ñ–∞–π–ª–∞ passwd""></input>
	</div>
	
	<button type=""submit"">–≤–æ–π—Ç–∏</button>
	
</form>

<div style=""margin-top: 4em;""><b style=""color: cadetblue;"">–í—ã–ø–æ–ª–Ω–∏—Ç–µ –æ–¥–Ω—É –∏–∑ –∫–æ–º–∞–Ω–¥ —á–µ—Ä–µ–∑ ssh</b><br><br>
	cat /home/lampac/passwd<br><br>
	docker exec -it lampac cat passwd
</div>

</body>
</html>
";

            return Content(html, contentType: "text/html; charset=utf-8");
        }

        ActionResult renderAdmin()
		{
            string adminHtml = IO.File.Exists("wwwroot/mycontrol/index.html") ? IO.File.ReadAllText("wwwroot/mycontrol/index.html") : IO.File.ReadAllText("wwwroot/control/index.html");
            return Content(adminHtml, contentType: "text/html; charset=utf-8");
		}
        #endregion


        #region init
        [Route("admin/init/save")]
        public ActionResult InitSave([FromForm]string json)
        {
			try
            {
                JsonConvert.DeserializeObject<AppInit>(json);
            }
			catch (Exception ex) { return Json(new { error = true, ex = ex.Message }); }

            var jo = JsonConvert.DeserializeObject<JObject>(json);

			JToken users = null;
            var accsdbNode = jo["accsdb"] as JObject;
            if (accsdbNode != null)
            {
                var usersNode = accsdbNode["users"];
                if (usersNode != null)
				{
					users = usersNode.DeepClone();
                    accsdbNode.Remove("users");

                    IO.File.WriteAllText("users.json", JsonConvert.SerializeObject(users, Formatting.Indented));
                }
            }

            IO.File.WriteAllText("init.conf", JsonConvert.SerializeObject(jo, Formatting.Indented));

            return Json(new { success = true });
        }

        [Route("admin/init/custom")]
        public ActionResult InitCustom()
        {
			string json = IO.File.Exists("init.conf") ? IO.File.ReadAllText("init.conf") : null;
			if (json != null && !json.Trim().StartsWith("{"))
				json = "{" + json + "}";

            var ob = json != null ? JsonConvert.DeserializeObject<JObject>(json) : new JObject { };
            return ContentTo(JsonConvert.SerializeObject(ob));
        }

        [Route("admin/init/current")]
        public ActionResult InitCurrent()
        {
            return Content(JsonConvert.SerializeObject(AppInit.conf), contentType: "application/json; charset=utf-8");
        }

        [Route("admin/init/default")]
        public ActionResult InitDefault()
        {
            return Content(JsonConvert.SerializeObject(new AppInit()), contentType: "application/json; charset=utf-8");
        }

        [Route("admin/init/example")]
        public ActionResult InitExample()
        {
            return Content(IO.File.Exists("example.conf") ? IO.File.ReadAllText("example.conf") : string.Empty);
        }
        #endregion

        #region sync/init
        [Route("admin/sync/init")]
        public ActionResult Synchtml()
        {
            string html = @"
<!DOCTYPE html>
<html>
<head>
	<title>–†–µ–¥–∞–∫—Ç–æ—Ä sync.conf</title>
</head>
<body>

<style type=""text/css"">
	* {
	    box-sizing: border-box;
	    outline: none;
	}
	body{
		padding: 40px;
		font-family: sans-serif;
	}
	label{
		display: block;
		font-weight: 700;
		margin-bottom: 8px;
	}
	input,
	textarea,
	select{
		width: 100%;
		padding: 10px;
	}
	button{
		padding: 10px;
	}
	form > * + *{
		margin-top: 30px;
	}
</style>

<form method=""post"" action="""" id=""form"">
	<div>
		<label>–í–∞—à sync.conf
		<textarea id=""value"" name=""value"" rows=""30"">{conf}</textarea>
	</div>
	
	<button type=""submit"">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
	
</form>

<script type=""text/javascript"">
	document.getElementById('form').addEventListener(""submit"", (e) => {
		let json = document.getElementById('value').value

		e.preventDefault()

		try{
			let formData = new FormData()
				formData.append('json', json)

			fetch('/admin/sync/init/save',{
			    method: ""POST"",
			    body: formData
			})
			.then((response)=>{
				if (!response.ok) {
					return response.json().then(err => {
						throw new Error(err.ex || '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏');
					});
				}
				return response.json();
			 })  
			.then((data)=>{
				if (data.success) {
					alert('–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ');
				} else if (data.error) {
					throw new Error(data.ex); 
				} else {
					throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏'); 
				}
			})
			.catch((e)=>{
				alert(e.message)
			})
		}
		catch(e){
			alert('–û—à–∏–±–∫–∞: ' + e.message)
		}
	})
</script>

</body>
</html>
";

            string conf = IO.File.Exists("sync.conf") ? IO.File.ReadAllText("sync.conf") : string.Empty;
            return Content(html.Replace("{conf}", conf), contentType: "text/html; charset=utf-8");
        }


        [Route("admin/sync/init/save")]
        public ActionResult SyncSave([FromForm] string json)
        {
            try
            {
                string testjson = json.Trim();
                if (!testjson.StartsWith("{"))
                    testjson = "{" + testjson + "}";

                JsonConvert.DeserializeObject<AppInit>(testjson);

            }
            catch (Exception ex) { return Json(new { error = true, ex = ex.Message }); }

            IO.File.WriteAllText("sync.conf", json);
            return Json(new { success = true });
        }
        #endregion

        #region manifest
        [Route("admin/manifest/install")]
        public Task ManifestInstallHtml(string online, string sisi, string jac, string dlna, string tracks, string ts, string catalog, string merch, string eng)
        {
            HttpContext.Response.ContentType = "text/html; charset=utf-8";

            if (AppInit.rootPasswd == "termux")
                return HttpContext.Response.WriteAsync("–í termux –æ–ø–µ—Ä–∞—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞");

            bool isEditManifest = false;

			if (IO.File.Exists("module/manifest.json"))
			{
                if (HttpContext.Request.Cookies.TryGetValue("passwd", out string passwd) && passwd == AppInit.rootPasswd)
                {
                    isEditManifest = true;
                }
                else
                {
                    HttpContext.Response.Redirect("/admin");
                    return Task.CompletedTask;
                }
            }

			if (HttpContext.Request.Method == "POST")
			{
				var modules = new List<string>(10);

				if (online == "on")
					modules.Add("{\"enable\":true,\"dll\":\"Online.dll\"}");

                if (sisi == "on")
                    modules.Add("{\"enable\":true,\"dll\":\"SISI.dll\"}");

                if (!string.IsNullOrEmpty(jac))
                {
                    modules.Add("{\"enable\":true,\"initspace\":\"Jackett.ModInit\",\"dll\":\"JacRed.dll\"}");

                    #region JacRed.conf
                    if (jac == "fdb")
                    {
                        var jacPath = "module/JacRed.conf";

                        JObject jj;
                        if (IO.File.Exists(jacPath))
                        {
                            string txt = IO.File.ReadAllText(jacPath).Trim();
                            if (string.IsNullOrEmpty(txt))
                                jj = new JObject();
                            else
                            {
                                if (!txt.StartsWith("{"))
                                    txt = "{" + txt + "}";

                                try
                                {
                                    jj = JsonConvert.DeserializeObject<JObject>(txt) ?? new JObject();
                                }
                                catch
                                {
                                    jj = new JObject();
                                }
                            }
                        }
                        else
                        {
                            jj = new JObject();
                        }

                        jj["typesearch"] = "red";
                        IO.File.WriteAllText(jacPath, JsonConvert.SerializeObject(jj, Formatting.Indented));
                    }
                    #endregion
                }

                if (dlna == "on")
                    modules.Add("{\"enable\":true,\"dll\":\"DLNA.dll\"}");

                if (tracks == "on")
                    modules.Add("{\"enable\":true,\"initspace\":\"Tracks.ModInit\",\"dll\":\"Tracks.dll\"}");

                if (ts == "on")
                    modules.Add("{\"enable\":true,\"initspace\":\"TorrServer.ModInit\",\"dll\":\"TorrServer.dll\"}");

                if (catalog == "on")
                    modules.Add("{\"enable\":true,\"initspace\":\"Catalog.ModInit\",\"dll\":\"Catalog.dll\"}");

                if (merch == "on")
                    modules.Add("{\"enable\":false,\"dll\":\"Merchant.dll\"}");

                IO.File.WriteAllText("module/manifest.json", $"[{string.Join(",", modules)}]");

                if (eng != "on")
                    UpdateInitConf(j => j["disableEng"] = true);

                if (isEditManifest)
                {
                    return HttpContext.Response.WriteAsync("–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ lampac –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫");
                }
                else
                {
                    #region frontend cloudflare
                    if (HttpContext.Request.Headers.TryGetValue("CF-Connecting-IP", out var xip) && !string.IsNullOrEmpty(xip))
                    {
                        UpdateInitConf(j =>
                        {
                            var listen = j["listen"] as JObject;
                            if (listen == null)
                            {
                                listen = new JObject();
                                j["listen"] = listen;
                            }

                            listen["frontend"] = "cloudflare";
                        });
                    }
                    #endregion

                    #region htmlSuccess
                    string passwdTxt = IO.File.Exists("passwd") ? IO.File.ReadAllText("passwd").Trim() : string.Empty;

                    #region shared_passwd
                    string sharedBlock = string.Empty;
                    if (IsLocalIp(requestInfo.IP) == false && IO.File.Exists("isdocker") == false)
                    {
                        string shared_passwd = CrypTo.unic(6).ToLower();

                        UpdateInitConf(j =>
                        {
                            var accsdb = j["accsdb"] as JObject;
                            if (accsdb == null)
                            {
                                accsdb = new JObject();
                                j["accsdb"] = accsdb;
                            }

                            accsdb["enable"] = true;
                            accsdb["shared_passwd"] = shared_passwd;
                        });

                        sharedBlock = $@"<div class=""block""><b>–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –≤ Lampa</b><br /><br />
                            –ü–∞—Ä–æ–ª—å: {shared_passwd}
                            <br><br>
                            –û—Ç–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –º–æ–∂–Ω–æ –≤ init.conf (accsdb) –∏–ª–∏ {host}/admin (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏) 
                        </div><hr />";
                    }
                    #endregion

                    string htmlSuccesds = $@"<!DOCTYPE html>
<html>
<head>
    <meta charset=""utf-8"" />
    <title>–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞</title>
</head>
<body>

<style type=""text/css"">
    * {{ box-sizing: border-box; outline: none; }}
    body {{ padding: 40px; font-family: sans-serif; }}
    h1 {{ color: #2b7a78; margin-bottom: 1em; text-align: center; }}
    hr {{ margin-top: 1em; margin-bottom: 2em; }}
    .block {{ margin-top: 20px; }}
    pre {{ background: #f5f5f5; padding: 12px; border-radius: 6px; white-space: pre-wrap; word-break: break-all; }}
</style>

<h1>–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞</h1>

{sharedBlock}

<div class=""block"">
    <b>–ê–¥–º–∏–Ω –ø–∞–Ω–µ–ª—å</b><br /><br />
    A–¥—Ä–µ—Å: {host}/admin<br />
    –ü–∞—Ä–æ–ª—å: {passwdTxt}
</div>

<hr />

<div class=""block"">
    <div style=""margin-top:10px""> 
        <b>Media Station X</b><br /><br />
        Settings -> Start Parameter -> Setup<br />
        Enter current ip address and port: {HttpContext.Request.Host.Value}<br /><br />
        –£–±—Ä–∞—Ç—å/–î–æ–±–∞–≤–∏—Ç—å –∞–¥—Ä–µ—Å–∞ –º–æ–∂–Ω–æ –≤ /home/lampac/msx.json
    </div>
</div>

<hr />

<div class=""block"">
    <b>–í–∏–¥–∂–µ—Ç –¥–ª—è Samsung</b><br /><br />
    {host}/samsung.wgt
</div>

<hr />

<div class=""block"">
    <b>–î–ª—è android apk</b><br /><br />
    –ó–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∞–∑–∞–¥ –∏ –≤–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –∞–¥—Ä–µ—Å: {host}
</div>

<hr />

<div class=""block"">
    <b>–ü–ª–∞–≥–∏–Ω—ã –¥–ª—è Lampa</b><br /><br />
    –ó–∞—Ö–æ–¥–∏–º –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ - —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è, –∂–º–µ–º –Ω–∞ –∫–Ω–æ–ø–∫—É ""–¥–æ–±–∞–≤–∏—Ç—å –ø–ª–∞–≥–∏–Ω"". –í –æ–∫–Ω–µ –≤–≤–æ–¥–∞ –≤–ø–∏—Å—ã–≤–∞–µ–º –∞–¥—Ä–µ—Å –ø–ª–∞–≥–∏–Ω–∞ {host}/on.js –∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –≤–∏–¥–∂–µ—Ç —É–¥–µ—Ä–∂–∏–≤–∞—è –∫–Ω–æ–ø–∫—É ""–Ω–∞–∑–∞–¥"" –ø–æ–∫–∞ –≤–∏–¥–∂–µ—Ç –Ω–µ –∑–∞–∫—Ä–æ–µ—Ç—Å—è.
</div>

<hr />

<div class=""block"">
    <b>TorrServer (–µ—Å–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω)</b><br /><br />
    {host}/ts
</div>

</body>
</html>";

                    return HttpContext.Response.WriteAsync(htmlSuccesds).ContinueWith(t => Program.Reload());
                    #endregion
                }
            }

            #region renderHtml
            string renderHtml()
			{
				var modules = IO.File.Exists("module/manifest.json") ? JsonConvert.DeserializeObject<List<RootModule>>(IO.File.ReadAllText("module/manifest.json")) : null;

				string IsChecked(string name, string def)
				{
					if (modules == null)
						return def;

                    bool res = modules.FirstOrDefault(m => m.dll == name)?.enable ?? false;
                    return res ? "checked" : string.Empty;
                }

                return $@"
<!DOCTYPE html>
<html>
<head>
    <meta charset=""utf-8"" />
	<title>–ú–æ–¥—É–ª–∏</title>
</head>
<body>

<style type='text/css'>
	* {{
	    box-sizing: border-box;
	    outline: none;
	}}
	body{{
		padding: 40px;
		font-family: sans-serif;
	}}
	label{{
		display: block;
		font-weight: 700;
		margin-bottom: 8px;
	}}
	input,
	select{{
		margin: 10px;
		margin-left: 0px;
	}}
	button{{
		padding: 10px;
	}}
	form > * + *{{
		margin-top: 30px;
	}}
	.flex{{
		display: flex;
		align-items: center;
	}}
</style>

<form method='post' action='/admin/manifest/install' id='form'>
	<div>
		<label>–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ–¥—É–ª–µ–π</label>
		<div class='flex'>
			<input name='online' type='checkbox' {IsChecked("Online.dll", "checked")} /> –û–Ω–ª–∞–π–Ω –±–∞–ª–∞–Ω—Å–µ—Ä—ã Rezka, Filmix, etc
		</div>
		<div class='flex'>
			&nbsp; &nbsp; &nbsp; <input name='eng' type='checkbox' checked /> ENG –±–∞–ª–∞–Ω—Å–µ—Ä—ã
		</div>
		<div class='flex'>
			<input name='sisi' type='checkbox' {IsChecked("SISI.dll", "checked")} /> –ö–ª—É–±–Ω–∏—á–∫–∞ 18+, PornHub, Xhamster, etc
		</div>
		<div class='flex'>
			<input name='catalog' type='checkbox' {IsChecked("Catalog.dll", "checked")} /> –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –∫–∞—Ç–∞–ª–æ–≥–∞ cub –∏ tmdb
		</div>
		<div class='flex'>
			<input name='dlna' type='checkbox' {IsChecked("DLNA.dll", "checked")} /> DLNA - –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤ –∏ –ø—Ä–æ—Å–º–æ—Ç—Ä –º–µ–¥–∏–∞ —Ñ–∞–π–ª–æ–≤ —Å –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ 
		</div>
		<div class='flex'>
			<input name='ts' type='checkbox' {IsChecked("TorrServer.dll", "checked")} /> TorrServer - –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å —Ç–æ—Ä—Ä–µ–Ω—Ç—ã –≤ –æ–Ω–ª–∞–π–Ω 
		</div>
		<div class='flex'>
			<input name='tracks' type='checkbox' {IsChecked("Tracks.dll", "checked")} /> Tracks - —Ç—Ä–∞–Ω—Å–∫–æ–¥–∏–Ω–≥ –≤–∏–¥–µ–æ –∏ –∑–∞–º–µ–Ω–∞ –Ω–∞–∑–≤–∞–Ω–∏–π –∞—É–¥–∏–æ–¥–æ—Ä–æ–∂–µ–∫ —Å rus1, rus2 –Ω–∞ —á–∏—Ç–∞–µ–º—ã–µ LostFilm, HDRezka, etc
		</div>
		<div class='flex'>
			<input name='merch' type='checkbox' {IsChecked("Merchant.dll", "")} /> –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –æ–ø–ª–∞—Ç—ã FreeKassa, Streampay, Litecoin, CryptoCloud
		</div>

		<br><br>
		<label>–ü–æ–∏—Å–∫ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤</label>
		<div class='flex'>
			<input name='jac' type='radio' value='webapi' checked /> –ë—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ –ø–æ –≤–Ω–µ—à–Ω–∏–º –±–∞–∑–∞–º JacRed, Rutor, Kinozal, NNM-Club, Rutracker, etc
		</div>
		<div class='flex'>
			<input name='jac' type='radio' value='fdb' /> –õ–æ–∫–∞–ª—å–Ω—ã–π jacred.xyz (–Ω–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —Å—Ç–∞–≤–∏—Ç—å –Ω–∞ –¥–æ–º–∞—à–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞) - 2GB HDD
		</div>
	</div>
	
	<button type='submit'>{(isEditManifest ? "–ò–∑–º–µ–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏" : "–ó–∞–≤–µ—Ä—à–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É")}</button></form></body></html>";
            }
            #endregion

            return HttpContext.Response.WriteAsync(renderHtml());
        }
        #endregion


        #region UpdateInitConf
        void UpdateInitConf(Action<JObject> modify)
        {
            JObject jo;

            if (IO.File.Exists("init.conf"))
            {
                string initconf = IO.File.ReadAllText("init.conf").Trim();
                if (string.IsNullOrEmpty(initconf))
                    jo = new JObject();

                else
                {
                    if (!initconf.StartsWith("{"))
                        initconf = "{" + initconf + "}";

                    try
                    {
                        jo = JsonConvert.DeserializeObject<JObject>(initconf) ?? new JObject();
                    }
                    catch
                    {
                        jo = new JObject();
                    }
                }
            }
            else
            {
                jo = new JObject();
            }

            modify?.Invoke(jo);

            IO.File.WriteAllText("init.conf", JsonConvert.SerializeObject(jo, Formatting.Indented));
        }
        #endregion

        #region IsLocalIp
        bool IsLocalIp(string ip)
        {
            if (string.IsNullOrWhiteSpace(ip))
                return false;

            // –ï—Å–ª–∏ ip –ø—Ä–∏—Ö–æ–¥–∏—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ IPv4-mapped IPv6 (::ffff:192.168.0.1)
            var lastColon = ip.LastIndexOf(':');
            if (lastColon != -1 && ip.Contains("."))
                ip = ip.Substring(lastColon + 1);

            if (!System.Net.IPAddress.TryParse(ip, out var addr))
                return false;

            // loopback (127.0.0.0/8 –∏ ::1)
            if (System.Net.IPAddress.IsLoopback(addr))
                return true;

            if (addr.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork) // IPv4
            {
                var b = addr.GetAddressBytes(); // [a,b,c,d]
                                                // 10.0.0.0/8
                if (b[0] == 10) return true;
                // 127.0.0.0/8
                if (b[0] == 127) return true;
                // 192.168.0.0/16
                if (b[0] == 192 && b[1] == 168) return true;
                // 172.16.0.0/12  => 172.16.0.0 - 172.31.255.255
                if (b[0] == 172 && b[1] >= 16 && b[1] <= 31) return true;

                return false;
            }

            if (addr.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6) // IPv6
            {
                var b = addr.GetAddressBytes();
                // unique local fc00::/7 (first byte 0xfc or 0xfd)
                if ((b[0] & 0xfe) == 0xfc) return true;
                // ::1 handled by IsLoopback above
                return false;
            }

            return false;
        }
        #endregion
    }
}
```

## File: Lampac/Controllers/WebLogController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Shared;

namespace Lampac.Controllers
{
    public class WebLogController : BaseController
    {
        [HttpGet]
        [AllowAnonymous]
        [Route("weblog")]
        public ActionResult WebLog(string token, string pattern, string receive = "http")
        {
            if (!AppInit.conf.weblog.enable)
                return Content("–í–∫–ª—é—á–∏—Ç–µ weblog –≤ init.conf\n\n\"weblog\": {\n   \"enable\": true\n}", contentType: "text/plain; charset=utf-8");

            if (!string.IsNullOrEmpty(AppInit.conf.weblog.token) && token != AppInit.conf.weblog.token)
                return Content("–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /weblog?token=my_key\n\n\"weblog\": {\n   \"enable\": true,\n   \"token\": \"my_key\"\n}", contentType: "text/plain; charset=utf-8");

            string html = $@"<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>weblog</title>
    <style>
        details summary {{
          font-weight: bold;
          font-size: 1.2em;
          color: #2772d2;
          cursor: pointer;
          list-style: none;
          user-select: none;
          position: relative;
        }}

        details summary:hover {{
          color: #1a4bb8;
        }}
    </style>
</head>
<body style='margin: 0px;'>
    <div id='controls' style='margin-bottom: 1em; background: #f0f0f0; padding: 10px; border-bottom: 1px solid #ccc;'>
        <label style='margin-right: 20px;'>–ó–∞–ø—Ä–æ—Å—ã:
            <select id='receiveSelect' style='padding: 0px 5px 0px 0px;'>
                <option value='http' {(receive == "http" ? "selected" : "")}>–ò—Å—Ö–æ–¥—è—â–∏–µ</option>
                <option value='request' {(receive == "request" ? "selected" : "")}>–í—Ö–æ–¥—è—â–∏–µ</option>
            </select>
        </label>
        <label for='patternInput'>–§–∏–ª—å—Ç—Ä: </label>
        <input type='text' id='patternInput' placeholder='rezka.ag' value='{pattern ?? ""}' style='margin-right: 20px;' />
    </div>
    <div id='log'></div>
    <script src='/js/nws-client-es5.js'></script>
    <script src='/signalr-6.0.25_es5.js'></script>
    <script>
        let pattern = document.getElementById('patternInput').value.trim();
        let receive = document.getElementById('receiveSelect').value;

        document.getElementById('patternInput').addEventListener('input', e => {{
            pattern = e.target.value.trim();
        }});
        document.getElementById('receiveSelect').addEventListener('change', e => {{
            receive = e.target.value;
        }});

        function send(message) {{
            if (pattern && message.indexOf(pattern) === -1) return;

            var messageHtml = message.replace(/</g, '&lt;').replace(/>/g, '&gt;');

            const markers = [
              {{ text: 'CurrentUrl: ', caseSensitive: true }},
              {{ text: 'StatusCode: ', caseSensitive: true }},
              {{ text: '&lt;!doctype html&gt;', caseSensitive: false }}
            ];

            for (const marker of markers) {{
              let searchText = marker.text;
              let messageText = messageHtml;
  
              if (!marker.caseSensitive)
                messageText = messageHtml.toLowerCase();
  
              const index = messageText.indexOf(searchText);
              if (index !== -1) {{
                messageHtml = messageHtml.slice(0, index) 
                  + '<details><summary>–ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ</summary>'
                  + messageHtml.slice(index) 
                  + '</details>';
                break;
              }}
            }}

            var par = document.getElementById('log');

            let messageElement = document.createElement('hr');
            messageElement.style.cssText = ' margin-bottom: 2.5em; margin-top: 2.5em;';
            par.insertBefore(messageElement, par.children[0]);

            messageElement = document.createElement('pre');
            messageElement.style.cssText = 'padding: 10px; background: cornsilk; white-space: pre-wrap; word-wrap: break-word;';
            if (messageHtml.indexOf('<details>') !== -1)
                messageElement.innerHTML = messageHtml;
            else 
                messageElement.innerText = message;
            par.insertBefore(messageElement, par.children[0]);
        }}


        let outageReported = false;
        function reportOutageOnce(message) {{
            if (!outageReported) {{
                send(message);
                outageReported = true;
            }}
        }}

        {(AppInit.conf.rch.websoket == "signalr" ? signalCode(token) : nwsCode(token))}
    </script>
</body>
</html>";

            return Content(html, "text/html; charset=utf-8");
        }


        static string nwsCode(string token) => $@"
const client = new NativeWsClient(""/nws"", {{
    autoReconnect: true,
    reconnectDelay: 2000,

    onOpen: function () {{
        send('WebSocket connected');
        outageReported = false;
        client.invoke('RegistryWebLog', '{token}');
    }},

    onClose: function () {{
        reportOutageOnce('Connection closed');
    }},

    onError: function (err) {{
        reportOutageOnce('Connection error: ' + (err && err.message ? err.message : String(err)));
    }}
}});

client.on('Receive', function (message, e) {{
    if (receive === e) send(message);
}});

client.connect();
";

        static string signalCode(string token) => $@"
const hubConnection = new signalR.HubConnectionBuilder()
    .withUrl('/ws')
    .build();

let reconnectAttempts = 0;
const maxReconnectAttempts = 150; // 5 minutes
const reconnectDelay = 2000;      // 2 seconds

function startConnection() {{
    hubConnection.start()
        .then(function () {{
            if (reconnectAttempts != 0)
                send('WebSocket connected');
            reconnectAttempts = 0; // Reset counter on successful connection
            hubConnection.invoke('RegistryWebLog', '{token}');
        }})
        .catch(function (err) {{
            console.log(`${{err.toString()}}\n\nAttempting to reconnect (${{reconnectAttempts}}/${{maxReconnectAttempts}})...`);
            attemptReconnect();
        }});
}}

function attemptReconnect() {{
    if (reconnectAttempts < maxReconnectAttempts) {{
        reconnectAttempts++;
        setTimeout(function() {{
            startConnection();
        }}, reconnectDelay);
    }} else {{
        send('Max reconnection attempts reached. Please refresh the page.');
    }}
}}

hubConnection.on('Receive', function(message, e) {{
    if(receive === e) send(message);
}});

hubConnection.onclose(function(err) {{
    if (err) {{
        send('Connection closed due to error: ' + err.toString());
    }} else {{
        send('Connection closed');
    }}
    attemptReconnect();
}});

startConnection();
";
    }
}
```

## File: Lampac/Controllers/OpenStatController.cs
```
Ôªøusing Lampac.Engine;
using Lampac.Engine.Middlewares;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Shared;
using Shared.Engine;
using Shared.Models.AppConf;
using Shared.PlaywrightCore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.NetworkInformation;

namespace Lampac.Controllers
{
    public class OpenStatController : BaseController
    {
        public OpenStatConf openstat => AppInit.conf.openstat;

        public bool IsDeny(out string ermsg) 
        {
            ermsg = "–í–∫–ª—é—á–∏—Ç–µ openstat –≤ init.conf\n\n\"openstat\": {\n   \"enable\": true\n}";

            if (!openstat.enable || (!string.IsNullOrEmpty(openstat.token) && openstat.token != HttpContext.Request.Query["token"].ToString()))
                return true;

            return false;
        }

        #region browser/context
        [AllowAnonymous]
        [Route("/stats/browser/context")]
        public ActionResult BrowserContext()
        {
            if (IsDeny(out string ermsg))
                return Content(ermsg, "text/plain; charset=utf-8");

            return Json(new
            {
                Chromium = new
                {
                    open = Chromium.ContextsCount,
                    req_keepopen = Chromium.stats_keepopen,
                    req_newcontext = Chromium.stats_newcontext,
                    ping = new 
                    {
                        Chromium.stats_ping.status,
                        Chromium.stats_ping.time,
                        Chromium.stats_ping.ex
                    }
                },
                Firefox = new
                {
                    open = Firefox.ContextsCount,
                    req_keepopen = Firefox.stats_keepopen,
                    req_newcontext = Firefox.stats_newcontext
                }
            });
        }
        #endregion

        #region request
        [AllowAnonymous]
        [Route("/stats/request")]
        public ActionResult Requests()
        {
            if (IsDeny(out string ermsg))
                return Content(ermsg, "text/plain; charset=utf-8");

            long req_min = memoryCache.Get<long>($"stats:request:{DateTime.Now.AddMinutes(-1).Minute}");

            long req_hour = req_min;
            for (int i = 1; i < 58; i++)
            {
                if (memoryCache.TryGetValue($"stats:request:{DateTime.Now.AddMinutes(-i).Minute}", out long _r))
                    req_hour += _r;
            }

            var responseStats = RequestStatisticsTracker.GetResponseTimeStatsLastMinute();

            var httpResponseMs = new Dictionary<string, object>
            {
                ["avg"] = Math.Round(responseStats.Average, 2)
            };

            foreach (var percentile in responseStats.PercentileAverages.OrderBy(x => x.Key))
                httpResponseMs.Add(percentile.Key.ToString(), Math.Round(percentile.Value, 2));

            return Json(new
            {
                req_min,
                req_hour,
                tcpConnections = IPGlobalProperties.GetIPGlobalProperties().GetActiveTcpConnections().Length,
                nws_online = nws.ConnectionCount,
                soks_online = soks.connections,
                http_active = RequestStatisticsTracker.ActiveHttpRequests,
                http_response_ms = httpResponseMs
            });
        }
        #endregion

        #region rch
        [AllowAnonymous]
        [Route("/stats/rch")]
        public ActionResult Rhc()
        {
            if (IsDeny(out string ermsg))
                return Content(ermsg, "text/plain; charset=utf-8");

            return Json(new { clients = RchClient.clients.Count, rchIds = RchClient.rchIds.Count });
        }
        #endregion
    }
}
```

## File: Lampac/Controllers/CubController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Shared;
using Shared.Engine;
using System.Web;

namespace Lampac.Controllers
{
    public class CubController : BaseController
    {
        [HttpGet]
        [AllowAnonymous]
        [Route("cubproxy.js")]
        [Route("cubproxy/js/{token}")]
        public ActionResult CubProxy(string token)
        {
            if (!AppInit.conf.cub.enabled(requestInfo.Country))
                return Content(string.Empty, contentType: "application/javascript; charset=utf-8");

            string file = FileCache.ReadAllText("plugins/cubproxy.js").Replace("{localhost}", host);
            file = file.Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(file, contentType: "application/javascript; charset=utf-8");
        }
    }
}
```

## File: Lampac/Controllers/TmdbController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Shared;
using Shared.Engine;
using System.Web;

namespace Lampac.Controllers
{
    public class TmdbController : BaseController
    {
        [HttpGet]
        [AllowAnonymous]
        [Route("tmdbproxy.js")]
        [Route("tmdbproxy/js/{token}")]
        public ActionResult TmdbProxy(string token)
        {
            string file = FileCache.ReadAllText("plugins/tmdbproxy.js").Replace("{localhost}", host);
            file = file.Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(file, contentType: "application/javascript; charset=utf-8");
        }
    }
}
```

## File: Lampac/Engine/soks.cs
```
Ôªøusing Microsoft.AspNetCore.SignalR;
using Shared;
using Shared.Engine;
using Shared.Models;
using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading.Tasks;

namespace Lampac.Engine
{
    public class soks : Hub, ISoks
    {
        #region soks
        public static int connections { get; private set; }

        public static IHubCallerClients hubClients = null;

        public IHubCallerClients AllClients => hubClients;
        #endregion

        #region Rch
        public void RchRegistry(string json)
        {
            if (!AppInit.conf.rch.enable)
                return;

            var httpContext = Context.GetHttpContext();
            var requestInfo = httpContext.Features.Get<RequestModel>();
            RchClient.Registry(requestInfo.IP, Context.ConnectionId, AppInit.Host(httpContext), json);
        }

        public void RchResult(string id, string value)
        {
            if (!AppInit.conf.rch.enable)
                return;

            if (RchClient.rchIds.TryGetValue(id, out var tcs))
                tcs.SetResult(value ?? string.Empty);
        }
        #endregion

        #region WebLog
        public static ConcurrentDictionary<string, byte> weblog_clients = new ConcurrentDictionary<string, byte>();

        public void RegistryWebLog(string token)
        {
            if (AppInit.conf.weblog.enable)
            {
                if (string.IsNullOrEmpty(AppInit.conf.weblog.token) || AppInit.conf.weblog.token == token)
                {
                    weblog_clients.AddOrUpdate(Context.ConnectionId, 0, (k, v) => 0);
                    return;
                }
            }
        }

        public void WebLog(string message, string plugin) => SendLog(message, plugin);

        public static void SendLog(string message, string plugin)
        {
            if (!AppInit.conf.weblog.enable || hubClients == null || string.IsNullOrEmpty(message) || string.IsNullOrEmpty(plugin) || message.Length > 4_000000)
                return;

            if (weblog_clients.Count > 0)
                hubClients.Clients(weblog_clients.Keys).SendAsync("Receive", message, plugin).ConfigureAwait(false);
        }
        #endregion

        #region Events
        static ConcurrentDictionary<string, string> event_clients = new ConcurrentDictionary<string, string>();

        public void RegistryEvent(string uid)
        {
            if (string.IsNullOrEmpty(uid))
                return;

            event_clients.AddOrUpdate(Context.ConnectionId, uid, (k,v) => uid);
        }

        /// <summary>
        /// –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π —á–µ—Ä–µ–∑ js
        /// </summary>
        /// <param name="uid"></param>
        /// <param name="name"></param>
        /// <param name="data"></param>
        public async Task events(string uid, string name, string data)
        {
            if (hubClients == null || string.IsNullOrEmpty(uid) || string.IsNullOrEmpty(name) || (data != null && data.Length > 10_000000))
                return;

            try
            {
                var clients = event_clients.Where(i => i.Value == uid && i.Key != Context.ConnectionId);
                if (clients.Any())
                    await hubClients.Clients(clients.Select(i => i.Key)).SendAsync("event", uid, name, data ?? string.Empty).ConfigureAwait(false);
            }
            catch { }
        }

        public async Task eventsId(string connectionId, string uid, string name, string data)
        {
            if (hubClients == null || string.IsNullOrEmpty(connectionId) || string.IsNullOrEmpty(name) || (data != null && data.Length > 10_000000))
                return;

            try
            {
                var clients = event_clients.Where(i => i.Key == connectionId);
                if (clients.Any())
                    await hubClients.Clients(clients.Select(i => i.Key)).SendAsync("event", uid ?? string.Empty, name, data ?? string.Empty).ConfigureAwait(false);
            }
            catch { }
        }

        public Task EventsAsync(string connectionId, string uid, string name, string data) => SendEvents(connectionId, uid, name, data);

        /// <summary>
        /// –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π —á–µ—Ä–µ–∑ —Å–µ—Ä–≤–µ—Ä
        /// </summary>
        /// <param name="connectionId"></param>
        /// <param name="uid"></param>
        /// <param name="name"></param>
        /// <param name="data"></param>
        async public static Task SendEvents(string connectionId, string uid, string name, string data)
        {
            if (hubClients == null || string.IsNullOrEmpty(uid) || string.IsNullOrEmpty(name) || (data != null && data.Length > 10_000000))
                return;

            try
            {
                var clients = event_clients.Where(i => i.Value == uid && i.Key != connectionId);
                if (clients.Any())
                    await hubClients.Clients(clients.Select(i => i.Key)).SendAsync("event", uid, name, data ?? string.Empty).ConfigureAwait(false);
            }
            catch { }
        }
        #endregion

        #region Connected / Disconnected
        public override Task OnConnectedAsync()
        {
            hubClients = Clients;
            connections++;

            return base.OnConnectedAsync();
        }

        public override Task OnDisconnectedAsync(Exception exception)
        {
            weblog_clients.TryRemove(Context.ConnectionId, out _);
            event_clients.TryRemove(Context.ConnectionId, out _);
            RchClient.OnDisconnected(Context.ConnectionId);

            hubClients = Clients;
            connections--;

            return base.OnDisconnectedAsync(exception);
        }
        #endregion


        public static void FullDispose()
        {
        }
    }
}

```

## File: Lampac/Engine/DynamicActionDescriptorChangeProvider.cs
```
using Microsoft.AspNetCore.Mvc.Infrastructure;
using Microsoft.Extensions.Primitives;
using System.Threading;

namespace Lampac.Engine
{
    public class DynamicActionDescriptorChangeProvider : IActionDescriptorChangeProvider
    {
        public static DynamicActionDescriptorChangeProvider Instance { get; } = new DynamicActionDescriptorChangeProvider();

        private CancellationTokenSource tokenSource = new CancellationTokenSource();
        public CancellationTokenSource TokenSource => tokenSource;

        public IChangeToken GetChangeToken() => new CancellationChangeToken(tokenSource.Token);

        public void NotifyChanges()
        {
            var previous = Interlocked.Exchange(ref tokenSource, new CancellationTokenSource());
            previous.Cancel();
        }
    }
}

```

## File: Lampac/Engine/nws.cs
```
using Microsoft.AspNetCore.Http;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Events;
using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine
{
    public class nws : INws
    {
        #region fields
        static readonly JsonSerializerOptions serializerOptions = new JsonSerializerOptions
        {
            WriteIndented = false
        };

        public static readonly ConcurrentDictionary<string, NwsConnection> _connections = new ConcurrentDictionary<string, NwsConnection>();

        static readonly Timer ConnectionMonitorTimer = new Timer(ConnectionMonitorCallback, null, TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1));

        public readonly static ConcurrentDictionary<string, byte> weblog_clients = new ConcurrentDictionary<string, byte>();

        public readonly static ConcurrentDictionary<string, string> event_clients = new ConcurrentDictionary<string, string>();

        public static int ConnectionCount => _connections.Count;
        #endregion

        #region interface
        public void WebLog(string message, string plugin) => SendLog(message, plugin);

        public Task EventsAsync(string connectionId, string uid, string name, string data) => SendEvents(connectionId, uid, name, data);

        public Task SendAsync(string connectionId, string method, params object[] args)
        {
            if (connectionId != null && _connections.TryGetValue(connectionId, out var client))
                return SendAsync(client, method, args);

            return Task.CompletedTask;
        }

        public ConcurrentDictionary<string, NwsConnection> AllConnections() => _connections;
        #endregion

        #region handle
        public static async Task HandleWebSocketAsync(HttpContext context)
        {
            if (!context.WebSockets.IsWebSocketRequest)
            {
                context.Response.StatusCode = StatusCodes.Status400BadRequest;
                return;
            }

            using (var socket = await context.WebSockets.AcceptWebSocketAsync().ConfigureAwait(false))
            {
                string connectionId = Guid.NewGuid().ToString("N");

                if (context.Request.Query.TryGetValue("id", out var _connectionId) && !string.IsNullOrEmpty(_connectionId.ToString()))
                {
                    connectionId = _connectionId.ToString();
                    Cleanup(connectionId);
                }

                try
                {
                    var requestInfo = context.Features.Get<RequestModel>();
                    string ip = requestInfo.IP ?? context.Connection.RemoteIpAddress?.ToString();

                    var connection = new NwsConnection(connectionId, socket, AppInit.Host(context), ip, requestInfo.UserAgent);

                    var cancellationSource = CancellationTokenSource.CreateLinkedTokenSource(context.RequestAborted);
                    connection.SetCancellationSource(cancellationSource);

                    _connections.AddOrUpdate(connectionId, connection, (k, v) => connection);

                    await SendAsync(connection, "Connected", connectionId).ConfigureAwait(false);

                    InvkEvent.NwsConnected(new EventNwsConnected(connectionId, ip, requestInfo, connection, cancellationSource.Token));

                    await ReceiveLoopAsync(connection, cancellationSource.Token).ConfigureAwait(false);
                }
                finally
                {
                    Cleanup(connectionId);
                    InvkEvent.NwsDisconnected(new EventNwsDisconnected(connectionId));
                }
            }
        }
        #endregion

        #region receive loop
        static async Task ReceiveLoopAsync(NwsConnection connection, CancellationToken token)
        {
            WebSocket socket = connection.Socket;
            var buffer = ArrayPool<byte>.Shared.Rent(4096);
            var builder = new StringBuilder();

            try
            {
                while (socket.State == WebSocketState.Open && !token.IsCancellationRequested)
                {
                    builder.Clear();

                    WebSocketReceiveResult result;

                    do
                    {
                        result = await socket.ReceiveAsync(new ArraySegment<byte>(buffer), token).ConfigureAwait(false);

                        if (result.MessageType == WebSocketMessageType.Close)
                        {
                            using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(20)))
                                await socket.CloseAsync(result.CloseStatus ?? WebSocketCloseStatus.NormalClosure, result.CloseStatusDescription, cts.Token).ConfigureAwait(false);
                            return;
                        }

                        if (result.Count > 0)
                        {
                            builder.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));
                            if (builder.Length > 10_000000)
                            {
                                using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(20)))
                                    await socket.CloseAsync(WebSocketCloseStatus.MessageTooBig, "payload too large", cts.Token).ConfigureAwait(false);
                                return;
                            }
                        }
                    }
                    while (!result.EndOfMessage);

                    connection.UpdateActivity();

                    if (result.MessageType == WebSocketMessageType.Text)
                    {
                        string message = builder.ToString();
                        builder.Clear();

                        if (!string.IsNullOrWhiteSpace(message) && message != "ping")
                            await HandleMessageAsync(connection, message).ConfigureAwait(false);
                    }
                }
            }
            catch (OperationCanceledException)
            {
            }
            catch (WebSocketException)
            {
            }
            catch (Exception)
            {
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
                builder.Clear();
            }
        }
        #endregion

        #region message handling
        static async Task HandleMessageAsync(NwsConnection connection, string payload)
        {
            try
            {
                using JsonDocument document = JsonDocument.Parse(payload);
                if (document.RootElement.ValueKind != JsonValueKind.Object)
                    return;

                if (!document.RootElement.TryGetProperty("method", out var methodProp))
                    return;

                string method = methodProp.GetString();
                JsonElement args = default;

                if (document.RootElement.TryGetProperty("args", out var argsProp) && argsProp.ValueKind == JsonValueKind.Array)
                    args = argsProp;

                InvkEvent.NwsMessage(new EventNwsMessage(connection.ConnectionId, payload, method, args));

                await InvokeAsync(connection, method, args).ConfigureAwait(false);
            }
            catch (JsonException)
            {
            }
        }

        static async Task InvokeAsync(NwsConnection connection, string method, JsonElement args)
        {
            if (string.IsNullOrEmpty(method))
                return;

            switch (method.ToLower())
            {
                case "rchregistry":
                    if (AppInit.conf.rch.enable)
                    {
                        string json = GetStringArg(args, 0);
                        RchClient.Registry(connection.Ip, connection.ConnectionId, connection.Host, json, connection);
                        await SendAsync(connection, "RchRegistry", connection.Ip).ConfigureAwait(false);
                    }
                    break;

                case "rchresult":
                    if (AppInit.conf.rch.enable)
                    {
                        string id = GetStringArg(args, 0);
                        string value = GetStringArg(args, 1) ?? string.Empty;

                        if (!string.IsNullOrEmpty(id) && RchClient.rchIds.TryGetValue(id, out var tcs))
                            tcs.TrySetResult(value);
                    }
                    break;

                case "registryweblog":
                    if (AppInit.conf.weblog.enable)
                    {
                        string token = GetStringArg(args, 0);
                        if (string.IsNullOrEmpty(AppInit.conf.weblog.token) || AppInit.conf.weblog.token == token)
                            weblog_clients.AddOrUpdate(connection.ConnectionId, 0, static (_, __) => 0);
                    }
                    break;

                case "weblog":
                    SendLog(GetStringArg(args, 0), GetStringArg(args, 1));
                    break;

                case "registryevent":
                {
                    string uid = GetStringArg(args, 0);
                    if (!string.IsNullOrEmpty(uid))
                        event_clients.AddOrUpdate(connection.ConnectionId, uid, (_, __) => uid);
                    break;
                }

                case "events":
                {
                    string uid = GetStringArg(args, 0);
                    string name = GetStringArg(args, 1);
                    string data = GetStringArg(args, 2);

                    if (name == "devices")
                    {
                        var evc = event_clients.Where(i => i.Value == uid).ToArray();

                        var devices = _connections
                            .Where(i => i.Value.ConnectionId != connection.ConnectionId)
                            .Where(i => i.Value.Ip == connection.Ip || event_clients.Values.Contains(uid))
                            .Select(i => new {
                                uid = event_clients.TryGetValue(i.Value.ConnectionId, out var _uid) ? _uid : null, 
                                i.Value.ConnectionId, 
                                i.Value.UserAgent
                            })
                            .ToArray();

                        await SendAsync(connection, "event", uid, name, devices).ConfigureAwait(false);
                        break;
                    }

                    await SendEvents(connection.ConnectionId, uid, name, data).ConfigureAwait(false);
                    break;
                }

                case "eventsid":
                {
                    string targetConnection = GetStringArg(args, 0);
                    string uid = GetStringArg(args, 1);
                    string name = GetStringArg(args, 2);
                    string data = GetStringArg(args, 3);
                    await SendEventToConnection(targetConnection, uid, name, data).ConfigureAwait(false);
                    break;
                }

                case "ping":
                    await SendAsync(connection, "pong").ConfigureAwait(false);
                    break;
            }
        }

        static string GetStringArg(JsonElement args, int index)
        {
            if (args.ValueKind != JsonValueKind.Array || args.GetArrayLength() <= index)
                return null;

            var element = args[index];
            if (element.ValueKind == JsonValueKind.String)
                return element.GetString();

            if (element.ValueKind == JsonValueKind.Null)
                return null;

            return element.ToString();
        }
        #endregion

        #region SendAsync
        static async Task SendAsync(NwsConnection connection, string method, params object[] args)
        {
            if (connection.Socket.State != WebSocketState.Open || string.IsNullOrEmpty(method))
                return;

            var payload = new { method, args = args ?? Array.Empty<object>() };
            byte[] bytes;

            try
            {
                bytes = Encoding.UTF8.GetBytes(JsonSerializer.Serialize(payload, serializerOptions));
            }
            catch
            {
                return;
            }

            try
            {
                await connection.SendLock.WaitAsync(TimeSpan.FromSeconds(20)).ConfigureAwait(false);

                if (connection.Socket.State == WebSocketState.Open)
                {
                    using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10)))
                        await connection.Socket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, cts.Token).ConfigureAwait(false);

                    connection.UpdateActivity();
                }
            }
            catch (WebSocketException)
            {
            }
            catch (OperationCanceledException)
            {
            }
            finally
            {
                connection.SendLock.Release();
            }
        }

        public static void SendLog(string message, string plugin)
        {
            if (!AppInit.conf.weblog.enable || string.IsNullOrEmpty(message) || string.IsNullOrEmpty(plugin) || message.Length > 4_000000)
                return;

            if (weblog_clients.IsEmpty)
                return;

            foreach (string connectionId in weblog_clients.Keys)
            {
                if (_connections.TryGetValue(connectionId, out var client))
                    _ = SendAsync(client, "Receive", message, plugin).ConfigureAwait(false);
            }
        }

        public static Task SendEvents(string connectionId, string uid, string name, string data)
        {
            if (string.IsNullOrEmpty(uid) || string.IsNullOrEmpty(name))
                return Task.CompletedTask;

            var targets = event_clients.Where(i => i.Value == uid && (connectionId == null || i.Key != connectionId)).Select(i => i.Key).ToArray();
            if (targets.Length == 0)
                return Task.CompletedTask;

            var tasks = new List<Task>(targets.Length);
            foreach (string targetId in targets)
            {
                if (_connections.TryGetValue(targetId, out var client))
                    tasks.Add(SendAsync(client, "event", uid, name, data ?? string.Empty));
            }

            if (tasks.Count == 0)
                return Task.CompletedTask;

            return Task.WhenAll(tasks);
        }

        static Task SendEventToConnection(string connectionId, string uid, string name, string data)
        {
            if (string.IsNullOrEmpty(connectionId) || string.IsNullOrEmpty(name))
                return Task.CompletedTask;

            if (_connections.TryGetValue(connectionId, out var client))
                return SendAsync(client, "event", uid ?? string.Empty, name, data ?? string.Empty);

            return Task.CompletedTask;
        }

        public static Task SendRchRequestAsync(string connectionId, string rchId, string url, string data, Dictionary<string, string> headers, bool returnHeaders)
        {
            if (string.IsNullOrEmpty(connectionId))
                return Task.CompletedTask;

            if (_connections.TryGetValue(connectionId, out var client))
                return SendAsync(client, "RchClient", rchId, url, data, headers, returnHeaders);

            return Task.CompletedTask;
        }
        #endregion

        #region cleanup
        public static void Cleanup(string connectionId)
        {
            if (string.IsNullOrEmpty(connectionId))
                return;

            if (_connections.TryRemove(connectionId, out var connection))
            {
                connection.Cancel();
                connection.Dispose();
            }

            weblog_clients.TryRemove(connectionId, out _);
            event_clients.TryRemove(connectionId, out _);
            RchClient.OnDisconnected(connectionId);
        }
        #endregion

        #region ConnectionMonitorCallback
        static void ConnectionMonitorCallback(object state)
        {
            try
            {
                if (_connections.IsEmpty)
                    return;

                foreach (string connectionId in _connections.Select(kv => kv.Key).ToArray())
                {
                    if (_connections.TryGetValue(connectionId, out var connection))
                    {
                        if (DateTime.UtcNow.AddMinutes(-2) >= connection.LastActivityUtc)
                            connection.Cancel();
                    }
                }
            }
            catch
            {
            }
        }
        #endregion


        #region FullDispose
        public static void FullDispose()
        {
            ConnectionMonitorTimer.Dispose();
            foreach (var connection in _connections)
                connection.Value.Cancel();
        }
        #endregion
    }
}

```

## File: Lampac/Engine/Middlewares/ProxyCub.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Models;
using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class ProxyCub
    {
        #region ProxyCub
        static FileSystemWatcher fileWatcher;

        static ConcurrentDictionary<string, byte> cacheFiles = new ConcurrentDictionary<string, byte>();

        static Timer cleanupTimer;

        static ProxyCub() 
        {
            Directory.CreateDirectory("cache/cub");

            foreach (var item in Directory.EnumerateFiles("cache/cub", "*"))
                cacheFiles.TryAdd(Path.GetFileName(item), 0);

            fileWatcher = new FileSystemWatcher
            {
                Path = "cache/cub",
                NotifyFilter = NotifyFilters.FileName,
                EnableRaisingEvents = true
            };

            fileWatcher.Created += (s, e) => { cacheFiles.TryAdd(e.Name, 0); };
            fileWatcher.Deleted += (s, e) => { cacheFiles.TryRemove(e.Name, out _); };

            cleanupTimer = new Timer(cleanup, null, TimeSpan.FromMinutes(30), TimeSpan.FromMinutes(30));
        }

        static void cleanup(object state)
        {
            try
            {
                var files = Directory.GetFiles("cache/cub", "*").Select(f => Path.GetFileName(f)).ToHashSet();

                foreach (string md5fileName in cacheFiles.Keys.ToArray())
                {
                    if (!files.Contains(md5fileName))
                        cacheFiles.TryRemove(md5fileName, out _);
                }
            }
            catch { }
        }

        public ProxyCub(RequestDelegate next) { }
        #endregion

        async public Task InvokeAsync(HttpContext httpContext, IMemoryCache memoryCache)
        {
            using (var ctsHttp = CancellationTokenSource.CreateLinkedTokenSource(httpContext.RequestAborted))
            {
                ctsHttp.CancelAfter(TimeSpan.FromSeconds(90));

                var hybridCache = new HybridCache();
                var requestInfo = httpContext.Features.Get<RequestModel>();

                var init = AppInit.conf.cub;
                string domain = init.domain;
                string path = httpContext.Request.Path.Value.Replace("/cub/", "");
                string query = httpContext.Request.QueryString.Value;
                string uri = Regex.Match(path, "^[^/]+/(.*)").Groups[1].Value + query;

                if (!init.enable || domain == "ws")
                {
                    httpContext.Response.Redirect($"https://{path}/{query}");
                    return;
                }

                if (path.Split(".")[0] is "geo" or "tmdb" or "tmapi" or "apitmdb" or "imagetmdb" or "cdn" or "ad" or "ws")
                    domain = $"{path.Split(".")[0]}.{domain}";

                if (domain.StartsWith("geo"))
                {
                    string country = requestInfo.Country;
                    if (string.IsNullOrEmpty(country))
                    {
                        var ipify = await Http.Get<JObject>("https://api.ipify.org/?format=json");
                        if (ipify != null || !string.IsNullOrEmpty(ipify.Value<string>("ip")))
                            country = GeoIP2.Country(ipify.Value<string>("ip"));
                    }

                    await httpContext.Response.WriteAsync(country ?? "", ctsHttp.Token);
                    return;
                }

                #region checker
                if (path.StartsWith("api/checker") || uri.StartsWith("api/checker"))
                {
                    if (HttpMethods.IsPost(httpContext.Request.Method))
                    {
                        if (httpContext.Request.ContentType != null &&
                            httpContext.Request.ContentType.StartsWith("application/x-www-form-urlencoded", StringComparison.OrdinalIgnoreCase))
                        {
                            using (var reader = new StreamReader(httpContext.Request.Body, leaveOpen: true))
                            {
                                string form = await reader.ReadToEndAsync();

                                var match = Regex.Match(form, @"(?:^|&)data=([^&]+)");
                                if (match.Success)
                                {
                                    string dataValue = Uri.UnescapeDataString(match.Groups[1].Value);
                                    await httpContext.Response.WriteAsync(dataValue, ctsHttp.Token);
                                    return;
                                }
                            }
                        }
                    }

                    await httpContext.Response.WriteAsync("ok", ctsHttp.Token);
                    return;
                }
                #endregion

                #region blacklist
                if (uri.StartsWith("api/plugins/blacklist"))
                {
                    httpContext.Response.ContentType = "application/json; charset=utf-8";
                    await httpContext.Response.WriteAsync("[]", ctsHttp.Token);
                    return;
                }
                #endregion

                #region ads/log/metric
                if (uri.StartsWith("api/metric/") || uri.StartsWith("api/ad/stat"))
                {
                    await httpContext.Response.WriteAsJsonAsync(new { secuses = true });
                    return;
                }

                if (uri.StartsWith("api/ad/vast"))
                {
                    await httpContext.Response.WriteAsJsonAsync(new 
                    { 
                        secuses = true,
                        ad = new string[] { },
                        day_of_month = DateTime.Now.Day,
                        days_in_month =  31,
                        month = DateTime.Now.Month
                    });
                    return;
                }
                #endregion

                var proxyManager = new ProxyManager("cub_api", init);
                var proxy = proxyManager.Get();

                bool isMedia = Regex.IsMatch(uri, "\\.(jpe?g|png|gif|webp|ico|svg|mp4|js|css)");

                if (0 >= init.cache_api || !HttpMethods.IsGet(httpContext.Request.Method) || isMedia ||
                    (path.Split(".")[0] is "imagetmdb" or "cdn" or "ad") ||
                    httpContext.Request.Headers.ContainsKey("token") || httpContext.Request.Headers.ContainsKey("profile"))
                {
                    #region bypass
                    string md5key = CrypTo.md5($"{domain}:{uri}");
                    string outFile = Path.Combine("cache", "cub", md5key);

                    if (cacheFiles.ContainsKey(md5key))
                    {
                        httpContext.Response.Headers["X-Cache-Status"] = "HIT";
                        httpContext.Response.ContentType = getContentType(uri);
                        await httpContext.Response.SendFileAsync(outFile);
                        return;
                    }

                    var handler = new HttpClientHandler()
                    {
                        AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate,
                        AllowAutoRedirect = false
                    };

                    handler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;

                    if (proxy != null)
                    {
                        handler.UseProxy = true;
                        handler.Proxy = proxy;
                    }
                    else { handler.UseProxy = false; }

                    var client = FrendlyHttp.HttpMessageClient("proxy", handler);
                    var request = CreateProxyHttpRequest(httpContext, new Uri($"{init.scheme}://{domain}/{uri}"), requestInfo, init.viewru && path.Split(".")[0] == "tmdb");

                    using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(15)))
                    {
                        using (var response = await client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cts.Token))
                        {
                            if (init.cache_img > 0 && isMedia && HttpMethods.IsGet(httpContext.Request.Method) && AppInit.conf.mikrotik == false && response.StatusCode == HttpStatusCode.OK)
                            {
                                #region cache
                                httpContext.Response.ContentType = getContentType(uri);
                                httpContext.Response.Headers["X-Cache-Status"] = "MISS";

                                int initialCapacity = response.Content.Headers.ContentLength.HasValue ?
                                    (int)response.Content.Headers.ContentLength.Value :
                                    20_000; // 20kB

                                using (var memoryStream = new MemoryStream(initialCapacity))
                                {
                                    try
                                    {
                                        bool saveCache = true;

                                        using (var responseStream = await response.Content.ReadAsStreamAsync())
                                        {
                                            byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);

                                            try
                                            {
                                                int bytesRead;

                                                while ((bytesRead = await responseStream.ReadAsync(buffer, ctsHttp.Token)) > 0)
                                                {
                                                    memoryStream.Write(buffer, 0, bytesRead);
                                                    await httpContext.Response.Body.WriteAsync(buffer, 0, bytesRead, ctsHttp.Token);
                                                }
                                            }
                                            catch
                                            {
                                                saveCache = false;
                                            }
                                            finally
                                            {
                                                ArrayPool<byte>.Shared.Return(buffer);
                                            }
                                        }

                                        if (saveCache && memoryStream.Length > 1000)
                                        {
                                            try
                                            {
                                                if (!cacheFiles.ContainsKey(md5key))
                                                {
                                                    File.WriteAllBytes(outFile, memoryStream.ToArray());
                                                    cacheFiles.TryAdd(md5key, 0);
                                                }
                                            }
                                            catch { File.Delete(outFile); }
                                        }
                                    }
                                    catch { }
                                }
                                #endregion
                            }
                            else
                            {
                                httpContext.Response.Headers["X-Cache-Status"] = "bypass";
                                await CopyProxyHttpResponse(httpContext, response);
                            }
                        }
                    }
                    #endregion
                }
                else
                {
                    #region cache
                    string memkey = $"cubproxy:{domain}:{uri}";
                    (string content, int statusCode, string contentType) cache = default;

                    var semaphore = new SemaphorManager(memkey, TimeSpan.FromSeconds(20));

                    try
                    {
                        await semaphore.WaitAsync();

                        if (!hybridCache.TryGetValue(memkey, out cache, inmemory: false))
                        {
                            var headers = HeadersModel.Init();

                            if (!string.IsNullOrEmpty(requestInfo.Country))
                                headers.Add(new HeadersModel("cf-connecting-ip", requestInfo.IP));

                            if (path.Split(".")[0] == "tmdb")
                            {
                                if (init.viewru)
                                    headers.Add(new HeadersModel("cookie", "viewru=1"));

                                headers.Add(new HeadersModel("user-agent", httpContext.Request.Headers.UserAgent.ToString()));
                            }
                            else
                            {
                                foreach (var header in httpContext.Request.Headers)
                                {
                                    if (header.Key.ToLower() is "cookie" or "user-agent")
                                        headers.Add(new HeadersModel(header.Key, header.Value.ToString()));
                                }
                            }

                            var result = await Http.BaseGetAsync($"{init.scheme}://{domain}/{uri}", timeoutSeconds: 10, proxy: proxy, headers: headers, statusCodeOK: false, useDefaultHeaders: false);
                            if (string.IsNullOrEmpty(result.content))
                            {
                                proxyManager.Refresh();
                                httpContext.Response.StatusCode = (int)result.response.StatusCode;
                                return;
                            }

                            cache.content = result.content;
                            cache.statusCode = (int)result.response.StatusCode;
                            cache.contentType = result.response.Content.Headers.ContentType.ToString();

                            if (domain.StartsWith("tmdb") || domain.StartsWith("tmapi") || domain.StartsWith("apitmdb"))
                            {
                                if (cache.content == "{\"blocked\":true}")
                                {
                                    var header = HeadersModel.Init(("localrequest", AppInit.rootPasswd));
                                    string json = await Http.Get($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/{uri}", timeoutSeconds: 5, headers: header);
                                    if (!string.IsNullOrEmpty(json))
                                    {
                                        cache.statusCode = 200;
                                        cache.contentType = "application/json; charset=utf-8";
                                        cache.content = json;
                                    }
                                }
                            }

                            httpContext.Response.Headers["X-Cache-Status"] = "MISS";

                            if (cache.statusCode == 200)
                            {
                                proxyManager.Success();
                                hybridCache.Set(memkey, cache, DateTime.Now.AddMinutes(init.cache_api), inmemory: false);
                            }
                        }
                        else
                        {
                            httpContext.Response.Headers["X-Cache-Status"] = "HIT";
                        }
                    }
                    finally
                    {
                        semaphore.Release();
                    }

                    httpContext.Response.StatusCode = cache.statusCode;
                    httpContext.Response.ContentType = cache.contentType;
                    await httpContext.Response.WriteAsync(cache.content, ctsHttp.Token);
                    #endregion
                }
            }
        }


        #region getContentType
        static string getContentType(string uri)
        {
            return Path.GetExtension(uri).ToLowerInvariant() switch
            {
                ".jpg" or ".jpeg" => "image/jpeg",
                ".png" => "image/png",
                ".gif" => "image/gif",
                ".webp" => "image/webp",
                ".ico" => "image/x-icon",
                ".svg" => "image/svg+xml",
                ".mp4" => "video/mp4",
                ".js" => "application/javascript",
                ".css" => "text/css",
                _ => "application/octet-stream"
            };
        }
        #endregion

        #region CreateProxyHttpRequest
        HttpRequestMessage CreateProxyHttpRequest(HttpContext context, Uri uri, RequestModel requestInfo, bool viewru)
        {
            var request = context.Request;

            var requestMessage = new HttpRequestMessage();

            var requestMethod = request.Method;
            if (HttpMethods.IsPost(requestMethod))
            {
                var streamContent = new StreamContent(request.Body);
                requestMessage.Content = streamContent;
            }

            if (viewru)
                request.Headers["cookie"] = "viewru=1";

            #region Headers
            foreach (var header in request.Headers)
            {
                if (header.Key.ToLower() is "host" or "origin" or "content-disposition" or "accept-encoding")
                    continue;

                if (viewru && header.Key.ToLower() == "cookie")
                    continue;

                if (header.Key.ToLower().StartsWith("x-"))
                    continue;

                if (!requestMessage.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray()) && requestMessage.Content != null)
                    requestMessage.Content?.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray());
            }
            #endregion

            if (!string.IsNullOrEmpty(requestInfo.Country))
                requestMessage.Headers.Add("cf-connecting-ip", requestInfo.IP);

            requestMessage.Headers.Host = uri.Authority;
            requestMessage.RequestUri = uri;
            requestMessage.Method = new HttpMethod(request.Method);
            //requestMessage.Version = new Version(2, 0);

            return requestMessage;
        }
        #endregion

        #region CopyProxyHttpResponse
        async Task CopyProxyHttpResponse(HttpContext context, HttpResponseMessage responseMessage)
        {
            var response = context.Response;
            response.StatusCode = (int)responseMessage.StatusCode;
            response.ContentLength = responseMessage.Content.Headers.ContentLength;

            #region UpdateHeaders
            void UpdateHeaders(HttpHeaders headers)
            {
                foreach (var header in headers)
                {
                    if (header.Key.ToLower() is "transfer-encoding" or "etag" or "connection" or "content-security-policy" or "content-disposition")
                        continue;

                    if (header.Key.ToLower().StartsWith("x-"))
                        continue;

                    if (header.Key.ToLower().Contains("access-control"))
                        continue;

                    string value = string.Empty;
                    foreach (var val in header.Value)
                        value += $"; {val}";

                    response.Headers[header.Key] = Regex.Replace(value, "^; ", "");
                }
            }
            #endregion

            UpdateHeaders(responseMessage.Headers);
            UpdateHeaders(responseMessage.Content.Headers);

            using (var responseStream = await responseMessage.Content.ReadAsStreamAsync())
            {
                if (response.Body == null)
                    throw new ArgumentNullException("destination");

                if (!responseStream.CanRead && !responseStream.CanWrite)
                    throw new ObjectDisposedException("ObjectDisposed_StreamClosed");

                if (!response.Body.CanRead && !response.Body.CanWrite)
                    throw new ObjectDisposedException("ObjectDisposed_StreamClosed");

                if (!responseStream.CanRead)
                    throw new NotSupportedException("NotSupported_UnreadableStream");

                if (!response.Body.CanWrite)
                    throw new NotSupportedException("NotSupported_UnwritableStream");

                using (var ctsHttp = CancellationTokenSource.CreateLinkedTokenSource(context.RequestAborted))
                {
                    ctsHttp.CancelAfter(TimeSpan.FromSeconds(90));
                    byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);

                    try
                    {
                        int bytesRead;

                        while ((bytesRead = await responseStream.ReadAsync(buffer, ctsHttp.Token)) != 0)
                            await response.Body.WriteAsync(buffer, 0, bytesRead, ctsHttp.Token);
                    }
                    finally
                    {
                        ArrayPool<byte>.Shared.Return(buffer);
                    }
                }
            }
        }
        #endregion
    }
}

```

## File: Lampac/Engine/Middlewares/OverrideResponse.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.CodeAnalysis.Scripting;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.CSharpGlobals;
using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class OverrideResponse
    {
        private readonly RequestDelegate _next;
        private readonly bool first;
        public OverrideResponse(RequestDelegate next, bool first)
        {
            _next = next;
            this.first = first;
        }

        public Task Invoke(HttpContext httpContext)
        {
            if (AppInit.conf.overrideResponse != null && AppInit.conf.overrideResponse.Count > 0)
            {
                var requestInfo = httpContext.Features.Get<RequestModel>();
                if (requestInfo.IsLocalRequest)
                    return _next(httpContext);

                string url = httpContext.Request.Path.Value + httpContext.Request.QueryString.Value;

                foreach (var over in AppInit.conf.overrideResponse.Where(i => i.firstEndpoint == first))
                {
                    if (Regex.IsMatch(url, over.pattern, RegexOptions.IgnoreCase))
                    {
                        switch (over.action)
                        {
                            case "html":
                                {
                                    httpContext.Response.ContentType = over.type;
                                    return httpContext.Response.WriteAsync(over.val.Replace("{localhost}", AppInit.Host(httpContext)), httpContext.RequestAborted);
                                }
                            case "file":
                                {
                                    httpContext.Response.ContentType = over.type;

                                    if (string.IsNullOrEmpty(over.val) || !File.Exists(over.val))
                                    {                                         
                                        httpContext.Response.StatusCode = 404;
                                        return Task.CompletedTask;
                                    }

                                    if (Regex.IsMatch(over.val, "\\.(html|txt|css|js|json|xml)$", RegexOptions.IgnoreCase))
                                    {
                                        string val = FileCache.ReadAllText(over.val);
                                        return httpContext.Response.WriteAsync(val.Replace("{localhost}", AppInit.Host(httpContext)), httpContext.RequestAborted);
                                    }
                                    else
                                    {
                                        return httpContext.Response.SendFileAsync(over.val);
                                    }
                                }
                            case "redirect":
                                {
                                    httpContext.Response.Redirect(over.val);
                                    return Task.CompletedTask;
                                }
                            case "eval":
                                {
                                    var options = ScriptOptions.Default
                                        .AddReferences(typeof(Console).Assembly).AddImports("System")
                                        .AddReferences(typeof(Regex).Assembly).AddImports("System.Text.RegularExpressions");

                                    bool _next = CSharpEval.BaseExecute<bool>(over.val, new OverrideResponseGlobals(url, httpContext.Request, requestInfo), options);
                                    if (!_next)
                                        return Task.CompletedTask;
                                    break;
                                }
                            default:
                                break;
                        }
                    }
                }
            }

            return _next(httpContext);
        }
    }
}

```

## File: Lampac/Engine/Middlewares/ModHeaders.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class ModHeaders
    {
        private readonly RequestDelegate _next;
        public ModHeaders(RequestDelegate next)
        {
            _next = next;
        }

        public Task Invoke(HttpContext httpContext)
        {
            if (httpContext.Request.Path.Value.StartsWith("/cors/check"))
                return Task.CompletedTask;

            httpContext.Response.Headers["Access-Control-Allow-Credentials"] = "true";
            httpContext.Response.Headers["Access-Control-Allow-Private-Network"] = "true";
            httpContext.Response.Headers["Access-Control-Allow-Methods"] = "POST, GET, OPTIONS";

            string allowHeaders = "Accept, Origin, Content-Type, Authorization, X-Requested-With, X-Signalr-User-Agent, Cache-Control, DNT, If-Modified-Since, Keep-Alive, User-Agent, Token, Profile";
            if (httpContext.Request.Headers.TryGetValue("Access-Control-Request-Headers", out var accessHeaders) && !string.IsNullOrEmpty(accessHeaders.ToString()))
                allowHeaders += ", " + accessHeaders.ToString();

            httpContext.Response.Headers["Access-Control-Allow-Headers"] = allowHeaders;

            if (httpContext.Request.Headers.TryGetValue("origin", out var origin))
                httpContext.Response.Headers["Access-Control-Allow-Origin"] = origin.ToString();
            else if (httpContext.Request.Headers.TryGetValue("referer", out var referer))
                httpContext.Response.Headers["Access-Control-Allow-Origin"] = referer.ToString();
            else
                httpContext.Response.Headers["Access-Control-Allow-Origin"] = "*";

            if (Regex.IsMatch(httpContext.Request.Path.Value, "^/(lampainit|sisi|lite|online|tmdbproxy|cubproxy|tracks|transcoding|dlna|timecode|bookmark|catalog|sync|backup|ts|invc-ws)\\.js") ||
                Regex.IsMatch(httpContext.Request.Path.Value, "^/(on/|(lite|online|sisi|timecode|bookmark|sync|tmdbproxy|dlna|ts|tracks|transcoding|backup|catalog|invc-ws)/js/)"))
            {
                httpContext.Response.Headers["Cache-Control"] = "no-cache, no-store, must-revalidate"; // HTTP 1.1.
                httpContext.Response.Headers["Pragma"] = "no-cache"; // HTTP 1.0.
                httpContext.Response.Headers["Expires"] = "0"; // Proxies.
            }

            if (HttpMethods.IsOptions(httpContext.Request.Method))
                return Task.CompletedTask;

            return _next(httpContext);
        }
    }
}

```

## File: Lampac/Engine/Middlewares/WAF.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Shared;
using Shared.Models;
using Shared.Models.AppConf;
using System;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class WAF
    {
        IMemoryCache memoryCache;
        private readonly RequestDelegate _next;
        public WAF(RequestDelegate next, IMemoryCache mem)
        {
            _next = next;
            memoryCache = mem;
        }

        public Task Invoke(HttpContext httpContext)
        {
            var waf = AppInit.conf.WAF;
            if (!waf.enable)
                return _next(httpContext);

            var requestInfo = httpContext.Features.Get<RequestModel>();
            if (requestInfo.IsLocalRequest || requestInfo.IsAnonymousRequest)
                return _next(httpContext);

            if (waf.whiteIps != null && waf.whiteIps.Contains(requestInfo.IP))
                return _next(httpContext);

            #region country
            if (waf.countryAllow != null)
            {
                // –µ—Å–ª–∏ –º—ã –Ω–µ –∑–Ω–∞–µ–º —Å—Ç—Ä–∞–Ω—É –∏–ª–∏ —Ç–æ—á–Ω–æ –∑–Ω–∞–µ–º, —á—Ç–æ –æ–Ω–∞ –Ω–µ –≤ —Å–ø–∏—Å–∫–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã—Ö
                if (string.IsNullOrEmpty(requestInfo.Country) || !waf.countryAllow.Contains(requestInfo.Country))
                {
                    httpContext.Response.StatusCode = 403;
                    return Task.CompletedTask;
                }
            }

            if (waf.countryDeny != null)
            {
                // —Ç–æ—á–Ω–æ –∑–Ω–∞–µ–º —Å—Ç—Ä–∞–Ω—É –∏ –æ–Ω–∞ –µ—Å—Ç—å –≤ —Å–ø–∏—Å–∫–µ –∑–∞–ø—Ä–µ—â–µ–Ω–Ω—ã—Ö
                if (!string.IsNullOrEmpty(requestInfo.Country) && waf.countryDeny.Contains(requestInfo.Country))
                {
                    httpContext.Response.StatusCode = 403;
                    return Task.CompletedTask;
                }
            }
            #endregion

            #region ips
            if (waf.ipsDeny != null)
            {
                if (waf.ipsDeny.Contains(requestInfo.IP))
                {
                    httpContext.Response.StatusCode = 403;
                    return Task.CompletedTask;
                }

                var clientIPAddress = IPAddress.Parse(requestInfo.IP);
                foreach (string ip in waf.ipsDeny)
                {
                    if (ip.Contains("/"))
                    {
                        string[] parts = ip.Split('/');
                        if (int.TryParse(parts[1], out int prefixLength))
                        {
                            if (new System.Net.IPNetwork(IPAddress.Parse(parts[0]), prefixLength).Contains(clientIPAddress))
                            {
                                httpContext.Response.StatusCode = 403;
                                return Task.CompletedTask;
                            }
                        }
                    }
                }
            }

            if (waf.ipsAllow != null)
            {
                if (!waf.ipsAllow.Contains(requestInfo.IP))
                {
                    bool deny = true;
                    var clientIPAddress = IPAddress.Parse(requestInfo.IP);
                    foreach (string ip in waf.ipsAllow)
                    {
                        if (ip.Contains("/"))
                        {
                            string[] parts = ip.Split('/');
                            if (int.TryParse(parts[1], out int prefixLength))
                            {
                                if (new System.Net.IPNetwork(IPAddress.Parse(parts[0]), prefixLength).Contains(clientIPAddress))
                                {
                                    deny = false;
                                    break;
                                }
                            }
                        }
                    }

                    if (deny)
                    {
                        httpContext.Response.StatusCode = 403;
                        return Task.CompletedTask;
                    }
                }
            }
            #endregion

            #region headers
            if (waf.headersDeny != null)
            {
                foreach (var header in waf.headersDeny)
                {
                    if (httpContext.Request.Headers.TryGetValue(header.Key, out var headerValue) && !string.IsNullOrEmpty(headerValue))
                    {
                        if (Regex.IsMatch(headerValue.ToString(), header.Value, RegexOptions.IgnoreCase))
                        {
                            httpContext.Response.StatusCode = 403;
                            return Task.CompletedTask;
                        }
                    }
                }
            }
            #endregion

            #region limit_req
            var (limit, pattern) = MapLimited(waf, httpContext.Request.Path.Value);
            if (limit > 0)
            {
                if (RateLimited(requestInfo.IP, limit, pattern))
                {
                    httpContext.Response.StatusCode = 429;
                    return Task.CompletedTask;
                }
            }
            #endregion

            return _next(httpContext);
        }


        #region MapLimited
        static (int limit, string pattern) MapLimited(WafConf waf, string path)
        {
            if (waf.limit_map != null)
            {
                foreach (var pathLimit in waf.limit_map)
                {
                    if (Regex.IsMatch(path, pathLimit.Key, RegexOptions.IgnoreCase))
                        return (pathLimit.Value, pathLimit.Key);
                }
            }

            return (waf.limit_req, "default");
        }
        #endregion

        #region RateLimited
        bool RateLimited(string userip, int limit_req, string pattern)
        {
            string memKeyLocIP = $"WAF:RateLimited:{userip}:{pattern}:{DateTime.Now.Minute}";

            if (memoryCache.TryGetValue(memKeyLocIP, out int req))
            {
                if (req >= limit_req)
                    return true;

                memoryCache.Set(memKeyLocIP, req+1, DateTime.Now.AddMinutes(1));
            }
            else
            {
                memoryCache.Set(memKeyLocIP, 1, DateTime.Now.AddMinutes(1));
            }

            return false;
        }
        #endregion
    }
}

```

## File: Lampac/Engine/Middlewares/Accsdb.cs
```
Ôªøusing Shared;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Shared.Models;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Shared.Engine;

namespace Lampac.Engine.Middlewares
{
    public class Accsdb
    {
        static Accsdb() 
        {
            Directory.CreateDirectory("cache/logs/accsdb");
        }

        private readonly RequestDelegate _next;
        IMemoryCache memoryCache;

        public Accsdb(RequestDelegate next, IMemoryCache mem)
        {
            _next = next;
            memoryCache = mem;
        }

        public Task Invoke(HttpContext httpContext)
        {
            var requestInfo = httpContext.Features.Get<RequestModel>();
            if (requestInfo.IsLocalRequest || requestInfo.IsAnonymousRequest)
                return _next(httpContext);

            #region manifest / admin
            if (httpContext.Request.Path.Value.StartsWith("/admin/") || httpContext.Request.Path.Value == "/admin")
            {
                if (httpContext.Request.Cookies.TryGetValue("passwd", out string passwd))
                {
                    if (passwd == AppInit.rootPasswd)
                    {
                        if (httpContext.Request.Path.Value.StartsWith("/admin/auth"))
                            return _next(httpContext);

                        return _next(httpContext);
                    }

                    string ipKey = $"Accsdb:auth:IP:{requestInfo.IP}";
                    if (!memoryCache.TryGetValue(ipKey, out HashSet<string> passwds))
                        passwds = new HashSet<string>();

                    passwds.Add(passwd);
                    memoryCache.Set(ipKey, passwds, DateTime.Today.AddDays(1));

                    if (passwds.Count > 5)
                        return httpContext.Response.WriteAsync("Too many attempts, try again tomorrow.", httpContext.RequestAborted);
                }

                if (httpContext.Request.Path.Value.StartsWith("/admin/auth"))
                    return _next(httpContext);

                httpContext.Response.Redirect("/admin/auth");
                return Task.CompletedTask;
            }
            #endregion

            #region ws / nws
            if (httpContext.Request.Path.Value.StartsWith("/ws") || httpContext.Request.Path.Value.StartsWith("/nws"))
            {
                if (AppInit.conf.weblog.enable || AppInit.conf.rch.enable || AppInit.conf.storage.enable || AppInit.conf.sync_user.enable)
                    return _next(httpContext);

                return httpContext.Response.WriteAsync("disabled", httpContext.RequestAborted);
            }
            #endregion

            #region jacred
            string jacpattern = "^/(api/v2.0/indexers|api/v1.0/|toloka|rutracker|rutor|torrentby|nnmclub|kinozal|bitru|selezen|megapeer|animelayer|anilibria|anifilm|toloka|lostfilm|bigfangroup|mazepa)";

            if (!string.IsNullOrEmpty(AppInit.conf.apikey))
            {
                if (Regex.IsMatch(httpContext.Request.Path.Value, jacpattern))
                {
                    if (AppInit.conf.apikey != httpContext.Request.Query["apikey"])
                        return Task.CompletedTask;
                }
            }
            #endregion

            if (AppInit.conf.accsdb.enable)
            {
                var accsdb = AppInit.conf.accsdb;

                if (httpContext.Request.Path.Value.StartsWith("/testaccsdb") && accsdb.shared_passwd != null && requestInfo.user_uid == accsdb.shared_passwd)
                {
                    requestInfo.IsLocalRequest = true;
                    httpContext.Features.Set(requestInfo);
                    return _next(httpContext);
                }

                if (!string.IsNullOrEmpty(accsdb.premium_pattern) && !Regex.IsMatch(httpContext.Request.Path.Value, accsdb.premium_pattern, RegexOptions.IgnoreCase))
                    return _next(httpContext);

                if (!string.IsNullOrEmpty(accsdb.whitepattern) && Regex.IsMatch(httpContext.Request.Path.Value, accsdb.whitepattern, RegexOptions.IgnoreCase))
                {
                    requestInfo.IsAnonymousRequest = true;
                    httpContext.Features.Set(requestInfo);
                    return _next(httpContext);
                }

                if (Regex.IsMatch(httpContext.Request.Path.Value, jacpattern))
                    return _next(httpContext);

                bool limitip = false;

                var user = requestInfo.user;

                if (requestInfo.user_uid != null && accsdb.white_uids != null && accsdb.white_uids.Contains(requestInfo.user_uid))
                    return _next(httpContext);

                string uri = httpContext.Request.Path.Value + httpContext.Request.QueryString.Value;

                if (user == null || user.ban || DateTime.UtcNow > user.expires || IsLockHostOrUser(requestInfo.user_uid, requestInfo.IP, uri, out limitip))
                {
                    if (httpContext.Request.Path.Value.StartsWith("/proxy/") || httpContext.Request.Path.Value.StartsWith("/proxyimg"))
                    {
                        string hash = Regex.Replace(httpContext.Request.Path.Value, "/(proxy|proxyimg([^/]+)?)/", "");
                        if (AppInit.conf.serverproxy.encrypt || ProxyLink.Decrypt(hash, requestInfo.IP)?.uri != null)
                            return _next(httpContext);
                    }

                    if (uri.StartsWith("/tmdb/api.themoviedb.org/") || uri.StartsWith("/tmdb/api/"))
                    {
                        httpContext.Response.Redirect("https://api.themoviedb.org/" + Regex.Replace(httpContext.Request.Path.Value, "^/tmdb/[^/]+/", ""));
                        return Task.CompletedTask;
                    }

                    if (Regex.IsMatch(httpContext.Request.Path.Value, "\\.(js|css|ico|png|svg|jpe?g|woff|webmanifest)"))
                    {
                        if (uri.StartsWith("/tmdb/image.tmdb.org/") || uri.StartsWith("/tmdb/img/"))
                        {
                            httpContext.Response.Redirect("https://image.tmdb.org/" + Regex.Replace(httpContext.Request.Path.Value, "^/tmdb/[^/]+/", ""));
                            return Task.CompletedTask;
                        }

                        httpContext.Response.StatusCode = 404;
                        httpContext.Response.ContentType = "application/octet-stream";
                        return Task.CompletedTask;
                    }

                    #region msg
                    string msg = limitip ? $"–ü—Ä–µ–≤—ã—à–µ–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ ip/–∑–∞–ø—Ä–æ—Å–æ–≤ –Ω–∞ –∞–∫–∫–∞—É–Ω—Ç."
                        : string.IsNullOrEmpty(requestInfo.user_uid) ? accsdb.authMesage
                        : accsdb.denyMesage.Replace("{account_email}", requestInfo.user_uid).Replace("{user_uid}", requestInfo.user_uid).Replace("{host}", httpContext.Request.Host.Value);

                    if (user != null)
                    {
                        if (user.ban)
                            msg = user.ban_msg ?? "–í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã";

                        else if (DateTime.UtcNow > user.expires)
                            msg = accsdb.expiresMesage.Replace("{account_email}", requestInfo.user_uid).Replace("{user_uid}", requestInfo.user_uid).Replace("{expires}", user.expires.ToString("dd.MM.yyyy"));
                    }
                    #endregion

                    #region denymsg
                    string denymsg = limitip ? $"–ü—Ä–µ–≤—ã—à–µ–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ ip/–∑–∞–ø—Ä–æ—Å–æ–≤ –Ω–∞ –∞–∫–∫–∞—É–Ω—Ç." : null;

                    if (user != null)
                    {
                        if (user.ban)
                            denymsg = user.ban_msg ?? "–í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã";

                        else if (DateTime.UtcNow > user.expires)
                            denymsg = accsdb.expiresMesage.Replace("{account_email}", requestInfo.user_uid).Replace("{user_uid}", requestInfo.user_uid).Replace("{expires}", user.expires.ToString("dd.MM.yyyy"));
                    }
                    #endregion

                    return httpContext.Response.WriteAsJsonAsync(new { accsdb = true, msg, denymsg, user }, httpContext.RequestAborted);
                }
            }

            return _next(httpContext);
        }


        #region IsLock
        static string logsLock = string.Empty;

        bool IsLockHostOrUser(string account_email, string userip, string uri, out bool islock)
        {
            if (string.IsNullOrEmpty(account_email))
            {
                islock = false;
                return islock;
            }

            if (Regex.IsMatch(uri, "^/(proxy/|proxyimg|lifeevents|externalids|sisi/(bookmarks|historys)|(ts|transcoding|dlna|storage|bookmark|tmdb|cub)/|timecode)"))
            {
                islock = false;
                return islock;
            }

            HashSet<string> ips = null;
            HashSet<string> urls = null;

            #region setLogs
            void setLogs(string name)
            {
                string logFile = $"cache/logs/accsdb/{DateTime.Now:dd-MM-yyyy}.lock.txt";
                if (logsLock != string.Empty && !File.Exists(logFile))
                    logsLock = string.Empty;

                string line = $"{name} / {account_email} / {CrypTo.md5(account_email)}.*.log";

                if (!logsLock.Contains(line))
                {
                    logsLock += $"{DateTime.Now}: {line}\n";
                    File.WriteAllText(logFile, logsLock);
                }
            }
            #endregion

            #region countlock_day
            int countlock_day(bool update)
            {
                string key = $"Accsdb:lock_day:{account_email}:{DateTime.Now.Day}";

                if (memoryCache.TryGetValue(key, out HashSet<int> lockhour))
                {
                    if (update)
                    {
                        lockhour.Add(DateTime.Now.Hour);
                        memoryCache.Set(key, lockhour, DateTime.Now.AddDays(1));
                    }

                    return lockhour.Count;
                }
                else if (update)
                {
                    lockhour = new HashSet<int>() { DateTime.Now.Hour };
                    memoryCache.Set(key, lockhour, DateTime.Now.AddDays(1));
                    return lockhour.Count;
                }

                return 0;
            }
            #endregion

            if (IsLockIpHour(account_email, userip, out islock, out ips) | IsLockReqHour(account_email, uri, out islock, out urls))
            {
                setLogs("lock_hour");
                countlock_day(update: true);

                File.WriteAllLines($"cache/logs/accsdb/{CrypTo.md5(account_email)}.ips.log", ips);
                File.WriteAllLines($"cache/logs/accsdb/{CrypTo.md5(account_email)}.urls.log", urls);

                return islock;
            }

            if (countlock_day(update: false) > AppInit.conf.accsdb.maxlock_day)
            {
                if (AppInit.conf.accsdb.blocked_hour != -1)
                    memoryCache.Set($"Accsdb:blocked_hour:{account_email}", 0, DateTime.Now.AddHours(AppInit.conf.accsdb.blocked_hour));

                setLogs("lock_day");
                islock = true;
                return islock;
            }

            if (memoryCache.TryGetValue($"Accsdb:blocked_hour:{account_email}", out _))
            {
                setLogs("blocked");
                islock = true;
                return islock;
            }

            islock = false;
            return islock;
        }


        bool IsLockIpHour(string account_email, string userip, out bool islock, out HashSet<string> ips)
        {
            string memKeyLocIP = $"Accsdb:IsLockIpHour:{account_email}:{DateTime.Now.Hour}";

            if (memoryCache.TryGetValue(memKeyLocIP, out ips))
            {
                ips.Add(userip);
                memoryCache.Set(memKeyLocIP, ips, DateTime.Now.AddHours(1));

                if (ips.Count > AppInit.conf.accsdb.maxip_hour)
                {
                    islock = true;
                    return islock;
                }
            }
            else
            {
                ips = new HashSet<string>() { userip };
                memoryCache.Set(memKeyLocIP, ips, DateTime.Now.AddHours(1));
            }

            islock = false;
            return islock;
        }

        bool IsLockReqHour(string account_email, string uri, out bool islock, out HashSet<string> urls)
        {
            string memKeyLocIP = $"Accsdb:IsLockReqHour:{account_email}:{DateTime.Now.Hour}";

            if (memoryCache.TryGetValue(memKeyLocIP, out urls))
            {
                urls.Add(uri);
                memoryCache.Set(memKeyLocIP, urls, DateTime.Now.AddHours(1));

                if (urls.Count > AppInit.conf.accsdb.maxrequest_hour)
                {
                    islock = true;
                    return islock;
                }
            }
            else
            {
                urls = new HashSet<string>() { uri };
                memoryCache.Set(memKeyLocIP, urls, DateTime.Now.AddHours(1));
            }

            islock = false;
            return islock;
        }
        #endregion
    }
}

```

## File: Lampac/Engine/Middlewares/Module.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Events;
using Shared.Models.Module.Entrys;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class Module
    {
        private readonly RequestDelegate _next;
        IMemoryCache memoryCache;
        private readonly bool first;

        public Module(RequestDelegate next, IMemoryCache mem, bool first)
        {
            _next = next;
            memoryCache = mem;
            this.first = first;
        }

        async public Task InvokeAsync(HttpContext httpContext)
        {
            #region modules
            MiddlewaresModuleEntry.EnsureCache();

            if (MiddlewaresModuleEntry.middlewareModulesCache != null && MiddlewaresModuleEntry.middlewareModulesCache.Count > 0)
            {
                foreach (var entry in MiddlewaresModuleEntry.middlewareModulesCache)
                {
                    var mod = entry.mod;

                    try
                    {
                        if (first && (mod.version == 0 || mod.version == 1))
                            continue;

                        if (mod.version >= 2)
                        {
                            if (entry.Invoke != null)
                            {
                                bool next = entry.Invoke(first, httpContext, memoryCache);
                                if (!next)
                                    return;
                            }

                            if (entry.InvokeAsync != null)
                            {
                                bool next = await entry.InvokeAsync(first, httpContext, memoryCache);
                                if (!next)
                                    return;
                            }
                        }
                        else
                        {
                            if (entry.InvokeV1 != null)
                            {
                                bool next = entry.InvokeV1(httpContext, memoryCache);
                                if (!next)
                                    return;
                            }

                            if (entry.InvokeAsyncV1 != null)
                            {
                                bool next = await entry.InvokeAsyncV1(httpContext, memoryCache);
                                if (!next)
                                    return;
                            }
                        }
                    }
                    catch { }
                }
            }
            #endregion 

            if ((first && InvkEvent.conf?.Middleware?.first != null) || (!first && InvkEvent.conf?.Middleware?.end != null))
            {
                var rqinfo = httpContext.Features.Get<RequestModel>();
                bool next = await InvkEvent.Middleware(first, new EventMiddleware(rqinfo, httpContext.Request, httpContext, new HybridCache(), memoryCache));
                if (!next)
                    return;
            }

            await _next(httpContext);
        }
    }
}

```

## File: Lampac/Engine/Middlewares/ProxyTmdb.cs
```
Ôªøusing DnsClient;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using NetVips;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Models;
using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class ProxyTmdb
    {
        #region ProxyTmdb
        static FileSystemWatcher fileWatcher;

        static ConcurrentDictionary<string, byte> cacheFiles = new ConcurrentDictionary<string, byte>();

        static Timer cleanupTimer;

        static ProxyTmdb()
        {
            if (AppInit.conf.multiaccess == false)
                return;

            Directory.CreateDirectory("cache/tmdb");

            foreach (var item in Directory.EnumerateFiles("cache/tmdb", "*"))
                cacheFiles.TryAdd(Path.GetFileName(item), 0);

            fileWatcher = new FileSystemWatcher
            {
                Path = "cache/tmdb",
                NotifyFilter = NotifyFilters.FileName,
                EnableRaisingEvents = true
            };

            fileWatcher.Created += (s, e) => { cacheFiles.TryAdd(e.Name, 0); };
            fileWatcher.Deleted += (s, e) => { cacheFiles.TryRemove(e.Name, out _); };

            cleanupTimer = new Timer(cleanup, null, TimeSpan.FromMinutes(60), TimeSpan.FromMinutes(60));
        }

        static void cleanup(object state)
        {
            try
            {
                var files = Directory.GetFiles("cache/tmdb", "*").Select(f => Path.GetFileName(f)).ToHashSet();

                foreach (string md5fileName in cacheFiles.Keys.ToArray())
                {
                    if (!files.Contains(md5fileName))
                        cacheFiles.TryRemove(md5fileName, out _);
                }
            }
            catch { }
        }

        public ProxyTmdb(RequestDelegate next) { }
        #endregion

        public Task Invoke(HttpContext httpContext)
        {
            var hybridCache = new HybridCache();
            var requestInfo = httpContext.Features.Get<RequestModel>();

            if (httpContext.Request.Path.Value.StartsWith("/tmdb/api/"))
                return API(httpContext, hybridCache, requestInfo);

            if (httpContext.Request.Path.Value.StartsWith("/tmdb/img/"))
                return IMG(httpContext, requestInfo);

            string path = Regex.Replace(httpContext.Request.Path.Value, "^/tmdb/https?://", "").Replace("/tmdb/", "");
            string uri = Regex.Match(path, "^[^/]+/(.*)").Groups[1].Value + httpContext.Request.QueryString.Value;

            if (path.Contains("api.themoviedb.org"))
            {
                httpContext.Request.Path = $"/tmdb/api/{uri}";
                return API(httpContext, hybridCache, requestInfo);
            }
            else if (path.Contains("image.tmdb.org"))
            {
                httpContext.Request.Path = $"/tmdb/img/{uri}";
                return IMG(httpContext, requestInfo);
            }

            httpContext.Response.StatusCode = 403;
            return Task.CompletedTask;
        }


        #region API
        async public Task API(HttpContext httpContex, HybridCache hybridCache, RequestModel requestInfo)
        {
            using (var ctsHttp = CancellationTokenSource.CreateLinkedTokenSource(httpContex.RequestAborted))
            {
                ctsHttp.CancelAfter(TimeSpan.FromSeconds(90));
                httpContex.Response.ContentType = "application/json; charset=utf-8";

                var init = AppInit.conf.tmdb;
                if (!init.enable && !requestInfo.IsLocalRequest)
                {
                    httpContex.Response.StatusCode = 401;
                    await httpContex.Response.WriteAsJsonAsync(new { error = true, msg = "disable" }, ctsHttp.Token);
                    return;
                }

                string path = httpContex.Request.Path.Value.Replace("/tmdb/api", "");
                path = Regex.Replace(path, "^/https?://api.themoviedb.org", "");
                path = Regex.Replace(path, "/$", "");

                string query = Regex.Replace(httpContex.Request.QueryString.Value, "(&|\\?)(account_email|email|uid|token)=[^&]+", "");
                string uri = "https://api.themoviedb.org" + path + query;

                string mkey = $"tmdb/api:{path}:{query}";

                if (hybridCache.TryGetValue(mkey, out (string json, int statusCode) cache, inmemory: false))
                {
                    httpContex.Response.Headers["X-Cache-Status"] = "HIT";
                    httpContex.Response.StatusCode = cache.statusCode;
                    httpContex.Response.ContentType = "application/json; charset=utf-8";
                    await httpContex.Response.WriteAsync(cache.json, ctsHttp.Token);
                    return;
                }

                httpContex.Response.Headers["X-Cache-Status"] = "MISS";

                string tmdb_ip = init.API_IP;

                #region DNS QueryType.A
                if (string.IsNullOrEmpty(tmdb_ip) && string.IsNullOrEmpty(init.API_Minor) && !string.IsNullOrEmpty(init.DNS))
                {
                    string dnskey = $"tmdb/api:dns:{init.DNS}";

                    var _spredns = new SemaphorManager(dnskey, TimeSpan.FromMinutes(1));

                    try
                    {
                        await _spredns.WaitAsync();

                        if (!Startup.memoryCache.TryGetValue(dnskey, out string dns_ip))
                        {
                            using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(50)))
                            {
                                var lookup = new LookupClient(IPAddress.Parse(init.DNS));
                                var queryType = await lookup.QueryAsync("api.themoviedb.org", QueryType.A, cancellationToken: cts.Token);
                                dns_ip = queryType?.Answers?.ARecords()?.FirstOrDefault()?.Address?.ToString();

                                if (!string.IsNullOrEmpty(dns_ip))
                                    Startup.memoryCache.Set(dnskey, dns_ip, DateTime.Now.AddMinutes(Math.Max(init.DNS_TTL, 5)));
                                else
                                    Startup.memoryCache.Set(dnskey, string.Empty, DateTime.Now.AddMinutes(5));
                            }
                        }

                        if (!string.IsNullOrEmpty(dns_ip))
                            tmdb_ip = dns_ip;
                    }
                    catch { }
                    finally
                    {
                        _spredns.Release();
                    }
                }
                #endregion

                var headers = new List<HeadersModel>();
                var proxyManager = new ProxyManager("tmdb_api", init);

                if (!string.IsNullOrEmpty(init.API_Minor))
                {
                    uri = uri.Replace("api.themoviedb.org", init.API_Minor);
                }
                else if (!string.IsNullOrEmpty(tmdb_ip))
                {
                    headers.Add(new HeadersModel("Host", "api.themoviedb.org"));
                    uri = uri.Replace("api.themoviedb.org", tmdb_ip);
                }

                var result = await Http.BaseGetAsync<JObject>(uri, timeoutSeconds: 20, proxy: proxyManager.Get(), httpversion: init.httpversion, headers: headers, statusCodeOK: false);
                if (result.content == null)
                {
                    proxyManager.Refresh();
                    httpContex.Response.StatusCode = 401;
                    await httpContex.Response.WriteAsJsonAsync(new { error = true, msg = "json null" }, ctsHttp.Token);
                    return;
                }

                cache.statusCode = (int)result.response.StatusCode;
                httpContex.Response.StatusCode = cache.statusCode;

                if (result.content.ContainsKey("status_message") || result.response.StatusCode != HttpStatusCode.OK)
                {
                    proxyManager.Refresh();
                    cache.json = JsonConvert.SerializeObject(result.content);

                    if (init.cache_api > 0 && !string.IsNullOrEmpty(cache.json))
                        hybridCache.Set(mkey, cache, DateTime.Now.AddMinutes(1), inmemory: true);

                    await httpContex.Response.WriteAsync(cache.json, ctsHttp.Token);
                    return;
                }

                cache.json = JsonConvert.SerializeObject(result.content);

                if (init.cache_api > 0 && !string.IsNullOrEmpty(cache.json))
                    hybridCache.Set(mkey, cache, DateTime.Now.AddMinutes(init.cache_api), inmemory: false);

                proxyManager.Success();
                httpContex.Response.ContentType = "application/json; charset=utf-8";
                await httpContex.Response.WriteAsync(cache.json, ctsHttp.Token);
            }
        }
        #endregion

        #region IMG
        async public Task IMG(HttpContext httpContex, RequestModel requestInfo)
        {
            using (var ctsHttp = CancellationTokenSource.CreateLinkedTokenSource(httpContex.RequestAborted))
            {
                ctsHttp.CancelAfter(TimeSpan.FromSeconds(90));

                var init = AppInit.conf.tmdb;
                if (!init.enable)
                {
                    httpContex.Response.StatusCode = 401;
                    await httpContex.Response.WriteAsJsonAsync(new { error = true, msg = "disable" }, ctsHttp.Token);
                    return;
                }

                string path = httpContex.Request.Path.Value.Replace("/tmdb/img", "");
                path = Regex.Replace(path, "^/https?://image.tmdb.org", "");

                string query = Regex.Replace(httpContex.Request.QueryString.Value, "(&|\\?)(account_email|email|uid|token)=[^&]+", "");
                string uri = "https://image.tmdb.org" + path + query;

                string md5key = CrypTo.md5($"{path}:{query}");
                string outFile = Path.Combine("cache", "tmdb", md5key);

                httpContex.Response.ContentType = path.Contains(".png") ? "image/png" : path.Contains(".svg") ? "image/svg+xml" : "image/jpeg";

                if (cacheFiles.ContainsKey(md5key) || (AppInit.conf.multiaccess == false && File.Exists(outFile)))
                {
                    httpContex.Response.Headers["X-Cache-Status"] = "HIT";
                    await httpContex.Response.SendFileAsync(outFile);
                    return;
                }

                string tmdb_ip = init.IMG_IP;

                #region DNS QueryType.A
                if (string.IsNullOrEmpty(tmdb_ip) && string.IsNullOrEmpty(init.IMG_Minor) && !string.IsNullOrEmpty(init.DNS))
                {
                    string dnskey = $"tmdb/img:dns:{init.DNS}";

                    var _spredns = new SemaphorManager(dnskey, TimeSpan.FromMinutes(1));

                    try
                    {
                        await _spredns.WaitAsync();

                        if (!Startup.memoryCache.TryGetValue(dnskey, out string dns_ip))
                        {
                            using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(50)))
                            {
                                var lookup = new LookupClient(IPAddress.Parse(init.DNS));
                                var result = await lookup.QueryAsync("image.tmdb.org", QueryType.A);
                                dns_ip = result?.Answers?.ARecords()?.FirstOrDefault()?.Address?.ToString();

                                if (!string.IsNullOrEmpty(dns_ip))
                                    Startup.memoryCache.Set(dnskey, dns_ip, DateTime.Now.AddMinutes(Math.Max(init.DNS_TTL, 5)));
                                else
                                    Startup.memoryCache.Set(dnskey, string.Empty, DateTime.Now.AddMinutes(5));
                            }
                        }

                        if (!string.IsNullOrEmpty(dns_ip))
                            tmdb_ip = dns_ip;
                    }
                    catch { }
                    finally
                    {
                        _spredns.Release();
                    }
                }
                #endregion

                #region headers
                var headers = new List<HeadersModel>()
                {
                    // –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ä—ã–π ua —á—Ç–æ-–±—ã –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å image/jpeg –≤–º–µ—Å—Ç–æ image/webp
                    new HeadersModel("Accept", "image/jpeg,image/png,image/*;q=0.8,*/*;q=0.5"),
                    new HeadersModel("User-Agent", "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2"),
                    new HeadersModel("Cache-Control", "max-age=0")
                };

                if (!string.IsNullOrEmpty(init.IMG_Minor))
                {
                    uri = uri.Replace("image.tmdb.org", init.IMG_Minor);
                }
                else if (!string.IsNullOrEmpty(tmdb_ip))
                {
                    headers.Add(new HeadersModel("Host", "image.tmdb.org"));
                    uri = uri.Replace("image.tmdb.org", tmdb_ip);
                }
                #endregion

                var proxyManager = new ProxyManager("tmdb_img", init);

                bool cacheimg = init.cache_img > 0 && AppInit.conf.mikrotik == false;
                var semaphore = cacheimg ? new SemaphorManager(uri, TimeSpan.FromMinutes(1)) : null;

                try
                {
                    if (semaphore != null)
                        await semaphore.WaitAsync();

                    if (cacheFiles.ContainsKey(md5key) || (AppInit.conf.multiaccess == false && File.Exists(outFile)))
                    {
                        httpContex.Response.Headers["X-Cache-Status"] = "HIT";
                        await httpContex.Response.SendFileAsync(outFile);
                        return;
                    }

                    var handler = Http.Handler(uri, proxyManager.Get());

                    var client = FrendlyHttp.HttpMessageClient(init.httpversion == 2 ? "http2proxyimg" : "proxyimg", handler);

                    var req = new HttpRequestMessage(HttpMethod.Get, uri)
                    {
                        Version = init.httpversion == 1 ? HttpVersion.Version11 : new Version(init.httpversion, 0)
                    };

                    Http.DefaultRequestHeaders(uri, req, null, null, headers);

                    using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(20)))
                    {
                        using (HttpResponseMessage response = await client.SendAsync(req, cts.Token))
                        {
                            if (response.StatusCode == HttpStatusCode.OK)
                                proxyManager.Success();
                            else
                                proxyManager.Refresh();

                            if (response.StatusCode == HttpStatusCode.OK && cacheimg)
                            {
                                #region cache
                                httpContex.Response.Headers["X-Cache-Status"] = "MISS";

                                int initialCapacity = response.Content.Headers.ContentLength.HasValue ?
                                    (int)response.Content.Headers.ContentLength.Value :
                                    50_000; // 50kB

                                using (var memoryStream = new MemoryStream(initialCapacity))
                                {
                                    try
                                    {
                                        bool saveCache = true;

                                        using (var responseStream = await response.Content.ReadAsStreamAsync())
                                        {
                                            byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);

                                            try
                                            {
                                                int bytesRead;

                                                while ((bytesRead = await responseStream.ReadAsync(buffer, ctsHttp.Token)) > 0)
                                                {
                                                    memoryStream.Write(buffer, 0, bytesRead);
                                                    await httpContex.Response.Body.WriteAsync(buffer, 0, bytesRead, ctsHttp.Token);
                                                }
                                            }
                                            catch
                                            {
                                                saveCache = false;
                                            }
                                            finally
                                            {
                                                ArrayPool<byte>.Shared.Return(buffer);
                                            }
                                        }

                                        if (saveCache && memoryStream.Length > 1000)
                                        {
                                            try
                                            {
                                                if (cacheFiles.ContainsKey(md5key) == false || (AppInit.conf.multiaccess == false && File.Exists(outFile) == false))
                                                {
                                                    #region check_img
                                                    if (init.check_img && !path.Contains(".svg"))
                                                    {
                                                        using (var image = Image.NewFromBuffer(memoryStream.ToArray()))
                                                        {
                                                            try
                                                            {
                                                                // —Ç–µ—Å—Ç–∏—Ä—É–µ–º jpg/png –Ω–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å
                                                                byte[] temp = image.JpegsaveBuffer();
                                                                if (temp == null || temp.Length == 0)
                                                                    return;
                                                            }
                                                            catch
                                                            {
                                                                return;
                                                            }
                                                        }
                                                    }
                                                    #endregion

                                                    File.WriteAllBytes(outFile, memoryStream.ToArray());

                                                    if (AppInit.conf.multiaccess)
                                                        cacheFiles.TryAdd(md5key, 0);
                                                }
                                            }
                                            catch { File.Delete(outFile); }
                                        }
                                    }
                                    catch { }
                                }
                                #endregion
                            }
                            else
                            {
                                httpContex.Response.StatusCode = (int)response.StatusCode;
                                httpContex.Response.Headers["X-Cache-Status"] = "bypass";
                                await response.Content.CopyToAsync(httpContex.Response.Body, ctsHttp.Token);
                            }
                        }
                    }
                }
                catch
                {
                    proxyManager.Refresh();

                    if (!string.IsNullOrEmpty(tmdb_ip))
                        httpContex.Response.Redirect(uri.Replace(tmdb_ip, "image.tmdb.org"));
                    else
                        httpContex.Response.Redirect(uri);
                }
                finally
                {
                    if (semaphore != null)
                        semaphore.Release();
                }
            }
        }
        #endregion
    }
}

```

## File: Lampac/Engine/Middlewares/RequestStatistics.cs
```
using Microsoft.AspNetCore.Http;
using Shared;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class RequestStatistics
    {
        private readonly RequestDelegate _next;

        public RequestStatistics(RequestDelegate next)
        {
            _next = next;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            bool trackStats = !(context.Request.Path.StartsWithSegments("/ws") || context.Request.Path.StartsWithSegments("/nws"));
            Stopwatch stopwatch = null;

            if (trackStats && AppInit.conf.openstat.enable)
                stopwatch = RequestStatisticsTracker.StartRequest();

            try
            {
                await _next(context);
            }
            finally
            {
                if (trackStats && AppInit.conf.openstat.enable)
                    RequestStatisticsTracker.CompleteRequest(stopwatch);
            }
        }
    }

    public static class RequestStatisticsTracker
    {
        static int activeHttpRequests;
        static readonly ConcurrentQueue<(DateTime timestamp, double durationMs)> ResponseTimes = new();

        public static int ActiveHttpRequests => Volatile.Read(ref activeHttpRequests);

        internal static Stopwatch StartRequest()
        {
            Interlocked.Increment(ref activeHttpRequests);
            return Stopwatch.StartNew();
        }

        internal static void CompleteRequest(Stopwatch stopwatch)
        {
            if (stopwatch == null)
                return;

            stopwatch.Stop();
            AddResponseTime(stopwatch.Elapsed.TotalMilliseconds);
            Interlocked.Decrement(ref activeHttpRequests);
        }

        static void AddResponseTime(double durationMs)
        {
            var now = DateTime.UtcNow;
            ResponseTimes.Enqueue((now, durationMs));
            CleanupResponseTimes(now);
        }

        static void CleanupResponseTimes(DateTime now)
        {
            while (ResponseTimes.TryPeek(out var oldest) && (now - oldest.timestamp).TotalSeconds > 60)
                ResponseTimes.TryDequeue(out _);
        }

        public static ResponseTimeStatistics GetResponseTimeStatsLastMinute()
        {
            var now = DateTime.UtcNow;
            CleanupResponseTimes(now);

            double sum = 0;
            int count = 0;
            var durations = new List<double>(ResponseTimes.Count);

            foreach (var item in ResponseTimes)
            {
                sum += item.durationMs;
                count++;
                durations.Add(item.durationMs);
            }

            if (count == 0)
            {
                return new ResponseTimeStatistics
                {
                    Average = 0,
                    PercentileAverages = InitializePercentileDictionary()
                };
            }

            durations.Sort();

            return new ResponseTimeStatistics
            {
                Average = sum / count,
                PercentileAverages = CalculatePercentileAverages(durations)
            };
        }

        static Dictionary<int, double> CalculatePercentileAverages(List<double> sortedDurations)
        {
            const int bucketCount = 10;
            var result = InitializePercentileDictionary();

            int total = sortedDurations.Count;
            int baseSize = total / bucketCount;
            int remainder = total % bucketCount;
            int currentIndex = 0;

            for (int i = 1; i <= bucketCount; i++)
            {
                int key = i * 10;
                int bucketSize = baseSize + (i <= remainder ? 1 : 0);

                if (bucketSize > 0)
                {
                    result[key] = AverageRange(sortedDurations, currentIndex, bucketSize);
                    currentIndex += bucketSize;
                }
            }

            return result;
        }

        static Dictionary<int, double> InitializePercentileDictionary()
        {
            var dict = new Dictionary<int, double>();
            for (int i = 1; i <= 10; i++)
                dict[i * 10] = 0;

            return dict;
        }

        static double AverageRange(List<double> sortedDurations, int startIndex, int length)
        {
            if (length <= 0)
                return 0;

            double total = 0;
            for (int i = 0; i < length; i++)
                total += sortedDurations[startIndex + i];

            return total / length;
        }

        public class ResponseTimeStatistics
        {
            public double Average { get; set; }

            public Dictionary<int, double> PercentileAverages { get; set; } = new();
        }
    }
}

```

## File: Lampac/Engine/Middlewares/AlwaysRjson.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Http.Extensions;
using Microsoft.AspNetCore.WebUtilities;
using Microsoft.Extensions.Primitives;
using Shared;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class AlwaysRjson
    {
        private readonly RequestDelegate _next;

        public AlwaysRjson(RequestDelegate next)
        {
            _next = next;
        }

        public Task Invoke(HttpContext context)
        {
            if (!AppInit.conf.always_rjson)
                return _next(context);

            var query = QueryHelpers.ParseQuery(context.Request.QueryString.HasValue ? context.Request.QueryString.Value : string.Empty);

            if (!RequiresRewrite(query))
                return _next(context);

            var builder = new QueryBuilder();

            foreach (var kv in query)
            {
                if (string.Equals(kv.Key, "rjson", StringComparison.OrdinalIgnoreCase))
                    continue;

                foreach (var value in kv.Value)
                    builder.Add(kv.Key, value);
            }

            builder.Add("rjson", "true");

            context.Request.QueryString = builder.ToQueryString();

            return _next(context);
        }

        static bool RequiresRewrite(IDictionary<string, StringValues> query)
        {
            if (!query.TryGetValue("rjson", out var value))
                return true;

            for (int i = 0; i < value.Count; i++)
            {
                if (string.Equals(value[i], "true", StringComparison.OrdinalIgnoreCase))
                    return false;
            }

            return true;
        }
    }
}

```

## File: Lampac/Engine/Middlewares/ProxyImg.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Shared;
using Shared.Engine;
using Shared.Models;
using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class ProxyImg
    {
        #region ProxyImg
        static FileSystemWatcher fileWatcher;

        static ConcurrentDictionary<string, long> cacheFiles = new ConcurrentDictionary<string, long>();

        static Timer cleanupTimer;

        static ProxyImg()
        {
            if (AppInit.conf.multiaccess == false)
                return;

            Directory.CreateDirectory("cache/img");

            foreach (var item in Directory.EnumerateFiles("cache/img", "*"))
                cacheFiles.TryAdd(Path.GetFileName(item), new FileInfo(item).Length);

            fileWatcher = new FileSystemWatcher
            {
                Path = "cache/img",
                NotifyFilter = NotifyFilters.FileName,
                EnableRaisingEvents = true
            };

            //fileWatcher.Created += (s, e) => 
            //{ 
            //    cacheFiles.TryAdd(e.Name, 0); 
            //};

            fileWatcher.Deleted += (s, e) => { cacheFiles.TryRemove(e.Name, out _); };

            cleanupTimer = new Timer(cleanup, null, TimeSpan.FromMinutes(60), TimeSpan.FromMinutes(60));
        }

        static void cleanup(object state)
        {
            try
            {
                var files = Directory.GetFiles("cache/img", "*").Select(f => Path.GetFileName(f)).ToHashSet();

                foreach (string md5fileName in cacheFiles.Keys.ToArray())
                {
                    if (!files.Contains(md5fileName))
                        cacheFiles.TryRemove(md5fileName, out _);
                }
            }
            catch { }
        }

        public ProxyImg(RequestDelegate next) { }
        #endregion

        async public Task InvokeAsync(HttpContext httpContext, IMemoryCache memoryCache)
        {
            using (var ctsHttp = CancellationTokenSource.CreateLinkedTokenSource(httpContext.RequestAborted))
            {
                ctsHttp.CancelAfter(TimeSpan.FromSeconds(90));

                var requestInfo = httpContext.Features.Get<RequestModel>();

                var init = AppInit.conf.serverproxy.image;
                bool cacheimg = init.cache && AppInit.conf.mikrotik == false;

                string servPath = Regex.Replace(httpContext.Request.Path.Value, "/proxyimg([^/]+)?/", "");
                string href = servPath + httpContext.Request.QueryString.Value;

                #region –ü—Ä–æ–≤–µ—Ä–∫–∏
                if (servPath.Contains("image.tmdb.org"))
                {
                    httpContext.Response.Redirect($"/tmdb/img/{Regex.Replace(href.Replace("://", ":/_/").Replace("//", "/").Replace(":/_/", "://"), "^https?://[^/]+/", "")}");
                    return;
                }

                var decryptLink = ProxyLink.Decrypt(servPath, requestInfo.IP);

                if (AppInit.conf.serverproxy.encrypt || decryptLink?.uri != null)
                {
                    href = decryptLink?.uri;
                }
                else
                {
                    if (!AppInit.conf.serverproxy.enable)
                    {
                        httpContext.Response.StatusCode = 403;
                        return;
                    }
                }

                if (string.IsNullOrWhiteSpace(href) || !href.StartsWith("http"))
                {
                    httpContext.Response.StatusCode = 404;
                    return;
                }
                #endregion

                if (AppInit.conf.serverproxy.showOrigUri)
                    httpContext.Response.Headers["PX-Orig"] = href;

                #region width / height
                int width = 0;
                int height = 0;

                if (httpContext.Request.Path.Value.StartsWith("/proxyimg:"))
                {
                    if (!cacheimg)
                        cacheimg = init.cache_rsize;

                    var gimg = Regex.Match(httpContext.Request.Path.Value, "/proxyimg:([0-9]+):([0-9]+)").Groups;
                    width = int.Parse(gimg[1].Value);
                    height = int.Parse(gimg[2].Value);
                }
                #endregion

                string md5key = CrypTo.md5($"{href}:{width}:{height}");
                string outFile = Path.Combine("cache", "img", md5key);

                string url_reserve = null;
                if (href.Contains(" or "))
                {
                    var urls = href.Split(" or ");
                    href = urls[0];
                    url_reserve = urls[1];
                }

                string contentType = href.Contains(".png") ? "image/png" : href.Contains(".webp") ? "image/webp" : "image/jpeg";
                if (width > 0 || height > 0)
                    contentType = href.Contains(".png") ? "image/png" : "image/jpeg";

                #region cacheFiles
                if (cacheFiles.ContainsKey(md5key) || (AppInit.conf.multiaccess == false && File.Exists(outFile)))
                {
                    httpContext.Response.Headers["X-Cache-Status"] = "HIT";
                    httpContext.Response.ContentType = contentType;

                    if (AppInit.conf.serverproxy.responseContentLength && cacheFiles.ContainsKey(md5key))
                        httpContext.Response.ContentLength = cacheFiles[md5key];

                    await httpContext.Response.SendFileAsync(outFile);
                    return;
                }
                #endregion

                var semaphore = cacheimg ?  new SemaphorManager(href, TimeSpan.FromMinutes(1)) : null;

                try
                {
                    string memKeyErrorDownload = $"ProxyImg:ErrorDownload:{href}";
                    if (memoryCache.TryGetValue(memKeyErrorDownload, out _))
                    {
                        httpContext.Response.Redirect(href);
                        return;
                    }

                    if (semaphore != null)
                        await semaphore.WaitAsync();

                    #region cacheFiles
                    if (cacheFiles.ContainsKey(md5key) || (AppInit.conf.multiaccess == false && File.Exists(outFile)))
                    {
                        httpContext.Response.Headers["X-Cache-Status"] = "HIT";
                        httpContext.Response.ContentType = contentType;

                        if (AppInit.conf.serverproxy.responseContentLength && cacheFiles.ContainsKey(md5key))
                            httpContext.Response.ContentLength = cacheFiles[md5key];

                        await httpContext.Response.SendFileAsync(outFile);
                        return;
                    }
                    #endregion

                    httpContext.Response.Headers["X-Cache-Status"] = cacheimg ? "MISS" : "bypass";

                    var proxyManager = decryptLink?.plugin == "posterapi" ? new ProxyManager("posterapi", AppInit.conf.posterApi) : new ProxyManager("proxyimg", init);
                    var proxy = proxyManager.Get();

                    if (width == 0 && height == 0)
                    {
                        #region bypass
                        bypass_reset:
                        var handler = Http.Handler(href, proxy);

                        var client = FrendlyHttp.HttpMessageClient("proxyimg", handler);

                        var req = new HttpRequestMessage(HttpMethod.Get, href)
                        {
                            Version = HttpVersion.Version11
                        };

                        Http.DefaultRequestHeaders(href, req, null, null, decryptLink?.headers);

                        using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(15)))
                        {
                            using (HttpResponseMessage response = await client.SendAsync(req, cts.Token))
                            {
                                if (response.StatusCode != HttpStatusCode.OK)
                                {
                                    if (url_reserve != null)
                                    {
                                        href = url_reserve;
                                        url_reserve = null;
                                        goto bypass_reset;
                                    }

                                    if (cacheimg)
                                        memoryCache.Set(memKeyErrorDownload, 0, DateTime.Now.AddSeconds(5));

                                    proxyManager.Refresh();
                                    httpContext.Response.Redirect(href);
                                    return;
                                }

                                httpContext.Response.StatusCode = (int)response.StatusCode;

                                if (response.Content.Headers.TryGetValues("Content-Type", out var contype))
                                    httpContext.Response.ContentType = contype?.FirstOrDefault() ?? contentType;
                                else
                                    httpContext.Response.ContentType = contentType;

                                if (AppInit.conf.serverproxy.responseContentLength && response.Content.Headers.ContentLength.HasValue)
                                    httpContext.Response.ContentLength = response.Content.Headers.ContentLength.Value;

                                if (cacheimg)
                                {
                                    int initialCapacity = response.Content.Headers.ContentLength.HasValue ?
                                        (int)response.Content.Headers.ContentLength.Value :
                                        50_000; // 50kB

                                    using (var memoryStream = new MemoryStream(initialCapacity))
                                    {
                                        try
                                        {
                                            bool saveCache = true;

                                            using (var responseStream = await response.Content.ReadAsStreamAsync())
                                            {
                                                byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);

                                                try
                                                {
                                                    int bytesRead;

                                                    while ((bytesRead = await responseStream.ReadAsync(buffer, ctsHttp.Token)) > 0)
                                                    {
                                                        memoryStream.Write(buffer, 0, bytesRead);
                                                        await httpContext.Response.Body.WriteAsync(buffer, 0, bytesRead, ctsHttp.Token);
                                                    }
                                                }
                                                catch
                                                {
                                                    saveCache = false;
                                                }
                                                finally
                                                {
                                                    ArrayPool<byte>.Shared.Return(buffer);
                                                }
                                            }

                                            if (saveCache && memoryStream.Length > 1000)
                                            {
                                                if (!response.Content.Headers.ContentLength.HasValue || response.Content.Headers.ContentLength.Value == memoryStream.Length)
                                                {
                                                    try
                                                    {
                                                        if (cacheFiles.ContainsKey(md5key) == false || (AppInit.conf.multiaccess == false && File.Exists(outFile) == false))
                                                        {
                                                            File.WriteAllBytes(outFile, memoryStream.ToArray());

                                                            if (AppInit.conf.multiaccess)
                                                                cacheFiles.TryAdd(md5key, memoryStream.Length);
                                                        }
                                                    }
                                                    catch { File.Delete(outFile); }
                                                }
                                            }
                                        }
                                        catch { }
                                    }
                                }
                                else
                                {
                                    await response.Content.CopyToAsync(httpContext.Response.Body, ctsHttp.Token);
                                }
                            }
                        }
                        #endregion
                    }
                    else
                    {
                        #region rsize
                        rsize_reset:
                        var array = await Download(href, proxy: proxy, headers: decryptLink?.headers);
                        if (array == null || 1000 > array.Length)
                        {
                            if (url_reserve != null)
                            {
                                href = url_reserve;
                                url_reserve = null;
                                goto rsize_reset;
                            }

                            if (cacheimg)
                                memoryCache.Set(memKeyErrorDownload, 0, DateTime.Now.AddSeconds(5));

                            proxyManager.Refresh();
                            httpContext.Response.Redirect(href);
                            return;
                        }

                        if (AppInit.conf.imagelibrary == "NetVips")
                        {
                            array = NetVipsImage(href, array, width, height);
                        }
                        else if (AppInit.conf.imagelibrary == "ImageMagick" && RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                        {
                            array = ImageMagick(array, width, height, cacheimg ? outFile : null);
                        }

                        if (cacheimg)
                        {
                            try
                            {
                                if (cacheFiles.ContainsKey(md5key) == false || (AppInit.conf.multiaccess == false && File.Exists(outFile) == false))
                                {
                                    File.WriteAllBytes(outFile, array);

                                    if (AppInit.conf.multiaccess)
                                        cacheFiles.TryAdd(md5key, array.Length);
                                }
                            }
                            catch { try { File.Delete(outFile); } catch { } }
                        }

                        proxyManager.Success();

                        httpContext.Response.ContentType = contentType;

                        if (AppInit.conf.serverproxy.responseContentLength)
                            httpContext.Response.ContentLength = array.Length;

                        await httpContext.Response.Body.WriteAsync(array, ctsHttp.Token);
                        #endregion
                    }
                }
                finally
                {
                    if (semaphore != null)
                        semaphore.Release();
                }
            }
        }


        #region Download
        async Task<byte[]> Download(string url, List<HeadersModel> headers = null, WebProxy proxy = null)
        {
            try
            {
                var handler = Http.Handler(url, proxy);

                var client = FrendlyHttp.HttpMessageClient("base", handler);

                var req = new HttpRequestMessage(HttpMethod.Get, url)
                {
                    Version = HttpVersion.Version11
                };

                if (headers != null)
                {
                    foreach (var h in headers)
                        req.Headers.TryAddWithoutValidation(h.name, h.val);
                }

                using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(15)))
                {
                    using (HttpResponseMessage response = await client.SendAsync(req, cts.Token))
                    {
                        if (response.StatusCode != HttpStatusCode.OK)
                            return null;

                        using (HttpContent content = response.Content)
                        {
                            byte[] res = await content.ReadAsByteArrayAsync();
                            if (res == null || res.Length == 0)
                                return null;

                            return res;
                        }
                    }
                }
            }
            catch
            {
                return null;
            }
        }
        #endregion

        #region NetVipsImage
        private byte[] NetVipsImage(string href, byte[] array, int width, int height)
        {
            try
            {
                using (var image = NetVips.Image.NewFromBuffer(array))
                {
                    if ((width != 0 && image.Width > width) || (height != 0 && image.Height > height))
                    {
                        using (var res = image.ThumbnailImage(width == 0 ? image.Width : width, height == 0 ? image.Height : height, crop: NetVips.Enums.Interesting.None))
                        {
                            var buffer = href.Contains(".png") ? res.PngsaveBuffer() : res.JpegsaveBuffer();
                            if (buffer != null && buffer.Length > 1000)
                            {
                                array = null;
                                return buffer;
                            }
                        }
                    }
                }
            }
            catch { }

            return array;
        }
        #endregion

        #region ImageMagick
        static string imaGikPath = null;

        /// <summary>
        /// apt install -y imagemagick libpng-dev libjpeg-dev libwebp-dev
        /// </summary>
        static byte[] ImageMagick(byte[] array, int width, int height, string myoutputFilePath)
        {
            string inputFilePath = null;
            string outputFilePath = null;

            if (Directory.Exists("/dev/shm"))
            {
                inputFilePath = $"/dev/shm/{CrypTo.md5(DateTime.Now.ToBinary().ToString())}.in";
                outputFilePath = myoutputFilePath ?? $"/dev/shm/{CrypTo.md5(DateTime.Now.ToBinary().ToString())}.out";
            }

            if (inputFilePath == null)
                inputFilePath = Path.GetTempFileName();

            if (outputFilePath == null) 
                outputFilePath = myoutputFilePath ?? Path.GetTempFileName();

            if (imaGikPath == null)
                imaGikPath = File.Exists("/usr/bin/magick") ? "magick" : "convert";

            try
            {
                File.WriteAllBytes(inputFilePath, array);

                string argsize = width > 0 && height > 0 ? $"{width}x{height}" : width > 0 ? $"{width}x" : $"x{height}";

                using (Process process = new Process())
                {
                    process.StartInfo.FileName = imaGikPath;
                    process.StartInfo.Arguments = $"\"{inputFilePath}\" -resize {argsize} \"{outputFilePath}\"";
                    process.StartInfo.RedirectStandardOutput = true;
                    process.StartInfo.RedirectStandardError = true;
                    process.StartInfo.UseShellExecute = false;
                    process.StartInfo.CreateNoWindow = true;

                    process.Start();
                    process.WaitForExit();

                    if (process.ExitCode != 0)
                        return array;
                }

                return File.ReadAllBytes(outputFilePath);
            }
            catch 
            { 
                return array; 
            }
            finally
            {
                try
                {
                    if (File.Exists(inputFilePath))
                        File.Delete(inputFilePath);

                    if (File.Exists(outputFilePath) && myoutputFilePath != outputFilePath)
                        File.Delete(outputFilePath);
                }
                catch { }
            }
        }
        #endregion
    }
}

```

## File: Lampac/Engine/Middlewares/ProxyAPI.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Shared;
using Shared.Engine;
using Shared.Models;
using Shared.Models.Proxy;
using Shared.Models.Events;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class ProxyAPI
    {
        #region ProxyAPI
        public ProxyAPI(RequestDelegate next) { }

        static ProxyAPI()
        {
            Directory.CreateDirectory("cache/hls");
        }
        #endregion

        async public Task InvokeAsync(HttpContext httpContext)
        {
            var init = AppInit.conf.serverproxy;
            var requestInfo = httpContext.Features.Get<RequestModel>();
            string reqip = requestInfo.IP;
            string servPath = httpContext.Request.Path.Value.Replace("/proxy/", "").Replace("/proxy-dash/", "");
            string servUri = servPath + httpContext.Request.QueryString.Value;

            #region tmdb proxy
            if (servUri.Contains(".themoviedb.org"))
            {
                httpContext.Response.Redirect($"/tmdb/api/{Regex.Match(servUri.Replace("://", ":/_/").Replace("//", "/").Replace(":/_/", "://"), "https?://[^/]+/(.*)").Groups[1].Value}");
                return;
            }
            else if (servUri.Contains(".tmdb.org"))
            {
                httpContext.Response.Redirect($"/tmdb/img/{Regex.Match(servUri.Replace("://", ":/_/").Replace("//", "/").Replace(":/_/", "://"), "https?://[^/]+/(.*)").Groups[1].Value}");
                return;
            }
            #endregion

            #region decryptLink
            var decryptLink = ProxyLink.Decrypt(httpContext.Request.Path.Value.StartsWith("/proxy-dash/") ? servPath.Split("/")[0] : servPath, reqip);

            if (init.encrypt || decryptLink?.uri != null || httpContext.Request.Path.Value.StartsWith("/proxy-dash/"))
            {
                servUri = decryptLink?.uri;
            }
            else
            {
                if (!init.enable)
                {
                    httpContext.Response.StatusCode = 403;
                    return;
                }
            }

            if (string.IsNullOrWhiteSpace(servUri) || !servUri.StartsWith("http"))
            {
                httpContext.Response.StatusCode = 404;
                return;
            }

            if (decryptLink == null)
                decryptLink = new ProxyLinkModel(reqip, null, null, servUri);
            #endregion

            if (init.showOrigUri)
            {
                //Console.WriteLine("PX-Orig: " + decryptLink.uri);
                httpContext.Response.Headers["PX-Orig"] = decryptLink.uri;
            }

            #region handler
            var handler = new HttpClientHandler()
            {
                AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate,
                AllowAutoRedirect = false
            };

            handler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;

            if (decryptLink.proxy != null)
            {
                handler.UseProxy = true;
                handler.Proxy = decryptLink.proxy;
            }
            else { handler.UseProxy = false; }
            #endregion

            if (httpContext.Request.Path.Value.StartsWith("/proxy-dash/"))
            {
                #region DASH
                servUri += Regex.Replace(httpContext.Request.Path.Value, "/[^/]+/[^/]+/", "") + httpContext.Request.QueryString.Value;

                var client = FrendlyHttp.HttpMessageClient("proxy", handler);

                using (var request = await CreateProxyHttpRequest(decryptLink.plugin, httpContext, decryptLink.headers, new Uri(servUri), true))
                {
                    using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(20)))
                    {
                        using (var response = await client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cts.Token).ConfigureAwait(false))
                        {
                            httpContext.Response.Headers["PX-Cache"] = "BYPASS";
                            await CopyProxyHttpResponse(httpContext, response).ConfigureAwait(false);
                        }
                    }
                }
                #endregion
            }
            else
            {
                #region Video OR
                if (servUri.Contains(" or "))
                {
                    var hdlr = new HttpClientHandler()
                    {
                        AllowAutoRedirect = true,
                        AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate
                    };

                    hdlr.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;

                    if (decryptLink.proxy != null)
                    {
                        hdlr.UseProxy = true;
                        hdlr.Proxy = decryptLink.proxy;
                    }
                    else { hdlr.UseProxy = false; }

                    string[] links = servUri.Split(" or ");
                    servUri = links[0].Trim();

                    try
                    {
                        // base => AllowAutoRedirect = true
                        var clientor = FrendlyHttp.HttpMessageClient("base", hdlr);

                        using (var requestor = await CreateProxyHttpRequest(decryptLink.plugin, httpContext, decryptLink.headers, new Uri(servUri), true))
                        {
                            using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(7)))
                            {
                                using (var response = await clientor.SendAsync(requestor, HttpCompletionOption.ResponseHeadersRead, cts.Token).ConfigureAwait(false))
                                {
                                    if ((int)response.StatusCode is 200 or 206) { }
                                    else
                                        servUri = links[1].Trim();
                                }
                            }
                        }
                    }
                    catch
                    {
                        servUri = links[1].Trim();
                    }

                    servUri = servUri.Split(" ")[0].Trim();
                    decryptLink.uri = servUri;

                    if (init.showOrigUri)
                        httpContext.Response.Headers["PX-Set-Orig"] = decryptLink.uri;
                }
                #endregion

                var client = FrendlyHttp.HttpMessageClient("proxy", handler);

                using (var request = await CreateProxyHttpRequest(decryptLink.plugin, httpContext, decryptLink.headers, new Uri(servUri), Regex.IsMatch(httpContext.Request.Path.Value, "\\.(m3u|ts|m4s|mp4|mkv|aacp|srt|vtt)", RegexOptions.IgnoreCase)))
                {
                    using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(20)))
                    {
                        using (var response = await client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cts.Token).ConfigureAwait(false))
                        {
                            if ((int)response.StatusCode is 301 or 302 or 303 or 0 || response.Headers.Location != null)
                            {
                                httpContext.Response.Redirect(validArgs($"{AppInit.Host(httpContext)}/proxy/{ProxyLink.Encrypt(response.Headers.Location.AbsoluteUri, decryptLink)}", httpContext));
                                return;
                            }

                            response.Content.Headers.TryGetValues("Content-Type", out var contentType);

                            bool ists = httpContext.Request.Path.Value.EndsWith(".ts") || httpContext.Request.Path.Value.EndsWith(".m4s");

                            if (!ists && (httpContext.Request.Path.Value.Contains(".m3u") || (contentType != null && contentType.First().ToLower() is "application/x-mpegurl" or "application/vnd.apple.mpegurl" or "text/plain")))
                            {
                                #region m3u8/txt
                                using (HttpContent content = response.Content)
                                {
                                    if (response.StatusCode == HttpStatusCode.OK || response.StatusCode == HttpStatusCode.PartialContent)
                                    {
                                        if (response.Content.Headers.ContentLength > init.maxlength_m3u)
                                        {
                                            httpContext.Response.StatusCode = 502;
                                            httpContext.Response.ContentType = "text/plain";
                                            await httpContext.Response.WriteAsync("bigfile", httpContext.RequestAborted).ConfigureAwait(false);
                                            return;
                                        }

                                        var array = await content.ReadAsByteArrayAsync(httpContext.RequestAborted).ConfigureAwait(false);
                                        if (array == null)
                                        {
                                            httpContext.Response.StatusCode = 502;
                                            await httpContext.Response.WriteAsync("error proxy m3u8", httpContext.RequestAborted).ConfigureAwait(false);
                                            return;
                                        }

                                        string hls = editm3u(Encoding.UTF8.GetString(array), httpContext, decryptLink);

                                        httpContext.Response.ContentType = contentType == null ? "application/vnd.apple.mpegurl" : contentType.First();
                                        httpContext.Response.StatusCode = (int)response.StatusCode;

                                        if (response.Headers.AcceptRanges != null)
                                            httpContext.Response.Headers["accept-ranges"] = "bytes";

                                        if (httpContext.Response.StatusCode == 206)
                                            httpContext.Response.Headers["content-range"] = $"bytes 0-{hls.Length - 1}/{hls.Length}";

                                        if (init.responseContentLength)
                                            httpContext.Response.ContentLength = hls.Length;

                                        await httpContext.Response.WriteAsync(hls, httpContext.RequestAborted).ConfigureAwait(false);
                                    }
                                    else
                                    {
                                        httpContext.Response.StatusCode = (int)response.StatusCode;
                                        await httpContext.Response.WriteAsync("error proxy m3u8", httpContext.RequestAborted).ConfigureAwait(false);
                                    }
                                }
                                #endregion
                            }
                            else if (httpContext.Request.Path.Value.Contains(".mpd") || (contentType != null && contentType.First().ToLower() is "application/dash+xml"))
                            {
                                #region dash
                                using (HttpContent content = response.Content)
                                {
                                    if (response.StatusCode == HttpStatusCode.OK)
                                    {
                                        if (response.Content.Headers.ContentLength > init.maxlength_m3u)
                                        {
                                            httpContext.Response.ContentType = "text/plain";
                                            await httpContext.Response.WriteAsync("bigfile", httpContext.RequestAborted).ConfigureAwait(false);
                                            return;
                                        }

                                        var array = await content.ReadAsByteArrayAsync(httpContext.RequestAborted).ConfigureAwait(false);
                                        if (array == null)
                                        {
                                            httpContext.Response.StatusCode = 502;
                                            await httpContext.Response.WriteAsync("error proxy mpd", httpContext.RequestAborted).ConfigureAwait(false);
                                            return;
                                        }

                                        string mpd = Encoding.UTF8.GetString(array);

                                        var m = Regex.Match(mpd, "<BaseURL>([^<]+)</BaseURL>");
                                        while (m.Success)
                                        {
                                            string baseURL = m.Groups[1].Value;
                                            mpd = Regex.Replace(mpd, baseURL, $"{AppInit.Host(httpContext)}/proxy-dash/{ProxyLink.Encrypt(baseURL, decryptLink, forceMd5: true)}/");
                                            m = m.NextMatch();
                                        }

                                        httpContext.Response.ContentType = contentType == null ? "application/dash+xml" : contentType.First();

                                        if (init.responseContentLength)
                                            httpContext.Response.ContentLength = mpd.Length;

                                        await httpContext.Response.WriteAsync(mpd, httpContext.RequestAborted).ConfigureAwait(false);
                                    }
                                    else
                                    {
                                        httpContext.Response.StatusCode = (int)response.StatusCode;
                                        await httpContext.Response.WriteAsync("error proxy", httpContext.RequestAborted).ConfigureAwait(false);
                                    }
                                }
                                #endregion
                            }
                            else
                            {
                                httpContext.Response.Headers["PX-Cache"] = "BYPASS";
                                await CopyProxyHttpResponse(httpContext, response).ConfigureAwait(false);
                            }
                        }
                    }
                }
            }
        }


        #region validArgs
        static string validArgs(string uri, HttpContext httpContext)
        {
            if (AppInit.conf.accsdb.enable && !AppInit.conf.serverproxy.encrypt)
                return AccsDbInvk.Args(uri, httpContext);

            return uri;
        }
        #endregion

        #region editm3u
        static string editm3u(string _m3u8, HttpContext httpContext, ProxyLinkModel decryptLink)
        {
            string proxyhost = $"{AppInit.Host(httpContext)}/proxy";
            string m3u8 = Regex.Replace(_m3u8, "(https?://[^\n\r\"\\# ]+)", m =>
            {
                return validArgs($"{proxyhost}/{ProxyLink.Encrypt(m.Groups[1].Value, decryptLink)}", httpContext);
            });

            string hlshost = Regex.Match(decryptLink.uri, "(https?://[^/]+)/").Groups[1].Value;
            string hlspatch = Regex.Match(decryptLink.uri, "(https?://[^\n\r]+/)([^/]+)$").Groups[1].Value;
            if (string.IsNullOrEmpty(hlspatch) && decryptLink.uri.EndsWith("/"))
                hlspatch = decryptLink.uri;

            m3u8 = Regex.Replace(m3u8, "([\n\r])([^\n\r]+)", m =>
            {
                string uri = m.Groups[2].Value;

                if (uri.Contains("#") || uri.Contains("\"") || uri.StartsWith("http"))
                    return m.Groups[0].Value;

                if (uri.StartsWith("//"))
                {
                    uri = "https:" + uri;
                }
                else if (uri.StartsWith("/"))
                {
                    uri = hlshost + uri;
                }
                else if (uri.StartsWith("./"))
                {
                    uri = hlspatch + uri.Substring(2);
                }
                else
                {
                    uri = hlspatch + uri;
                }

                return m.Groups[1].Value + validArgs($"{proxyhost}/{ProxyLink.Encrypt(uri, decryptLink)}", httpContext);
            });

            m3u8 = Regex.Replace(m3u8, "(URI=\")([^\"]+)", m =>
            {
                string uri = m.Groups[2].Value;

                if (uri.Contains("\"") || uri.StartsWith("http"))
                    return m.Groups[0].Value;

                if (uri.StartsWith("//"))
                {
                    uri = "https:" + uri;
                }
                else if (uri.StartsWith("/"))
                {
                    uri = hlshost + uri;
                }
                else if (uri.StartsWith("./"))
                {
                    uri = hlspatch + uri.Substring(2);
                }
                else
                {
                    uri = hlspatch + uri;
                }

                return m.Groups[1].Value + validArgs($"{proxyhost}/{ProxyLink.Encrypt(uri, decryptLink)}", httpContext);
            });

            return m3u8;
        }
        #endregion


        #region CreateProxyHttpRequest
        async static Task<HttpRequestMessage> CreateProxyHttpRequest(string plugin, HttpContext context, List<HeadersModel> headers, Uri uri, bool ismedia)
        {
            var request = context.Request;

            var requestMessage = new HttpRequestMessage();

            var requestMethod = request.Method;
            if (HttpMethods.IsPost(requestMethod))
            {
                var streamContent = new StreamContent(request.Body);
                requestMessage.Content = streamContent;
            }

            #region Headers
            if (headers != null && headers.Count > 0)
            {
                foreach (var item in headers)
                    requestMessage.Headers.TryAddWithoutValidation(item.name, item.val);
            }

            if (ismedia || headers != null)
            {
                foreach (var header in request.Headers)
                {
                    if (header.Key.ToLower() is "range")
                    {
                        if (!requestMessage.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray()) && requestMessage.Content != null)
                            requestMessage.Content?.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray());
                    }
                }
            }
            else
            {
                foreach (var header in request.Headers)
                {
                    if (header.Key.ToLower() is "host" or "origin" or "user-agent" or "referer" or "content-disposition" or "accept-encoding")
                        continue;

                    if (header.Key.ToLower().StartsWith("x-"))
                        continue;

                    if (!requestMessage.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray()) && requestMessage.Content != null)
                    {
                        //Console.WriteLine(header.Key + ": " + String.Join(" ", header.Value.ToArray()));
                        requestMessage.Content?.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray());
                    }
                }
            }

            if (!requestMessage.Headers.Contains("User-Agent"))
                requestMessage.Headers.TryAddWithoutValidation("User-Agent", Http.UserAgent);
            #endregion

            requestMessage.Headers.Host = uri.Authority;
            requestMessage.RequestUri = uri;
            requestMessage.Method = new HttpMethod(request.Method);

            //requestMessage.Version = new Version(2, 0);
            //Console.WriteLine(JsonConvert.SerializeObject(requestMessage.Headers, Formatting.Indented));

            await InvkEvent.ProxyApi(new EventProxyApiCreateHttpRequest(plugin, request, headers, uri, ismedia, requestMessage));

            return requestMessage;
        }
        #endregion

        #region CopyProxyHttpResponse
        async Task CopyProxyHttpResponse(HttpContext context, HttpResponseMessage responseMessage)
        {
            var response = context.Response;
            response.StatusCode = (int)responseMessage.StatusCode;
            response.ContentLength = responseMessage.Content.Headers.ContentLength;

            #region UpdateHeaders
            void UpdateHeaders(HttpHeaders headers)
            {
                foreach (var header in headers)
                {
                    if (header.Key.ToLower() is "transfer-encoding" or "etag" or "connection" or "content-security-policy" or "content-disposition")
                        continue;

                    if (!AppInit.conf.serverproxy.responseContentLength && header.Key.ToLower() == "content-length")
                        continue;

                    if (header.Key.ToLower().StartsWith("x-") || header.Key.ToLower().StartsWith("alt-"))
                        continue;

                    if (header.Key.ToLower().StartsWith("access-control"))
                        continue;

                    string value = string.Empty;
                    foreach (var val in header.Value)
                        value += $"; {val}";

                    response.Headers[header.Key] = Regex.Replace(value, "^; ", "");
                    //response.Headers[header.Key] = header.Value.ToArray();
                }
            }
            #endregion

            UpdateHeaders(responseMessage.Headers);
            UpdateHeaders(responseMessage.Content.Headers);

            using (var responseStream = await responseMessage.Content.ReadAsStreamAsync().ConfigureAwait(false))
            {
                if (response.Body == null)
                    throw new ArgumentNullException("destination");

                if (!responseStream.CanRead && !responseStream.CanWrite)
                    throw new ObjectDisposedException("ObjectDisposed_StreamClosed");

                if (!response.Body.CanRead && !response.Body.CanWrite)
                    throw new ObjectDisposedException("ObjectDisposed_StreamClosed");

                if (!responseStream.CanRead)
                    throw new NotSupportedException("NotSupported_UnreadableStream");

                if (!response.Body.CanWrite)
                    throw new NotSupportedException("NotSupported_UnwritableStream");

                var bunit = AppInit.conf.serverproxy?.buffering;

                if (bunit?.enable == true && 
                   ((!string.IsNullOrEmpty(bunit.pattern) && Regex.IsMatch(context.Request.Path.Value, bunit.pattern, RegexOptions.IgnoreCase)) || 
                   context.Request.Path.Value.EndsWith(".mp4") || context.Request.Path.Value.EndsWith(".mkv") || responseMessage.Content.Headers.ContentLength > 40_000000))
                {
                    #region buffering
                    var channel = Channel.CreateBounded<(byte[] Buffer, int Length)>(new BoundedChannelOptions(capacity: bunit.length)
                    {
                        FullMode = BoundedChannelFullMode.Wait,
                        SingleWriter = true,
                        SingleReader = true
                    });

                    var readTask = Task.Factory.StartNew(async () =>
                        {
                            try
                            {
                                while (!context.RequestAborted.IsCancellationRequested)
                                {
                                    byte[] chunkBuffer = ArrayPool<byte>.Shared.Rent(Math.Max(bunit.rent, 4096));

                                    try
                                    {
                                        int bytesRead = await responseStream.ReadAsync(chunkBuffer, 0, chunkBuffer.Length, context.RequestAborted);

                                        if (bytesRead == 0)
                                        {
                                            ArrayPool<byte>.Shared.Return(chunkBuffer);
                                            break;
                                        }

                                        await channel.Writer.WriteAsync((chunkBuffer, bytesRead), context.RequestAborted);
                                    }
                                    catch
                                    {
                                        ArrayPool<byte>.Shared.Return(chunkBuffer);
                                        break;
                                    }
                                }
                            }
                            finally
                            {
                                channel.Writer.Complete();
                            }
                        },
                        context.RequestAborted, TaskCreationOptions.LongRunning | TaskCreationOptions.DenyChildAttach, TaskScheduler.Default
                    ).Unwrap();

                    var writeTask = Task.Factory.StartNew(async () =>
                        {
                            bool reqAborted = false;

                            await foreach (var (chunkBuffer, length) in channel.Reader.ReadAllAsync(context.RequestAborted))
                            {
                                try
                                {
                                    if (reqAborted == false)
                                        await response.Body.WriteAsync(chunkBuffer, 0, length, context.RequestAborted);
                                }
                                catch 
                                {
                                    reqAborted = true;
                                }
                                finally
                                {
                                    ArrayPool<byte>.Shared.Return(chunkBuffer);
                                }
                            }
                        },
                        context.RequestAborted, TaskCreationOptions.LongRunning | TaskCreationOptions.DenyChildAttach, TaskScheduler.Default
                    ).Unwrap();

                    await Task.WhenAll(readTask, writeTask).ConfigureAwait(false);
                    #endregion
                }
                else
                {
                    #region bypass
                    byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);

                    try
                    {
                        int bytesRead;

                        while ((bytesRead = await responseStream.ReadAsync(buffer, context.RequestAborted).ConfigureAwait(false)) != 0)
                            await response.Body.WriteAsync(buffer, 0, bytesRead, context.RequestAborted).ConfigureAwait(false);
                    }
                    finally
                    {
                        ArrayPool<byte>.Shared.Return(buffer);
                    }
                    #endregion
                }
            }
        }
        #endregion
    }
}

```

## File: Lampac/Engine/Middlewares/RequestInfo.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;
using Shared;
using Shared.Models;
using System;
using System.IO;
using System.Net;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class RequestInfo
    {
        #region RequestInfo
        private readonly RequestDelegate _next;
        IMemoryCache memoryCache;

        public RequestInfo(RequestDelegate next, IMemoryCache mem)
        {
            _next = next;
            memoryCache = mem;
        }
        #endregion

        public Task Invoke(HttpContext httpContext)
        {
            #region stats
            if (AppInit.conf.openstat.enable)
            {
                string skey = $"stats:request:{DateTime.Now.Minute}";
                if (!memoryCache.TryGetValue(skey, out long _req))
                    _req = 0;

                _req++;
                memoryCache.Set(skey, _req, DateTime.Now.AddMinutes(59));
            }
            #endregion

            bool IsLocalRequest = false;
            string cf_country = null;
            string clientIp = httpContext.Connection.RemoteIpAddress.ToString();

            if (httpContext.Request.Headers.TryGetValue("localrequest", out var _localpasswd))
            {
                if (_localpasswd.ToString() != AppInit.rootPasswd)
                    return httpContext.Response.WriteAsync("error passwd", httpContext.RequestAborted);

                IsLocalRequest = true;

                if (httpContext.Request.Headers.TryGetValue("x-client-ip", out var xip) && !string.IsNullOrEmpty(xip))
                    clientIp = xip;
            }
            else if (AppInit.conf.real_ip_cf || AppInit.conf.listen.frontend == "cloudflare")
            {
                #region cloudflare
                if (Program.cloudflare_ips != null && Program.cloudflare_ips.Count > 0)
                {
                    try
                    {
                        var clientIPAddress = IPAddress.Parse(clientIp);
                        foreach (var cf in Program.cloudflare_ips)
                        {
                            if (new System.Net.IPNetwork(cf.prefix, cf.prefixLength).Contains(clientIPAddress))
                            {
                                if (httpContext.Request.Headers.TryGetValue("CF-Connecting-IP", out var xip) && !string.IsNullOrEmpty(xip))
                                    clientIp = xip;

                                if (httpContext.Request.Headers.TryGetValue("X-Forwarded-Proto", out var xfp) && !string.IsNullOrEmpty(xfp))
                                {
                                    if (xfp == "http" || xfp == "https")
                                        httpContext.Request.Scheme = xfp;
                                }

                                if (httpContext.Request.Headers.TryGetValue("CF-IPCountry", out var xcountry) && !string.IsNullOrEmpty(xcountry))
                                    cf_country = xcountry;

                                break;
                            }
                        }
                    }
                    catch { }
                }
                #endregion
            }
            // –∑–∞–ø—Ä–æ—Å —Å cloudflare, –∑–∞–ø—Ä–æ—Å –Ω–µ –≤ –∞–¥–º–∏–Ω–∫—É
            else if (httpContext.Request.Headers.ContainsKey("CF-Connecting-IP") && !httpContext.Request.Path.Value.StartsWith("/admin"))
            {
                // –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω frontend –∏ —ç—Ç–æ –Ω–µ –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞, —Ç–æ–≥–¥–∞ –≤—ã–≤–æ–¥–∏–º –æ—à–∏–±–∫—É
                if (string.IsNullOrEmpty(AppInit.conf.listen.frontend) && File.Exists("module/manifest.json"))
                    return httpContext.Response.WriteAsync(unknownFrontend, httpContext.RequestAborted);
            }

            var req = new RequestModel()
            {
                IsLocalRequest = IsLocalRequest,
                IP = clientIp,
                Country = cf_country,
                Path = httpContext.Request.Path.Value,
                Query = httpContext.Request.QueryString.Value,
                UserAgent = httpContext.Request.Headers.UserAgent
            };

            #region Weblog Request
            if (!IsLocalRequest)
            {
                string builderLog()
                {
                    var logBuilder = new System.Text.StringBuilder();
                    logBuilder.AppendLine($"{DateTime.Now}");
                    logBuilder.AppendLine($"IP: {clientIp} {req.Country}");
                    logBuilder.AppendLine($"URL: {AppInit.Host(httpContext)}{httpContext.Request.Path}{httpContext.Request.QueryString}\n");

                    foreach (var header in httpContext.Request.Headers)
                        logBuilder.AppendLine($"{header.Key}: {header.Value}");

                    return logBuilder.ToString();
                }

                if (AppInit.conf.rch.websoket == "signalr")
                {
                    if (soks.weblog_clients.Count > 0)
                        soks.SendLog(builderLog(), "request");
                }
                else
                {
                    if (nws.weblog_clients.Count > 0)
                        nws.SendLog(builderLog(), "request");
                }
            }
            #endregion

            if (!string.IsNullOrEmpty(AppInit.conf.accsdb.domainId_pattern))
            {
                string uid = Regex.Match(httpContext.Request.Host.Host, AppInit.conf.accsdb.domainId_pattern).Groups[1].Value;
                req.user = AppInit.conf.accsdb.findUser(uid);
                req.user_uid = uid;

                if (req.user == null)
                    return httpContext.Response.WriteAsync("user not found", httpContext.RequestAborted);

                req.@params = AppInit.conf.accsdb.@params;

                httpContext.Features.Set(req);
                return _next(httpContext);
            }
            else
            {
                #region getuid
                string getuid()
                {
                    if (httpContext.Request.Query.ContainsKey("token"))
                    {
                        string val = httpContext.Request.Query["token"].ToString();
                        if (!string.IsNullOrEmpty(val))
                            return val;
                    }

                    if (httpContext.Request.Query.ContainsKey("account_email"))
                    {
                        string val = httpContext.Request.Query["account_email"].ToString();
                        if (!string.IsNullOrEmpty(val))
                            return val;
                    }

                    if (httpContext.Request.Query.ContainsKey("uid"))
                    {
                        string val = httpContext.Request.Query["uid"].ToString();
                        if (!string.IsNullOrEmpty(val))
                            return val;
                    }

                    if (httpContext.Request.Query.ContainsKey("box_mac"))
                    {
                        string val = httpContext.Request.Query["box_mac"].ToString();
                        if (!string.IsNullOrEmpty(val))
                            return val;
                    }

                    return null;
                }
                #endregion

                req.user = AppInit.conf.accsdb.findUser(httpContext, out string uid);
                req.user_uid = uid;

                if (string.IsNullOrEmpty(req.user_uid))
                    req.user_uid = getuid();

                if (req.user != null)
                    req.@params = AppInit.conf.accsdb.@params;

                httpContext.Features.Set(req);
                return _next(httpContext);
            }
        }


        static string unknownFrontend = @"<!DOCTYPE html>
<html lang='ru'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>CloudFlare</title>
    <link href='/control/npm/bootstrap.min.css' rel='stylesheet'>
</head>
<body>
    <div class='container mt-5'>
        <div class='card mt-4'>
            <div class='card-body'>
                <h5 class='card-title'>–£–∫–∞–∂–∏—Ç–µ frontend –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞</h5>
				<br>
                <p class='card-text'>–î–æ–±–∞–≤—å—Ç–µ –≤ init.conf —Å–ª–µ–¥—É—é—â–∏–π –∫–æ–¥:</p>
                <pre style='background: #e9ecef;'><code>""listen"": {
  ""frontend"": ""cloudflare""
}</code></pre>
				<br>
                <p class='card-text'>–õ–∏–±–æ –æ—Ç–∫–ª—é—á–∏—Ç–µ –ø—Ä–æ–≤–µ—Ä–∫—É CF-Connecting-IP:</p>
                <pre style='background: #e9ecef;'><code>""listen"": {
  ""frontend"": ""off""
}</code></pre>
				<br>
                <p class='card-text'>–¢–∞–∫ –∂–µ –ø–∞—Ä–∞–º–µ—Ç—Ä –º–æ–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å –≤ <a href='/admin' target='_blank'>–∞–¥–º–∏–Ω–∫–µ</a>: –û—Å—Ç–∞–ª—å–Ω–æ–µ, base, frontend</p>
            </div>
        </div>
    </div>
</body>
</html>";
    }
}

```

## File: Lampac/Engine/Middlewares/Extensions.cs
```
Ôªøusing Microsoft.AspNetCore.Builder;

namespace Lampac.Engine.Middlewares
{
    public static class Extensions
    {
        public static IApplicationBuilder UseWAF(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<WAF>();
        }

        public static IApplicationBuilder UseModHeaders(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<ModHeaders>();
        }

        public static IApplicationBuilder UseRequestStatistics(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<RequestStatistics>();
        }

        public static IApplicationBuilder UseOverrideResponse(this IApplicationBuilder builder, bool first)
        {
            return builder.UseMiddleware<OverrideResponse>(first);
        }

        public static IApplicationBuilder UseRequestInfo(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<RequestInfo>();
        }

        public static IApplicationBuilder UseAnonymousRequest(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<AnonymousRequest>();
        }

        public static IApplicationBuilder UseAlwaysRjson(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<AlwaysRjson>();
        }

        public static IApplicationBuilder UseAccsdb(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<Accsdb>();
        }

        public static IApplicationBuilder UseProxyAPI(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<ProxyAPI>();
        }

        public static IApplicationBuilder UseProxyIMG(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<ProxyImg>();
        }

        public static IApplicationBuilder UseProxyCub(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<ProxyCub>();
        }

        public static IApplicationBuilder UseProxyTmdb(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<ProxyTmdb>();
        }

        public static IApplicationBuilder UseModule(this IApplicationBuilder builder, bool first)
        {
            return builder.UseMiddleware<Module>(first);
        }
    }
}

```

## File: Lampac/Engine/Middlewares/AnonymousRequest.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Shared.Models;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Lampac.Engine.Middlewares
{
    public class AnonymousRequest
    {
        static bool manifestInitial = false;

        private readonly RequestDelegate _next;
        public AnonymousRequest(RequestDelegate next)
        {
            _next = next;
        }

        public Task Invoke(HttpContext httpContext)
        {
            var requestInfo = httpContext.Features.Get<RequestModel>();

            if (!manifestInitial)
            {
                if (!File.Exists("module/manifest.json"))
                {
                    if (httpContext.Request.Path.Value.StartsWith("/admin/manifest/install"))
                    {
                        requestInfo.IsAnonymousRequest = true;
                        httpContext.Features.Set(requestInfo);
                        return _next(httpContext);
                    }

                    httpContext.Response.Redirect("/admin/manifest/install");
                    return Task.CompletedTask;
                }
                else { manifestInitial = true; }
            }

            var endpoint = httpContext.GetEndpoint();
            if (endpoint != null && endpoint.Metadata.GetMetadata<IAllowAnonymous>() != null)
                requestInfo.IsAnonymousRequest = true;

            if (httpContext.Request.Path.Value == "/" || httpContext.Request.Path.Value == "/favicon.ico")
                requestInfo.IsAnonymousRequest = true;

            if (httpContext.Request.Path.Value == "/.well-known/appspecific/com.chrome.devtools.json")
                requestInfo.IsAnonymousRequest = true;

            if (httpContext.Request.Path.Value.EndsWith("/personal.lampa"))
                requestInfo.IsAnonymousRequest = true;

            if (Regex.IsMatch(httpContext.Request.Path.Value, "^/(merchant/payconfirm|streampay|b2pay|cryptocloud|freekassa|litecoin)(/|$)", RegexOptions.IgnoreCase))
                requestInfo.IsAnonymousRequest = true;

            if (Regex.IsMatch(httpContext.Request.Path.Value, "^/(proxy-dash|cub|corseu|media|ts|kit|bind)(/|$)", RegexOptions.IgnoreCase))
                requestInfo.IsAnonymousRequest = true;

            if (Regex.IsMatch(httpContext.Request.Path.Value, "^/(api/chromium|headers|myip|geo|version|weblog|stats|rch|ping|extensions)(/|$)", RegexOptions.IgnoreCase))
                requestInfo.IsAnonymousRequest = true;

            if (Regex.IsMatch(httpContext.Request.Path.Value, "^/(on/|(lite|online|sisi|timecode|bookmark|sync|tmdbproxy|dlna|ts|tracks|transcoding|backup|catalog|invc-ws)/js/)", RegexOptions.IgnoreCase))
                requestInfo.IsAnonymousRequest = true;

            if (Regex.IsMatch(httpContext.Request.Path.Value, "^/lite/(withsearch|filmixpro|fxapi/lowlevel|kinopubpro|vokinotk|rhs/bind|iptvonline/bind|getstv/bind)(/|$)", RegexOptions.IgnoreCase))
                requestInfo.IsAnonymousRequest = true;

            if (Regex.IsMatch(httpContext.Request.Path.Value, "^/(([^/]+/)?app\\.min\\.js|([^/]+/)?css/app\\.css|[a-zA-Z\\-]+\\.js|msx/start\\.json|samsung\\.wgt)", RegexOptions.IgnoreCase))
                requestInfo.IsAnonymousRequest = true;

            httpContext.Features.Set(requestInfo);
            return _next(httpContext);
        }
    }
}

```

## File: Lampac/Engine/CRON/KurwaCron.cs
```
Ôªøusing Newtonsoft.Json;
using Shared.Engine;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;

namespace Lampac.Engine.CRON
{
    public static class KurwaCron
    {
        public static void Run()
        {
            _cronTimer = new Timer(cron, null, TimeSpan.FromHours(1), TimeSpan.FromHours(5));
        }

        static Timer _cronTimer;

        static bool _cronWork = false;

        async static void cron(object state)
        {
            if (_cronWork)
                return;

            _cronWork = true;

            try
            {
                var externalids = await Http.Get<Dictionary<string, string>>("http://194.246.82.144/externalids.json", weblog: false);
                if (externalids != null && externalids.Count > 0)
                    await File.WriteAllTextAsync("data/externalids.json", JsonConvert.SerializeObject(externalids));

                var cdnmovies = await Http.Download("http://194.246.82.144/cdnmovies.json");
                if (cdnmovies != null && cdnmovies.Length > 0)
                    await File.WriteAllBytesAsync("data/cdnmovies.json", cdnmovies);

                var veoveo = await Http.Download("http://194.246.82.144/veoveo.json");
                if (veoveo != null && veoveo.Length > 0)
                    await File.WriteAllBytesAsync("data/veoveo.json", veoveo);

                var kodik = await Http.Download("http://194.246.82.144/kodik.json");
                if (kodik != null && kodik.Length > 0)
                    await File.WriteAllBytesAsync("data/kodik.json", kodik);
            }
            catch { }
            finally
            {
                _cronWork = false;
            }
        }
    }
}

```

## File: Lampac/Engine/CRON/LampaCron.cs
```
Ôªøusing Shared;
using Shared.Engine;
using System;
using System.IO;
using System.IO.Compression;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine.CRON
{
    public static class LampaCron
    {
        static string currentapp;

        public static void Run()
        {
            var init = AppInit.conf.LampaWeb;
            _cronTimer = new Timer(cron, null, TimeSpan.FromSeconds(20), TimeSpan.FromMinutes(Math.Max(init.intervalupdate, 5)));
        }

        static Timer _cronTimer;

        static bool _cronWork = false;

        async static void cron(object state)
        {
            if (_cronWork)
                return;

            _cronWork = true;

            try
            {
                var init = AppInit.conf.LampaWeb;
                bool istree = !string.IsNullOrEmpty(init.tree);

                async ValueTask<bool> update()
                {
                    if (!init.autoupdate)
                        return false;

                    if (!File.Exists("wwwroot/lampa-main/app.min.js"))
                        return true;

                    if (istree && File.Exists("wwwroot/lampa-main/tree") && init.tree == File.ReadAllText("wwwroot/lampa-main/tree"))
                        return false;

                    string gitapp = await Http.Get($"https://raw.githubusercontent.com/{init.git}/{(istree ? init.tree : "main")}/app.min.js", weblog: false);
                    if (gitapp == null || !gitapp.Contains("author: 'Yumata'"))
                        return false;

                    if (currentapp == null)
                    {
                        currentapp = File.ReadAllText("wwwroot/lampa-main/app.min.js");
                        currentapp = CrypTo.md5(currentapp);
                    }

                    if (CrypTo.md5(gitapp) != currentapp)
                        return true;

                    if (istree)
                        File.WriteAllText("wwwroot/lampa-main/tree", init.tree);

                    return false;
                }

                if (await update())
                {
                    string uri = istree ?
                        $"https://github.com/{init.git}/archive/{init.tree}.zip" :
                        $"https://github.com/{init.git}/archive/refs/heads/main.zip";

                    byte[] array = await Http.Download(uri, MaxResponseContentBufferSize: 20_000_000, timeoutSeconds: 40);
                    if (array != null)
                    {
                        currentapp = null;

                        await File.WriteAllBytesAsync("wwwroot/lampa.zip", array);
                        ZipFile.ExtractToDirectory("wwwroot/lampa.zip", "wwwroot/", overwriteFiles: true);

                        if (istree)
                        {
                            foreach (string infilePath in Directory.GetFiles($"wwwroot/lampa-{init.tree}", "*", SearchOption.AllDirectories))
                            {
                                string outfile = infilePath.Replace($"lampa-{init.tree}", "lampa-main");
                                Directory.CreateDirectory(Path.GetDirectoryName(outfile));
                                File.Copy(infilePath, outfile, true);
                            }

                            File.WriteAllText("wwwroot/lampa-main/tree", init.tree);
                        }

                        string html = File.ReadAllText("wwwroot/lampa-main/index.html");
                        html = html.Replace("</body>", "<script src=\"/lampainit.js\"></script></body>");

                        File.WriteAllText("wwwroot/lampa-main/index.html", html);
                        File.CreateText("wwwroot/lampa-main/personal.lampa");

                        if (!File.Exists("wwwroot/lampa-main/plugins_black_list.json"))
                            File.WriteAllText("wwwroot/lampa-main/plugins_black_list.json", "[]");

                        if (!File.Exists("wwwroot/lampa-main/plugins/modification.js"))
                        {
                            Directory.CreateDirectory("wwwroot/lampa-main/plugins");
                            File.WriteAllText("wwwroot/lampa-main/plugins/modification.js", string.Empty);
                        }

                        File.Delete("wwwroot/lampa.zip");

                        if (istree)
                            Directory.Delete($"wwwroot/lampa-{init.tree}", true);
                    }
                }
            }
            catch { }
            finally
            {
                _cronWork = false;
            }
        }
    }
}

```

## File: Lampac/Engine/CRON/TrackersCron.cs
```
Ôªøusing Shared;
using Shared.Engine;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine.CRON
{
    public static class TrackersCron
    {
        public static void Run()
        {
            _cronTimer = new Timer(cron, null, TimeSpan.FromMinutes(2), TimeSpan.FromMinutes(AppInit.conf.dlna.intervalUpdateTrackers));
        }

        static Timer _cronTimer;

        static bool _cronWork = false;

        async static void cron(object state)
        {
            if (_cronWork)
                return;

            _cronWork = true;

            try
            {
                if (AppInit.modules == null || AppInit.modules.FirstOrDefault(i => i.dll == "DLNA.dll" && i.enable) == null)
                    return;

                if (AppInit.conf.dlna.enable && AppInit.conf.dlna.autoupdatetrackers)
                {
                    var trackers = new HashSet<string>();
                    var trackers_bad = new HashSet<string>();
                    var temp = new HashSet<string>();

                    foreach (string uri in new string[]
                    {
                        "http://redapi.cfhttp.top/trackers.txt",
                        "https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_all_ip.txt",
                        "https://raw.githubusercontent.com/XIU2/TrackersListCollection/master/all.txt",
                        "https://newtrackon.com/api/all"
                    })
                    {
                        string plain = await Http.Get(uri, weblog: false);
                        if (plain == null)
                            continue;

                        foreach (string line in plain.Replace("\r", "").Replace("\t", "").Split("\n"))
                            if (!string.IsNullOrEmpty(line))
                                temp.Add(line.Trim());
                    }

                    foreach (string url in temp)
                    {
                        if (await ckeck(url))
                            trackers.Add(url);
                        else
                            trackers_bad.Add(url);
                    }

                    File.WriteAllLines("cache/trackers_bad.txt", trackers_bad);
                    File.WriteAllLines("cache/trackers.txt", trackers.OrderByDescending(i => Regex.IsMatch(i, "[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+")).ThenByDescending(i => i.StartsWith("http")));
                }
            }
            catch { }
            finally
            {
                _cronWork = false;
            }
        }


        async static Task<bool> ckeck(string tracker)
        {
            if (string.IsNullOrWhiteSpace(tracker) || tracker.Contains("["))
                return false;

            if (tracker.StartsWith("http"))
            {
                try
                {
                    using (var handler = new System.Net.Http.HttpClientHandler())
                    {
                        handler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;

                        using (var client = new System.Net.Http.HttpClient(handler))
                        {
                            client.Timeout = TimeSpan.FromSeconds(7);
                            await client.GetAsync(tracker, System.Net.Http.HttpCompletionOption.ResponseHeadersRead);
                            return true;
                        }
                    }
                }
                catch { }
            }
            else if (tracker.StartsWith("udp:"))
            {
                try
                {
                    tracker = tracker.Replace("udp://", "");

                    string host = tracker.Split(':')[0].Split('/')[0];
                    int port = tracker.Contains(":") ? int.Parse(tracker.Split(':')[1].Split('/')[0]) : 6969;

                    using (UdpClient client = new UdpClient(host, port))
                    {
                        CancellationTokenSource cts = new CancellationTokenSource();
                        cts.CancelAfter(7000);

                        string uri = Regex.Match(tracker, "^[^/]/(.*)").Groups[1].Value;
                        await client.SendAsync(Encoding.UTF8.GetBytes($"GET /{uri} HTTP/1.1\r\nHost: {host}\r\n\r\n"), cts.Token);
                        return true;
                    }
                }
                catch { }
            }

            return false;
        }
    }
}

```

## File: Lampac/Engine/CRON/PluginsCron.cs
```
Ôªøusing Shared;
using Shared.Engine;
using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Lampac.Engine.CRON
{
    public static class PluginsCron
    {
        public static void Run()
        {
            _cronTimer = new Timer(cron, null, TimeSpan.FromMinutes(2), TimeSpan.FromHours(1));
        }

        static Timer _cronTimer;

        static bool _cronWork = false;

        async static void cron(object state)
        {
            if (_cronWork)
                return;

            _cronWork = true;

            try
            {
                if (!AppInit.conf.pirate_store)
                    return;

                async ValueTask update(string url, string checkcode = "Lampa.", string path = null)
                {
                    try
                    {
                        string js = await Http.Get(url, Encoding.UTF8, weblog: false);
                        if (js != null && js.Contains(checkcode))
                        {
                            if (path == null)
                                path = Path.GetFileName(url);

                            if (js.Contains("METRIKA"))
                                js = js.Replace("$('body').append(METRIKA);", "");

                            File.WriteAllText($"wwwroot/plugins/{path}", js, Encoding.UTF8);
                        }
                    }
                    catch { }
                }

                await update("https://immisterio.github.io/bwa/fx.js");
                await update("https://adultjs.onrender.com", path: "adult.js");
                await update("https://nb557.github.io/plugins/online_mod.js");
                await update("http://github.freebie.tom.ru/want.js");
                await update("https://nb557.github.io/plugins/reset_subs.js");
                await update("http://193.233.134.21/plugins/mult.js");
                await update("https://nemiroff.github.io/lampa/select_weapon.js");
                await update("https://nb557.github.io/plugins/not_mobile.js");
                await update("http://cub.red/plugin/etor", path: "etor.js");
                await update("http://193.233.134.21/plugins/checker.js");
                await update("https://plugin.rootu.top/ts-preload.js");
                await update("https://lampame.github.io/main/pubtorr/pubtorr.js");
                await update("https://lampame.github.io/main/nc/nc.js");
                await update("https://nb557.github.io/plugins/rating.js");
                await update("https://github.freebie.tom.ru/torrents.js");
                await update("https://nnmdd.github.io/lampa_hotkeys/hotkeys.js");
                await update("https://bazzzilius.github.io/scripts/gold_theme.js");
                await update("https://bdvburik.github.io/rezkacomment.js");
                await update("https://lampame.github.io/main/Shikimori/Shikimori.js");
            }
            catch { }
            finally
            {
                _cronWork = false;
            }
        }
    }
}

```

## File: Lampac/Engine/CRON/CacheCron.cs
```
Ôªøusing Shared;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;

namespace Lampac.Engine.CRON
{
    public static class CacheCron
    {
        public static void Run()
        {
            _cronTimer = new Timer(cron, null, TimeSpan.FromMinutes(2), TimeSpan.FromMinutes(4));
        }

        static Timer _cronTimer;

        static bool _cronWork = false;

        static void cron(object state)
        {
            if (_cronWork)
                return;

            _cronWork = true;

            try
            {
                var files = new Dictionary<string, FileInfo>();
                long freeDiskSpace = getFreeDiskSpace();

                foreach (var conf in new List<(string path, int minute)> {
                    ("tmdb", AppInit.conf.tmdb.cache_img),
                    ("cub", AppInit.conf.cub.cache_img),
                    ("img", AppInit.conf.serverproxy.image.cache_time),
                    ("torrent", AppInit.conf.fileCacheInactive.torrent),
                    ("html", AppInit.conf.fileCacheInactive.html),
                    ("hls", AppInit.conf.fileCacheInactive.hls),
                    ("storage/temp", 10)
                })
                {
                    try
                    {
                        if (conf.minute == -1 || !Directory.Exists(Path.Combine("cache", conf.path)))
                            continue;

                        foreach (string infile in Directory.EnumerateFiles(Path.Combine("cache", conf.path), "*", SearchOption.AllDirectories))
                        {
                            try
                            {
                                if (conf.minute == 0)
                                    File.Delete(infile);
                                else
                                {
                                    var fileinfo = new FileInfo(infile);
                                    if (DateTime.Now > fileinfo.LastWriteTime.AddMinutes(conf.minute))
                                        fileinfo.Delete();
                                    else if (1073741824 > freeDiskSpace) // 1Gb
                                        files.TryAdd(infile, fileinfo);
                                }
                            }
                            catch { }
                        }
                    }
                    catch { }
                }

                if (files.Count > 0)
                {
                    long removeGb = 0;

                    foreach (var item in files.OrderBy(i => i.Value.LastWriteTime))
                    {
                        try
                        {
                            if (File.Exists(item.Key))
                            {
                                File.Delete(item.Key);
                                removeGb += item.Value.Length;

                                // 2Gb
                                if (removeGb > 2147483648)
                                    break;
                            }
                        }
                        catch { }
                    }
                }
            }
            catch { }
            finally 
            {
                _cronWork = false;
            }
        }


        static long getFreeDiskSpace()
        {
            try
            {
                var directory = new DirectoryInfo("cache");
                var drive = DriveInfo.GetDrives()
                    .FirstOrDefault(d => d.IsReady && directory.FullName.StartsWith(d.RootDirectory.FullName, StringComparison.OrdinalIgnoreCase));
                return drive?.AvailableFreeSpace ?? -1;
            }
            catch
            {
                return -1;
            }
        }
    }
}

```

## File: Lampac/Engine/CRON/SyncCron.cs
```
Ôªøusing Shared;
using Shared.Engine;
using Shared.Models;
using System;
using System.Threading;

namespace Lampac.Engine.CRON
{
    public static class SyncCron
    {
        public static void Run()
        {
            _cronTimer = new Timer(cron, null, TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(1));
        }

        static Timer _cronTimer;

        static bool _cronWork = false;

        async static void cron(object state)
        {
            if (_cronWork)
                return;

            _cronWork = true;

            try
            {
                var sync = AppInit.conf?.sync;

                if (sync == null || !sync.enable || sync.type != "slave" || string.IsNullOrEmpty(sync.api_host) || string.IsNullOrEmpty(sync.api_passwd))
                    return;

                var init = await Http.Get<AppInit>(sync.api_host + "/api/sync", timeoutSeconds: 5, headers: HeadersModel.Init("localrequest", sync.api_passwd), weblog: false);
                if (init != null)
                {
                    if (sync.sync_full)
                    {
                        init.sync = sync;
                        AppInit.conf = init;
                    }
                    else
                    {
                        AppInit.conf.accsdb.users = init.accsdb.users;
                    }
                }
            }
            catch { }
            finally
            {
                _cronWork = false;
            }
        }
    }
}

```

## File: Online/GlobalUsings.cs
```
Ôªøglobal using System;
global using System.Web;
global using System.Threading.Tasks;
global using System.Collections.Generic;
global using System.Text.RegularExpressions;
global using System.Collections.Concurrent;
global using System.IO;
global using System.Linq;
global using Shared;
global using Shared.Models;
global using Shared.Engine;
global using Shared.Engine.Online;
global using Shared.Models.Templates;
global using Shared.Models.Base;
```

## File: Online/OnlineApi.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Events;
using Shared.Models.Module;
using Shared.Models.Module.Entrys;
using Shared.Models.SQL;
using Shared.PlaywrightCore;
using System.Data;
using System.Text;
using IO = System.IO;

namespace Online.Controllers
{
    public class OnlineApiController : BaseController
    {
        #region online.js
        [HttpGet]
        [AllowAnonymous]
        [Route("online.js")]
        [Route("online/js/{token}")]
        public ContentResult Online(string token)
        {
            var init = AppInit.conf.online;
            var apr = init.appReplace ?? InvkEvent.conf?.Controller?.AppReplace?.online?.regex;

            string memKey = $"online.js:{apr?.Count ?? 0}:{InvkEvent.conf?.Controller?.AppReplace?.online?.list?.Count ?? 0}:{init.version}:{init.description}:{init.apn}:{host}:{init.spider}:{init.component}:{init.name}:{init.spiderName}";
            if (!memoryCache.TryGetValue(memKey, out (string file, string filecleaer) cache))
            {
                cache.file = FileCache.ReadAllText("plugins/online.js", saveCache: false)
                    .Replace("{rch_websoket}", FileCache.ReadAllText($"plugins/rch_{AppInit.conf.rch.websoket}.js", saveCache: false));

                string playerinner = FileCache.ReadAllText("plugins/player-inner.js", saveCache: false)
                       .Replace("{useplayer}", (!string.IsNullOrEmpty(AppInit.conf.playerInner)).ToString().ToLower())
                       .Replace("{notUseTranscoding}", (AppInit.conf.transcoding.enable == false).ToString().ToLower());

                #region appReplace
                if (apr != null)
                {
                    foreach (var r in apr)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        cache.file = Regex.Replace(cache.file, r.Key, val, RegexOptions.IgnoreCase);
                    }
                }

                if (InvkEvent.conf?.Controller?.AppReplace?.online?.list != null)
                {
                    foreach (var r in InvkEvent.conf.Controller.AppReplace.online.list)
                    {
                        string val = r.Value;
                        if (val.StartsWith("file:"))
                            val = IO.File.ReadAllText(val.Substring(5));

                        cache.file = cache.file.Replace(r.Key, val);
                    }
                }
                #endregion

                if (!init.version)
                {
                    cache.file = Regex.Replace(cache.file, "version: \\'[^\\']+\\'", "version: ''")
                                      .Replace("manifst.name, \" v\"", "manifst.name, \" \"");
                }

                if (init.description != "–ü–ª–∞–≥–∏–Ω –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –æ–Ω–ª–∞–π–Ω —Å–µ—Ä–∏–∞–ª–æ–≤ –∏ —Ñ–∏–ª—å–º–æ–≤")
                    cache.file = Regex.Replace(cache.file, "description: \\'([^\\']+)?\\'", $"description: '{init.description}'");

                if (init.apn != null)
                    cache.file = Regex.Replace(cache.file, "apn: \\'([^\\']+)?\\'", $"apn: '{init.apn}'");

                var bulder = new StringBuilder(cache.file);

                if (!init.spider)
                {
                    bulder = bulder.Replace("addSourceSearch('Spider', 'spider');", "")
                                   .Replace("addSourceSearch('Anime', 'spider/anime');", "");
                }

                if (init.component != "lampac")
                {
                    bulder = bulder.Replace("component: 'lampac'", $"component: '{init.component}'")
                                   .Replace("'lampac', component", $"'{init.component}', component")
                                   .Replace("window.lampac_plugin", $"window.{init.component}_plugin");
                }

                if (init.name != "Lampac")
                    bulder = bulder.Replace("name: 'Lampac'", $"name: '{init.name}'");

                if (init.spiderName != "Spider")
                {
                    bulder = bulder.Replace("addSourceSearch('Spider'", $"addSourceSearch('{init.spiderName}'")
                                   .Replace("addSourceSearch('Anime'", $"addSourceSearch('{init.spiderName} - Anime'");
                }

                bulder = bulder
                    .Replace("{invc-rch}", FileCache.ReadAllText("plugins/invc-rch.js", saveCache: false))
                    .Replace("{invc-rch_nws}", FileCache.ReadAllText("plugins/invc-rch_nws.js", saveCache: false))
                    .Replace("{player-inner}", playerinner)
                    .Replace("{localhost}", host);

                cache.file = bulder.ToString();
                cache.filecleaer = cache.file.Replace("{token}", string.Empty);

                if (AppInit.conf.mikrotik == false)
                    memoryCache.Set(memKey, cache, DateTime.Now.AddMinutes(1));
            }

            if (InvkEvent.conf?.Controller?.AppReplace?.online?.eval != null)
            {
                string source = InvkEvent.AppReplace("online", new EventAppReplace(cache.file, token, null, host, requestInfo, HttpContext.Request, hybridCache));
                return Content(source.Replace("{token}", HttpUtility.UrlEncode(token)), "application/javascript; charset=utf-8");
            }

            return Content(token != null ? cache.file.Replace("{token}", HttpUtility.UrlEncode(token)) : cache.filecleaer, "application/javascript; charset=utf-8");
        }
        #endregion

        #region lite.js
        [HttpGet]
        [AllowAnonymous]
        [Route("lite.js")]
        [Route("lite/js/{token}")]
        public ActionResult Lite(string token)
        {
            var sb = new StringBuilder(FileCache.ReadAllText("plugins/lite.js"));

            sb.Replace("{localhost}", $"{host}/lite")
              .Replace("{token}", HttpUtility.UrlEncode(token));

            return Content(sb.ToString(), "application/javascript; charset=utf-8");
        }
        #endregion


        #region externalids
        /// <summary>
        /// imdb_id, kinopoisk_id
        /// </summary>
        static ConcurrentDictionary<string, string> externalids = new ConcurrentDictionary<string, string>();

        static DateTime externalids_lastWriteTime = default, externalids_nextCheck = default;

        [Route("externalids")]
        async public ValueTask<ActionResult> Externalids(string id, string imdb_id, long kinopoisk_id, int serial)
        {
            #region load externalids
            if (IO.File.Exists("data/externalids.json"))
            {
                try
                {
                    if (externalids_nextCheck > DateTime.Now || externalids_nextCheck == default)
                    {
                        externalids_nextCheck = DateTime.Now.AddMinutes(5);
                        var lastWriteTime = IO.File.GetLastWriteTime("data/externalids.json");
                        if (lastWriteTime != externalids_lastWriteTime)
                        {
                            externalids_lastWriteTime = lastWriteTime;
                            foreach (var item in JsonConvert.DeserializeObject<Dictionary<string, string>>(IO.File.ReadAllText("data/externalids.json")))
                                externalids.AddOrUpdate(item.Key, item.Value, (k, v) => item.Value);
                        }
                    }
                }
                catch { }
            }
            #endregion

            #region KP_
            if (id != null && id.StartsWith("KP_"))
            {
                string _kp = id.Substring(0, 3);
                foreach (var eid in externalids)
                {
                    if (eid.Value == _kp && !string.IsNullOrEmpty(eid.Key))
                    {
                        imdb_id = eid.Key;
                        break;
                    }
                }

                if (!string.IsNullOrEmpty(imdb_id))
                {
                    return Json(new { imdb_id, kinopoisk_id = _kp });
                }
                else
                {
                    string mkey = $"externalids:KP_:{_kp}";
                    if (!hybridCache.TryGetValue(mkey, out string _imdbid, inmemory: false))
                    {
                        string json = await Http.Get($"https://api.alloha.tv/?token=04941a9a3ca3ac16e2b4327347bbc1&kp=" + _kp, timeoutSeconds: 5);
                        _imdbid = Regex.Match(json ?? "", "\"id_imdb\":\"(tt[^\"]+)\"").Groups[1].Value;
                        hybridCache.Set(mkey, _imdbid, DateTime.Now.AddHours(8), inmemory: false);
                    }

                    return Json(new { imdb_id = _imdbid, kinopoisk_id = _kp });
                }
            }
            #endregion

            #region getAlloha / getVSDN / getTabus
            async Task<string> getAlloha(string imdb)
            {
                var proxyManager = new ProxyManager("alloha", AppInit.conf.Alloha);
                string json = await Http.Get("https://api.alloha.tv/?token=04941a9a3ca3ac16e2b4327347bbc1&imdb=" + imdb, timeoutSeconds: 5, proxy: proxyManager.Get());
                if (json == null)
                    return null;

                string kpid = Regex.Match(json, "\"id_kp\":([0-9]+),").Groups[1].Value;
                if (!string.IsNullOrEmpty(kpid) && kpid != "0" && kpid != "null")
                    return kpid;

                return null;
            }

            async Task<string> getVSDN(string imdb)
            {
                if (AppInit.conf.Lumex.spider && AppInit.conf.mikrotik == false)
                {
                    long? res = Lumex.database.FirstOrDefault(i => i.imdb_id == imdb).kinopoisk_id;
                    if (res > 0)
                        return res.ToString();
                }

                if (string.IsNullOrEmpty(AppInit.conf.VideoCDN.token) || string.IsNullOrEmpty(AppInit.conf.VideoCDN.iframehost))
                    return null;

                var proxyManager = new ProxyManager("vcdn", AppInit.conf.VideoCDN);
                string json = await Http.Get($"{AppInit.conf.VideoCDN.iframehost}/api/short?api_token={AppInit.conf.VideoCDN.token}&imdb_id={imdb}", timeoutSeconds: 5, proxy: proxyManager.Get());
                if (json == null)
                    return null;

                string kpid = Regex.Match(json, "\"kp_id\":\"?([0-9]+)\"?").Groups[1].Value;
                if (!string.IsNullOrEmpty(kpid) && kpid != "0" && kpid != "null")
                    return kpid;

                return null;
            }

            async Task<string> getTabus(string imdb)
            {
                var proxyManager = new ProxyManager("collaps", AppInit.conf.Collaps);
                string json = await Http.Get("https://api.bhcesh.me/franchise/details?token=d39edcf2b6219b6421bffe15dde9f1b3&imdb_id=" + imdb.Remove(0, 2), timeoutSeconds: 5, proxy: proxyManager.Get());
                if (json == null)
                    return null;

                string kpid = Regex.Match(json, "\"kinopoisk_id\":\"?([0-9]+)\"?").Groups[1].Value;
                if (!string.IsNullOrEmpty(kpid) && kpid != "0" && kpid != "null")
                    return kpid;

                return null;
            }
            #endregion

            #region get imdb_id
            if (string.IsNullOrWhiteSpace(imdb_id))
            {
                if (kinopoisk_id > 0)
                {
                    string kinopoisk_id_str = kinopoisk_id.ToString();
                    foreach (var eid in externalids)
                    {
                        if (eid.Value == kinopoisk_id_str && !string.IsNullOrEmpty(eid.Key))
                        {
                            imdb_id = eid.Key;
                            break;
                        }
                    }
                }

                if (string.IsNullOrWhiteSpace(imdb_id) && long.TryParse(id, out long _testid) && _testid > 0)
                {
                    using (var sqlDb = new ExternalidsContext())
                        imdb_id = sqlDb.imdb.Find($"{id}_{serial}")?.value;

                    if (string.IsNullOrEmpty(imdb_id))
                    {
                        string mkey = $"externalids:locktmdb:{serial}:{id}";
                        if (!hybridCache.TryGetValue(mkey, out _))
                        {
                            hybridCache.Set(mkey, 0, DateTime.Now.AddHours(1));

                            string cat = serial == 1 ? "tv" : "movie";
                            var header = HeadersModel.Init(("localrequest", AppInit.rootPasswd));
                            string json = await Http.Get($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/3/{cat}/{id}?api_key={AppInit.conf.tmdb.api_key}&append_to_response=external_ids", timeoutSeconds: 5, headers: header);
                            if (!string.IsNullOrWhiteSpace(json))
                            {
                                imdb_id = Regex.Match(json, "\"imdb_id\":\"(tt[0-9]+)\"").Groups[1].Value;
                                if (!string.IsNullOrEmpty(imdb_id))
                                {
                                    using (var sqlDb = new ExternalidsContext())
                                    {
                                        sqlDb.Add(new ExternalidsSqlModel()
                                        {
                                            Id = $"{id}_{serial}",
                                            value = imdb_id
                                        });

                                        await sqlDb.SaveChangesLocks();
                                    }
                                }
                            }
                        }
                    }
                }
            }
            #endregion

            #region get kinopoisk_id
            string kpid = null;

            if (!string.IsNullOrWhiteSpace(imdb_id))
            {
                externalids.TryGetValue(imdb_id, out kpid);

                if (string.IsNullOrEmpty(kpid) || kpid == "0")
                {
                    using (var sqlDb = new ExternalidsContext())
                    {
                        kpid = sqlDb.kinopoisk.Find(imdb_id)?.value;

                        if (string.IsNullOrEmpty(kpid) && kinopoisk_id == 0)
                        {
                            string mkey = $"externalids:lockkpid:{imdb_id}";
                            if (!hybridCache.TryGetValue(mkey, out _))
                            {
                                hybridCache.Set(mkey, 0, DateTime.Now.AddDays(1));

                                switch (AppInit.conf.online.findkp ?? "all")
                                {
                                    case "alloha":
                                        kpid = await getAlloha(imdb_id);
                                        break;
                                    case "vsdn":
                                        kpid = await getVSDN(imdb_id);
                                        break;
                                    case "tabus":
                                        kpid = await getTabus(imdb_id);
                                        break;
                                    default:
                                        {
                                            var tasks = new List<Task<string>> { getVSDN(imdb_id), getAlloha(imdb_id), getTabus(imdb_id) };

                                            while (tasks.Count > 0)
                                            {
                                                var completedTask = await Task.WhenAny(tasks);
                                                tasks.Remove(completedTask);

                                                var result = completedTask.Result;
                                                if (result != null)
                                                {
                                                    kpid = result;
                                                    break;
                                                }
                                            }

                                            break;
                                        }
                                }

                                if (!string.IsNullOrEmpty(kpid) && kpid != "0")
                                {
                                    sqlDb.Add(new ExternalidsSqlModel()
                                    {
                                        Id = imdb_id,
                                        value = kpid
                                    });

                                    await sqlDb.SaveChangesLocks();
                                }
                            }
                        }
                    }
                }
            }
            #endregion

            kpid = kpid != null ? kpid : kinopoisk_id.ToString();
            InvkEvent.Externalids(id, ref imdb_id, ref kpid, serial);

            return Content($"{{\"imdb_id\":\"{imdb_id}\",\"kinopoisk_id\":\"{kpid}\"}}", "application/json; charset=utf-8");
        }
        #endregion

        #region WithSearch
        [AllowAnonymous]
        [Route("lite/withsearch")]
        public ActionResult WithSearch()
        {
            if (AppInit.conf.online.with_search == null)
                return ContentTo("[]");

            return Json(AppInit.conf.online.with_search);
        }
        #endregion

        #region spider
        [Route("lite/spider")]
        [Route("lite/spider/anime")]
        async public Task<ActionResult> Spider(string title)
        {
            if (!AppInit.conf.online.spider)
                return ContentTo("{}");

            var rch = new RchClient(HttpContext, host, new BaseSettings() { rhub = true }, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var user = requestInfo.user;
            var piders = new List<(string name, string uri, int index)>();

            bool isanime = HttpContext.Request.Path.Value?.EndsWith("/anime") == true;

            #region module
            OnlineModuleEntry.EnsureCache();
            var spiderArgs = new OnlineSpiderModel(title, isanime);

            if (OnlineModuleEntry.onlineModulesCache != null && OnlineModuleEntry.onlineModulesCache.Count > 0)
            {
                void addResult(List<(string name, string url, int index)> result)
                {
                    if (result == null || result.Count == 0)
                        return;

                    foreach (var item in result)
                    {
                        if (string.IsNullOrEmpty(item.name) || string.IsNullOrEmpty(item.url))
                            continue;

                        piders.Add((item.name, item.url, item.index));
                    }
                }

                foreach (var entry in OnlineModuleEntry.onlineModulesCache)
                {
                    try
                    {
                        if (entry.Spider != null)
                        {
                            try
                            {
                                var result = entry.Spider(HttpContext, memoryCache, requestInfo, host, spiderArgs);
                                addResult(result);
                            }
                            catch { }
                        }

                        if (entry.SpiderAsync != null)
                        {
                            try
                            {
                                var result = await entry.SpiderAsync(HttpContext, memoryCache, requestInfo, host, spiderArgs);
                                addResult(result);
                            }
                            catch { }
                        }

                    }
                    catch (Exception ex) { Console.WriteLine($"Modules {entry.mod?.NamespacePath(entry.mod.online)}: {ex.Message}\n\n"); }
                }
            }
            #endregion

            #region send
            void send(BaseSettings init, string plugin = null)
            {
                if (!init.spider || !init.enable || init.rip)
                    return;

                if (init.geo_hide != null)
                {
                    if (requestInfo.Country != null && init.geo_hide.Contains(requestInfo.Country))
                        return;
                }

                if (init.group_hide)
                {
                    if (init.group > 0)
                    {
                        if (user == null || init.group > user.group)
                            return;
                    }
                    else if (AppInit.conf.accsdb.enable)
                    {
                        if (user == null && string.IsNullOrEmpty(AppInit.conf.accsdb.premium_pattern))
                            return;
                    }
                }

                string url = null;
                string displayname = init.displayname ?? init.plugin;

                if (string.IsNullOrEmpty(init.overridepasswd))
                {
                    url = init.overridehost;
                    if (string.IsNullOrEmpty(url) && init.overridehosts != null && init.overridehosts.Length > 0)
                        url = init.overridehosts[Random.Shared.Next(0, init.overridehosts.Length)];
                }

                if (string.IsNullOrEmpty(url))
                    url = $"{host}/lite/" + (plugin ?? init.plugin).ToLower();

                piders.Add((init.displayname ?? init.plugin, $"{url}?title={HttpUtility.UrlEncode(title)}&clarification=1&rjson=true&similar=true", init.displayindex));
            }
            #endregion

            if (isanime)
            {
                send(AppInit.conf.Kodik);
                send(AppInit.conf.AnimeLib);
                send(AppInit.conf.AnilibriaOnline, "anilibria");
                send(AppInit.conf.Animevost);
                send(AppInit.conf.Animebesst);
                send(AppInit.conf.MoonAnime);
                send(AppInit.conf.AnimeGo);
            }

            send(AppInit.conf.Filmix);
            send(AppInit.conf.FilmixTV, "filmixtv");
            send(AppInit.conf.FilmixPartner, "fxapi");

            send(AppInit.conf.Rezka);
            send(AppInit.conf.RezkaPrem, "rhsprem");

            send(AppInit.conf.KinoPub);
            send(AppInit.conf.Kinogo);
            send(AppInit.conf.GetsTV, "getstv-search");
            send(AppInit.conf.Kinobase);
            send(AppInit.conf.Alloha, "alloha-search");
            send(AppInit.conf.Collaps, "collaps-search");
            send(AppInit.conf.VeoVeo, "veoveo-spider");

            if (!string.IsNullOrEmpty(AppInit.conf.VideoCDN.token))
                send(AppInit.conf.VideoCDN);

            if (AppInit.conf.Lumex.priorityBrowser == "http" || PlaywrightBrowser.Status != PlaywrightStatus.disabled)
                send(AppInit.conf.Lumex);

            send(AppInit.conf.VDBmovies);
            send(AppInit.conf.HDVB, "hdvb-search");

            return Json(piders.OrderByDescending(i => i.index).ToDictionary(k => k.name, v => v.uri));
        }
        #endregion


        #region events
        [HttpGet]
        [AllowAnonymous]
        [Route("lifeevents")]
        public ActionResult LifeEvents(string memkey, long id, string imdb_id, long kinopoisk_id, int serial)
        {
            string json = null;
            JsonResult error(string msg) => Json(new { accsdb = true, ready = true, online = new string[] { }, msg });

            List<(string code, int index, bool work)> _links = null;
            if (memoryCache.TryGetValue(memkey, out List<(string code, int index, bool work)> links))
                _links = links.ToList();

            if (_links != null && _links.Count(i => i.code != null) > 0)
            {
                bool ready = _links.Count == _links.Count(i => i.code != null);
                string online = string.Join(",", _links.Where(i => i.code != null).OrderByDescending(i => i.work).ThenBy(i => i.index).Select(i => i.code));

                if (ready && !online.Contains("\"show\":true"))
                {
                    if (string.IsNullOrEmpty(imdb_id) && 0 >= kinopoisk_id)
                        return error($"–î–æ–±–∞–≤—å—Ç–µ \"IMDB ID\" {(serial == 1 ? "—Å–µ—Ä–∏–∞–ª–∞" : "—Ñ–∏–ª—å–º–∞")} –Ω–∞ https://themoviedb.org/{(serial == 1 ? "tv" : "movie")}/{id}/edit?active_nav_item=external_ids");

                    return error($"–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –æ–Ω–ª–∞–π–Ω –¥–ª—è {(serial == 1 ? "—Å–µ—Ä–∏–∞–ª–∞" : "—Ñ–∏–ª—å–º–∞")}");
                }

                json = "{" + $"\"ready\":{ready.ToString().ToLower()},\"tasks\":{_links.Count},\"online\":[{online.Replace("{localhost}", host)}]" + "}";
            }

            return Content(json ?? "{\"ready\":false,\"tasks\":0,\"online\":[]}", contentType: "application/javascript; charset=utf-8");
        }


        [HttpGet]
        [Route("lite/events")]
        async public ValueTask<ActionResult> Events(string id, string imdb_id, long kinopoisk_id, long tmdb_id, string title, string original_title, string original_language, int year, string source, string rchtype, int serial = -1, bool life = false, bool islite = false, string account_email = null, string uid = null, string token = null, string nws_id = null)
        {
            var online = new List<(dynamic init, string name, string url, string plugin, int index)>(50);
            bool isanime = original_language is "ja" or "zh";

            #region fix title
            bool fix_title = false;

            if (title != null && original_language != null && original_language.Split("|")[0] is "ja" or "ko" or "zh" or "cn")
            {
                if (long.TryParse(id, out long tmdbid) && tmdbid > 0)
                {
                    Regex chineseRegex = new Regex("[\u4E00-\u9FFF]"); // –î–∏–∞–ø–∞–∑–æ–Ω –¥–ª—è –∫–∏—Ç–∞–π—Å–∫–∏—Ö –∏–µ—Ä–æ–≥–ª–∏—Ñ–æ–≤
                    Regex japaneseRegex = new Regex("[\u3040-\u30FF\uFF66-\uFF9F]"); // –•–∏—Ä–∞–≥–∞–Ω–∞, –∫–∞—Ç–∞–∫–∞–Ω–∞ –∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
                    Regex koreanRegex = new Regex("[\uAC00-\uD7AF]"); // –î–∏–∞–ø–∞–∑–æ–Ω –¥–ª—è –∫–æ—Ä–µ–π—Å–∫–∏—Ö —Ö–∞–Ω–≥—ã–ª—å—Å–∫–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤

                    if (chineseRegex.IsMatch(title) || japaneseRegex.IsMatch(title) || koreanRegex.IsMatch(title))
                    {
                        var header = HeadersModel.Init(("localrequest", AppInit.rootPasswd));
                        var result = await Http.Get<JObject>($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/tmdb/api/3/{(serial == 1 ? "tv" : "movie")}/{tmdbid}?api_key={AppInit.conf.tmdb.api_key}&language=en", timeoutSeconds: 4, headers: header);
                        if (result != null)
                        {
                            string _title = serial == 1 ? result.Value<string>("name") : result.Value<string>("title");
                            if (!string.IsNullOrEmpty(_title))
                            {
                                title = _title;
                                fix_title = true;
                            }
                        }
                    }
                }
            }
            #endregion

            var conf = AppInit.conf;
            var user = requestInfo.user;
            JObject kitconf = await loadKitConf();

            #region modules
            OnlineModuleEntry.EnsureCache();

            if (OnlineModuleEntry.onlineModulesCache != null && OnlineModuleEntry.onlineModulesCache.Count > 0)
            {
                var args = new OnlineEventsModel(id, imdb_id, kinopoisk_id, title, original_title, original_language, year, source, rchtype, serial, life, islite, account_email, uid, token, nws_id);

                foreach (var entry in OnlineModuleEntry.onlineModulesCache)
                {
                    try
                    {
                        #region version >= 3 methods
                        if (entry.Invoke != null)
                        {
                            try
                            {
                                var result = entry.Invoke(HttpContext, memoryCache, requestInfo, host, args);
                                if (result != null && result.Count > 0)
                                {
                                    foreach (var r in result)
                                        online.Add((null, r.name, r.url, r.plugin, r.index));
                                }
                            }
                            catch { }
                        }

                        if (entry.InvokeAsync != null)
                        {
                            try
                            {
                                var result = await entry.InvokeAsync(HttpContext, memoryCache, requestInfo, host, args);
                                if (result != null && result.Count > 0)
                                {
                                    foreach (var r in result)
                                        online.Add((null, r.name, r.url, r.plugin, r.index));
                                }
                            }
                            catch { }
                        }
                        #endregion

                        #region version < 3 legacy methods
                        if (entry.Events != null)
                        {
                            try
                            {
                                long.TryParse(id, out long tmdbid);
                                var result = entry.Events(host, tmdbid, imdb_id, kinopoisk_id, title, original_title, original_language, year, source, serial, account_email);
                                if (result != null && result.Count > 0)
                                {
                                    foreach (var r in result)
                                        online.Add((null, r.name, r.url, r.plugin, r.index));
                                }
                            }
                            catch { }
                        }

                        if (entry.EventsAsync != null)
                        {
                            try
                            {
                                long.TryParse(id, out long tmdbid);
                                var result = await entry.EventsAsync(HttpContext, memoryCache, host, tmdbid, imdb_id, kinopoisk_id, title, original_title, original_language, year, source, serial, account_email);
                                if (result != null && result.Count > 0)
                                {
                                    foreach (var r in result)
                                        online.Add((null, r.name, r.url, r.plugin, r.index));
                                }
                            }
                            catch { }
                        }
                        #endregion
                    }
                    catch (Exception ex) { Console.WriteLine($"Modules {entry.mod?.NamespacePath(entry.mod.online)}: {ex.Message}\n\n"); }
                }
            }
            #endregion

            #region send
            void send(BaseSettings _init, string plugin = null, string name = null, string arg_title = null, string arg_url = null, string rch_access = null, BaseSettings myinit = null)
            {
                var init = myinit != null ? _init : loadKit(_init, kitconf);
                bool enable = init.enable && !init.rip;
                if (!enable)
                    return;

                if (init.rhub && !init.rhub_fallback)
                {
                    if (rch_access != null && rchtype != null) 
                    {
                        enable = rch_access.Contains(rchtype);
                        if (enable && init.rhub_geo_disable != null)
                        {
                            if (requestInfo.Country != null && init.rhub_geo_disable.Contains(requestInfo.Country))
                                enable = false;
                        }
                    }
                }

                if (enable && init.client_type != null && rchtype != null)
                    enable = init.client_type.Contains(rchtype);

                if (init.geo_hide != null)
                {
                    if (requestInfo.Country != null && init.geo_hide.Contains(requestInfo.Country))
                        enable = false;
                }

                if (enable)
                {
                    if (init.group_hide)
                    {
                        if (init.group > 0)
                        {
                            if (user == null || init.group > user.group)
                                return;
                        }
                        else if (AppInit.conf.accsdb.enable)
                        {
                            if (user == null && string.IsNullOrEmpty(AppInit.conf.accsdb.premium_pattern))
                                return;
                        }
                    }

                    string url = string.Empty;

                    if (string.IsNullOrEmpty(init.overridepasswd))
                    {
                        url = init.overridehost;
                        if (string.IsNullOrEmpty(url) && init.overridehosts != null && init.overridehosts.Length > 0)
                            url = init.overridehosts[Random.Shared.Next(0, init.overridehosts.Length)];
                    }

                    string displayname = init.displayname ?? name ?? init.plugin;

                    if (!string.IsNullOrEmpty(url))
                    {
                        if (plugin == "collaps-dash")
                        {
                            displayname = displayname.Replace("- 720p", "- 1080p");
                            url = url.Replace("/collaps", "/collaps-dash");
                        }
                    }
                    else {
                        url = "{localhost}/lite/" + (plugin ?? (init.plugin ?? name).ToLower()) + arg_url;
                    }

                    if (original_language != null && original_language.Split("|")[0] is "ru" or "ja" or "ko" or "zh" or "cn")
                    {
                        string _p = (plugin ?? (init.plugin ?? name).ToLower());
                        if (_p is "filmix" or "filmixtv" or "fxapi" or "kinoukr" or "rezka" or "rhsprem" or "redheadsound" or "kinopub" or "alloha" or "lumex" or "vcdn" or "videocdn" or "fancdn" or "redheadsound" or "kinotochka" or "remux") // || (_p == "kodik" && kinopoisk_id == 0 && string.IsNullOrEmpty(imdb_id))
                            url += (url.Contains("?") ? "&" : "?") + "clarification=1";
                    }

                    online.Add((myinit, $"{displayname}{arg_title}", url, (plugin ?? init.plugin ?? name).ToLower(), init.displayindex > 0 ? init.displayindex : online.Count));
                }
            }
            #endregion

            if (original_language != null && original_language.Split("|")[0] is "ja" or "ko" or "zh" or "cn" or "th" or "vi" or "tl")
                send(conf.Kodik);

            if (serial == -1 || isanime)
            {
                send(conf.AniLiberty);
                send(conf.AnilibriaOnline, "anilibria", "Anilibria");
                send(conf.AnimeLib);
                send(conf.Animevost, rch_access: "apk,cors");
                send(conf.Animebesst, rch_access: "apk");
                send(conf.AnimeGo);
                send(conf.AniMedia);
                send(conf.MoonAnime);
            }

            #region VoKino
            if (kinopoisk_id > 0 || source?.ToLower() == "vokino")
            {
                string vid = kinopoisk_id.ToString();
                if (source?.ToLower() == "vokino" && !string.IsNullOrEmpty(id))
                    vid = id;

                var myinit = loadKit(conf.VoKino, kitconf , (j, i, c) => 
                {
                    if (j.ContainsKey("online"))
                        i.online = c.online;

                    return i;
                });

                if (myinit.enable && !string.IsNullOrEmpty(myinit.token))
                {
                    async ValueTask vkino()
                    {
                        if (myinit.rhub || !conf.online.checkOnlineSearch)
                        {
                            VoKinoInvoke.SendOnline(myinit, online, null);
                        }
                        else
                        {
                            if (!hybridCache.TryGetValue($"vokino:view:{vid}", out JObject view))
                            {
                                view = await Http.Get<JObject>($"{myinit.corsHost()}/v2/view/{vid}?token={myinit.token}", timeoutSeconds: 4);
                                if (view != null)
                                    hybridCache.Set($"vokino:view:{vid}", view, cacheTime(20));
                            }

                            if (view != null && view.ContainsKey("online") && view["online"] is JObject onlineObj)
                                VoKinoInvoke.SendOnline(myinit, online, onlineObj);
                        }
                    };

                    if (AppInit.conf.accsdb.enable)
                    {
                        if (user != null)
                        {
                            if (myinit.group > user.group && myinit.group_hide) { }
                            else
                                await vkino();
                        }
                        else
                        {
                            if (!string.IsNullOrEmpty(AppInit.conf.accsdb.premium_pattern))
                                await vkino();
                        }
                    }
                    else
                    {
                        if (myinit.group > 0 && myinit.group_hide && (user == null || myinit.group > user.group)) { }
                        else
                            await vkino();
                    }
                }
            }
            #endregion

            #region Filmix
            {
                var myinit = loadKit(conf.Filmix, kitconf, (j, i, c) => 
                { 
                    if (j.ContainsKey("pro"))
                        i.pro = c.pro; 
                    return i; 
                });

                if (string.IsNullOrEmpty(myinit.token) && (myinit.tokens == null || myinit.tokens.Length == 0) && conf.Filmix.hidefreeStart > 0)
                {
                    if (TimeZoneTo.ByIds(["Europe/Kyiv", "Europe/Kiev", "FLE Standard Time"], out DateTime kievTime))
                    {
                        if (kievTime.Hour >= conf.Filmix.hidefreeStart && kievTime.Hour < conf.Filmix.hidefreeEnd)
                            myinit.enable = false;
                    }
                }

                send(myinit, myinit: myinit, rch_access: "apk");
            }

            send(conf.FilmixTV, "filmixtv");
            send(conf.FilmixPartner, "fxapi", "Filmix");
            #endregion

            send(conf.KinoPub);
            send(conf.IptvOnline, "iptvonline", "iptv.online");
            send(conf.GetsTV);

            #region Alloha
            {
                var myinit = loadKit(conf.Alloha, kitconf , (j, i, c) => 
                { 
                    if (j.ContainsKey("m4s"))
                        i.m4s = c.m4s;
                    return i; 
                });

                send(myinit, myinit: myinit);
            }
            #endregion

            #region Rezka
            {
                var rezka_premium = loadKit(conf.RezkaPrem, kitconf , (j, i, c) => 
                {
                    if (j.ContainsKey("premium"))
                        i.premium = c.premium; 
                    return i; 
                });

                send(rezka_premium, "rhsprem", "HDRezka", myinit: rezka_premium);

                if (rezka_premium.enable == false)
                {
                    var myinit = await loadKit(conf.Rezka, (j, i, c) =>
                    {
                        if (j.ContainsKey("premium"))
                            i.premium = c.premium;
                        return i;
                    });

                    send(myinit, myinit: myinit);
                }
            }
            #endregion

            if (PlaywrightBrowser.Status != PlaywrightStatus.disabled)
                send(conf.Mirage);

            if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Kinobase.overridehost) || conf.Kinobase.overridehosts?.Length > 0)
                send(conf.Kinobase);

            if (conf.VDBmovies.rhub || conf.VDBmovies.priorityBrowser == "http" || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.VDBmovies.overridehost) || conf.VDBmovies.overridehosts?.Length > 0)
                send(conf.VDBmovies, rch_access: "apk");

            if (kinopoisk_id > 0)
            {
                if (conf.VideoDB.rhub || conf.VideoDB.priorityBrowser == "http" || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.VideoDB.overridehost) || conf.VideoDB.overridehosts?.Length > 0)
                    send(conf.VideoDB, rch_access: "apk");

                if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Zetflix.overridehost) || conf.Zetflix.overridehosts?.Length > 0)
                    send(conf.Zetflix);
            }

            if (serial == -1 || serial == 0 || !string.IsNullOrEmpty(conf.FanCDN.token) || !string.IsNullOrEmpty(conf.FanCDN.overridehost) || conf.FanCDN.overridehosts?.Length > 0)
            {
                if (conf.FanCDN.rhub || conf.FanCDN.priorityBrowser == "http" || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.FanCDN.overridehost) || conf.FanCDN.overridehosts?.Length > 0)
                    send(conf.FanCDN, rch_access: "apk");
            }

            send(conf.VideoCDN);

            if (conf.Lumex.priorityBrowser == "http" || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Lumex.overridehost) || conf.Lumex.overridehosts?.Length > 0)
                send(conf.Lumex);

            if (conf.Kinogo.rhub || PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Kinogo.overridehost) || conf.Kinogo.overridehosts?.Length > 0)
                send(conf.Kinogo, rch_access: "apk");

            if (kinopoisk_id > 0)
                send(conf.Ashdi, "ashdi", "Ashdi (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π)");

            if (!isanime)
                send(conf.Kinoukr, "kinoukr", "Kinoukr (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π)", rch_access: "apk,cors");

            send(conf.Eneyida, "eneyida", "Eneyida (–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π)", rch_access: "apk,cors");

            #region Collaps
            {
                var myinit = loadKit(conf.Collaps, kitconf, (j, i, c) =>
                {
                    if (j.ContainsKey("dash"))
                        i.dash = c.dash;
                    if (j.ContainsKey("two"))
                        i.two = c.two;
                    return i;
                });

                send(myinit, "collaps", $"Collaps ({(myinit.dash ? "DASH" : "HLS")})", rch_access: "apk", myinit: myinit);

                if (myinit.two && !myinit.dash)
                    send(myinit, "collaps-dash", "Collaps (DASH)", rch_access: "apk");
            }
            #endregion

            if (serial == -1 || serial == 0)
            {
                send(conf.Plvideo, "plvideo", "Plvideo", rch_access: "apk,cors");
                send(conf.RutubeMovie, "rutubemovie", "Rutube", rch_access: "apk,cors");
                send(conf.VkMovie, "vkmovie", "VK –í–∏–¥–µ–æ", rch_access: "apk,cors");
            }

            if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Videoseed.overridehost) || conf.Videoseed.overridehosts?.Length > 0)
                send(conf.Videoseed);

            send(conf.Vibix, rch_access: "apk");
            send(conf.VeoVeo);

            if (serial == -1 || serial == 0)
                send(conf.iRemux, "remux");

            #region PidTor
            if (conf.PidTor.enable)
            {
                if ((conf.PidTor.torrs != null && conf.PidTor.torrs.Length > 0) || (conf.PidTor.auth_torrs != null && conf.PidTor.auth_torrs.Count > 0) || AppInit.modules.FirstOrDefault(i => i.dll == "TorrServer.dll" && i.enable) != null)
                {
                    void psend()
                    {
                        var _conf = InvkEvent.conf.PidTor != null ? conf.PidTor.Clone() : conf.PidTor;

                        InvkEvent.PidTor(new EventPidTor(_conf, requestInfo, hybridCache));

                        if (!_conf.enable)
                            return;

                        if (_conf.group > 0 && _conf.group_hide)
                        {
                            if (user == null || _conf.group > user.group)
                                return;
                        }

                        online.Add((null, $"{_conf.displayname ?? "Pid≈¶or"}", "{localhost}/lite/pidtor", "pidtor", _conf.displayindex > 0 ? _conf.displayindex : online.Count));
                    }

                    psend();
                }
            }
            #endregion

            if (serial == -1 || serial == 0)
                send(conf.Redheadsound, rch_access: "apk");

            send(conf.HDVB, rch_access: "apk");
            send(conf.Kinotochka, rch_access: "apk,cors");

            if ((serial == -1 || (serial == 1 && !isanime)) && kinopoisk_id > 0)
                send(conf.CDNmovies, rch_access: "apk,cors");

            if (serial == -1 || serial == 0)
                send(conf.IframeVideo);

            if (kinopoisk_id > 0 && !isanime)
                send(conf.CDNvideohub, "cdnvideohub", "VideoHUB", rch_access: "apk,cors");

            #region ENG
            if ((original_language == null || original_language == "en") && conf.disableEng == false)
            {
                if (tmdb_id > 0 || (source != null && (source is "tmdb" or "cub")))
                {
                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Hydraflix.overridehost) || conf.Hydraflix.overridehosts?.Length > 0)
                        send(conf.Hydraflix, "hydraflix", "HydraFlix (ENG)");

                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Vidsrc.overridehost) || conf.Vidsrc.overridehosts?.Length > 0)
                        send(conf.Vidsrc, "vidsrc", "VidSrc (ENG)");

                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.VidLink.overridehost) || conf.VidLink.overridehosts?.Length > 0)
                        send(conf.VidLink, "vidlink", "VidLink (ENG)");

                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Videasy.overridehost) || conf.Videasy.overridehosts?.Length > 0)
                        send(conf.Videasy, "videasy", "Videasy (ENG)");

                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.MovPI.overridehost) || conf.MovPI.overridehosts?.Length > 0)
                        send(conf.MovPI, "movpi", "MovPI (ENG)");

                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Smashystream.overridehost) || conf.Smashystream.overridehosts?.Length > 0)
                        send(conf.Smashystream, "smashystream", "SmashyStream (ENG)");

                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Autoembed.overridehost) || conf.Autoembed.overridehosts?.Length > 0)
                        send(conf.Autoembed, "autoembed", "AutoEmbed (ENG)");

                    if (PlaywrightBrowser.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Playembed.overridehost) || conf.Playembed.overridehosts?.Length > 0)
                        send(conf.Playembed, "playembed", "PlayEmbed (ENG)");

                    if (Firefox.Status != PlaywrightStatus.disabled || !string.IsNullOrEmpty(conf.Twoembed.overridehost) || conf.Twoembed.overridehosts?.Length > 0)
                        send(conf.Twoembed, "twoembed", "2Embed (ENG)");

                    send(conf.Rgshows, "rgshows", "RgShows (ENG)");
                }
            }
            #endregion

            if (!life && conf.litejac)
                online.Add((null, "–¢–æ—Ä—Ä–µ–Ω—Ç—ã", "{localhost}/lite/jac", "jac", 200));

            #region checkOnlineSearch
            bool chos = conf.online.checkOnlineSearch && !string.IsNullOrEmpty(id);

            if (chos && IO.File.Exists("isdocker"))
            {
                string version = await Http.Get($"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}/version", timeoutSeconds: 4, headers: HeadersModel.Init("localrequest", AppInit.rootPasswd));
                if (version == null || !version.StartsWith(appversion))
                    chos = false;
            }

            if (chos)
            {
                string memkey = CrypTo.md5($"checkOnlineSearch:{id}:{serial}:{source?.Replace("tmdb", "")?.Replace("cub", "")}:{online.Count}:{(IsKitConf ? requestInfo.user_uid : null)}");

                if (!memoryCache.TryGetValue(memkey, out List<(string code, int index, bool work)> links) || !conf.multiaccess)
                {
                    var tasks = new List<Task>();
                    links = new List<(string code, int index, bool work)>(online.Count);
                    for (int i = 0; i < online.Count; i++)
                        links.Add(default);

                    memoryCache.Set(memkey, links, DateTime.Now.AddMinutes(5));

                    foreach (var o in online)
                    {
                        var tk = checkSearch(memkey, links, tasks.Count, o.init, o.index, o.name, o.url, o.plugin, id, imdb_id, kinopoisk_id, tmdb_id, title, original_title, original_language, source, year, serial, life, rchtype);
                        tasks.Add(tk);
                    }

                    if (life)
                        return Json(new { life = true, memkey, title = (fix_title ? title : null) });

                    await Task.WhenAll(tasks);
                }

                if (life)
                    return Json(new { life = true, memkey });

                return ContentTo($"[{string.Join(",", links.Where(i => i.code != null).OrderByDescending(i => i.work).ThenBy(i => i.index).Select(i => i.code)).Replace("{localhost}", host)}]");
            }
            #endregion

            string online_result = string.Join(",", online.OrderBy(i => i.index).Select(i => "{\"name\":\"" + i.name + "\",\"url\":\"" + i.url + "\",\"balanser\":\"" + i.plugin + "\"}"));
            return ContentTo($"[{online_result.Replace("{localhost}", host)}]");
        }
        #endregion

        #region checkSearch
        async Task checkSearch(string memkey, List<(string code, int index, bool work)> links, int indexList, dynamic init, int index, string name, string uri, string plugin,
                               string id, string imdb_id, long kinopoisk_id, long tmdb_id, string title, string original_title, string original_language, string source,  int year, int serial, bool life, string rchtype)
        {
            try
            {
                string srq = uri.Replace("{localhost}", $"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}");
                var header = uri.Contains("{localhost}") ? HeadersModel.Init(("xhost", host), ("xscheme", HttpContext.Request.Scheme), ("localrequest", AppInit.rootPasswd)) : null;

                string checkuri = $"{srq}{(srq.Contains("?") ? "&" : "?")}id={HttpUtility.UrlEncode(id)}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&tmdb_id={tmdb_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&original_language={original_language}&source={source}&year={year}&serial={serial}&rchtype={rchtype}&checksearch=true";
                string res = await Http.Get(AccsDbInvk.Args(checkuri, HttpContext), timeoutSeconds: 10, headers: header);

                if (string.IsNullOrEmpty(res))
                    res = string.Empty;

                bool rch = res.Contains("\"rch\":true");
                bool work = rch || res.Contains("data-json=") 
                    || res.Contains("\"type\":\"movie\"") 
                    || res.Contains("\"type\":\"episode\"")
                    || res.Contains("\"type\":\"season\"");

                string quality = string.Empty;
                string balanser = plugin.Contains("/") ? plugin.Split("/")[1] : plugin;

                #region –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞
                if (work && life)
                {
                    foreach (string q in new string[] { "2160", "1080", "720", "480", "360" })
                    {
                        if (res.Contains("<!--q:"))
                        {
                            quality = " - " + Regex.Match(res, "<!--q:([^>]+)-->").Groups[1].Value;
                            break;
                        }
                        else if (res.Contains($"\"{q}p\"") || res.Contains($">{q}p<") || res.Contains($"<!--{q}p-->"))
                        {
                            quality = $" - {q}p";
                            break;
                        }
                    }

                    if (quality == "2160")
                        quality = res.Contains("HDR") ? " - 4K HDR" : " - 4K";

                    if (init != null)
                    {
                        if (balanser == "filmix")
                        {
                            if (!init.pro)
                                quality = string.IsNullOrEmpty(init.token) ? " - 480p" : " - 720p";
                        }

                        if (balanser == "alloha")
                            quality = string.IsNullOrEmpty(quality) ? (init.m4s ? " ~ 2160p" : " ~ 1080p") : quality;

                        if (balanser == "rezka" || balanser == "rhs")
                        {
                            string rezkaq = init.premium ? " ~ 2160p" : " ~ 720p";
                            quality = string.IsNullOrEmpty(quality) ? rezkaq : quality;
                        }

                        if (balanser == "collaps")
                            quality = init.dash ? " ~ 1080p" : " ~ 720p";
                    }

                    if (quality == string.Empty)
                    {
                        switch (balanser)
                        {
                            case "fxapi":
                            case "filmix":
                            case "filmixtv":
                            case "kinopub":
                            case "vokino":
                            case "vokino-alloha":
                            case "vokino-filmix":
                            case "alloha":
                            case "remux":
                            case "pidtor":
                            case "rhsprem":
                            case "animelib":
                            case "mirage":
                            case "videodb":
                            case "iptvonline":
                            case "plvideo":
                            case "rutubemovie":
                            case "vkmovie":
                                quality = " ~ 2160p";
                                break;
                            case "kinobase":
                            case "kinogo":
                            case "getstv":
                            case "zetflix":
                            case "vcdn":
                            case "videocdn":
                            case "lumex":
                            case "vibix":
                            case "videoseed":
                            case "eneyida":
                            case "kinoukr":
                            case "ashdi":
                            case "hdvb":
                            case "anilibria":
                            case "aniliberty":
                            case "redheadsound":
                            case "iframevideo":
                            case "animego":
                            case "lostfilmhd":
                            case "vdbmovies":
                            case "collaps-dash":
                            case "fancdn":
                            case "cdnvideohub":
                            case "moonanime":
                            case "playembed":
                            case "rgshows":
                            case "twoembed":
                            case "vidsrc":
                            case "smashystream":
                            case "hydraflix":
                            case "movpi":
                            case "videasy":
                            case "vidlink":
                            case "autoembed":
                            case "veoveo":
                            case "vokino-vibix":
                            case "vokino-monframe":
                            case "vokino-remux":
                            case "vokino-ashdi":
                            case "vokino-hdvb":
                                quality = " ~ 1080p";
                                break;
                            case "voidboost":
                            case "animedia":
                            case "animevost":
                            case "animebesst":
                            case "kodik":
                            case "kinotochka":
                            case "rhs":
                                quality = " ~ 720p";
                                break;
                            case "kinokrad":
                            case "kinoprofi":
                            case "seasonvar":
                                quality = " - 480p";
                                break;
                            case "cdnmovies":
                                quality = " - 360p";
                                break;
                            default:
                                break;
                        }

                        if (balanser == "vokino")
                            quality = res.Contains("4K HDR") ? " - 4K HDR" : res.Contains("4K ") ? " - 4K" : quality;
                    }
                }
                #endregion

                if (!name.Contains(" - ") && AppInit.conf.online.showquality && !string.IsNullOrEmpty(quality))
                {
                    name = Regex.Replace(name, " ~ .*$", "");
                    name += quality;
                }

                links[indexList] = ("{" + $"\"name\":\"{name}\",\"url\":\"{uri}\",\"index\":{index},\"show\":{work.ToString().ToLower()},\"balanser\":\"{plugin}\",\"rch\":{rch.ToString().ToLower()}" + "}", index, work);
            }
            catch (Exception ex) { Console.WriteLine("checkSearch: " + ex.ToString()); }
        }
        #endregion
    }
}
```

## File: Online/Controllers/Collaps.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Collaps;

namespace Online.Controllers
{
    public class Collaps : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/collaps")]
        [Route("lite/collaps-dash")]
        async public ValueTask<ActionResult> Index(long orid, string imdb_id, long kinopoisk_id, string title, string original_title, int s = -1, bool origsource = false, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.Collaps, (j, i, c) =>
            {
                if (j.ContainsKey("two"))
                    i.two = c.two;
                if (j.ContainsKey("dash"))
                    i.dash = c.dash;
                return i;
            });

            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            if (similar || (orid == 0 && kinopoisk_id == 0 && string.IsNullOrWhiteSpace(imdb_id)))
                return await Search(title, origsource, rjson);

            string module = HttpContext.Request.Path.Value.StartsWith("/lite/collaps-dash") ? "dash" : "hls";
            if (module == "dash")
                init.dash = true;
            else if (init.two)
                init.dash = false;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var oninvk = new CollapsInvoke
            (
               host,
               init.corsHost(),
               init.dash,
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl), httpHeaders(init)) : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               onstreamtofile => rch.enable ? onstreamtofile : HostStreamProxy(init, onstreamtofile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            reset:
            var cache = await InvokeCache<EmbedModel>($"collaps:view:{imdb_id}:{kinopoisk_id}:{orid}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(imdb_id, kinopoisk_id, orid);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => 
            {
                string html = oninvk.Html(cache.Value, imdb_id, kinopoisk_id, orid, title, original_title, s, vast: init.vast, rjson: rjson, headers: httpHeaders(init.host, init.headers_stream));
                if (module == "dash")
                    html = html.Replace("lite/collaps", "lite/collaps-dash");

                return html;

            }, origsource: origsource, gbcache: !rch.enable);
        }


        [HttpGet]
        [Route("lite/collaps-search")]
        async public ValueTask<ActionResult> Search(string title, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.Collaps);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            reset: 
            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var cache = await InvokeCache<ResultSearch[]>($"collaps:search:{title}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string uri = $"{init.apihost}/list?token={init.token}&name={HttpUtility.UrlEncode(title)}";
                var root = rch.enable ? await rch.Get<JObject>(uri) : await Http.Get<JObject>(uri, timeoutSeconds: 8, proxy: proxy);
                if (root == null || !root.ContainsKey("results"))
                    return res.Fail("results");

                return root["results"].ToObject<ResultSearch[]>();
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () =>
            {
                var stpl = new SimilarTpl(cache.Value.Length);

                foreach (var j in cache.Value)
                {
                    string uri = $"{host}/lite/collaps?orid={j.id}";
                    stpl.Append(j.name ?? j.origin_name, j.year.ToString(), string.Empty, uri, PosterApi.Size(j.poster));
                }

                return rjson ? stpl.ToJson() : stpl.ToHtml();

            }, origsource: origsource, gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/iRemux.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace Online.Controllers
{
    public class iRemux : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.iRemux);

        #region iRemuxInvoke
        public iRemuxInvoke InitRemuxInvoke()
        {
            var proxy = proxyManager.Get();
            var init = AppInit.conf.iRemux;

            return new iRemuxInvoke
            (
               host,
               init.corsHost(),
               ongettourl => Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, cookie: init.cookie, headers: httpHeaders(init)),
               (url, data) => Http.Post(init.cors(url), data, timeoutSeconds: 8, proxy: proxy, cookie: init.cookie, headers: httpHeaders(init)),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
               requesterror: () => proxyManager.Refresh()
            );
        }
        #endregion

        [HttpGet]
        [Route("lite/remux")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int year, string href, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.iRemux);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title ?? original_title) || year == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var oninvk = InitRemuxInvoke();

            var content = await InvokeCache($"remux:{title}:{original_title}:{year}:{href}", cacheTime(40, init: init), () => oninvk.Embed(title, original_title, year, href), proxyManager);
            if (content == null)
                return OnError();

            return ContentTo(oninvk.Html(content, title, original_title, year, rjson: rjson));
        }


        [HttpGet]
        [Route("lite/remux/movie")]
        async public ValueTask<ActionResult> Movie(string linkid, string quality, string title, string original_title)
        {
            var init = await loadKit(AppInit.conf.iRemux);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var oninvk = InitRemuxInvoke();

            string weblink = await InvokeCache($"remux:view:{linkid}:{proxyManager.CurrentProxyIp}", cacheTime(20), () => oninvk.Weblink(linkid), proxyManager);
            if (weblink == null)
                return OnError();

            return ContentTo(oninvk.Movie(weblink, quality, title, original_title, vast: init.vast));
        }
    }
}

```

## File: Online/Controllers/HDVB.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.HDVB;

namespace Online.Controllers
{
    public class HDVB : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.HDVB);

        [HttpGet]
        [Route("lite/hdvb")]
        async public ValueTask<ActionResult> Index(long kinopoisk_id, string title, string original_title, int t = -1, int s = -1, bool origsource = false, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.HDVB);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            if (similar || kinopoisk_id == 0)
                return await SpiderSearch(title, origsource, rjson);

            #region search
            reset:
            JArray data = await search(rch, kinopoisk_id);
            if (data == null)
            {
                if(init.rhub && init.rhub_fallback)
                {
                    init.rhub = false;
                    goto reset;
                }

                return OnError();
            }
            #endregion

            if (data.First.Value<string>("type") == "movie")
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, data.Count);

                foreach (var m in data)
                {
                    string link = $"{host}/lite/hdvb/video?kinopoisk_id={kinopoisk_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&iframe={HttpUtility.UrlEncode(m.Value<string>("iframe_url"))}";
                    
                    mtpl.Append(m.Value<string>("translator"), link, "call", accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true"));
                }

                return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                if (s == -1)
                {
                    var tpl = new SeasonTpl();
                    var tmp_season = new HashSet<string>();

                    foreach (var voice in data)
                    {
                        foreach (var season in voice.Value<JArray>("serial_episodes"))
                        {
                            string season_name = $"{season.Value<int>("season_number")} —Å–µ–∑–æ–Ω";
                            if (tmp_season.Contains(season_name))
                                continue;

                            tmp_season.Add(season_name);

                            string link = $"{host}/lite/hdvb?rjson={rjson}&serial=1&kinopoisk_id={kinopoisk_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&s={season.Value<int>("season_number")}";
                            tpl.Append(season_name, link, season.Value<int>("season_number"));
                        }
                    }

                    return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                }
                else
                {
                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var vtpl = new VoiceTpl();

                    for (int i = 0; i < data.Count; i++)
                    {
                        if (data[i].Value<JArray>("serial_episodes").FirstOrDefault(i => i.Value<int>("season_number") == s) == null)
                            continue;

                        if (t == -1)
                            t = i;

                        string link = $"{host}/lite/hdvb?rjson={rjson}&serial=1&kinopoisk_id={kinopoisk_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&s={s}&t={i}";
                        vtpl.Append(data[i].Value<string>("translator"), t == i, link);
                    }
                    #endregion

                    var etpl = new EpisodeTpl();
                    string iframe = HttpUtility.UrlEncode(data[t].Value<string>("iframe_url"));
                    string translator = HttpUtility.UrlEncode(data[t].Value<string>("translator"));

                    string sArhc = s.ToString();

                    foreach (int episode in data[t].Value<JArray>("serial_episodes").FirstOrDefault(i => i.Value<int>("season_number") == s).Value<JArray>("episodes").ToObject<List<int>>())
                    {
                        string link = $"{host}/lite/hdvb/serial?title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&iframe={iframe}&t={translator}&s={s}&e={episode}";
                        string streamlink = accsArgs($"{link.Replace("/serial", "/serial.m3u8")}&play=true");

                        etpl.Append($"{episode} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.ToString(), link, "call", streamlink: streamlink);
                    }

                    if (rjson)
                        return ContentTo(etpl.ToJson(vtpl));

                    return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                }
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/hdvb/video")]
        [Route("lite/hdvb/video.m3u8")]
        async public ValueTask<ActionResult> Video(string iframe, string title, string original_title, bool play)
        {
            var init = await loadKit(AppInit.conf.HDVB);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            var proxy = proxyManager.Get();

            string memKey = $"video:view:video:{iframe}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out string urim3u8))
                {
                    var header = httpHeaders(init, HeadersModel.Init(
                        ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                        ("sec-fetch-dest", "document"),
                        ("sec-fetch-mode", "navigate"),
                        ("sec-fetch-site", "none")
                    ));

                    reset:
                    string html = rch.enable ? await rch.Get(iframe, header) :
                                               await Http.Get(iframe, timeoutSeconds: 8, proxy: proxy, headers: header);

                    if (html != null)
                    {
                        string vid = "vid11";
                        string href = Regex.Match(html, "\"href\":\"([^\"]+)\"").Groups[1].Value;
                        string csrftoken = Regex.Match(html, "\"key\":\"([^\"]+)\"").Groups[1].Value.Replace("\\", "");
                        string file = Regex.Match(html, "\"file\":\"([^\"]+)\"").Groups[1].Value.Replace("\\", "");
                        file = Regex.Replace(file, "^/playlist/", "/");
                        file = Regex.Replace(file, "\\.txt$", "");

                        if (!string.IsNullOrWhiteSpace(href) && !string.IsNullOrWhiteSpace(file) && !string.IsNullOrWhiteSpace(csrftoken))
                        {
                            string origin = Regex.Match(iframe, "(https?://[^/]+)").Groups[1].Value;

                            header = httpHeaders(init, HeadersModel.Init(
                                ("accept", "*/*"),
                                ("origin", origin),
                                ("referer", $"{origin}/"),
                                ("sec-fetch-dest", "empty"),
                                ("sec-fetch-mode", "cors"),
                                ("sec-fetch-site", "same-site"),
                                ("x-csrf-token", csrftoken)
                            ));

                            urim3u8 = rch.enable ? await rch.Post($"https://{vid}.{href}/playlist/{file}.txt", "", header) :
                                                   await Http.Post($"https://{vid}.{href}/playlist/{file}.txt", "", timeoutSeconds: 8, proxy: proxy, headers: header);

                            if (urim3u8 != null)
                            {
                                if (!urim3u8.Contains("/index.m3u8"))
                                {
                                    file = Regex.Match(urim3u8, "\"file\":\"([^\"]+)\"").Groups[1].Value.Replace("\\", "");
                                    file = Regex.Replace(file, "^/playlist/", "/");
                                    file = Regex.Replace(file, "\\.txt$", "");

                                    if (!string.IsNullOrEmpty(file))
                                    {
                                        urim3u8 = rch.enable ? await rch.Post($"https://{vid}.{href}/playlist/{file}.txt", "", header) :
                                                               await Http.Post($"https://{vid}.{href}/playlist/{file}.txt", "", timeoutSeconds: 8, proxy: proxy, headers: header);
                                    }
                                }
                            }
                        }
                    }

                    if (string.IsNullOrEmpty(urim3u8))
                    {
                        if (!rch.enable)
                            proxyManager.Refresh();

                        if (init.rhub && init.rhub_fallback)
                        {
                            init.rhub = false;
                            goto reset;
                        }

                        return OnError();
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, urim3u8, cacheTime(20, init: init));
                }

                string m3u8 = HostStreamProxy(init, urim3u8, proxy: proxy);

                if (play)
                    return RedirectToPlay(m3u8);

                return ContentTo(VideoTpl.ToJson("play", m3u8, (title ?? original_title), vast: init.vast));
            });
        }
        #endregion

        #region Serial
        [HttpGet]
        [Route("lite/hdvb/serial")]
        [Route("lite/hdvb/serial.m3u8")]
        async public ValueTask<ActionResult> Serial(string iframe, string t, string s, string e, string title, string original_title, bool play)
        {
            var init = await loadKit(AppInit.conf.HDVB);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            var proxy = proxyManager.Get();

            string memKey = $"video:view:serial:{iframe}:{t}:{s}:{e}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out string urim3u8))
                {
                    string vid = "vid11";

                    #region playlist
                    string mkey_playlist = $"video:view:playlist:{iframe}";
                    if (!hybridCache.TryGetValue(mkey_playlist, out (List<Folder> playlist, string href, List<HeadersModel> header) cache))
                    {
                        cache.header = httpHeaders(init, HeadersModel.Init(
                            ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                            ("sec-fetch-dest", "iframe"),
                            ("sec-fetch-mode", "navigate"),
                            ("sec-fetch-site", "cross-site"),
                            ("referer", $"{init.host}/")
                        ));

                        reset_playlist:
                        string html = rch.enable ? await rch.Get(iframe, cache.header) :
                                                   await Http.Get(iframe, timeoutSeconds: 8, proxy: proxy, headers: cache.header);

                        if (html != null)
                        {
                            string href = Regex.Match(html, "\"href\":\"([^\"]+)\"").Groups[1].Value;
                            string csrftoken = Regex.Match(html, "\"key\":\"([^\"]+)\"").Groups[1].Value.Replace("\\", "");
                            string file = Regex.Match(html, "\"file\":\"([^\"]+)\"").Groups[1].Value.Replace("\\", "");
                            file = Regex.Replace(file, "^/playlist/", "/");
                            file = Regex.Replace(file, "\\.txt$", "");

                            if (!string.IsNullOrWhiteSpace(href) && !string.IsNullOrWhiteSpace(file) && !string.IsNullOrWhiteSpace(csrftoken))
                            {
                                string origin = Regex.Match(iframe, "(https?://[^/]+)").Groups[1].Value;

                                cache.header = httpHeaders(init, HeadersModel.Init(
                                    ("accept", "*/*"),
                                    ("origin", origin),
                                    ("referer", $"{origin}/"),
                                    ("sec-fetch-dest", "empty"),
                                    ("sec-fetch-mode", "cors"),
                                    ("sec-fetch-site", "same-site"),
                                    ("x-csrf-token", csrftoken)
                                ));

                                cache.playlist = rch.enable ? await rch.Post<List<Folder>>($"https://{vid}.{href}/playlist/{file}.txt", "", cache.header) :
                                                              await Http.Post<List<Folder>>($"https://{vid}.{href}/playlist/{file}.txt", "", timeoutSeconds: 8, proxy: proxy, headers: cache.header, IgnoreDeserializeObject: true);

                                if (cache.playlist != null && cache.playlist.Count > 0)
                                {
                                    cache.href = href;
                                    hybridCache.Set(mkey_playlist, cache, cacheTime(40, init: init));
                                }
                                else
                                {
                                    if (!rch.enable)
                                        proxyManager.Refresh();

                                    if (init.rhub && init.rhub_fallback)
                                    {
                                        init.rhub = false;
                                        goto reset_playlist;
                                    }

                                    return OnError();
                                }
                            }
                        }
                    }
                    #endregion

                    #region episode
                    reset_episode:
                    string episode = cache.playlist.First(i => i.id == s).folder.First(i => i.episode == e).folder.First(i => i.title == t).file;
                    if (!string.IsNullOrEmpty(episode))
                    {
                        episode = Regex.Replace(episode, "^/playlist/", "/");
                        episode = Regex.Replace(episode, "\\.txt$", "");

                        urim3u8 = rch.enable ? await rch.Post($"https://{vid}.{cache.href}/playlist/{episode}.txt", "", cache.header) :
                                               await Http.Post($"https://{vid}.{cache.href}/playlist/{episode}.txt", "", timeoutSeconds: 8, proxy: proxy, headers: cache.header);
                    }

                    if (string.IsNullOrEmpty(urim3u8) || !urim3u8.Contains("/index.m3u8"))
                    {
                        if (!rch.enable)
                            proxyManager.Refresh();

                        if (init.rhub && init.rhub_fallback)
                        {
                            init.rhub = false;
                            goto reset_episode;
                        }

                        return OnError();
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, urim3u8, cacheTime(20, init: init));
                    #endregion
                }

                if (play)
                    return Redirect(HostStreamProxy(init, urim3u8, proxy: proxy));

                return Content("{\"method\":\"play\",\"url\":\"" + HostStreamProxy(init, urim3u8, proxy: proxy) + "\",\"title\":\"" + (title ?? original_title) + "\"}", "application/json; charset=utf-8");
            });
        }
        #endregion

        #region SpiderSearch
        [HttpGet]
        [Route("lite/hdvb-search")]
        async public ValueTask<ActionResult> SpiderSearch(string title, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.HDVB);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            reset:
            var cache = await InvokeCache<JArray>($"hdvb:search:{title}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string uri = $"{init.host}/api/videos.json?token={init.token}&title={HttpUtility.UrlEncode(title)}";
                var root = rch.enable ? await rch.Get<JArray>(uri) :
                                        await Http.Get<JArray>(uri, timeoutSeconds: 8, proxy: proxyManager.Get());

                if (root == null)
                    return res.Fail("results");

                return root;
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () =>
            {
                var hash = new HashSet<long>(cache.Value.Count);
                var stpl = new SimilarTpl(cache.Value.Count);

                foreach (var j in cache.Value)
                {
                    var kinopoisk_id = j.Value<long?>("kinopoisk_id");
                    if (kinopoisk_id > 0 && !hash.Contains((long)kinopoisk_id))
                    {
                        hash.Add((long)kinopoisk_id);
                        string uri = $"{host}/lite/hdvb?kinopoisk_id={kinopoisk_id}";
                        stpl.Append(j.Value<string>("title_ru") ?? j.Value<string>("title_en"), j.Value<int>("year").ToString(), string.Empty, uri, PosterApi.Size(j.Value<string>("poster")));
                    }
                }

                return rjson ? stpl.ToJson() : stpl.ToHtml();

            }, origsource: origsource);
        }
        #endregion


        #region search
        async ValueTask<JArray> search(RchClient rch, long kinopoisk_id)
        {
            string memKey = $"hdvb:view:{kinopoisk_id}";

            if (!hybridCache.TryGetValue(memKey, out JArray root, inmemory: false))
            {
                var init = await loadKit(AppInit.conf.HDVB);
                string uri = $"{init.host}/api/videos.json?token={init.token}&id_kp={kinopoisk_id}";

                root = rch.enable ? await rch.Get<JArray>(uri) :
                                    await Http.Get<JArray>(uri, timeoutSeconds: 8, proxy: proxyManager.Get());

                if (root == null)
                {
                    if (!rch.enable)
                        proxyManager.Refresh();
                    return null;
                }

                if (!rch.enable)
                    proxyManager.Success();

                hybridCache.Set(memKey, root, cacheTime(40, init: init), inmemory: false);
            }

            if (root.Count == 0)
                return null;

            return root;
        }
        #endregion
    }
}

```

## File: Online/Controllers/RezkaPremium.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Shared.Models.Online.Rezka;
using Shared.Models.Online.Settings;
using System.Management;
using System.Net;

namespace Online.Controllers
{
    public class RezkaPremium : BaseOnlineController
    {
        #region InitRezkaInvoke
        static string uid = null, typeuid = null;

        static void genUid()
        {
            if (uid == null)
            {
                try
                {
                    uid = System.IO.File.ReadAllText("/etc/machine-id");
                    typeuid = "machine-id";
                }
                catch
                {
                    if (AppInit.Win32NT)
                    {
                        try
                        {
                            using (var searcher = new ManagementObjectSearcher("select ProcessorId from Win32_Processor"))
                            {
                                foreach (var item in searcher.Get())
                                    uid = item["ProcessorId"].ToString();
                            }

                            typeuid = "ProcessorId";
                        }
                        catch { }
                    }
                }

                if (string.IsNullOrEmpty(uid))
                {
                    if (System.IO.File.Exists("cache/uid"))
                    {
                        uid = System.IO.File.ReadAllText("cache/uid");
                    }
                    else
                    {
                        uid = CrypTo.SHA256(DateTime.Now.ToBinary().ToString());
                        System.IO.File.WriteAllText("cache/uid", uid);
                    }

                    typeuid = "generate";
                }
            }
        }

        List<HeadersModel> apiHeaders(RezkaSettings init, string cookie)
        {
            genUid();
            return httpHeaders(init, HeadersModel.Init(
               ("X-Lampac-App", "1"),
               ("X-Lampac-Version", $"{appversion}.{minorversion}"),
               ("X-Lampac-Device-Id", $"{(AppInit.Win32NT ? "win32" : "linux")}:uid/{Regex.Replace(uid, "[^a-zA-Z0-9]+", "").Trim()}:type_uid/{typeuid}"),
               ("X-Lampac-Cookie", cookie),
               ("User-Agent", requestInfo.UserAgent)
            ));
        }

        async public ValueTask<(RezkaInvoke invk, string cookie, string log)> InitRezkaInvoke(RezkaSettings init)
        {
            init.host = new RezkaSettings(null, "kwwsv=22odps1df").host;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);
            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            genUid();

            var cook = await getCookie(init, proxy);
            if (string.IsNullOrEmpty(cook.cookie))
                return (null, null, cook.log);

            var headers = apiHeaders(init, cook.cookie);

            string country = requestInfo.Country;

            if (!rch.enable && country != null)
                headers.Add(new HeadersModel("X-Real-IP", requestInfo.IP));

            if (init.forceua)
                country = "UA";

            init.premium = true;

            return (new RezkaInvoke
            (
                host,
                init,
                (url, _) => rch.enable ? rch.Get(url, headers) : Http.Get(url, timeoutSeconds: 8, proxy: proxy, headers: headers, statusCodeOK: !url.Contains("do=search")),
                (url, data, _) => rch.enable ? rch.Post(url, data, headers) : Http.Post(url, data, timeoutSeconds: 8, proxy: proxy, headers: headers),
                streamfile => HostStreamProxy(init, RezkaInvoke.fixcdn(country, init.uacdn, streamfile), proxy: proxy),
                requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            ), cook.cookie, null);
        }
        #endregion

        #region RezkaBind
        [HttpGet]
        [AllowAnonymous]
        [Route("/lite/rhs/bind")]
        async public Task<ActionResult> RezkaBind(string login, string pass)
        {
            string html = string.Empty;

            if (string.IsNullOrWhiteSpace(login) || string.IsNullOrWhiteSpace(pass))
            {
                html = "–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç–∞ rezka.ag <br> <br><form method=\"get\" action=\"/lite/rhs/bind\"><input type=\"text\" name=\"login\" placeholder=\"email\"> &nbsp; &nbsp; <input type=\"text\" name=\"pass\" placeholder=\"–ø–∞—Ä–æ–ª—å\"><br><br><button>–ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è</button></form> ";
            }
            else
            {
                var result = await getCookie(new RezkaSettings(null, "kwwsv=22odps1df") 
                {
                    login = login,
                    passwd = pass
                }, timeoutError: 5);

                if (string.IsNullOrEmpty(result.cookie))
                {
                    html = "–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ ;(<br><br>" + result.log.Replace("\n", "<br>");
                }
                else
                {
                    html = "–î–æ–±–∞–≤—å—Ç–µ –≤ init.conf<br><br>\"RezkaPrem\": {<br>&nbsp;&nbsp;\"enable\": true,<br>&nbsp;&nbsp;\"cookie\": \"" + result.cookie + "\"<br>},<br>\"Rezka\": {<br>&nbsp;&nbsp;\"enable\": false<br>}";
                }
            }

            return Content(html, "text/html; charset=utf-8");
        }
        #endregion

        #region Initialization
        ValueTask<RezkaSettings> Initialization()
        {
            return loadKit(AppInit.conf.RezkaPrem, (j, i, c) =>
            {
                if (j.ContainsKey("uacdn"))
                    i.uacdn = c.uacdn;

                if (j.ContainsKey("forceua"))
                    i.forceua = c.forceua;

                if (j.ContainsKey("reserve"))
                    i.reserve = c.reserve;

                return i;
            });
        }
        #endregion

        [HttpGet]
        [Route("lite/rhsprem")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int clarification, int year, int s = -1, string href = null, bool rjson = false, int serial = -1, bool similar = false, string source = null, string id = null)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(href) && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() is "rezka" or "hdrezka")
                    href = id;
            }

            var proxyManager = new ProxyManager(init);

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: serial == 0 ? null : -1);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.enable)
            {
                if (!AppInit.conf.rch.enable)
                    return ShowError(RchClient.ErrorMsg);

                if (string.IsNullOrEmpty(init.cookie))
                    return ShowError($"rhub —Ä–∞–±–æ—Ç–∞–µ—Ç —á–µ—Ä–µ–∑ cookie - {host}/lite/rhs/bind");
            }

            if (string.IsNullOrWhiteSpace(href) && string.IsNullOrWhiteSpace(title))
                return OnError("href/title = null");

            var onrezka = await InitRezkaInvoke(init);
            if (onrezka.invk == null)
                return OnError("authorization error ;(", weblog: onrezka.log);

            var oninvk = onrezka.invk;

            #region search
            string search_uri = null;

            if (string.IsNullOrEmpty(href))
            {
                var search = await InvokeCache<SearchModel>($"rhsprem:search:{title}:{original_title}:{clarification}:{year}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    var content = await oninvk.Search(title, original_title, clarification, year);
                    if (content == null || (content.IsEmpty && content.content != null))
                        return res.Fail(content.content ?? "content");

                    return content;
                });

                if (search.ErrorMsg != null && search.ErrorMsg.Contains("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞"))
                    return ShowError(search.ErrorMsg);

                if (similar || string.IsNullOrEmpty(search.Value?.href))
                {
                    if (search.Value?.IsEmpty == true)
                        return ShowError(search.Value.content ?? "–ø–æ–∏—Å–∫ –Ω–µ –¥–∞–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤");

                    return OnResult(search, () =>
                    {
                        if (search.Value.similar == null)
                            return string.Empty;

                        var stpl = new SimilarTpl(search.Value.similar.Count);

                        foreach (var similar in search.Value.similar)
                        {
                            string link = $"{host}/lite/rhsprem?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&href={HttpUtility.UrlEncode(similar.href)}";

                            stpl.Append(similar.title, similar.year, string.Empty, link, PosterApi.Size(similar.img));
                        }

                        return rjson ? stpl.ToJson() : stpl.ToHtml();
                    });
                }

                href = search.Value.href;
                search_uri = search.Value.search_uri;
            }
            #endregion

            var cache = await InvokeCache<EmbedModel>($"rhsprem:{href}", cacheTime(10, init: init), rch.enable ? null : proxyManager, async res => 
            {
                return await oninvk.Embed(href, search_uri);
            });

            return OnResult(cache, () => oninvk.Html(cache.Value, accsArgs(string.Empty), title, original_title, s, href, true, rjson).Replace("/rezka", "/rhsprem"), gbcache: !rch.enable);
        }


        #region Serial
        [HttpGet]
        [Route("lite/rhsprem/serial")]
        async public ValueTask<ActionResult> Serial(string title, string original_title, string href, long id, int t, int s = -1, bool rjson = false, bool similar = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(href))
                return OnError("href = null");

            var onrezka = await InitRezkaInvoke(init);
            if (onrezka.invk == null)
                return OnError("authorization error ;(", weblog: onrezka.log);

            var oninvk = onrezka.invk;

            var proxyManager = new ProxyManager(init);

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var cache_root = await InvokeCache<Episodes>($"rhsprem:view:serial:{id}:{t}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.SerialEmbed(id, t);
            });

            var cache_content = await InvokeCache<EmbedModel>($"rhsprem:{href}", cacheTime(10, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(href, null);
            });

            return ContentTo(oninvk.Serial(cache_root.Value, cache_content.Value, accsArgs(string.Empty), title, original_title, href, id, t, s, true, rjson).Replace("/rezka", "/rhsprem"));
        }
        #endregion

        #region Movie
        [HttpGet]
        [Route("lite/rhsprem/movie")]
        [Route("lite/rhsprem/movie.m3u8")]
        async public ValueTask<ActionResult> Movie(string title, string original_title, long id, int t, int director = 0, int s = -1, int e = -1, string favs = null, bool play = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var onrezka = await InitRezkaInvoke(init);
            if (onrezka.invk == null)
                return OnError("authorization error ;(", weblog: onrezka.log);

            var oninvk = onrezka.invk;
            var proxyManager = new ProxyManager(init);

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: s == -1 ? null : -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var cache = await InvokeCache<MovieModel>($"rhsprem:view:get_cdn_series:{id}:{t}:{director}:{s}:{e}:{onrezka.cookie}", cacheTime(5, mikrotik: 1, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Movie(id, t, director, s, e, favs);
            });

            string result = oninvk.Movie(cache.Value, title, original_title, play, vast: init.vast);
            if (result == null)
                return OnError("result = null", weblog: oninvk.requestlog);

            if (play)
                return RedirectToPlay(result);

            return ContentTo(result.Replace("/rezka", "/rhsprem"));
        }
        #endregion


        #region getCookie
        static Dictionary<string, string> authCookie = new Dictionary<string, string>();

        async ValueTask<(string cookie, string log)> getCookie(RezkaSettings init, WebProxy proxy = null, int timeoutError = 15)
        {
            if (!string.IsNullOrEmpty(init.cookie))
                return ($"dle_user_taken=1; {Regex.Match(init.cookie, "(dle_user_id=[^;]+;)")} {Regex.Match(init.cookie, "(dle_password=[^;]+)")}".Trim(), null);

            if (string.IsNullOrEmpty(init.login) || string.IsNullOrEmpty(init.passwd))
                return default;

            if (authCookie.TryGetValue(init.login, out string _cook))
                return (_cook, null);

            if (memoryCache.TryGetValue($"rhsprem:login:{init.login}", out _))
                return default;

            string loglines = string.Empty;
            memoryCache.Set($"rhsprem:login:{init.login}", 0, TimeSpan.FromSeconds(timeoutError));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false,
                    AutomaticDecompression = DecompressionMethods.Brotli | DecompressionMethods.GZip | DecompressionMethods.Deflate
                })
                {

                    if (proxy != null)
                    {
                        clientHandler.UseProxy = true;
                        clientHandler.Proxy = proxy;
                    }
                    else { clientHandler.UseProxy = false; }

                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(15);

                        foreach (var item in apiHeaders(init, string.Empty))
                            client.DefaultRequestHeaders.Add(item.name, item.val);

                        var postParams = new Dictionary<string, string>
                        {
                            { "login_name", init.login },
                            { "login_password", init.passwd },
                            { "login_not_save", "0" }
                        };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            loglines += $"POST: {init.host}/ajax/login/\n";
                            loglines += $"{postContent.ReadAsStringAsync().Result}\n";

                            using (var response = await client.PostAsync($"{init.host}/ajax/login/", postContent))
                            {
                                loglines += $"\n\nStatusCode: {(int)response.StatusCode}\n";

                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string cookie = string.Empty;

                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrEmpty(line))
                                            continue;

                                        if (line.Contains("=deleted;"))
                                            continue;

                                        loglines += $"Set-Cookie: {line}\n";

                                        if (line.Contains("dle_user_id") || line.Contains("dle_password"))
                                            cookie += $"{line.Split(";")[0]}; ";
                                    }

                                    if (cookie.Contains("dle_user_id") && cookie.Contains("dle_password"))
                                    {
                                        _cook = $"dle_user_taken=1; {Regex.Replace(cookie.Trim(), ";$", "")}";
                                        authCookie.TryAdd(init.login, _cook);
                                    }

                                    loglines += $"authCookie: {authCookie}\n\n";
                                    loglines += await response.Content.ReadAsStringAsync();
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception ex) { loglines += $"\n\nHDRezka Exception: {ex}"; }

            return (_cook, loglines);
        }
        #endregion
    }
}

```

## File: Online/Controllers/VideoDB.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Shared.Models.Online.Settings;
using Shared.Models.Online.VideoDB;
using Shared.PlaywrightCore;
using System.Net;

namespace Online.Controllers
{
    public class VideoDB : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/videodb")]
        async public ValueTask<ActionResult> Index(long kinopoisk_id, string title, string original_title, string t, int s = -1, int sid = -1, bool origsource = false, bool rjson = false, int serial = -1)
        {
            var init = await loadKit(AppInit.conf.VideoDB);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (kinopoisk_id == 0)
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: serial == 0 ? null : -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            var oninvk = new VideoDBInvoke
            (
               host,
               init.apihost,
               (url, head) => rch.enable ? rch.Get(init.cors(url), httpHeaders(init)) : black_magic(url, init, proxy),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy.proxy)
            );

            reset: 
            var cache = await InvokeCache<EmbedModel>(rch.ipkey($"videodb:view:{kinopoisk_id}", proxyManager), cacheTime(20, init: init), proxyManager, async res =>
            {
                return await oninvk.Embed(kinopoisk_id);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, accsArgs(string.Empty), kinopoisk_id, title, original_title, t, s, sid, rjson), origsource: origsource);
        }


        #region Manifest
        [HttpGet]
        [Route("lite/videodb/manifest")]
        [Route("lite/videodb/manifest.m3u8")]
        async public ValueTask<ActionResult> Manifest(string link, bool serial)
        {
            var init = await loadKit(AppInit.conf.VideoDB);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(link))
                return OnError();

            bool play = HttpContext.Request.Path.Value.Contains(".m3u8");

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: serial ? -1 : null);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            string memKey = rch.ipkey($"videodb:video:{link}", proxyManager);

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out string location))
                {
                    reset:

                    try
                    {
                        var headers = httpHeaders(init, HeadersModel.Init(
                            ("sec-fetch-dest", "empty"),
                            ("sec-fetch-mode", "cors"),
                            ("sec-fetch-site", "same-site"),
                            ("origin", "{host}"),
                            ("referer", "{host}/")
                        ));

                        if (rch.enable)
                        {
                            var res = await rch.Headers(link, null, headers);
                            location = res.currentUrl;
                        }
                        else if (init.priorityBrowser == "http")
                        {
                            location = await Http.GetLocation(link, httpversion: 2, timeoutSeconds: 8, proxy: proxy.proxy, headers: headers);
                        }
                        else
                        {
                            using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                            {
                                var page = await browser.NewPageAsync(init.plugin, proxy: proxy.data);
                                if (page == null)
                                    return null;

                                browser.SetFailedUrl(link);

                                await page.RouteAsync("**/*", async route =>
                                {
                                    try
                                    {
                                        if (route.Request.Url.Contains("api/chromium/iframe"))
                                        {
                                            await route.ContinueAsync();
                                            return;
                                        }

                                        if (route.Request.Url == link)
                                        {
                                            await route.ContinueAsync(new RouteContinueOptions { Headers = headers.ToDictionary() });

                                            var response = await page.WaitForResponseAsync(route.Request.Url);
                                            if (response != null)
                                                response.Headers.TryGetValue("location", out location);

                                            browser.SetPageResult(location);
                                            PlaywrightBase.WebLog(route.Request, response, location, proxy.data);
                                            return;
                                        }

                                        await route.AbortAsync();
                                    }
                                    catch { }
                                });

                                PlaywrightBase.GotoAsync(page, PlaywrightBase.IframeUrl(link));

                                location = await browser.WaitPageResult();
                            }
                        }
                    }
                    catch { }

                    if (string.IsNullOrEmpty(location) || link == location)
                    {
                        if (init.rhub && init.rhub_fallback)
                        {
                            init.rhub = false;
                            goto reset;
                        }
                        return OnError();
                    }

                    if (!rch.enable)
                        proxyManager.Success();

                    hybridCache.Set(memKey, location, cacheTime(20, rhub: 2, init: init));
                }

                string hls = HostStreamProxy(init, location, proxy: proxy.proxy);

                if (play)
                    return RedirectToPlay(hls);

                return ContentTo(VideoTpl.ToJson("play", hls, "auto", vast: init.vast));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<string> black_magic(string uri, OnlinesSettings init, (WebProxy proxy, (string ip, string username, string password) data) baseproxy)
        {
            try
            {
                var headers = httpHeaders(init, HeadersModel.Init(
                    ("sec-fetch-dest", "iframe"),
                    ("sec-fetch-mode", "navigate"),
                    ("sec-fetch-site", "cross-site"),
                    ("referer", "{host}/")
                ));

                if (init.priorityBrowser == "http")
                    return await Http.Get(uri, httpversion: 2, timeoutSeconds: 8, proxy: baseproxy.proxy, headers: headers);

                using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                {
                    var page = await browser.NewPageAsync(init.plugin, init.headers, proxy: baseproxy.data, imitationHuman: init.imitationHuman).ConfigureAwait(false);
                    if (page == null)
                        return null;

                    browser.SetFailedUrl(uri);

                    await page.RouteAsync("**/*", async route =>
                    {
                        try
                        {
                            if (route.Request.Url.StartsWith(init.host))
                            {
                                await route.FulfillAsync(new RouteFulfillOptions
                                {
                                    Body = PlaywrightBase.IframeHtml(uri)
                                });
                            }
                            else if (route.Request.Url == uri)
                            {
                                string html = null;
                                await route.ContinueAsync();

                                var response = await page.WaitForResponseAsync(route.Request.Url);
                                if (response != null)
                                    html = await response.TextAsync();

                                browser.SetPageResult(html);
                                PlaywrightBase.WebLog(route.Request, response, html, baseproxy.data);
                                return;
                            }
                            else
                            {
                                if (!init.imitationHuman || route.Request.Url.EndsWith(".m3u8") || route.Request.Url.Contains("/cdn-cgi/challenge-platform/"))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                }
                                else
                                {
                                    if (await PlaywrightBase.AbortOrCache(page, route))
                                        return;

                                    await route.ContinueAsync();
                                }
                            }
                        }
                        catch { }
                    });

                    PlaywrightBase.GotoAsync(page, init.host);

                    return await browser.WaitPageResult().ConfigureAwait(false);
                }
            }
            catch { return null; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/FilmixTV.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.FilmixTV;
using Shared.Models.Online.Settings;
using System.Text;
using System.Threading;
using F = System.IO.File;

namespace Online.Controllers
{
    /// <summary>
    /// –ê–≤—Ç–æ—Ä https://github.com/fellicienne
    /// https://github.com/immisterio/Lampac/pull/41
    /// </summary>
    public class FilmixTV : BaseOnlineController
    {
        static readonly SemaphoreSlim _accessTokenLock = new SemaphoreSlim(1, 1);

        [HttpGet]
        [Route("lite/filmixtv")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int clarification, int year, int postid, int t = -1, int? s = null, bool origsource = false, bool rjson = false, bool similar = false, string source = null, string id = null)
        {
            if (postid == 0 && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() is "filmix" or "filmixapp")
                {
                    if (!int.TryParse(id, out postid))
                        int.TryParse(Regex.Match(id, "/([0-9]+)-").Groups[1].Value, out postid);
                }
            }

            var init = await loadKit(AppInit.conf.FilmixTV, (j, i, c) =>
            {
                if (j.ContainsKey("pro"))
                    i.pro = c.pro;

                i.user_apitv = c.user_apitv;
                i.passwd_apitv = c.passwd_apitv;
                return i;
            });

            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.user_apitv))
                return OnError("user_apitv", gbcache: false);

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            #region accessToken
            var tokenResult = await EnsureAccessToken(init, proxyManager);

            if (!tokenResult.IsSuccess)
                return ShowError(HttpUtility.HtmlEncode(tokenResult.ErrorMsg));

            init.token_apitv = tokenResult.Token;
            #endregion

            var headers = httpHeaders(init, HeadersModel.Init
            (
                ("Authorization", $"Bearer {init.token_apitv}"),
                ("hash", init.hash_apitv)
            ));

            var oninvk = new FilmixTVInvoke
            (
               host,
               init.corsHost(),
               ongettourl => Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: headers),
               (url, data) => Http.Post(init.cors(url), data, timeoutSeconds: 8, headers: headers),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
               requesterror: () => proxyManager.Refresh(),
               rjson: rjson
            );

            if (postid == 0)
            {
                var search = await InvokeCache<Shared.Models.Online.Filmix.SearchResult>($"filmixtv:search:{title}:{original_title}:{clarification}:{similar}", cacheTime(40, init: init), proxyManager, async res =>
                {
                    return await oninvk.Search(title, original_title, clarification, year, similar);
                });

                if (!search.IsSuccess)
                    return OnError(search.ErrorMsg);

                if (search.Value.id == 0)
                    return ContentTo(rjson ? search.Value.similars.Value.ToJson() : search.Value.similars.Value.ToHtml());

                postid = search.Value.id;
            }

            var cache = await InvokeCache<RootObject>($"filmixtv:post:{postid}:{init.token_apitv}", cacheTime(20, init: init), proxyManager, onget: async res =>
            {
                string json = await Http.Get($"{init.corsHost()}/api-fx/post/{postid}/video-links", timeoutSeconds: 8, headers: headers);

                return oninvk.Post(json);
            });

            return OnResult(cache, () => oninvk.Html(cache.Value, init.pro, postid, title, original_title, t, s, vast: init.vast), origsource: origsource);
        }


        #region [Copilot AI] EnsureAccessToken
        async ValueTask<(bool IsSuccess, string Token, string ErrorMsg)> EnsureAccessToken(FilmixSettings init, ProxyManager proxyManager)
        {
            try
            {
                await _accessTokenLock.WaitAsync(TimeSpan.FromMinutes(1));

                string hashFile = $"cache/filmixtv-{CrypTo.md5(init.user_apitv)}.hash";

                if (F.Exists(hashFile))
                {
                    init.hash_apitv = F.ReadAllText(hashFile);
                }
                else
                {
                    var rtk = await Http.Get<JObject>($"{init.corsHost()}/api-fx/request-token", timeoutSeconds: 30);
                    if (rtk == null || !rtk.ContainsKey("token"))
                        return (false, null, "rtk");

                    string hash = rtk.Value<string>("token");
                    if (string.IsNullOrEmpty(hash))
                        return (false, null, "hash");

                    init.hash_apitv = hash;
                }

                var auth = await InvokeCache<string>($"filmixtv:accessToken:{init.user_apitv}:{init.passwd_apitv}:{init.hash_apitv}", TimeSpan.FromHours(5), proxyManager, async res =>
                {
                    JObject root_auth = null;

                    string authFile = $"cache/filmixtv-{CrypTo.md5(init.hash_apitv)}.auth";

                    if (F.Exists(authFile))
                    {
                        string refreshToken = Regex.Match(F.ReadAllText(authFile), "\"refreshToken\": ?\"([^\"]+)\"").Groups[1].Value;
                        root_auth = await Http.Get<JObject>($"{init.corsHost()}/api-fx/refresh?refreshToken={HttpUtility.UrlEncode(refreshToken)}", headers: HeadersModel.Init("hash", init.hash_apitv), timeoutSeconds: 30);
                    }
                    else
                    {
                        var data = new System.Net.Http.StringContent($"{{\"user_name\":\"{init.user_apitv}\",\"user_passw\":\"{init.passwd_apitv}\",\"session\":true}}", Encoding.UTF8, "application/json");
                        root_auth = await Http.Post<JObject>($"{init.corsHost()}/api-fx/auth", data, headers: HeadersModel.Init("hash", init.hash_apitv), timeoutSeconds: 30);
                    }

                    string accessToken = root_auth?.GetValue("accessToken")?.ToString();
                    if (string.IsNullOrEmpty(accessToken))
                    {
                        if (root_auth != null)
                        {
                            if (root_auth.ContainsKey("msg"))
                                return res.Fail(root_auth.Value<string>("msg"));

                            return res.Fail(root_auth.ToString());
                        }

                        return res.Fail("accessToken");
                    }

                    F.WriteAllText(hashFile, init.hash_apitv);
                    F.WriteAllText(authFile, root_auth.ToString());
                    return accessToken;
                });

                if (!auth.IsSuccess)
                    return (false, null, auth.ErrorMsg);

                return (true, auth.Value, null);
            }
            catch (Exception ex) { return (false, null, ex.Message); }
            finally
            {
                _accessTokenLock.Release();
            }
        }
        #endregion
    }
}

```

## File: Online/Controllers/IptvOnline.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;
using System.Net;
using System.Text;

namespace Online.Controllers
{
    public class IptvOnline : BaseOnlineController
    {
        #region Bind
        [HttpGet]
        [AllowAnonymous]
        [Route("lite/iptvonline/bind")]
        public ActionResult Bind(string KEY, string ID)
        {
            string html = string.Empty;

            if (string.IsNullOrWhiteSpace(KEY) || string.IsNullOrWhiteSpace(ID))
            {
                html = "–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ <a href='https://iptv.online/ru/dealers/api' target=_blank>https://iptv.online/ru/dealers/api</a> <br> <br><form method=\"get\" action=\"/lite/iptvonline/bind\"><input type=\"text\" name=\"KEY\" placeholder=\"X-API-KEY\"> &nbsp; &nbsp; <input type=\"text\" name=\"ID\" placeholder=\"X-API-ID\"><br><br><button>–ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è</button></form> ";
            }
            else
            {
                html = "–î–æ–±–∞–≤—å—Ç–µ –≤ init.conf<br><br>\"IptvOnline\": {<br>&nbsp;&nbsp;\"enable\": true,<br>&nbsp;&nbsp;\"token\": \"" + $"{ID}:{KEY}" + "\"<br>}";
            }

            return Content(html, "text/html; charset=utf-8");
        }
        #endregion

        [HttpGet]
        [Route("lite/iptvonline")]
        async public ValueTask<ActionResult> Index(string imdb_id, long kinopoisk_id, string title, string original_title, int serial = -1, int s = -1, bool rjson = false, bool origsource = false)
        {
            var init = await loadKit(AppInit.conf.IptvOnline);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            #region AUTH
            if (!hybridCache.TryGetValue($"iptvonline:auth:{init.token}", out string codeauth))
            {
                var auth = await Http.Post<JObject>($"{init.host}/v1/api/auth", "", timeoutSeconds: 8, proxy: proxy, useDefaultHeaders: false, headers: HeadersModel.Init(
                    ("X-API-KEY", init.token.Split(":")[1]),
                    ("X-API-ID", init.token.Split(":")[0])
                ));

                if (auth == null)
                {
                    proxyManager.Refresh();
                    return null;
                }

                string code = auth.Value<string>("code");
                if (string.IsNullOrEmpty(code))
                    return null;

                codeauth = code;
                hybridCache.Set($"iptvonline:auth:{init.token}", codeauth, DateTime.Now.AddHours(2));
            }
            #endregion

            var data = await search(init, proxyManager, proxy, codeauth, serial, imdb_id, kinopoisk_id, title, original_title);
            if (data == null)
                return OnError();

            if (data.Value<string>("message") != null)
                return ShowError(data.Value<string>("message"));

            #region media
            string id = data.Value<string>("id");
            var cache = await InvokeCache<JToken>($"IptvOnline:{id}:{init.token}", cacheTime(20, init: init), proxyManager, async res =>
            {
                var header = httpHeaders(init, HeadersModel.Init(
                    ("X-API-AUTH", codeauth),
                    ("X-API-ID", init.token.Split(":")[0])
                ));

                string uri = $"{init.host}/v1/api/media/{(serial == 1 ? "serials" : "movies")}/{id}/";
                var root = await Http.Get<JObject>(init.cors(uri), timeoutSeconds: 8, proxy: proxy, headers: header, useDefaultHeaders: false);

                if (root == null || !root.ContainsKey("data"))
                    return res.Fail("data");

                return root["data"];
            });
            #endregion

            return OnResult(cache, () =>
            {
                if (cache.Value.Value<string>("category") == "movie")
                {
                    #region –§–∏–ª—å–º
                    var mtpl = new MovieTpl(title, original_title, 1);

                    string stream = HostStreamProxy(init, cache.Value["medias"].First.Value<string>("url") + "#.m3u8", proxy: proxy);
                    string quality = cache.Value.Value<int?>("quality")?.ToString();
                    if (quality != null)
                        quality += "p";

                    mtpl.Append(quality ?? title, stream, vast: init.vast);

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∞–ª
                    if (s == -1)
                    {
                        string enc_title = HttpUtility.UrlEncode(title);
                        string enc_original_title = HttpUtility.UrlEncode(original_title);

                        string quality = cache.Value.Value<string>("quality");
                        if (quality != null)
                            quality += "p";

                        var tpl = new SeasonTpl(quality);

                        foreach (var media in cache.Value["medias"])
                        {
                            int season = media.Value<int>("season");
                            string link = $"{host}/lite/iptvonline?rjson={rjson}&serial={serial}&kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&title={enc_title}&original_title={enc_original_title}&s={season}";
                            tpl.Append($"{season} —Å–µ–∑–æ–Ω", link, season);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        var etpl = new EpisodeTpl();
                        string sArhc = s.ToString();

                        foreach (var episode in cache.Value["medias"].First(i => i.Value<int>("season") == s).Value<JArray>("episodes"))
                        {
                            string name = episode.Value<string>("title");
                            string file = episode.Value<string>("url") + "#.m3u8";

                            if (string.IsNullOrEmpty(file))
                                continue;

                            string stream = HostStreamProxy(init, file, proxy: proxy);
                            etpl.Append(name ?? $"{episode.Value<int>("episode")} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.Value<int>("episode").ToString(), stream, vast: init.vast);
                        }

                        return rjson ? etpl.ToJson() : etpl.ToHtml();
                    }
                    #endregion
                }

            }, origsource: origsource);
        }


        #region search
        async ValueTask<JToken> search(OnlinesSettings init, ProxyManager proxyManager, WebProxy proxy, string codeauth, int serial, string imdb_id, long kinopoisk_id, string title, string original_title)
        {
            string memKey = $"iptvonline:view:{kinopoisk_id}:{imdb_id}:{title}:{original_title}";

            if (!hybridCache.TryGetValue(memKey, out JToken data))
            {
                string stitle = StringConvert.SearchName(title);
                string sorigtitle = StringConvert.SearchName(original_title);

                async Task<JToken> goSearch(string search)
                {
                    if (string.IsNullOrEmpty(search))
                        return null;

                    var header = httpHeaders(init, HeadersModel.Init(
                        ("X-API-AUTH", codeauth),
                        ("X-API-ID", init.token.Split(":")[0])
                    ));

                    string uri = $"{init.host}/v1/api/media/{(serial == 1 ? "serials" : "movies")}";
                    var data = new System.Net.Http.StringContent(JsonConvert.SerializeObject(new { search }), Encoding.UTF8, "application/json");

                    var video = await Http.Get<JObject>(uri, body: data, timeoutSeconds: 8, proxy: proxy, headers: header, useDefaultHeaders: false);

                    if (video == null)
                    {
                        proxyManager.Refresh();
                        return null;
                    }

                    if (video.ContainsKey("message") && video.Value<string>("message") == "No Subscribed By Media API")
                        return video;

                    if (!video.ContainsKey("data"))
                        return null;

                    foreach (var item in video["data"])
                    {
                        if (kinopoisk_id > 0)
                        {
                            if (item.Value<long?>("kinopoisk") == kinopoisk_id) 
                                return item;   
                        }

                        if (!string.IsNullOrEmpty(imdb_id))
                        {
                            if ($"tt{item.Value<long?>("imdb")}" == imdb_id)
                                return item;
                        }
                    }

                    foreach (var item in video["data"])
                    {
                        if (sorigtitle != null)
                        {
                            if (StringConvert.SearchName(item.Value<string>("orig_title")) == sorigtitle)
                                return item;
                        }

                        if (stitle != null)
                        {
                            if (StringConvert.SearchName(item.Value<string>("ru_title")) == stitle)
                                return item;
                        }
                    }

                    return null;
                }

                data = await goSearch(original_title) ?? await goSearch(title);
                if (data == null)
                    return null;

                proxyManager.Success();
                hybridCache.Set(memKey, data, cacheTime(30, init: init));
            }

            return data;
        }
        #endregion
    }
}

```

## File: Online/Controllers/IframeVideo.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;

namespace Online.Controllers
{
    public class IframeVideo : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.IframeVideo);

        [HttpGet]
        [Route("lite/iframevideo")]
        async public Task<ActionResult> Index(string imdb_id, long kinopoisk_id, string title, string original_title)
        {
            var init = await loadKit(AppInit.conf.IframeVideo);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var frame = await iframe(imdb_id, kinopoisk_id);
            if (frame.type == null || (frame.type != "movie" && frame.type != "anime"))
                return OnError();

            bool firstjson = true;
            string html = "<div class=\"videos__line\">";

            var match = new Regex("<a href='/[^/]+/([^/]+)/iframe[^']+' [^>]+><span title='[^']+'>([^<]+)</span>").Match(frame.content);
            while (match.Success)
            {
                if (!string.IsNullOrWhiteSpace(match.Groups[1].Value))
                {
                    string link = $"{host}/lite/iframevideo/video?title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&type={frame.type}&cid={frame.cid}&token={match.Groups[1].Value}";
                    string streamlink = $"{link.Replace("/video", "/video.m3u8")}&play=true";

                    html += "<div class=\"videos__item videos__movie selector " + (firstjson ? "focused" : "") + "\" media=\"\" data-json='{\"method\":\"call\",\"url\":\"" + link + "\",\"stream\":\"" + streamlink + "\"}'><div class=\"videos__item-imgbox videos__movie-imgbox\"></div><div class=\"videos__item-title\">" + match.Groups[2].Value + "</div></div>";
                    firstjson = false;
                }
                match = match.NextMatch();
            }

            if (firstjson)
            {
                string _v = Regex.Match(html, "<span class='muted'><span [^>]+>([^<]+)</span>").Groups[1].Value;
                if (string.IsNullOrWhiteSpace(_v))
                    _v = Regex.Match(html, "<span class='muted'>([^<\n\r]+)").Groups[1].Value;

                string token = Regex.Match(frame.path, "/[^/]+/([^/]+)/iframe").Groups[1].Value;
                if (string.IsNullOrWhiteSpace(token))
                    return Content(string.Empty);

                string voice = string.IsNullOrWhiteSpace(_v) ? "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é" : _v;
                string link = $"{host}/lite/iframevideo/video?title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&type={frame.type}&cid={frame.cid}&token={token}";
                string streamlink = $"{link.Replace("/video", "/video.m3u8")}&play=true";

                html += "<div class=\"videos__item videos__movie selector focused\" media=\"\" data-json='{\"method\":\"call\",\"url\":\"" + link + "\",\"stream\":\"" + streamlink + "\"}'><div class=\"videos__item-imgbox videos__movie-imgbox\"></div><div class=\"videos__item-title\">" + voice + "</div></div>";
            }

            return Content(html + "</div>", "text/html; charset=utf-8");
        }


        #region Video
        [HttpGet]
        [Route("lite/iframevideo/video")]
        [Route("lite/iframevideo/video.m3u8")]
        async public Task<ActionResult> Video(string type, int cid, string token, string title, string original_title, bool play)
        {
            var init = await loadKit(AppInit.conf.IframeVideo);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var proxy = proxyManager.Get();

            string memKey = $"iframevideo:view:video:{type}:{cid}:{token}";
            if (!hybridCache.TryGetValue(memKey, out string urim3u8))
            {
                string json = await Http.Post($"{init.cdnhost}/loadvideo", $"token={token}&type={type}&season=&episode=&mobile=false&id={cid}&qt=480", timeoutSeconds: 10, proxy: proxy, headers: httpHeaders(init, HeadersModel.Init(
                    ("DNT", "1"),
                    ("Origin", init.cdnhost),
                    ("P-REF", string.Empty),
                    ("Referer", $"{init.cdnhost}/"),
                    ("Sec-Fetch-Dest", "empty"),
                    ("Sec-Fetch-Mode", "cors"),
                    ("Sec-Fetch-Site", "same-origin"),
                    ("X-REF", $"{init.host}/"),
                    ("sec-ch-ua", "\"Google Chrome\";v=\"113\", \"Chromium\";v=\"113\", \"Not-A.Brand\";v=\"24\""),
                    ("sec-ch-ua-mobile", "?0"),
                    ("sec-ch-ua-platform", "\"Windows\"")
                )));

                urim3u8 = Regex.Match(json ?? "", "{\"src\":\"([^\"]+)\"").Groups[1].Value.Replace("\\", "");
                if (string.IsNullOrWhiteSpace(urim3u8))
                    return OnError(proxyManager);

                hybridCache.Set(memKey, urim3u8, cacheTime(20, init: init));
            }

            string url = HostStreamProxy(init, urim3u8, proxy: proxy);
            if (play)
                return RedirectToPlay(url);

            return Content("{\"method\":\"play\",\"url\":\"" + url + "\",\"title\":\"" + (title ?? original_title) + "\"}", "application/json; charset=utf-8");
        }
        #endregion

        #region iframe
        async ValueTask<(string content, string type, int cid, string path)> iframe(string imdb_id, long kinopoisk_id)
        {
            var init = AppInit.conf.IframeVideo;

            if (kinopoisk_id == 0 && string.IsNullOrWhiteSpace(imdb_id))
                return (null, null, 0, null);

            string memKey = $"iframevideo:view:{imdb_id}:{kinopoisk_id}";

            if (!hybridCache.TryGetValue(memKey, out (string content, string type, int cid, string path) res))
            {
                string uri = $"{init.apihost}/api/v2/search?imdb={imdb_id}&kp={kinopoisk_id}";
                if (!string.IsNullOrWhiteSpace(init.token))
                    uri = $"{init.apihost}/api/v2/movies?kp={kinopoisk_id}&imdb={imdb_id}&api_token={init.token}";

                var proxy = proxyManager.Get();
                var root = await Http.Get<JObject>(uri, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));
                if (root == null)
                    return (null, null, 0, null);

                var item = root.Value<JArray>("results")?[0];
                if (item == null)
                    return (null, null, 0, null);

                res.cid = item.Value<int>("cid");
                res.path = item.Value<string>("path");
                res.type = item.Value<string>("type");

                res.content = await Http.Get(res.path, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init, HeadersModel.Init(
                    ("DNT", "1"),
                    ("Referer", $"{init.host}/"),
                    ("Sec-Fetch-Dest", "iframe"),
                    ("Sec-Fetch-Mode", "navigate"),
                    ("Sec-Fetch-Site", "cross-site"),
                    ("Upgrade-Insecure-Requests", "1"),
                    ("sec-ch-ua", "\"Google Chrome\";v=\"113\", \"Chromium\";v=\"113\", \"Not-A.Brand\";v=\"24\""),
                    ("sec-ch-ua-mobile", "?0"),
                    ("sec-ch-ua-platform", "\"Windows\"")
                )));

                if (res.content == null)
                {
                    proxyManager.Refresh();
                    return (null, null, 0, null);
                }

                hybridCache.Set(memKey, res, cacheTime(20, init: init));
            }

            return res;
        }
        #endregion
    }
}

```

## File: Online/Controllers/Lumex.cs
```
Ôªøusing DnsClient;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Routing;
using Microsoft.Playwright;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Lumex;
using Shared.PlaywrightCore;
using System.Threading;

namespace Online.Controllers
{
    public class Lumex : BaseOnlineController
    {
        //static Lumex()
        //{
        //    FixHostEvent();
        //}

        //static Dictionary<string, string> ips = null;

        //public static void FixHostEvent()
        //{
        //    if (ips != null) 
        //        return;

        //    ips = new Dictionary<string, string>();

        //    EventListener.ProxyApiCreateHttpRequest += async httpRequestModel =>
        //    {
        //        if (!httpRequestModel.uri.Host.Contains("mediaaly.pro"))
        //            return;

        //        string targetHost = httpRequestModel.uri.Host.Replace("mediaaly.pro", "saicdn.com");

        //        if (!ips.TryGetValue(targetHost, out string dns_ip))
        //        {
        //            using (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10)))
        //            {
        //                var lookup = new LookupClient();
        //                var queryType = await lookup.QueryAsync(targetHost, QueryType.A, cancellationToken: cts.Token);

        //                dns_ip = queryType?.Answers?.ARecords()?.FirstOrDefault()?.Address?.ToString();

        //                if (string.IsNullOrEmpty(dns_ip))
        //                    return;

        //                ips.TryAdd(targetHost, dns_ip);
        //            }
        //        }

        //        var newUri = new Uri(httpRequestModel.requestMessage.RequestUri.AbsoluteUri.Replace(httpRequestModel.uri.Host, dns_ip));
        //        httpRequestModel.requestMessage.RequestUri = newUri;
        //    };
        //}


        #region database
        static List<DatumDB> databaseCache;

        public static IEnumerable<DatumDB> database
        {
            get
            {
                if (AppInit.conf.multiaccess || databaseCache != null)
                    return databaseCache ??= JsonHelper.ListReader<DatumDB>("data/lumex.json", 105000);

                return JsonHelper.IEnumerableReader<DatumDB>("data/lumex.json");
            }
        }
        #endregion

        [HttpGet]
        [Route("lite/lumex")]
        async public ValueTask<ActionResult> Index(long content_id, string content_type, string imdb_id, long kinopoisk_id, string title, string original_title, string t, int clarification, int s = -1, int serial = -1, bool origsource = false, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.Lumex);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (init.priorityBrowser == "firefox")
            {
                if (Firefox.Status == PlaywrightStatus.disabled)
                    return OnError("Firefox disabled");
            }
            else if (init.priorityBrowser != "http")
            {
                if (Chromium.Status == PlaywrightStatus.disabled)
                    return OnError("Chromium disabled");
            }

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var oninvk = new LumexInvoke
            (
               init,
               (url, referer) => Http.Get(init.cors(url), referer: referer, timeoutSeconds: 8, proxy: proxy.proxy, headers: httpHeaders(init)),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy.proxy),
               host,
               requesterror: () => proxyManager.Refresh()
            );

            if (similar || (content_id == 0 && kinopoisk_id == 0 && string.IsNullOrEmpty(imdb_id)))
            {
                string memKey = $"lumex:search:{title}:{original_title}:{clarification}";

                return await InvkSemaphore(init, memKey, async () =>
                {
                    if (!hybridCache.TryGetValue(memKey, out SimilarTpl search))
                    {
                        search = await oninvk.Search(title, original_title, serial, clarification, database);
                        if (search.data?.Count == 0)
                            return OnError("search");

                        hybridCache.Set(memKey, search, cacheTime(40, init: init));
                    }

                    return ContentTo(rjson ? search.ToJson() : search.ToHtml());
                });
            }

            var cache = await InvokeCache<EmbedModel>($"videocdn:{content_id}:{content_type}:{kinopoisk_id}:{imdb_id}:{proxyManager.CurrentProxyIp}", cacheTime(10, init: init), proxyManager,  async res =>
            {
                string content_uri = null;
                var content_headers = new List<HeadersModel>();

                #region uri
                string targetUrl = $"https://p.{init.iframehost}/{init.clientId}";
                if (content_id > 0)
                {
                    targetUrl += $"/{content_type}/{content_id}";
                }
                else
                {
                    if (kinopoisk_id > 0)
                        targetUrl += $"?kp_id={kinopoisk_id}";
                    if (!string.IsNullOrEmpty(imdb_id))
                        targetUrl += (targetUrl.Contains("?") ? "&" : "?") + $"imdb_id={imdb_id}";
                }
                #endregion

                if (init.priorityBrowser == "http" && kinopoisk_id > 0)
                {
                    content_uri = $"https://api.{init.iframehost}/content?clientId={init.clientId}&contentType=short&kpId={kinopoisk_id}";
                    content_headers = HeadersModel.Init(Chromium.baseContextOptions.ExtraHTTPHeaders);
                    content_headers.Add(new HeadersModel("accept", "*/*"));
                    content_headers.Add(new HeadersModel("origin", $"https://p.{init.iframehost}"));
                    content_headers.Add(new HeadersModel("referer", $"https://p.{init.iframehost}/"));
                    content_headers.Add(new HeadersModel("sec-fetch-site", "same-site "));
                    content_headers.Add(new HeadersModel("sec-fetch-mode", "cors"));
                    content_headers.Add(new HeadersModel("sec-fetch-dest", "empty"));
                }
                else if (init.priorityBrowser == "scraping")
                {
                    #region Scraping
                    using (var browser = new Scraping(targetUrl, "/content\\?contentId=", null))
                    {
                        browser.OnRequest += e =>
                        {
                            if (Regex.IsMatch(e.HttpClient.Request.Url, "\\.(css|woff2|jpe?g|png|ico)") ||
                               !Regex.IsMatch(e.HttpClient.Request.Url, "(lumex|cloudflare|sentry|gstatic)\\."))
                            {
                                e.Ok(string.Empty);
                            }
                        };

                        var scrap = await browser.WaitPageResult(15);

                        if (scrap != null)
                        {
                            content_uri = scrap.Url;
                            foreach (var item in scrap.Headers)
                            {
                                if (item.Name.ToLower() is "host" or "accept-encoding" or "connection" or "range" or "cookie")
                                    continue;

                                content_headers.Add(new HeadersModel(item.Name, item.Value));
                            }
                        }
                    }
                    #endregion
                }
                else
                {
                    #region Playwright
                    try
                    {
                        using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                        {
                            var page = await browser.NewPageAsync(init.plugin, proxy: proxy.data).ConfigureAwait(false);
                            if (page == null)
                                return null;

                            await page.Context.ClearCookiesAsync(new BrowserContextClearCookiesOptions { Domain = $"api.{init.iframehost}", Name = "x-csrf-token" });

                            await page.RouteAsync("**/*", async route =>
                            {
                                try
                                {
                                    if (content_uri != null || browser.IsCompleted)
                                    {
                                        PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (route.Request.Url.Contains("/content?clientId="))
                                    {
                                        content_uri = route.Request.Url.Replace("%3D", "=").Replace("%3F", "&");
                                        foreach (var item in route.Request.Headers)
                                        {
                                            if (item.Key is "host" or "accept-encoding" or "connection" or "range" or "cookie")
                                                continue;

                                            content_headers.Add(new HeadersModel(item.Key, item.Value));
                                        }

                                        foreach (var h in new List<(string key, string val)>
                                        {
                                            ("sec-fetch-site", "same-site"),
                                            ("sec-fetch-mode", "cors"),
                                            ("sec-fetch-dest", "empty"),
                                        })
                                        {
                                            if (!route.Request.Headers.ContainsKey(h.key))
                                                content_headers.Add(new HeadersModel(h.key, h.val));
                                        }

                                        browser.SetPageResult(string.Empty);
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                        return;

                                    await route.ContinueAsync();
                                }
                                catch { }
                            });

                            PlaywrightBase.GotoAsync(page, targetUrl);
                            await browser.WaitPageResult().ConfigureAwait(false);
                        }
                    }
                    catch { }
                    #endregion
                }

                if (content_uri == null)
                    return res.Fail("content_uri");

                var result = await Http.BaseGetAsync(content_uri, proxy: proxy.proxy, headers: content_headers);

                if (string.IsNullOrEmpty(result.content))
                {
                    proxyManager.Refresh();
                    return res.Fail("content");
                }

                if (!result.response.Headers.TryGetValues("Set-Cookie", out var cook))
                {
                    proxyManager.Refresh();
                    return res.Fail("cook");
                }

                string csrf = Regex.Match(cook.FirstOrDefault() ?? "", "x-csrf-token=([^\n\r; ]+)").Groups[1].Value.Trim();
                if (string.IsNullOrEmpty(csrf))
                {
                    proxyManager.Refresh();
                    return res.Fail("csrf");
                }

                content_headers.Add(new HeadersModel("x-csrf-token", csrf.Split("%")[0]));
                content_headers.Add(new HeadersModel("cookie", $"x-csrf-token={csrf}"));

                var md = JsonConvert.DeserializeObject<JObject>(result.content)["player"].ToObject<EmbedModel>();
                md.csrf = CrypTo.md5(DateTime.Now.ToFileTime().ToString());

                hybridCache.Set(md.csrf, content_headers, DateTime.Now.AddDays(1));

                return md;
            });

            return OnResult(cache, () => oninvk.Html(cache.Value, accsArgs(string.Empty), content_id, content_type, imdb_id, kinopoisk_id, title, original_title, clarification, t, s, rjson: rjson), origsource: origsource);
        }


        #region Video
        [HttpGet]
        [Route("lite/lumex/video")]
        [Route("lite/lumex/video.m3u8")]
        async public ValueTask<ActionResult> Video(string playlist, string csrf, int max_quality)
        {
            var init = await loadKit(AppInit.conf.Lumex);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrEmpty(playlist) || string.IsNullOrEmpty(csrf))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            string memkey = $"lumex/video:{playlist}:{csrf}";

            return await InvkSemaphore(init, memkey, async () =>
            {
                if (!hybridCache.TryGetValue(memkey, out string hls))
                {
                    if (!hybridCache.TryGetValue(csrf, out List<HeadersModel> content_headers))
                        return OnError();

                    var result = await Http.Post<JObject>($"https://api.{init.iframehost}" + playlist, "", httpversion: 2, proxy: proxy, timeoutSeconds: 8, headers: content_headers);

                    if (result == null || !result.ContainsKey("url"))
                        return OnError();

                    string url = result.Value<string>("url");
                    if (string.IsNullOrEmpty(url))
                        return OnError();

                    if (url.StartsWith("/"))
                        hls = $"{init.scheme}:{url}";
                    else
                        hls = url;

                    hybridCache.Set(memkey, hls, cacheTime(20, init: init));
                }

                string sproxy(string uri) => HostStreamProxy(init, uri, proxy: proxy);

                if (max_quality > 0 && !init.hls)
                {
                    var streamquality = new StreamQualityTpl();

                    foreach (int q in new int[] { 1080, 720, 480, 360, 240 })
                    {
                        if (max_quality >= q)
                            streamquality.Append(sproxy(Regex.Replace(hls, "/hls\\.m3u8$", $"/{q}.mp4")), $"{q}p");
                    }

                    if (!streamquality.Any())
                        return OnError("streams");

                    var first = streamquality.Firts();
                    return ContentTo(VideoTpl.ToJson("play", first.link, first.quality, streamquality: streamquality, vast: init.vast));
                }

                return Redirect(sproxy(hls));
            });
        }
        #endregion
    }
}

```

## File: Online/Controllers/VkMovie.cs
```
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.VkMovie;

namespace Online.Controllers
{
    public class VkMovie : BaseOnlineController
    {
        static readonly int client_id = 52461373;
        static string access_token;
        static DateTime token_expires;

        [HttpGet]
        [Route("lite/vkmovie")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int year, int serial, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.VkMovie);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (serial == 1)
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            if (!await EnsureAnonymToken(init, proxy))
                return ShowError("token");

            string searchTitle = StringConvert.SearchName(title);

            reset:
            var cache = await InvokeCache<CatalogVideo[]>(rch.ipkey($"vkmovie:view:{searchTitle}:{year}", proxyManager), cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string url = $"{init.host}/method/catalog.getVideoSearchWeb2?v=5.264&client_id={client_id}";
                string data = $"screen_ref=search_video_service&input_method=keyboard_search_button&q={HttpUtility.UrlEncode($"{title} {year}")}&access_token={access_token}";

                var root = rch.enable
                    ? await rch.Post<JObject>(url, data, httpHeaders(init))
                    : await Http.Post<JObject>(url, data, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));

                if (root == null || !root.ContainsKey("response"))
                    return res.Fail("response");

                var videos = root["response"]?["catalog_videos"]?.ToObject<CatalogVideo[]>();
                if (videos == null)
                    return res.Fail("catalog_videos");

                return videos;
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () =>
            {
                var mtpl = new MovieTpl(title, original_title, cache.Value.Length);

                foreach (var item in cache.Value
                    .OrderByDescending(i => i.video?.files?.mp4_2160 != null)
                    .ThenByDescending(i => i.video?.files?.mp4_1440 != null)
                    .ThenByDescending(i => i.video?.files?.mp4_1080 != null))
                {
                    var video = item.video;
                    if (video == null || video.files == null)
                        continue;

                    string name = StringConvert.SearchName(video.title);
                    if (name == null || !name.Contains(searchTitle))
                        continue;

                    if (!(name.Contains(year.ToString()) || name.Contains((year + 1).ToString()) || name.Contains((year - 1).ToString())))
                        continue;

                    if (video.duration < 3000) // 50 min
                        continue;

                    if (name.Contains("—Ç—Ä–µ–π–ª–µ—Ä") || name.Contains("trailer") || 
                        name.Contains("–ø—Ä–µ–º—å–µ—Ä–∞") || name.Contains("–æ–±–∑–æ—Ä") ||
                        name.Contains("—Å–µ–∑–æ–Ω") || name.Contains("—Å–µ—Ä–∏–∞–ª") ||
                        name.Contains("—Å–µ—Ä–∏—è") || name.Contains("—Å–µ—Ä–∏–π"))
                        continue;

                    if (string.IsNullOrEmpty(video.files.mp4_2160) 
                        && string.IsNullOrEmpty(video.files.mp4_1440) 
                        && string.IsNullOrEmpty(video.files.mp4_1080) 
                        && string.IsNullOrEmpty(video.files.mp4_720))
                        continue;

                    var streams = new StreamQualityTpl();

                    void append(string url, string quality)
                    {
                        if (!string.IsNullOrEmpty(url))
                            streams.Append(HostStreamProxy(init, url, proxy: proxy), quality);
                    }

                    //append(video.files.hls, "auto");
                    append(video.files.mp4_2160, "2160p");
                    append(video.files.mp4_1440, "1440p");
                    append(video.files.mp4_1080, "1080p");
                    append(video.files.mp4_720, "720p");
                    append(video.files.mp4_480, "480p");
                    append(video.files.mp4_360, "360p");
                    append(video.files.mp4_240, "240p");
                    append(video.files.mp4_144, "144p");

                    if (!streams.Any())
                        continue;

                    SubtitleTpl? subtitles = null;

                    if (video.subtitles != null && video.subtitles.Length > 0)
                    {
                        var subtitleTpl = new SubtitleTpl(video.subtitles.Length);

                        foreach (var subtitle in video.subtitles)
                        {
                            if (string.IsNullOrEmpty(subtitle?.url))
                                continue;

                            string label = subtitle.manifest_name;
                            if (string.IsNullOrEmpty(label))
                                label = !string.IsNullOrEmpty(subtitle.title) ? subtitle.title : subtitle.lang;

                            subtitleTpl.Append(label, HostStreamProxy(init, subtitle.url, proxy: proxy));
                        }

                        if (!subtitleTpl.IsEmpty())
                            subtitles = subtitleTpl;
                    }

                    mtpl.Append(video.title, streams.Firts().link, streamquality: streams, subtitles: subtitles, headers: HeadersModel.Init(init.headers), vast: init.vast);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();

            }, gbcache: !rch.enable);
        }


        async ValueTask<bool> EnsureAnonymToken(BaseSettings init, System.Net.WebProxy proxy)
        {
            // If token exists and not expired - ok
            if (!string.IsNullOrEmpty(access_token) && token_expires > DateTime.UtcNow)
                return true;

            var sem = _semaphoreLocks.GetOrAdd("vkmovie:anonym_token", _ => new System.Threading.SemaphoreSlim(1, 1));

            try
            {
                await sem.WaitAsync(TimeSpan.FromSeconds(40));

                // double-check after acquiring semaphore
                if (!string.IsNullOrEmpty(access_token) && token_expires > DateTime.UtcNow)
                    return true;

                string url = "https://login.vk.com/?act=get_anonym_token";
                string postData = $"client_secret=o557NLIkAErNhakXrQ7A&client_id={client_id}&scopes=audio_anonymous%2Cvideo_anonymous%2Cphotos_anonymous%2Cprofile_anonymous&isApiOauthAnonymEnabled=false&version=1&app_id=6287487";

                JObject root = null;

                try
                {
                    root = await Http.Post<JObject>(url, postData, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));
                }
                catch
                {
                    // ignore
                }

                if (root == null || !root.ContainsKey("data"))
                    return false;

                var data = root["data"];

                string token = data?["access_token"]?.ToString();
                if (string.IsNullOrEmpty(token))
                    return false;

                access_token = token;

                long? expires = data?["expires"]?.ToObject<long?>()
                    ?? data?["expired_at"]?.ToObject<long?>()
                    ?? -1;

                // "expires":1760171110 (24—á) | 20—á
                token_expires = expires == -1 
                    ? DateTime.UtcNow.AddHours(10) 
                    : DateTimeOffset.FromUnixTimeSeconds(expires.Value).UtcDateTime.AddHours(-4);

                return true;
            }
            finally
            {
                sem.Release();
            }
        }
    }
}

```

## File: Online/Controllers/CDNmovies.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.CDNmovies;

namespace Online.Controllers
{
    public class CDNmovies : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/cdnmovies")]
        async public ValueTask<ActionResult> Index(long kinopoisk_id, string title, string original_title, int t, int s = -1, int sid = -1, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.CDNmovies);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (kinopoisk_id == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var oninvk = new CDNmoviesInvoke
            (
               host,
               init.corsHost(),
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl), httpHeaders(init)) : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               onstreamtofile => HostStreamProxy(init, onstreamtofile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            reset:
            var cache = await InvokeCache<Voice[]>($"cdnmovies:view:{kinopoisk_id}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(kinopoisk_id);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, kinopoisk_id, title, original_title, t, s, sid, vast: init.vast, rjson: rjson), origsource: origsource, gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/Filmix.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Filmix;

namespace Online.Controllers
{
    public class Filmix : BaseOnlineController
    {
        #region filmixpro
        [HttpGet]
        [AllowAnonymous]
        [Route("lite/filmixpro")]
        async public Task<ActionResult> Pro()
        {
            var token_request = await Http.Get<JObject>($"{AppInit.conf.Filmix.corsHost()}/api/v2/token_request?user_dev_apk=2.0.1&user_dev_id=&user_dev_name=Xiaomi&user_dev_os=11&user_dev_vendor=Xiaomi&user_dev_token=", useDefaultHeaders: false);

            if (token_request == null)
                return Content($"–Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ {AppInit.conf.Filmix.corsHost()}", "text/html; charset=utf-8");

            string html = "1. –û—Ç–∫—Ä–æ–π—Ç–µ <a href='https://filmix.my/consoles'>https://filmix.my/consoles</a> <br>";
            html += $"2. –í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ <b>{token_request.Value<string>("user_code")}</b><br>";
            html += $"<br><br><br>–î–æ–±–∞–≤—å—Ç–µ –≤ init.conf<br><br>";
            html += "\"Filmix\": {<br>&nbsp;&nbsp;\"token\": \"" + token_request.Value<string>("code") + "\",<br>&nbsp;&nbsp;\"pro\": true<br>}";

            return Content(html, "text/html; charset=utf-8");
        }
        #endregion

        [HttpGet]
        [Route("lite/filmix")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int clarification, int year, int postid, int t, int? s = null, bool origsource = false, bool rjson = false, bool similar = false, string source = null, string id = null)
        {
            if (postid == 0 && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() is "filmix" or "filmixapp")
                {
                    if (!int.TryParse(id, out postid))
                        int.TryParse(Regex.Match(id, "/([0-9]+)-").Groups[1].Value, out postid);
                }
            }

            var init = await loadKit(AppInit.conf.Filmix, (j, i, c) =>
            {
                if (j.ContainsKey("reserve"))
                    i.reserve = c.reserve;

                i.pro = c.pro;
                i.tokens = c.tokens;
                return i;
            });

            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("cors,web", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            string token = init.token;
            if (init.tokens != null && init.tokens.Length > 1)
                token = init.tokens[Random.Shared.Next(0, init.tokens.Length)];

            reset:

            var oninvk = new FilmixInvoke
            (
               init,
               host,
               token,
               ongettourl => rch.enable 
                    ? rch.Get(init.cors(ongettourl), httpHeaders(init), useDefaultHeaders: false) 
                    : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init), useDefaultHeaders: false),
               (url, data, head) => rch.enable 
                    ? rch.Post(init.cors(url), data, (head != null ? head : httpHeaders(init)), useDefaultHeaders: false) 
                    : Http.Post(init.cors(url), data, timeoutSeconds: 8, headers: head != null ? head : httpHeaders(init), useDefaultHeaders: false),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } },
               rjson: rjson
            );

            if (postid == 0)
            {
                var search = await InvokeCache<SearchResult>($"filmix:search:{title}:{original_title}:{year}:{clarification}:{similar}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    return await oninvk.Search(title, original_title, clarification, year, similar);
                });

                if (!search.IsSuccess)
                    return OnError(search.ErrorMsg);

                if (search.Value.id == 0)
                    return ContentTo(rjson ? search.Value.similars.Value.ToJson() : search.Value.similars.Value.ToHtml());

                postid = search.Value.id;
            }

            var cache = await InvokeCache<RootObject>($"filmix:post:{postid}:{token}", cacheTime(20, init: init), rch.enable ? null : proxyManager, onget: async res =>
            {
                return await oninvk.Post(postid);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, init.pro, postid, title, original_title, t, s, vast: init.vast), origsource: origsource, gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/VideoCDN.cs
```
Ôªøusing Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Lumex;
using Shared.Models.Online.Settings;
using System.Net;
using System.Text;

namespace Online.Controllers
{
    public class VideoCDN : BaseOnlineController
    {
        static VideoCDN() 
        { 
            Directory.CreateDirectory("cache/logs/VideoCDN");

            //Lumex.FixHostEvent();
        }

        #region Initialization
        async ValueTask<LumexSettings> Initialization()
        {
            var init = await loadKit(AppInit.conf.VideoCDN, (j, i, c) =>
            {
                if (j.ContainsKey("log"))
                    i.log = c.log;

                i.clientId = c.clientId;
                i.username = c.username;
                i.password = c.password;
                i.domain = Regex.Replace(c.domain ?? "bwa", "^https?://", "").Split(".")[0];
                i.corseu = false;
                i.rhub = !i.disable_protection;

                return i;
            });

            init.rhub = !init.disable_protection;
            return init;
        }
        #endregion

        [HttpGet]
        [Route("lite/videocdn")]
        async public ValueTask<ActionResult> Index(long content_id, string content_type, string imdb_id, long kinopoisk_id, string title, string original_title, string t, int clarification, bool similar = false, int s = -1, int serial = -1, bool rjson = false, bool checksearch = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.username) || string.IsNullOrEmpty(init.password))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            if (content_id == 0)
            {
                var search = await InvokeCache($"videocdn:search:{imdb_id}:{kinopoisk_id}:{title ?? original_title}:{clarification}:{similar}", TimeSpan.FromHours(1),
                    () => Search(init, imdb_id, kinopoisk_id, title, original_title, serial, clarification, similar, proxy)
                );

                if (search.content_type == null && search.similar.data == null)
                    return OnError();

                if (search.similar.data != null)
                    return ContentTo(rjson ? search.similar.ToJson() : search.similar.ToHtml());

                content_id = search.content_id;
                content_type = search.content_type;
            }

            if (content_id == 0 || string.IsNullOrEmpty(content_type))
                return OnError();

            if (checksearch)
                return Content("data-json=");

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: serial == 0 ? null : -1);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string accessToken = await getToken(proxy);
            if (string.IsNullOrEmpty(accessToken))
                return OnError();

            var player = await getPlayer(content_id, content_type, accessToken, proxy);
            if (player == null)
                return OnError();

            if (player.content_type is "movie" or "anime")
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title, player.media.Length);

                foreach (var media in player.media)
                {
                    string hash = CrypTo.md5($"{init.clientId}:{content_type}:{content_id}:{media.playlist}:{requestInfo.IP}");
                    string link = accsArgs($"{host}/lite/videocdn/video?rjson={rjson}&content_id={content_id}&content_type={content_type}&playlist={HttpUtility.UrlEncode(media.playlist)}&max_quality={media.max_quality}&translation_id={media.translation_id}&hash={hash}");
                    string streamlink = link.Replace("/videocdn/video", "/videocdn/video.m3u8") + "&play=true";

                    mtpl.Append(media.translation_name, link, "call", streamlink, quality: media.max_quality?.ToString());
                }

                return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                if (s == -1)
                {
                    var tpl = new SeasonTpl(player.media.First().max_quality?.ToString(), player.media.Length);

                    foreach (var media in player.media.OrderBy(s => s.season_id))
                    {
                        string link = $"{host}/lite/videocdn?rjson={rjson}&content_id={content_id}&content_type={content_type}&title={enc_title}&original_title={enc_original_title}&s={media.season_id}";
                        tpl.Append($"{media.season_id} —Å–µ–∑–æ–Ω", link, media.season_id);
                    }

                    return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                }
                else
                {
                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var vtpl = new VoiceTpl();
                    var tmpVoice = new HashSet<int>();

                    foreach (var media in player.media)
                    {
                        if (media.season_id != s)
                            continue;

                        foreach (var episode in media.episodes)
                        {
                            foreach (var voice in episode.media)
                            {
                                if (tmpVoice.Contains(voice.translation_id))
                                    continue;

                                tmpVoice.Add(voice.translation_id);

                                if (string.IsNullOrEmpty(t))
                                    t = voice.translation_id.ToString();

                                vtpl.Append(voice.translation_name, t == voice.translation_id.ToString(), $"{host}/lite/videocdn?rjson={rjson}&content_id={content_id}&content_type={content_type}&title={enc_title}&original_title={enc_original_title}&s={s}&t={voice.translation_id}");
                            }
                        }
                    }
                    #endregion

                    if (string.IsNullOrEmpty(t))
                        t = "0";

                    var etpl = new EpisodeTpl();
                    string sArhc = s.ToString();

                    foreach (var media in player.media)
                    {
                        if (media.season_id != s)
                            continue;

                        foreach (var episode in media.episodes)
                        {
                            foreach (var voice in episode.media)
                            {
                                if (voice.translation_id.ToString() != t)
                                    continue;

                                string hash = CrypTo.md5($"{init.clientId}:{content_type}:{content_id}:{voice.playlist}:{requestInfo.IP}");
                                string link = accsArgs($"{host}/lite/videocdn/video?content_id={content_id}&content_type={content_type}&playlist={HttpUtility.UrlEncode(voice.playlist)}&max_quality={voice.max_quality}&s={s}&e={episode.episode_id}&translation_id={voice.translation_id}&hash={hash}&serial=true");
                                string streamlink = link.Replace("/videocdn/video", "/videocdn/video.m3u8") + "&play=true";

                                etpl.Append($"{episode.episode_id} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.episode_id.ToString(), link, "call", streamlink: streamlink);
                            }
                        }
                    }

                    if (rjson)
                        return ContentTo(etpl.ToJson(vtpl));

                    return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                }
                #endregion
            }
        }


        #region Video
        static FileStream logFileStream = null;

        [HttpGet]
        [Route("lite/videocdn/video")]
        [Route("lite/videocdn/video.m3u8")]
        async public ValueTask<ActionResult> Video(string hash, long content_id, string content_type, string playlist, int max_quality, bool play, bool serial, int s, int e, int translation_id)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (hash != CrypTo.md5($"{init.clientId}:{content_type}:{content_id}:{playlist}:{requestInfo.IP}"))
                return OnError("hash", gbcache: false);

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: serial ? -1 : null);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            string accessToken = await getToken(proxy);
            if (string.IsNullOrEmpty(accessToken))
                return OnError("token", gbcache: false);

            try
            {
                if (init.log)
                {
                    string data = System.Text.Json.JsonSerializer.Serialize(new
                    {
                        time = DateTime.Now,
                        requestInfo.Country,
                        requestInfo.IP,
                        requestInfo.UserAgent,
                        video = new { content_id, content_type, playlist, accessToken }
                    });

                    string patchlog = $"cache/logs/VideoCDN/{DateTime.Today:dd-MM}.txt";

                    if (logFileStream == null || !System.IO.File.Exists(patchlog))
                        logFileStream = new FileStream(patchlog, FileMode.Append, FileAccess.Write);

                    var buffer = Encoding.UTF8.GetBytes($"{data}\n");
                    logFileStream.Write(buffer, 0, buffer.Length);
                    logFileStream.Flush();
                }
            }
            catch { }

            string clientIP = init.verifyip ? requestInfo.IP : "::1";
            string memkey = $"videocdn/video:{playlist}:{(init.streamproxy ? "" : clientIP)}";

            return await InvkSemaphore(init, memkey, async () =>
            {
                if (!hybridCache.TryGetValue(memkey, out string hls))
                {
                    var headers = HeadersModel.Init("Authorization", $"Bearer {accessToken}");

                    if (!init.streamproxy)
                        headers.Add(new("X-LAMPA-CLIENT-IP", clientIP));

                    var result = rch.enable ? await rch.Post<JObject>(init.apihost + playlist, "{}", headers: headers) :
                                              await Http.Post<JObject>(init.apihost + playlist, "{}", headers: headers, proxy: proxy);

                    if (result == null || !result.ContainsKey("url"))
                        return OnError(null, gbcache: false);

                    string url = result.Value<string>("url");
                    if (string.IsNullOrEmpty(url))
                        return OnError(null, gbcache: false);

                    if (url.StartsWith("/"))
                        hls = $"{init.scheme}:{url}";
                    else
                        hls = url;

                    hybridCache.Set(memkey, hls, DateTime.Now.AddMinutes(10));
                }

                if (play)
                    return Redirect(HostStreamProxy(init, hls));

                var player = await getPlayer(content_id, content_type, accessToken, proxy);
                VastConf vast = requestInfo.user != null ? null : new VastConf() { url = player?.tag_url, msg = init?.vast?.msg };
                if (init.disable_ads)
                    vast = null;

                #region subtitle
                var subtitles = new SubtitleTpl();

                try
                {
                    if (translation_id > 0)
                    {
                        if (serial)
                        {
                            if (e > 0 && s > 0)
                            {
                                foreach (var media in player.media.Where(i => i.season_id == s))
                                {
                                    foreach (var episode in media.episodes.Where(i => i.episode_id == e))
                                    {
                                        foreach (var voice in episode.media.Where(i => i.translation_id == translation_id))
                                        {
                                            if (voice.tracks != null)
                                            {
                                                foreach (var t in voice.tracks)
                                                    subtitles.Append(t.label ?? t.srlang, $"{init.scheme}:{t.src}");

                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            var tracks = player.media.FirstOrDefault(i => i.translation_id == translation_id).tracks;
                            if (tracks != null)
                            {
                                foreach (var t in tracks)
                                    subtitles.Append(t.label ?? t.srlang, $"{init.scheme}:{t.src}");
                            }
                        }
                    }
                }
                catch { }
                #endregion

                if (max_quality > 0 && !init.hls)
                {
                    var streamquality = new StreamQualityTpl();
                    foreach (int q in new int[] { 1080, 720, 480, 360, 240 })
                    {
                        if (max_quality >= q)
                            streamquality.Append(HostStreamProxy(init, Regex.Replace(hls, "/hls\\.m3u8$", $"/{q}.mp4")), $"{q}p");
                    }

                    if (!streamquality.Any())
                        return OnError("streams");

                    var first = streamquality.Firts();
                    return ContentTo(VideoTpl.ToJson("play", first.link, first.quality, streamquality: streamquality, subtitles: subtitles, vast: vast));
                }

                return ContentTo(VideoTpl.ToJson("play", HostStreamProxy(init, hls), "auto", subtitles: subtitles, vast: vast));
            });
        }
        #endregion


        #region getToken
        async ValueTask<string> getToken(WebProxy proxy)
        {
            var init = await Initialization();

            #region refreshToken
            string memKey = $"videocdn:refreshToken:{init.username}";
            if (!hybridCache.TryGetValue(memKey, out string refreshToken))
            {
                var data = new System.Net.Http.StringContent($"{{\"username\":\"{init.username}\",\"password\":\"{init.password}\"}}", Encoding.UTF8, "application/json");
                var job = await Http.Post<JObject>($"{init.apihost}/login", data, useDefaultHeaders: false, proxy: proxy);
                if (job == null || !job.ContainsKey("refreshToken"))
                    return null;

                refreshToken = job.Value<string>("refreshToken");
                if (string.IsNullOrEmpty(refreshToken))
                    return null;

                hybridCache.Set(memKey, refreshToken, DateTime.Now.AddDays(2));
            }
            #endregion

            string clientIP = init.verifyip ? requestInfo.IP : "::1";

            memKey = $"videocdn:accessToken:{(init.streamproxy ? "" : clientIP)}";
            if (!hybridCache.TryGetValue(memKey, out string accessToken))
            {
                var headers = init.streamproxy ? null : HeadersModel.Init(("X-LAMPA-CLIENT-IP", clientIP));

                var data = new System.Net.Http.StringContent($"{{\"token\":\"{refreshToken}\"}}", Encoding.UTF8, "application/json");
                var job = await Http.Post<JObject>($"{init.apihost}/refresh", data, timeoutSeconds: 5, useDefaultHeaders: false, headers: headers, proxy: proxy);
                if (job == null || !job.ContainsKey("accessToken"))
                    return null;

                accessToken = job.Value<string>("accessToken");
                if (string.IsNullOrEmpty(accessToken))
                    return null;

                hybridCache.Set(memKey, accessToken, DateTime.Now.AddMinutes(5));
            }

            return accessToken;
        }
        #endregion

        #region getPlayer
        async ValueTask<EmbedModel> getPlayer(long content_id, string content_type, string accessToken, WebProxy proxy)
        {
            if (content_id == 0 || string.IsNullOrEmpty(content_type))
                return null;

            var init = await Initialization();
            string clientIP = init.verifyip ? requestInfo.IP : "::1";

            return await InvokeCache($"videocdn:{content_id}:{content_type}:{accessToken}:{(init.streamproxy ? "" : clientIP)}", TimeSpan.FromMinutes(5), async () =>
            {
                var headers = HeadersModel.Init(
                    ("Authorization", $"Bearer {accessToken}"),
                    ("User-Agent", HttpContext.Request.Headers.UserAgent)
                );

                if (!init.streamproxy)
                    headers.Add(new("X-LAMPA-CLIENT-IP", clientIP));

                string json = await Http.Get($"{init.apihost}/stream?clientId={init.clientId}&contentType={content_type}&contentId={content_id}&domain={init.domain}", useDefaultHeaders: false, timeoutSeconds: 8, headers: headers, proxy: proxy);
                if (string.IsNullOrEmpty(json))
                    return null;

                var job = JsonConvert.DeserializeObject<JObject>(json);

                var model = job["player"].ToObject<EmbedModel>();
                model.tag_url = job["ads"]["rolls"].First.Value<string>("tag_url");

                return model;
            });
        }
        #endregion

        #region Search
        async ValueTask<(long content_id, string content_type, SimilarTpl similar)> Search(LumexSettings init, string imdb_id, long kinopoisk_id, string title, string original_title, int serial, int clarification, bool similar, WebProxy proxy)
        {
            async Task<JToken> searchId(string imdb_id, long kinopoisk_id)
            {
                if (string.IsNullOrEmpty(init.token))
                    return null;

                if (string.IsNullOrEmpty(imdb_id) && kinopoisk_id == 0)
                    return null;

                string arg = kinopoisk_id > 0 ? $"&kinopoisk_id={kinopoisk_id}" : $"&imdb_id={imdb_id}";
                var job = await Http.Get<JObject>($"{init.iframehost}/api/short?api_token={init.token}" + arg, timeoutSeconds: 8, proxy: proxy);
                if (job == null || !job.ContainsKey("data"))
                    return null;

                var result = job["data"]?.First;
                if (result == null)
                    return null;

                return result;
            }

            var movie = similar ? null : (await searchId(imdb_id, 0) ?? await searchId(null, kinopoisk_id));
            if (movie != null)
            {
                return (movie.Value<long>("id"), movie.Value<string>("content_type"), default);
            }
            else
            {
                if (string.IsNullOrEmpty(title ?? original_title) || string.IsNullOrEmpty(init.token))
                    return default;

                string uri = $"{init.iframehost}/api/short?api_token={init.token}&title={HttpUtility.UrlEncode(clarification == 1 ? title : (original_title ?? title))}";
                string json = await Http.Get(uri, timeoutSeconds: 8, proxy: proxy);
                if (json == null)
                    return default;

                SearchRoot root;

                try
                {
                    root = JsonConvert.DeserializeObject<SearchRoot>(json);
                    if (root?.data == null || root.data.Length == 0)
                        return default;
                }
                catch { return default; }

                var stpl = new SimilarTpl(root.data.Length);

                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);

                int count = 0;
                foreach (var item in root.data)
                {
                    if (serial != -1)
                    {
                        if ((serial == 0 && item.content_type != "movie") || (serial == 1 && item.content_type == "movie"))
                            continue;
                    }

                    if (clarification != 1)
                    {
                        bool isok = title != null && title.Length > 3 && item.title != null && item.title.ToLower().Contains(title.ToLower());
                        isok = isok ? true : original_title != null && original_title.Length > 3 && item.orig_title != null && item.orig_title.ToLower().Contains(original_title.ToLower());

                        if (!isok)
                            continue;
                    }

                    string year = item.add?.Split("-")?[0] ?? string.Empty;
                    string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.orig_title) ? $"{item.title} / {item.orig_title}" : (item.title ?? item.orig_title);

                    string details = $"imdb: {item.imdb_id} {stpl.OnlineSplit} kinopoisk: {item.kp_id}";

                    string img = PosterApi.Find(item.kp_id, item.imdb_id);
                    stpl.Append(name, year, details, $"{host}/lite/videocdn?title={enc_title}&original_title={enc_original_title}&content_id={item.id}&content_type={item.content_type}", img);

                    count += 1;
                }

                return (0, null, stpl);
            }
        }
        #endregion
    }
}

```

## File: Online/Controllers/FanCDN.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Shared.PlaywrightCore;
using System.Net;
using BrowserCookie = Microsoft.Playwright.Cookie;
using Microsoft.AspNetCore.Routing;
using Shared.Models.Online.Settings;
using Shared.Models.Online.FanCDN;

namespace Online.Controllers
{
    public class FanCDN : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/fancdn")]
        async public ValueTask<ActionResult> Index(string imdb_id, long kinopoisk_id, string title, string original_title, int year, int serial, int t = -1, int s = -1, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.FanCDN);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.token) && string.IsNullOrEmpty(init.cookie))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var oninvk = new FanCDNInvoke
            (
               host,
               init.host,
               async ongettourl => 
               {
                   if (ongettourl.Contains("fancdn."))
                       return await black_magic(init, rch, init.cors(ongettourl), proxy);

                   if (string.IsNullOrEmpty(init.cookie))
                       return null;

                   var headers = httpHeaders(init, HeadersModel.Init(
                       ("sec-fetch-dest", "document"),
                       ("sec-fetch-mode", "navigate"),
                       ("sec-fetch-site", "none"),
                       ("cookie", init.cookie)
                   ));

                   if (rch.enable)
                       return await rch.Get(init.cors(ongettourl), headers);

                   if (init.priorityBrowser == "http")
                       return await Http.Get(init.cors(ongettourl), httpversion: 2, timeoutSeconds: 8, proxy: proxy.proxy, headers: headers);

                   #region Browser Search
                   try
                   {
                       using (var browser = new PlaywrightBrowser())
                       {
                           var page = await browser.NewPageAsync(init.plugin, proxy: proxy.data);
                           if (page == null)
                               return null;

                           string fanhost = "." + Regex.Replace(init.host, "^https?://", "");
                           var excookie = DateTimeOffset.UtcNow.AddYears(1).ToUnixTimeSeconds();

                           var cookies = new List<BrowserCookie>();
                           foreach (string line in init.cookie.Split(";"))
                           {
                               if (string.IsNullOrEmpty(line) || !line.Contains("=") || line.Contains("cf_clearance") || line.Contains("PHPSESSID"))
                                   continue;

                               cookies.Add(new BrowserCookie()
                               {
                                   Domain = fanhost,
                                   Expires = excookie,
                                   Path = "/",
                                   HttpOnly = true,
                                   Secure = true,
                                   Name = line.Split("=")[0].Trim(),
                                   Value = line.Split("=")[1].Trim()
                               });
                           }

                           await page.Context.AddCookiesAsync(cookies);

                           var response = await page.GotoAsync(ongettourl, new PageGotoOptions()
                           {
                               Timeout = 10_000,
                               WaitUntil = WaitUntilState.DOMContentLoaded 
                           });

                           if (response == null)
                               return null;

                           string result = await response.TextAsync();
                           PlaywrightBase.WebLog("GET", ongettourl, result, proxy.data, response: response);
                           return result;
                       }
                   }
                   catch
                   {
                       return null;
                   }
                   #endregion
               },
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy.proxy)
            );

            reset:
            var cache = await InvokeCache<EmbedModel>(rch.ipkey($"fancdn:{title}", proxyManager), cacheTime(20, init: init), proxyManager, async res =>
            {
                var result = !string.IsNullOrEmpty(init.token) && kinopoisk_id > 0 ? await oninvk.EmbedToken(kinopoisk_id, init.token) : await oninvk.EmbedSearch(title, original_title, year, serial);
                if (result == null)
                    return res.Fail("result");

                return result;
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, imdb_id, kinopoisk_id, title, original_title, t, s, rjson: rjson, vast: init.vast, headers: httpHeaders(init)), origsource: origsource);
        }


        #region black_magic
        async Task<string> black_magic(OnlinesSettings init, RchClient rch, string uri, (WebProxy proxy, (string ip, string username, string password) data) baseproxy)
        {
            try
            {
                var headers = httpHeaders(init, HeadersModel.Init(
                    ("sec-fetch-dest", "iframe"),
                    ("sec-fetch-mode", "navigate"),
                    ("sec-fetch-site", "cross-site"),
                    ("referer", $"{init.host}/")
                ));

                if (rch.enable)
                    return await rch.Get(uri, headers);

                if (init.priorityBrowser == "http")
                    return await Http.Get(uri, httpversion: 2, timeoutSeconds: 8, proxy: baseproxy.proxy, headers: headers);

                using (var browser = new PlaywrightBrowser())
                {
                    var page = await browser.NewPageAsync(init.plugin, init.headers, proxy: baseproxy.data, imitationHuman: init.imitationHuman);
                    if (page == null)
                        return null;

                    browser.SetFailedUrl(uri);

                    await page.RouteAsync("**/*", async route =>
                    {
                        try
                        {
                            if (route.Request.Url.StartsWith(init.host))
                            {
                                await route.FulfillAsync(new RouteFulfillOptions
                                {
                                    Body = PlaywrightBase.IframeHtml(uri)
                                });
                            }
                            else if (route.Request.Url == uri)
                            {
                                string html = null;
                                await browser.ClearContinueAsync(route, page);

                                var response = await page.WaitForResponseAsync(route.Request.Url);
                                if (response != null)
                                    html = await response.TextAsync();

                                browser.SetPageResult(html);
                                PlaywrightBase.WebLog(route.Request, response, html, baseproxy.data);
                            }
                            else
                            {
                                if (!init.imitationHuman || route.Request.Url.EndsWith(".m3u8"))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                }
                                else
                                {
                                    if (await PlaywrightBase.AbortOrCache(page, route))
                                        return;

                                    await browser.ClearContinueAsync(route, page);
                                }
                            }
                        }
                        catch { }
                    });

                    PlaywrightBase.GotoAsync(page, init.host);
                    return await browser.WaitPageResult();
                }
            }
            catch
            {
                return null; 
            }
        }
        #endregion
    }
}

```

## File: Online/Controllers/VoKino.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.VoKino;

namespace Online.Controllers
{
    public class VoKino : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.VoKino);

        #region vokinotk
        [HttpGet]
        [AllowAnonymous]
        [Route("lite/vokinotk")]
        async public Task<ActionResult> Token(string login, string pass)
        {
            string html = string.Empty;

            if (string.IsNullOrWhiteSpace(login) || string.IsNullOrWhiteSpace(pass))
            {
                html = "–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç–∞ <a href='http://vokino.tv'>vokino.tv</a> <br> <br><form method=\"get\" action=\"/lite/vokinotk\"><input type=\"text\" name=\"login\" placeholder=\"email\"> &nbsp; &nbsp; <input type=\"text\" name=\"pass\" placeholder=\"–ø–∞—Ä–æ–ª—å\"><br><br><button>–î–æ–±–∞–≤–∏—Ç—å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ</button></form> ";
            }
            else
            {
                string deviceid = new string(DateTime.Now.ToBinary().ToString().Reverse().ToArray()).Substring(0, 8);
                var token_request = await Http.Get<JObject>($"{AppInit.conf.VoKino.corsHost()}/v2/auth?email={HttpUtility.UrlEncode(login)}&passwd={HttpUtility.UrlEncode(pass)}&deviceid={deviceid}", proxy: proxyManager.Get(), headers: HeadersModel.Init("user-agent", "lampac"));

                if (token_request == null)
                    return Content($"–Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ {AppInit.conf.VoKino.corsHost()}", "text/html; charset=utf-8");

                string authToken = token_request.Value<string>("authToken");
                if (string.IsNullOrEmpty(authToken))
                    return Content(token_request.Value<string>("error") ?? "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–æ–∫–µ–Ω", "text/html; charset=utf-8");

                html = "–î–æ–±–∞–≤—å—Ç–µ –≤ init.conf<br><br>\"VoKino\": {<br>&nbsp;&nbsp;\"enable\": true,<br>&nbsp;&nbsp;\"token\": \"" + authToken + "\"<br>}";
            }

            return Content(html, "text/html; charset=utf-8");
        }
        #endregion

        [HttpGet]
        [Route("lite/vokino")]
        async public ValueTask<ActionResult> Index(bool checksearch, string origid, long kinopoisk_id, string title, string original_title, string balancer, string t, int s = -1, bool rjson = false, string source = null, string id = null)
        {
            if (string.IsNullOrEmpty(origid) && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() == "vokino")
                    origid = id;
            }

            var init = await loadKit(AppInit.conf.VoKino, (j, i, c) => 
            {
                if (j.ContainsKey("online"))
                    i.online = c.online;
                return i; 
            });

            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            if (kinopoisk_id == 0 && string.IsNullOrEmpty(origid))
                return OnError();

            if (balancer is "filmix" or "ashdi" or "monframe")
                init.streamproxy = false;

            if (checksearch /*&& balancer != "vokino"*/)
                return Content("data-json="); // –∑–∞–≥–ª—É—à–∫–∞ –æ—Ç 429 –∏ +1 –∫ –ø—Ä–æ—Å–º–æ—Ç—Ä—É

            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var oninvk = new VoKinoInvoke
            (
               host,
               init.corsHost(),
               init.token,
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl), httpHeaders(init)) : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            reset:
            var cache = await InvokeCache<EmbedModel>(rch.ipkey($"vokino:{kinopoisk_id}:{origid}:{balancer}:{t}:{init.token}", proxyManager), cacheTime(20, rhub: 2, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(origid, kinopoisk_id, balancer, t);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, origid, kinopoisk_id, title, original_title, balancer, t, s, init.vast, rjson), gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/Vibix.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Vibix;
using Shared.Models.Online.Settings;

namespace Online.Controllers
{
    public class Vibix : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.Vibix);

        [HttpGet]
        [Route("lite/vibix")]
        async public ValueTask<ActionResult> Index(string imdb_id, long kinopoisk_id, string title, string original_title,  int s = -1, bool rjson = false, bool origsource = false)
        {
            var init = await loadKit(AppInit.conf.Vibix);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            var data = await search(init, imdb_id, kinopoisk_id);
            if (data == null)
                return OnError();

            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            reset:
            var cache = await InvokeCache<EmbedModel>(rch.ipkey($"vibix:iframe:{data.iframe_url}:{init.token}", proxyManager), cacheTime(20, rhub: 2, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string api_url = data.iframe_url
                    .Replace("/embed/", "/api/v1/embed/")
                    .Replace("/embed-serials/", "/api/v1/embed-serials/");

                api_url += $"?kp={CrypTo.unic(6).ToLower()}";

                var api_headers = httpHeaders(init, HeadersModel.Init(
                    ("accept", "*/*"),
                    ("accept-language", "ru-RU,ru;q=0.9,uk-UA;q=0.8,uk;q=0.7,en-US;q=0.6,en;q=0.5"),
                    ("sec-fetch-dest", "empty"),
                    ("sec-fetch-mode", "cors"),
                    ("sec-fetch-site", "same-origin"),
                    ("referer", data.iframe_url)
                ));

                var root = rch.enable 
                    ? await rch.Get<JObject>(init.cors(api_url), api_headers) 
                    : await Http.Get<JObject>(init.cors(api_url), timeoutSeconds: 8, proxy: proxy, headers: api_headers, httpversion: 2);

                if (root == null || !root.ContainsKey("data") || root["data"]?["playlist"] == null)
                    return res.Fail("root");

                return new EmbedModel() { playlist = root["data"]["playlist"].ToObject<Seasons[]>() };
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            if (data.type == "movie")
            {
                #region –§–∏–ª—å–º
                return OnResult(cache, () => 
                {
                    var mtpl = new MovieTpl(title, original_title, 1);

                    foreach (var movie in cache.Value.playlist)
                    {
                        var streams = new StreamQualityTpl();

                        foreach (string q in new string[] { "1080", "720", "480" })
                        {
                            var g = new Regex($"{q}p?\\](\\{{[^\\}}]+\\}})?(?<file>https?://[^,\t\\[\\;\\{{ ]+\\.mp4)").Match(movie.file).Groups;

                            if (!string.IsNullOrEmpty(g["file"].Value))
                                streams.Append(HostStreamProxy(init, g["file"].Value, proxy: proxy), $"{q}p");
                        }

                        mtpl.Append(movie.title, streams.Firts().link, streamquality: streams, vast: init.vast);
                    }

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();

                }, origsource: origsource, gbcache: !rch.enable);
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                return OnResult(cache, () =>
                {
                    string enc_title = HttpUtility.UrlEncode(title);
                    string enc_original_title = HttpUtility.UrlEncode(original_title);

                    if (s == -1)
                    {
                        var tpl = new SeasonTpl(cache.Value.playlist.Length);

                        foreach (var season in cache.Value.playlist)
                        {
                            string name = season.title;
                            if (int.TryParse(Regex.Match(name, "([0-9]+)$").Groups[1].Value, out int _s) && _s > 0)
                            {
                                string link = $"{host}/lite/vibix?rjson={rjson}&kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&title={enc_title}&original_title={enc_original_title}&s={_s}";
                                tpl.Append($"{_s} —Å–µ–∑–æ–Ω", link, _s);
                            }
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        var etpl = new EpisodeTpl();
                        string sArhc = s.ToString();

                        foreach (var season in cache.Value.playlist)
                        {
                            if (!season.title.EndsWith($" {s}"))
                                continue;

                            foreach (var episode in season.folder)
                            {
                                string name = episode.title;
                                string file = episode.folder?.First().file ?? episode.file;

                                if (string.IsNullOrEmpty(name) || string.IsNullOrEmpty(file))
                                    continue;

                                var streams = new StreamQualityTpl();

                                foreach (string q in new string[] { "1080", "720", "480" })
                                {
                                    var g = new Regex($"{q}p?\\](\\{{[^\\}}]+\\}})?(?<file>https?://[^,\t\\[\\;\\{{ ]+\\.mp4)").Match(file).Groups;
                                    if (!string.IsNullOrEmpty(g["file"].Value))
                                        streams.Append(HostStreamProxy(init, g["file"].Value, proxy: proxy), $"{q}p");
                                }

                                etpl.Append(name, title ?? original_title, sArhc, Regex.Match(name, "([0-9]+)").Groups[1].Value, streams.Firts().link, streamquality: streams, vast: init.vast);
                            }
                        }

                        return rjson ? etpl.ToJson() : etpl.ToHtml();
                    }

                }, origsource: origsource, gbcache: !rch.enable);
                #endregion
            }
        }


        #region search
        async ValueTask<Video> search(OnlinesSettings init, string imdb_id, long kinopoisk_id)
        {
            string memKey = $"vibix:view:{kinopoisk_id}:{imdb_id}";

            if (!hybridCache.TryGetValue(memKey, out Video root))
            {
                async Task<Video> goSearch(string imdb_id, long kinopoisk_id)
                {
                    if (string.IsNullOrEmpty(imdb_id) && kinopoisk_id == 0)
                        return null;

                    string uri = kinopoisk_id > 0 ? $"kp/{kinopoisk_id}" : $"imdb/{imdb_id}";
                    var header = httpHeaders(init, HeadersModel.Init(
                        ("Accept", "application/json"),
                        ("Authorization", $"Bearer {init.token}"),
                        ("X-CSRF-TOKEN", "")
                    ));

                    var video = await Http.Get<Video>($"{init.host}/api/v1/publisher/videos/{uri}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: header);

                    if (video == null)
                    {
                        proxyManager.Refresh();
                        return null;
                    }

                    if (string.IsNullOrEmpty(video.iframe_url) || string.IsNullOrEmpty(video.type))
                        return null;

                    return video;
                }

                root = await goSearch(null, kinopoisk_id) ?? await goSearch(imdb_id, 0);
                if (root == null)
                    return null;

                proxyManager.Success();
                hybridCache.Set(memKey, root, cacheTime(30, init: init));
            }

            return root;
        }
        #endregion
    }
}

```

## File: Online/Controllers/Zetflix.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class Zetflix : BaseOnlineController
    {
        static string PHPSESSID = null;

        [HttpGet]
        [Route("lite/zetflix")]
        async public ValueTask<ActionResult> Index(long id, int serial, long kinopoisk_id, string title, string original_title, string t, int s = -1, bool orightml = false, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.Zetflix);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (kinopoisk_id == 0)
                return OnError();

            if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string ztfhost = await goHost(init.host);
            string log = $"{HttpContext.Request.Path.Value}\n\nstart init\n";

            var oninvk = new ZetflixInvoke
            (
               host,
               ztfhost,
               init.hls,
               (url, head) => Http.Get(init.cors(url), headers: httpHeaders(init, head), timeoutSeconds: 8, proxy: proxy.proxy),
               onstreamtofile => HostStreamProxy(init, onstreamtofile, proxy: proxy.proxy)
               //AppInit.log
            );

            int rs = serial == 1 ? (s == -1 ? 1 : s) : s;

            string html = await InvokeCache($"zetfix:view:{kinopoisk_id}:{rs}:{proxyManager.CurrentProxyIp}", cacheTime(20, init: init), async () => 
            {
                string uri = $"{ztfhost}/iplayer/videodb.php?kp={kinopoisk_id}" + (rs > 0 ? $"&season={rs}" : "");

                var headers = HeadersModel.Init(Chromium.baseContextOptions.ExtraHTTPHeaders.ToDictionary(), ("Referer", "https://www.google.com/"));

                string result = string.IsNullOrEmpty(PHPSESSID) ? null : await Http.Get(uri, proxy: proxy.proxy, cookie: $"PHPSESSID={PHPSESSID}", headers: headers);
                if (result != null && !result.StartsWith("<script>(function"))
                {
                    if (!result.Contains("new Playerjs"))
                        return null;

                    proxyManager.Success();
                    return result;
                }

                try
                {
                    using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                    {
                        log += "browser init\n";

                        var page = await browser.NewPageAsync(init.plugin, new Dictionary<string, string>()
                        {
                            ["Referer"] = "https://www.google.com/"

                        }, proxy: proxy.data, keepopen: init.browser_keepopen).ConfigureAwait(false);

                        if (page == null)
                            return null;

                        if (init.browser_keepopen)
                        {
                            await page.Context.ClearCookiesAsync(new BrowserContextClearCookiesOptions
                            {
                                Domain = Regex.Replace(ztfhost, "^https?://", ""),
                                Name = "PHPSESSID"

                            }).ConfigureAwait(false);
                        }

                        log += "page init\n";

                        await page.RouteAsync("**/*", async route =>
                        {
                            try
                            {
                                if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                    return;

                                await route.ContinueAsync();
                            }
                            catch { }
                        });

                        await page.GotoAsync(uri, new PageGotoOptions() 
                        {
                            Timeout = 15_000,
                            WaitUntil = WaitUntilState.NetworkIdle 
                        }).ConfigureAwait(false);

                        result = await page.ContentAsync().ConfigureAwait(false);

                        log += $"{result}\n\n";

                        if (result == null || result.StartsWith("<script>(function"))
                        {
                            proxyManager.Refresh();
                            return null;
                        }

                        var cook = await page.Context.CookiesAsync().ConfigureAwait(false);
                        PHPSESSID = cook?.FirstOrDefault(i => i.Name == "PHPSESSID")?.Value;

                        if (!result.Contains("new Playerjs"))
                            return null;

                        return result;
                    }
                }
                catch (Exception ex) 
                {
                    log += $"\nex: {ex}\n";
                    return null; 
                }
            });

            if (html == null)
                return OnError();

            if (orightml)
                return Content(html, "text/plain; charset=utf-8");

            var content = oninvk.Embed(html);
            if (content.pl == null)
                return OnError();

            if (origsource)
                return Json(content);

            int number_of_seasons = 1;
            if (!content.movie && s == -1 && id > 0)
                number_of_seasons = await InvokeCache($"zetfix:number_of_seasons:{kinopoisk_id}", cacheTime(120, init: init), () => oninvk.number_of_seasons(id));

            OnLog(log + "\nStart OnResult");

            return ContentTo(oninvk.Html(content, number_of_seasons, kinopoisk_id, title, original_title, t, s, vast: init.vast, rjson: rjson));
        }


        async ValueTask<string> goHost(string host)
        {
            if (!Regex.IsMatch(host, "^https?://go\\."))
                return host;

            string backhost = CrypTo.DecodeBase64("aHR0cHM6Ly96ZXQtZmxpeC5vbmxpbmU=");

            string memkey = $"zeflix:gohost:{host}";
            if (hybridCache.TryGetValue(memkey, out string ztfhost))
            {
                if (string.IsNullOrEmpty(ztfhost))
                    return backhost;

                return ztfhost;
            }

            string html = await Http.Get(host, timeoutSeconds: 8);
            if (html != null)
            {
                ztfhost = Regex.Match(html, "\"([^\"]+)\"\\);</script>").Groups[1].Value;
                if (!string.IsNullOrEmpty(ztfhost))
                {
                    ztfhost = $"https://{ztfhost}";
                    hybridCache.Set(memkey, ztfhost, DateTime.Now.AddMinutes(20));
                    return ztfhost;
                }
            }
            else
            {
                hybridCache.Set(memkey, string.Empty, DateTime.Now.AddMinutes(1));
            }

            return backhost;
        }
    }
}

```

## File: Online/Controllers/KinoPub.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.KinoPub;
using System.Net;

namespace Online.Controllers
{
    public class KinoPub : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.KinoPub);

        static CookieContainer cookies = new CookieContainer();

        #region kinopubpro
        [HttpGet]
        [AllowAnonymous]
        [Route("lite/kinopubpro")]
        async public Task<ActionResult> Pro(string code, string name)
        {
            var proxy = proxyManager.Get();
            var init = AppInit.conf.KinoPub;
            var headers = httpHeaders(init);

            if (string.IsNullOrWhiteSpace(code))
            {
                var token_request = await Http.Post<JObject>($"{init.corsHost()}/oauth2/device?grant_type=device_code&client_id=xbmc&client_secret=cgg3gtifu46urtfp2zp1nqtba0k2ezxh", "", proxy: proxy, headers: httpHeaders(init), httpversion: 2);

                if (token_request == null)
                    return Content($"–Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ {init.corsHost()}", "text/html; charset=utf-8");

                string html = "1. –û—Ç–∫—Ä–æ–π—Ç–µ <a href='https://kino.pub/device'>https://kino.pub/device</a> <br>";
                html += $"2. –í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ <b>{token_request.Value<string>("user_code")}</b><br>";
                html += $"3. –ö–æ–≥–¥–∞ –Ω–∞ —Å–∞–π—Ç–µ kino.pub –ø–æ—è–≤–∏—Ç—Å—è \"–û–∂–∏–¥–∞–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞\", –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É \"–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∞–∫—Ç–∏–≤–∞—Ü–∏—é\" –∫–æ—Ç–æ—Ä–∞—è –Ω–∏–∂–µ</b>";

                html += $"<br><br><a href='/lite/kinopubpro?code={token_request.Value<string>("code")}&name={name}'><button>–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∞–∫—Ç–∏–≤–∞—Ü–∏—é</button></a>";

                return Content(html, "text/html; charset=utf-8");
            }
            else
            {
                var device_token = await Http.Post<JObject>($"{init.corsHost()}/oauth2/device?grant_type=device_token&client_id=xbmc&client_secret=cgg3gtifu46urtfp2zp1nqtba0k2ezxh&code={code}", "", proxy: proxy, headers: httpHeaders(init), httpversion: 2);
                if (device_token == null || string.IsNullOrWhiteSpace(device_token.Value<string>("access_token")))
                    return LocalRedirect("/lite/kinopubpro");

                if (!string.IsNullOrEmpty(name))
                    await Http.Post($"{init.corsHost()}/v1/device/notify?access_token={device_token.Value<string>("access_token")}", $"&title={name}", proxy: proxy, headers: httpHeaders(init), httpversion: 2);

                return Content("–î–æ–±–∞–≤—å—Ç–µ –≤ init.conf<br><br>\"KinoPub\": {<br>&nbsp;&nbsp;\"enable\": true,<br>&nbsp;&nbsp;\"token\": \"" + device_token.Value<string>("access_token") + "\"<br>}", "text/html; charset=utf-8");
            }
        }
        #endregion

        [HttpGet]
        [Route("lite/kinopub")]
        async public ValueTask<ActionResult> Index(string imdb_id, long kinopoisk_id, string title, string original_title, int year, int clarification, int postid, int s = -1, int t = -1, string codec = null, bool origsource = false, bool rjson = false, bool similar = false, string source = null, string id = null)
        {
            if (postid == 0 && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() == "kinopub")
                    int.TryParse(id, out postid);
            }

            var init = await loadKit(AppInit.conf.KinoPub, (j, i, c) =>
            {
                if (j.ContainsKey("filetype"))
                    i.filetype = c.filetype;
                i.tokens = c.tokens;
                return i;
            });

            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxy = proxyManager.Get();

            string token = init.token;
            if (init.tokens != null && init.tokens.Length > 1)
                token = init.tokens[Random.Shared.Next(0, init.tokens.Length)];

            var oninvk = new KinoPubInvoke
            (
               host,
               init.corsHost(),
               token,
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl), httpHeaders(init)) : 
                                          Http.Get(init.cors(ongettourl), httpversion: 2, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init), cookieContainer: cookies),
               (stream, filepath) => HostStreamProxy(init, stream, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            if (postid == 0)
            {
                var search = await InvokeCache<SearchResult>($"kinopub:search:{title}:{year}:{clarification}:{imdb_id}:{kinopoisk_id}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    return await oninvk.Search(title, original_title, year, clarification, imdb_id, kinopoisk_id);
                });

                if (!search.IsSuccess)
                    return OnError(search.ErrorMsg);

                if (similar || search.Value.id == 0)
                {
                    if (search.Value.similars == null)
                        return OnError();

                    return ContentTo(rjson ? search.Value.similars.Value.ToJson() : search.Value.similars.Value.ToHtml());
                }

                postid = search.Value.id;
            }

            var cache = await InvokeCache<RootObject>($"kinopub:post:{postid}:{token}", cacheTime(10, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Post(postid);
            });

            return OnResult(cache, () => oninvk.Html(cache.Value, init.filetype, title, original_title, postid, s, t, codec, vast: init.vast, rjson: rjson), origsource: origsource, gbcache: !rch.enable);
        }


        [HttpGet]
        [Route("lite/kinopub/subtitles.json")]
        async public ValueTask<ActionResult> Subtitles(int mid)
        {
            var init = await loadKit(AppInit.conf.KinoPub, (j, i, c) =>
            {
                i.tokens = c.tokens;
                return i;
            });

            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxy = proxyManager.Get();

            string token = init.token;
            if (init.tokens != null && init.tokens.Length > 1)
                token = init.tokens[Random.Shared.Next(0, init.tokens.Length)];

            string uri = $"{init.corsHost()}/v1/items/media-links?mid={mid}&access_token={token}";

            var root = await InvokeCache($"kinopub:media-links:{mid}:{token}", cacheTime(20, init: init), 
                () => Http.Get<JObject>(uri, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init))
            );

            if (root == null || !root.ContainsKey("subtitles"))
            {
                proxyManager.Refresh();
                return ContentTo("[]");
            }

            var subs = root["subtitles"] as JArray;

            if (subs == null || subs.Count == 0)
                return ContentTo("[]");

            var tpl = new SubtitleTpl(subs.Count);

            foreach (var s in subs.OfType<JObject>())
            {
                try
                {
                    string lang = s.Value<string>("lang");
                    string url = s.Value<string>("url");

                    if (!string.IsNullOrEmpty(url))
                        tpl.Append(lang, HostStreamProxy(init, url, proxy: proxy));
                }
                catch { }
            }

            return ContentTo(tpl.ToJson());
        }
    }
}

```

## File: Online/Controllers/Redheadsound.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Redheadsound;

namespace Online.Controllers
{
    public class Redheadsound : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/redheadsound")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int year, int clarification, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.Redheadsound);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title) || year == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var oninvk = new RedheadsoundInvoke
            (
               host,
               init.corsHost(),
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl), httpHeaders(init)) : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               (url, data) => rch.enable ? rch.Post(init.cors(url), data, httpHeaders(init)) : Http.Post(init.cors(url), data, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            reset:
            var cache = await InvokeCache<EmbedModel>($"redheadsound:view:{title}:{year}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(title, year);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, title, vast: init.vast, rjson: rjson), origsource: origsource, gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/Mirage.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class Mirage : BaseOnlineController
    {
        ValueTask<AllohaSettings> Initialization()
        {
            return loadKit(AppInit.conf.Mirage, (j, i, c) =>
            {
                if (j.ContainsKey("m4s"))
                    i.m4s = c.m4s;
                return i;
            });
        }

        [HttpGet]
        [Route("lite/mirage")]
        async public ValueTask<ActionResult> Index(string orid, string imdb_id, long kinopoisk_id, string title, string original_title, int serial, string original_language, int year, int t = -1, int s = -1, bool origsource = false, bool rjson = false, bool similar = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: serial == 0 ? null : -1);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (similar)
                return await SpiderSearch(title, origsource, rjson);

            var result = await search(orid, imdb_id, kinopoisk_id, title, serial, original_language, year);
            if (result.category_id == 0 || result.data == null)
                return OnError();

            JToken data = result.data;
            string tokenMovie = data["token_movie"] != null ? data.Value<string>("token_movie") : null;
            var frame = await iframe(tokenMovie, init);
            if (frame.all == null)
                return OnError();

            //return ContentTo(JsonConvert.SerializeObject(frame.all));

            if (result.category_id is 1 or 3)
            {
                #region –§–∏–ª—å–º
                var videos = frame.all["theatrical"].ToObject<Dictionary<string, Dictionary<string, JObject>>>();

                var mtpl = new MovieTpl(title, original_title, videos.Count);

                foreach (var i in videos)
                {
                    var file = i.Value.First().Value;

                    string translation = file.Value<string>("translation");
                    string quality = file.Value<string>("quality");
                    long id = file.Value<long>("id");
                    bool uhd = init.m4s ? file.Value<bool>("uhd") : false;

                    string link = $"{host}/lite/mirage/video?id_file={id}&token_movie={data.Value<string>("token_movie")}";
                    string streamlink = accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true");

                    mtpl.Append(translation, link, "call", streamlink, voice_name: uhd ? "2160p" : quality, quality: uhd ? "2160p" : "");
                }

                return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                string defaultargs = $"&orid={orid}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&year={year}&original_language={original_language}";

                if (s == -1)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    string q = null;
                    try
                    {
                        if (init.m4s)
                            q = frame.active.Value<bool>("uhd") == true ? "2160p" : null;
                    }
                    catch { }

                    Dictionary<string, JToken> seasons;
                    if (frame.all["seasons"] != null)
                        seasons = frame.all["seasons"].ToObject<Dictionary<string, JToken>>();
                    else
                        seasons = frame.all.ToObject<Dictionary<string, JToken>>();

                    if (seasons.First().Key.StartsWith("t"))
                    {
                        var tpl = new SeasonTpl(q);

                        var seasonNumbers = new HashSet<int>();

                        foreach (var translation in seasons)
                        {
                            var file = translation.Value["file"];
                            if (file == null)
                                continue;

                            foreach (var season in file.ToObject<Dictionary<string, object>>())
                            {
                                if (int.TryParse(season.Key, out int seasonNumber))
                                    seasonNumbers.Add(seasonNumber);
                            }
                        }

                        if (!seasonNumbers.Any())
                            seasonNumbers.Add(frame.active.Value<int>("seasons"));

                        foreach (int i in seasonNumbers.OrderBy(i => i))
                            tpl.Append($"{i} —Å–µ–∑–æ–Ω", $"{host}/lite/mirage?rjson={rjson}&s={i}{defaultargs}", i.ToString());

                        return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                    }
                    else
                    {
                        var tpl = new SeasonTpl(q, seasons.Count);

                        foreach (var season in seasons)
                            tpl.Append($"{season.Key} —Å–µ–∑–æ–Ω", $"{host}/lite/mirage?rjson={rjson}&s={season.Key}{defaultargs}", season.Key);

                        return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                    }
                    #endregion
                }
                else
                {
                    var vtpl = new VoiceTpl();
                    var etpl = new EpisodeTpl();
                    var voices = new HashSet<int>();

                    string sArhc = s.ToString();

                    if (frame.all[sArhc] is JArray)
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        foreach (var episode in frame.all[sArhc])
                        {
                            foreach (var voice in episode.ToObject<Dictionary<string, JObject>>().Select(i => i.Value))
                            {
                                int id_translation = voice.Value<int>("id_translation");
                                if (voices.Contains(id_translation))
                                    continue;

                                voices.Add(id_translation);

                                if (t == -1)
                                    t = id_translation;

                                string link = $"{host}/lite/mirage?rjson={rjson}&s={s}&t={id_translation}{defaultargs}";
                                bool active = t == id_translation;

                                vtpl.Append(voice.Value<string>("translation"), active, link);
                            }
                        }
                        #endregion

                        foreach (var episode in frame.all[sArhc])
                        {
                            foreach (var voice in episode.ToObject<Dictionary<string, JObject>>().Select(i => i.Value))
                            {
                                if (voice.Value<int>("id_translation") != t)
                                    continue;

                                string translation = voice.Value<string>("translation");
                                int e = voice.Value<int>("episode");

                                string link = $"{host}/lite/mirage/video?id_file={voice.Value<long>("id")}&token_movie={data.Value<string>("token_movie")}";
                                string streamlink = accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true");

                                if (e > 0)
                                    etpl.Append($"{e} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, e.ToString(), link, "call", voice_name: translation, streamlink: streamlink);
                            }
                        }
                    }
                    else if (frame.all.ToObject<Dictionary<string, object>>().First().Key.StartsWith("t"))
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        foreach (var node in frame.all)
                        {
                            if (!node.First["file"].ToObject<Dictionary<string, object>>().ContainsKey(sArhc))
                                continue;

                            var voice = node.First["file"].First.First.First.First;
                            int id_translation = voice.Value<int>("id_translation");
                            if (voices.Contains(id_translation))
                                continue;

                            voices.Add(id_translation);

                            if (t == -1)
                                t = id_translation;

                            string link = $"{host}/lite/mirage?rjson={rjson}&s={s}&t={id_translation}{defaultargs}";
                            bool active = t == id_translation;

                            vtpl.Append(voice.Value<string>("translation"), active, link);
                        }
                        #endregion

                        foreach (var node in frame.all)
                        {
                            foreach (var season in node.First["file"].ToObject<Dictionary<string, object>>())
                            {
                                if (season.Key != sArhc)
                                    continue;

                                if (season.Value is JArray sjar)
                                {

                                }
                                else if (season.Value is JObject sjob)
                                {
                                    foreach (var episode in sjob.ToObject<Dictionary<string, JObject>>())
                                    {
                                        if (episode.Value.Value<int>("id_translation") != t)
                                            continue;

                                        string translation = episode.Value.Value<string>("translation");
                                        int e = episode.Value.Value<int>("episode");

                                        string link = $"{host}/lite/mirage/video?id_file={episode.Value.Value<long>("id")}&token_movie={data.Value<string>("token_movie")}";
                                        string streamlink = accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true");

                                        if (e > 0)
                                            etpl.Append($"{e} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, e.ToString(), link, "call", voice_name: translation, streamlink: streamlink);
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        foreach (var episode in frame.all[sArhc].ToObject<Dictionary<string, Dictionary<string, JObject>>>())
                        {
                            foreach (var voice in episode.Value.Select(i => i.Value))
                            {
                                int id_translation = voice.Value<int>("id_translation");
                                if (voices.Contains(id_translation))
                                    continue;

                                voices.Add(id_translation);

                                if (t == -1)
                                    t = id_translation;

                                string link = $"{host}/lite/mirage?rjson={rjson}&s={s}&t={id_translation}{defaultargs}";
                                bool active = t == id_translation;

                                vtpl.Append(voice.Value<string>("translation"), active, link);
                            }
                        }
                        #endregion

                        foreach (var episode in frame.all[sArhc].ToObject<Dictionary<string, Dictionary<string, JObject>>>())
                        {
                            foreach (var voice in episode.Value.Select(i => i.Value))
                            {
                                string translation = voice.Value<string>("translation");
                                if (voice.Value<int>("id_translation") != t)
                                    continue;

                                string link = $"{host}/lite/mirage/video?id_file={voice.Value<long>("id")}&token_movie={data.Value<string>("token_movie")}";
                                string streamlink = accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true");

                                etpl.Append($"{episode.Key} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.Key, link, "call", voice_name: translation, streamlink: streamlink);
                            }
                        }
                    }

                    if (rjson)
                        return ContentTo(etpl.ToJson(vtpl));

                    return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                }
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/mirage/video")]
        [Route("lite/mirage/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id_file, string token_movie, bool play)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string memKey = $"mirage:video:{id_file}:{init.m4s}";
            if (!hybridCache.TryGetValue(memKey, out (string hls, List<HeadersModel> headers) movie))
            {
                movie = await goMovie($"{init.linkhost}/?token_movie={token_movie}&token={init.token}", id_file, init);
                if (movie.hls == null)
                    return OnError();

                hybridCache.Set(memKey, movie, cacheTime(10));
            }

            var streamquality = new StreamQualityTpl();
            streamquality.Append(HostStreamProxy(init, movie.hls, headers: movie.headers), "auto");

            if (play)
                return Redirect(streamquality.Firts().link);

            return ContentTo(VideoTpl.ToJson("play", streamquality.Firts().link, "auto",
                streamquality: streamquality,
                vast: init.vast,
                headers: movie.headers,
                hls_manifest_timeout: (int)TimeSpan.FromSeconds(20).TotalMilliseconds
            ));
        }
        #endregion

        #region iframe
        async ValueTask<(JToken all, JToken active)> iframe(string token_movie, AllohaSettings init)
        {
            if (string.IsNullOrEmpty(token_movie))
                return default;

            string memKey = $"mirage:iframe:{token_movie}";
            if (!hybridCache.TryGetValue(memKey, out (JToken all, JToken active) cache))
            {
                string uri = $"{init.linkhost}/?token_movie={token_movie}&token={init.token}";
                string referer = $"https://lgfilm.fun/" + reffers[Random.Shared.Next(0, reffers.Length)];

                string html = await Http.Get(uri, httpversion: 2, timeoutSeconds: 8, headers: httpHeaders(init, HeadersModel.Init(
                    ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                    ("referer", referer),
                    ("sec-fetch-dest", "iframe"),
                    ("sec-fetch-mode", "navigate"),
                    ("sec-fetch-site", "cross-site"),
                    ("upgrade-insecure-requests", "1")
                )));

                string json = Regex.Match(html ?? "", "fileList = JSON.parse\\('([^\n\r]+)'\\);").Groups[1].Value;
                if (string.IsNullOrEmpty(json))
                    return default;

                try
                {
                    var root = JsonConvert.DeserializeObject<JObject>(json);
                    if (root == null || !root.ContainsKey("all"))
                        return default;

                    cache = (root["all"], root["active"]);

                    hybridCache.Set(memKey, cache, cacheTime(40));
                }
                catch { return default; }
            }

            return cache;
        }
        #endregion

        #region goMovie
        async Task<(string hls, List<HeadersModel> headers)> goMovie(string uri, long id_file, AllohaSettings init)
        {
            try
            {
                using (var browser = new PlaywrightBrowser())
                {
                    var page = await browser.NewPageAsync(init.plugin).ConfigureAwait(false);
                    if (page == null)
                        return default;

                    await page.RouteAsync("**/*", async route =>
                    {
                        try
                        {
                            if (route.Request.Url.Contains("lgfilm.fun"))
                            {
                                await route.FulfillAsync(new RouteFulfillOptions
                                {
                                    Body = PlaywrightBase.IframeHtml(uri)
                                });
                            }
                            else if (route.Request.Method == "POST" && route.Request.Url.Contains("/movies/"))
                            {
                                string newUrl = Regex.Replace(route.Request.Url, "/[0-9]+$", $"/{id_file}");

                                var fetchHeaders = route.Request.Headers;
                                fetchHeaders.TryAdd("accept-encoding", "gzip, deflate, br, zstd");
                                fetchHeaders.TryAdd("cache-control", "no-cache");
                                fetchHeaders.TryAdd("dnt", "1");
                                fetchHeaders.TryAdd("pragma", "no-cache");
                                fetchHeaders.TryAdd("priority", "u=1, i");
                                fetchHeaders.TryAdd("sec-fetch-dest", "empty");
                                fetchHeaders.TryAdd("sec-fetch-mode", "cors");
                                fetchHeaders.TryAdd("sec-fetch-site", "same-origin");
                                fetchHeaders.TryAdd("sec-fetch-storage-access", "active");

                                var fetchResponse = await route.FetchAsync(new RouteFetchOptions
                                {
                                    Url = newUrl,
                                    Method = "POST",
                                    Headers = fetchHeaders,
                                    PostData = route.Request.PostDataBuffer
                                }).ConfigureAwait(false);

                                string body = await fetchResponse.TextAsync().ConfigureAwait(false);

                                string targetStream = null;
                                if (init.m4s)
                                    targetStream = Regex.Match(body, "\"(2160|1440)\":\"([^\"]+)\"").Groups[2].Value;

                                if (string.IsNullOrWhiteSpace(targetStream))
                                    targetStream = Regex.Match(body, "\"(1080|720)\":\"([^\"]+)\"").Groups[2].Value;

                                if (!string.IsNullOrWhiteSpace(targetStream))
                                    body = Regex.Replace(body, "\"(2160|1440|1080|720|480|360)\":\"[^\"]+\"", $"\"$1\":\"{targetStream}\"");

                                await route.FulfillAsync(new RouteFulfillOptions
                                {
                                    Status = fetchResponse.Status,
                                    Body = body,
                                    Headers = fetchResponse.Headers
                                }).ConfigureAwait(false);
                            }
                            else
                            {
                                if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                    return;

                                await route.ContinueAsync();
                            }
                        }
                        catch { }
                    });

                    page.Response += Page_Response;

                    PlaywrightBase.GotoAsync(page, $"https://lgfilm.fun/" + reffers[Random.Shared.Next(0, reffers.Length)]);

                    try
                    {
                        return await tcsPageResponse.Task.WaitAsync(TimeSpan.FromSeconds(15));
                    }
                    catch { }
                    finally
                    {
                        page.Response -= Page_Response;
                    }
                }
            }
            catch { }

            return default;
        }

        TaskCompletionSource<(string hls, List<HeadersModel> headers)> tcsPageResponse = new TaskCompletionSource<(string hls, List<HeadersModel> headers)>();

        private void Page_Response(object sender, IResponse e)
        {
            if (e.Request.Method == "GET" && e.Url.Contains("/master.m3u8"))
            {
                var headers = HeadersModel.Init(Http.defaultFullHeaders,
                    ("sec-fetch-dest", "empty"),
                    ("sec-fetch-mode", "cors"),
                    ("sec-fetch-site", "cross-site")
                );

                foreach (var item in e.Request.Headers)
                {
                    if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                        continue;

                    if (!Http.defaultFullHeaders.ContainsKey(item.Key.ToLower()))
                        headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                }

                tcsPageResponse.SetResult((e.Url, headers));
            }
        }
        #endregion


        #region SpiderSearch
        [HttpGet]
        [Route("lite/mirage-search")]
        async public ValueTask<ActionResult> SpiderSearch(string title, bool origsource = false, bool rjson = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var cache = await InvokeCache<JArray>($"mirage:search:{title}", cacheTime(40, init: init), proxyManager, async res =>
            {
                var root = await Http.Get<JObject>($"{init.apihost}/?token={init.token}&name={HttpUtility.UrlEncode(title)}&list", timeoutSeconds: 8, proxy: proxyManager.Get());
                if (root == null || !root.ContainsKey("data"))
                    return res.Fail("data");

                return root["data"].ToObject<JArray>();
            });

            return OnResult(cache, () =>
            {
                var stpl = new SimilarTpl(cache.Value.Count);

                foreach (var j in cache.Value)
                {
                    string uri = $"{host}/lite/mirage?orid={j.Value<string>("token_movie")}";
                    stpl.Append(j.Value<string>("name") ?? j.Value<string>("original_name"), j.Value<int>("year").ToString(), string.Empty, uri, PosterApi.Size(j.Value<string>("poster")));
                }

                return rjson ? stpl.ToJson() : stpl.ToHtml();

            }, origsource: origsource);
        }
        #endregion

        #region search
        async ValueTask<(bool refresh_proxy, int category_id, JToken data)> search(string token_movie, string imdb_id, long kinopoisk_id, string title, int serial, string original_language, int year)
        {
            var init = await Initialization();
            string memKey = $"mirage:view:{kinopoisk_id}:{imdb_id}";
            if (0 >= kinopoisk_id && string.IsNullOrEmpty(imdb_id))
                memKey = $"mirage:viewsearch:{title}:{serial}:{original_language}:{year}";

            if (!string.IsNullOrEmpty(token_movie))
                memKey = $"mirage:view:{token_movie}";

            JObject root;

            if (!hybridCache.TryGetValue(memKey, out (int category_id, JToken data) res))
            {
                string stitle = title.ToLower();

                if (memKey.Contains(":viewsearch:"))
                {
                    if (string.IsNullOrWhiteSpace(title) || year == 0)
                        return default;

                    root = await Http.Get<JObject>($"{init.apihost}/?token={init.token}&name={HttpUtility.UrlEncode(title)}&list={(serial == 1 ? "serial" : "movie")}", timeoutSeconds: 8);
                    if (root == null)
                        return (true, 0, null);

                    if (root.ContainsKey("data"))
                    {
                        foreach (var item in root["data"])
                        {
                            if (item.Value<string>("name")?.ToLower()?.Trim() == stitle)
                            {
                                int y = item.Value<int>("year");
                                if (y > 0 && (y == year || y == (year - 1) || y == (year + 1)))
                                {
                                    if (original_language == "ru" && item.Value<string>("country")?.ToLower() != "—Ä–æ—Å—Å–∏—è")
                                        continue;

                                    res.data = item;
                                    res.category_id = item.Value<int>("category_id");
                                    break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    root = await Http.Get<JObject>($"{init.apihost}/?token={init.token}&kp={kinopoisk_id}&imdb={imdb_id}&token_movie={token_movie}", timeoutSeconds: 8);
                    if (root == null)
                        return (true, 0, null);

                    if (root.ContainsKey("data"))
                    {
                        res.data = root.GetValue("data");
                        res.category_id = res.data.Value<int>("category");
                    }
                }

                if (res.data != null || (root.ContainsKey("error_info") && root.Value<string>("error_info") == "not movie"))
                    hybridCache.Set(memKey, res, cacheTime(res.category_id is 1 or 3 ? 120 : 40, init: init));
                else
                    hybridCache.Set(memKey, res, cacheTime(2, init: init));
            }

            return (false, res.category_id, res.data);
        }
        #endregion


        static string[] reffers = new string[] { "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "1400-princessa-i-tajna-goblinov-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "408-legenda-o-chernom-dereve-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1221-magazin-svetilnikov-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1112-vspylchivyj-svjaschennik-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1239-forsazh-polnyj-vpered-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1230-chelovek-vnutri-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1214-moj-marchello-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1200-reinkarnacija-vozvraschenie-vedmy-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1185-ne-hochu-nichego-terjat-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1168-astral-koshmar-v-spring-garden-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1179-komandante-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1157-bolshoe-prikljuchenie-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "1143-kak-stat-korolem-2024.html", "944-pingvin-2024.html", "944-ping–≤–∏–Ω-2024.html" };
    }
}

```

## File: Online/Controllers/Jackett.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;

namespace Online.Controllers
{
    public class Jackett : BaseController
    {
        [HttpGet]
        [Route("lite/jac")]
        async public ValueTask<ActionResult> Index(string title, string original_title, string original_language, int year, int serial, int quality = -1)
        {
            if (!AppInit.conf.litejac)
                return Content(string.Empty);

            #region –ö–µ—à –∑–∞–ø—Ä–æ—Å–∞
            string localhost = $"http://{AppInit.conf.listen.localhost}:{AppInit.conf.listen.port}";

            string memkey = $"lite/jac:{title}:{original_title}:{year}";
            if (!hybridCache.TryGetValue(memkey, out JArray results, inmemory: false) || quality == -1)
            {
                var root = await Http.Get<JObject>($"{localhost}/api/v2.0/indexers/all/results?apikey={AppInit.conf.apikey}&title={HttpUtility.UrlEncode(title)}&title_original={HttpUtility.UrlEncode(original_title)}&year={year}&is_serial={(original_language == "ja" ? 5 : (serial + 1))}", timeoutSeconds: 11, headers: HeadersModel.Init("localrequest", AppInit.rootPasswd));
                if (root == null)
                    return Content(string.Empty, "text/html; charset=utf-8");

                results = root.GetValue("Results")?.ToObject<JArray>();
                if (results == null || results.Count == 0)
                    return Content(string.Empty, "text/html; charset=utf-8");

                hybridCache.Set(memkey, results, DateTime.Now.AddMinutes(5), inmemory: false);
            }
            #endregion

            bool firstjson = true;
            string html = string.Empty;

            #region –ú–µ–Ω—é –∫–∞—á–µ—Å—Ç–≤–∞
            HashSet<int> qualitys = new HashSet<int>();

            foreach (var item in results)
            {
                var info = item.Value<JObject>("Info");
                if (info != null)
                    qualitys.Add(info.Value<int>("quality"));
            }

            html = "<div class=\"videos__line\">";

            foreach (int q in qualitys.OrderByDescending(i => i))
            {
                string link = $"{host}/lite/jac?year={year}&serial={serial}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&quality={q}";

                string active = q == quality ? "active" : "";

                html += "<div class=\"videos__button selector " + active + "\" data-json='{\"method\":\"link\",\"url\":\"" + link + "\"}'>" + $"{q}p" + "</div>";
                firstjson = false;
            }

            firstjson = true;
            html += "</div>";
            #endregion

            foreach (var item in results)
            {
                int sid = item.Value<int>("Seeders"), pir = item.Value<int>("Peers"), q = 0;
                string magnet = item.Value<string>("MagnetUri");
                string tracker = item.Value<string>("Tracker");
                string sizeName = null;

                if (string.IsNullOrWhiteSpace(magnet))
                    magnet = item.Value<string>("Link").Replace(localhost, host);

                var info = item.Value<JObject>("Info");
                if (info != null)
                {
                    q = info.Value<int>("quality");
                    sizeName = info.Value<string>("sizeName");

                    if (quality != -1 && quality != q)
                        continue;
                }

                html += "<div class=\"videos__item videos__torrent selector " + (firstjson ? "focused" : "") + "\" media=\"\" data-json='{\"method\":\"torrent\",\"Link\":\"" + magnet + "\",\"title\":\"" + (title ?? original_title) + "\"}'><div class=\"videos__torrent-title\">" + item.Value<string>("Title") + $"</div><div class=\"videos__item-title\">–†–∞–∑–º–µ—Ä {sizeName} / –†–∞–∑–¥–∞—é—Ç {sid} / –ö–∞—á–∞—é—Ç {pir} / {q}p / {tracker}</div></div>";
                firstjson = false;
            }

            return Content(html, "text/html; charset=utf-8");
        }
    }
}

```

## File: Online/Controllers/Kinobase.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Shared.Models.Online.Kinobase;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class Kinobase : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/kinobase")]
        async public ValueTask<ActionResult> Index(string title, int year, int s = -1, int serial = -1, string href = null, string t = null, bool rjson = false, bool similar = false, string source = null, string id = null)
        {
            var init = await loadKit(AppInit.conf.Kinobase);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (string.IsNullOrEmpty(href) && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() == "kinobase")
                    href = id;
            }

            var proxyManager = new ProxyManager(AppInit.conf.Kinobase);
            var proxy = proxyManager.BaseGet();

            var oninvk = new KinobaseInvoke
            (
               host,
               init,
               ongettourl => 
               {
                   if (ongettourl.Contains("/search?query="))
                       return Http.Get(ongettourl, timeoutSeconds: 8, proxy: proxy.proxy, referer: init.host, httpversion: 2, headers: httpHeaders(init));

                   return black_magic(ongettourl, init, proxy.data);
               },
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy.proxy),
               requesterror: () => proxyManager.Refresh()
            );

            #region search
            if (string.IsNullOrEmpty(href))
            {
                var search = await InvokeCache<SearchModel>($"kinobase:search:{title}:{year}", cacheTime(40, init: init), proxyManager, async res =>
                {
                    var content = await oninvk.Search(title, year);
                    if (content == null)
                        return res.Fail("search");

                    return content;
                });

                if (similar || string.IsNullOrEmpty(search.Value?.link))
                    return OnResult(search, () => rjson ? search.Value.similar.Value.ToJson() : search.Value.similar.Value.ToHtml());

                if (string.IsNullOrEmpty(search.Value?.link))
                    return OnError();

                href = search.Value?.link;
            }
            #endregion

            var cache = await InvokeCache<EmbedModel>($"kinobase:view:{href}:{proxyManager.CurrentProxyIp}", cacheTime(20, init: init), proxyManager, async res =>
            {
                var content = await oninvk.Embed(href, init.playerjs);
                if (content == null)
                    return res.Fail("embed");

                return content;
            });

            return OnResult(cache, () => 
            {
                if (cache.Value.IsEmpty)
                    return ShowErrorString(cache.Value.errormsg);

                return oninvk.Html(cache.Value, title, href, s, t, rjson);
            });
        }



        #region black_magic
        async ValueTask<string> black_magic(string uri, KinobaseSettings init, (string ip, string username, string password) proxy)
        {
            try
            {
                using (var browser = new PlaywrightBrowser())
                {
                    var page = await browser.NewPageAsync(init.plugin, proxy: proxy, headers: init.headers).ConfigureAwait(false);
                    if (page == null)
                        return null;

                    await page.Context.AddCookiesAsync(new List<Cookie>()
                    {
                        new Cookie()
                        {
                            Name = "player_settings",
                            Value = $"{(init.playerjs ? "new" : "old")}|{(init.hls ? "hls" : "mp4")}|{(init.hdr ? 1 : 0)}",
                            Domain = Regex.Match(init.host, "^https?://([^/]+)").Groups[1].Value,
                            Path = "/",
                            Expires = 2220002226
                        }
                    }).ConfigureAwait(false);

                    await page.RouteAsync("**/*", async route =>
                    {
                        try
                        {
                            if (route.Request.Url.Contains("/playerjs.js"))
                            {
                                await route.FulfillAsync(new RouteFulfillOptions
                                {
                                    Body = System.IO.File.ReadAllText("data/kinobase_playerjs.js")
                                });

                                return;
                            }
                            else if (route.Request.Url.Contains("/uppod.js"))
                            {
                                await route.FulfillAsync(new RouteFulfillOptions
                                {
                                    Body = System.IO.File.ReadAllText("data/kinobase_uppod.js")
                                });

                                return;
                            }

                            if (!route.Request.Url.Contains(init.host) || route.Request.Url.Contains("/comments"))
                            {
                                await route.AbortAsync();
                                return;
                            }

                            if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, patterCache: "/js/(jquery|boot)\\.js"))
                                return;

                            await route.ContinueAsync();
                        }
                        catch { }
                    });

                    PlaywrightBase.GotoAsync(page, uri);
                    await browser.WaitForAnySelectorAsync(page, "#playerjsfile", ".uppod-media", ".alert").ConfigureAwait(false);

                    string content = await page.ContentAsync().ConfigureAwait(false);

                    PlaywrightBase.WebLog("GET", uri, content, proxy);
                    return content;
                }
            }
            catch { return null; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/VeoVeo.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;
using Shared.Models.Online.VeoVeo;
using System.Net;

namespace Online.Controllers
{
    public class VeoVeo : BaseOnlineController
    {
        #region database
        static List<Movie> databaseCache;

        static IEnumerable<Movie> database
        {
            get
            {
                if (AppInit.conf.multiaccess || databaseCache != null)
                    return databaseCache ??= JsonHelper.ListReader<Movie>("data/veoveo.json", 45000);

                return JsonHelper.IEnumerableReader<Movie>("data/veoveo.json");
            }
        }
        #endregion

        [HttpGet]
        [Route("lite/veoveo")]
        async public ValueTask<ActionResult> Index(long movieid, string imdb_id, long kinopoisk_id, string title, string original_title, int clarification, int s = -1, bool rjson = false, bool origsource = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.VeoVeo);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            if (movieid == 0)
            {
                if (similar)
                    return Spider(title);

                var movie = search(init, proxyManager, proxy, imdb_id, kinopoisk_id, title, original_title);
                if (movie == null)
                    return Spider(clarification == 1 ? title : (original_title ?? title));

                movieid = movie.Value.id;
            }

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            #region media
            var cache = await InvokeCache<JArray>($"{init.plugin}:view:{movieid}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string uri = $"{init.host}/balancer-api/proxy/playlists/catalog-api/episodes?content-id={movieid}";
                
                var root = rch.enable 
                    ? await rch.Get<JArray>(init.cors(uri), httpHeaders(init))
                    : await Http.Get<JArray>(init.cors(uri), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));

                if (root == null || root.Count == 0)
                    return res.Fail("data");

                return root;
            });
            #endregion

            return OnResult(cache, () =>
            {
                if (cache.Value.First["season"].Value<int>("order") == 0)
                {
                    #region –§–∏–ª—å–º
                    var mtpl = new MovieTpl(title, original_title, 1);

                    string file = cache.Value.First["episodeVariants"]
                        .OrderByDescending(i => i.Value<string>("filepath").Contains(".m3u8"))
                        .First()
                        .Value<string>("filepath");

                    string stream = HostStreamProxy(init, file, proxy: proxy);

                    mtpl.Append("1080p", stream, vast: init.vast);

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∞–ª
                    if (s == -1)
                    {
                        var tpl = new SeasonTpl();
                        var hash = new HashSet<int>();

                        foreach (var item in cache.Value)
                        {
                            var season = item["season"].Value<int>("order");
                            if (hash.Contains(season))
                                continue;

                            hash.Add(season);
                            string link = $"{host}/lite/veoveo?rjson={rjson}&kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&s={season}";
                            tpl.Append($"{season} —Å–µ–∑–æ–Ω", link, season);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        var episodes = cache.Value.Where(i => i["season"].Value<int>("order") == s);

                        var etpl = new EpisodeTpl(episodes.Count());
                        string sArhc = s.ToString();

                        foreach (var episode in episodes.OrderBy(i => i.Value<int>("order")))
                        {
                            string name = episode.Value<string>("title");

                            string file = episode["episodeVariants"]
                                .OrderByDescending(i => i.Value<string>("filepath").Contains(".m3u8"))
                                .First()
                                .Value<string>("filepath");

                            if (string.IsNullOrEmpty(file))
                                continue;

                            string stream = HostStreamProxy(init, file, proxy: proxy);
                            etpl.Append(name ?? $"{episode.Value<int>("order")} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.Value<int>("order").ToString(), stream, vast: init.vast);
                        }

                        return rjson ? etpl.ToJson() : etpl.ToHtml();
                    }
                    #endregion
                }

            }, origsource: origsource);
        }

        #region Spider
        [HttpGet]
        [Route("lite/veoveo-spider")]
        public ActionResult Spider(string title)
        {
            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var stpl = new SimilarTpl(100);
            string _t = StringConvert.SearchName(title);
            if (string.IsNullOrEmpty(_t))
                return OnError();

            foreach (var m in database)
            {
                if (stpl.data.Count >= 100)
                    break;

                if (StringConvert.SearchName(m.title, string.Empty).Contains(_t) || StringConvert.SearchName(m.originalTitle, string.Empty).Contains(_t))
                {
                    string uri = $"{host}/lite/veoveo?movieid={m.id}";
                    stpl.Append(m.title ?? m.originalTitle, m.year.ToString(), string.Empty, uri, PosterApi.Find(m.kinopoiskId, m.imdbId));
                }
            }

            return ContentTo(stpl.ToJson());
        }
        #endregion

        #region search
        Movie? search(OnlinesSettings init, ProxyManager proxyManager, WebProxy proxy, string imdb_id, long kinopoisk_id, string title, string original_title)
        {
            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            Movie? goSearch(bool searchToId)
            {
                if (searchToId && kinopoisk_id == 0 && string.IsNullOrEmpty(imdb_id))
                    return null;

                foreach (var item in database)
                {
                    if (searchToId)
                    {
                        if (kinopoisk_id > 0)
                        {
                            if (item.kinopoiskId == kinopoisk_id)
                                return item;
                        }

                        if (!string.IsNullOrEmpty(imdb_id))
                        {
                            if (item.imdbId == imdb_id)
                                return item;
                        }
                    }
                    else
                    {
                        if (sorigtitle != null)
                        {
                            if (StringConvert.SearchName(item.originalTitle) == sorigtitle)
                                return item;
                        }

                        if (stitle != null)
                        {
                            if (StringConvert.SearchName(item.title) == stitle)
                                return item;
                        }
                    }
                }

                return null;
            }

            return goSearch(true) ?? goSearch(false);
        }
        #endregion
    }
}

```

## File: Online/Controllers/PiTor.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.PiTor;
using Shared.Models.Online.Settings;
using System.Data;

namespace Online.Controllers
{
    public class PiTor : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/pidtor")]
        async public ValueTask<ActionResult> Index(string account_email, string title, string original_title, int year, string original_language, int serial, int s = -1, bool rjson = false)
        {
            var init = AppInit.conf.PidTor;
            if (!init.enable)
                return OnError();

            if (NoAccessGroup(init, out string error_msg))
                return ShowError(error_msg);

            string memKey = $"pidtor:{title}:{original_title}:{year}";

            return await InvkSemaphore(null, memKey, async () =>
            {
                #region –ö–µ—à –∑–∞–ø—Ä–æ—Å–∞
                if (!hybridCache.TryGetValue(memKey, out List<(string name, string voice, string magnet, int sid, string tr, string quality, long size, string mediainfo, Result torrent)> torrents))
                {
                    var root = await Http.Get<RootObject>($"{init.redapi}/api/v2.0/indexers/all/results?title={HttpUtility.UrlEncode(title)}&title_original={HttpUtility.UrlEncode(original_title)}&year={year}&is_serial={(original_language == "ja" ? 5 : (serial + 1))}&apikey={init.apikey}", timeoutSeconds: 8);
                    if (root == null)
                        return Content(string.Empty, "text/html; charset=utf-8");

                    torrents = new List<(string name, string voice, string magnet, int sid, string tr, string quality, long size, string mediainfo, Result torrent)>();
                    var results = root?.Results;
                    if (results != null && results.Length > 0)
                    {
                        foreach (var torrent in results)
                        {
                            string magnet = torrent.MagnetUri;
                            string name = torrent.Title;

                            if (string.IsNullOrEmpty(magnet) || string.IsNullOrEmpty(name))
                                continue;

                            string tracker = torrent.Tracker;
                            if (tracker == "selezen")
                                continue;

                            if (init.max_serial_size > 0 && init.max_size > 0)
                            {
                                if (serial == 1)
                                {
                                    if (torrent.Size > init.max_serial_size)
                                        continue;
                                }
                                else
                                {
                                    if (torrent.Size > init.max_size)
                                        continue;
                                }
                            }
                            else
                            {
                                if (init.max_size > 0 && torrent.Size > init.max_size)
                                    continue;
                            }

                            if (init.forceAll || Regex.IsMatch(name.ToLower(), "(4k|uhd)( |\\]|,|$)") || name.Contains("2160p") || name.Contains("1080p") || name.Contains("720p"))
                            {
                                int sid = torrent.Seeders;
                                long? size = torrent.Size;

                                if (sid >= init.min_sid)
                                {
                                    string mediainfo = torrent.info.sizeName ?? string.Empty;
                                    if (!string.IsNullOrEmpty(mediainfo))
                                        mediainfo += " / ";

                                    #region –ü–µ—Ä–µ–≤–æ–¥
                                    string voicename = string.Empty;

                                    var voices = torrent.info.voices;
                                    if (voices != null && voices.Length > 0)
                                        voicename = string.Join(", ", voices);
                                    #endregion

                                    #region –ü–µ—Ä–µ–≤–æ–¥ 2
                                    if (string.IsNullOrWhiteSpace(voicename))
                                    {
                                        if (Regex.IsMatch(name.ToLower(), "( –¥–±| d|–¥—É–±–ª—è–∂)", RegexOptions.IgnoreCase))
                                            voicename += "–î—É–±–ª—è–∂, ";

                                        if (Regex.IsMatch(name.ToLower(), "( —Å—Ç| –ø–º)", RegexOptions.IgnoreCase))
                                            voicename += "–ú–Ω–æ–≥–æ–≥–æ–ª–æ—Å—ã–π, ";

                                        if (torrent.Tracker.ToLower() == "lostfilm")
                                        {
                                            voicename += "LostFilm, ";
                                        }
                                        else if (torrent.Tracker.ToLower() == "toloka")
                                        {
                                            voicename += "–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π, ";
                                        }
                                        else
                                        {
                                            var allVoices = new HashSet<string>
                                            {
                                                "Movie Dubbing", "Bravo Records", "Ozz", "Laci", "Kerob", "LE-Production",  "Parovoz Production", "Paradox", "Omskbird", "LostFilm", "–ü—Ä–∏—á—É–¥–∏–∫–∏", "BaibaKo", "NewStudio", "AlexFilm", "FocusStudio", "Gears Media", "Jaskier", "ViruseProject",
                                                "–ö—É–±–∏–∫ –≤ –ö—É–±–µ", "IdeaFilm", "Sunshine Studio", "Ozz.tv", "Hamster Studio", "–°–µ—Ä–±–∏–Ω", "To4ka", "–ö—Ä–∞–≤–µ—Ü", "Victory-Films", "SNK-TV", "GladiolusTV", "Jetvis Studio", "ApofysTeam", "ColdFilm",
                                                "Agatha Studdio", "KinoView", "Jimmy J.", "Shadow Dub Project", "Amedia", "Red Media", "Selena International", "–ì–æ–±–ª–∏–Ω", "Universal Russia", "Kiitos", "Paramount Comedy", "–ö—É—Ä–∞–∂-–ë–∞–º–±–µ–π",
                                                "–°—Ç—É–¥–∏—è –ü–∏—Ä–∞—Ç—Å–∫–æ–≥–æ –î—É–±–ª—è–∂–∞", "–ß–∞–¥–æ–≤", "–ö–∞—Ä–ø–æ–≤—Å–∫–∏–π", "RecentFilms", "–ü–µ—Ä–≤—ã–π –∫–∞–Ω–∞–ª", "Alternative Production", "NEON Studio", "–ö–æ–ª–æ–±–æ–∫", "–î–æ–ª—å—Å–∫–∏–π", "–°–∏–Ω–µ–º–∞ –£–°", "–ì–∞–≤—Ä–∏–ª–æ–≤", "–ñ–∏–≤–æ–≤", "SDI Media",
                                                "–ê–ª–µ–∫—Å–µ–µ–≤", "Green–†–∞–π Studio", "–ú–∏—Ö–∞–ª–µ–≤", "–ï—Å–∞—Ä–µ–≤", "–í–∏–∑–≥—É–Ω–æ–≤", "–õ–∏–±–µ—Ä–≥–∞–ª", "–ö—É–∑–Ω–µ—Ü–æ–≤", "–°–∞–Ω–∞–µ–≤", "–î–¢–í", "–î–æ—Ö–∞–ª–æ–≤", "Sunshine Studio", "–ì–æ—Ä—á–∞–∫–æ–≤", "LevshaFilm", "CasStudio", "–í–æ–ª–æ–¥–∞—Ä—Å–∫–∏–π",
                                                "ColdFilm", "–®–≤–∞—Ä–∫–æ", "–ö–∞—Ä—Ü–µ–≤", "ETV+", "–í–ì–¢–†–ö", "Gravi-TV", "1001cinema", "Zone Vision Studio", "–•–∏—Ö–∏–∫–∞—é—â–∏–π –¥–æ–∫—Ç–æ—Ä", "Murzilka", "turok1990", "FOX", "STEPonee", "Elrom", "–ö–æ–ª–æ–±–æ–∫", "HighHopes",
                                                "SoftBox", "Green–†–∞–π Studio", "NovaFilm", "–ß–µ—Ç—ã—Ä–µ –≤ –∫–≤–∞–¥—Ä–∞—Ç–µ", "Greb&Creative", "MUZOBOZ", "ZM-Show", "RecentFilms", "Kerems13", "Hamster Studio", "New Dream Media", "–ò–≥–º–∞—Ä", "–ö–æ—Ç–æ–≤", "DeadLine Studio",
                                                "Jetvis Studio", "–†–µ–Ω–¢–í", "–ê–Ω–¥—Ä–µ–π –ü–∏—Ç–µ—Ä—Å–∫–∏–π", "Fox Life", "–†—ã–±–∏–Ω", "Trdlo.studio", "Studio Victory –êsia", "Ozeon", "–ù–¢–í", "CP Digital", "AniLibria", "STEPonee", "Levelin", "FanStudio", "Cmert",
                                                "–ò–Ω—Ç–µ—Ä—Ñ–∏–ª—å–º", "SunshineStudio", "Kulzvuk Studio", "–ö–∞—à–∫–∏–Ω", "–í–∞—Ä—Ç–∞–Ω –î–æ—Ö–∞–ª–æ–≤", "–ù–µ–º–∞—Ö–æ–≤", "Sedorelli", "–°–¢–°", "–Ø—Ä–æ—Ü–∫–∏–π", "ICG", "–¢–í–¶", "–®—Ç–µ–π–Ω", "AzOnFilm", "SorzTeam", "–ì–∞–µ–≤—Å–∫–∏–π", "–ú—É–¥—Ä–æ–≤",
                                                "–í–æ—Ä–æ–±—å–µ–≤ –°–µ—Ä–≥–µ–π", "–°—Ç—É–¥–∏—è –†–∞–π–¥–æ", "DeeAFilm Studio", "zamez", "ViruseProject", "–ò–≤–∞–Ω–æ–≤", "STEPonee", "–†–µ–Ω–¢–í", "–°–í-–î—É–±–ª—å", "BadBajo", "–ö–æ–º–µ–¥–∏—è –¢–í", "–ú–∞—Å—Ç–µ—Ä –¢—ç–π–ø", "5-–π –∫–∞–Ω–∞–ª –°–ü–±", "SDI Media",
                                                "–ì–ª–∞–Ω—Ü", "–û—Ö! –°—Ç—É–¥–∏—è", "–°–í-–ö–∞–¥—Ä", "2x2", "–ö–æ—Ç–æ–≤–∞", "–ü–æ–∑–∏—Ç–∏–≤", "RusFilm", "–ù–∞–∑–∞—Ä–æ–≤", "XDUB Dorama", "–†–µ–∞–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥", "Kansai", "Sound-Group", "–ù–∏–∫–æ–ª–∞–π –î—Ä–æ–∑–¥–æ–≤", "ZEE TV", "Ozz.tv", "MTV",
                                                "–°—ã–µ–Ω–¥—É–∫", "GoldTeam", "–ë–µ–ª–æ–≤", "Dream Records", "–Ø–∫–æ–≤–ª–µ–≤", "Vano", "SilverSnow", "Lord32x", "Filiza Studio", "Sony Sci-Fi", "Flux-Team", "NewStation", "XDUB Dorama", "Hamster Studio", "Dream Records",
                                                "DexterTV", "ColdFilm", "Good People", "RusFilm", "Levelin", "AniDUB", "SHIZA Project", "AniLibria.TV", "StudioBand", "AniMedia", "Kansai", "Onibaku", "JWA Project", "MC Entertainment", "Oni", "Jade",
                                                "Ancord", "ANIvoice", "Nika Lenina", "Bars MacAdams", "JAM", "Anika", "Berial", "Kobayashi", "Cuba77", "RiZZ_fisher", "OSLIKt", "Lupin", "Ryc99", "Nazel & Freya", "Trina_D", "JeFerSon", "Vulpes Vulpes",
                                                "Hamster", "KinoGolos", "Fox Crime", "–î–µ–Ω–∏—Å –®–∞–¥–∏–Ω—Å–∫–∏–π", "AniFilm", "Rain Death", "LostFilm", "New Records", "Ancord", "–ü–µ—Ä–≤—ã–π –¢–í–ß", "RG.Paravozik", "Profix Media", "Tycoon", "RealFake",
                                                "HDrezka", "Jimmy J.", "AlexFilm", "Discovery", "Viasat History", "AniMedia", "JAM", "HiWayGrope", "Ancord", "–°–í-–î—É–±–ª—å", "Tycoon", "SHIZA Project", "GREEN TEA", "STEPonee", "AlphaProject",
                                                "AnimeReactor", "Animegroup", "Shachiburi", "Persona99", "3df voice", "CactusTeam", "AniMaunt", "AniMedia", "AnimeReactor", "ShinkaDan", "Jaskier", "ShowJet", "RAIM", "RusFilm", "Victory-Films",
                                                "–ê—Ä—Ö–∏–¢–µ–∞—Ç—Ä", "Project Web Mania", "ko136", "–ö—É—Ä–∞–°–≥—Ä–µ—á–µ–π", "AMS", "–°–í-–°—Ç—É–¥–∏—è", "–•—Ä–∞–º –î–æ—Ä–∞–º –¢–í", "TurkStar", "–ú–µ–¥–≤–µ–¥–µ–≤", "–†—è–±–æ–≤", "BukeDub", "FilmGate", "FilmsClub", "Sony Turbo", "–¢–í–¶", "AXN Sci-Fi",
                                                "NovaFilm", "DIVA Universal", "–ö—É—Ä–¥–æ–≤", "–ù–µ–æ–∫–ª–∞—Å—Å–∏–∫–∞", "fiendover", "SomeWax", "–õ–æ–≥–∏–Ω–æ—Ñ—Ñ", "Cartoon Network", "Sony Turbo", "Loginoff", "CrezaStudio", "–í–æ—Ä–æ—Ç–∏–ª–∏–Ω", "LakeFilms", "Andy", "CP Digital",
                                                "XDUB Dorama + –ö–æ–ª–æ–±–æ–∫", "SDI Media", "KosharaSerials", "–ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥ –ê—Ä—Ç", "Julia Prosenuk", "–ê–†–ö-–¢–í Studio", "–¢.–û –î—Ä—É–∑–µ–π", "Anifilm", "Animedub", "AlphaProject", "Paramount Channel", "–ö–∏—Ä–∏–ª–ª–∏—Ü–∞",
                                                "AniPLague", "–í–∏–¥–µ–æ—Å–µ—Ä–≤–∏—Å", "JoyStudio", "HighHopes", "TVShows", "AniFilm", "GostFilm", "West Video", "–§–æ—Ä–º–∞—Ç AB", "Film Prestige", "West Video", "–ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥ –ê—Ä—Ç", "SovetRomantica", "–†—É–§–∏–ª–º—Å",
                                                "AveBrasil", "Greb&Creative", "BTI Studios", "–ü–∏—Ñ–∞–≥–æ—Ä", "Eurochannel", "NewStudio", "–ö–∞—Ä–º–µ–Ω –í–∏–¥–µ–æ", "–ö–æ—à–∫–∏–Ω", "–ö—Ä–∞–≤–µ—Ü", "Rainbow World", "–í–æ—Ä–æ—Ç–∏–ª–∏–Ω", "–í–∞—Ä—É—Å-–í–∏–¥–µ–æ", "ClubFATE", "HiWay Grope",
                                                "Banyan Studio", "Mallorn Studio", "Asian Miracle Group", "–≠–π –ë–∏ –í–∏–¥–µ–æ", "AniStar", "Korean Craze", "LakeFilms", "–ù–µ–≤–∞—Ñ–∏–ª—å–º", "Hallmark", "Netflix", "Mallorn Studio", "Sony Channel", "East Dream",
                                                "Bonsai Studio", "Lucky Production", "Octopus", "TUMBLER Studio", "CrazyCatStudio", "Amber", "Train Studio", "–ê–Ω–∞—Å—Ç–∞—Å–∏—è –ì–∞–π–¥–∞—Ä–∂–∏", "–ú–∞–¥–ª–µ–Ω –î—é–≤–∞–ª—å", "Fox Life", "Sound Film", "Cowabunga Studio", "–§–∏–ª—å–º—ç–∫—Å–ø–æ—Ä—Ç",
                                                "VO-Production", "Sound Film", "Nickelodeon", "MixFilm", "Green–†–∞–π Studio", "Sound-Group", "Back Board Cinema", "–ö–∏—Ä–∏–ª–ª –°–∞–≥–∞—á", "Bonsai Studio", "Stevie", "OnisFilms", "MaxMeister", "Syfy Universal",
                                                "TUMBLER Studio", "NewStation", "Neo-Sound", "–ú—É—Ä–∞–≤—Å–∫–∏–π", "IdeaFilm", "–†—É—Ç–∏–ª–æ–≤", "–¢–∏–º–æ—Ñ–µ–µ–≤", "–õ–∞–≥—É—Ç–∞", "–î—å—è–∫–æ–Ω–æ–≤", "Zone Vision Studio", "Onibaku", "AniMaunt", "Voice Project", "AniStar", "–ü–∏—Ñ–∞–≥–æ—Ä",
                                                "VoicePower", "StudioFilms", "Elysium", "AniStar", "BeniAffet", "Selena International", "Paul Bunyan", "CoralMedia", "–ö–æ–Ω–¥–æ—Ä", "–ò–≥–º–∞—Ä", "ViP Premiere", "FireDub", "AveTurk", "Sony Sci-Fi", "–Ø–Ω–∫–µ–ª–µ–≤–∏—á",
                                                "–ö–∏—Ä–µ–µ–≤", "–ë–∞–≥–∏—á–µ–≤", "2x2", "–õ–µ–∫—Å–∏–∫–æ–Ω", "–ù–æ—Ç–∞", "Arisu", "Superbit", "AveDorama", "VideoBIZ", "–ö–∏–Ω–æ–º–∞–Ω–∏—è", "DDV", "Alternative Production", "WestFilm", "–ê–Ω–∞—Å—Ç–∞—Å–∏—è –ì–∞–π–¥–∞—Ä–∂–∏ + –ê–Ω–¥—Ä–µ–π –Æ—Ä—á–µ–Ω–∫–æ", "–ö–∏–Ω–æ–º–∞–Ω–∏—è",
                                                "Agatha Studdio", "Green–†–∞–π Studio", "VSI Moscow", "Horizon Studio", "Flarrow Films", "Amazing Dubbing", "Asian Miracle Group", "–í–∏–¥–µ–æ–ø—Ä–æ–¥–∞–∫—à–Ω", "VGM Studio", "FocusX", "CBS Drama", "NovaFilm", "Novamedia",
                                                "East Dream", "–î–∞—Å–µ–≤–∏—á", "–ê–Ω–∞—Ç–æ–ª–∏–π –ì—É—Å–µ–≤", "Twister", "–ú–æ—Ä–æ–∑–æ–≤", "NewComers", "kubik&ko", "DeMon", "–ê–Ω–∞—Ç–æ–ª–∏–π –ê—à–º–∞—Ä–∏–Ω", "Inter Video", "–ü—Ä–æ–Ω–∏–Ω", "AMC", "–í–µ–ª–µ—Å", "Volume-6 Studio", "–•–æ—Ä—Ä–æ—Ä –ú—ç–π–∫–µ—Ä",
                                                "Ghostface", "Sephiroth", "–ê–∫–∏—Ä–∞", "–î–µ–≤–∞–ª—å –í–∏–¥–µ–æ", "RussianGuy27", "neko64", "Shaman", "Franek Monk", "–í–æ—Ä–æ–Ω", "Andre1288", "Selena International", "GalVid", "–î—Ä—É–≥–æ–µ –∫–∏–Ω–æ", "–°—Ç—É–¥–∏—è NLS", "Sam2007",
                                                "HaseRiLLoPaW", "–°–µ–≤–∞—Å—Ç—å—è–Ω–æ–≤", "D.I.M.", "–ú–∞—Ä—á–µ–Ω–∫–æ", "–ñ—É—Ä–∞–≤–ª–µ–≤", "–ù-–ö–∏–Ω–æ", "Lazer Video", "SesDizi", "Red Media", "–†—É–¥–æ–π", "–¢–æ–≤–±–∏–Ω", "–°–µ—Ä–≥–µ–π –î–∏–¥–æ–∫", "–•—É–∞–Ω –†–æ—Ö–∞—Å", "binjak", "–ö–∞—Ä—É—Å–µ–ª—å", "Lizard Cinema",
                                                "–í–∞—Ä—É—Å-–í–∏–¥–µ–æ", "–ê–∫—Ü–µ–Ω—Ç", "RG.Paravozik", "Max Nabokov", "Barin101", "–í–∞—Å—å–∫–∞ –ö—É—Ä–æ–ª–µ—Å–æ–≤", "–§–æ—Ä—Ç—É–Ω–∞-–§–∏–ª—å–º", "Amalgama", "AnyFilm", "–°—Ç—É–¥–∏—è –†–∞–π–¥–æ", "–ö–æ–∑–ª–æ–≤", "Zoomvision Studio", "–ü–∏—Ñ–∞–≥–æ—Ä", "Urasiko",
                                                "VIP Serial HD", "–ù–°–¢", "–ö–∏–Ω–æ–ª—é–∫—Å", "Project Web Mania", "–ó–∞–≤–≥–æ—Ä–æ–¥–Ω–∏–π", "AB-Video", "Twister", "Universal Channel", "Wakanim", "SnowRecords", "–°.–†.–ò", "–°—Ç–∞—Ä—ã–π –ë–∏–ª—å–±–æ", "Ozz.tv", "Mystery Film", "–†–µ–Ω–¢–í",
                                                "–õ–∞—Ç—ã—à–µ–≤", "–í–∞—â–µ–Ω–∫–æ", "–õ–∞–π–∫–æ", "–°–æ–Ω–æ—Ç–µ–∫", "Psychotronic", "DIVA Universal", "Gremlin Creative Studio", "–ù–µ–≤–∞-1", "–ú–∞–∫—Å–∏–º –ñ–æ–ª–æ–±–æ–≤", "Good People", "–ú–æ–±–∏–ª—å–Ω–æ–µ —Ç–µ–ª–µ–≤–∏–¥–µ–Ω–∏–µ", "Lazer Video",
                                                "IVI", "DoubleRec", "Milvus", "RedDiamond Studio", "Astana TV", "–ù–∏–∫–∏—Ç–∏–Ω", "–ö–¢–ö", "D2Lab", "–ù–°–¢", "DoubleRec", "Black Street Records", "–û—Å—Ç–∞–Ω–∫–∏–Ω–æ", "TatamiFilm", "–í–∏–¥–µ–æ–±–∞–∑–∞", "Crunchyroll", "Novamedia",
                                                "RedRussian1337", "–ö–æ–Ω—Ç–µ–Ω—Ç–∏–∫OFF", "Creative Sound", "HelloMickey Production", "–ü–∏—Ä–∞–º–∏–¥–∞", "CLS Media", "–°–æ–Ω—å–∫–∏–Ω", "–ú–∞—Å—Ç–µ—Ä –¢—ç–π–ø", "Garsu Pasaulis", "DDV", "IdeaFilm", "Gold Cinema", "–ß–µ!", "–ù–∞—Ä—ã—à–∫–∏–Ω",
                                                "Intra Communications", "OnisFilms", "XDUB Dorama", "–ö–∏–ø–∞—Ä–∏—Å", "–ö–æ—Ä–æ–ª—ë–≤", "visanti-vasaer", "–ì–æ—Ç–ª–∏–±", "Paramount Channel", "–°–¢–°", "–¥–∏–∫—Ç–æ—Ä CDV", "Pazl Voice", "–ü—Ä—è–º–æ—Å—Ç–∞–Ω–æ–≤", "Zerzia", "–ù–¢–í", "MGM",
                                                "–î—å—è–∫–æ–≤", "–í–æ–ª—å–≥–∞", "–ê–†–ö-–¢–í Studio", "–î—É–±—Ä–æ–≤–∏–Ω", "–ú–ò–†", "Netflix", "Jetix", "–ö–∏–ø–∞—Ä–∏—Å", "RUSCICO", "Seoul Bay", "–§–∏–ª–æ–Ω–æ–≤", "–ú–∞—Ö–æ–Ω—å–∫–æ", "–°—Ç—Ä–æ–µ–≤", "–°–∞–Ω—è –ë–µ–ª—ã–π", "–ì–æ–≤–∏–Ω–¥–∞ –†–∞–≥–∞", "–û—à—É—Ä–∫–æ–≤", "Horror Maker",
                                                "–•–ª–æ–ø—É—à–∫–∞", "–•—Ä—É—Å—Ç–∞–ª–µ–≤", "–ê–Ω—Ç–æ–Ω–æ–≤ –ù–∏–∫–æ–ª–∞–π", "–ó–æ–ª–æ—Ç—É—Ö–∏–Ω", "–ê—Ä—Ö–∏–ê–∑–∏—è", "–ü–æ–ø–æ–≤", "Ultradox", "–ú–æ—Å—Ç-–í–∏–¥–µ–æ", "–ê–ª—å—Ç–µ—Ä–∞ –ü–∞—Ä—Å", "–û–≥–æ—Ä–æ–¥–Ω–∏–∫–æ–≤", "–¢–≤–∏–Ω", "–•–∞–±–∞—Ä", "AimaksaLTV", "–¢–ù–¢", "FDV", "3df voice",
                                                "The Kitchen Russia", "–£–ª—å–ø–∞–Ω–µ–π –≠–ª—å—Ä–æ–º", "–í–∏–¥–µ–æ–∏–º–ø—É–ª—å—Å", "GoodTime Media", "Alezan", "True Dubbing Studio", "FDV", "–ö–∞—Ä—É—Å–µ–ª—å", "–ò–Ω—Ç–µ—Ä", "Contentica", "–ú–µ–ª—å–Ω–∏—Ü–∞", "RealFake", "–ò–î–î–ö", "–ò–Ω—Ñ–æ-—Ñ–∏–ª—å–º",
                                                "–ú—å—é–∑–∏–∫-—Ç—Ä–µ–π–¥", "–ö–∏—Ä–¥–∏–Ω | Stalk", "–î–∏–æ–ù–∏–ö", "–°—Ç–∞—Å—é–∫", "TV1000", "Hallmark", "–¢–æ–Ω–∏–∫—Å –ú–µ–¥–∏–∞", "–ë–µ—Å—Å–æ–Ω–æ–≤", "Gears Media", "–ë–∞—Ö—É—Ä–∞–Ω–∏", "NewDub", "Cinema Prestige", "–ù–∞–±–∏–µ–≤", "New Dream Media", "–¢–í3",
                                                "–ú–∞–ª–∏–Ω–æ–≤—Å–∫–∏–π –°–µ—Ä–≥–µ–π", "Superbit", "–ö–µ–Ω—Å –ú–∞—Ç–≤–µ–π", "LE-Production", "Voiz", "–°–≤–µ—Ç–ª–∞", "Cinema Prestige", "JAM", "LDV", "Videogram", "–ò–Ω–¥–∏—è –¢–í", "RedDiamond Studio", "–ì–µ—Ä—É—Å–æ–≤", "–≠–ª–µ–≥–∏—è —Ñ–∏–ª—å–º", "Nastia",
                                                "–°–µ–º—ã–∫–∏–Ω–∞ –Æ–ª–∏—è", "–≠–ª–µ–∫—Ç—Ä–∏—á–∫–∞", "–®—Ç–∞–º–ø –î–º–∏—Ç—Ä–∏–π", "–ü—è—Ç–Ω–∏—Ü–∞", "Oneinchnales", "Gravi-TV", "D2Lab", "–ö–∏–Ω–æ–ø—Ä–µ–º—å–µ—Ä–∞", "–ë—É—Å–æ–≤ –ì–ª–µ–±", "LE-Production", "1001cinema", "Amazing Dubbing", "Emslie",
                                                "1+1", "100 –¢–í", "1001 cinema", "2+2", "2—Ö2", "3df voice", "4u2ges", "5 –∫–∞–Ω–∞–ª", "A. Lazarchuk", "AAA-Sound", "AB-Video", "AdiSound", "ALEKS KV", "AlexFilm", "AlphaProject", "Alternative Production",
                                                "Amalgam", "AMC", "Amedia", "AMS", "Andy", "AniLibria", "AniMedia", "Animegroup", "Animereactor", "AnimeSpace Team", "Anistar", "AniUA", "AniWayt", "Anything-group", "AOS",
                                                "Arasi project", "ARRU Workshop", "AuraFilm", "AvePremier", "AveTurk", "AXN Sci-Fi", "Azazel", "AzOnFilm", "BadBajo", "BadCatStudio", "BBC Saint-Petersburg", "BD CEE", "Black Street Records",
                                                "Bonsai Studio", "Bo–ª—å–≥a", "Brain Production", "BraveSound", "BTI Studios", "Bubble Dubbing Company", "Byako Records", "Cactus Team", "Cartoon Network", "CBS Drama", "CDV", "Cinema Prestige",
                                                "CinemaSET GROUP", "CinemaTone", "ColdFilm", "Contentica", "CP Digital", "CPIG", "Crunchyroll", "Cuba77", "D1", "D2lab", "datynet", "DDV", "DeadLine", "DeadSno", "DeMon", "den904", "Description",
                                                "DexterTV", "Dice", "Discovery", "DniproFilm", "DoubleRec", "DreamRecords", "DVD Classic", "East Dream", "Eladiel", "Elegia", "ELEKTRI4KA", "Elrom", "ELYSIUM", "Epic Team", "eraserhead", "erogg",
                                                "Eurochannel", "Extrabit", "F-TRAIN", "Family Fan Edition", "FDV", "FiliZa Studio", "Film Prestige", "FilmGate", "FilmsClub", "FireDub", "Flarrow Films", "Flux-Team", "FocusStudio", "FOX", "Fox Crime",
                                                "Fox Russia", "FoxLife", "Foxlight", "Franek Monk", "Gala Voices", "Garsu Pasaulis", "Gears Media", "Gemini", "General Film", "GetSmart", "Gezell Studio", "Gits", "GladiolusTV", "GoldTeam", "Good People",
                                                "Goodtime Media", "GoodVideo", "GostFilm", "Gramalant", "Gravi-TV", "GREEN TEA", "Green–†–∞–π Studio", "Gremlin Creative Studio", "Hallmark", "HamsterStudio", "HiWay Grope", "Horizon Studio", "hungry_inri",
                                                "ICG", "ICTV", "IdeaFilm", "IgVin &amp; Solncekleshka", "ImageArt", "INTERFILM", "Ivnet Cinema", "I–ù–¢–ï–†", "Jakob Bellmann", "JAM", "Janetta", "Jaskier", "JeFerSon", "jept", "JetiX", "Jetvis", "JimmyJ",
                                                "KANSAI", "KIHO", "kiitos", "KinoGolos", "Kinomania", "KosharaSerials", "K–æ–ª–æ–±–æ–∫", "L0cDoG", "LakeFilms", "LDV", "LE-Production", "LeDoyen", "LevshaFilm", "LeXiKC", "Liga HQ", "Line", "Lisitz",
                                                "Lizard Cinema Trade", "Lord32x", "lord666", "LostFilm", "Lucky Production", "Macross", "madrid", "Mallorn Studio", "Marclail", "Max Nabokov", "MC Entertainment", "MCA", "McElroy", "Mega-Anime",
                                                "Melodic Voice Studio", "metalrus", "MGM", "MifSnaiper", "Mikail", "Milirina", "MiraiDub", "MOYGOLOS", "MrRose", "MTV", "Murzilka", "MUZOBOZ", "National Geographic", "NemFilm", "Neoclassica", "NEON Studio",
                                                "New Dream Media", "NewComers", "NewStation", "NewStudio", "Nice-Media", "Nickelodeon", "No-Future", "NovaFilm", "Novamedia", "Octopus", "Oghra-Brown", "OMSKBIRD", "Onibaku", "OnisFilms", "OpenDub",
                                                "OSLIKt", "Ozz TV", "PaDet", "Paramount Comedy", "Paramount Pictures", "Parovoz Production", "PashaUp", "Paul Bunyan", "Pazl Voice", "PCB Translate", "Persona99", "PiratVoice", "Postmodern", "Profix Media",
                                                "Project Web Mania", "Prolix", "QTV", "R5", "Radamant", "RainDeath", "RATTLEBOX", "RealFake", "Reanimedia", "Rebel Voice", "RecentFilms", "Red Media", "RedDiamond Studio", "RedDog", "RedRussian1337",
                                                "Renegade Team", "RG Paravozik", "RinGo", "RoxMarty", "Rumble", "RUSCICO", "RusFilm", "RussianGuy27", "Saint Sound", "SakuraNight", "Satkur", "Sawyer888", "Sci-Fi Russia", "SDI Media", "Selena", "seqw0",
                                                "SesDizi", "SGEV", "Shachiburi", "SHIZA", "ShowJet", "Sky Voices", "SkyeFilmTV", "SmallFilm", "SmallFilm", "SNK-TV", "SnowRecords", "SOFTBOX", "SOLDLUCK2", "Solod", "SomeWax", "Sony Channel", "Sony Turbo",
                                                "Sound Film", "SpaceDust", "ssvss", "st.Elrom", "STEPonee", "SunshineStudio", "Superbit", "Suzaku", "sweet couple", "TatamiFilm", "TB5", "TF-AniGroup", "The Kitchen Russia", "The Mike Rec.", "Timecraft",
                                                "To4kaTV", "Tori", "Total DVD", "TrainStudio", "Troy", "True Dubbing Studio", "TUMBLER Studio", "turok1990", "TV 1000", "TVShows", "Twister", "Twix", "Tycoon", "Ultradox", "Universal Russia", "VashMax2",
                                                "VendettA", "VHS", "VicTeam", "VictoryFilms", "Video-BIZ", "Videogram", "ViruseProject", "visanti-vasaer", "VIZ Media", "VO-production", "Voice Project Studio", "VoicePower", "VSI Moscow", "VulpesVulpes",
                                                "Wakanim", "Wayland team", "WestFilm", "WiaDUB", "WVoice", "XL Media", "XvidClub Studio", "zamez", "ZEE TV", "Zendos", "ZM-SHOW", "Zone Studio", "Zone Vision", "–ê–≥–∞–ø–æ–≤", "–ê–∫–æ–ø—è–Ω", "–ê–ª–µ–∫—Å–µ–µ–≤", "–ê—Ä—Ç–µ–º—å–µ–≤",
                                                "–ë–∞–≥–∏—á–µ–≤", "–ë–µ—Å—Å–æ–Ω–æ–≤", "–í–∞—Å–∏–ª—å–µ–≤", "–í–∞—Å–∏–ª—å—Ü–µ–≤", "–ì–∞–≤—Ä–∏–ª–æ–≤", "–ì–µ—Ä—É—Å–æ–≤", "–ì–æ—Ç–ª–∏–±", "–ì—Ä–∏–≥–æ—Ä—å–µ–≤", "–î–∞—Å–µ–≤–∏—á", "–î–æ–ª—å—Å–∫–∏–π", "–ö–∞—Ä–ø–æ–≤—Å–∫–∏–π", "–ö–∞—à–∫–∏–Ω", "–ö–∏—Ä–µ–µ–≤", "–ö–ª—é–∫–≤–∏–Ω", "–ö–æ—Å—Ç—é–∫–µ–≤–∏—á", "–ú–∞—Ç–≤–µ–µ–≤", "–ú–∏—Ö–∞–ª–µ–≤", "–ú–∏—à–∏–Ω",
                                                "–ú—É–¥—Ä–æ–≤", "–ü—Ä–æ–Ω–∏–Ω", "–°–∞–≤—á–µ–Ω–∫–æ", "–°–º–∏—Ä–Ω–æ–≤", "–¢–∏–º–æ—Ñ–µ–µ–≤", "–¢–æ–ª—Å—Ç–æ–±—Ä–æ–≤", "–ß—É–µ–≤", "–®—É–≤–∞–µ–≤", "–Ø–∫–æ–≤–ª–µ–≤", "–ê–ê–ê-sound", "–ê–ë—ã–ì–î–µ", "–ê–∫–∞–ª–∏—Ç", "–ê–∫–∏—Ä–∞", "–ê–ª—å—è–Ω—Å", "–ê–º–∞–ª—å–≥–∞–º–∞", "–ê–ú–°", "–ê–Ω–í–∞–¥", "–ê–Ω—É–±–∏—Å", "Anubis", "–ê—Ä–∫-–¢–í",
                                                "–ê–†–ö-–¢–í Studio", "–ë. –§–µ–¥–æ—Ä–æ–≤", "–ë–∏–±–∏–∫–æ–≤", "–ë–∏–≥—ã—á", "–ë–æ–π–∫–æ–≤", "–ê–±–¥—É–ª–æ–≤", "–ë–µ–ª–æ–≤", "–í–∏—Ö—Ä–æ–≤", "–í–æ—Ä–æ–Ω—Ü–æ–≤", "–ì–æ—Ä—á–∞–∫–æ–≤", "–î–∞–Ω–∏–ª–æ–≤", "–î–æ—Ö–∞–ª–æ–≤", "–ö–æ—Ç–æ–≤", "–ö–æ—à–∫–∏–Ω", "–ù–∞–∑–∞—Ä–æ–≤", "–ü–æ–ø–æ–≤", "–†—É–∫–∏–Ω", "–†—É—Ç–∏–ª–æ–≤",
                                                "–í–∞—Ä—É—Å –í–∏–¥–µ–æ", "–í–∞—Å—å–∫–∞ –ö—É—Ä–æ–ª–µ—Å–æ–≤", "–í–∞—â–µ–Ω–∫–æ –°.", "–í–µ–∫—à–∏–Ω", "–í–µ–ª–µ—Å", "–í–µ—Å–µ–ª—å—á–∞–∫", "–í–∏–¥–µ–æ–∏–º–ø—É–ª—å—Å", "–í–∏—Ç—è ¬´–≥–æ–≤–æ—Ä—É–Ω¬ª", "–í–æ–π—Å–æ–≤–µ—Ä", "–í–æ–ª—å–≥–∞", "–í–æ—Ä–æ–Ω", "–í–æ—Ä–æ—Ç–∏–ª–∏–Ω", "–ì. –õ–∏–±–µ—Ä–≥–∞–ª", "–ì. –†—É–º—è–Ω—Ü–µ–≤", "–ì–µ–π –ö–∏–Ω–æ –ì–∏–¥",
                                                "–ì–ö–ì", "–ì–ª—É—Ö–æ–≤—Å–∫–∏–π", "–ì—Ä–∏–∑–ª–∏", "–ì—É–Ω–¥–æ—Å", "–î–µ–Ω—å—â–∏–∫–æ–≤", "–ï—Å–∞—Ä–µ–≤", "–ù—É—Ä–º—É—Ö–∞–º–µ—Ç–æ–≤", "–ü—É—á–∫–æ–≤", "–°—Ç–∞—Å—é–∫", "–®–∞–¥–∏–Ω—Å–∫–∏–π", "–®—Ç–∞–º–ø", "sf@irat", "–î–µ—Ä–∂–∏–º–æ—Ä–¥–∞", "–î–æ–º–∞—à–Ω–∏–π", "–î–¢–í", "–î—å—è–∫–æ–Ω–æ–≤", "–ï. –ì–∞–µ–≤—Å–∫–∏–π", "–ï. –ì—Ä–∞–Ω–∫–∏–Ω",
                                                "–ï. –õ—É—Ä—å–µ", "–ï. –†—É–¥–æ–π", "–ï. –•—Ä—É—Å—Ç–∞–ª—ë–≤", "–ï–ê –°–∏–Ω–µ–º–∞", "–ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥ –ê—Ä—Ç", "–ñ–∏–≤–∞–≥–æ", "–ñ—É—á–∫–æ–≤", "–ó –†–∞–Ω–∫—É –î–æ –ù–æ—á—ñ", "–ó–∞–≤–≥–æ—Ä–æ–¥–Ω–∏–π", "–ó–µ–±—É—Ä–æ", "–ó–µ—Ä–µ–Ω–∏—Ü—ã–Ω", "–ò. –ï—Ä–µ–º–µ–µ–≤", "–ò. –ö–ª—É—à–∏–Ω", "–ò. –°–∞—Ñ—Ä–æ–Ω–æ–≤", "–ò. –°—Ç–µ–ø–∞–Ω–æ–≤",
                                                "–ò–ì–ú", "–ò–≥–º–∞—Ä", "–ò–î–î–ö", "–ò–º–∏–¥–∂-–ê—Ä—Ç", "–ò–Ω–∏—Å", "–ò—Ä—ç–Ω", "–ò—Å—Ç-–í–µ—Å—Ç", "–ö. –ü–æ–∑–¥–Ω—è–∫–æ–≤", "–ö. –§–∏–ª–æ–Ω–æ–≤", "–ö9", "–ö–∞—Ä–∞–ø–µ—Ç—è–Ω", "–ö–∞—Ä–º–µ–Ω –í–∏–¥–µ–æ", "–ö–∞—Ä—É—Å–µ–ª—å", "–ö–≤–∞–¥—Ä–∞—Ç –ú–∞–ª–µ–≤–∏—á–∞", "–ö–∏–ª—å–∫–∞",  "–ö–∏–ø–∞—Ä–∏—Å", "–ö–æ—Ä–æ–ª–µ–≤", "–ö–æ—Ç–æ–≤–∞",
                                                "–ö—Ä–∞–≤–µ—Ü", "–ö—É–±–∏–∫ –≤ –ö—É–±–µ", "–ö—É—Ä–∞–∂-–ë–∞–º–±–µ–π", "–õ. –í–æ–ª–æ–¥–∞—Ä—Å–∫–∏–π", "–õ–∞–∑–µ—Ä –í–∏–¥–µ–æ", "–õ–∞–Ω—Å–µ–ª–∞–ü", "–õ–∞–ø—à–∏–Ω", "–õ–µ–∫—Å–∏–∫–æ–Ω", "–õ–µ–Ω—Ñ–∏–ª—å–º", "–õ–µ—à–∞ –ü—Ä–∞–ø–æ—Ä—â–∏–∫", "–õ–∏–∑–∞—Ä–¥", "–õ—é—Å—å–µ–Ω–∞", "–ó–∞—É–≥–∞—Ä–æ–≤", "–ò–≤–∞–Ω–æ–≤", "–ò–≤–∞–Ω–æ–≤–∞ –∏ –ü. –ü–∞—à—É—Ç",
                                                "–õ–∞—Ç—ã—à–µ–≤", "–û—à—É—Ä–∫–æ–≤", "–ß–∞–¥–æ–≤", "–Ø—Ä–æ—Ü–∫–∏–π", "–ú–∞–∫—Å–∏–º –õ–æ–≥–∏–Ω–æ—Ñ—Ñ", "–ú–∞–ª–∏–Ω–æ–≤—Å–∫–∏–π", "–ú–∞—Ä—á–µ–Ω–∫–æ", "–ú–∞—Å—Ç–µ—Ä –¢—ç–π–ø", "–ú–∞—Ö–æ–Ω—å–∫–æ", "–ú–∞—à–∏–Ω—Å–∫–∏–π", "–ú–µ–¥–∏–∞-–ö–æ–º–ø–ª–µ–∫—Å", "–ú–µ–ª—å–Ω–∏—Ü–∞", "–ú–∏–∫–∞ –ë–æ–Ω–¥–∞—Ä–∏–∫", "–ú–∏–Ω—è–µ–≤", "–ú–∏—Ç–µ–ª—å–º–∞–Ω",
                                                "–ú–æ—Å—Ç –í–∏–¥–µ–æ", "–ú–æ—Å—Ñ–∏–ª—å–º", "–ú—É—Ä–∞–≤—Å–∫–∏–π", "–ú—å—é–∑–∏–∫-—Ç—Ä–µ–π–¥", "–ù-–ö–∏–Ω–æ", "–ù. –ê–Ω—Ç–æ–Ω–æ–≤", "–ù. –î—Ä–æ–∑–¥–æ–≤", "–ù. –ó–æ–ª–æ—Ç—É—Ö–∏–Ω", "–ù.–°–µ–≤–∞—Å—Ç—å—è–Ω–æ–≤ seva1988", "–ù–∞–±–∏–µ–≤", "–ù–∞—Ç–∞–ª—å—è –ì—É—Ä–∑–æ", "–ù–ï–í–ê 1", "–ù–µ–≤–∞—Ñ–∏–ª—å–º", "–ù–µ–ó—É–ø–∏–Ω—è–π–ü—Ä–æ–¥–∞–∫—à–Ω",
                                                "–ù–µ–æ–∫–ª–∞—Å—Å–∏–∫–∞", "–ù–µ—Å–º–µ—Ä—Ç–µ–ª—å–Ω–æ–µ –æ—Ä—É–∂–∏–µ", "–ù–õ–û-TV", "–ù–æ–≤–∏–π", "–ù–æ–≤—ã–π –¥–∏—Å–∫", "–ù–æ–≤—ã–π –î—É–±–ª—è–∂", "–ù–æ–≤—ã–π –ö–∞–Ω–∞–ª", "–ù–æ—Ç–∞", "–ù–°–¢", "–ù–¢–í", "–ù–¢–ù", "–û–≤–µ—Ä–ª–æ—Ä–¥", "–û–≥–æ—Ä–æ–¥–Ω–∏–∫–æ–≤", "–û–º–∏–∫—Ä–æ–Ω", "–ì–ª–∞–Ω—Ü", "–ö–∞—Ä—Ü–µ–≤", "–ú–æ—Ä–æ–∑–æ–≤",
                                                "–ü—Ä—è–º–æ—Å—Ç–∞–Ω–æ–≤", "–°–∞–Ω–∞–µ–≤", "–ü–∞—Ä–∞–¥–∏–∑", "–ü–µ–ø–µ–ª–∞—Ü", "–ü–µ—Ä–≤—ã–π –∫–∞–Ω–∞–ª –û–†–¢", "–ü–µ—Ä–µ–≤–æ–¥–º–∞–Ω", "–ü–µ—Ä–µ—Ü", "–ü–µ—Ç–µ—Ä–±—É—Ä–≥—Å–∫–∏–π –¥—É–±–ª—è–∂", "–ü–µ—Ç–µ—Ä–±—É—Ä–∂–µ—Ü", "–ü–∏—Ä–∞–º–∏–¥–∞", "–ü–∏—Ñ–∞–≥–æ—Ä", "–ü–æ–∑–∏—Ç–∏–≤-–ú—É–ª—å—Ç–∏–º–µ–¥–∏–∞", "–ü—Ä–∞–π–¥ –ü—Ä–æ–¥–∞–∫—à–Ω", "–ü—Ä–µ–º—å–µ—Ä –í–∏–¥–µ–æ",
                                                "–ü—Ä–µ–º—å–µ—Ä –ú—É–ª—å—Ç–∏–º–µ–¥–∏–∞", "–ü—Ä–∏—á—É–¥–∏–∫–∏", "–†. –Ø–Ω–∫–µ–ª–µ–≤–∏—á", "–†–∞–π–¥–æ", "–†–∞–∫—É—Ä—Å", "–†–µ–Ω–¢–í", "–†–æ—Å—Å–∏—è", "–†–¢–†", "–†—É—Å—Å–∫–∏–π –¥—É–±–ª—è–∂", "–†—É—Å—Å–∫–∏–π –†–µ–ø–æ—Ä—Ç–∞–∂", "–†—É–§–∏–ª–º—Å", "–†—ã–∂–∏–π –ø–µ—Å", "–°. –í–∏–∑–≥—É–Ω–æ–≤", "–°. –î—å—è–∫–æ–≤", "–°. –ö–∞–∑–∞–∫–æ–≤",
                                                "–°. –ö—É–∑–Ω–µ—Ü–æ–≤", "–°. –ö—É–∑—å–º–∏—á—ë–≤", "–°. –õ–µ–±–µ–¥–µ–≤", "–°. –ú–∞–∫–∞—à–æ–≤", "–°. –†—è–±–æ–≤", "–°. –©–µ–≥–æ–ª—å–∫–æ–≤", "–°.–†.–ò.", "–°olumbia Service", "–°–∞–º–∞—Ä—Å–∫–∏–π", "–°–í –°—Ç—É–¥–∏—è", "–°–í-–î—É–±–ª—å", "–°–≤–µ—Ç–ª–∞", "–°–µ–ª–µ–Ω–∞ –ò–Ω—Ç–µ—Ä–Ω–µ—à–Ω–ª", "–°–∏–Ω–µ–º–∞ –¢—Ä–µ–π–¥",
                                                "–°–∏–Ω–µ–º–∞ –£–°", "–°–∏–Ω—Ç–∞ –†—É—Ä–æ–Ω–∏", "–°–∏–Ω—Ö—Ä–æ–Ω", "–°–æ–≤–µ—Ç—Å–∫–∏–π", "–°–æ–∫—É—Ä–æ–≤", "–°–æ–ª–æ–¥—É—Ö–∏–Ω", "–°–æ–Ω–æ—Ç–µ–∫", "–°–æ–Ω—å–∫–∏–Ω", "–°–æ—é–∑ –í–∏–¥–µ–æ", "–°–æ—é–∑–º—É–ª—å—Ç—Ñ–∏–ª—å–º", "–°–ü–î - –°–ª–∞–¥–∫–∞—è –ø–∞—Ä–æ—á–∫–∞", "–°—Ç—Ä–æ–µ–≤", "–°–¢–°", "–°—Ç—É–¥–∏–∏ –°—É–≤–µ—Ä–µ–Ω–Ω–æ–≥–æ –õ–µ–ø—Ä–æ–∑–æ—Ä–∏—è",
                                                "–°—Ç—É–¥–∏—è ¬´–°—Ç–∞—Ä—Ç—Ä–µ–∫¬ª", "KOleso", "–°—Ç—É–¥–∏—è –ì–æ—Ä—å–∫–æ–≥–æ", "–°—Ç—É–¥–∏—è –ö–æ–ª–æ–±–æ–∫", "–°—Ç—É–¥–∏—è –ü–∏—Ä–∞—Ç—Å–∫–æ–≥–æ –î—É–±–ª—è–∂–∞", "–°—Ç—É–¥–∏—è –†–∞–π–¥–æ", "–°—Ç—É–¥–∏—è –¢—Ä—ë—Ö", "–ì—É—Ä—Ç–æ–º", "–°—É–ø–µ—Ä–±–∏—Ç", "–°—ã–µ–Ω–¥—É–∫", "–¢–∞–∫ –¢—Ä–µ–±–∞ –ü—Ä–æ–¥–∞–∫—à–Ω", "–¢–í XXI –≤–µ–∫", "–¢–í –°–ü–±",
                                                "–¢–í-3", "–¢–í6", "–¢–í–ò–ù", "–¢–í–¶", "–¢–í–ß 1", "–¢–ù–¢", "–¢–û –î—Ä—É–∑–µ–π", "–¢–æ–ª–º–∞—á–µ–≤", "–¢–æ—á–∫–∞ Z—Ä–µ–Ω–∏—è", "–¢—Ä–∞–º–≤–∞–π-—Ñ–∏–ª—å–º", "–¢–†–ö", "–£–æ–ª—Ç –î–∏—Å–Ω–µ–π –ö–æ–º–ø–∞–Ω–∏", "–•–∏—Ö–∏–¥–æ–∫", "–•–ª–æ–ø—É—à–∫–∞", "–¶—ñ–∫–∞–≤–∞ –Ü–¥–µ—è", "–ß–µ—Ç—ã—Ä–µ –≤ –∫–≤–∞–¥—Ä–∞—Ç–µ", "–®–≤–µ—Ü–æ–≤",
                                                "–®—Ç–∞–º–ø", "–®—Ç–µ–π–Ω", "–Æ. –ñ–∏–≤–æ–≤", "–Æ. –ù–µ–º–∞—Ö–æ–≤", "–Æ. –°–µ—Ä–±–∏–Ω", "–Æ. –¢–æ–≤–±–∏–Ω", "–Ø. –ë–µ–ª–ª–º–∞–Ω–Ω", "–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π"
                                            };

                                            foreach (string v in allVoices)
                                            {
                                                if (v.Length > 4 && name.ToLower().Contains(v.ToLower()))
                                                    voicename += $"{v}, ";
                                            }
                                        }

                                        voicename = Regex.Replace(voicename, ", +$", "");
                                    }
                                    #endregion

                                    if (init.emptyVoice == false && string.IsNullOrEmpty(voicename))
                                        continue;

                                    voicename  = voicename ?? string.Empty;

                                    #region HDR / HEVC / Dolby Vision
                                    if (Regex.IsMatch(name, "HDR10", RegexOptions.IgnoreCase) || Regex.IsMatch(name, "10-?bit", RegexOptions.IgnoreCase))
                                        mediainfo += " HDR10 ";
                                    else if (Regex.IsMatch(name, "HDR", RegexOptions.IgnoreCase))
                                        mediainfo += " HDR ";
                                    else
                                    {
                                        mediainfo += " SDR ";
                                    }

                                    if (Regex.IsMatch(name, "HEVC", RegexOptions.IgnoreCase) || Regex.IsMatch(name, "H.265", RegexOptions.IgnoreCase))
                                        mediainfo += " / H.265 ";

                                    if (Regex.IsMatch(name, "Dolby Vision", RegexOptions.IgnoreCase))
                                        mediainfo += " / Dolby Vision ";
                                    #endregion

                                    #region tr arg
                                    string tr = string.Empty;
                                    var match = Regex.Match(magnet, "(&|\\?)tr=([^&\\?]+)");
                                    while (match.Success)
                                    {
                                        string t = match.Groups[2].Value.Trim().ToLower();
                                        if (!string.IsNullOrEmpty(t))
                                            tr += t.Contains("/") || t.Contains(":") ? $"&tr={HttpUtility.UrlEncode(t)}" : $"&tr={t}";

                                        match = match.NextMatch();
                                    }

                                    if (!string.IsNullOrEmpty(tr))
                                        tr = tr.Remove(0, 1);
                                    #endregion

                                    if (!string.IsNullOrEmpty(init.filter) && !Regex.IsMatch($"{name}:{voicename}", init.filter, RegexOptions.IgnoreCase))
                                        continue;

                                    if (!string.IsNullOrEmpty(init.filter_ignore) && Regex.IsMatch($"{name}:{voicename}", init.filter_ignore, RegexOptions.IgnoreCase))
                                        continue;

                                    torrents.Add((name, voicename, magnet, sid, tr, (name.Contains("2160p") ? "2160p" : name.Contains("1080p") ? "1080p" : "720–∑"), (torrent.Size ?? 0), mediainfo, torrent));
                                }
                            }
                        }
                    }

                    hybridCache.Set(memKey, torrents, DateTime.Now.AddMinutes(5));
                }

                if (torrents.Count == 0)
                    return Content(string.Empty);
                #endregion

                string en_title = HttpUtility.UrlEncode(title);
                string en_original_title = HttpUtility.UrlEncode(original_title);

                var movies = torrents
                    .OrderByDescending(i => i.voice.Contains("–î—É–±–ª—è–∂"))
                    .ThenByDescending(i => !string.IsNullOrEmpty(i.voice))
                    .ThenByDescending(i => i.magnet.Contains("&tr="));

                movies = init.sort == "size" 
                    ? movies.ThenByDescending(i => i.size) 
                    : init.sort == "sid" ? movies.ThenByDescending(i => i.sid) 
                    : movies.ThenByDescending(i => i.torrent.PublishDate);

                if (serial == 1)
                {
                    if (s == -1)
                    {
                        HashSet<int> seasons = new HashSet<int>();

                        var tpl = new SeasonTpl(quality: movies.FirstOrDefault
                        (
                            i => Regex.IsMatch(i.name, "(4k|uhd)( |\\]|,|$)", RegexOptions.IgnoreCase) || i.name.Contains("2160p")).name != null ? "2160p" :
                                 movies.FirstOrDefault(i => i.name.Contains("1080p")).name != null ? "1080p" : "720p"
                        );

                        foreach (var t in movies)
                        {
                            if (t.torrent.info.seasons == null || t.torrent.info.seasons.Length == 0)
                                continue;

                            foreach (var item in t.torrent.info.seasons)
                                seasons.Add(item);
                        }

                        foreach (int season in seasons.OrderBy(i => i))
                            tpl.Append($"{season} —Å–µ–∑–æ–Ω", $"{host}/lite/pidtor?rjson={rjson}&title={en_title}&original_title={en_original_title}&year={year}&original_language={original_language}&serial=1&s={season}", season);

                        return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                    }
                    else
                    {
                        var stpl = new SimilarTpl();

                        foreach (var torrent in movies)
                        {
                            if (torrent.torrent.info.seasons == null || torrent.torrent.info.seasons.Length == 0)
                                continue;

                            if (!torrent.torrent.info.seasons.Contains(s) || torrent.torrent.info.seasons.Length != 1) // –º–Ω–æ–≥–æ—Å–µ–∑–æ–Ω–Ω—ã–π 
                                continue;

                            string hashmagnet = Regex.Match(torrent.magnet, "magnet:\\?xt=urn:btih:([a-zA-Z0-9]+)").Groups[1].Value.ToLower();
                            if (string.IsNullOrWhiteSpace(hashmagnet))
                                continue;

                            stpl.Append(torrent.voice, null, $"{torrent.quality} / {torrent.mediainfo} / {torrent.sid}", accsArgs($"{host}/lite/pidtor/serial/{hashmagnet}?{torrent.tr}&rjson={rjson}&title={en_title}&original_title={en_original_title}&s={s}"));
                        }

                        return ContentTo(rjson ? stpl.ToJson() : stpl.ToHtml());
                    }
                }
                else
                {
                    var mtpl = new MovieTpl(title, original_title);

                    foreach (var torrent in movies)
                    {
                        string hashmagnet = Regex.Match(torrent.magnet, "magnet:\\?xt=urn:btih:([a-zA-Z0-9]+)").Groups[1].Value.ToLower();
                        if (string.IsNullOrWhiteSpace(hashmagnet))
                            continue;

                        mtpl.Append(torrent.voice, accsArgs($"{host}/lite/pidtor/s{hashmagnet}?{torrent.tr}"), voice_name: $"{torrent.quality} / {torrent.mediainfo} / {torrent.sid}", quality: torrent.quality.Replace("p", ""));
                    }

                    return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                }
            });
        }


        [HttpGet]
        [Route("lite/pidtor/serial/{id}")]
        async public ValueTask<ActionResult> Serial(string id, string account_email, string title, string original_title, int s, bool rjson = false)
        {
            var init = AppInit.conf.PidTor;
            if (!init.enable)
                return OnError();

            if (NoAccessGroup(init, out string error_msg))
                return ShowError(error_msg);

            string tr = Regex.Replace(HttpContext.Request.QueryString.Value.Remove(0, 1), "&(account_email|uid|token|title|original_title|rjson|s)=[^&]+", "");

            string memKey = $"pidtor:serial:{id}";

            return await InvkSemaphore(null, memKey, async () =>
            {
                #region –ö–µ—à –∑–∞–ø—Ä–æ—Å–∞
                if (!hybridCache.TryGetValue(memKey, out FileStat[] file_stats))
                {
                    #region gots
                    (List<HeadersModel> header, string host) gots()
                    {
                        if ((init.torrs == null || init.torrs.Length == 0) && (init.auth_torrs == null || init.auth_torrs.Count == 0))
                        {
                            if (System.IO.File.Exists("torrserver/accs.db"))
                            {
                                string accs = System.IO.File.ReadAllText("torrserver/accs.db");
                                string passwd = Regex.Match(accs, "\"ts\":\"([^\"]+)\"").Groups[1].Value;

                                return (HeadersModel.Init("Authorization", $"Basic {CrypTo.Base64($"ts:{passwd}")}"), $"http://{AppInit.conf.listen.localhost}:9080");
                            }

                            return (null, $"http://{AppInit.conf.listen.localhost}:9080");
                        }

                        if (init.auth_torrs != null && init.auth_torrs.Count > 0)
                        {
                            var ts = init.auth_torrs.First();
                            string login = ts.login.Replace("{account_email}", account_email);
                            var auth = HeadersModel.Init("Authorization", $"Basic {CrypTo.Base64($"{login}:{ts.passwd}")}");

                            return (httpHeaders(ts.host, HeadersModel.Join(auth, ts.headers)), ts.host);
                        }
                        else
                        {
                            if (init.base_auth != null && init.base_auth.enable)
                            {
                                var ts = init.auth_torrs.First();
                                string login = init.base_auth.login.Replace("{account_email}", account_email);
                                var auth = HeadersModel.Init("Authorization", $"Basic {CrypTo.Base64($"{login}:{init.base_auth.passwd}")}");

                                return (httpHeaders(ts.host, HeadersModel.Join(auth, init.base_auth.headers)), ts.host);
                            }

                            return (null, init.torrs.First());
                        }
                    }
                    #endregion

                    var ts = gots();

                    string magnet = $"magnet:?xt=urn:btih:{id}&" + tr;
                    string hash = await Http.Post($"{ts.host}/torrents", "{\"action\":\"add\",\"link\":\"" + magnet + "\",\"title\":\"\",\"poster\":\"\",\"save_to_db\":false}", timeoutSeconds: 8, headers: ts.header);
                    if (hash == null)
                        return OnError();

                    hash = Regex.Match(hash, "\"hash\":\"([^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(hash))
                        return OnError();

                    Stat stat = null;
                    var ex = DateTime.Now.AddSeconds(20);

                resetgotingo: stat = await Http.Post<Stat>($"{ts.host}/torrents", "{\"action\":\"get\",\"hash\":\"" + hash + "\"}", timeoutSeconds: 3, headers: ts.header);
                    if (stat?.file_stats == null || stat.file_stats.Length == 0)
                    {
                        if (DateTime.Now > ex)
                        {
                            _ = Http.Post($"{ts.host}/torrents", "{\"action\":\"rem\",\"hash\":\"" + hash + "\"}", headers: ts.header);
                            return OnError();
                        }

                        await Task.Delay(250);
                        goto resetgotingo;
                    }

                    _ = Http.Post($"{ts.host}/torrents", "{\"action\":\"rem\",\"hash\":\"" + hash + "\"}", headers: ts.header);

                    file_stats = stat.file_stats;
                    hybridCache.Set(memKey, file_stats, DateTime.Now.AddHours(36));
                }
                #endregion

                var mtpl = new EpisodeTpl();

                foreach (var torrent in file_stats)
                {
                    if (Path.GetExtension(torrent.Path) is ".srt" or ".txt" or ".jpg" or ".png")
                        continue;

                    mtpl.Append(Path.GetFileName(torrent.Path), title ?? original_title, s.ToString(), torrent.Id.ToString(), accsArgs($"{host}/lite/pidtor/s{id}?{tr}&tsid={torrent.Id}"));
                }

                return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
            });
        }


        [HttpGet]
        [Route("lite/pidtor/s{id}")]
        async public ValueTask<ActionResult> Stream(string id, int tsid = -1, string account_email = null)
        {
            var init = AppInit.conf.PidTor;
            if (!init.enable)
                return OnError();

            if (NoAccessGroup(init, out string error_msg))
                return ShowError(error_msg);

            string country = requestInfo.Country;

            int index = tsid != -1 ? tsid : 1;
            string magnet = $"magnet:?xt=urn:btih:{id}&" + Regex.Replace(HttpContext.Request.QueryString.Value.Remove(0, 1), "&(account_email|uid|token|tsid)=[^&]+", "");

            #region auth_stream
            async ValueTask<ActionResult> auth_stream(string host, string login, string passwd, string uhost = null, Dictionary<string, string> addheaders = null)
            {
                string memKey = $"pidtor:auth_stream:{id}:{uhost ?? host}";
                if (!hybridCache.TryGetValue(memKey, out string hash))
                {
                    login = login.Replace("{account_email}", account_email ?? string.Empty);

                    var headers = HeadersModel.Init("Authorization", $"Basic {CrypTo.Base64($"{login}:{passwd}")}");
                        headers = HeadersModel.Join(headers, addheaders);

                    hash = await Http.Post($"{host}/torrents", "{\"action\":\"add\",\"link\":\"" + magnet + "\",\"title\":\"\",\"poster\":\"\",\"save_to_db\":false}", timeoutSeconds: 5, headers: headers);
                    if (hash == null)
                        return OnError($"{host} unavailable");

                    hash = Regex.Match(hash, "\"hash\":\"([^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(hash))
                        return OnError("hash null");

                    hybridCache.Set(memKey, hash, DateTime.Now.AddMinutes(1));
                }

                return Redirect($"{uhost ?? host}/stream?link={hash}&index={index}&play");
            }
            #endregion

            if ((init.torrs == null || init.torrs.Length == 0) && (init.auth_torrs == null || init.auth_torrs.Count == 0))
            {
                if (System.IO.File.Exists("torrserver/accs.db"))
                {
                    string accs = System.IO.File.ReadAllText("torrserver/accs.db");
                    string passwd = Regex.Match(accs, "\"ts\":\"([^\"]+)\"").Groups[1].Value;

                    return await auth_stream($"http://{AppInit.conf.listen.localhost}:9080", "ts", passwd, uhost: $"{host}/ts");
                }

                return Redirect($"{host}/ts/stream?link={HttpUtility.UrlEncode(magnet)}&index={index}&play");
            }

            if (init.auth_torrs != null && init.auth_torrs.Count > 0)
            {
                string tskey = $"pidtor:ts2:{id}:{requestInfo.IP}";
                if (!hybridCache.TryGetValue(tskey, out PidTorAuthTS ts))
                {
                    var tors = init.auth_torrs.Where(i => i.enable).ToList();

                    if (country != null)
                        tors = tors.Where(i => i.country == null || i.country.Contains(country)).Where(i => i.no_country == null || !i.no_country.Contains(country)).ToList();

                    ts = tors[Random.Shared.Next(0, tors.Count)];
                    hybridCache.Set(tskey, ts, DateTime.Now.AddHours(4));
                }

                return await auth_stream(ts.host, ts.login, ts.passwd, addheaders: ts.headers);
            }
            else 
            {
                if (init.base_auth != null && init.base_auth.enable)
                {
                    string tskey = $"pidtor:ts3:{id}:{requestInfo.IP}";
                    if (!hybridCache.TryGetValue(tskey, out string ts))
                    {
                        ts = init.torrs[Random.Shared.Next(0, init.torrs.Length)];
                        hybridCache.Set(tskey, ts, DateTime.Now.AddHours(4));
                    }

                    return await auth_stream(ts, init.base_auth.login, init.base_auth.passwd, addheaders: init.base_auth.headers);
                }

                string key = $"pidtor:ts4:{id}:{requestInfo.IP}";
                if (!hybridCache.TryGetValue(key, out string tshost))
                {
                    tshost = init.torrs[Random.Shared.Next(0, init.torrs.Length)];
                    hybridCache.Set(key, tshost, DateTime.Now.AddHours(4));
                }

                return Redirect($"{tshost}/stream?link={HttpUtility.UrlEncode(magnet)}&index={index}&play");
            }
        }
    }
}

```

## File: Online/Controllers/FilmixPartner.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Filmix;
using System.Security.Cryptography;
using System.Text;

namespace Online.Controllers
{
    public class FilmixPartner : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/fxapi")]
        async public ValueTask<ActionResult> Index(long kinopoisk_id, bool checksearch, string title, string original_title, int year, int postid, int t = -1, int s = -1, bool rjson = false, bool similar = false, string source = null, string id = null)
        {
            if (postid == 0 && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() is "filmix" or "filmixapp")
                {
                    if (!int.TryParse(id, out postid))
                        int.TryParse(Regex.Match(id, "/([0-9]+)-").Groups[1].Value, out postid);
                }
            }

            var init = await loadKit(AppInit.conf.FilmixPartner);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (postid == 0)
            {
                var res = await InvokeCache($"fxapi:search:{title}:{original_title}:{similar}", cacheTime(40, init: init), () => Search(title, original_title, year, similar));
                if (similar)
                    return ContentTo(rjson ? res.similars.Value.ToJson() : res.similars.Value.ToHtml());

                if (res != null)
                    postid = res.id;

                // –ø–ª–∞—Ç–Ω—ã–π –ø–æ–∏—Å–∫
                if (!checksearch && postid == 0 && kinopoisk_id > 0)
                    postid = await searchKp(kinopoisk_id);

                if (postid == 0 && res?.similars != null)
                    return ContentTo(rjson ? res.similars.Value.ToJson() : res.similars.Value.ToHtml());
            }

            if (postid == 0)
                return OnError();

            if (checksearch)
                return Content("data-json=");

            string hashKey = $"fxapi:hashfimix:{requestInfo.IP}";
            hybridCache.TryGetValue(hashKey, out string hashfimix);

            string videoKey = $"fxapi:{postid}:{(string.IsNullOrEmpty(hashfimix) ? requestInfo.IP : "")}";

            return await InvkSemaphore(init, videoKey, async () =>
            {
                #region video_links
                if (!hybridCache.TryGetValue(videoKey, out JArray root))
                {
                    string XFXTOKEN = await getXFXTOKEN(requestInfo.user_uid);
                    if (string.IsNullOrWhiteSpace(XFXTOKEN))
                        return OnError();

                    root = await Http.Get<JArray>($"{init.corsHost()}/video_links/{postid}", headers: httpHeaders(init, HeadersModel.Init("X-FX-TOKEN", XFXTOKEN)));

                    if (root == null || root.Count == 0)
                        return OnError();

                    var first = root.First.ToObject<JObject>();
                    if (!first.ContainsKey("files") && !first.ContainsKey("seasons"))
                        return OnError();

                    if (string.IsNullOrEmpty(hashfimix))
                    {
                        hashfimix = Regex.Match(root.First.ToString().Replace("\\", ""), "/s/([^/]+)/").Groups[1].Value;

                        if (!string.IsNullOrEmpty(hashfimix))
                        {
                            videoKey = $"fxapi:{postid}";
                            hybridCache.Set(hashKey, hashfimix, DateTime.Now.AddHours(1));
                        }
                    }

                    hybridCache.Set(videoKey, root, DateTime.Now.AddHours(2));
                }
                #endregion

                if (root.First.ToObject<JObject>().ContainsKey("files"))
                {
                    #region –§–∏–ª—å–º
                    var mtpl = new MovieTpl(title, original_title, root.Count);

                    foreach (var movie in root)
                    {
                        var streamquality = new StreamQualityTpl();

                        foreach (var file in movie.Value<JArray>("files").OrderByDescending(i => i.Value<int>("quality")))
                        {
                            int q = file.Value<int>("quality");
                            string url = file.Value<string>("url");
                            if (!string.IsNullOrEmpty(hashfimix))
                                url = Regex.Replace(url, "/s/[^/]+/", $"/s/{hashfimix}/");

                            streamquality.Append(HostStreamProxy(init, url), $"{q}p");
                        }

                        mtpl.Append(movie.Value<string>("name"), streamquality.Firts().link, streamquality: streamquality, vast: init.vast);
                    }

                    return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∞–ª
                    if (s == -1)
                    {
                        #region –°–µ–∑–æ–Ω—ã
                        var tpl = new SeasonTpl(root.Count);
                        var temp_season = new HashSet<int>();

                        foreach (var translation in root)
                        {
                            foreach (var season in translation.Value<JArray>("seasons"))
                            {
                                int sid = season.Value<int>("season");
                                string sname = $"{sid} —Å–µ–∑–æ–Ω";

                                if (!temp_season.Contains(sid))
                                {
                                    temp_season.Add(sid);
                                    string link = $"{host}/lite/fxapi?rjson={rjson}&postid={postid}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&s={sid}";
                                    tpl.Append(sname, link, sid);
                                }
                            }
                        }

                        return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                        #endregion
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        int indexTranslate = 0;
                        var vtpl = new VoiceTpl();

                        foreach (var translation in root)
                        {
                            foreach (var season in translation.Value<JArray>("seasons"))
                            {
                                if (season.Value<int>("season") == s)
                                {
                                    string link = $"{host}/lite/fxapi?rjson={rjson}&postid={postid}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&s={s}&t={indexTranslate}";
                                    bool active = t == indexTranslate;

                                    if (t == -1)
                                        t = indexTranslate;

                                    vtpl.Append(translation.Value<string>("name"), active, link);
                                    break;
                                }
                            }

                            indexTranslate++;
                        }
                        #endregion

                        #region –°–µ—Ä–∏–∏
                        var etpl = new EpisodeTpl();
                        string sArhc = s.ToString();

                        foreach (var episode in root[t].Value<JArray>("seasons").FirstOrDefault(i => i.Value<int>("season") == s).Value<JObject>("episodes").ToObject<Dictionary<string, JObject>>().Values)
                        {
                            var streamquality = new StreamQualityTpl();

                            foreach (var file in episode.Value<JArray>("files").OrderByDescending(i => i.Value<int>("quality")))
                            {
                                int q = file.Value<int>("quality");
                                string url = file.Value<string>("url");
                                if (!string.IsNullOrEmpty(hashfimix))
                                    url = Regex.Replace(url, "/s/[^/]+/", $"/s/{hashfimix}/");

                                string l = HostStreamProxy(init, url);

                                streamquality.Append(l, $"{q}p");
                            }

                            int e = episode.Value<int>("episode");
                            etpl.Append($"{e} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, e.ToString(), streamquality.Firts().link, streamquality: streamquality, vast: init.vast);
                        }
                        #endregion

                        if (rjson)
                            return ContentTo(etpl.ToJson(vtpl));

                        return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                    }
                    #endregion
                }
            });
        }


        [HttpGet]
        [Route("lite/fxapi/lowlevel/{*uri}")]
        async public Task<ActionResult> LowlevelApi(string uri)
        {
            var init = AppInit.conf.FilmixPartner;

            if (!init.enable)
                return OnError("disable", gbcache: false);

            if (!HttpContext.Request.Headers.TryGetValue("low_passw", out var low_passw) || low_passw.ToString() != init.lowlevel_api_passw)
                return OnError("lowlevel_api", gbcache: false);

            string XFXTOKEN = await getXFXTOKEN();
            if (string.IsNullOrWhiteSpace(XFXTOKEN))
                return OnError("XFXTOKEN", gbcache: false);

            string json = await Http.Get($"{init.corsHost()}/{uri}", headers: httpHeaders(init, HeadersModel.Init("X-FX-TOKEN", XFXTOKEN)));

            return Content(json, "application/json; charset=utf-8");
        }


        #region search
        async ValueTask<int> searchKp(long kinopoisk_id)
        {
            if (kinopoisk_id == 0)
                return 0;

            string memKey = $"fxapi:search:{kinopoisk_id}";
            if (!hybridCache.TryGetValue(memKey, out int postid))
            {
                string XFXTOKEN = await getXFXTOKEN();
                if (string.IsNullOrWhiteSpace(XFXTOKEN))
                    return 0;

                var root = await Http.Get<JObject>($"{AppInit.conf.FilmixPartner.corsHost()}/film/by-kp/{kinopoisk_id}", headers: httpHeaders(AppInit.conf.FilmixPartner, HeadersModel.Init("X-FX-TOKEN", XFXTOKEN)));

                if (root == null || !root.ContainsKey("id"))
                    return 0;

                postid = root.Value<int>("id"); 

                if (postid > 0)
                    hybridCache.Set(memKey, postid, DateTime.Now.AddDays(20));
                else
                    hybridCache.Set(memKey, postid, DateTime.Now.AddDays(1));
            }

            return postid;
        }


        async ValueTask<SearchResult> Search(string title, string original_title, int year, bool similar)
        {
            if (string.IsNullOrWhiteSpace(title ?? original_title))
                return null;

            var proxyManager = new ProxyManager("filmix", AppInit.conf.Filmix);
            var proxy = proxyManager.Get();

            string uri = $"{AppInit.conf.Filmix.corsHost()}/api/v2/search?story={HttpUtility.UrlEncode(title)}&user_dev_apk=2.0.1&user_dev_id=&user_dev_name=Xiaomi&user_dev_os=11&user_dev_token={AppInit.conf.Filmix.token}&user_dev_vendor=Xiaomi";

            string json = await Http.Get(AppInit.conf.Filmix.cors(uri), timeoutSeconds: 7, proxy: proxy, useDefaultHeaders: false, headers: HeadersModel.Init(
                ("Accept-Encoding", "gzip")
            ));

            if (json == null)
            {
                proxyManager.Refresh();
                return await Search2(title, original_title, year);
            }

            List<SearchModel> root = null;

            try
            {
                root = JsonConvert.DeserializeObject<List<SearchModel>>(json);
            }
            catch { }

            if (root == null || root.Count == 0)
                return await Search2(title, original_title, year);

            var ids = new List<int>();
            var stpl = new SimilarTpl(root.Count);

            string enc_title = HttpUtility.UrlEncode(title);
            string enc_original_title = HttpUtility.UrlEncode(original_title);

            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            foreach (var item in root)
            {
                if (item == null)
                    continue;

                string name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.original_title) ? $"{item.title} / {item.original_title}" : (item.title ?? item.original_title);

                stpl.Append(name, item.year.ToString(), string.Empty, host + $"lite/fxapi?postid={item.id}&title={enc_title}&original_title={enc_original_title}", PosterApi.Size(item.poster));

                if ((!string.IsNullOrEmpty(stitle) && StringConvert.SearchName(item.title) == stitle) ||
                    (!string.IsNullOrEmpty(sorigtitle) && StringConvert.SearchName(item.original_title) == sorigtitle))
                {
                    if (item.year == year)
                        ids.Add(item.id);
                }
            }

            if (ids.Count == 1 &&!similar)
                return new SearchResult() { id = ids[0] };

            return new SearchResult() { similars = stpl };
        }


        async Task<SearchResult> Search2(string? title, string? original_title, int year)
        {
            async Task<List<SearchModel>> gosearch(string? story)
            {
                if (string.IsNullOrEmpty(story))
                    return null;

                string uri = $"https://api.filmix.tv/api-fx/list?search={HttpUtility.UrlEncode(story)}&limit=48";

                string json = await Http.Get(uri, timeoutSeconds: 5);
                if (string.IsNullOrEmpty(json) || !json.Contains("\"status\":\"ok\""))
                    return null;

                List<SearchModel> root = null;

                try
                {
                    root = JsonConvert.DeserializeObject<List<SearchModel>>(json);
                }
                catch { }

                if (root == null || root.Count == 0)
                    return null;

                return root;
            }

            var result = await gosearch(original_title);
            if (result == null)
                result = await gosearch(title);

            if (result == null)
                return default;

            var ids = new List<int>();
            var stpl = new SimilarTpl(result.Count);

            string? enc_title = HttpUtility.UrlEncode(title);
            string? enc_original_title = HttpUtility.UrlEncode(original_title);

            string stitle = StringConvert.SearchName(title);
            string sorigtitle = StringConvert.SearchName(original_title);

            foreach (var item in result)
            {
                if (item == null)
                    continue;

                string? name = !string.IsNullOrEmpty(item.title) && !string.IsNullOrEmpty(item.original_title) ? $"{item.title} / {item.original_title}" : (item.title ?? item.original_title);

                stpl.Append(name, item.year.ToString(), string.Empty, host + $"lite/filmix?postid={item.id}&title={enc_title}&original_title={enc_original_title}", PosterApi.Size(item.poster));

                if ((!string.IsNullOrEmpty(stitle) && StringConvert.SearchName(item.title) == stitle) ||
                    (!string.IsNullOrEmpty(sorigtitle) && StringConvert.SearchName(item.original_title) == sorigtitle))
                {
                    if (item.year == year)
                        ids.Add(item.id);
                }
            }

            if (ids.Count == 1)
                return new SearchResult() { id = ids[0] };

            return new SearchResult() { similars = stpl };
        }
        #endregion

        #region getXFXTOKEN
        static long userid = 1;

        static string serverip = null;

        async ValueTask<string> getXFXTOKEN(string uid = null)
        {
            var init = AppInit.conf.FilmixPartner;

            if (serverip == null)
            {
                var myip = await Http.Get<JObject>($"{init.host}/my_ip", headers: httpHeaders(init));
                if (myip == null || string.IsNullOrWhiteSpace(myip.Value<string>("ip")))
                    return null;

                serverip = myip.Value<string>("ip");
            }

            if (userid > 20_000)
                userid = 1;
            userid++;

            if (uid != null)
            {
                using (SHA256 sha256Hash = SHA256.Create())
                {
                    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫—É –≤ –±–∞–π—Ç—ã –∏ –≤—ã—á–∏—Å–ª—è–µ–º —Ö—ç—à
                    byte[] bytes = sha256Hash.ComputeHash(Encoding.UTF8.GetBytes(uid));

                    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –ø–µ—Ä–≤—ã–µ 8 –±–∞–π—Ç —Ö—ç—à–∞ –≤ —á–∏—Å–ª–æ
                    long result = BitConverter.ToInt64(bytes, 0);
                    userid = Math.Abs(result); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                }
            }

            string XNICK = ReverseString(DateTime.Now.ToString("HHmm")) + DateTime.Now.ToString("yyyyMMdd");
            string XSAM = ReverseString(serverip.Replace(".", "")) + DateTime.Now.ToString("HHmm");

            var salt = await Http.Post<JObject>($"{init.host}/request-salt", $"key={init.APIKEY}", headers: httpHeaders(init, HeadersModel.Init(
                ("X-NICK", SHA1(XNICK)),
                ("X-SAM", SHA1(XSAM))
            )));

            if (salt == null || string.IsNullOrWhiteSpace(salt.Value<string>("salt")))
                return null;

            string token = SHA1(init.APISECRET + init.APIKEY + CrypTo.md5(array_sum(serverip) + salt.Value<string>("salt")));

            var xtk = await Http.Post<JObject>($"{init.host}/request-token", $"user_name={init.user_name}&user_passw={init.user_passw}&key={init.APIKEY}&token={token}", headers: httpHeaders(init, HeadersModel.Init("User-Id", userid.ToString())));

            if (xtk != null && !string.IsNullOrWhiteSpace(xtk.Value<string>("token")))
                return xtk.Value<string>("token");

            return null;
        }
        #endregion

        #region ReverseString / array_sum / SHA1
        static string ReverseString(string s)
        {
            char[] charArray = s.ToCharArray();
            Array.Reverse(charArray);
            return new string(charArray);
        }

        static int array_sum(string s)
        {
            List<int> mass = new List<int>();
            foreach (var num in s.Split("."))
                mass.Add(int.Parse(num));

            return mass.Sum();
        }

        static string SHA1(string IntText)
        {
            using (var sha1 = new System.Security.Cryptography.SHA1Managed())
            {
                var result = sha1.ComputeHash(Encoding.UTF8.GetBytes(IntText));
                return BitConverter.ToString(result).Replace("-", "").ToLower();
            }
        }
        #endregion
    }
}

```

## File: Online/Controllers/Videoseed.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Newtonsoft.Json.Linq;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class Videoseed : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/videoseed")]
        async public ValueTask<ActionResult> Index(string imdb_id, long kinopoisk_id, string title, string original_title, int year, int s = -1, bool rjson = false, int serial = -1)
        {
            var init = await loadKit(AppInit.conf.Videoseed);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string memKey = $"videoseed:view:{kinopoisk_id}:{imdb_id}:{original_title}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                #region search
                if (!hybridCache.TryGetValue(memKey, out (Dictionary<string, JObject> seasons, string iframe) cache))
                {
                    #region goSearch
                    async ValueTask<JToken> goSearch(bool isOk, string arg)
                    {
                        if (!isOk)
                            return null;

                        string uri = $"{init.host}/apiv2.php?item={(serial == 1 ? "serial" : "movie")}&token={init.token}" + arg;
                        var root = await Http.Get<JObject>(uri, timeoutSeconds: 8, headers: httpHeaders(init), proxy: proxy.proxy);

                        if (root == null || !root.ContainsKey("data") || root.Value<string>("status") == "error")
                        {
                            proxyManager.Refresh();
                            return null;
                        }

                        return root["data"]?.First;
                    }
                    #endregion

                    var data = await goSearch(kinopoisk_id > 0, $"&kp={kinopoisk_id}") ??
                               await goSearch(!string.IsNullOrEmpty(imdb_id), $"&tmdb={imdb_id}") ??
                               await goSearch(!string.IsNullOrEmpty(original_title), $"&q={HttpUtility.UrlEncode(original_title)}&release_year_from={year - 1}&release_year_to={year + 1}");

                    if (data == null)
                    {
                        proxyManager.Refresh();
                        return OnError();
                    }

                    if (serial == 1)
                        cache.seasons = data?["seasons"]?.ToObject<Dictionary<string, JObject>>();
                    else
                        cache.iframe = data?.Value<string>("iframe");

                    if (cache.seasons == null && string.IsNullOrEmpty(cache.iframe))
                    {
                        proxyManager.Refresh();
                        return OnError();
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(40, init: init));
                }
                #endregion

                if (cache.iframe != null)
                {
                    #region –§–∏–ª—å–º
                    var mtpl = new MovieTpl(title, original_title, 1);
                    mtpl.Append("–ü–æ-—É–º–æ–ª—á–∞–Ω–∏—é", accsArgs($"{host}/lite/videoseed/video/{AesTo.Encrypt(cache.iframe)}") + "#.m3u8", "call", vast: init.vast);

                    return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∞–ª
                    string enc_title = HttpUtility.UrlEncode(title);
                    string enc_original_title = HttpUtility.UrlEncode(original_title);

                    if (s == -1)
                    {
                        var tpl = new SeasonTpl(cache.seasons.Count);

                        foreach (var season in cache.seasons)
                        {
                            string link = $"{host}/lite/videoseed?rjson={rjson}&kinopoisk_id={kinopoisk_id}&imdb_id={imdb_id}&title={enc_title}&original_title={enc_original_title}&s={season.Key}";
                            tpl.Append($"{season.Key} —Å–µ–∑–æ–Ω", link, season.Key);
                        }

                        return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                    }
                    else
                    {
                        string sArhc = s.ToString();
                        var videos = cache.seasons.First(i => i.Key == sArhc).Value["videos"].ToObject<Dictionary<string, JObject>>();

                        var etpl = new EpisodeTpl(videos.Count);

                        foreach (var video in videos)
                        {
                            string iframe = video.Value.Value<string>("iframe");
                            etpl.Append($"{video.Key} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, video.Key, accsArgs($"{host}/lite/videoseed/video/{AesTo.Encrypt(iframe)}"), "call", vast: init.vast);
                        }

                        return ContentTo(rjson ? etpl.ToJson() : etpl.ToHtml());
                    }
                    #endregion
                }
            });
        }


        #region Video
        [HttpGet]
        [Route("lite/videoseed/video/{*iframe}")]
        async public ValueTask<ActionResult> Video(string iframe)
        {
            var init = await loadKit(AppInit.conf.Videoseed);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            iframe = AesTo.Decrypt(iframe);
            if (string.IsNullOrEmpty(iframe))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string memKey = $"videoseed:video:{iframe}:{proxyManager.CurrentProxyIp}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out string location))
                {
                    var headers = httpHeaders(init);

                    try
                    {
                        using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                        {
                            var page = await browser.NewPageAsync(init.plugin, proxy: proxy.data, headers: headers?.ToDictionary()).ConfigureAwait(false);
                            if (page == null)
                                return null;

                            await page.AddInitScriptAsync("localStorage.setItem('pljsquality', '1080p');").ConfigureAwait(false);

                            await page.RouteAsync("**/*", async route =>
                            {
                                try
                                {
                                    if (!string.IsNullOrEmpty(location))
                                    {
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (route.Request.Url.Contains(".m3u8") || (route.Request.Url.Contains(".mp4") && !route.Request.Url.Contains(".ts")))
                                        location = route.Request.Url;

                                    if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                        return;

                                    await route.ContinueAsync();
                                }
                                catch { }
                            });

                            var options = new PageGotoOptions()
                            {
                                Timeout = 15_000,
                                WaitUntil = WaitUntilState.NetworkIdle
                            };

                            var result = await page.GotoAsync(iframe, options).ConfigureAwait(false);
                            if (result != null && string.IsNullOrEmpty(location))
                            {
                                string html = await page.ContentAsync().ConfigureAwait(false);
                                location = Regex.Match(html, "<video preload=\"none\" src=\"(https?://[^\"]+)\"").Groups[1].Value;
                                if (!location.Contains(".m3u") && !location.Contains(".mp4"))
                                    location = null;
                            }

                            PlaywrightBase.WebLog("SET", iframe, location, proxy.data);
                        }

                        if (string.IsNullOrEmpty(location))
                        {
                            proxyManager.Refresh();
                            return OnError();
                        }
                    }
                    catch
                    {
                        return OnError();
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, location, cacheTime(20));
                }

                string link = HostStreamProxy(init, location, proxy: proxy.proxy, headers: HeadersModel.Init("referer", iframe));
                return ContentTo(VideoTpl.ToJson("play", link, "auto", vast: init.vast));
            });
        }
        #endregion
    }
}

```

## File: Online/Controllers/Alloha.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Alloha;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class Alloha : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.Alloha);

        #region Initialization
        ValueTask<AllohaSettings> Initialization()
        {
            return loadKit(AppInit.conf.Alloha, (j, i, c) =>
            {
                if (j.ContainsKey("m4s"))
                    i.m4s = c.m4s;

                if (j.ContainsKey("linkhost"))
                    i.linkhost = c.linkhost;

                if (j.ContainsKey("reserve"))
                    i.reserve = c.reserve;

                i.secret_token = c.secret_token;
                i.token = c.token;
                return i;
            });
        }
        #endregion

        [HttpGet]
        [Route("lite/alloha")]
        async public ValueTask<ActionResult> Index(string orid, string imdb_id, long kinopoisk_id, string title, string original_title, int serial, string original_language, int year, string t, int s = -1, bool origsource = false, bool rjson = false, bool similar = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (similar)
                return await SpiderSearch(title, origsource, rjson);

            var result = await search(init, orid, imdb_id, kinopoisk_id, title, serial, original_language, year);
            if (result.category_id == 0)
                return OnError("data", proxyManager, result.refresh_proxy);

            if (result.data == null)
                return Ok();

            if (origsource)
                return ContentTo(JsonConvert.SerializeObject(result.data));

            JToken data = result.data;

            string defaultargs = $"&orid={orid}&imdb_id={imdb_id}&kinopoisk_id={kinopoisk_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&serial={serial}&year={year}&original_language={original_language}";

            if (result.category_id is 1 or 3)
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title);
                bool directors_cut = data.Value<bool>("available_directors_cut");

                foreach (var translation in data.Value<JObject>("translation_iframe").ToObject<Dictionary<string, Dictionary<string, object>>>())
                {
                    string link = $"{host}/lite/alloha/video?t={translation.Key}&token_movie={result.data.Value<string>("token_movie")}" + defaultargs;
                    string streamlink = accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true");

                    bool uhd = false;
                    if (translation.Value.TryGetValue("uhd", out object _uhd))
                        uhd = _uhd.ToString().ToLower() == "true" && init.m4s;

                    if (directors_cut && translation.Key == "66")
                        mtpl.Append("–†–µ–∂–∏—Å—Å–µ—Ä—Å–∫–∞—è –≤–µ—Ä—Å–∏—è", $"{link}&directors_cut=true", "call", $"{streamlink}&directors_cut=true", voice_name: uhd ? "2160p" : translation.Value["quality"].ToString(), quality: uhd ? "2160p" : "");

                    mtpl.Append(translation.Value["name"].ToString(), link, "call", streamlink, voice_name: uhd ? "2160p" : translation.Value["quality"].ToString(), quality: uhd ? "2160p" : "");
                }

                return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∞–ª
                if (s == -1)
                {
                    var tpl = new SeasonTpl(result.data.Value<bool>("uhd") && init.m4s ? "2160p" : null);

                    foreach (var season in data.Value<JObject>("seasons").ToObject<Dictionary<string, object>>().Reverse())
                        tpl.Append($"{season.Key} —Å–µ–∑–æ–Ω", $"{host}/lite/alloha?rjson={rjson}&s={season.Key}{defaultargs}", season.Key);

                    return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                }
                else
                {
                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var vtpl = new VoiceTpl();
                    var temp_translation = new HashSet<string>();

                    string activTranslate = t;

                    foreach (var episodes in data.Value<JObject>("seasons").GetValue(s.ToString()).Value<JObject>("episodes").ToObject<Dictionary<string, Episode>>().Select(i => i.Value.translation))
                    {
                        foreach (var translation in episodes)
                        {
                            if (temp_translation.Contains(translation.Value.translation) || translation.Value.translation.ToLower().Contains("—Å—É–±—Ç–∏—Ç—Ä—ã"))
                                continue;

                            temp_translation.Add(translation.Value.translation);

                            if (string.IsNullOrWhiteSpace(activTranslate))
                                activTranslate = translation.Key;

                            vtpl.Append(translation.Value.translation, activTranslate == translation.Key, $"{host}/lite/alloha?rjson={rjson}&s={s}&t={translation.Key}{defaultargs}");
                        }
                    }
                    #endregion

                    var etpl = new EpisodeTpl();
                    string sArhc = s.ToString();

                    foreach (var episode in data.Value<JObject>("seasons").GetValue(sArhc).Value<JObject>("episodes").ToObject<Dictionary<string, Episode>>().Reverse())
                    {
                        if (!string.IsNullOrWhiteSpace(activTranslate) && !episode.Value.translation.ContainsKey(activTranslate))
                            continue;

                        string link = $"{host}/lite/alloha/video?t={activTranslate}&s={s}&e={episode.Key}&token_movie={result.data.Value<string>("token_movie")}" + defaultargs;
                        string streamlink = accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true");

                        etpl.Append($"{episode.Key} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.Key, link, "call", streamlink: streamlink);
                    }

                    if (rjson)
                        return ContentTo(etpl.ToJson(vtpl));

                    return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                }
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/alloha/video")]
        [Route("lite/alloha/video.m3u8")]
        async public ValueTask<ActionResult> Video(string token_movie, string title, string original_title, string t, int s, int e, bool play, bool directors_cut)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxy = proxyManager.BaseGet();

            return await InvkSemaphore(init, $"alloha:view:stream:{init.secret_token}:{token_movie}:{t}:{s}:{e}:{init.m4s}:{directors_cut}", async () =>
            {
                if (!string.IsNullOrEmpty(init.secret_token))
                {
                    #region –ü—Ä—è–º—ã–µ —Å—Å—ã–ª–∫–∏
                    string userIp = requestInfo.IP;
                    if (init.localip || init.streamproxy)
                    {
                        userIp = await mylocalip();
                        if (userIp == null)
                            return OnError("userIp");
                    }

                    string memKey = $"alloha:view:stream:{init.secret_token}:{token_movie}:{t}:{s}:{e}:{userIp}:{init.m4s}:{directors_cut}";
                    if (!hybridCache.TryGetValue(memKey, out JToken data))
                    {
                        #region url –∑–∞–ø—Ä–æ—Å–∞
                        string uri = $"{init.linkhost}/direct?secret_token={init.secret_token}&token_movie={token_movie}";

                        uri += $"&ip={userIp}&translation={t}";

                        if (s > 0)
                            uri += $"&season={s}";

                        if (e > 0)
                            uri += $"&episode={e}";

                        if (init.m4s)
                            uri += "&av1=true";

                        if (directors_cut)
                            uri += "&directors_cut";
                        #endregion

                        var root = await Http.Get<JObject>(uri, timeoutSeconds: 8, proxy: proxy.proxy, headers: httpHeaders(init));
                        if (root == null)
                            return OnError("json", proxyManager);

                        if (!root.ContainsKey("data"))
                            return OnError("data");

                        proxyManager.Success();

                        data = root["data"];
                        hybridCache.Set(memKey, data, cacheTime(10, init: init));
                    }

                    #region subtitle
                    var subtitles = new SubtitleTpl();

                    try
                    {
                        foreach (var sub in data["file"]["tracks"])
                            subtitles.Append(sub.Value<string>("label"), sub.Value<string>("src"));
                    }
                    catch { }
                    #endregion

                    List<(string link, string quality)> streams = null;

                    foreach (var hlsSource in data["file"]["hlsSource"])
                    {
                        // first or default
                        if (streams == null || hlsSource.Value<bool>("default"))
                        {
                            streams = new List<(string link, string quality)>(6);

                            foreach (var q in hlsSource["quality"].ToObject<Dictionary<string, string>>())
                            {
                                string file = q.Value;
                                if (init.reserve)
                                    file += " or " + hlsSource["reserve"][q.Key].ToString();

                                streams.Add((HostStreamProxy(init, file, proxy: proxy.proxy), $"{q.Key}p"));
                            }
                        }
                    }

                    if (streams == null || streams.Count == 0)
                        return OnError("streams");

                    var streamquality = new StreamQualityTpl(streams);

                    if (play)
                        return RedirectToPlay(streamquality.Firts().link);

                    #region segments
                    var segments = new SegmentTpl();

                    var dfile = data["file"];
                    string skipTime = dfile.Value<string>("skipTime");
                    string removeTime = dfile.Value<string>("removeTime");

                    if (skipTime != null && skipTime.Contains("-"))
                    {
                        foreach (string skp in skipTime.Split(","))
                        {
                            var t = skp.Trim().Split('-');
                            if (t.Length >= 2 && int.TryParse(t[0].Trim(), out int start) && int.TryParse(t[1].Trim(), out int end))
                                segments.skip(start, end);
                        }
                    }

                    if (removeTime != null && removeTime.Contains("-"))
                    {
                        foreach (string skp in removeTime.Split(","))
                        {
                            var t = skp.Trim().Split('-');
                            if (t.Length >= 2 && int.TryParse(t[0].Trim(), out int start) && int.TryParse(t[1].Trim(), out int end))
                                segments.ad(start, end);
                        }
                    }
                    #endregion

                    return ContentTo(VideoTpl.ToJson("play", streamquality.Firts().link, (title ?? original_title),
                        streamquality: streamquality,
                        vast: init.vast,
                        subtitles: subtitles,
                        segments: segments,
                        hls_manifest_timeout: (int)TimeSpan.FromSeconds(20).TotalMilliseconds
                    ));
                    #endregion
                }
                else
                {
                    #region Playwright
                    init.streamproxy = true; // force streamproxy

                    string memKey = $"alloha:black_magic:{proxy.data.ip}:{token_movie}:{t}:{s}:{e}";
                    if (!hybridCache.TryGetValue(memKey, out (string hls, List<HeadersModel> headers) cache))
                    {
                        if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                            return OnError();

                        using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                        {
                            string targetHost = "https://alloha.tv";

                            string targetUrl = $"{init.linkhost}/?token_movie={token_movie}&translation={t}&token={init.token}";
                            if (s > 0)
                                targetUrl += $"&season={s}&episode={e}";

                            var page = await browser.NewPageAsync(init.plugin, proxy: proxy.data, headers: Http.defaultFullHeaders).ConfigureAwait(false);
                            if (page == null)
                                return null;

                            string q = init.m4s ? "2160" : "1080";
                            await page.AddInitScriptAsync($"localStorage.setItem('allplay', '{{\"captionParam\":{{\"fontSize\":\"100%\",\"colorText\":\"–ë–µ–ª—ã–π\",\"colorBackground\":\"–ß–µ—Ä–Ω—ã–π\",\"opacityText\":\"100%\",\"opacityBackground\":\"75%\",\"styleText\":\"–ë–µ–∑ –∫–æ–Ω—Ç—É—Ä–∞\",\"weightText\":\"–û–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç\"}},\"quality\":{q},\"volume\":0.5,\"muted\":false}}');");

                            await page.RouteAsync("**/*", async route =>
                            {
                                try
                                {
                                    if (browser.IsCompleted || route.Request.Url.Contains("blank.mp4") || route.Request.Url.Contains("googleapis.com"))
                                    {
                                        PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (route.Request.Url.StartsWith(targetHost))
                                    {
                                        await route.FulfillAsync(new RouteFulfillOptions
                                        {
                                            Body = PlaywrightBase.IframeHtml(targetUrl)
                                        });
                                    }
                                    else
                                    {
                                        if (route.Request.Url.Contains("/m/"))
                                        {
                                            await route.ContinueAsync();

                                            var response = await page.WaitForResponseAsync(route.Request.Url);
                                            if (response != null && response.Headers.ContainsKey("location"))
                                            {
                                                response = await page.WaitForResponseAsync(response.Headers["location"]);
                                                if (response != null)
                                                {
                                                    cache.headers = HeadersModel.Init(Http.defaultFullHeaders,
                                                        ("sec-fetch-dest", "empty"),
                                                        ("sec-fetch-mode", "cors"),
                                                        ("sec-fetch-site", "cross-site")
                                                    );

                                                    foreach (var item in response.Request.Headers)
                                                    {
                                                        if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                                            continue;

                                                        if (!Http.defaultFullHeaders.ContainsKey(item.Key.ToLower()))
                                                            cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                                    }

                                                    PlaywrightBase.ConsoleLog($"Playwright: SET {response.Request.Url}", cache.headers);
                                                    browser.SetPageResult(response.Request.Url);
                                                }
                                            }
                                        }
                                        else
                                        {
                                            if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                                return;

                                            await route.ContinueAsync();
                                        }
                                    }
                                }
                                catch { }
                            });

                            PlaywrightBase.GotoAsync(page, targetHost);
                            cache.hls = await browser.WaitPageResult();
                        }

                        if (string.IsNullOrEmpty(cache.hls))
                            return OnError();

                        hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                    }

                    var streamquality = new StreamQualityTpl();
                    streamquality.Append(HostStreamProxy(init, cache.hls, headers: cache.headers), "auto");

                    if (play)
                        return RedirectToPlay(streamquality.Firts().link);

                    return ContentTo(VideoTpl.ToJson("play", streamquality.Firts().link, title ?? original_title,
                        streamquality: streamquality,
                        vast: init.vast,
                        headers: cache.headers
                    ));
                    #endregion
                }
            });
        }
        #endregion

        #region SpiderSearch
        [HttpGet]
        [Route("lite/alloha-search")]
        async public ValueTask<ActionResult> SpiderSearch(string title, bool origsource = false, bool rjson = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var cache = await InvokeCache<JArray>($"alloha:search:{title}", cacheTime(40, init: init), proxyManager, async res =>
            {
                var root = await Http.Get<JObject>($"{init.apihost}/?token={init.token}&name={HttpUtility.UrlEncode(title)}&list", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                if (root == null || !root.ContainsKey("data"))
                    return res.Fail("data");

                return root["data"].ToObject<JArray>();
            });

            return OnResult(cache, () =>
            {
                var stpl = new SimilarTpl(cache.Value.Count);

                foreach (var j in cache.Value)
                {
                    string uri = $"{host}/lite/alloha?orid={j.Value<string>("token_movie")}";
                    stpl.Append(j.Value<string>("name") ?? j.Value<string>("original_name"), j.Value<int>("year").ToString(), string.Empty, uri, PosterApi.Size(j.Value<string>("poster")));
                }

                return rjson ? stpl.ToJson() : stpl.ToHtml();

            }, origsource: origsource);
        }
        #endregion


        #region search
        async ValueTask<(bool refresh_proxy, int category_id, JToken data)> search(AllohaSettings init, string token_movie, string imdb_id, long kinopoisk_id, string title, int serial, string original_language, int year)
        {
            string memKey = $"alloha:view:{kinopoisk_id}:{imdb_id}";
            if (0 >= kinopoisk_id && string.IsNullOrEmpty(imdb_id))
                memKey = $"alloha:viewsearch:{title}:{serial}:{original_language}:{year}";

            if (!string.IsNullOrEmpty(token_movie))
                memKey = $"alloha:view:{token_movie}";

            JObject root = null;

            if (!hybridCache.TryGetValue(memKey, out (int category_id, JToken data) res))
            {
                if (memKey.Contains(":viewsearch:"))
                {
                    if (string.IsNullOrWhiteSpace(title) || year == 0)
                        return default;

                    root = await Http.Get<JObject>($"{init.apihost}/?token={init.token}&name={HttpUtility.UrlEncode(title)}&list={(serial == 1 ? "serial" : "movie")}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                    if (root == null)
                        return (true, 0, null);

                    if (root.ContainsKey("data"))
                    {
                        string stitle = title.ToLower();

                        foreach (var item in root["data"])
                        {
                            if (item.Value<string>("name")?.ToLower()?.Trim() == stitle)
                            {
                                int y = item.Value<int>("year");
                                if (y > 0 && (y == year || y == (year - 1) || y == (year + 1)))
                                {
                                    if (original_language == "ru" && item.Value<string>("country")?.ToLower() != "—Ä–æ—Å—Å–∏—è")
                                        continue;

                                    res.data = item;
                                    res.category_id = item.Value<int>("category_id");
                                    break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (!string.IsNullOrEmpty(imdb_id))
                        root = await Http.Get<JObject>($"{init.apihost}/?token={init.token}&imdb={imdb_id}&token_movie={token_movie}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                    
                    if ((root == null || !root.ContainsKey("data")) && kinopoisk_id > 0)
                        root = await Http.Get<JObject>($"{init.apihost}/?token={init.token}&kp={kinopoisk_id}&token_movie={token_movie}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));

                    if (root == null)
                        return (true, 0, null);

                    if (root.ContainsKey("data"))
                    {
                        res.data = root.GetValue("data");
                        res.category_id = res.data.Value<int>("category");
                    }
                }

                if (res.data != null)
                    proxyManager.Success();

                if (res.data != null || (root.ContainsKey("error_info") && root.Value<string>("error_info") == "not movie"))
                    hybridCache.Set(memKey, res, cacheTime(res.category_id is 1 or 3 ? 120 : 40, init: init));
                else
                    hybridCache.Set(memKey, res, cacheTime(2, init: init));
            }

            return (false, res.category_id, res.data);
        }
        #endregion
    }
}

```

## File: Online/Controllers/CDNvideohub.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;

namespace Online.Controllers
{
    public class CDNvideohub : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/cdnvideohub")]
        async public ValueTask<ActionResult> Index(string title, string original_title, long kinopoisk_id, string t, int s = -1, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.CDNvideohub);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            reset:
            var cache = await InvokeCache<JObject>($"cdnvideohub:view:{kinopoisk_id}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string uri = $"{init.corsHost()}/api/v1/player/sv/playlist?pub=12&aggr=kp&id={kinopoisk_id}";

                var root = rch.enable 
                    ? await rch.Get<JObject>(uri, httpHeaders(init)) 
                    : await Http.Get<JObject>(uri, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));

                if (root == null || !root.ContainsKey("items"))
                    return res.Fail("root");

                var videos = root["items"] as JArray;
                if (videos == null || videos.Count == 0)
                    return res.Fail("video");

                return root;
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => 
            {
                if (cache.Value.Value<bool>("isSerial"))
                {
                    #region –°–µ—Ä–∏–∞–ª
                    string defaultargs = $"&rjson={rjson}&kinopoisk_id={kinopoisk_id}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}";

                    if (s == -1)
                    {
                        #region –°–µ–∑–æ–Ω—ã
                        var tpl = new SeasonTpl();
                        var hash = new HashSet<int>();

                        foreach (var video in cache.Value["items"].OrderBy(i => i.Value<int>("season")))
                        {
                            int season = video.Value<int>("season");

                            if (hash.Contains(season))
                                continue;

                            hash.Add(season);
                            tpl.Append($"{season} —Å–µ–∑–æ–Ω", $"{host}/lite/cdnvideohub?s={season}{defaultargs}", season);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                        #endregion
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();
                        var tmpVoice = new HashSet<string>();

                        foreach (var video in cache.Value["items"])
                        {
                            if (video.Value<int>("season") != s)
                                continue;

                            string voice_studio = video.Value<string>("voiceStudio");
                            if (string.IsNullOrEmpty(voice_studio) || tmpVoice.Contains(voice_studio))
                                continue;

                            tmpVoice.Add(voice_studio);

                            if (string.IsNullOrEmpty(t))
                                t = voice_studio;

                            vtpl.Append(voice_studio, t == voice_studio, $"{host}/lite/cdnvideohub?s={s}&t={HttpUtility.UrlEncode(voice_studio)}{defaultargs}");
                        }
                        #endregion

                        var etpl = new EpisodeTpl();
                        string sArhc = s.ToString();
                        var tmpEpisode = new HashSet<int>();

                        foreach (var video in cache.Value["items"].OrderBy(i => i.Value<int>("episode")))
                        {
                            if (video.Value<int>("season") != s || video.Value<string>("voiceStudio") != t)
                                continue;

                            string vkId = video.Value<string>("vkId");
                            if (string.IsNullOrEmpty(vkId))
                                continue;

                            int episode = video.Value<int>("episode");

                            if (tmpEpisode.Contains(episode))
                                continue;

                            tmpEpisode.Add(episode);

                            string link = accsArgs($"{host}/lite/cdnvideohub/video.m3u8?vkId={vkId}&title={HttpUtility.UrlEncode(title)}");

                            etpl.Append($"{episode} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, episode.ToString(), link, "call", streamlink: $"{link}&play=true", vast: init.vast);
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                    #endregion
                }
                else
                {
                    #region –§–∏–ª—å–º
                    var mtpl = new MovieTpl(title, original_title);

                    foreach (var video in cache.Value["items"])
                    {
                        string voice = video.Value<string>("voiceStudio") ?? video.Value<string>("voiceType");
                        string vkId = video.Value<string>("vkId");

                        string link = accsArgs($"{host}/lite/cdnvideohub/video.m3u8?vkId={vkId}&title={HttpUtility.UrlEncode(title)}");

                        mtpl.Append(voice, link, "call", vast: init.vast);
                    }

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                    #endregion
                }

            }, origsource: origsource, gbcache: !rch.enable);
        }


        #region Video
        [HttpGet]
        [Route("lite/cdnvideohub/video.m3u8")]
        async public ValueTask<ActionResult> Video(string vkId, string title, bool play)
        {
            var init = await loadKit(AppInit.conf.CDNvideohub);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            reset: 
            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("cors,web", out string rch_error))
                return ShowError(rch_error);

            var cache = await InvokeCache<string>(rch.ipkey($"cdnvideohub:video:{vkId}", proxyManager), cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                if (rch.IsNotConnected())
                    return res.Fail(rch.connectionMsg);

                string uri = $"{init.corsHost()}/api/v1/player/sv/video/{vkId}";

                string iframe;
                if (rch.enable)
                {
                    iframe = await rch.Get(init.cors(uri), headers: httpHeaders(init));
                }
                else
                {
                    iframe = await Http.Get(uri, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init), httpversion: 2);
                }

                if (iframe == null)
                    return res.Fail("iframe");

                string hls = Regex.Match(iframe, "\"hlsUrl\":\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(hls))
                    return res.Fail("hls");

                return hls.Replace("u0026", "&").Replace("\\", "");
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            if (!cache.IsSuccess)
                return OnError(cache.ErrorMsg, gbcache: !rch.enable);

            string link = HostStreamProxy(init, cache.Value, proxy: proxyManager.Get());

            if (play)
                return RedirectToPlay(link);

            return ContentTo(VideoTpl.ToJson("play", link, title, vast: init.vast));
        }
        #endregion
    }
}

```

## File: Online/Controllers/GetsTV.cs
```
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;
using System.Text;

namespace Online.Controllers
{
    public class GetsTV : BaseOnlineController
    {
        #region Bind
        [HttpGet]
        [AllowAnonymous]
        [Route("/lite/getstv/bind")]
        async public Task<ActionResult> Bind(string login, string pass)
        {
            string html = string.Empty;

            if (string.IsNullOrWhiteSpace(login) || string.IsNullOrWhiteSpace(pass))
            {
                return ContentTo("–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç–∞ getstv.com <br> <br><form method=\"get\" action=\"/lite/getstv/bind\"><input type=\"text\" name=\"login\" placeholder=\"email\"> &nbsp; &nbsp; <input type=\"text\" name=\"pass\" placeholder=\"–ø–∞—Ä–æ–ª—å\"><br><br><button>–ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è</button></form>");
            }
            else
            {
                string postdata = $"{{\"email\":\"{login}\",\"password\":\"{pass}\",\"fingerprint\":\"{CrypTo.md5(DateTime.Now.ToString())}\",\"device\":{{}}}}";
                var result =  await Http.Post<JObject>($"{AppInit.conf.GetsTV.corsHost()}/api/login", new System.Net.Http.StringContent(postdata, Encoding.UTF8, "application/json"), headers: httpHeaders(AppInit.conf.GetsTV));

                if (result == null)
                    return ContentTo("–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ ;(");

                string token = result.Value<string>("token");
                if (string.IsNullOrEmpty(token))
                    return ContentTo(JsonConvert.SerializeObject(result, Formatting.Indented));

                return ContentTo("–î–æ–±–∞–≤—å—Ç–µ –≤ init.conf<br><br>\"GetsTV\": {<br>&nbsp;&nbsp;\"enable\": true,<br>&nbsp;&nbsp;\"token\": \"" + token + "\"<br>}");
            }
        }
        #endregion

        ProxyManager proxyManager = new ProxyManager(AppInit.conf.GetsTV);

        [HttpGet]
        [Route("lite/getstv")]
        async public ValueTask<ActionResult> Index(string orid, string title, string original_title, int year, int t = -1, int s = -1, bool rjson = false, bool similar = false, string source = null, string id = null)
        {
            var init = await loadKit(AppInit.conf.GetsTV);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (string.IsNullOrEmpty(orid) && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() == "getstv")
                    orid = id;
            }

            if (string.IsNullOrEmpty(orid))
            {
                var result = await search(init, title, original_title, year);

                if (result.id != null && similar == false)
                    orid = result.id;
                else
                {
                    if (result.similar.data == null || result.similar.data.Count == 0)
                        return OnError("data");

                    return ContentTo(rjson ? result.similar.ToJson() : result.similar.ToHtml());
                }
            }

            var cache = await InvokeCache<JObject>($"getstv:movies:{orid}", cacheTime(20, init: init), proxyManager, async res =>
            {
                var headers = httpHeaders(init, HeadersModel.Init("authorization", $"Bearer {init.token}"));
                var root = await Http.Get<JObject>($"{init.corsHost()}/api/movies/{orid}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: headers);
                if (root == null)
                    return res.Fail("movies");

                return root;
            });

            return OnResult(cache, () => 
            {
                string defaultargs = $"&orid={orid}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&year={year}";

                if (cache.Value.Value<string>("type") == "movie")
                {
                    #region –§–∏–ª—å–º
                    var mtpl = new MovieTpl(title, original_title);

                    foreach (var media in cache.Value["media"])
                    {
                        string link = $"{host}/lite/getstv/video.m3u8?id={media.Value<string>("_id")}";
                        string streamlink = accsArgs($"{link}&play=true");

                        mtpl.Append(media.Value<string>("trName"), link, "call", streamlink, details: media.Value<string>("sourceType"));
                    }

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∞–ª
                    if (s == -1)
                    {
                        var tpl = new SeasonTpl();

                        foreach (var season in cache.Value["seasons"])
                        {
                            int seasonNum = season.Value<int>("seasonNum");
                            tpl.Append($"{seasonNum} —Å–µ–∑–æ–Ω", $"{host}/lite/getstv?rjson={rjson}&s={seasonNum}{defaultargs}", seasonNum);
                        }

                        return rjson ? tpl.ToJson() : tpl.ToHtml();
                    }
                    else
                    {
                        var episodes = cache.Value["seasons"].First(i => i.Value<int>("seasonNum") == s)["episodes"];

                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();
                        var temp_translation = new HashSet<int>();

                        foreach (var e in episodes)
                        {
                            foreach (var tr in e["trs"])
                            {
                                int trId = tr.Value<int>("trId");
                                if (temp_translation.Contains(trId))
                                    continue;

                                temp_translation.Add(trId);

                                if (t == -1)
                                    t = trId;

                                vtpl.Append(tr.Value<string>("trName"), t == trId, $"{host}/lite/getstv?rjson={rjson}&s={s}&t={trId}{defaultargs}");
                            }
                        }
                        #endregion

                        var etpl = new EpisodeTpl();
                        string sArhc = s.ToString();

                        foreach (var episode in episodes)
                        {
                            foreach (var tr in episode["trs"])
                            {
                                if (tr.Value<int>("trId") == t)
                                {
                                    int e = episode.Value<int>("episodeNum");
                                    string link = $"{host}/lite/getstv/video.m3u8?id={tr.Value<string>("_id")}";
                                    string streamlink = accsArgs($"{link}&play=true");

                                    etpl.Append($"{e} —Å–µ—Ä–∏—è", title ?? original_title, sArhc, e.ToString(), link, "call", streamlink: streamlink);
                                    break;
                                }
                            }
                        }

                        if (rjson)
                            return etpl.ToJson(vtpl);

                        return vtpl.ToHtml() + etpl.ToHtml();
                    }
                    #endregion
                }
            });
        }


        #region Video
        [HttpGet]
        [Route("lite/getstv/video.m3u8")]
        async public ValueTask<ActionResult> Video(string id, bool play)
        {
            var init = await loadKit(AppInit.conf.GetsTV);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxy = proxyManager.Get();

            string memKey = $"getstv:view:stream:{id}:{init.token}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out JObject root))
                {
                    var headers = httpHeaders(init, HeadersModel.Init("authorization", $"Bearer {init.token}"));
                    root = await Http.Get<JObject>($"{init.corsHost()}/api/media/{id}?format=m3u8&protocol=https", timeoutSeconds: 8, proxy: proxy, headers: headers);
                    if (root == null)
                        return OnError("json", proxyManager);

                    if (!root.ContainsKey("resolutions"))
                        return OnError("resolutions");

                    proxyManager.Success();
                    hybridCache.Set(memKey, root, cacheTime(10, init: init));
                }

                #region subtitle
                var subtitles = new SubtitleTpl();

                try
                {
                    foreach (var sub in root["subtitles"])
                        subtitles.Append(sub.Value<string>("lang"), sub.Value<string>("url"));
                }
                catch { }
                #endregion

                var streamquality = new StreamQualityTpl();

                foreach (var r in root["resolutions"])
                    streamquality.Append(HostStreamProxy(init, r.Value<string>("url"), proxy: proxy), $"{r.Value<int>("type")}p");

                if (!streamquality.Any())
                    return OnError("stream");

                if (play)
                    return RedirectToPlay(streamquality.Firts().link);

                var titleObj = root["media"]["movie"]["title"] as JObject;
                string titleRu = titleObj?["ru"]?.ToString();
                string titleEn = titleObj?["en"]?.ToString();

                string name = titleRu ?? titleEn;
                if (titleRu != null && titleEn != null)
                    name = $"{titleRu} / {titleEn}";

                return ContentTo(VideoTpl.ToJson("play", streamquality.Firts().link, name,
                    streamquality: streamquality,
                    vast: init.vast,
                    subtitles: subtitles
                ));
            });
        }
        #endregion

        #region SpiderSearch
        [HttpGet]
        [Route("lite/getstv-search")]
        async public ValueTask<ActionResult> SpiderSearch(string title, bool rjson = false)
        {
            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var init = await loadKit(AppInit.conf.GetsTV);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var result = await search(init, title, null, 0);
            if (result.similar.data?.Count == 0)
                return OnError("data");

            return ContentTo(rjson ? result.similar.ToJson() : result.similar.ToHtml());
        }
        #endregion


        #region search
        async ValueTask<(string id, SimilarTpl similar)> search(OnlinesSettings init, string title, string original_title, int year)
        {
            if (string.IsNullOrWhiteSpace(title) || string.IsNullOrEmpty(init.token))
                return default;

            string memKey = $"getstv:search:{title ?? original_title}";
            if (!hybridCache.TryGetValue(memKey, out JArray root))
            {
                var headers = httpHeaders(init, HeadersModel.Init("authorization", $"Bearer {init.token}"));
                root = await Http.Get<JArray>($"{init.corsHost()}/api/movies?skip=0&sort=updated&searchText={HttpUtility.UrlEncode(title)}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: headers);
                if (root == null)
                {
                    proxyManager.Refresh();
                    return default;
                }

                proxyManager.Success();
                hybridCache.Set(memKey, root, cacheTime(20, init: init));
            }

            List<string> ids = new List<string>();
            var stpl = new SimilarTpl(root.Count);

            string stitle = StringConvert.SearchName(title);
            string soriginal_title = StringConvert.SearchName(original_title);

            foreach (var j in root)
            {
                string uri = $"{host}/lite/getstv?orid={j.Value<string>("_id")}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&year={year}";

                var titleObj = j["title"] as JObject;
                string titleRu = titleObj?["ru"]?.ToString();
                string titleEn = titleObj?["en"]?.ToString();

                string name = titleRu ?? titleEn;
                if (titleRu != null && titleEn != null)
                    name = $"{titleRu} / {titleEn}";

                int released = j.Value<DateTime>("released").Year;
                string img = $"https://img.getstv.com/poster/cover/345x518/{j.Value<string>("poster")}.jpg";
                stpl.Append(name, released.ToString(), j.Value<string>("contentType"), uri, img);

                if ((titleRu != null && (StringConvert.SearchName(titleRu) == stitle || StringConvert.SearchName(titleRu) == soriginal_title)) ||
                    (titleEn != null && (StringConvert.SearchName(titleEn) == stitle || StringConvert.SearchName(titleEn) == soriginal_title)))
                {
                    if (released == year)
                        ids.Add(j.Value<string>("_id"));
                }
            }

            if (ids.Count == 1)
                return (ids[0], stpl);

            return (null, stpl);
        }
        #endregion
    }
}

```

## File: Online/Controllers/Kinogo.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;
using System.Net;

namespace Online.Controllers
{
    public class Kinogo : BaseOnlineController
    {
        public class SearchModel
        {
            public string link { get; set; }

            public SimilarTpl? similar { get; set; }
        }

        [HttpGet]
        [Route("lite/kinogo")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int year, bool rjson, string href, bool similar, int s = -1, int t = -1)
        {
            var init = await loadKit(AppInit.conf.Kinogo);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            #region search
            if (string.IsNullOrEmpty(href))
            {
                if (string.IsNullOrEmpty(title))
                    return OnError("search params");

                reset_search:
                var search = await InvokeCache<SearchModel>($"kinogo:search:{title}:{year}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string data = $"do=search&subaction=search&search_start=0&full_search=0&result_from=1&story={HttpUtility.UrlEncode(title)}";

                    string searchHtml = rch.enable 
                        ? await rch.Post($"{init.corsHost()}/index.php?do=search", data, httpHeaders(init)) 
                        : await Http.Post($"{init.corsHost()}/index.php?do=search", data, timeoutSeconds: 8, proxy: proxy.proxy, headers: httpHeaders(init));

                    if (searchHtml == null)
                        return res.Fail("search");

                    var result = SearchResult(searchHtml, title, year);
                    if (result == null)
                        return res.Fail("search-result");

                    return result;
                });

                if (similar || string.IsNullOrEmpty(search.Value?.link))
                    return OnResult(search, () => rjson ? search.Value.similar.Value.ToJson() : search.Value.similar.Value.ToHtml());

                if (string.IsNullOrEmpty(search.Value?.link))
                {
                    if (IsRhubFallback(search, init))
                        goto reset_search;

                    return OnError();
                }

                href = search.Value?.link;
            }
            #endregion

            if (string.IsNullOrEmpty(href))
                return OnError();

            #region embed
            reset_embed:
            var cache = await InvokeCache<JArray>(rch.ipkey(href, proxyManager), cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string targetHref = $"{init.corsHost()}/{href}";

                string html = rch.enable 
                    ? await rch.Get(targetHref, httpHeaders(init)) 
                    : await Http.Get(init.cors(targetHref), timeoutSeconds: 8, proxy: proxy.proxy, headers: httpHeaders(init));

                if (html == null) 
                    return res.Fail("html");

                string iframe = Regex.Match(html, "<iframe [^>]+data-src=\"([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(iframe))
                    return res.Fail("iframe");

                string embedUrl = iframe.StartsWith("//") ? $"https:{iframe}" : iframe;
                var embedHeaders = httpHeaders(init, HeadersModel.Init("referer", targetHref));

                string embedHtml = rch.enable 
                    ? await rch.Get(init.cors(embedUrl), embedHeaders) 
                    : await PlaywrightBrowser.Get(init, init.cors(embedUrl), headers: embedHeaders, proxy.data);

                if (embedHtml == null)
                    return res.Fail("embed");

                string playlistPath = Regex.Match(embedHtml, "\"file\":\"(/playlist/[^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(playlistPath))
                    return res.Fail("playlist");

                string playlistUrl = Regex.Match(embedUrl, "^(https?://[^/]+)").Groups[1].Value + playlistPath;
                var playlistHeaders = httpHeaders(init, HeadersModel.Init("referer", embedUrl));

                string playlistJson = rch.enable 
                    ? await rch.Get(init.cors(playlistUrl), playlistHeaders) 
                    : await PlaywrightBrowser.Get(init, init.cors(playlistUrl), headers: playlistHeaders, proxy.data);

                if (playlistJson == null)
                    return res.Fail("playlist-json");

                try
                {
                    var playlist = JArray.Parse(playlistJson);
                    if (playlist == null || playlist.Count == 0)
                        return res.Fail("playlist");

                    return playlist;
                }
                catch
                {
                    return res.Fail("DeserializeObject");
                }
            });

            if (IsRhubFallback(cache, init))
                goto reset_embed;
            #endregion

            return OnResult(cache, () =>
            {
                return BuildResult(init, cache.Value, title, original_title, year, s, t, rjson, href, proxy.proxy);

            }, gbcache: !rch.enable);
        }


        #region BuildResult
        string BuildResult(OnlinesSettings init, JArray playlist, string title, string original_title, int year, int s, int t, bool rjson, string href, WebProxy proxy)
        {
            if (playlist.First.Value<string>("file") != null)
            {
                var mtpl = new MovieTpl(title, original_title);

                foreach (var source in playlist)
                {
                    string voice = source.Value<string>("title");
                    string file = source.Value<string>("file");

                    if (string.IsNullOrEmpty(voice) || string.IsNullOrEmpty(file))
                        continue;

                    if (file.StartsWith("//"))
                        file = "https:" + file;

                    #region subtitle
                    var subtitles = new SubtitleTpl();
                    string _subs = source.Value<string>("subtitle");
                    if (!string.IsNullOrEmpty(_subs))
                    {
                        var match = new Regex("\\[([^\\]]+)\\]([^\\[\\,]+)").Match(_subs);
                        while (match.Success)
                        {
                            string srt = match.Groups[2].Value;
                            if (srt.StartsWith("//"))
                                srt = "https:" + srt;

                            subtitles.Append(match.Groups[1].Value, HostStreamProxy(init, srt, proxy: proxy));
                            match = match.NextMatch();
                        }
                    }
                    #endregion

                    voice = Regex.Replace(voice, "<[^>]+>", "");
                    mtpl.Append(voice, HostStreamProxy(init, file, proxy: proxy), subtitles: subtitles, vast: init.vast);
                }

                return rjson ? mtpl.ToJson() : mtpl.ToHtml();
            }
            else
            {
                string enc_title = HttpUtility.UrlEncode(title);
                string enc_original_title = HttpUtility.UrlEncode(original_title);
                string enc_href = HttpUtility.UrlEncode(href);

                if (s == -1)
                {
                    var tpl = new SeasonTpl(playlist.Count);
                    foreach (var season in playlist)
                    {
                        string _s = Regex.Match(season.Value<string>("title"), " ([0-9]+)$").Groups[1].Value;
                        if (!string.IsNullOrEmpty(_s))
                        {
                            string link = $"{host}/lite/kinogo?rjson={rjson}&title={enc_title}&original_title={enc_original_title}&year={year}&href={enc_href}&s={_s}";
                            tpl.Append($"{_s} —Å–µ–∑–æ–Ω", link, _s);
                        }
                    }

                    return rjson ? tpl.ToJson() : tpl.ToHtml();
                }
                else
                {
                    var episodes = playlist.First(i => i.Value<string>("title").EndsWith($" {s}"))["folder"];

                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var vtpl = new VoiceTpl();
                    var hashSet = new HashSet<int>();

                    foreach (var episode in episodes)
                    {
                        foreach (var voice in episode["folder"])
                        {
                            int voice_id = voice.Value<int>("voice_id");
                            if (!hashSet.Add(voice_id))
                                continue;

                            if (t == -1)
                                t = voice_id;

                            string link = $"{host}/lite/kinogo?rjson={rjson}&title={enc_title}&original_title={enc_original_title}&year={year}&href={enc_href}&s={s}&t={voice_id}";
                            bool active = t == voice_id;

                            vtpl.Append(voice.Value<string>("title"), active, link);
                        }
                    }
                    #endregion

                    var etpl = new EpisodeTpl(episodes.Count());
                    string sArhc = s.ToString();

                    foreach (var episode in episodes)
                    {
                        string name = episode.Value<string>("title");
                        string file = episode["folder"].FirstOrDefault(i => i.Value<int>("voice_id") == t)?.Value<string>("file");

                        if (string.IsNullOrEmpty(file))
                            continue;

                        if (file.StartsWith("//"))
                            file = "https:" + file;

                        #region subtitle
                        var subtitles = new SubtitleTpl();
                        string _subs = episode.Value<string>("subtitle");

                        if (!string.IsNullOrEmpty(_subs))
                        {
                            var match = new Regex("\\[([^\\]]+)\\]([^\\[\\,]+)").Match(_subs);
                            while (match.Success)
                            {
                                string srt = match.Groups[2].Value;
                                if (srt.StartsWith("//"))
                                    srt = "https:" + srt;

                                subtitles.Append(match.Groups[1].Value, HostStreamProxy(init, srt, proxy: proxy));
                                match = match.NextMatch();
                            }
                        }
                        #endregion

                        string stream = HostStreamProxy(init, file, proxy: proxy);
                        etpl.Append(name, title ?? original_title, sArhc, Regex.Match(name, " ([0-9]+)$").Groups[1].Value, stream, subtitles: subtitles, vast: init.vast);
                    }

                    if (rjson)
                        return etpl.ToJson(vtpl);

                    return vtpl.ToHtml() + etpl.ToHtml();
                }
            }
        }
        #endregion

        #region SearchResult
        SearchModel SearchResult(string html, string title, int year)
        {
            string stitle = StringConvert.SearchName(title);

            var matches = Regex.Matches(html, "<div id=\"[0-9]+\" class=\"shortstory\">(.*?)<div class=\"shortstory__meta\">", RegexOptions.Singleline);
            if (matches.Count == 0)
                return null;

            var similar = new SimilarTpl(matches.Count);

            string link = null;

            foreach (Match match in matches)
            {
                string block = match.Groups[1].Value;
                string href = Regex.Match(block, "<a href=\"https?://[^/]+/([^\"]+)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(href))
                    continue;

                string name = Regex.Match(block, "<h2>([^<]+)</h2>").Groups[1].Value;
                if (string.IsNullOrEmpty(name))
                    continue;
                
                string blockYear = Regex.Match(block, "–ì–æ–¥ –≤—ã–ø—É—Å–∫–∞:</b><a[^>]*>([0-9]{4})").Groups[1].Value;

                string img = Regex.Match(block, "<img\\s+data-src=\"([^\"]+)\"").Groups[1].Value;
                if (!string.IsNullOrEmpty(img))
                    img = AppInit.conf.Kinogo.corsHost() + img;

                string uri = $"{host}/lite/kinogo?href={HttpUtility.UrlEncode(href)}";
                similar.Append(name, blockYear, string.Empty, uri, PosterApi.Size(img));

                if (StringConvert.SearchName(name).Contains(stitle) && blockYear == year.ToString())
                    link = href;
            }

            if (string.IsNullOrEmpty(link) && similar.data.Count == 0)
                return null;

            return new SearchModel() 
            {
                link = link,
                similar = similar
            };
        }
        #endregion
    }
}
```

## File: Online/Controllers/RutubeMovie.cs
```
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.RutubeMovie;

namespace Online.Controllers
{
    public class RutubeMovie : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/rutubemovie")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int year, int serial, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.RutubeMovie);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            string searchTitle = StringConvert.SearchName(title);
            if (string.IsNullOrEmpty(searchTitle) || year == 0)
                return OnError();

            var proxyManager = new ProxyManager(init);

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            if (serial == 1)
            {
                return OnError();
            }
            else
            {
                reset:
                string memKey = $"rutubemovie:view:{searchTitle}:{year}:{(rch.enable ? requestInfo.Country : "")}";
                var cache = await InvokeCache<Result[]>(memKey, cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string uri = $"api/search/video/?content_type=video&duration=movie&query={HttpUtility.UrlEncode($"{title} {year}")}";
                    var root = rch.enable ? await rch.Get<JObject>($"{init.host}/{uri}", httpHeaders(init)) : 
                                            await Http.Get<JObject>($"{init.host}/{uri}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));

                    if (root == null || !root.ContainsKey("results"))
                        return res.Fail("content");

                    return root["results"].ToObject<Result[]>();
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                return OnResult(cache, () =>
                {
                    var mtpl = new MovieTpl(title, original_title, cache.Value.Length);

                    foreach (var movie in cache.Value)
                    {
                        string name = StringConvert.SearchName(movie.title);
                        if (name != null && name.Contains(searchTitle) && (name.Contains(year.ToString()) || name.Contains((year + 1).ToString()) || name.Contains((year - 1).ToString())))
                        {
                            long duration = movie.duration;
                            if (duration > 3000) // 50 minutes
                            {
                                if (name.Contains("—Ç—Ä–µ–π–ª–µ—Ä") || name.Contains("trailer") ||
                                    name.Contains("–ø—Ä–µ–º—å–µ—Ä–∞") || name.Contains("–æ–±–∑–æ—Ä") ||
                                    name.Contains("—Å–µ–∑–æ–Ω") || name.Contains("—Å–µ—Ä–∏–∞–ª") ||
                                    name.Contains("—Å–µ—Ä–∏—è") || name.Contains("—Å–µ—Ä–∏–π"))
                                    continue;

                                if (movie.category.id == 4)
                                {
                                    if (movie.is_hidden || movie.is_deleted || movie.is_adult || movie.is_locked || movie.is_audio || movie.is_paid || movie.is_livestream)
                                        continue;

                                    mtpl.Append(movie.title, $"{host}/lite/rutubemovie/play?linkid={movie.id}", "call", vast: init.vast);
                                }
                            }
                        }
                    }

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();

                }, gbcache: !rch.enable);
            }
        }


        [HttpGet]
        [Route("lite/rutubemovie/play")]
        async public ValueTask<ActionResult> Movie(string linkid)
        {
            var init = await loadKit(AppInit.conf.RutubeMovie);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(linkid))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            reset:
            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var cache = await InvokeCache<string>($"rutubemovie:play:{linkid}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string uri = $"api/play/options/{linkid}/?no_404=true&referer=&pver=v2&client=wdp";
                var root = rch.enable ? await rch.Get<JObject>($"{init.host}/{uri}", httpHeaders(init)) : 
                                        await Http.Get<JObject>($"{init.host}/{uri}", timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));

                if (root == null || !root.ContainsKey("video_balancer"))
                    return res.Fail("video_balancer");

                return root["video_balancer"].Value<string>("m3u8");
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return ContentTo(VideoTpl.ToJson("play", HostStreamProxy(init, cache.Value, proxy: proxy), "auto", vast: init.vast));
        }
    }
}

```

## File: Online/Controllers/Kinotochka.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Kinotochka;

namespace Online.Controllers
{
    public class Kinotochka : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/kinotochka")]
        async public ValueTask<ActionResult> Index(long kinopoisk_id, string title, string original_title, int serial, string newsuri, int s = -1, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.Kinotochka);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            // enable 720p
            string cookie = init.cookie;

            if (serial == 1)
            {
                if (s == -1)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    reset:
                    var cache = await InvokeCache<List<(string name, string uri, string season)>>($"kinotochka:seasons:{title}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
                    {
                        List<(string, string, string)> links = null;

                        if (kinopoisk_id > 0) // https://kinovibe.co/embed.html
                        {
                            string uri = $"{init.corsHost()}/api/find-by-kinopoisk.php?kinopoisk={kinopoisk_id}";
                            var root = rch.enable ? await rch.Get<JArray>(uri, httpHeaders(init)) : await Http.Get<JArray>(uri, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));
                            if (root == null || root.Count == 0)
                                return res.Fail("find-by-kinopoisk");

                            links = new List<(string, string, string)>(root.Count);
                            foreach (var item in root)
                            {
                                string url = item.Value<string>("url");
                                string sname = Regex.Match(url, "-([0-9]+)-sezon").Groups[1].Value;
                                if (!string.IsNullOrEmpty(sname))
                                    links.Add(($"{sname} —Å–µ–∑–æ–Ω", $"{host}/lite/kinotochka?title={HttpUtility.UrlEncode(title)}&serial={serial}&s={sname}&newsuri={HttpUtility.UrlEncode(url)}", sname));
                            }

                            if (links.Count == 0)
                                return res.Fail("links");
                        }
                        else
                        {
                            string data = $"do=search&subaction=search&search_start=0&full_search=0&result_from=1&story={HttpUtility.UrlEncode(title)}";
                            string search = rch.enable ? await rch.Post($"{init.corsHost()}/index.php?do=search", data, httpHeaders(init)) : await Http.Post($"{init.corsHost()}/index.php?do=search", data, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));
                            if (search == null)
                            {
                                if (!rch.enable)
                                    proxyManager.Refresh();

                                return res.Fail("search");
                            }

                            var rows = search.Split("sres-wrap clearfix");
                            links = new List<(string, string, string)>(rows.Length);

                            string stitle = StringConvert.SearchName(title);

                            foreach (string row in rows.Skip(1).Reverse())
                            {
                                var gname = Regex.Match(row, "<h2>([^<]+) (([0-9]+) –°–µ–∑–æ–Ω) \\([0-9]{4}\\)</h2>", RegexOptions.IgnoreCase).Groups;

                                if (StringConvert.SearchName(gname[1].Value) == stitle)
                                {
                                    string uri = Regex.Match(row, "href=\"(https?://[^\"]+\\.html)\"").Groups[1].Value;
                                    if (string.IsNullOrWhiteSpace(uri))
                                        continue;

                                    links.Add((gname[2].Value.ToLower(), $"{host}/lite/kinotochka?title={HttpUtility.UrlEncode(title)}&serial={serial}&s={gname[3].Value}&newsuri={HttpUtility.UrlEncode(uri)}", gname[3].Value));
                                }
                            }

                            if (links.Count == 0 && !search.Contains(">–ü–æ–∏—Å–∫ –ø–æ —Å–∞–π—Ç—É<"))
                                return res.Fail("links");
                        }

                        return links;
                    });

                    if (IsRhubFallback(cache, init))
                        goto reset;

                    return OnResult(cache, () =>
                    {
                        var tpl = new SeasonTpl(cache.Value.Count);

                        foreach (var l in cache.Value)
                            tpl.Append(l.name, l.uri, l.season);

                        return rjson ? tpl.ToJson() : tpl.ToHtml();

                    }, gbcache: !rch.enable);
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∏
                    reset: 
                    var cache = await InvokeCache<List<(string name, string uri)>>($"kinotochka:playlist:{newsuri}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
                    {
                        string news = rch.enable ? await rch.Get(newsuri, httpHeaders(init)) : await Http.Get(newsuri, timeoutSeconds: 8, proxy: proxy, cookie: cookie, headers: httpHeaders(init));
                        if (news == null)
                        {
                            if (!rch.enable)
                                proxyManager.Refresh();

                            return res.Fail("news");
                        }

                        string filetxt = Regex.Match(news, "file:\"(https?://[^\"]+\\.txt)\"").Groups[1].Value;
                        if (string.IsNullOrEmpty(filetxt))
                            return res.Fail("filetxt");

                        var root = rch.enable ? await rch.Get<JObject>(filetxt, httpHeaders(init)) : await Http.Get<JObject>(filetxt, timeoutSeconds: 8, proxy: proxy, cookie: cookie, headers: httpHeaders(init));
                        if (root == null)
                        {
                            if (!rch.enable)
                                proxyManager.Refresh();

                            return res.Fail("root");
                        }

                        var playlist = root.Value<JArray>("playlist");
                        if (playlist == null)
                            return res.Fail("playlist");

                        var links = new List<(string name, string uri)>(playlist.Count);

                        foreach (var pl in playlist)
                        {
                            string name = pl.Value<string>("comment");
                            string file = pl.Value<string>("file");
                            if (!string.IsNullOrWhiteSpace(name) && !string.IsNullOrWhiteSpace(file))
                            {
                                if (file.Contains("].mp4"))
                                    file = Regex.Replace(file, "\\[[^\\]]+,([0-9]+)\\]\\.mp4$", "$1.mp4");

                                links.Add((name.Split("<")[0].Trim(), file));
                            }
                        }

                        if (links.Count == 0)
                            return res.Fail("links");

                        return links;
                    });

                    if (IsRhubFallback(cache, init))
                        goto reset;

                    return OnResult(cache, () =>
                    {
                        var etpl = new EpisodeTpl(cache.Value.Count);

                        foreach (var l in cache.Value)
                            etpl.Append(l.name, title, s.ToString(), Regex.Match(l.name, "^([0-9]+)").Groups[1].Value, HostStreamProxy(init, l.uri, proxy: proxy), vast: init.vast);

                        return rjson ? etpl.ToJson() : etpl.ToHtml();

                    }, gbcache: !rch.enable);
                    #endregion
                }
            }
            else
            {
                #region –§–∏–ª—å–º
                if (kinopoisk_id == 0)
                    return OnError();

                reset:
                var cache = await InvokeCache<EmbedModel>($"kinotochka:view:{kinopoisk_id}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string uri = $"{init.corsHost()}/embed/kinopoisk/{kinopoisk_id}";
                    string embed = rch.enable ? await rch.Get(uri, httpHeaders(init)) : await Http.Get(uri, timeoutSeconds: 8, proxy: proxy, cookie: cookie, headers: httpHeaders(init));
                    if (embed == null)
                    {
                        if (!rch.enable)
                            proxyManager.Refresh();

                        return res.Fail("embed");
                    }

                    string file = Regex.Match(embed, "id:\"playerjshd\", file:\"(https?://[^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(file))
                        return res.Fail("file");

                    foreach (string f in file.Split(",").Reverse())
                    {
                        if (string.IsNullOrWhiteSpace(f))
                            continue;

                        file = f;
                        break;
                    }

                    return new EmbedModel() { content = file };
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                return OnResult(cache, () => 
                {
                    var mtpl = new MovieTpl(title, original_title, 1);
                    mtpl.Append("–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é", HostStreamProxy(init, cache.Value.content, proxy: proxy), vast: init.vast);

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();

                }, gbcache: !rch.enable);
                #endregion
            }
        }
    }
}

```

## File: Online/Controllers/Plvideo.cs
```
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Plvideo;

namespace Online.Controllers
{
    public class Plvideo : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/plvideo")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int year, int serial, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.Plvideo);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            string searchTitle = StringConvert.SearchName(title);
            if (string.IsNullOrEmpty(searchTitle) || year == 0)
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            if (serial == 1)
            {
                return OnError();
            }
            else
            {
                reset:
                var cache = await InvokeCache<Item[]>($"plvideo:view:{searchTitle}:{year}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string uri = $"v1/videos?Type=video&Query={HttpUtility.UrlEncode($"{title} {year}")}&From=0&Size=20&Aud=16&Qf=false";
                    var root = rch.enable ? await rch.Get<JObject>($"{init.host}/{uri}", httpHeaders(init)) : 
                                            await Http.Get<JObject>($"{init.host}/{uri}", timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));

                    if (root == null || !root.ContainsKey("items"))
                        return res.Fail("content");

                    return root["items"].ToObject<Item[]>();
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                return OnResult(cache, () =>
                {
                    var mtpl = new MovieTpl(title, original_title, cache.Value.Length);

                    foreach (var movie in cache.Value)
                    {
                        string name = StringConvert.SearchName(movie.title);
                        if (name != null && name.StartsWith(searchTitle) && (name.Contains(year.ToString()) || name.Contains((year + 1).ToString()) || name.Contains((year - 1).ToString())))
                        {
                            long duration = movie.uploadFile.videoDuration;
                            if (duration > 1900000) // 30 minutes
                            {
                                if (name.Contains("—Ç—Ä–µ–π–ª–µ—Ä") || name.Contains("–ø—Ä–µ–º—å–µ—Ä–∞") || name.Contains("—Å–µ–∑–æ–Ω") || name.Contains("—Å–µ—Ä–∏–∞–ª") || name.Contains("—Å–µ—Ä–∏—è") || name.Contains("—Å–µ—Ä–∏–π"))
                                    continue;

                                if (movie.visible != "public")
                                    continue;

                                mtpl.Append(movie.title, $"{host}/lite/plvideo/movie?linkid={movie.id}", "call");
                            }
                        }
                    }

                    return rjson ? mtpl.ToJson() : mtpl.ToHtml();

                }, gbcache: !rch.enable);
            }
        }



        [HttpGet]
        [Route("lite/plvideo/movie")]
        async public ValueTask<ActionResult> Movie(string linkid)
        {
            var init = await loadKit(AppInit.conf.Plvideo);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(linkid))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            reset: var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var cache = await InvokeCache<Dictionary<string, Profile>>($"plvideo:play:{linkid}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                string uri = $"v1/videos/{linkid}?Aud=16";
                var root = rch.enable ? await rch.Get<JObject>($"{init.host}/{uri}", httpHeaders(init)) : 
                                        await Http.Get<JObject>($"{init.host}/{uri}", timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));

                if (root == null || !root.ContainsKey("item"))
                    return res.Fail("item");

                return root["item"]["profiles"].ToObject<Dictionary<string, Profile>>();
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            var streams = new StreamQualityTpl();
            foreach (string q in new string[] { "2160p", "1440p", "1080p", "720p", "468p", "360p", "240p" })
            {
                if (cache.Value.TryGetValue(q, out Profile p))
                {
                    if (!string.IsNullOrEmpty(p.hls))
                        streams.Append(HostStreamProxy(init, p.hls + "#.m3u8", proxy: proxy), q);
                }
            }

            return ContentTo(VideoTpl.ToJson("play", streams.Firts().link, streams.Firts().quality, streamquality: streams, vast: init.vast));
        }
    }
}

```

## File: Online/Controllers/VDBmovies.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Shared.Models.Online.Settings;
using Shared.Models.Online.VDBmovies;
using Shared.PlaywrightCore;
using System.Net;

namespace Online.Controllers
{
    public class VDBmovies : BaseOnlineController
    {
        #region database
        static List<MovieDB> databaseCache;

        static IEnumerable<MovieDB> database
        {
            get
            {
                if (AppInit.conf.multiaccess || databaseCache != null)
                    return databaseCache ??= JsonHelper.ListReader<MovieDB>("data/cdnmovies.json", 105000);

                return JsonHelper.IEnumerableReader<MovieDB>("data/cdnmovies.json");
            }
        }
        #endregion

        static string referer = CrypTo.DecodeBase64("aHR0cHM6Ly9tb3ZpZWJvb20uc3RvcmUv");

        [HttpGet]
        [Route("lite/vdbmovies")]
        async public ValueTask<ActionResult> Index(string orid, string imdb_id, long kinopoisk_id, string title, string original_title, bool similar, string t, int sid, int s = -1, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.VDBmovies);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            var oninvk = new VDBmoviesInvoke
            (
               host,
               init.hls,
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy.proxy)
            );

            #region –ø–æ–∏—Å–∫
            if (similar || (string.IsNullOrEmpty(orid) && kinopoisk_id == 0))
            {
                if (!init.spider)
                    return OnError("spider");

                var stpl = new SimilarTpl();

                string stitle = StringConvert.SearchName(title);
                string sorigtitle = StringConvert.SearchName(original_title);

                foreach (var j in database)
                {
                    if (stpl.data.Count > 100)
                        break;

                    bool IsOkTitle = false, IsOkID = false;

                    if (kinopoisk_id > 0 && kinopoisk_id == j.kinopoisk_id)
                        IsOkID = true;

                    if (!string.IsNullOrEmpty(imdb_id) && j.imdb_id == imdb_id)
                        IsOkID = true;

                    if (!IsOkID)
                    {
                        if (sorigtitle != null && StringConvert.SearchName(j.orig_title) == sorigtitle)
                            IsOkTitle = true;

                        if (!IsOkTitle && stitle != null)
                        {
                            if (StringConvert.SearchName(j.ru_title) != null)
                            {
                                if (StringConvert.SearchName(j.ru_title).Contains(stitle))
                                    IsOkTitle = true;
                            }

                            if (!IsOkTitle && StringConvert.SearchName(j.orig_title) != null)
                            {
                                if (StringConvert.SearchName(j.orig_title).Contains(stitle))
                                    IsOkTitle = true;
                            }
                        }
                    }

                    if (IsOkTitle || IsOkID)
                    {
                        if (!similar && IsOkID)
                        {
                            orid = j.id;
                            break;
                        }
                        else
                        {
                            string uri = $"{host}/lite/vdbmovies?orid={j.id}";
                            stpl.Append(j.ru_title ?? j.orig_title, j.year.ToString(), string.Empty, uri, PosterApi.Find(j.kinopoisk_id, j.imdb_id));
                        }
                    }
                }

                if (similar || string.IsNullOrEmpty(orid))
                    return ContentTo(rjson ? stpl.ToJson() : stpl.ToHtml());
            }
            #endregion

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web,cors", out string rch_error))
                return ShowError(rch_error);

            reset: 
            var cache = await InvokeCache<EmbedModel>(rch.ipkey($"vdbmovies:{orid}:{kinopoisk_id}", proxyManager), cacheTime(20, rhub: 2, init: init), proxyManager, async res =>
            {
                string uri = $"{init.corsHost()}/kinopoisk/{kinopoisk_id}/iframe";
                if (!string.IsNullOrEmpty(orid))
                    uri = $"{init.corsHost()}/content/{orid}/iframe";

                string html = rch.enable ? await rch.Get(uri, httpHeaders(init, HeadersModel.Init(("referer", referer)))) : 
                                           await black_magic(uri, referer, init, proxy);

                if (html == null)
                    return res.Fail("html");

                string file = Regex.Match(html, "file:([\t ]+)?'(#[^']+)").Groups[2].Value;
                if (string.IsNullOrEmpty(file))
                    return res.Fail("file");

                return oninvk.Embed(oninvk.DecodeEval(file));
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, orid, imdb_id, kinopoisk_id, title, original_title, t, s, sid, vast: init.vast, rjson: rjson), origsource: origsource, gbcache: !rch.enable);
        }


        #region black_magic
        async Task<string> black_magic(string uri, string referer, OnlinesSettings init, (WebProxy proxy, (string ip, string username, string password) data) baseproxy)
        {
            try
            {
                var headers = httpHeaders(init, HeadersModel.Init(
                    ("sec-fetch-dest", "iframe"),
                    ("sec-fetch-mode", "navigate"),
                    ("sec-fetch-site", "cross-site"),
                    ("referer", referer)
                ));

                if (init.priorityBrowser == "http")
                    return await Http.Get(uri, httpversion: 2, timeoutSeconds: 8, proxy: baseproxy.proxy, headers: headers);

                using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                {
                    var page = await browser.NewPageAsync(init.plugin, init.headers, proxy: baseproxy.data, imitationHuman: init.imitationHuman).ConfigureAwait(false);
                    if (page == null)
                        return null;

                    browser.SetFailedUrl(uri);

                    await page.RouteAsync("**/*", async route =>
                    {
                        try
                        {
                            if (route.Request.Url.StartsWith(referer))
                            {
                                await route.FulfillAsync(new RouteFulfillOptions
                                {
                                    Body = PlaywrightBase.IframeHtml(uri)
                                });
                            }
                            else if (route.Request.Url == uri)
                            {
                                string html = null;
                                await route.ContinueAsync();

                                var response = await page.WaitForResponseAsync(route.Request.Url);
                                if (response != null)
                                    html = await response.TextAsync();

                                browser.SetPageResult(html);
                                PlaywrightBase.WebLog(route.Request, response, html, baseproxy.data);
                                return;
                            }
                            else
                            {
                                if (!init.imitationHuman || route.Request.Url.EndsWith(".m3u8") || route.Request.Url.Contains("/cdn-cgi/challenge-platform/"))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                }
                                else
                                {
                                    if (await PlaywrightBase.AbortOrCache(page, route))
                                        return;

                                    await route.ContinueAsync();
                                }
                            }
                        }
                        catch { }
                    });

                    PlaywrightBase.GotoAsync(page, referer);
                    return await browser.WaitPageResult().ConfigureAwait(false);
                }
            }
            catch { return null; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/Rezka.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;
using Shared.Models.Online.Rezka;
using Shared.Models.Online.Settings;
using System.Net;

namespace Online.Controllers
{
    public class Rezka : BaseOnlineController
    {
        #region InitRezkaInvoke
        async public ValueTask<RezkaInvoke> InitRezkaInvoke(RezkaSettings init)
        {
            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            string country = init.forceua ? "UA" : requestInfo.Country;
            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            var headers = httpHeaders(init);
            var cookie = await getCookie(init);

            if (rch.enable && cookie != null)
                headers.Add(new HeadersModel("Cookie", rhubCookie));

            if (init.xapp)
                headers.Add(new HeadersModel("X-App-Hdrezka-App", "1"));

            if (init.xrealip)
                headers.Add(new HeadersModel("realip", requestInfo.IP));

            return new RezkaInvoke
            (
                host,
                init,
                (url, hed) =>
                    rch.enable ? rch.Get(url, HeadersModel.Join(hed, headers)) :
                    Http.Get(init.cors(url), timeoutSeconds: 8, proxy: proxy, headers: HeadersModel.Join(hed, headers), cookieContainer: cookieContainer, statusCodeOK: false),
                (url, data, hed) =>
                    rch.enable ? rch.Post(url, data, HeadersModel.Join(hed, headers)) :
                    Http.Post(init.cors(url), data, timeoutSeconds: 8, proxy: proxy, headers: HeadersModel.Join(hed, headers), cookieContainer: cookieContainer),
                streamfile => HostStreamProxy(init, RezkaInvoke.fixcdn(country, init.uacdn, streamfile), proxy: proxy, headers: RezkaInvoke.StreamProxyHeaders(init)),
                requesterror: () => proxyManager.Refresh()
            );
        }
        #endregion

        #region Initialization
        ValueTask<RezkaSettings> Initialization()
        {
            return loadKit(AppInit.conf.Rezka, (j, i, c) =>
            {
                if (j.ContainsKey("premium"))
                    i.premium = c.premium;

                if (j.ContainsKey("uacdn"))
                    i.uacdn = c.uacdn;

                if (j.ContainsKey("forceua"))
                    i.forceua = c.forceua;

                if (j.ContainsKey("reserve"))
                    i.reserve = c.reserve;

                if (j.ContainsKey("ajax"))
                    i.ajax = c.ajax;

                return i;
            });
        }
        #endregion

        [HttpGet]
        [Route("lite/rezka")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int clarification, int year, int s = -1, string href = null, bool rjson = false, int serial = -1, bool similar = false, string source = null, string id = null)
        {
            #region Initialization
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (init.premium || AppInit.conf.RezkaPrem.enable) 
                return ShowError("–ó–∞–º–µ–Ω–∏—Ç–µ Rezka –Ω–∞ RezkaPrem –≤ init.conf");

            if (string.IsNullOrWhiteSpace(href) && string.IsNullOrWhiteSpace(title))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: serial == 0 ? null : -1);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.enable)
            {
                if (rch.IsNotSupport("web", out string rch_error))
                    return ShowError($"–ù—É–∂–µ–Ω HDRezka Premium<br>{init.host}/payments/");

                if (requestInfo.Country == "RU")
                {
                    if (rch.InfoConnected()?.rchtype != "apk")
                        return ShowError($"–ù—É–∂–µ–Ω HDRezka Premium<br>{init.host}/payments/");

                    if (await getCookie(init) == null)
                        return ShowError("–£–∫–∞–∂–∏—Ç–µ –ª–æ–≥–∏–Ω/–ø–∞—Ä–æ–ª—å –∏–ª–∏ cookie");
                }
            }
            #endregion

            if (string.IsNullOrEmpty(href) && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() is "rezka" or "hdrezka")
                    href = id;
            }

            var oninvk = await InitRezkaInvoke(init);
            var proxyManager = new ProxyManager(init);

            #region search
            string search_uri = null;

            if (string.IsNullOrEmpty(href))
            {
                var search = await InvokeCache<SearchModel>($"rezka:search:{title}:{original_title}:{clarification}:{year}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    var content = await oninvk.Search(title, original_title, clarification, year);
                    if (content == null || (content.IsEmpty && content.content != null))
                        return res.Fail(content.content ?? "content");

                    return content;
                });

                if (search.ErrorMsg != null && search.ErrorMsg.Contains("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞"))
                    return ShowError(search.ErrorMsg);

                if (similar || string.IsNullOrEmpty(search.Value?.href))
                {
                    if (search.Value?.IsEmpty == true)
                        return ShowError(search.Value.content ?? "–ø–æ–∏—Å–∫ –Ω–µ –¥–∞–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤");

                    return OnResult(search, () =>
                    {
                        if (search.Value.similar == null)
                            return string.Empty;

                        var stpl = new SimilarTpl(search.Value.similar.Count);

                        foreach (var similar in search.Value.similar)
                        {
                            string link = $"{host}/lite/rezka?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&href={HttpUtility.UrlEncode(similar.href)}";

                            stpl.Append(similar.title, similar.year, string.Empty, link, PosterApi.Size(similar.img));
                        }

                        return rjson ? stpl.ToJson() : stpl.ToHtml();
                    });
                }

                href = search.Value.href;
                search_uri = search.Value.search_uri;
            }
            #endregion

            var cache = await InvokeCache<EmbedModel>($"rezka:{href}", cacheTime(10, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(href, search_uri);
            });

            return OnResult(cache, () => oninvk.Html(cache.Value, accsArgs(string.Empty), title, original_title, s, href, true, rjson), gbcache: !rch.enable);
        }


        #region Serial
        [HttpGet]
        [Route("lite/rezka/serial")]
        async public ValueTask<ActionResult> Serial(string title, string original_title, string href, long id, int t, int s = -1, bool rjson = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(href))
                return OnError();

            var oninvk = await InitRezkaInvoke(init);
            var proxyManager = new ProxyManager(init);

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            Episodes root = await InvokeCache($"rezka:view:serial:{id}:{t}", cacheTime(20, init: init), () => oninvk.SerialEmbed(id, t));
            if (root == null)
                return OnError(null, gbcache: !rch.enable);

            var content = await InvokeCache($"rezka:{href}", cacheTime(20, init: init), () => oninvk.Embed(href, null));
            if (content == null)
                return OnError(null, gbcache: !rch.enable);

            return ContentTo(oninvk.Serial(root, content, accsArgs(string.Empty), title, original_title, href, id, t, s, true, rjson));
        }
        #endregion

        #region Movie
        [HttpGet]
        [Route("lite/rezka/movie")]
        [Route("lite/rezka/movie.m3u8")]
        async public ValueTask<ActionResult> Movie(string title, string original_title, string voice, long id, int t, int director = 0, int s = -1, int e = -1, string favs = null, bool play = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var oninvk = await InitRezkaInvoke(init);
            var proxyManager = new ProxyManager(init);

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: s == -1 ? null : -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string realip = (init.xrealip && init.corseu) ? requestInfo.IP : "";

            MovieModel md = null;

            /// ajax = true (get_cdn_series)
            /// ajax = false (movie | get_cdn_series)
            /// ajax = null (movie)

            if (init.ajax != null && init.ajax.Value == false && !string.IsNullOrEmpty(voice))
            {
                md = await InvokeCache(rch.ipkey($"rezka:movie:{voice}:{realip}:{init.cookie}", proxyManager), cacheTime(20, mikrotik: 1, init: init), () => oninvk.Movie(voice), proxyManager);
            }

            if (md == null && init.ajax != null)
                md = await InvokeCache(rch.ipkey($"rezka:view:get_cdn_series:{id}:{t}:{director}:{s}:{e}:{realip}:{init.cookie}", proxyManager), cacheTime(20, mikrotik: 1, init: init), () => oninvk.Movie(id, t, director, s, e, favs), proxyManager);

            if (md == null)
                return OnError(null, gbcache: !rch.enable);

            string result = oninvk.Movie(md, title, original_title, play, vast: init.vast);
            if (result == null)
                return OnError(null, gbcache: !rch.enable);

            if (play)
                return RedirectToPlay(result);

            return ContentTo(result);
        }
        #endregion


        #region getCookie
        static string rhubCookie = string.Empty;
        static CookieContainer cookieContainer = null;

        async ValueTask<CookieContainer> getCookie(RezkaSettings init)
        {
            if (cookieContainer != null)
                return cookieContainer;

            string domain = Regex.Match(init.host, "https?://([^/]+)").Groups[1].Value;

            #region setCookieContainer
            void setCookieContainer(string coks)
            {
                cookieContainer = new CookieContainer();

                if (coks != string.Empty && !coks.Contains("hdmbbs"))
                    coks = $"hdmbbs=1; {coks}";

                if (!coks.Contains("dle_user_taken"))
                    coks = $"dle_user_taken=1; {coks}";

                foreach (string line in coks.Split(";"))
                {
                    if (string.IsNullOrEmpty(line) || !line.Contains("="))
                        continue;

                    var g = Regex.Match(line.Trim(), "^([^=]+)=([^\n\r]+)").Groups;
                    string name = g[1].Value.Trim();
                    string value = g[2].Value.Trim();

                    if (name is "CLID" or "MUID" or "_clck" or "_clsk")
                        continue;

                    if (name.StartsWith("_ym_"))
                        continue;

                    if (name != "PHPSESSID")
                        rhubCookie += $"{name}={value}; ";

                    if (name == "hdmbbs")
                    {
                        cookieContainer.Add(new Cookie()
                        {
                            Path = "/",
                            Expires = DateTime.Today.AddYears(1),
                            Domain = domain,
                            Name = name,
                            Value = value
                        });
                    }
                    else
                    {
                        cookieContainer.Add(new Cookie()
                        {
                            Path = "/",
                            Expires = name == "PHPSESSID" ? default : DateTime.Today.AddYears(1),
                            Domain = $".{domain}",
                            Name = name,
                            Value = value,
                            HttpOnly = true
                        });
                    }
                }

                rhubCookie = Regex.Replace(rhubCookie.Trim(), ";$", "");
            }
            #endregion

            if (!string.IsNullOrEmpty(init.cookie))
            {
                setCookieContainer(init.cookie.Trim());
                return cookieContainer;
            }

            if (string.IsNullOrEmpty(init.login) || string.IsNullOrEmpty(init.passwd))
            {
                setCookieContainer(string.Empty);
                return cookieContainer;
            }

            if (memoryCache.TryGetValue("rezka:login", out _))
                return null;

            memoryCache.Set("rezka:login", 0, TimeSpan.FromMinutes(2));

            try
            {
                using (var clientHandler = new System.Net.Http.HttpClientHandler()
                {
                    AllowAutoRedirect = false
                })
                {
                    clientHandler.ServerCertificateCustomValidationCallback += (sender, cert, chain, sslPolicyErrors) => true;
                    using (var client = new System.Net.Http.HttpClient(clientHandler))
                    {
                        client.Timeout = TimeSpan.FromSeconds(20);
                        client.DefaultRequestHeaders.Add("user-agent", Http.UserAgent);

                        var postParams = new Dictionary<string, string>
                        {
                            { "login_name", init.login },
                            { "login_password", init.passwd },
                            { "login_not_save", "0" }
                        };

                        using (var postContent = new System.Net.Http.FormUrlEncodedContent(postParams))
                        {
                            using (var response = await client.PostAsync($"{init.host}/ajax/login/", postContent))
                            {
                                if (response.Headers.TryGetValues("Set-Cookie", out var cook))
                                {
                                    string cookie = string.Empty;

                                    foreach (string line in cook)
                                    {
                                        if (string.IsNullOrEmpty(line))
                                            continue;

                                        if (line.Contains("=deleted;") || !line.Contains(domain))
                                            continue;

                                        string c = line.Split(";")[0];
                                        if (c.Contains("="))
                                        {
                                            string name = c.Split("=")[0];
                                            if (cookie.Contains(name))
                                            {
                                                cookie = Regex.Replace(cookie, $"{name}=[^;]+", $"{name}={c.Split("=")[1]}");
                                            }
                                            else
                                            {
                                                cookie += $"{c}; ";
                                            }
                                        }
                                    }

                                    if (cookie.Contains("dle_user_id") && cookie.Contains("dle_password"))
                                    {
                                        setCookieContainer(cookie.Trim());
                                        return cookieContainer;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch { }

            return null;
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/Vidsrc.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.Caching.Memory;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class VidSrc : BaseENGController
    {
        [HttpGet]
        [Route("lite/vidsrc")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.Vidsrc, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, method: "call");
        }


        #region Video
        static List<HeadersModel> lastHeaders = null;


        [HttpGet]
        [Route("lite/vidsrc/video")]
        [Route("lite/vidsrc/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id, string imdb_id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.Vidsrc);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (id == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/v2/embed/movie/{id}?autoPlay=true&poster=false";
            if (s > 0)
                embed = $"{init.host}/v2/embed/tv/{id}/{s}/{e}?autoPlay=true&poster=false";

            return await InvkSemaphore(init, embed, async () =>
            {
                #region api servers
                if (memoryCache.TryGetValue($"vidsrc:lastvrf:{id}", out string _vrf) && s > 0)
                {
                    string uri = $"{init.host}/api/{id}/servers?id={id}&type=tv&season={s}&episode={e}&vrf={_vrf}&imdbId={imdb_id}";
                    if (!hybridCache.TryGetValue(uri, out JToken data))
                    {
                        try
                        {
                            var root = await Http.Get<JObject>(uri, timeoutSeconds: 8);
                            if (root != null && root.ContainsKey("data"))
                            {
                                string hash = root["data"].First.Value<string>("hash");
                                var source = await Http.Get<JObject>($"{init.host}/api/source/{hash}", timeoutSeconds: 8);
                                if (source != null && source.ContainsKey("data"))
                                {
                                    data = source["data"];
                                    hybridCache.Set(uri, data, cacheTime(20));
                                }
                            }
                        }
                        catch { }
                    }

                    if (data != null)
                    {
                        var subtitles = new SubtitleTpl();
                        try
                        {
                            foreach (var sub in data["subtitles"])
                                subtitles.Append(sub.Value<string>("label"), HostStreamProxy(init, sub.Value<string>("file"), proxy: proxy.proxy));
                        }
                        catch { }

                        var lastHeaders_headers = httpHeaders(init.host, init.headers_stream);
                        if (lastHeaders_headers.Count == 0)
                            lastHeaders_headers = lastHeaders;

                        string file = HostStreamProxy(init, data.Value<string>("source"), proxy: proxy.proxy, headers: lastHeaders_headers);
                        if (play)
                            return RedirectToPlay(file);

                        return ContentTo(VideoTpl.ToJson("play", file, "English", subtitles: subtitles, vast: init.vast, headers: init.streamproxy ? null : lastHeaders_headers));
                    }
                }
                #endregion

                var cache = await black_magic(id, embed, init, proxyManager, proxy.data);
                if (cache.m3u8 == null)
                    return StatusCode(502);

                var headers_stream = httpHeaders(init.host, init.headers_stream);
                if (headers_stream.Count == 0)
                    headers_stream = cache.headers;

                string hls = HostStreamProxy(init, cache.m3u8, proxy: proxy.proxy, headers: headers_stream);

                if (play)
                    return RedirectToPlay(hls);

                return ContentTo(VideoTpl.ToJson("play", hls, "English", vast: init.vast, headers: init.streamproxy ? null : headers_stream));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string m3u8, List<HeadersModel> headers)> black_magic(long id, string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"vidsrc:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out (string m3u8, List<HeadersModel> headers) cache))
                {
                    if (init.priorityBrowser == "scraping")
                    {
                        #region Scraping
                        using (var browser = new Scraping(uri, "\\.m3u8", null))
                        {
                            browser.OnRequest += e =>
                            {
                                if (Regex.IsMatch(e.HttpClient.Request.Url, "/api/[0-9]+/servers"))
                                {
                                    string vrf = Regex.Match(e.HttpClient.Request.Url, "&vrf=([^&]+)").Groups[1].Value;
                                    if (!string.IsNullOrEmpty(vrf) && e.HttpClient.Request.Url.Contains("&type=tv"))
                                        memoryCache.Set($"vidsrc:lastvrf:{id}", vrf, DateTime.Now.AddDays(1));
                                }
                                else if (Regex.IsMatch(e.HttpClient.Request.Url.Split("?")[0], "\\.(woff2?|vtt|srt|css|ico)$"))
                                    e.Ok(string.Empty);
                            };

                            var scrap = await browser.WaitPageResult(20);

                            if (scrap != null)
                            {
                                cache.m3u8 = scrap.Url;
                                cache.headers = new List<HeadersModel>();

                                foreach (var item in scrap.Headers)
                                {
                                    if (item.Name.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                        continue;

                                    cache.headers.Add(new HeadersModel(item.Name, item.Value));
                                }
                            }
                        }
                        #endregion
                    }
                    else
                    {
                        #region Playwright
                        using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                        {
                            var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy);
                            if (page == null)
                                return default;

                            await page.RouteAsync("**/*", async route =>
                            {
                                try
                                {
                                    if (browser.IsCompleted || Regex.IsMatch(route.Request.Url.Split("?")[0], "\\.(woff2?|vtt|srt|css|ico)$"))
                                    {
                                        PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (await PlaywrightBase.AbortOrCache(page, route, fullCacheJS: true))
                                        return;

                                    if (Regex.IsMatch(route.Request.Url, "/api/[0-9]+/servers"))
                                    {
                                        string vrf = Regex.Match(route.Request.Url, "&vrf=([^&]+)").Groups[1].Value;
                                        if (!string.IsNullOrEmpty(vrf) && route.Request.Url.Contains("&type=tv"))
                                            memoryCache.Set($"vidsrc:lastvrf:{id}", vrf, DateTime.Now.AddDays(1));
                                    }

                                    if (route.Request.Url.Contains(".m3u8"))
                                    {
                                        cache.headers = new List<HeadersModel>();
                                        foreach (var item in route.Request.Headers)
                                        {
                                            if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                                continue;

                                            cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                        }

                                        lastHeaders = cache.headers;

                                        PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                        browser.SetPageResult(route.Request.Url);
                                        await route.AbortAsync();
                                        return;
                                    }

                                    await route.ContinueAsync();
                                }
                                catch { }
                            });

                            PlaywrightBase.GotoAsync(page, uri);
                            cache.m3u8 = await browser.WaitPageResult(20);
                        }
                        #endregion
                    }

                    if (cache.m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/PlayEmbed.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class PlayEmbed : BaseENGController
    {
        [HttpGet]
        [Route("lite/playembed")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.Playembed, checksearch, id, tmdb_id,imdb_id, title, original_title, serial, s, rjson, method: "call");
        }


        #region Video
        [HttpGet]
        [Route("lite/playembed/video")]
        [Route("lite/playembed/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.Playembed);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/movie/{id}?colour=e1216d&autoplay=true&autonextepisode=false&pausescreen=true";
            if (s > 0)
                embed = $"{init.host}/tv/{id}/{s}/{e}?colour=e1216d&autoplay=true&autonextepisode=false&pausescreen=true";

            return await InvkSemaphore(init, embed, async () =>
            {
                var cache = await black_magic(embed, init, proxyManager, proxy.data);
                if (cache.m3u8 == null)
                    return StatusCode(502);

                var headers_stream = httpHeaders(init.host, init.headers_stream);
                if (headers_stream.Count == 0)
                    headers_stream = cache.headers;

                string hls = HostStreamProxy(init, cache.m3u8, proxy: proxy.proxy, headers: headers_stream);

                if (play)
                    return RedirectToPlay(hls);

                return ContentTo(VideoTpl.ToJson("play", hls, "English", vast: init.vast, headers: init.streamproxy ? null : headers_stream));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string m3u8, List<HeadersModel> headers)> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"playembed:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out (string m3u8, List<HeadersModel> headers) cache))
                {
                    using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                    {
                        var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy);
                        if (page == null)
                            return default;

                        await page.RouteAsync("**/*", async route =>
                        {
                            try
                            {
                                if (browser.IsCompleted || Regex.IsMatch(route.Request.Url, "(/ads/)"))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }

                                if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                    return;

                                if (route.Request.Url.Contains(".m3u8") || route.Request.Url.Contains("/playlist/"))
                                {
                                    cache.headers = HeadersModel.Init(
                                        ("sec-fetch-dest", "empty"),
                                        ("sec-fetch-mode", "cors"),
                                        ("sec-fetch-site", "cross-site")
                                    );

                                    foreach (var item in route.Request.Headers)
                                    {
                                        if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                            continue;

                                        if (cache.headers.FirstOrDefault(k => k.name == item.Key) == null)
                                            cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                    }

                                    PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                    browser.SetPageResult(route.Request.Url);
                                    await route.AbortAsync();
                                    return;
                                }

                                await route.ContinueAsync();
                            }
                            catch { }
                        });

                        PlaywrightBase.GotoAsync(page, uri);
                        cache.m3u8 = await browser.WaitPageResult(20);
                    }

                    if (cache.m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/Videasy.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.PlaywrightCore;
using Shared.Models.Online.Settings;

namespace Online.Controllers
{
    public class Videasy : BaseENGController
    {
        [HttpGet]
        [Route("lite/videasy")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.Videasy, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, method: "call");
        }


        #region Video
        [HttpGet]
        [Route("lite/videasy/video")]
        [Route("lite/videasy/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.Videasy);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (id == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/movie/{id}";
            if (s > 0)
                embed = $"{init.host}/tv/{id}/{s}/{e}";

            return await InvkSemaphore(init, embed, async () =>
            {
                var cache = await black_magic(embed, init, proxyManager, proxy.data);
                if (cache.m3u8 == null)
                    return StatusCode(502);

                var headers_stream = httpHeaders(init.host, init.headers_stream);
                if (headers_stream.Count == 0)
                    headers_stream = cache.headers;

                string hls = HostStreamProxy(init, cache.m3u8, proxy: proxy.proxy, headers: headers_stream);

                if (play)
                    return RedirectToPlay(hls);

                return ContentTo(VideoTpl.ToJson("play", hls, "English", vast: init.vast, headers: init.streamproxy ? null : headers_stream));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string m3u8, List<HeadersModel> headers)> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"videasy:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out (string m3u8, List<HeadersModel> headers) cache))
                {
                    using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                    {
                        var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy, deferredDispose: true);
                        if (page == null)
                            return default;

                        await page.RouteAsync("**/*", async route =>
                        {
                            try
                            {
                                if (browser.IsCompleted)
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }

                                if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true))
                                    return;

                                if (route.Request.Url.Contains(".m3u8") || route.Request.Url.Contains(".mp4") || route.Request.Url.Contains("/mp4/") || route.Request.Url.Contains("mp4."))
                                {
                                    cache.headers = new List<HeadersModel>();
                                    foreach (var item in route.Request.Headers)
                                    {
                                        if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                            continue;

                                        cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                    }

                                    PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                    browser.completionSource.SetResult(route.Request.Url);
                                    await route.AbortAsync();
                                    return;
                                }

                                await route.ContinueAsync();
                            }
                            catch { }
                        });

                        PlaywrightBase.GotoAsync(page, uri);

                        for (int i = 0; i < 10*5; i++) // 5 second
                        {
                            if (browser.IsCompleted)
                                break;

                            foreach (string playBtnSelector in new string[] { "div.flex.flex-col.items-center.gap-y-3.title-year > button" })
                            {
                                try
                                {
                                    var playBtn = await page.QuerySelectorAsync(playBtnSelector);
                                    if (playBtn != null)
                                        await playBtn.ClickAsync();
                                }
                                catch { }
                            }

                            await Task.Delay(100);
                        }

                        // await browser.WaitPageResult()
                        cache.m3u8 = await browser.completionSource.Task;
                    }

                    if (cache.m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/BaseENGController.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;

namespace Online.Controllers
{
    public class BaseENGController : BaseOnlineController
    {
        async public ValueTask<ActionResult> ViewTmdb(OnlinesSettings _init, bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false, bool mp4 = false, string method = "play", int? hls_manifest_timeout = null, string extension = "m3u8")
        {
            if (checksearch)
                return Content("data-json=");

            var init = await loadKit(_init);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (tmdb_id > 0)
                id = tmdb_id;

            if (hls_manifest_timeout == null)
                hls_manifest_timeout = (int)TimeSpan.FromSeconds(20).TotalMilliseconds;

            if (serial == 1)
            {
                #region –°–µ—Ä–∏–∞–ª
                var tmdb = await InvokeCache<JToken>($"tmdb:seasons:{id}", cacheTime(40, init: init), async res =>
                {
                    var root = await Http.Get<JObject>($"{AppInit.conf.cub.scheme}://tmdb.{AppInit.conf.cub.mirror}/3/tv/{id}?api_key={AppInit.conf.tmdb.api_key}");

                    if (root == null || !root.ContainsKey("seasons"))
                        return res.Fail("seasons");

                    return root["seasons"];
                });

                if (!tmdb.IsSuccess)
                    return OnError(tmdb.ErrorMsg);

                if (s == -1)
                {
                    #region –°–µ–∑–æ–Ω—ã
                    var tpl = new SeasonTpl();

                    foreach (var season in tmdb.Value)
                    {
                        int number = season.Value<int>("season_number");
                        if (1 > number)
                            continue;

                        string link = $"{host}/lite/{init.plugin.ToLower()}?id={id}&imdb_id={imdb_id}&serial=1&rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&s={number}";
                        tpl.Append($"{number} —Å–µ–∑–æ–Ω", link, number);
                    }

                    return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                    #endregion
                }
                else
                {
                    #region –°–µ—Ä–∏–∏
                    var etpl = new EpisodeTpl();

                    foreach (var season in tmdb.Value)
                    {
                        if (season.Value<int>("season_number") != s)
                            continue;

                        for (int i = 1; i <= season.Value<int>("episode_count"); i++)
                        {
                            string path = (mp4 || method == "call") ? "video" : $"video.{extension}";
                            string uri = $"{host}/lite/{init.plugin.ToLower()}/{path}?id={id}&imdb_id={imdb_id}&s={s}&e={i}";
                            string stream = method == "call" ? accsArgs($"{host}/lite/{init.plugin.ToLower()}/{(mp4 ? "video" : $"video.{extension}")}?id={id}&imdb_id={imdb_id}&s={s}&e={i}&play=true") : null;

                            if (method == "play")
                                uri = accsArgs(uri);

                            etpl.Append($"{i} —Å–µ—Ä–∏—è", title ?? original_title, s.ToString(), i.ToString(), uri, method, streamlink: stream, vast: init.vast, hls_manifest_timeout: hls_manifest_timeout);
                        }
                    }

                    return ContentTo(rjson ? etpl.ToJson() : etpl.ToHtml());
                    #endregion
                }
                #endregion
            }
            else
            {
                #region –§–∏–ª—å–º
                var mtpl = new MovieTpl(title, original_title);

                string path = (mp4 || method == "call") ? "video" : $"video.{extension}";
                string uri = $"{host}/lite/{init.plugin.ToLower()}/{path}?id={id}&imdb_id={imdb_id}";
                string stream = method == "call" ? accsArgs($"{host}/lite/{init.plugin.ToLower()}/{(mp4 ? "video" : $"video.{extension}")}?id={id}&imdb_id={imdb_id}&play=true") : null;

                if (method == "play")
                    uri = accsArgs(uri);

                mtpl.Append("English", uri, method, stream: stream, vast: init.vast, hls_manifest_timeout: hls_manifest_timeout);

                return ContentTo(rjson ? mtpl.ToJson() : mtpl.ToHtml());
                #endregion
            }
        }
    }
}

```

## File: Online/Controllers/ENG/AutoEmbed.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class AutoEmbed : BaseENGController
    {
        [HttpGet]
        [Route("lite/autoembed")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            var init = AppInit.conf.Autoembed;
            return ViewTmdb(init, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, mp4: true, method: "call");
        }


        #region Video
        [HttpGet]
        [Route("lite/autoembed/video")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.Autoembed);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/embed/movie/{id}";
            if (s > 0)
                embed = $"{init.host}/embed/tv/{id}/{s}/{e}";

            return await InvkSemaphore(init, embed, async () =>
            {
                var cache = await black_magic(embed, init, proxyManager, proxy.data);
                if (cache.file == null)
                    return StatusCode(502);

                var headers_stream = httpHeaders(init.host, init.headers_stream);
                if (headers_stream.Count == 0)
                    headers_stream = cache.headers;

                string file = HostStreamProxy(init, cache.file, proxy: proxy.proxy, headers: headers_stream);

                if (play)
                    return RedirectToPlay(file);

                return ContentTo(VideoTpl.ToJson("play", file, "English", vast: init.vast, headers: init.streamproxy ? null : headers_stream));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string file, List<HeadersModel> headers)> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"autoembed:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out (string file, List<HeadersModel> headers) cache))
                {
                    using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                    {
                        var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy);
                        if (page == null)
                            return default;

                        await page.RouteAsync("**/*", async route =>
                        {
                            try
                            {
                                if (cache.file != null || await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                    return;

                                if ((Regex.IsMatch(route.Request.Url, "(hakunaymatata|kphimplayer)") && route.Request.Url.Contains(".mp4")) 
                                    || route.Request.Url.Contains("/embed-proxy?url=")
                                    || route.Request.Url.Contains(".m3u8"))
                                {
                                    cache.headers = HeadersModel.Init(
                                        ("sec-fetch-dest", "empty"),
                                        ("sec-fetch-mode", "cors"),
                                        ("sec-fetch-site", "cross-site"), 
                                        ("referer", $"{init.host}/"),
                                        ("origin", init.host)
                                    );

                                    foreach (var item in route.Request.Headers)
                                    {
                                        if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                            continue;

                                        if (cache.headers.FirstOrDefault(k => k.name == item.Key) == null)
                                            cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                    }

                                    PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                    browser.SetPageResult(route.Request.Url);
                                    await route.AbortAsync();
                                    return;
                                }

                                if (browser.IsCompleted || Regex.IsMatch(route.Request.Url, "(/ads/|vast.xml|ping.gif|silent.mp4)"))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }

                                await route.ContinueAsync();
                            }
                            catch { }
                        });

                        PlaywrightBase.GotoAsync(page, uri);
                        cache.file = await browser.WaitPageResult(20);
                    }

                    if (cache.file == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/MovPI.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Shared.PlaywrightCore;
using Shared.Models.Online.Settings;

namespace Online.Controllers
{
    public class MovPI : BaseENGController
    {
        [HttpGet]
        [Route("lite/movpi")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.MovPI, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, method: "call");
        }


        #region Video
        [HttpGet]
        [Route("lite/movpi/video")]
        [Route("lite/movpi/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.MovPI);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (id == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/movie/{id}?autoPlay=true&poster=false";
            if (s > 0)
                embed = $"{init.host}/tv/{id}-{s}-{e}?autoPlay=true&poster=false";

            return await InvkSemaphore(init, embed, async () =>
            {
                var cache = await black_magic(embed, init, proxyManager, proxy.data);
                if (cache.m3u8 == null)
                    return StatusCode(502);

                var headers_stream = httpHeaders(init.host, init.headers_stream);
                if (headers_stream.Count == 0)
                    headers_stream = cache.headers;

                string hls = HostStreamProxy(init, cache.m3u8, proxy: proxy.proxy, headers: headers_stream);

                if (play)
                    return RedirectToPlay(hls);

                return ContentTo(VideoTpl.ToJson("play", hls, "English", vast: init.vast, headers: init.streamproxy ? null : headers_stream));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string m3u8, List<HeadersModel> headers)> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"movpi:black_magic:{uri}:{proxy.ip}";
                if (!hybridCache.TryGetValue(memKey, out (string m3u8, List<HeadersModel> headers) cache))
                {
                    if (init.priorityBrowser == "scraping")
                    {
                        #region Scraping
                        using (var browser = new Scraping(uri, "\\.m3u8", null))
                        {
                            browser.OnRequest += e =>
                            {
                                if (uri == e.HttpClient.Request.Url)
                                    e.HttpClient.Request.Headers.AddHeader("Referer", CrypTo.DecodeBase64("aHR0cHM6Ly93d3cuaHlkcmFmbGl4LnZpcC8="));
                            };

                            var scrap = await browser.WaitPageResult(20);

                            if (scrap != null)
                            {
                                cache.m3u8 = scrap.Url;
                                cache.headers = new List<HeadersModel>();

                                foreach (var item in scrap.Headers)
                                {
                                    if (item.Name.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                        continue;

                                    cache.headers.Add(new HeadersModel(item.Name, item.Value));
                                }
                            }
                        }
                        #endregion
                    }
                    else
                    {
                        #region Playwright
                        using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                        {
                            var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy);
                            if (page == null)
                                return default;

                            await page.RouteAsync("**/*", async route =>
                            {
                                try
                                {
                                    if (route.Request.Url.Contains("api/chromium/iframe"))
                                    {
                                        await route.ContinueAsync();
                                        return;
                                    }

                                    if (browser.IsCompleted)
                                    {
                                        PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                        return;

                                    if (route.Request.Url == uri)
                                    {
                                        await route.ContinueAsync(new RouteContinueOptions
                                        {
                                            Headers = httpHeaders(init, HeadersModel.Init(("referer", CrypTo.DecodeBase64("aHR0cHM6Ly93d3cuaHlkcmFmbGl4LnZpcC8=")))).ToDictionary()
                                        });
                                        return;
                                    }

                                    if (route.Request.Url.Contains(".m3u8"))
                                    {
                                        cache.headers = new List<HeadersModel>();
                                        foreach (var item in route.Request.Headers)
                                        {
                                            if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                                continue;

                                            cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                        }

                                        PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                        browser.SetPageResult(route.Request.Url);
                                        await route.AbortAsync();
                                        return;
                                    }

                                    await route.ContinueAsync();
                                }
                                catch { }
                            });

                            PlaywrightBase.GotoAsync(page, PlaywrightBase.IframeUrl(uri));

                            cache.m3u8 = await browser.WaitPageResult(20);
                        }
                        #endregion
                    }

                    if (cache.m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/VidLink.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class VidLink : BaseENGController
    {
        [HttpGet]
        [Route("lite/vidlink")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.VidLink, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, mp4: true, method: "call");
        }


        #region Video
        [HttpGet]
        [Route("lite/vidlink/video")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.VidLink);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (id == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/movie/{id}";
            if (s > 0)
                embed = $"{init.host}/tv/{id}/{s}/{e}";

            return await InvkSemaphore(init, embed, async () =>
            {
                var cache = await black_magic(embed, init, proxyManager, proxy.data);
                if (cache.m3u8 == null)
                    return StatusCode(502);

                var headers_stream = httpHeaders(init.host, init.headers_stream);
                if (headers_stream.Count == 0)
                    headers_stream = cache.headers;

                string file = HostStreamProxy(init, cache.m3u8, proxy: proxy.proxy, headers: headers_stream);

                if (play)
                    return RedirectToPlay(file);

                return ContentTo(VideoTpl.ToJson("play", file, "English", vast: init.vast, headers: init.streamproxy ? null : headers_stream));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string m3u8, List<HeadersModel> headers)> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"vidlink:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out (string m3u8, List<HeadersModel> headers) cache))
                {
                    if (init.priorityBrowser == "scraping")
                    {
                        #region Scraping
                        using (var browser = new Scraping(uri, "\\.(m3u|mp4)", null))
                        {
                            browser.OnRequest += e =>
                            {
                                if (Regex.IsMatch(e.HttpClient.Request.Url, "(adsco|pubtrky|clarity)\\."))
                                    e.Ok(string.Empty);
                            };

                            var scrap = await browser.WaitPageResult(20);

                            if (scrap != null)
                            {
                                cache.m3u8 = scrap.Url;
                                cache.headers = new List<HeadersModel>();

                                foreach (var item in scrap.Headers)
                                {
                                    if (item.Name.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                        continue;

                                    cache.headers.Add(new HeadersModel(item.Name, item.Value));
                                }
                            }
                        }
                        #endregion
                    }
                    else
                    {
                        #region Playwright
                        using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                        {
                            var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy);
                            if (page == null)
                                return default;

                            await page.RouteAsync("**/*", async route =>
                            {
                                try
                                {
                                    if (browser.IsCompleted)
                                    {
                                        PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true, patterCache: "/api/(mercury|venus)$"))
                                        return;

                                    if (route.Request.Url.Contains("adsco.") || route.Request.Url.Contains("pubtrky.") || route.Request.Url.Contains("clarity."))
                                    {
                                        PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (route.Request.Url.Contains(".m3u") || route.Request.Url.Contains(".mp4"))
                                    {
                                        cache.headers = new List<HeadersModel>();
                                        foreach (var item in route.Request.Headers)
                                        {
                                            if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                                continue;

                                            cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                        }

                                        PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                        browser.SetPageResult(route.Request.Url);
                                        await route.AbortAsync();
                                        return;
                                    }

                                    await route.ContinueAsync();
                                }
                                catch { }
                            });

                            PlaywrightBase.GotoAsync(page, uri);
                            cache.m3u8 = await browser.WaitPageResult(20);
                        }
                        #endregion
                    }

                    if (cache.m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/HydraFlix.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class HydraFlix : BaseENGController
    {
        [HttpGet]
        [Route("lite/hydraflix")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.Hydraflix, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, method: "call", extension: "m3u8");
        }


        #region Video
        [HttpGet]
        [Route("lite/hydraflix/video")]
        [Route("lite/hydraflix/video.mpd")]
        [Route("lite/hydraflix/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.Hydraflix);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (id == 0)
                return OnError();

            if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/movie/{id}?autoPlay=true&theme=e1216d";
            if (s > 0)
                embed = $"{init.host}/tv/{id}/{s}/{e}?autoPlay=true&theme=e1216d";

            return await InvkSemaphore(init, embed, async () =>
            {
                var cache = await black_magic(embed, init, proxyManager, proxy.data);
                if (cache.m3u8 == null)
                    return StatusCode(502);

                var headers_stream = httpHeaders(init.host, init.headers_stream);
                if (headers_stream.Count == 0)
                    headers_stream = cache.headers;

                string file = HostStreamProxy(init, cache.m3u8, proxy: proxy.proxy, headers: headers_stream);

                if (play)
                    return RedirectToPlay(file);

                return ContentTo(VideoTpl.ToJson("play", file, "English", vast: init.vast, headers: init.streamproxy ? null : headers_stream));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string m3u8, List<HeadersModel> headers)> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"Hydraflix:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out (string m3u8, List<HeadersModel> headers) cache))
                {
                    if (init.priorityBrowser == "scraping")
                    {
                        #region Scraping
                        using (var browser = new Scraping(uri, "\\.(mpd|m3u|mp4)", null))
                        {
                            //browser.OnRequest += e =>
                            //{
                            //    if (Regex.IsMatch(e.HttpClient.Request.Url, "\\.(css|woff2|jpe?g|png|ico)"))
                            //        e.Ok(string.Empty);
                            //};

                            var scrap = await browser.WaitPageResult(20);

                            if (scrap != null)
                            {
                                cache.m3u8 = scrap.Url;
                                cache.headers = new List<HeadersModel>();

                                foreach (var item in scrap.Headers)
                                {
                                    if (item.Name.ToLower() is "host" or "accept-encoding" or "connection" or "range" or "cookie")
                                        continue;

                                    cache.headers.Add(new HeadersModel(item.Name, item.Value));
                                }
                            }
                        }
                        #endregion
                    }
                    else
                    {
                        #region Playwright
                        using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                        {
                            var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy);
                            if (page == null)
                                return default;

                            await page.RouteAsync("**/*", async route =>
                            {
                                try
                                {
                                    if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                        return;

                                    if (browser.IsCompleted || route.Request.Url.Contains("adsco."))
                                    {
                                        PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                        await route.AbortAsync();
                                        return;
                                    }

                                    if (Regex.IsMatch(route.Request.Url, "\\.(mpd|m3u|mp4)"))
                                    {
                                        cache.headers = new List<HeadersModel>();
                                        foreach (var item in route.Request.Headers)
                                        {
                                            if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                                continue;

                                            cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                        }

                                        PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                        browser.SetPageResult(route.Request.Url);
                                        await route.AbortAsync();
                                        return;
                                    }

                                    await route.ContinueAsync();
                                }
                                catch { }
                            });

                            PlaywrightBase.GotoAsync(page, uri);
                            cache.m3u8 = await browser.WaitPageResult(20);
                        }
                        #endregion
                    }

                    if (cache.m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch 
            { 
                return default; 
            }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/SmashyStream.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.Playwright;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class SmashyStream : BaseENGController
    {
        [HttpGet]
        [Route("lite/smashystream")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.Smashystream, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, hls_manifest_timeout: (int)TimeSpan.FromSeconds(35).TotalMilliseconds);
        }


        #region Video
        [HttpGet]
        [Route("lite/smashystream/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1)
        {
            var init = await loadKit(AppInit.conf.Smashystream);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (id == 0)
                return OnError();

            if (PlaywrightBrowser.Status == PlaywrightStatus.disabled)
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/movie/{id}";
            if (s > 0)
                embed = $"{init.host}/tv/{id}?s={s}&e={e}";

            return await InvkSemaphore(init, embed, async () =>
            {
                var cache = await black_magic(embed, init, proxyManager, proxy.data);
                if (cache.m3u8 == null)
                    return StatusCode(502);

                return Redirect(HostStreamProxy(init, cache.m3u8, proxy: proxy.proxy, headers: cache.headers));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<(string m3u8, List<HeadersModel> headers)> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"smashystream:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out (string m3u8, List<HeadersModel> headers) cache))
                {
                    DateTime routeActiveTime = default;

                    using (var browser = new PlaywrightBrowser(init.priorityBrowser))
                    {
                        var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy, deferredDispose: true).ConfigureAwait(false);
                        if (page == null)
                            return default;

                        await page.RouteAsync("**/*", async route =>
                        {
                            try
                            {
                                routeActiveTime = DateTime.Now;

                                if (browser.IsCompleted || route.Request.Url.Contains(".m3u") || Regex.IsMatch(route.Request.Url, "(\\.vtt|histats.com|solid.gif|poster.png|doubleclick\\.|inkblotconusor\\.|jrbbavbvqmrjw\\.)"))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }

                                if (await PlaywrightBase.AbortOrCache(page, route, fullCacheJS: true))
                                    return;

                                if (route.Request.Url.Contains("master.txt"))
                                {
                                    cache.headers = new List<HeadersModel>();
                                    foreach (var item in route.Request.Headers)
                                    {
                                        if (item.Key.ToLower() is "host" or "accept-encoding" or "connection" or "range")
                                            continue;

                                        cache.headers.Add(new HeadersModel(item.Key, item.Value.ToString()));
                                    }

                                    PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}", cache.headers);
                                    browser.SetPageResult(route.Request.Url);
                                    cache.m3u8 = route.Request.Url;
                                    await route.AbortAsync();
                                    return;
                                }

                                await route.ContinueAsync();
                            }
                            catch { }
                        });

                        await page.GotoAsync(uri, new PageGotoOptions() 
                        {
                            Timeout = 15_000,
                            WaitUntil = WaitUntilState.DOMContentLoaded 
                        }).ConfigureAwait(false);

                        var frameElement = await page.WaitForSelectorAsync("iframe[src*='smashyplayer.top']", new PageWaitForSelectorOptions 
                        { 
                            Timeout = 15_000, 
                            State = WaitForSelectorState.Visible 
                        }).ConfigureAwait(false);

                        var frame = await frameElement.ContentFrameAsync().ConfigureAwait(false);

                        // –Ω–µ–≤—å–µ–±–µ–Ω–Ω–∞—è –º–∞–≥–∏—è –æ–±—Ö–æ–¥–∞ –∑–∞—â–∏—Ç—ã =)
                        await Task.Delay(1000).ConfigureAwait(false);
                        while (routeActiveTime.AddSeconds(1) > DateTime.Now)
                            await Task.Delay(100).ConfigureAwait(false);

                        await frame.WaitForSelectorAsync("#player-button", new FrameWaitForSelectorOptions() { Timeout = 10_000 }).ConfigureAwait(false);

                        var endTime = DateTime.Now.AddSeconds(5);
                        while (endTime > DateTime.Now && cache.m3u8 == null)
                        {
                            try
                            {
                                await frame.ClickAsync("#player-button", new FrameClickOptions
                                {
                                    Timeout = 400,
                                    Force = true
                                }).ConfigureAwait(false);

                                await Task.Delay(200).ConfigureAwait(false);
                            }
                            catch { }
                        }
                    }

                    if (cache.m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(20, init: init));
                }

                return cache;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/RgShows.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Settings;
using System.Net;

namespace Online.Controllers
{
    public class RgShows : BaseENGController
    {
        [HttpGet]
        [Route("lite/rgshows")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.Rgshows, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, mp4: true, method: "call", hls_manifest_timeout: (int)TimeSpan.FromSeconds(30).TotalMilliseconds);
        }


        #region Video
        [HttpGet]
        [Route("lite/rgshows/video")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.Rgshows);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/main/movie/{id}";
            if (s > 0)
                embed = $"{init.host}/main/tv/{id}/{s}/{e}";

            return await InvkSemaphore(init, embed, async () =>
            {
                string file = await magic(embed, init, proxyManager, proxy.proxy);
                if (file == null)
                    return StatusCode(502);

                file = HostStreamProxy(init, file, proxy: proxy.proxy);

                if (play)
                    return RedirectToPlay(file);

                return ContentTo(VideoTpl.ToJson("play", file, "English", vast: init.vast, headers: init.streamproxy ? null : httpHeaders(init.host, init.headers_stream), hls_manifest_timeout: (int)TimeSpan.FromSeconds(30).TotalMilliseconds));
            });
        }
        #endregion

        #region magic
        async ValueTask<string> magic(string uri, OnlinesSettings init, ProxyManager proxyManager, WebProxy proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return uri;

            try
            {
                string memKey = $"rgshows:{uri}";
                if (!hybridCache.TryGetValue(memKey, out string file))
                {
                    var root = await Http.Get<JObject>(uri, timeoutSeconds: 40, httpversion: 2, headers: httpHeaders(init));
                    if (root == null || !root.ContainsKey("stream"))
                    {
                        proxyManager.Refresh();
                        return null;
                    }

                    file = root["stream"].Value<string>("url");
                    if (string.IsNullOrEmpty(file))
                        return null;

                    proxyManager.Success();
                    hybridCache.Set(memKey, file, cacheTime(20, init: init));
                }

                return file;
            }
            catch { return null; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/ENG/TwoEmbed.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Settings;
using Shared.PlaywrightCore;

namespace Online.Controllers
{
    public class TwoEmbed : BaseENGController
    {
        [HttpGet]
        [Route("lite/twoembed")]
        public ValueTask<ActionResult> Index(bool checksearch, long id, long tmdb_id, string imdb_id, string title, string original_title, int serial, int s = -1, bool rjson = false)
        {
            return ViewTmdb(AppInit.conf.Twoembed, checksearch, id, tmdb_id, imdb_id, title, original_title, serial, s, rjson, method: "call");
        }


        #region Video
        [HttpGet]
        [Route("lite/twoembed/video")]
        [Route("lite/twoembed/video.m3u8")]
        async public ValueTask<ActionResult> Video(long id, int s = -1, int e = -1, bool play = false)
        {
            var init = await loadKit(AppInit.conf.Twoembed);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (Firefox.Status == PlaywrightStatus.disabled)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.BaseGet();

            string embed = $"{init.host}/embed/movie/{id}";
            if (s > 0)
                embed = $"{init.host}/embed/tv/{id}/{s}/{e}";

            return await InvkSemaphore(init, embed, async () =>
            {
                var hls = await black_magic(embed, init, proxyManager, proxy.data);
                if (hls == null)
                    return StatusCode(502);

                hls = HostStreamProxy(init, hls, proxy: proxy.proxy);

                if (play)
                    return RedirectToPlay(hls);

                return ContentTo(VideoTpl.ToJson("play", hls, "English", vast: init.vast, headers: init.streamproxy ? null : httpHeaders(init.host, init.headers_stream)));
            });
        }
        #endregion

        #region black_magic
        async ValueTask<string> black_magic(string uri, OnlinesSettings init, ProxyManager proxyManager, (string ip, string username, string password) proxy)
        {
            if (string.IsNullOrEmpty(uri))
                return default;

            try
            {
                string memKey = $"twoembed:black_magic:{uri}";
                if (!hybridCache.TryGetValue(memKey, out string m3u8))
                {
                    using (var browser = new Firefox())
                    {
                        var page = await browser.NewPageAsync(init.plugin, httpHeaders(init).ToDictionary(), proxy);
                        if (page == null)
                            return default;

                        await page.RouteAsync("**/*", async route =>
                        {
                            try
                            {
                                if (await PlaywrightBase.AbortOrCache(page, route, abortMedia: true, fullCacheJS: true))
                                    return;

                                if (browser.IsCompleted || Regex.IsMatch(route.Request.Url, "(fonts.googleapis|pixel.embed|rtmark)\\."))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: Abort {route.Request.Url}");
                                    await route.AbortAsync();
                                    return;
                                }

                                if (route.Request.Url.Contains(".m3u8"))
                                {
                                    PlaywrightBase.ConsoleLog($"Playwright: SET {route.Request.Url}");
                                    browser.IsCompleted = true;
                                    browser.completionSource.SetResult(route.Request.Url);
                                    await route.AbortAsync();
                                    return;
                                }

                                await route.ContinueAsync();
                            }
                            catch { }
                        });

                        PlaywrightBase.GotoAsync(page, uri);
                        m3u8 = await browser.WaitPageResult(20);
                    }

                    if (m3u8 == null)
                    {
                        proxyManager.Refresh();
                        return default;
                    }

                    proxyManager.Success();
                    hybridCache.Set(memKey, m3u8, cacheTime(20, init: init));
                }

                return m3u8;
            }
            catch { return default; }
        }
        #endregion
    }
}

```

## File: Online/Controllers/UKR/Kinoukr.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Eneyida;

namespace Online.Controllers
{
    public class Kinoukr : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/kinoukr")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int clarification, int year, string t, int s = -1, string href = null, bool origsource = false, bool rjson = false, string source = null, string id = null)
        {
            var init = await loadKit(AppInit.conf.Kinoukr);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var oninvk = new KinoukrInvoke
            (
               host,
               init.corsHost(),
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl), httpHeaders(init)) : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               (url, data) => rch.enable ? rch.Post(init.cors(url), data, httpHeaders(init)) : Http.Post(init.cors(url), data, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               onstreamtofile => HostStreamProxy(init, onstreamtofile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
               //onlog: (l) => { Console.WriteLine(l); return string.Empty; }
            );

            if (string.IsNullOrEmpty(href) && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() == "kinoukr")
                    href = await InvokeCache($"kinoukr:source:{id}", cacheTime(180, init: init), () => oninvk.getIframeSource($"{init.host}/{id}"));
            }

            reset:
            var cache = await InvokeCache<EmbedModel>($"kinoukr:view:{title}:{original_title}:{year}:{href}:{clarification}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.EmbedKurwa(clarification, title, original_title, year, href);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, clarification, title, original_title, year, t, s, href, vast: init.vast, rjson: rjson), origsource: origsource, gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/UKR/Ashdi.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Ashdi;

namespace Online.Controllers
{
    public class Ashdi : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/ashdi")]
        async public ValueTask<ActionResult> Index(long kinopoisk_id, string title, string original_title, int t = -1, int s = -1, bool origsource = false, bool rjson = false)
        {
            var init = await loadKit(AppInit.conf.Ashdi);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (kinopoisk_id == 0)
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var oninvk = new AshdiInvoke
            (
               host,
               init.corsHost(),
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl), httpHeaders(init)) : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init), statusCodeOK: false),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            reset:
            var cache = await InvokeCache<EmbedModel>($"ashdi:view:{kinopoisk_id}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(kinopoisk_id);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, kinopoisk_id, title, original_title, t, s, vast: init.vast, rjson: rjson), origsource: origsource, gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/UKR/Eneyida.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.Eneyida;

namespace Online.Controllers
{
    public class Eneyida : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/eneyida")]
        async public Task<ActionResult> Index(string title, string original_title, int clarification, int year, int t = -1, int s = -1, string href = null, bool rjson = false, bool similar = false, string source = null, string id = null)
        {
            var init = await loadKit(AppInit.conf.Eneyida);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(href) && !string.IsNullOrEmpty(source) && !string.IsNullOrEmpty(id))
            {
                if (source.ToLower() == "eneyida")
                    href = $"{init.host}/{id}";
            }

            if (string.IsNullOrWhiteSpace(href) && (string.IsNullOrWhiteSpace(original_title) || year == 0))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            var oninvk = new EneyidaInvoke
            (
               host,
               init.corsHost(),
               ongettourl => rch.enable ? rch.Get(init.cors(ongettourl)) : Http.Get(init.cors(ongettourl), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               (url, data) => rch.enable ? rch.Post(init.cors(url), data) : Http.Post(init.cors(url), data, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
               onstreamtofile => HostStreamProxy(init, onstreamtofile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            reset:
            var cache = await InvokeCache<EmbedModel>($"eneyida:view:{title}:{year}:{href}:{clarification}:{similar}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed((similar || clarification == 1) ? title : original_title, year, href, similar);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, clarification, title, original_title, year, t, s, href, vast: init.vast, rjson: rjson), gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/Anime/AniMedia.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace Online.Controllers
{
    public class AniMedia : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.AniMedia);

        [HttpGet]
        [Route("lite/animedia")]
        async public ValueTask<ActionResult> Index(string title, string news, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.AniMedia);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (string.IsNullOrEmpty(news))
            {
                if (string.IsNullOrEmpty(title))
                    return OnError();

                #region –ü–æ–∏—Å–∫
                string memkey = $"animedia:search:{title}:{similar}";

                return await InvkSemaphore(init, memkey, async () =>
                {
                    if (!hybridCache.TryGetValue(memkey, out List<(string title, string url, string img)> catalog, inmemory: false))
                    {
                        string search = await Http.Post($"{init.corsHost()}/index.php?do=search", $"do=search&subaction=search&from_page=0&story={HttpUtility.UrlEncode(title)}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                        if (search == null)
                            return OnError(proxyManager);

                        var rows = search.Split("</article>")[1].Split("grid-item d-flex fd-column");

                        catalog = new List<(string title, string url, string img)>(rows.Length);

                        foreach (string row in rows.Skip(1))
                        {
                            var g = Regex.Match(row, "<a href=\"https?://[^/]+/([^\"]+)\" class=\"poster__link\"><h3 class=\"poster__title line-clamp\">([^<]+)</h3></a>").Groups;

                            if (!string.IsNullOrEmpty(g[1].Value) && !string.IsNullOrEmpty(g[2].Value))
                            {
                                string img = Regex.Match(row, "<img src=\"([^\"]+)\"").Groups[1].Value;
                                if (!string.IsNullOrEmpty(img))
                                    img = init.host + img;

                                if (similar || StringConvert.SearchName(g[2].Value).Contains(StringConvert.SearchName(title)))
                                    catalog.Add((g[2].Value, g[1].Value, img));
                            }
                        }

                        if (catalog.Count == 0 && !search.Contains("id=\"dosearch\""))
                            return OnError();

                        proxyManager.Success();
                        hybridCache.Set(memkey, catalog, cacheTime(40, init: init), inmemory: false);
                    }

                    if (catalog.Count == 0)
                        return OnError();

                    if (!similar && catalog.Count == 1)
                        return LocalRedirect(accsArgs($"/lite/animedia?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&news={HttpUtility.UrlEncode(catalog[0].url)}"));

                    var stpl = new SimilarTpl(catalog.Count);

                    foreach (var res in catalog)
                    {
                        string uri = $"{host}/lite/animedia?title={HttpUtility.UrlEncode(title)}&news={HttpUtility.UrlEncode(res.url)}";
                        stpl.Append(res.title, string.Empty, string.Empty, uri, PosterApi.Size(res.img));
                    }

                    return ContentTo(rjson ? stpl.ToJson() : stpl.ToHtml());
                });
                #endregion
            }
            else 
            {
                #region –°–µ—Ä–∏–∏
                string memKey = $"animedia:{news}";

                return await InvkSemaphore(init, memKey, async () =>
                {
                    if (!hybridCache.TryGetValue(memKey, out List<(int episode, string s, string vod)> links, inmemory: false))
                    {
                        string html = await Http.Get($"{init.corsHost()}/{news}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                        if (html == null)
                            return OnError(proxyManager);

                        var match = Regex.Match(html, "data-vid=\"([0-9]+)\"[\t ]+data-vlnk=\"([^\"]+)\"");
                        links = new List<(int episode, string s, string vod)>(match.Length);

                        string pmovie = Regex.Match(html, "class=\"pmovie__main-info ws-nowrap\">([^<]+)<").Groups[1].Value;
                        string s = Regex.Match(pmovie, "Season[\t ]+([0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value;
                        if (string.IsNullOrEmpty(s))
                            s = "1";

                        while (match.Success)
                        {
                            string vod = match.Groups[2].Value;
                            if (!string.IsNullOrEmpty(match.Groups[1].Value) && !string.IsNullOrEmpty(vod) && vod.Contains("/vod/"))
                            {
                                if (int.TryParse(match.Groups[1].Value, out int episode) && episode > 0)
                                {
                                    if (links.FirstOrDefault(i => i.episode == episode).vod == null)
                                        links.Add((episode, s, vod));
                                }
                            }

                            match = match.NextMatch();
                        }

                        if (links.Count == 0)
                            return OnError();

                        proxyManager.Success();
                        hybridCache.Set(memKey, links, cacheTime(30, init: init), inmemory: false);
                    }

                    var etpl = new EpisodeTpl(links.Count);

                    foreach (var l in links.OrderBy(i => i.episode))
                        etpl.Append($"{l.episode} —Å–µ—Ä–∏—è", title, l.s, l.episode.ToString(), accsArgs($"{host}/lite/animedia/video.m3u8?vod={HttpUtility.UrlEncode(l.vod)}"), vast: init.vast);

                    return ContentTo(rjson ? etpl.ToJson() : etpl.ToHtml());
                });
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/animedia/video.m3u8")]
        async public ValueTask<ActionResult> Video(string vod)
        {
            var init = await loadKit(AppInit.conf.AniMedia);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            string memKey = $"animedia:{vod}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out string hls))
                {
                    string embed = await Http.Get(vod, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));

                    if (string.IsNullOrEmpty(embed))
                        return OnError(proxyManager);

                    hls = Regex.Match(embed, "file:\"([^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(hls))
                        return OnError(proxyManager);

                    proxyManager.Success();
                    hybridCache.Set(memKey, hls, cacheTime(180, init: init));
                }

                return Redirect(HostStreamProxy(init, hls, proxy: proxyManager.Get()));
            });
        }
        #endregion
    }
}

```

## File: Online/Controllers/Anime/MoonAnime.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;

namespace Online.Controllers
{
    public class MoonAnime : BaseOnlineController
    {
        static MoonAnime() {
            Directory.CreateDirectory("cache/logs/MoonAnime");
        }

        ProxyManager proxyManager = new ProxyManager(AppInit.conf.MoonAnime);

        [HttpGet]
        [Route("lite/moonanime")]
        async public ValueTask<ActionResult> Index(string imdb_id, string title, string original_title, long animeid, string t, int s = -1, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.MoonAnime);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (animeid == 0)
            {
                #region –ü–æ–∏—Å–∫
                string memkey = $"moonanime:search:{imdb_id}:{title}:{original_title}";

                return await InvkSemaphore(init, memkey, async () =>
                {
                    if (!hybridCache.TryGetValue(memkey, out List<(string title, string year, long id, string poster)> catalog, inmemory: false))
                    {
                        async Task<JObject> goSearch(string arg)
                        {
                            if (string.IsNullOrEmpty(arg.Split("=")?[1]))
                                return null;

                            var search = await Http.Get<JObject>($"{init.corsHost()}/api/2.0/titles?api_key={init.token}&limit=20" + arg, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                            if (search == null || !search.ContainsKey("anime_list"))
                                return null;

                            if (search["anime_list"].Count() == 0)
                                return null;

                            return search;
                        }

                        JObject search = await goSearch($"&imdbid={imdb_id}") ?? await goSearch($"&japanese_title={HttpUtility.UrlEncode(original_title)}") ?? await goSearch($"&title={HttpUtility.UrlEncode(title)}");
                        if (search == null)
                            return OnError(proxyManager);

                        catalog = new List<(string title, string year, long id, string poster)>();

                        foreach (var anime in search["anime_list"])
                        {
                            string _titl = anime.Value<string>("title");
                            int year = anime.Value<int>("year");

                            if (string.IsNullOrEmpty(_titl))
                                continue;

                            catalog.Add((_titl, year.ToString(), anime.Value<long>("id"), anime.Value<string>("poster")));
                        }

                        if (catalog.Count == 0)
                            return OnError();

                        proxyManager.Success();
                        hybridCache.Set(memkey, catalog, cacheTime(40, init: init), inmemory: false);
                    }

                    if (!similar && catalog.Count == 1)
                        return LocalRedirect(accsArgs($"/lite/moonanime?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&animeid={catalog[0].id}"));

                    var stpl = new SimilarTpl(catalog.Count);

                    foreach (var res in catalog)
                    {
                        string uri = $"{host}/lite/moonanime?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&animeid={res.id}";
                        stpl.Append(res.title, res.year, string.Empty, uri, PosterApi.Size(res.poster));
                    }

                    return ContentTo(rjson ? stpl.ToJson() : stpl.ToHtml());
                });
                #endregion
            }
            else 
            {
                #region –°–µ—Ä–∏–∏
                string memKey = $"moonanime:playlist:{animeid}";

                return await InvkSemaphore(init, memKey, async () =>
                {
                    if (!hybridCache.TryGetValue(memKey, out JArray root))
                    {
                        root = await Http.Get<JArray>($"{init.corsHost()}/api/2.0/title/{animeid}/videos?api_key={init.token}", timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                        if (root == null)
                            return OnError(proxyManager);

                        proxyManager.Success();
                        hybridCache.Set(memKey, root, cacheTime(30, init: init));
                    }

                    if (s == -1)
                    {
                        var tpl = new SeasonTpl();
                        var temp = new HashSet<string>();

                        foreach (var voices in root)
                        {
                            foreach (var voice in voices.ToObject<Dictionary<string, Dictionary<string, JArray>>>())
                            {
                                foreach (var season in voice.Value)
                                {
                                    if (temp.Contains(season.Key))
                                        continue;

                                    temp.Add(season.Key);

                                    tpl.Append($"{season.Key} —Å–µ–∑–æ–Ω", $"{host}/lite/moonanime?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&animeid={animeid}&s={season.Key}", season.Key);
                                }
                            }
                        }

                        return ContentTo(rjson ? tpl.ToJson() : tpl.ToHtml());
                    }
                    else
                    {
                        #region –ü–µ—Ä–µ–≤–æ–¥
                        var vtpl = new VoiceTpl();
                        string activTranslate = t;

                        foreach (var voices in root)
                        {
                            foreach (var voice in voices.ToObject<Dictionary<string, Dictionary<string, JArray>>>())
                            {
                                foreach (var season in voice.Value)
                                {
                                    if (season.Key != s.ToString())
                                        continue;

                                    if (string.IsNullOrEmpty(activTranslate))
                                        activTranslate = voice.Key;

                                    vtpl.Append(voice.Key, activTranslate == voice.Key, $"{host}/lite/moonanime?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}&animeid={animeid}&s={s}&t={HttpUtility.UrlEncode(voice.Key)}");
                                }
                            }
                        }
                        #endregion

                        var etpl = new EpisodeTpl();
                        string sArhc = s.ToString();

                        foreach (var voices in root)
                        {
                            foreach (var voice in voices.ToObject<Dictionary<string, Dictionary<string, JArray>>>())
                            {
                                if (voice.Key != activTranslate)
                                    continue;

                                foreach (var season in voice.Value)
                                {
                                    if (season.Key != sArhc)
                                        continue;

                                    foreach (var folder in season.Value)
                                    {
                                        int episode = folder.Value<int>("episode");
                                        string vod = folder.Value<string>("vod");

                                        string link = $"{host}/lite/moonanime/video?vod={HttpUtility.UrlEncode(vod)}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}";
                                        string streamlink = accsArgs($"{link.Replace("/video", "/video.m3u8")}&play=true");

                                        etpl.Append($"{episode} —Å–µ—Ä–∏—è", title, sArhc, episode.ToString(), link, "call", streamlink: streamlink);
                                    }
                                }
                            }
                        }

                        if (rjson)
                            return ContentTo(etpl.ToJson(vtpl));

                        return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                    }
                });
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/moonanime/video")]
        [Route("lite/moonanime/video.m3u8")]
        async public ValueTask<ActionResult> Video(string vod, bool play, string title, string original_title)
        {
            var init = await loadKit(AppInit.conf.MoonAnime);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            string memKey = $"moonanime:vod:{vod}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out (string file, string subtitle) cache))
                {
                    string iframe = await Http.Get(vod + "?partner=lampa", timeoutSeconds: 10, httpversion: 2, proxy: proxyManager.Get(), headers: httpHeaders(init, HeadersModel.Init(
                        ("cache-control", "no-cache"),
                        ("dnt", "1"),
                        ("accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"),
                        ("pragma", "no-cache"),
                        ("priority", "u=0, i"),
                        ("sec-ch-ua", "\"Chromium\";v=\"130\", \"Microsoft Edge\";v=\"130\", \"Not?A_Brand\";v=\"99\""),
                        ("sec-ch-ua-mobile", "?0"),
                        ("sec-ch-ua-platform", "\"Windows\""),
                        ("sec-fetch-dest", "document"),
                        ("sec-fetch-mode", "navigate"),
                        ("sec-fetch-site", "none"),
                        ("sec-fetch-user", "?1"),
                        ("upgrade-insecure-requests", "1"),
                        ("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0")
                    )));

                    if (iframe == null)
                        return OnError(proxyManager);

                    cache.file = Regex.Match(iframe, "file: ?\"([^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(cache.file))
                        return OnError();

                    #region stats
                    _ = await Http.Post("https://moonanime.art/api/stats/", $"{{\"domain\":\"{CrypTo.DecodeBase64("bGFtcGEubXg=")}\",\"player\":\"{vod}?partner=lampa\",\"play\":1}}", timeoutSeconds: 4, httpversion: 2, removeContentType: true, proxy: proxyManager.Get(), headers: HeadersModel.Init(
                        ("accept", "*/*"),
                        ("cache-control", "no-cache"),
                        ("dnt", "1"),
                        ("origin", CrypTo.DecodeBase64("aHR0cDovL2xhbXBhLm14")),
                        ("pragma", "no-cache"),
                        ("priority", "u=1, i"),
                        ("referer", vod),
                        ("sec-ch-ua", "\"Google Chrome\";v=\"131\", \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\""),
                        ("sec-ch-ua-mobile", "?0"),
                        ("sec-ch-ua-platform", "\"Windows\""),
                        ("sec-fetch-dest", "empty"),
                        ("sec-fetch-mode", "cors"),
                        ("sec-fetch-site", "same-origin"),
                        ("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36")
                    ));

                    try
                    {
                        System.IO.File.AppendAllText($"cache/logs/MoonAnime/{DateTime.Today.ToString("MM-yyyy")}.txt", $"{DateTime.Now.ToString("dd / HH:mm")} - {requestInfo.IP} / {vod}\n");
                    }
                    catch { }
                    #endregion

                    cache.subtitle = Regex.Match(iframe, "subtitle: ?\"([^\"]+)\"").Groups[1].Value;
                    if (string.IsNullOrEmpty(cache.subtitle) || cache.subtitle == "null")
                        cache.subtitle = Regex.Match(iframe, "thumbnails: ?\"([^\"]+)\"").Groups[1].Value;

                    proxyManager.Success();
                    hybridCache.Set(memKey, cache, cacheTime(30, init: init));
                }

                var subtitles = new SubtitleTpl();
                if (!string.IsNullOrEmpty(cache.subtitle))
                    subtitles.Append("–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é", cache.subtitle);

                string file = HostStreamProxy(init, cache.file, proxy: proxyManager.Get(), headers: HeadersModel.Init(
                    ("accept", "*/*"),
                    ("accept-language", "ru,en;q=0.9,en-GB;q=0.8,en-US;q=0.7"),
                    ("dnt", "1"),
                    ("origin", CrypTo.DecodeBase64("aHR0cDovL2xhbXBhLm14")),
                    ("priority", "u=1, i"),
                    ("sec-ch-ua", "\"Chromium\";v=\"130\", \"Microsoft Edge\";v=\"130\", \"Not?A_Brand\";v=\"99\""),
                    ("sec-ch-ua-mobile", "?0"),
                    ("sec-ch-ua-platform", "\"Windows\""),
                    ("sec-fetch-dest", "empty"),
                    ("sec-fetch-mode", "cors"),
                    ("sec-fetch-site", "cross-site"),
                    ("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 Edg/130.0.0.0")
                ));


                if (play)
                    return RedirectToPlay(file);

                return ContentTo(VideoTpl.ToJson("play", file, (title ?? original_title), subtitles: subtitles, vast: init.vast));
            });
        }
        #endregion
    }
}

```

## File: Online/Controllers/Anime/AnimeLib.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.AnimeLib;
using Shared.Models.Online.Settings;
using System.Net.Http;
using System.Text;
using System.Threading;

namespace Online.Controllers
{
    public class AnimeLib : BaseOnlineController
    {
        static readonly SemaphoreSlim TokenSemaphore = new SemaphoreSlim(1, 1);

        ProxyManager proxyManager = new ProxyManager(AppInit.conf.AnimeLib);

        [HttpGet]
        [Route("lite/animelib")]
        async public ValueTask<ActionResult> Index(string title, string original_title, int year, string uri, string t, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.AnimeLib);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            await EnsureAnimeLibToken(init);

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var headers = httpHeaders(init, HeadersModel.Init("authorization", $"Bearer {init.token}"));

            if (string.IsNullOrWhiteSpace(uri))
            {
                #region –ü–æ–∏—Å–∫
                if (string.IsNullOrWhiteSpace(title))
                    return OnError();

                string memkey = $"animelib:search:{title}:{original_title}";

                return await InvkSemaphore(init, memkey, async () =>
                {
                    if (!hybridCache.TryGetValue(memkey, out List<(string title, string year, string uri, bool coincidence, string cover)> catalog, inmemory: false))
                    {
                        async Task<DataSearch[]> goSearch(string q)
                        {
                            if (string.IsNullOrEmpty(q))
                                return null;

                            string req_uri = $"{init.corsHost()}/api/anime?fields[]=rate_avg&fields[]=rate&fields[]=releaseDate&q={HttpUtility.UrlEncode(q)}";
                            var result = rch.enable ? await rch.Get<JObject>(req_uri, headers) :
                                                      await Http.Get<JObject>(req_uri, httpversion: 2, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: headers);

                            if (result == null || !result.ContainsKey("data"))
                                return null;

                            return result["data"].ToObject<DataSearch[]>();
                        }

                        var search = await goSearch(original_title);

                        if (search == null || search.Length == 0)
                            search = await goSearch(title);

                        if (search == null || search.Length == 0)
                            return OnError(proxyManager, refresh_proxy: !rch.enable);

                        string stitle = StringConvert.SearchName(title);
                        catalog = new List<(string title, string year, string uri, bool coincidence, string cover)>(search.Length);

                        foreach (var anime in search)
                        {
                            if (string.IsNullOrEmpty(anime.slug_url))
                                continue;

                            var model = ($"{anime.rus_name} / {anime.eng_name}", (anime.releaseDate != null ? anime.releaseDate.Split("-")[0] : "0"), anime.slug_url, false, anime.cover.@default);

                            if (stitle == StringConvert.SearchName(anime.rus_name) || stitle == StringConvert.SearchName(anime.eng_name))
                            {
                                if (!string.IsNullOrEmpty(anime.releaseDate) && anime.releaseDate.StartsWith(year.ToString()))
                                    model.Item4 = true;
                            }

                            catalog.Add(model);
                        }

                        if (catalog.Count == 0)
                            return OnError();

                        if (!rch.enable)
                            proxyManager.Success();

                        hybridCache.Set(memkey, catalog, cacheTime(40, init: init), inmemory: false);
                    }

                    if (!similar && catalog.Where(i => i.coincidence).Count() == 1)
                        return LocalRedirect(accsArgs($"/lite/animelib?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&uri={HttpUtility.UrlEncode(catalog.First(i => i.coincidence).uri)}"));

                    var stpl = new SimilarTpl(catalog.Count);

                    foreach (var res in catalog)
                        stpl.Append(res.title, res.year, string.Empty, $"{host}/lite/animelib?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&uri={HttpUtility.UrlEncode(res.uri)}", PosterApi.Size(res.cover));

                    return ContentTo(rjson ? stpl.ToJson() : stpl.ToHtml());
                });
                #endregion
            }
            else
            {
                #region –°–µ—Ä–∏–∏
                string memKey = $"animelib:playlist:{uri}";

                return await InvkSemaphore(init, memKey, async () =>
                {
                    if (!hybridCache.TryGetValue(memKey, out Episode[] episodes))
                    {
                        string req_uri = $"{init.corsHost()}/api/episodes?anime_id={uri}";

                        var root = rch.enable ? await rch.Get<JObject>(req_uri, headers) :
                                                await Http.Get<JObject>(req_uri, timeoutSeconds: 8, httpversion: 2, proxy: proxyManager.Get(), headers: headers);

                        if (root == null || !root.ContainsKey("data"))
                            return OnError(proxyManager, refresh_proxy: !rch.enable);

                        episodes = root["data"].ToObject<Episode[]>();

                        if (episodes.Length == 0)
                            return OnError();

                        if (!rch.enable)
                            proxyManager.Success();

                        hybridCache.Set(memKey, episodes, cacheTime(30, init: init));
                    }

                    #region –ü–µ—Ä–µ–≤–æ–¥
                    memKey = $"animelib:video:{episodes.First().id}";
                    if (!hybridCache.TryGetValue(memKey, out Player[] players))
                    {
                        if (rch.IsNotConnected())
                            return ContentTo(rch.connectionMsg);

                        string req_uri = $"{init.corsHost()}/api/episodes/{episodes.First().id}";

                        var root = rch.enable ? await rch.Get<JObject>(req_uri, headers) :
                                                await Http.Get<JObject>(req_uri, httpversion: 2, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: headers);

                        if (root == null || !root.ContainsKey("data"))
                            return OnError(proxyManager, refresh_proxy: !rch.enable);

                        players = root["data"]["players"].ToObject<Player[]>();
                        hybridCache.Set(memKey, players, cacheTime(30, init: init));
                    }

                    var vtpl = new VoiceTpl(players.Length);
                    string activTranslate = t;

                    foreach (var player in players)
                    {
                        if (player.player != "Animelib")
                            continue;

                        if (string.IsNullOrEmpty(activTranslate))
                            activTranslate = player.team.name;

                        vtpl.Append(player.team.name, activTranslate == player.team.name, $"{host}/lite/animelib?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&uri={HttpUtility.UrlEncode(uri)}&t={HttpUtility.UrlEncode(player.team.name)}");
                    }
                    #endregion

                    var etpl = new EpisodeTpl(episodes.Length);

                    foreach (var episode in episodes)
                    {
                        string name = string.IsNullOrEmpty(episode.name) ? title : $"{title} / {episode.name}";

                        string link = $"{host}/lite/animelib/video?id={episode.id}&voice={HttpUtility.UrlEncode(activTranslate)}&title={HttpUtility.UrlEncode(title)}";

                        etpl.Append($"{episode.number} —Å–µ—Ä–∏—è", name, episode.season, episode.number, link, "call", streamlink: accsArgs($"{link}&play=true"));
                    }

                    if (rjson)
                        return ContentTo(etpl.ToJson(vtpl));

                    return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                });
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/animelib/video")]
        async public ValueTask<ActionResult> Video(string title, long id, string voice, bool play)
        {
            var init = await loadKit(AppInit.conf.AnimeLib);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            await EnsureAnimeLibToken(init);

            if (string.IsNullOrEmpty(init.token))
                return OnError();

            reset: 
            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var cache = await InvokeCache<Player[]>($"animelib:video:{id}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
            {
                if (rch.IsNotConnected())
                    return res.Fail(rch.connectionMsg);

                string req_uri = $"{init.corsHost()}/api/episodes/{id}";
                var headers = httpHeaders(init, HeadersModel.Init("authorization", $"Bearer {init.token}"));

                var root = rch.enable ? await rch.Get<JObject>(req_uri, headers) :
                                        await Http.Get<JObject>(req_uri, httpversion: 2, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: headers);

                if (root == null || !root.ContainsKey("data"))
                    return res.Fail("data");

                return root["data"]["players"].ToObject<Player[]>();
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            if (!cache.IsSuccess)
                return OnError(cache.ErrorMsg);

            var headers_stream = httpHeaders(init.host, init.headers_stream);

            #region goStreams
            List<(string link, string quality)> goStreams(string _voice)
            {
                var _streams = new List<(string link, string quality)>(5);

                foreach (var player in cache.Value)
                {
                    if (player.player != "Animelib")
                        continue;

                    if (!string.IsNullOrEmpty(_voice) && _voice != player.team.name)
                        continue;

                    foreach (var video in player.video.quality)
                    {
                        if (string.IsNullOrEmpty(video.href))
                            continue;

                        string file = HostStreamProxy(init, "https://video1.cdnlibs.org/.%D0%B0s/" + video.href, proxy: proxyManager.Get(), headers: headers_stream);

                        _streams.Add((file, $"{video.quality}p"));
                    }

                    if (_streams.Count > 0)
                        break;
                }

                return _streams;
            }
            #endregion

            List<(string link, string quality)> streams;

            if (string.IsNullOrEmpty(voice))
            {
                streams = goStreams(null);
            }
            else
            {
                streams = goStreams(voice);
                if (streams.Count == 0)
                    streams = goStreams(null);
            }

            if (streams == null || streams.Count == 0)
                return OnError("streams");

            var streamquality = new StreamQualityTpl(streams);

            if (play)
                return RedirectToPlay(streamquality.Firts().link);

            return ContentTo(VideoTpl.ToJson("play", streamquality.Firts().link, title, streamquality: streamquality, vast: init.vast, headers: init.streamproxy ? null : headers_stream));
        }
        #endregion


        #region [Codex AI] EnsureAnimeLibToken / RequestAnimeLibToken
        async ValueTask EnsureAnimeLibToken(OnlinesSettings init)
        {
            if (!string.IsNullOrEmpty(init.token))
                return;

            try
            {
                await TokenSemaphore.WaitAsync(TimeSpan.FromMinutes(1));

                AnimeLibTokenState cache = null;
                string TokenCachePath = Path.Combine("cache", "animelib.json");

                try
                {
                    string json = System.IO.File.ReadAllText(TokenCachePath);
                    cache = JsonConvert.DeserializeObject<AnimeLibTokenState>(json);
                }
                catch { }

                if (cache == null)
                    return;

                if (!string.IsNullOrEmpty(cache.token) && cache.refresh_time > DateTimeOffset.UtcNow.ToUnixTimeSeconds())
                {
                    init.token = cache.token;
                    return;
                }

                var tokens = await RequestAnimeLibToken(cache.refresh_token);
                if (tokens == null)
                    return;

                cache = new AnimeLibTokenState
                {
                    token = tokens.Value.accessToken,
                    refresh_token = tokens.Value.refreshToken,
                    // 2592000 —Å–µ–∫—É–Ω–¥ / 60 = 43200 –º–∏–Ω—É—Ç
                    // 43200 –º–∏–Ω—É—Ç / 60 = 720 —á–∞—Å–æ–≤
                    // 720 —á–∞—Å–æ–≤ / 24 = 30 –¥–Ω–µ–π
                    refresh_time = DateTimeOffset.UtcNow.AddDays(20).ToUnixTimeSeconds()
                };

                try
                {
                    System.IO.File.WriteAllText(TokenCachePath, JsonConvert.SerializeObject(cache));
                }
                catch { }

                init.token = cache.token;
            }
            catch { }
            finally
            {
                TokenSemaphore.Release();
            }
        }

        async ValueTask<(string accessToken, string refreshToken)?> RequestAnimeLibToken(string refreshToken)
        {
            var payload = JsonConvert.SerializeObject(new
            {
                grant_type = "refresh_token",
                client_id = "1",
                refresh_token = refreshToken,
                scope = string.Empty
            });

            using (var content = new StringContent(payload, Encoding.UTF8, "application/json"))
            {
                var headers = HeadersModel.Init(Http.defaultFullHeaders,
                    ("accept", "*/*"),
                    ("origin", "https://anilib.me"),
                    ("referer", "https://anilib.me/"),
                    ("accept-language", "en-US,en;q=0.9,ru;q=0.8"),
                    ("client-time-zone", "Europe/Kiev"),
                    ("sec-fetch-dest", "empty"),
                    ("sec-fetch-mode", "cors"),
                    ("sec-fetch-site", "cross-site"),
                    ("site-id", "5")
                );

                var result = await Http.Post<JObject>("https://api.cdnlibs.org/api/auth/oauth/token", content, httpversion: 2, timeoutSeconds: 8, headers: headers, useDefaultHeaders: false);
                if (result == null)
                    return null;

                //{"token_type":"Bearer","expires_in":2592000,"access_token":"*","refresh_token":"*"}

                string accessToken = result.Value<string>("access_token");
                string newRefreshToken = result.Value<string>("refresh_token");

                if (string.IsNullOrEmpty(accessToken) || string.IsNullOrEmpty(newRefreshToken))
                    return null;

                return (accessToken, newRefreshToken);
            }
        }
        #endregion
    }
}

```

## File: Online/Controllers/Anime/AniLiberty.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;

namespace Online.Controllers
{
    public class AniLiberty : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/aniliberty")]
        async public ValueTask<ActionResult> Index(string title, int year, int releases, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.AniLiberty);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var proxyManager = new ProxyManager(AppInit.conf.AniLiberty);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (releases == 0)
            {
                #region –ü–æ–∏—Å–∫
                string stitle = StringConvert.SearchName(title);
                if (string.IsNullOrEmpty(stitle))
                    return OnError();

                reset:
                var cache = await InvokeCache<List<(string title, string year, int releases, string cover)>>($"aniliberty:search:{title}:{similar}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string req_uri = $"{init.corsHost()}/api/v1/app/search/releases?query={HttpUtility.UrlEncode(title)}";
                    var search = rch.enable ? await rch.Get<JArray>(req_uri, httpHeaders(init)) :
                                              await Http.Get<JArray>(req_uri, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init));

                    if (search == null || search.Count == 0)
                        return res.Fail("search");

                    bool checkName = true;
                    var catalog = new List<(string title, string year, int releases, string cover)>(search.Count);

                    retry: foreach (var anime in search)
                    {
                        var name = anime["name"];
                        string name_main = StringConvert.SearchName(name.Value<string>("main"));
                        string name_english = StringConvert.SearchName(name.Value<string>("english"));

                        if (!checkName || similar || (name_main != null && name_main.StartsWith(stitle)) || (name_english != null && name_english.StartsWith(stitle)))
                        {
                            int id = anime.Value<int>("id");
                            int releaseDate = anime.Value<int>("year");

                            string img = null;
                            var cover = anime["poster"];
                            if (cover != null)
                                img = init.host + cover.Value<string>("src");

                            catalog.Add(($"{name.Value<string>("main")} / {name.Value<string>("english")}", releaseDate.ToString(), id, img));
                        }
                    }

                    if (catalog.Count == 0)
                    {
                        if (checkName && similar == false)
                        {
                            checkName = false;
                            goto retry;
                        }

                        return res.Fail("catalog");
                    }

                    return catalog;
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                if (!similar && cache.Value != null && cache.Value.Count == 1)
                    return LocalRedirect(accsArgs($"/lite/aniliberty?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&releases={cache.Value.First().releases}"));

                return OnResult(cache, () =>
                {
                    var stpl = new SimilarTpl(cache.Value.Count);

                    foreach (var res in cache.Value)
                        stpl.Append(res.title, res.year, string.Empty, $"{host}/lite/aniliberty?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&releases={res.releases}", PosterApi.Size(res.cover));

                    return rjson ? stpl.ToJson() : stpl.ToHtml();

                }, gbcache: !rch.enable);
                #endregion
            }
            else 
            {
                #region –°–µ—Ä–∏–∏
                reset: 
                var cache = await InvokeCache<JObject>($"aniliberty:releases:{releases}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string req_uri = $"{init.corsHost()}/api/v1/anime/releases/{releases}";

                    var root = rch.enable ? await rch.Get<JObject>(req_uri, httpHeaders(init)) :
                                            await Http.Get<JObject>(req_uri, timeoutSeconds: 8, httpversion: 2, proxy: proxy, headers: httpHeaders(init));

                    if (root == null || !root.ContainsKey("episodes"))
                        return res.Fail("episodes");

                    return root;
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                return OnResult(cache, () =>
                {
                    var episodes = cache.Value["episodes"] as JArray;
                    var etpl = new EpisodeTpl(episodes.Count);

                    foreach (var episode in episodes)
                    {
                        string alias = cache.Value.Value<string>("alias") ?? "";
                        string season = Regex.Match(alias, "-([0-9]+)(nd|th)").Groups[1].Value;
                        if (string.IsNullOrEmpty(season))
                        {
                            season = Regex.Match(alias, "season-([0-9]+)").Groups[1].Value;
                            if (string.IsNullOrEmpty(season))
                                season = "1";
                        }

                        string number = episode.Value<string>("ordinal");

                        string name = episode.Value<string>("name");
                        name = string.IsNullOrEmpty(name) ? $"{number} —Å–µ—Ä–∏—è" : name;

                        var streams = new StreamQualityTpl();
                        foreach (var f in new List<(string quality, string url)>
                        {
                            ("1080p", episode.Value<string>("hls_1080")),
                            ("720p", episode.Value<string>("hls_720")),
                            ("480p", episode.Value<string>("hls_480"))
                        })
                        {
                            if (string.IsNullOrEmpty(f.url))
                                continue;

                            streams.Append(HostStreamProxy(init, f.url, proxy: proxy), f.quality);
                        }

                        etpl.Append(name, title, season, number, streams.Firts().link, streamquality: streams);
                    }

                    return rjson ? etpl.ToJson() : etpl.ToHtml();

                }, gbcache: !rch.enable);
                #endregion
            }
        }
    }
}

```

## File: Online/Controllers/Anime/Kodik.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared.Models.Online.Kodik;
using Shared.Models.Online.Settings;
using System.Security.Cryptography;
using System.Text;

namespace Online.Controllers
{
    public class Kodik : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.Kodik);

        #region database
        static List<Result> databaseCache;

        static IEnumerable<Result> database
        {
            get
            {
                if (AppInit.conf.multiaccess || databaseCache != null)
                    return databaseCache ??= JsonHelper.ListReader<Result>("data/kodik.json", 70_000);

                return JsonHelper.IEnumerableReader<Result>("data/kodik.json");
            }
        }
        #endregion

        #region InitKodikInvoke
        public KodikInvoke InitKodikInvoke(KodikSettings init)
        {
            var proxy = proxyManager.Get();

            return new KodikInvoke
            (
                host,
                init.apihost,
                init.token,
                init.hls,
                init.cdn_is_working,
                "video",
                database,
                (uri, head) => Http.Get(init.cors(uri), timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
                (uri, data) => Http.Post(init.cors(uri), data, timeoutSeconds: 8, proxy: proxy, headers: httpHeaders(init)),
                streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
                requesterror: () => proxyManager.Refresh()
            );
        }
        #endregion

        #region Initialization
        ValueTask<KodikSettings> Initialization()
        {
            return loadKit(AppInit.conf.Kodik, (j, i, c) =>
            {
                if (j.ContainsKey("linkhost"))
                    i.linkhost = c.linkhost;

                if (j.ContainsKey("secret_token"))
                    i.secret_token = c.secret_token;

                if (j.ContainsKey("auto_proxy"))
                    i.auto_proxy = c.auto_proxy;

                if (j.ContainsKey("cdn_is_working"))
                    i.cdn_is_working = c.cdn_is_working;

                return i;
            });
        }
        #endregion

        [HttpGet]
        [Route("lite/kodik")]
        async public ValueTask<ActionResult> Index(string imdb_id, long kinopoisk_id, string title, string original_title, int clarification, string pick, string kid, int s = -1, bool rjson = false, bool similar = false)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            List<Result> content = null;
            var oninvk = InitKodikInvoke(init);

            if (similar || clarification == 1 || (kinopoisk_id == 0 && string.IsNullOrEmpty(imdb_id)))
            {
                EmbedModel res = null;

                if (clarification == 1)
                {
                    if (string.IsNullOrEmpty(title))
                        return OnError();

                    res = await InvokeCache($"kodik:search:{title}", cacheTime(40, init: init), () => oninvk.Embed(title, null, clarification), proxyManager);
                    if (res?.result == null || res.result.Count == 0)
                        return OnError();
                }
                else
                {
                    if (string.IsNullOrEmpty(pick) && string.IsNullOrEmpty(title ?? original_title))
                        return OnError();

                    res = await InvokeCache($"kodik:search2:{original_title}:{title}:{clarification}", cacheTime(40, init: AppInit.conf.Kodik), async () => 
                    {
                        var i = await oninvk.Embed(null, original_title, clarification);
                        if (i?.result == null || i.result.Count == 0)
                            return await oninvk.Embed(title, null, clarification);

                        return i;

                    }, proxyManager);
                }

                if (string.IsNullOrEmpty(pick))
                    return ContentTo(res?.stpl == null ? string.Empty : (rjson ? res.stpl.Value.ToJson() : res.stpl.Value.ToHtml()));

                content = oninvk.Embed(res.result, pick);
            }
            else
            {
                content = await InvokeCache($"kodik:search:{kinopoisk_id}:{imdb_id}", cacheTime(40, init: AppInit.conf.Kodik), () => oninvk.Embed(imdb_id, kinopoisk_id, s), proxyManager);
                if (content == null || content.Count == 0)
                    return LocalRedirect(accsArgs($"/lite/kodik?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&original_title={HttpUtility.UrlEncode(original_title)}"));
            }

            return ContentTo(await oninvk.Html(content, accsArgs(string.Empty), imdb_id, kinopoisk_id, title, original_title, clarification, pick, kid, s, true, rjson));
        }

        #region Video
        [HttpGet]
        [Route("lite/kodik/video")]
        [Route("lite/kodik/video.m3u8")]
        async public ValueTask<ActionResult> VideoAPI(string title, string original_title, string link, int episode, bool play)
        {
            var init = await Initialization();
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (string.IsNullOrWhiteSpace(init.secret_token))
            {
                var oninvk = InitKodikInvoke(init);

                var streams = await InvokeCache($"kodik:video:{link}:{play}", cacheTime(40, init: init), () => oninvk.VideoParse(init.linkhost, link), proxyManager);
                if (streams == null)
                    return OnError();

                string result = oninvk.VideoParse(streams, title, original_title, episode, play, vast: init.vast);
                if (string.IsNullOrEmpty(result))
                    return OnError();

                if (play)
                    return RedirectToPlay(result);

                return ContentTo(result);
            }
            else
            {
                string userIp = requestInfo.IP;
                if (init.localip)
                {
                    userIp = await mylocalip();
                    if (userIp == null)
                        return OnError();
                }

                var proxy = proxyManager.Get();

                string memKey = $"kodik:view:stream:{link}:{init.secret_token}:{requestInfo.IP}";

                return await InvkSemaphore(init, memKey, async () =>
                {
                    if (!hybridCache.TryGetValue(memKey, out (List<(string q, string url)> streams, SegmentTpl segments) cache))
                    {
                        string deadline = DateTime.Now.AddHours(4).ToString("yyyy MM dd HH").Replace(" ", "");
                        string hmac = HMAC(init.secret_token, $"{link}:{userIp}:{deadline}");

                        var root = await Http.Get<JObject>($"http://kodik.biz/api/video-links?link={link}&p={init.token}&ip={userIp}&d={deadline}&s={hmac}&auto_proxy={init.auto_proxy.ToString().ToLower()}&skip_segments=true", timeoutSeconds: 8, proxy: proxy);

                        if (root == null || !root.ContainsKey("links"))
                            return OnError("links");

                        cache.streams = new List<(string q, string url)>(3);

                        foreach (var link in root["links"].ToObject<Dictionary<string, JObject>>())
                        {
                            string src = link.Value.Value<string>("Src");
                            if (src.StartsWith("http"))
                                src = src.Substring(src.IndexOf("://") + 3);

                            cache.streams.Add(($"{link.Key}p", $"https://{src}"));
                        }

                        if (cache.streams.Count == 0)
                        {
                            proxyManager.Refresh();
                            return OnError("streams");
                        }

                        cache.streams.Reverse();

                        if (root.ContainsKey("segments"))
                        {
                            var segs = root["segments"] as JObject;
                            if (segs != null)
                            {
                                cache.segments = new SegmentTpl();

                                foreach (string key in new string[] { "ad", "skip" })
                                {
                                    if (segs.ContainsKey(key))
                                    {
                                        var arr = segs[key] as JArray;
                                        if (arr != null)
                                        {
                                            foreach (var it in arr)
                                            {
                                                int? s = it.Value<int?>("start");
                                                int? e = it.Value<int?>("end");
                                                if (s.HasValue && e.HasValue)
                                                    cache.segments.ad(s.Value, e.Value);
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        proxyManager.Success();
                        hybridCache.Set(memKey, cache, cacheTime(120, init: init));
                    }

                    var streamquality = new StreamQualityTpl();
                    foreach (var l in cache.streams)
                        streamquality.Append(HostStreamProxy(init, l.url, proxy: proxy), l.q);

                    if (play)
                        return RedirectToPlay(streamquality.Firts().link);

                    string name = title ?? original_title;
                    if (episode > 0)
                        name += $" ({episode} —Å–µ—Ä–∏—è)";

                    return ContentTo(VideoTpl.ToJson("play", streamquality.Firts().link, name, streamquality: streamquality, vast: init.vast, segments: cache.segments));
                });
            }
        }
        #endregion


        #region HMAC
        static string HMAC(string key, string message)
        {
            using (var hash = new HMACSHA256(Encoding.UTF8.GetBytes(key)))
            {
                return BitConverter.ToString(hash.ComputeHash(Encoding.UTF8.GetBytes(message))).Replace("-", "").ToLower();
            }
        }
        #endregion
    }
}

```

## File: Online/Controllers/Anime/AnimeGo.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;

namespace Online.Controllers
{
    public class AnimeGo : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.AnimeGo);

        [HttpGet]
        [Route("lite/animego")]
        async public ValueTask<ActionResult> Index(string title, int year, int pid, int s, string t, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.AnimeGo);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var headers_stream = httpHeaders(init.host, init.headers_stream);

            if (pid == 0)
            {
                #region –ü–æ–∏—Å–∫
                string memkey = $"animego:search:{title}";

                return await InvkSemaphore(init, memkey, async () =>
                {
                    if (!hybridCache.TryGetValue(memkey, out List<(string title, string year, string pid, string s, string img)> catalog, inmemory: false))
                    {
                        string search = await Http.Get($"{init.corsHost()}/search/anime?q={HttpUtility.UrlEncode(title)}", timeoutSeconds: 10, proxy: proxyManager.Get(), headers: httpHeaders(init), httpversion: 2);
                        if (search == null)
                            return OnError(proxyManager);

                        var rows = search.Split("class=\"p-poster__stack\"");

                        catalog = new List<(string title, string year, string pid, string s, string img)>(rows.Length);

                        foreach (string row in rows.Skip(1))
                        {
                            string player_id = Regex.Match(row, "data-ajax-url=\"/[^\"]+-([0-9]+)\"").Groups[1].Value;
                            string name = Regex.Match(row, "card-title text-truncate\"><a [^>]+>([^<]+)<").Groups[1].Value;
                            string animeyear = Regex.Match(row, "class=\"anime-year\"><a [^>]+>([0-9]{4})<").Groups[1].Value;
                            string img = Regex.Match(row, "data-original=\"([^\"]+)\"").Groups[1].Value;
                            if (string.IsNullOrEmpty(img))
                                img = null;

                            if (!string.IsNullOrWhiteSpace(player_id) && !string.IsNullOrWhiteSpace(name) && StringConvert.SearchName(name).Contains(StringConvert.SearchName(title)))
                            {
                                string season = "0";
                                if (animeyear == year.ToString() && StringConvert.SearchName(name) == StringConvert.SearchName(title))
                                    season = "1";

                                catalog.Add((name, Regex.Match(row, ">([0-9]{4})</a>").Groups[1].Value, player_id, season, img));
                            }
                        }

                        if (catalog.Count == 0)
                            return OnError();

                        proxyManager.Success();
                        hybridCache.Set(memkey, catalog, cacheTime(40, init: init), inmemory: false);
                    }

                    if (!similar && catalog.Count == 1)
                        return LocalRedirect(accsArgs($"/lite/animego?title={HttpUtility.UrlEncode(title)}&pid={catalog[0].pid}&s={catalog[0].s}"));

                    var stpl = new SimilarTpl(catalog.Count);

                    foreach (var res in catalog)
                    {
                        string uri = $"{host}/lite/animego?title={HttpUtility.UrlEncode(title)}&pid={res.pid}&s={res.s}";
                        stpl.Append(res.title, res.year, string.Empty, uri, PosterApi.Size(res.img));
                    }

                    return ContentTo(rjson ? stpl.ToJson() : stpl.ToHtml());
                });
                #endregion
            }
            else 
            {
                #region –°–µ—Ä–∏–∏
                string memKey = $"animego:playlist:{pid}";

                return await InvkSemaphore(init, memKey, async () =>
                {
                    if (!hybridCache.TryGetValue(memKey, out (string translation, List<(string episode, string uri)> links, List<(string name, string id)> translations) cache))
                    {
                        #region content
                        var player = await Http.Get<JObject>($"{init.corsHost()}/anime/{pid}/player?_allow=true", timeoutSeconds: 10, proxy: proxyManager.Get(), httpversion: 2, headers: httpHeaders(init, HeadersModel.Init(
                            ("cache-control", "no-cache"),
                            ("dnt", "1"),
                            ("pragma", "no-cache"),
                            ("referer", $"{init.host}/"),
                            ("sec-fetch-dest", "empty"),
                            ("sec-fetch-mode", "cors"),
                            ("sec-fetch-site", "same-origin"),
                            ("x-requested-with", "XMLHttpRequest")
                        )));

                        string content = player?.Value<string>("content");
                        if (string.IsNullOrWhiteSpace(content))
                            return OnError(proxyManager);
                        #endregion

                        var g = Regex.Match(content, "data-player=\"(https?:)?//(aniboom\\.[^/]+)/embed/([^\"\\?&]+)\\?episode=1\\&amp;translation=([0-9]+)\"").Groups;
                        if (string.IsNullOrWhiteSpace(g[2].Value) || string.IsNullOrWhiteSpace(g[3].Value) || string.IsNullOrWhiteSpace(g[4].Value))
                            return OnError();

                        #region links
                        var match = Regex.Match(content, "data-episode=\"([0-9]+)\"");
                        cache.links = new List<(string episode, string uri)>(match.Length);

                        while (match.Success)
                        {
                            if (!string.IsNullOrWhiteSpace(match.Groups[1].Value))
                                cache.links.Add((match.Groups[1].Value, $"video.m3u8?host={g[2].Value}&token={g[3].Value}&e={match.Groups[1].Value}"));

                            match = match.NextMatch();
                        }

                        if (cache.links.Count == 0)
                            return OnError();
                        #endregion

                        #region translation / translations
                        match = Regex.Match(content, "data-player=\"(https?:)?//aniboom\\.[^/]+/embed/[^\"\\?&]+\\?episode=[0-9]+\\&amp;translation=([0-9]+)\"[\n\r\t ]+data-provider=\"[0-9]+\"[\n\r\t ]+data-provide-dubbing=\"([0-9]+)\"");

                        cache.translation = g[4].Value;
                        cache.translations = new List<(string name, string id)>(match.Length);

                        while (match.Success)
                        {
                            if (!string.IsNullOrWhiteSpace(match.Groups[2].Value) && !string.IsNullOrWhiteSpace(match.Groups[3].Value))
                            {
                                string name = Regex.Match(content, $"data-dubbing=\"{match.Groups[3].Value}\"><span [^>]+>[\n\r\t ]+([^\n\r<]+)").Groups[1].Value.Trim();
                                if (!string.IsNullOrWhiteSpace(name))
                                    cache.translations.Add((name, match.Groups[2].Value));
                            }

                            match = match.NextMatch();
                        }
                        #endregion

                        proxyManager.Success();
                        hybridCache.Set(memKey, cache, cacheTime(30, init: init));
                    }

                    #region –ü–µ—Ä–µ–≤–æ–¥
                    var vtpl = new VoiceTpl(cache.translations.Count);
                    if (string.IsNullOrWhiteSpace(t))
                        t = cache.translation;

                    foreach (var translation in cache.translations)
                    {
                        string link = $"{host}/lite/animego?pid={pid}&title={HttpUtility.UrlEncode(title)}&s={s}&t={translation.id}";
                        vtpl.Append(translation.name, t == translation.id, link);
                    }
                    #endregion

                    var etpl = new EpisodeTpl(cache.links.Count);
                    string sArhc = s.ToString();

                    foreach (var l in cache.links)
                    {
                        string hls = accsArgs($"{host}/lite/animego/{l.uri}&t={t ?? cache.translation}");

                        etpl.Append($"{l.episode} —Å–µ—Ä–∏—è", title, sArhc, l.episode, hls, "play", headers: headers_stream);
                    }

                    if (rjson)
                        return ContentTo(etpl.ToJson(vtpl));

                    return ContentTo(vtpl.ToHtml() + etpl.ToHtml());
                });
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/animego/video.m3u8")]
        async public ValueTask<ActionResult> Video(string host, string token, string t, int e)
        {
            var init = await loadKit(AppInit.conf.AnimeGo);
            if (await IsBadInitialization(init, rch: false))
                return badInitMsg;

            string memKey = $"animego:video:{token}:{t}:{e}";

            return await InvkSemaphore(init, memKey, async () =>
            {
                if (!hybridCache.TryGetValue(memKey, out string hls))
                {
                    string embed = await Http.Get($"https://{host}/embed/{token}?episode={e}&translation={t}", timeoutSeconds: 10, proxy: proxyManager.Get(), httpversion: 2, headers: httpHeaders(init, HeadersModel.Init(
                        ("cache-control", "no-cache"),
                        ("dnt", "1"),
                        ("pragma", "no-cache"),
                        ("referer", $"{init.host}/"),
                        ("sec-fetch-dest", "empty"),
                        ("sec-fetch-mode", "cors"),
                        ("sec-fetch-site", "same-origin"),
                        ("x-requested-with", "XMLHttpRequest")
                    )));

                    if (string.IsNullOrWhiteSpace(embed))
                        return OnError(proxyManager);

                    embed = embed.Replace("&quot;", "\"").Replace("\\", "");

                    hls = Regex.Match(embed, "\"hls\":\"\\{\"src\":\"(https?:)?(//[^\"]+\\.m3u8)\"").Groups[2].Value;
                    if (string.IsNullOrWhiteSpace(hls))
                        return OnError(proxyManager);

                    hls = "https:" + hls;

                    proxyManager.Success();
                    hybridCache.Set(memKey, hls, cacheTime(30, init: init));
                }

                return Redirect(HostStreamProxy(init, hls, proxy: proxyManager.Get()));
            });
        }
        #endregion
    }
}

```

## File: Online/Controllers/Anime/AniLibria.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared.Models.Online.AniLibria;

namespace Online.Controllers
{
    public class AniLibriaOnline : BaseOnlineController
    {
        [HttpGet]
        [Route("lite/anilibria")]
        async public ValueTask<ActionResult> Index(string title, string code, int year, bool origsource = false, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.AnilibriaOnline);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrEmpty(title))
                return OnError();

            var proxyManager = new ProxyManager(init);
            var proxy = proxyManager.Get();

            var rch = new RchClient(HttpContext, host, init, requestInfo);
            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            var oninvk = new AniLibriaInvoke
            (
               host,
               init.corsHost(),
               ongettourl => rch.enable ? rch.Get<List<RootObject>>(init.cors(ongettourl)) : Http.Get<List<RootObject>>(init.cors(ongettourl), timeoutSeconds: 40, proxy: proxy, IgnoreDeserializeObject: true, headers: httpHeaders(init)),
               streamfile => HostStreamProxy(init, streamfile, proxy: proxy),
               requesterror: () => { if (!rch.enable) { proxyManager.Refresh(); } }
            );

            reset:
            var cache = await InvokeCache<List<RootObject>>($"anilibriaonline:{title}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
            {
                return await oninvk.Embed(title);
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            return OnResult(cache, () => oninvk.Html(cache.Value, title, code, year, vast: init.vast, rjson: rjson, similar: similar), origsource: origsource, gbcache: !rch.enable);
        }
    }
}

```

## File: Online/Controllers/Anime/Animebesst.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace Online.Controllers
{
    public class Animebesst : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.Animebesst);

        [HttpGet]
        [Route("lite/animebesst")]
        async public ValueTask<ActionResult> Index(string title, string uri, int s, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.Animebesst);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("cors,web", out string rch_error))
                return ShowError(rch_error);

            reset:
            if (string.IsNullOrEmpty(uri))
            {
                if (string.IsNullOrWhiteSpace(title))
                    return OnError();

                #region –ü–æ–∏—Å–∫
                var cache = await InvokeCache<List<(string title, string year, string uri, string s, string img)>>($"animebesst:search:{title}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string data = $"do=search&subaction=search&search_start=0&full_search=0&result_from=1&story={HttpUtility.UrlEncode(title)}";
                    string search = rch.enable ? await rch.Post($"{init.corsHost()}/index.php?do=search", data) : await Http.Post($"{init.corsHost()}/index.php?do=search", data, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                    if (search == null)
                        return res.Fail("search");

                    var rows = search.Split("id=\"sidebar\"")[0].Split("class=\"shortstory-listab\"");

                    var catalog = new List<(string title, string year, string uri, string s, string img)>(rows.Length);

                    foreach (string row in rows.Skip(1))
                    {
                        if (row.Contains("–ù–æ–≤–æ—Å—Ç–∏"))
                            continue;

                        var g = Regex.Match(row, "class=\"shortstory-listab-title\"><a href=\"(https?://[^\"]+\\.html)\">([^<]+)</a>").Groups;

                        if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                        {
                            string season = "0";
                            if (g[2].Value.Contains("—Å–µ–∑–æ–Ω"))
                            {
                                season = Regex.Match(g[2].Value, "([0-9]+) —Å–µ–∑–æ–Ω").Groups[1].Value;
                                if (string.IsNullOrEmpty(season))
                                    season = "1";
                            }

                            string img = Regex.Match(row, "<img class=\"img-fit lozad\" data-src=\"([^\"]+)\"").Groups[1].Value;
                            if (string.IsNullOrEmpty(img))
                                img = null;

                            catalog.Add((g[2].Value, Regex.Match(row, "\">([0-9]{4})</a>").Groups[1].Value, g[1].Value, season, img));
                        }
                    }

                    if (catalog.Count == 0 && !search.Contains(">–ü–æ–∏—Å–∫ –ø–æ —Å–∞–π—Ç—É<"))
                        return res.Fail("catalog");

                    return catalog;
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                if (cache.Value != null && cache.Value.Count == 0)
                    return OnError();

                if (!similar && cache.Value != null && cache.Value.Count == 1)
                    return LocalRedirect(accsArgs($"/lite/animebesst?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&uri={HttpUtility.UrlEncode(cache.Value[0].uri)}&s={cache.Value[0].s}"));

                return OnResult(cache, () =>
                {
                    var stpl = new SimilarTpl(cache.Value.Count);

                    foreach (var res in cache.Value)
                    {
                        string _u = $"{host}/lite/animebesst?title={HttpUtility.UrlEncode(title)}&uri={HttpUtility.UrlEncode(res.uri)}&s={res.s}";
                        stpl.Append(res.title, res.year, string.Empty, _u, PosterApi.Size(res.img));
                    }

                    return rjson ? stpl.ToJson() : stpl.ToHtml();

                }, gbcache: !rch.enable);
                #endregion
            }
            else 
            {
                #region –°–µ—Ä–∏–∏
                var cache = await InvokeCache<List<(string episode, string name, string uri)>>($"animebesst:playlist:{uri}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string news = rch.enable ? await rch.Get(uri) : await Http.Get(uri, timeoutSeconds: 10, proxy: proxyManager.Get(), headers: httpHeaders(init));
                    if (news == null)
                        return res.Fail("news");

                    string videoList = Regex.Match(news, "var videoList ?=([^\n\r]+)").Groups[1].Value.Trim();
                    if (string.IsNullOrEmpty(videoList))
                        return res.Fail("videoList");

                    var links = new List<(string episode, string name, string uri)>(5);
                    var match = Regex.Match(videoList, "\"id\":\"([0-9]+)( [^\"]+)?\",\"link\":\"(https?:)?\\\\/\\\\/([^\"]+)\"");
                    while (match.Success)
                    {
                        if (!string.IsNullOrWhiteSpace(match.Groups[1].Value) && !string.IsNullOrWhiteSpace(match.Groups[4].Value))
                            links.Add((match.Groups[1].Value, match.Groups[2].Value.Trim(), match.Groups[4].Value.Replace("\\", "")));

                        match = match.NextMatch();
                    }

                    if (links.Count == 0)
                        return res.Fail("links");

                    return links;
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                return OnResult(cache, () =>
                {
                    var etpl = new EpisodeTpl(cache.Value.Count);
                    string sArhc = s.ToString();

                    foreach (var l in cache.Value)
                    {
                        string name = string.IsNullOrEmpty(l.name) ? $"{l.episode} —Å–µ—Ä–∏—è" : $"{l.episode} {l.name}";
                        string voice_name = !string.IsNullOrEmpty(l.name) ? Regex.Replace(l.name, "(^\\(|\\)$)", "") : "";

                        string link = accsArgs($"{host}/lite/animebesst/video.m3u8?uri={HttpUtility.UrlEncode(l.uri)}&title={HttpUtility.UrlEncode(title)}");

                        etpl.Append(name, $"{title} / {name}", sArhc, l.episode, link, "call", streamlink: $"{link}&play=true", voice_name: Regex.Unescape(voice_name));
                    }

                    return rjson ? etpl.ToJson() : etpl.ToHtml();

                }, gbcache: !rch.enable);
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/animebesst/video.m3u8")]
        async public ValueTask<ActionResult> Video(string uri, string title, bool play)
        {
            var init = await loadKit(AppInit.conf.Animebesst);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            reset: 
            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("cors,web", out string rch_error))
                return ShowError(rch_error);

            var cache = await InvokeCache<string>($"animebesst:video:{uri}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
            {
                if (rch.IsNotConnected())
                    return res.Fail(rch.connectionMsg);

                string iframe;
                if (rch.enable)
                {
                    iframe = await rch.Get(init.cors($"https://{uri}"), headers: httpHeaders(init));
                }
                else
                {
                    iframe = await Http.Get(init.cors($"https://{uri}"), referer: init.host, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init), httpversion: 2);
                }

                if (iframe == null)
                    return res.Fail("iframe");

                string hls = Regex.Match(iframe, "file:\"(https?://[^\"]+\\.m3u8)\"").Groups[1].Value;
                if (string.IsNullOrEmpty(hls))
                    return res.Fail("hls");

                return hls;
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            if (!cache.IsSuccess)
                return OnError(cache.ErrorMsg, gbcache: !rch.enable);

            string link = HostStreamProxy(init, cache.Value, proxy: proxyManager.Get());

            if (play)
                return RedirectToPlay(link);

            return ContentTo(VideoTpl.ToJson("play", link, title, vast: init.vast));
        }
        #endregion
    }
}

```

## File: Online/Controllers/Anime/Animevost.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;

namespace Online.Controllers
{
    public class Animevost : BaseOnlineController
    {
        ProxyManager proxyManager = new ProxyManager(AppInit.conf.Animevost);

        [HttpGet]
        [Route("lite/animevost")]
        async public ValueTask<ActionResult> Index(string title, int year, string uri, int s, bool rjson = false, bool similar = false)
        {
            var init = await loadKit(AppInit.conf.Animevost);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            if (string.IsNullOrWhiteSpace(title))
                return OnError();

            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected() || rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            reset:
            if (string.IsNullOrWhiteSpace(uri))
            {
                #region –ü–æ–∏—Å–∫
                var cache = await InvokeCache<List<(string title, string year, string uri, string s, string img)>>($"animevost:search:{title}:{similar}", cacheTime(40, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string data = $"do=search&subaction=search&search_start=0&full_search=0&result_from=1&story={HttpUtility.UrlEncode(title)}";
                    string search = rch.enable ? await rch.Post($"{init.corsHost()}/index.php?do=search", data) : await Http.Post($"{init.corsHost()}/index.php?do=search", data, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));
                    if (search == null)
                        return res.Fail("search");

                    var rows = search.Split("class=\"shortstory\"");

                    var smlr = new List<(string title, string year, string uri, string s, string img)>(rows.Length);
                    var catalog = new List<(string title, string year, string uri, string s, string img)>(rows.Length);

                    foreach (string row in rows.Skip(1))
                    {
                        var g = Regex.Match(row, "<a href=\"(https?://[^\"]+\\.html)\">([^<]+)</a>").Groups;
                        string animeyear = Regex.Match(row, "<strong>–ì–æ–¥ –≤—ã—Ö–æ–¥–∞: ?</strong>([0-9]{4})</p>").Groups[1].Value;
                        string img = Regex.Match(row, " src=\"(/uploads/[^\"]+)\"").Groups[1].Value;
                        if (!string.IsNullOrEmpty(img))
                            img = init.host + img;

                        if (!string.IsNullOrWhiteSpace(g[1].Value) && !string.IsNullOrWhiteSpace(g[2].Value))
                        {
                            string season = Regex.Match(g[2].Value, "([0-9 ]+) ?nd ", RegexOptions.IgnoreCase).Groups[1].Value.Trim();
                            if (string.IsNullOrEmpty(season))
                            {
                                season = Regex.Match(g[2].Value, "Season ([0-9]+)", RegexOptions.IgnoreCase).Groups[1].Value.Trim();
                                if (string.IsNullOrEmpty(season))
                                    season = "1";
                            }

                            smlr.Add((g[2].Value, animeyear, g[1].Value, season, string.IsNullOrEmpty(img) ? null : img));

                            if (animeyear == year.ToString() && StringConvert.SearchName(g[2].Value).Contains(StringConvert.SearchName(title)))
                                catalog.Add((g[2].Value, animeyear, g[1].Value, season, null));
                        }
                    }

                    if (catalog.Count == 0 && smlr.Count == 0)
                        return res.Fail("catalog");

                    if (!similar && catalog.Count > 0)
                        return catalog;

                    return smlr;
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                if (!similar && cache.Value != null && cache.Value.Count == 1)
                    return LocalRedirect(accsArgs($"/lite/animevost?rjson={rjson}&title={HttpUtility.UrlEncode(title)}&uri={HttpUtility.UrlEncode(cache.Value[0].uri)}&s={cache.Value[0].s}"));

                return OnResult(cache, () =>
                {
                    if (cache.Value.Count == 0)
                        return string.Empty;

                    var stpl = new SimilarTpl(cache.Value.Count);

                    foreach (var res in cache.Value)
                    {
                        string uri = $"{host}/lite/animevost?title={HttpUtility.UrlEncode(title)}&uri={HttpUtility.UrlEncode(res.uri)}&s={res.s}";
                        stpl.Append(res.title, res.year, string.Empty, uri, PosterApi.Size(res.img));
                    }

                    return rjson ? stpl.ToJson() : stpl.ToHtml();

                }, gbcache: !rch.enable);
                #endregion
            }
            else 
            {
                #region –°–µ—Ä–∏–∏
                var cache = await InvokeCache<List<(string episode, string id)>>($"animevost:playlist:{uri}", cacheTime(30, init: init), rch.enable ? null : proxyManager, async res =>
                {
                    string news = rch.enable ? await rch.Get(uri) : await Http.Get(uri, timeoutSeconds: 10, proxy: proxyManager.Get(), headers: httpHeaders(init));
                    if (news == null)
                    {
                        if (!rch.enable)
                            proxyManager.Refresh();

                        return res.Fail("news");
                    }

                    string data = Regex.Match(news, "var data = ([^\n\r]+)").Groups[1].Value;
                    if (string.IsNullOrEmpty(data))
                    {
                        if (!rch.enable)
                            proxyManager.Refresh();

                        return res.Fail("data");
                    }

                    var match = Regex.Match(data, "\"([^\"]+)\":\"([0-9]+)\",");
                    var links = new List<(string episode, string id)>(match.Length);

                    while (match.Success)
                    {
                        if (!string.IsNullOrWhiteSpace(match.Groups[1].Value) && !string.IsNullOrWhiteSpace(match.Groups[2].Value))
                            links.Add((match.Groups[1].Value, match.Groups[2].Value));

                        match = match.NextMatch();
                    }

                    if (links.Count == 0)
                        return res.Fail("links");

                    return links;
                });

                if (IsRhubFallback(cache, init))
                    goto reset;

                return OnResult(cache, () =>
                {
                    var etpl = new EpisodeTpl(cache.Value.Count);
                    string sArhc = s.ToString();

                    foreach (var l in cache.Value)
                    {
                        string link = $"{host}/lite/animevost/video?id={l.id}&title={HttpUtility.UrlEncode(title)}";

                        etpl.Append(l.episode, title, sArhc, Regex.Match(l.episode, "^([0-9]+)").Groups[1].Value, link, "call", streamlink: accsArgs($"{link}&play=true"));
                    }

                    return rjson ? etpl.ToJson() : etpl.ToHtml();

                }, gbcache: !rch.enable);
                #endregion
            }
        }


        #region Video
        [HttpGet]
        [Route("lite/animevost/video")]
        async public ValueTask<ActionResult> Video(int id, string title, bool play)
        {
            var init = await loadKit(AppInit.conf.Animevost);
            if (await IsBadInitialization(init, rch: true))
                return badInitMsg;

            reset: 
            var rch = new RchClient(HttpContext, host, init, requestInfo, keepalive: -1);

            if (rch.IsNotConnected())
            {
                if (init.rhub_fallback && play)
                    rch.Disabled();
                else
                    return ContentTo(rch.connectionMsg);
            }

            if (!play && rch.IsRequiredConnected())
                return ContentTo(rch.connectionMsg);

            if (rch.IsNotSupport("web", out string rch_error))
                return ShowError(rch_error);

            var cache = await InvokeCache<List<(string l, string q)>>($"animevost:video:{id}", cacheTime(20, init: init), rch.enable ? null : proxyManager, async res =>
            {
                if (rch.IsNotConnected())
                    return res.Fail(rch.connectionMsg);

                string uri = $"{init.corsHost()}/frame5.php?play={id}&old=1";
                string iframe = rch.enable ? await rch.Get(uri) : await Http.Get(uri, timeoutSeconds: 8, proxy: proxyManager.Get(), headers: httpHeaders(init));

                var links = new List<(string l, string q)>(2);

                string mp4 = Regex.Match(iframe ?? "", "download=\"invoice\"[^>]+href=\"(https?://[^\"]+)\">720p").Groups[1].Value;
                if (!string.IsNullOrEmpty(mp4))
                    links.Add((mp4, "720p"));

                mp4 = Regex.Match(iframe ?? "", "download=\"invoice\"[^>]+href=\"(https?://[^\"]+)\">480p").Groups[1].Value;
                if (!string.IsNullOrEmpty(mp4))
                    links.Add((mp4, "480p"));

                if (links.Count == 0)
                {
                    if (!rch.enable)
                        proxyManager.Refresh();

                    return res.Fail("mp4");
                }

                if (!rch.enable)
                    proxyManager.Success();

                return links;
            });

            if (IsRhubFallback(cache, init))
                goto reset;

            if (cache.IsSuccess && play)
                return Redirect(HostStreamProxy(init, cache.Value[0].l, proxy: proxyManager.Get()));

            return OnResult(cache, () =>
            {
                string link = HostStreamProxy(init, cache.Value[0].l, proxy: proxyManager.Get());
                return VideoTpl.ToJson("play", link, title, vast: init.vast);

            }, gbcache: !rch.enable);
        }
        #endregion
    }
}

```

## File: TorrServer/ApiController.cs
```
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Shared;
using Shared.Engine;
using Shared.Models.Base;
using System;
using System.Buffers;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Web;

namespace TorrServer.Controllers
{
    public class TorrServerController : BaseController
    {
        #region ts.js
        [HttpGet]
        [AllowAnonymous]
        [Route("ts.js")]
        [Route("ts/js/{token}")]
        public ActionResult Plugin(string token)
        {
            string file = FileCache.ReadAllText("plugins/ts.js").Replace("{localhost}", Regex.Replace(host, "^https?://", ""));

            if (!string.IsNullOrEmpty(token))
                file = Regex.Replace(file, "Lampa.Storage.set\\('torrserver_login'[^\n\r]+", $"Lampa.Storage.set('torrserver_login','{HttpUtility.UrlEncode(token)}');");

            return Content(file, "application/javascript; charset=utf-8");
        }
        #endregion

        #region HttpClient
        private static readonly HttpClient httpClient = new HttpClient(new SocketsHttpHandler
        {
            AllowAutoRedirect = true,
            AutomaticDecompression = DecompressionMethods.None,
            SslOptions = { RemoteCertificateValidationCallback = (sender, cert, chain, sslPolicyErrors) => true },
            MaxConnectionsPerServer = 100
        })
        {
            BaseAddress = new Uri($"http://{AppInit.conf.listen.localhost}:{ModInit.tsport}"),
            DefaultRequestHeaders =
            {
                Authorization = new AuthenticationHeaderValue("Basic", CrypTo.Base64($"ts:{ModInit.tspass}")),
            },
            Timeout = TimeSpan.FromSeconds(30)
        };
        #endregion


        #region Main
        [Route("ts")]
        [Route("ts/static/js/{suffix}")]
        async public Task<ActionResult> Main()
        {
            string html = null;
            string pathRequest = Regex.Replace(HttpContext.Request.Path.Value, "^/ts", "");

            try
            {
                var responseMessage = await httpClient.GetAsync(pathRequest + HttpContext.Request.QueryString.Value).ConfigureAwait(false);
                html = await responseMessage.Content.ReadAsStringAsync().ConfigureAwait(false);
            }
            catch { }

            if (html == null)
                return StatusCode(500);

            if (pathRequest.Contains(".js"))
            {
                string key = Regex.Match(html, "\\.concat\\(([^,]+),\"/echo\"").Groups[1].Value;
                html = html.Replace($".concat({key},\"/", $".concat({key},\"/ts/");
                return Content(html, "application/javascript; charset=utf-8");
            }
            else
            {
                html = html.Replace("href=\"/", "href=\"/ts/").Replace("src=\"/", "src=\"/ts/");
                html = html.Replace("src=\"./", "src=\"/ts/");
                return Content(html, "text/html; charset=utf-8");
            }
        }
        #endregion

        #region TorAPI
        [Route("ts/{*suffix}")]
        async public Task Index()
        {
            if (HttpContext.Request.Path.Value.StartsWith("/shutdown"))
            {
                HttpContext.Response.StatusCode = 404;
                return;
            }

            if (AppInit.conf.accsdb.enable)
            {
                #region –û–±—Ä–∞–±–æ—Ç–∫–∞ stream –ø–æ—Ç–æ–∫–∞
                if (HttpContext.Request.Method == "GET" && Regex.IsMatch(HttpContext.Request.Path.Value, "^/ts/(stream|play)"))
                {
                    await TorAPI().ConfigureAwait(false);
                    return;

                    //if (ModInit.clientIps.Contains(HttpContext.Connection.RemoteIpAddress.ToString()))
                    //{
                    //    await TorAPI();
                    //    return;
                    //}
                    //else
                    //{
                    //    HttpContext.Response.StatusCode = 404;
                    //    return;
                    //}
                }
                #endregion

                #region Access-Control-Request-Headers
                if (HttpContext.Request.Method == "OPTIONS" && HttpContext.Request.Headers.TryGetValue("Access-Control-Request-Headers", out var AccessControl) && AccessControl == "authorization")
                {
                    HttpContext.Response.StatusCode = 204;
                    return;
                }
                #endregion

                if (HttpContext.Request.Headers.TryGetValue("Authorization", out var Authorization))
                {
                    byte[] data = Convert.FromBase64String(Authorization.ToString().Replace("Basic ", ""));
                    string[] decodedString = Encoding.UTF8.GetString(data).Split(":");

                    string login = decodedString[0].ToLower().Trim();
                    string passwd = decodedString[1];

                    if (AppInit.conf.accsdb.findUser(login) is AccsUser user && !user.ban && user.expires > DateTime.UtcNow && passwd == ModInit.conf.defaultPasswd)
                    {
                        if (ModInit.conf.group > user.group)
                        {
                            await HttpContext.Response.WriteAsync("NoAccessGroup", HttpContext.RequestAborted).ConfigureAwait(false);
                            return;
                        }

                        await TorAPI(user).ConfigureAwait(false);
                        return;
                    }
                }

                if (HttpContext.Request.Path.Value.StartsWith("/ts/echo"))
                {
                    await HttpContext.Response.WriteAsync("MatriX.API", HttpContext.RequestAborted).ConfigureAwait(false);
                    return;
                }

                HttpContext.Response.StatusCode = 401;
                HttpContext.Response.Headers["Www-Authenticate"] = "Basic realm=Authorization Required";
                return;
            }
            else
            {
                await TorAPI().ConfigureAwait(false);
                return;
            }
        }

        async public Task TorAPI(AccsUser user = null)
        {
            string pathRequest = Regex.Replace(HttpContext.Request.Path.Value, "^/ts", "");
            string servUri = $"http://{AppInit.conf.listen.localhost}:{ModInit.tsport}{pathRequest + HttpContext.Request.QueryString.Value}";

            #region settings
            if (pathRequest.StartsWith("/settings"))
            {
                if (HttpContext.Request.Method != "POST")
                {
                    HttpContext.Response.StatusCode = 404;
                    await HttpContext.Response.WriteAsync("404 page not found", HttpContext.RequestAborted).ConfigureAwait(false);
                    return;
                }

                using (var reader = new StreamReader(HttpContext.Request.Body, Encoding.UTF8, leaveOpen: true))
                {
                    string requestJson = await reader.ReadToEndAsync().ConfigureAwait(false);

                    if (requestJson.Contains("\"get\""))
                    {
                        var rs = await httpClient.PostAsync("/settings", new StringContent("{\"action\":\"get\"}", Encoding.UTF8, "application/json")).ConfigureAwait(false);
                        await rs.Content.CopyToAsync(HttpContext.Response.Body, HttpContext.RequestAborted).ConfigureAwait(false);
                        return;
                    }
                    else if (!ModInit.conf.rdb || requestInfo.IP == "127.0.0.1" || requestInfo.IP.StartsWith("192.168."))
                    {
                        await httpClient.PostAsync("/settings", new StringContent(requestJson, Encoding.UTF8, "application/json")).ConfigureAwait(false);
                    }

                    await HttpContext.Response.WriteAsync(string.Empty, HttpContext.RequestAborted).ConfigureAwait(false);
                    return;
                }
            }
            #endregion

            #region playlist
            if (pathRequest.StartsWith("/stream/") && HttpContext.Request.QueryString.Value.Contains("&m3u"))
            {
                string m3u = await httpClient.GetStringAsync(servUri).ConfigureAwait(false);
                HttpContext.Response.ContentType = "audio/x-mpegurl; charset=utf-8";
                await HttpContext.Response.WriteAsync((m3u ?? string.Empty).Replace("/stream/", "/ts/stream/"), HttpContext.RequestAborted).ConfigureAwait(false);
                return;
            }
            #endregion

            #region multiaccess
            if (ModInit.conf.multiaccess == "full" || (ModInit.conf.multiaccess == "auth" && user != null))
            {
                if (HttpContext.Request.Method == "POST" && pathRequest == "/torrents" && user?.group != 666)
                {
                    HttpContext.Request.EnableBuffering();
                    using (var readerBody = new StreamReader(HttpContext.Request.Body, Encoding.UTF8, leaveOpen: true)) // –û—Å—Ç–∞–≤–ª—è–µ–º –ø–æ—Ç–æ–∫ –æ—Ç–∫—Ä—ã—Ç—ã–º
                    {
                        string requestJson = await readerBody.ReadToEndAsync().ConfigureAwait(false);

                        if (requestJson.Contains("\"action\":\"add\"") || requestJson.Contains("\"action\":\"list\""))
                        {
                            try
                            {
                                var rs = await httpClient.PostAsync(pathRequest, new StringContent(requestJson, Encoding.UTF8, "application/json")).ConfigureAwait(false);
                                string json = await rs.Content.ReadAsStringAsync().ConfigureAwait(false);

                                string uid = user?.id ?? user?.ids?.FirstOrDefault();
                                HttpContext.Response.ContentType = "application/json; charset=utf-8";

                                if (requestJson.Contains("\"action\":\"add\""))
                                {
                                    #region add
                                    string hash = Regex.Match(json, "\"hash\":\"([^\"]+)\"").Groups[1].Value;
                                    if (!string.IsNullOrEmpty(hash))
                                    {
                                        var doc = ModInit.whosehash.FindById(hash);

                                        if (doc != null)
                                        {
                                            doc.ip = requestInfo.IP;
                                            doc.uid = uid;
                                            ModInit.whosehash.Update(doc);
                                        }
                                        else
                                        {
                                            ModInit.whosehash.Insert(new WhoseHashModel
                                            {
                                                id = hash,
                                                ip = requestInfo.IP,
                                                uid = uid
                                            });
                                        }
                                    }

                                    await HttpContext.Response.WriteAsync(json, HttpContext.RequestAborted).ConfigureAwait(false);
                                    return;
                                    #endregion
                                }
                                else
                                {
                                    #region list
                                    var torrents = JArray.Parse(json);

                                    for (int i = torrents.Count - 1; i >= 0; i--)
                                    {
                                        var hash = torrents[i]["hash"]?.ToString();

                                        if (!string.IsNullOrEmpty(hash))
                                        {
                                            var doc = ModInit.whosehash.FindById(hash);

                                            if (doc != null)
                                            {
                                                if (doc.ip == requestInfo.IP || (doc.uid != null && doc.uid == uid)) { }
                                                else
                                                    torrents.RemoveAt(i);
                                            }
                                        }
                                    }

                                    await HttpContext.Response.WriteAsync(torrents.ToString(), HttpContext.RequestAborted).ConfigureAwait(false);
                                    return;
                                    #endregion
                                }
                            }
                            catch { }

                            HttpContext.Response.StatusCode = 500;
                            await HttpContext.Response.WriteAsync(string.Empty, HttpContext.RequestAborted).ConfigureAwait(false);
                            return;
                        }
                    }

                    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é
                    HttpContext.Request.Body.Position = 0;
                }
            }
            #endregion

            var request = CreateProxyHttpRequest(HttpContext, new Uri(servUri));

            var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead).ConfigureAwait(false);
            await CopyProxyHttpResponse(HttpContext, response).ConfigureAwait(false);
        }
        #endregion


        #region CreateProxyHttpRequest
        HttpRequestMessage CreateProxyHttpRequest(HttpContext context, Uri uri)
        {
            var request = context.Request;

            var requestMessage = new HttpRequestMessage();
            var requestMethod = request.Method;
            if (HttpMethods.IsPost(requestMethod))
            {
                var streamContent = new StreamContent(request.Body);
                requestMessage.Content = streamContent;
            }

            foreach (var header in request.Headers)
            {
                if (header.Key.ToLower() is "authorization")
                    continue;

                if (!requestMessage.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray()) && requestMessage.Content != null)
                    requestMessage.Content?.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray());
            }

            requestMessage.Headers.Host = string.IsNullOrEmpty(AppInit.conf.listen.host) ? context.Request.Host.Value : AppInit.conf.listen.host;
            requestMessage.RequestUri = uri;
            requestMessage.Method = new HttpMethod(request.Method);

            return requestMessage;
        }
        #endregion

        #region CopyProxyHttpResponse
        async Task CopyProxyHttpResponse(HttpContext context, HttpResponseMessage responseMessage)
        {
            var response = context.Response;
            response.StatusCode = (int)responseMessage.StatusCode;

            #region UpdateHeaders
            void UpdateHeaders(HttpHeaders headers)
            {
                foreach (var header in headers)
                {
                    if (header.Key.ToLower() is "transfer-encoding" or "etag" or "connection" or "content-security-policy" or "content-disposition")
                        continue;

                    string value = string.Empty;
                    foreach (var val in header.Value)
                        value += $"; {val}";

                    response.Headers[header.Key] = Regex.Replace(value, "^; ", "");
                    //response.Headers[header.Key] = header.Value.ToArray();
                }
            }
            #endregion

            UpdateHeaders(responseMessage.Headers);
            UpdateHeaders(responseMessage.Content.Headers);

            var responseStream = await responseMessage.Content.ReadAsStreamAsync().ConfigureAwait(false);

            if (response.Body == null)
                throw new ArgumentNullException("destination");

            if (!responseStream.CanRead && !responseStream.CanWrite)
                throw new ObjectDisposedException("ObjectDisposed_StreamClosed");

            if (!response.Body.CanRead && !response.Body.CanWrite)
                throw new ObjectDisposedException("ObjectDisposed_StreamClosed");

            if (!responseStream.CanRead || !response.Body.CanWrite)
                throw new NotSupportedException("NotSupported_UnreadableStream");

            byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);

            try
            {
                int bytesRead;

                while ((bytesRead = await responseStream.ReadAsync(buffer, context.RequestAborted).ConfigureAwait(false)) != 0)
                    await response.Body.WriteAsync(buffer, 0, bytesRead, context.RequestAborted).ConfigureAwait(false);
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
        #endregion
    }
}

```

## File: TorrServer/ModInit.cs
```
Ôªøusing LiteDB;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Shared.Engine;
using Shared.Models.Module;
using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace TorrServer
{
    public class ModInit
    {
        #region static
        static bool IsShutdown;

        public static int tsport = 9080;

        public static string tspass = CrypTo.md5(DateTime.Now.ToBinary().ToString());

        public static string homedir;

        public static string tspath;

        public static Process tsprocess;
        #endregion

        #region dataDb
        static LiteDatabase dataDb;

        public static ILiteCollection<WhoseHashModel> whosehash { get; set; }
        #endregion

        #region ModInit
        public string releases { get; set; } = "MatriX.135";

        public bool rdb { get; set; }

        public string defaultPasswd { get; set; } = "ts";

        public int group { get; set; }

        /// <summary>
        /// auth
        /// full
        /// null - desable
        /// </summary>
        public string multiaccess { get; set; } = "auth";

        public bool checkfile { get; set; } = true;


        static (ModInit, DateTime) cacheconf = default;

        public static ModInit conf => cacheconf.Item1;
        #endregion

        #region cron_UpdateSettings
        static Timer _cronTimer;

        static bool _cronWork = false;

        static void cron_UpdateSettings(object state)
        {
            if (_cronWork)
                return;

            _cronWork = true;

            try
            {
                string path = "module/TorrServer.conf";

                if (!File.Exists(path))
                {
                    if (cacheconf.Item1 == null)
                        cacheconf.Item1 = new ModInit();

                    return;
                }

                var lastWriteTime = File.GetLastWriteTime(path);

                if (cacheconf.Item2 != lastWriteTime)
                {
                    cacheconf.Item1 = JsonConvert.DeserializeObject<ModInit>(File.ReadAllText(path));
                    cacheconf.Item2 = lastWriteTime;
                }
            }
            catch { }
            finally
            {
                _cronWork = false;
            }
        }
        #endregion

        #region loaded
        public static void loaded(InitspaceModel initspace)
        {
            RegisterShutdown(initspace);

            _cronTimer = new Timer(cron_UpdateSettings, null, TimeSpan.Zero, TimeSpan.FromSeconds(1));

            dataDb = new LiteDatabase("cache/ts.db");
            whosehash = dataDb.GetCollection<WhoseHashModel>("whosehash");

            #region homedir
            homedir = Directory.GetCurrentDirectory();
            if (string.IsNullOrWhiteSpace(homedir) || homedir == "/")
                homedir = string.Empty;

            homedir = Path.Combine(homedir, "torrserver");
            Directory.CreateDirectory(homedir);
            #endregion

            #region tspath
            tspath = Path.Combine(homedir, "TorrServer-linux");

            if (Environment.OSVersion.Platform == PlatformID.Win32NT)
                tspath = Path.Combine(homedir, "TorrServer-windows-amd64.exe");
            #endregion

            File.WriteAllText(Path.Combine(homedir, "accs.db"), $"{{\"ts\":\"{tspass}\"}}");

            ThreadPool.QueueUserWorkItem(async _ =>
            {
                #region downloadUrl
                string downloadUrl;
                if (Environment.OSVersion.Platform == PlatformID.Win32NT)
                {
                    downloadUrl = "https://github.com/YouROK/TorrServer/releases/latest/download/TorrServer-windows-amd64.exe";
                    if (conf.releases != "latest")
                        downloadUrl = $"https://github.com/YouROK/TorrServer/releases/download/{conf.releases}/TorrServer-windows-amd64.exe";
                }
                else
                {
                    string uname = (await Bash.Run("uname -m")) ?? string.Empty;
                    string arch = uname.Contains("x86_64") ? "amd64" : (uname.Contains("i386") || uname.Contains("i686")) ? "386" : uname.Contains("aarch64") ? "arm64" : uname.Contains("armv7") ? "arm7" : uname.Contains("armv6") ? "arm5" : "amd64";

                    downloadUrl = "https://github.com/YouROK/TorrServer/releases/latest/download/TorrServer-linux-" + arch;
                    if (conf.releases != "latest")
                        downloadUrl = $"https://github.com/YouROK/TorrServer/releases/download/{conf.releases}/TorrServer-linux-" + arch;
                }
                #endregion

                #region updatet/install
                async Task install()
                {
                    try
                    {
                        if (conf.releases == "latest")
                        {
                            var root = await Http.Get<JObject>("https://api.github.com/repos/YouROK/TorrServer/releases/latest");
                            if (root != null && root.ContainsKey("tag_name"))
                            {
                                string tagname = root.Value<string>("tag_name");
                                if (!string.IsNullOrEmpty(tagname))
                                {
                                    if (!File.Exists($"{homedir}/tagname") || tagname != File.ReadAllText($"{homedir}/tagname"))
                                    {
                                        if (File.Exists(tspath))
                                            File.Delete(tspath);

                                        File.WriteAllText($"{homedir}/tagname", tagname);
                                    }
                                }
                            }
                        }

                        if (!File.Exists(tspath))
                        {
                            if (Environment.OSVersion.Platform == PlatformID.Win32NT)
                            {
                                tsprocess?.Dispose();
                                bool success = await Http.DownloadFile(downloadUrl, tspath, timeoutSeconds: 200);
                                if (!success)
                                    File.Delete(tspath);
                            }
                            else
                            {
                                tsprocess?.Dispose();
                                bool success = await Http.DownloadFile(downloadUrl, tspath, timeoutSeconds: 200);
                                if (success)
                                    Bash.Invoke($"chmod +x {tspath}");
                                else
                                    Bash.Invoke($"rm -f {tspath}");
                            }
                        }
                    }
                    catch { }
                }

                await install();

                if (!File.Exists(tspath))
                {
                    await Task.Delay(10_000);
                    await install();
                }

                if (!File.Exists("isdocker") && conf.checkfile)
                {
                    var response = await Http.ResponseHeaders(downloadUrl, timeoutSeconds: 10, allowAutoRedirect: true);
                    if (response != null && response.Content.Headers.ContentLength.HasValue && new FileInfo(tspath).Length != response.Content.Headers.ContentLength.Value)
                    {
                        File.Delete(tspath);
                        await Task.Delay(10_000);
                        await install();
                    }
                }
                #endregion

                while (!IsShutdown && File.Exists(tspath))
                {
                    try
                    {
                        tsprocess = new Process();
                        tsprocess.StartInfo.UseShellExecute = false;
                        tsprocess.StartInfo.RedirectStandardOutput = true;
                        tsprocess.StartInfo.RedirectStandardError = true;
                        tsprocess.StartInfo.FileName = tspath;
                        tsprocess.StartInfo.Arguments = $"--httpauth -p {tsport} -d \"{homedir}\"";

                        tsprocess.Start();

                        tsprocess.OutputDataReceived += (sender, args) => { };
                        tsprocess.ErrorDataReceived += (sender, args) => { };
                        tsprocess.BeginOutputReadLine();
                        tsprocess.BeginErrorReadLine();

                        await tsprocess.WaitForExitAsync();
                    }
                    catch { }

                    await Task.Delay(10_000);
                }
            });
        }
        #endregion


        #region Shutdown
        static void RegisterShutdown(InitspaceModel initspace)
        {
            if (initspace?.app?.ApplicationServices != null)
            {
                var lifetime = initspace.app.ApplicationServices.GetService<IHostApplicationLifetime>();
                lifetime?.ApplicationStopping.Register(StopTranscoding);
            }

            AppDomain.CurrentDomain.ProcessExit += (_, _) => StopTranscoding();
        }

        static void StopTranscoding()
        {
            try
            {
                IsShutdown = true;
                tsprocess?.Kill(true);
                _cronTimer.Dispose();
            }
            catch { }
        }
        #endregion
    }
}

```

## File: TorrServer/WhoseHashModel.cs
```
Ôªøusing LiteDB;

namespace TorrServer
{
    public class WhoseHashModel
    {
        [BsonId]
        public string id { get; set; }

        public string ip { get; set; }

        public string uid { get; set; }

        public string hash { get; set; }
    }
}

```

## File: Merchant/Litecoin.cs
```
Ôªøusing System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Microsoft.Extensions.Caching.Memory;
using System;
using System.Text.RegularExpressions;
using Shared;
using System.Threading;
using IO = System.IO.File;
using System.IO;
using Shared.Engine;
using Shared.Models.Merchant.LtcWallet;
using Shared.Models;

namespace Merchant.Controllers
{
    public class Litecoin : MerchantController
    {
        #region Litecoin
        static Litecoin()
        {
            Directory.CreateDirectory("merchant/invoice/litecoin");
            ThreadPool.QueueUserWorkItem(async _ => await ChekTransactions());
        }
        #endregion

        #region LtcKurs
        async static ValueTask<double> LtcKurs()
        {
            if (!Startup.memoryCache.TryGetValue("Litecoin:kurs:ltc", out double kurs))
            {
                var exmo = await Http.Get<JObject>("https://api.exmo.com/v1.1/ticker");
                var LTC_USD = exmo.GetValue("LTC_USD");

                double avg = LTC_USD.Value<double>("avg");
                double buy_price = LTC_USD.Value<double>("buy_price");

                kurs = avg > buy_price ? buy_price : avg;
                Startup.memoryCache.Set("Litecoin:kurs:ltc", kurs, DateTime.Now.AddMinutes(15));
            }

            return kurs;
        }
        #endregion

        [HttpGet]
        [Route("litecoin/getnewaddress")]
        async public Task<ActionResult> Index(string email)
        {
            if (!AppInit.conf.Merchant.LtcWallet.enable || string.IsNullOrWhiteSpace(email))
                return Content(string.Empty);

            email = decodeEmail(email);
            string pathEmail = $"merchant/invoice/litecoin/{CrypTo.md5(email)}.email";
            double buyprice = await LtcKurs();

            if (IO.Exists(pathEmail))
            {
                return Json(new
                {
                    payinaddress = IO.ReadAllText(pathEmail),
                    buyprice,
                    amount = AppInit.conf.Merchant.accessCost / buyprice
                });
            }
            else
            {
                string json = await Http.Post(AppInit.conf.Merchant.LtcWallet.rpc, "{\"method\": \"getnewaddress\"}", headers: HeadersModel.Init("Authorization", $"Basic {CrypTo.Base64($"{AppInit.conf.Merchant.LtcWallet.rpcuser}:{AppInit.conf.Merchant.LtcWallet.rpcpassword}")}"));

                string payinAddress = Regex.Match(json ?? string.Empty, "\"result\":\"([^\"]+)\"").Groups[1].Value.Trim();

                if (string.IsNullOrWhiteSpace(payinAddress) || !Regex.IsMatch(payinAddress, "^[0-9a-zA-Z]+$") || 20 > payinAddress.Length)
                {
                    return Json(new { });
                }
                else
                {
                    IO.WriteAllText(pathEmail, payinAddress);
                    IO.WriteAllText($"merchant/invoice/litecoin/{payinAddress}.ltc", email);
                }

                return Json(new
                {
                    payinaddress = payinAddress,
                    buyprice,
                    amount = AppInit.conf.Merchant.accessCost / buyprice
                });
            }
        }


        #region ChekTransactions
        async static Task ChekTransactions()
        {
            while (true)
            {
                await Task.Delay(TimeSpan.FromMinutes(1));
                if (!AppInit.conf.Merchant.LtcWallet.enable)
                    continue;

                try
                {
                    double kurs = await LtcKurs();
                    if (kurs == -1)
                        continue;

                    var root = await Http.Post<RootTransactions>(AppInit.conf.Merchant.LtcWallet.rpc, "{\"method\": \"listtransactions\", \"params\": [\"*\", 20]}", headers: HeadersModel.Init("Authorization", $"Basic {CrypTo.Base64($"{AppInit.conf.Merchant.LtcWallet.rpcuser}:{AppInit.conf.Merchant.LtcWallet.rpcpassword}")}"));

                    var transactions = root?.result;
                    if (transactions == null || transactions.Count == 0)
                        continue;

                    foreach (var trans in transactions)
                    {
                        if (trans.category != "receive" || string.IsNullOrWhiteSpace(trans.txid))
                            continue;

                        try
                        {
                            if (IO.Exists($"merchant/invoice/litecoin/{trans.txid}.txid"))
                                continue;

                            string email = IO.ReadAllText($"merchant/invoice/litecoin/{trans.address}.ltc");
                            IO.WriteAllText($"merchant/invoice/litecoin/{trans.txid}.txid", $"{email}\n{trans.address}");

                            double cost = (double)AppInit.conf.Merchant.accessCost / (double)(AppInit.conf.Merchant.accessForMonths * 30);
                            PayConfirm(email, "litecoin", $"{trans.address} - {trans.txid}", days: (int)((trans.amount * kurs) / cost));
                        }
                        catch { }
                    }
                }
                catch { }
            }
        }
        #endregion
    }
}

```

## File: Merchant/CryptoCloud.cs
```
Ôªøusing System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;
using IO = System.IO.File;
using System.IO;
using Microsoft.Extensions.Caching.Memory;
using System;
using Shared;
using Shared.Engine;
using Shared.Models;

namespace Merchant.Controllers
{
    /// <summary>
    /// https://app.cryptocloud.plus/integration/api
    /// </summary>
    public class CryptoCloud : MerchantController
    {
        static CryptoCloud() { Directory.CreateDirectory("merchant/invoice/cryptocloud"); }


        [HttpGet]
        [Route("cryptocloud/invoice/create")]
        async public Task<ActionResult> Index(string email)
        {
            if (!AppInit.conf.Merchant.CryptoCloud.enable || string.IsNullOrWhiteSpace(email))
                return Content(string.Empty);

            email = decodeEmail(email);

            Dictionary<string, string> postParams = new Dictionary<string, string>()
            {
                ["amount"] = AppInit.conf.Merchant.accessCost.ToString(),
                ["shop_id"] = AppInit.conf.Merchant.CryptoCloud.SHOPID,
                //["currency"] = "USD",
                //["order_id"] = CrypTo.md5(DateTime.Now.ToBinary().ToString()),
                ["email"] = email
            };

            if (memoryCache.TryGetValue($"cryptocloud:{email}", out string pay_url))
                return Redirect(pay_url);

            var root = await Http.Post<JObject>("https://api.cryptocloud.plus/v1/invoice/create", new System.Net.Http.FormUrlEncodedContent(postParams), headers: HeadersModel.Init("Authorization", $"Token {AppInit.conf.Merchant.CryptoCloud.APIKEY}"));
            if (root == null || !root.ContainsKey("pay_url"))
                return Content("root == null");

            pay_url = root.Value<string>("pay_url");
            if (string.IsNullOrWhiteSpace(pay_url))
                return Content("pay_url == null");

            memoryCache.Set($"cryptocloud:{email}", pay_url, DateTime.Now.AddHours(2));

            IO.WriteAllText($"merchant/invoice/cryptocloud/{root.Value<string>("invoice_id")}", JsonConvert.SerializeObject(postParams));

            return Redirect(pay_url);
        }


        [HttpPost]
        [Route("cryptocloud/callback")]
        async public Task<ActionResult> Callback(string invoice_id)
        {
            if (!AppInit.conf.Merchant.CryptoCloud.enable || !IO.Exists($"merchant/invoice/cryptocloud/{invoice_id}"))
                return StatusCode(403);

            WriteLog("cryptocloud", JsonConvert.SerializeObject(HttpContext.Request.Form));

            var root = await Http.Get<JObject>("https://api.cryptocloud.plus/v1/invoice/info?uuid=INV-" + invoice_id, headers: HeadersModel.Init("Authorization", $"Token {AppInit.conf.Merchant.CryptoCloud.APIKEY}"));
            if (root == null || root.Value<string>("status") != "success")
                return StatusCode(403);

            if (root.Value<string>("status_invoice") is "paid" or "overpaid")
            {
                var invoice = JsonConvert.DeserializeObject<Dictionary<string, string>>(IO.ReadAllText($"merchant/invoice/cryptocloud/{invoice_id}"));
                PayConfirm(invoice["email"], "cryptocloud", invoice_id);

                return StatusCode(200);
            }

            return StatusCode(403);
        }
    }
}

```

## File: Merchant/MerchantController.cs
```
Ôªøusing Shared;
using Shared.Models.Base;
using System;
using System.Web;

namespace Merchant
{
    public class MerchantController : BaseController
    {
        static DateTime LastWriteTimeUsers = default;

        static string _users = null;

        public static void PayConfirm(string email, string merch, string order, int days = 0)
        {
            var lastWriteTimeUsers = System.IO.File.GetLastWriteTime("merchant/users.txt");

            if (_users == null || LastWriteTimeUsers != lastWriteTimeUsers)
            {
                LastWriteTimeUsers = lastWriteTimeUsers;
                _users = System.IO.File.ReadAllText("merchant/users.txt");
            }

            string users = _users;

            if (!users.Contains($",{merch},{order}"))
            {
                DateTime ex = default;

                if (days > 0)
                {
                    if (AppInit.conf.accsdb.findUser(email) is AccsUser user)
                    {
                        ex = user.expires;
                        ex = ex > DateTime.UtcNow ? ex.AddDays(days) : DateTime.UtcNow.AddDays(days);
                        user.expires = ex;
                        user.group = AppInit.conf.Merchant.defaultGroup;
                    }
                    else
                    {
                        ex = DateTime.UtcNow.AddDays(days);
                        AppInit.conf.accsdb.users.Add(new AccsUser() 
                        {
                            id = email.ToLower().Trim(),
                            expires = ex,
                            group = AppInit.conf.Merchant.defaultGroup
                        });
                    }
                }
                else
                {
                    if (AppInit.conf.accsdb.findUser(email) is AccsUser user)
                    {
                        ex = user.expires;
                        ex = ex > DateTime.UtcNow ? ex.AddMonths(AppInit.conf.Merchant.accessForMonths) : DateTime.UtcNow.AddMonths(AppInit.conf.Merchant.accessForMonths);
                        user.expires = ex;
                        user.group = AppInit.conf.Merchant.defaultGroup;
                    }
                    else
                    {
                        ex = DateTime.UtcNow.AddMonths(AppInit.conf.Merchant.accessForMonths);
                        AppInit.conf.accsdb.users.Add(new AccsUser()
                        {
                            id = email.ToLower().Trim(),
                            expires = ex,
                            group = AppInit.conf.Merchant.defaultGroup
                        });
                    }
                }

                System.IO.File.AppendAllText("merchant/users.txt", $"{email.ToLower().Trim()},{ex.ToFileTimeUtc()},{merch},{order}\n");

                _users += $"{email.ToLower().Trim()},{ex.ToFileTimeUtc()},{merch},{order}\n";
                LastWriteTimeUsers = System.IO.File.GetLastWriteTime("merchant/users.txt");
            }
        }


        public static void WriteLog(string merch, string content)
        {
            try
            {
                System.IO.File.AppendAllText($"merchant/log/{merch}.txt", content + "\n\n\n");
            }
            catch { }
        }


        public static string decodeEmail(string email)
        {
            if (string.IsNullOrEmpty(email))
                return null;    

            return HttpUtility.UrlDecode(email.ToLower().Trim());
        }
    }
}

```

## File: Merchant/MerchApi.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using Shared;

namespace Merchant.Controllers
{
    public class MerchApi : MerchantController
    {
        [HttpGet]
        [Route("merchant/user")]
        public ActionResult Index(string account_email)
        {
            string email = decodeEmail(account_email);
            if (email == null)
                return Json(new { error = true, msg = "email null" });

            var user = AppInit.conf.accsdb.findUser(email);
            if (user == null)
                return Json(new { error = true, msg = "user not found" });

            return Json(new
            {
                user.id,
                user.ids,
                user.ban,
                user.ban_msg,
                user.expires,
                user.group
            });
        }


        [Route("merchant/payconfirm")]
        public ActionResult ConfirmPay(string passwd, string account_email, string merch, string order, int days = 0)
        {
            if (passwd != AppInit.rootPasswd)
                return Content("incorrect passwd");

            string email = decodeEmail(account_email);
            if (email == null)
                return Json(new { error = true, msg = "email null" });

            PayConfirm(email, merch, order, days);

            var user = AppInit.conf.accsdb.findUser(email);
            if (user == null)
                return Json(new { error = true, msg = "user not found" });

            return Json(user);
        }
    }
}

```

## File: Merchant/Streampay.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using System;
using IO = System.IO.File;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Chaos.NaCl;
using System.Text.RegularExpressions;
using System.Linq;
using Microsoft.Extensions.Caching.Memory;
using Shared;

namespace Merchant.Controllers
{
    public class Streampay : MerchantController
    {
        static Streampay() { Directory.CreateDirectory("merchant/invoice/streampay"); }


        [HttpGet]
        [Route("streampay/new")]
        async public Task<ActionResult> Index(string email)
        {
            var init = AppInit.conf.Merchant.Streampay;
            if (!init.enable || string.IsNullOrWhiteSpace(email))
                return Content(string.Empty);

            email = decodeEmail(email);
            string transid = DateTime.Now.ToBinary().ToString().Replace("-", "");

            if (memoryCache.TryGetValue($"streampay:{transid}", out string pay_link))
                return Redirect(pay_link);

            IO.WriteAllText($"merchant/invoice/streampay/{transid}", email);

            var body = new
            {
                init.store_id,
                customer = email,
                external_id = transid,
                description = $"–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ {AppInit.conf.Merchant.accessForMonths} {EndOfText("–º–µ—Å—è—Ü", "–º–µ—Å—è—Ü–∞", "–º–µ—Å—è—Ü–µ–≤", AppInit.conf.Merchant.accessForMonths)}",
                system_currency = "USDT",
                payment_type = 2,
                amount = AppInit.conf.Merchant.accessCost
            };

            var jsonBody = JsonSerializer.Serialize(body);
            string signature = Sign(Encoding.UTF8.GetBytes(jsonBody + DateTime.UtcNow.ToString("yyyyMMdd:HHmm")), init.private_key);

            using (var httpClient = new HttpClient())
            {
                var request = new HttpRequestMessage(HttpMethod.Post, "https://api.streampay.org/api/payment/create")
                {
                    Content = new StringContent(jsonBody, Encoding.UTF8, "application/json")
                };

                request.Headers.Add("signature", signature);

                var response = await httpClient.SendAsync(request);
                if (response.IsSuccessStatusCode)
                {
                    string respData = await response.Content.ReadAsStringAsync();
                    string pay_url = Regex.Match(respData, "\"pay_url\":\"([^\"]+)\"").Groups[1].Value;

                    if (!string.IsNullOrEmpty(pay_url))
                    {
                        memoryCache.Set($"streampay:{transid}", pay_url, DateTime.Now.AddHours(2));
                        return Redirect(pay_url);
                    }

                    return Content(respData);
                }
                else if (response.StatusCode == System.Net.HttpStatusCode.Forbidden)
                {
                    return Content("Invalid signature");
                }
                else if (response.StatusCode == System.Net.HttpStatusCode.NotAcceptable)
                {
                    return Content("Invalid request data");
                }
                else if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
                {
                    return Content("Internal server error");
                }
            }

            return Content("error");
        }


        [HttpGet]
        [Route("streampay/callback")]
        public ActionResult Callback()
        {
            string transid = Request.Query["external_id"].ToString();

            if (Request.Query["status"] != "awaiting_payment")
                memoryCache.Remove($"streampay:{transid}");

            var merchant = AppInit.conf.Merchant;
            if (!merchant.Streampay.enable || !IO.Exists($"merchant/invoice/streampay/{transid}") || Request.Query["status"] != "success")
                return Ok();

            var now = DateTime.UtcNow;
            var queryParams = Request.Query.OrderBy(x => x.Key).Select(x => $"{x.Key}={x.Value}").ToList();
            string paramsStr = string.Join('&', queryParams);
            byte[] paramsBuf = Encoding.UTF8.GetBytes(paramsStr);

            string log = $"{paramsStr}\n{JsonSerializer.Serialize(Request.Headers)}";

            for (int i = 0; i < 2; i++)
            {
                string tm = now.ToString("yyyyMMdd:HHmm");
                var bufToSign = paramsBuf.Concat(Encoding.UTF8.GetBytes(tm)).ToArray();

                bool verify = Verify(Request.Headers["Signature"], bufToSign, merchant.Streampay.public_key);
                log += $"\nverify: {verify} | {tm} | signature: {Request.Headers["Signature"]}";

                if (verify)
                {
                    PayConfirm(IO.ReadAllText($"merchant/invoice/streampay/{transid}"), "streampay", transid);

                    WriteLog("streampay", log + "\nOK");
                    return Ok();
                }

                now = now.AddMinutes(-1);
            }

            WriteLog("streampay", log + "\nForbid");
            return Forbid();
        }



        static string Sign(byte[] message, string privateKey)
        {
            var bytes = Ed25519.Sign(message, HexToBytes(privateKey));

            StringBuilder hex = new StringBuilder(bytes.Length * 2);

            foreach (byte b in bytes)
                hex.AppendFormat("{0:x2}", b);

            return hex.ToString();
        }

        static bool Verify(string signature, byte[] message, string publicKey)
        {
            try
            {
                return Ed25519.Verify(HexToBytes(signature), message, HexToBytes(publicKey));
            }
            catch { return false; }
        }

        static byte[] HexToBytes(string key)
        {
            if (key.Length % 2 != 0)
                return null;

            int byteCount = key.Length / 2;
            byte[] hexKey = new byte[byteCount];

            for (int i = 0; i < byteCount; i++)
            {
                string byteString = key.Substring(i * 2, 2);
                byte keyValue = Convert.ToByte(byteString, 16);
                hexKey[i] = keyValue;
            }

            return hexKey;
        }

        static string EndOfText(string s1, string s2, string s3, int x)
        {
            int n = x % 100;
            if ((n > 10) && (n < 20))
                return s3;

            switch (x % 10)
            {
                case 4: return s2;
                case 0:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9: return s3;
                default: return s1;
            }
        }
    }
}

```

## File: Merchant/FreeKassa.cs
```
Ôªøusing Microsoft.AspNetCore.Mvc;
using System;
using Newtonsoft.Json;
using IO = System.IO.File;
using System.IO;
using Shared.Engine;
using Shared;

namespace Merchant.Controllers
{
    /// <summary>
    /// https://docs.freekassa.ru/
    /// </summary>
    public class FreeKassa : MerchantController
    {
        static FreeKassa() { Directory.CreateDirectory("merchant/invoice/freekassa"); }


        [HttpGet]
        [Route("freekassa/new")]
        public ActionResult Index(string email)
        {
            if (!AppInit.conf.Merchant.FreeKassa.enable || string.IsNullOrWhiteSpace(email))
                return Content(string.Empty);

            string transid = DateTime.Now.ToBinary().ToString().Replace("-", "");

            IO.WriteAllText($"merchant/invoice/freekassa/{transid}", decodeEmail(email));

            string hash = CrypTo.md5($"{AppInit.conf.Merchant.FreeKassa.shop_id}:{AppInit.conf.Merchant.accessCost}:{AppInit.conf.Merchant.FreeKassa.secret}:USD:{transid}");
            return Redirect("https://pay.freekassa.ru/" + $"?m={AppInit.conf.Merchant.FreeKassa.shop_id}&oa={AppInit.conf.Merchant.accessCost}&o={transid}&s={hash}&currency=USD");
        }


        [HttpPost]
        [Route("freekassa/callback")]
        public ActionResult Callback(string AMOUNT, long MERCHANT_ORDER_ID, string SIGN)
        {
            if (!AppInit.conf.Merchant.FreeKassa.enable || !IO.Exists($"merchant/invoice/freekassa/{MERCHANT_ORDER_ID}"))
                return StatusCode(403);

            WriteLog("freekassa", JsonConvert.SerializeObject(HttpContext.Request.Form));

            if (CrypTo.md5($"{AppInit.conf.Merchant.FreeKassa.shop_id}:{AMOUNT}:{AppInit.conf.Merchant.FreeKassa.secret}:{MERCHANT_ORDER_ID}") == SIGN)
            {
                string email = IO.ReadAllText($"merchant/invoice/freekassa/{MERCHANT_ORDER_ID}");
                PayConfirm(email, "freekassa", MERCHANT_ORDER_ID.ToString());

                return Content("YES");
            }

            return Content("SIGN != hash");
        }
    }
}

```

## File: Merchant/B2PAY.cs
```
Ôªøusing System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Microsoft.AspNetCore.Http;
using System.Text;
using IO = System.IO.File;
using System.IO;
using Shared;
using Shared.Engine;

namespace Merchant.Controllers
{
    /// <summary>
    /// https://pay.b2pay.io/merchant/api.php
    /// </summary>
    public class B2PAY : MerchantController
    {
        static B2PAY() { Directory.CreateDirectory("merchant/invoice/b2pay"); }


        [HttpGet]
        [Route("b2pay/new")]
        async public Task<ActionResult> Index(string email)
        {
            if (!AppInit.conf.Merchant.B2PAY.enable || string.IsNullOrWhiteSpace(email))
                return Content(string.Empty);

            Dictionary<string, dynamic> payment = new Dictionary<string, dynamic>() 
            {
                ["amount"] = AppInit.conf.Merchant.accessCost,
                ["currency"] = "USD",
                ["description"] = "Buy Premium",
                ["order_number"] = CrypTo.md5(DateTime.Now.ToBinary().ToString()),
                ["type_payment"] = "merchant",
                ["usr"] = "new",
                ["custom_field"] = decodeEmail(email),
                ["callback_url"] = CrypTo.Base64($"{AppInit.Host(HttpContext)}/b2pay/callback"),
                ["success_url"] = CrypTo.Base64($"{AppInit.Host(HttpContext)}/buy/success.html"),
                ["error_url"] = CrypTo.Base64($"{AppInit.Host(HttpContext)}/buy/error.html")
            };

            payment.Add("signature", CrypTo.Base64(CrypTo.md5binary($"{AppInit.conf.Merchant.accessCost}:{payment["callback_url"]}:{payment["currency"]}:{payment["custom_field"]}:{payment["description"]}:{payment["error_url"]}:{payment["order_number"]}:{payment["success_url"]}:merchant:new:{AppInit.conf.Merchant.B2PAY.encryption_password}")));

            string data = $"payment={CrypTo.Base64(CrypTo.AES256(JsonConvert.SerializeObject(payment), AppInit.conf.Merchant.B2PAY.encryption_password, AppInit.conf.Merchant.B2PAY.encryption_iv))}&id={AppInit.conf.Merchant.B2PAY.username_id}";

            var root = await Http.Post<JObject>(AppInit.conf.Merchant.B2PAY.sandbox ? "https://pay.b2pay.io/api_sandbox/merchantpayments.php" : "https://pay.b2pay.io/api/merchantpayments.php", data);
            if (root == null || !root.ContainsKey("data"))
                return Content("data == null");

            string invoiceurl = root.Value<JObject>("data")?.Value<string>("url");
            if (string.IsNullOrWhiteSpace(invoiceurl))
                return Content("invoiceurl == null");

            IO.WriteAllText($"merchant/invoice/b2pay/{payment["order_number"]}", JsonConvert.SerializeObject(payment));

            return Redirect(invoiceurl);
        }


        [HttpPost]
        [Route("b2pay/callback")]
        async public Task<ActionResult> Callback()
        {
            if (!AppInit.conf.Merchant.B2PAY.enable || HttpContext.Request.Method != HttpMethods.Post || HttpContext.Request.ContentLength == 0)
                return StatusCode(404);

            var buffer = new byte[Convert.ToInt32(HttpContext.Request.ContentLength)];
            await HttpContext.Request.Body.ReadAsync(buffer, 0, buffer.Length);

            var requestContent = Encoding.UTF8.GetString(buffer);
            WriteLog("b2pay", requestContent);

            JObject result = JsonConvert.DeserializeObject<JObject>(requestContent);
            string signature = CrypTo.Base64(CrypTo.md5binary($"{result.Value<string>("amount")}:{result.Value<string>("currency")}:{result.Value<string>("gatewayAmount")}:{result.Value<string>("gatewayCurrency")}:{result.Value<string>("gatewayRate")}:{result.Value<string>("orderNumber")}:{result.Value<string>("pay_id")}:{result.Value<string>("sanitizedMask")}:{result.Value<string>("status")}:{result.Value<string>("token")}:pay:{AppInit.conf.Merchant.B2PAY.encryption_password}"));

            if (result.Value<string>("sign") != signature)
                return StatusCode(401);

            string orderNumber = result.Value<string>("orderNumber");
            if (result.Value<string>("status") != "approved" || string.IsNullOrWhiteSpace(orderNumber) || !IO.Exists($"merchant/invoice/b2pay/{orderNumber}"))
                return StatusCode(403);

            var invoice = JsonConvert.DeserializeObject<Dictionary<string, string>>(IO.ReadAllText($"merchant/invoice/b2pay/{orderNumber}"));
            PayConfirm(invoice["custom_field"], "b2pay", orderNumber);

            return Content("ok");
        }
    }
}

```


```

---

## docs/TMDB_CENSORSHIP_ANALYSIS.md

```markdown
# üõ° –ê–Ω–∞–ª–∏–∑ –º–µ—Ç–æ–¥–æ–≤ –æ–±—Ö–æ–¥–∞ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫ TMDB: Reverse Engineering –æ—Ç—á–µ—Ç

–≠—Ç–æ—Ç –¥–æ–∫—É–º–µ–Ω—Ç –æ–±–æ–±—â–∞–µ—Ç —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –º–µ—Ç–æ–¥—ã, –∫–æ—Ç–æ—Ä—ã–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ Android-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (Lampa, Vokino, NUM) –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–æ—Å—Ç—É–ø–∞ –∫ TMDB –≤ —É—Å–ª–æ–≤–∏—è—Ö —Å–µ—Ç–µ–≤–æ–π —Ü–µ–Ω–∑—É—Ä—ã (–†–ö–ù, DPI, SNI/IP Blocking).

## 1. –ö–æ–Ω—Ç–µ–∫—Å—Ç: –ü–æ—á–µ–º—É –±–ª–æ–∫–∏—Ä—É—é—Ç?
*   **–¶–µ–ª—å:** –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞—Ç–∞–ª–æ–≥–∞–º "–ø–∏—Ä–∞—Ç—Å–∫–æ–≥–æ" –∫–æ–Ω—Ç–µ–Ω—Ç–∞.
*   **–ú–µ—Ç–æ–¥:** –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –¥–æ–º–µ–Ω–æ–≤ `api.themoviedb.org` –∏ `image.tmdb.org` –ø–æ SNI (Server Name Indication) –∏ IP-–∞–¥—Ä–µ—Å–∞–º CDN (Cloudflare/Fastly).
*   **–ü—Ä–æ–±–ª–µ–º–∞:** –ü—Ä—è–º–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ª–æ–º–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –¥–æ–º–∞—à–Ω–∏—Ö –º–µ–¥–∏–∞-—Ü–µ–Ω—Ç—Ä–æ–≤.

---

## 2. –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è (–ø–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è–º)

### 2.1. Lampa ("–¢–æ–Ω–∫–∏–π –ö–ª–∏–µ–Ω—Ç" / JS-Injection)
*   **–§–∏–ª–æ—Å–æ—Ñ–∏—è:** –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ ‚Äî —ç—Ç–æ –±—Ä–∞—É–∑–µ—Ä (WebView), –ª–æ–≥–∏–∫–∞ ‚Äî —ç—Ç–æ JS, –∑–∞–≥—Ä—É–∂–∞–µ–º—ã–π –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏.
*   **CUB Mirror Network:**
    *   –ò—Å–ø–æ–ª—å–∑—É–µ—Ç —Å–µ—Ç—å Nginx-–ø—Ä–æ–∫—Å–∏ (`cub.red`, `cub.watch`), —Ä–∞–∑–º–µ—â–µ–Ω–Ω—ã—Ö –≤ "—Å–≤–æ–±–æ–¥–Ω—ã—Ö" —é—Ä–∏—Å–¥–∏–∫—Ü–∏—è—Ö (–ù–∏–¥–µ—Ä–ª–∞–Ω–¥—ã).
    *   **Anti-DPI:** –ò—Å–ø–æ–ª—å–∑—É–µ—Ç SSL Termination —Å –≤–∞–ª–∏–¥–Ω—ã–º–∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞–º–∏ Let's Encrypt –¥–ª—è –¥–æ–º–µ–Ω–æ–≤, –Ω–µ –Ω–∞—Ö–æ–¥—è—â–∏—Ö—Å—è –≤ —á–µ—Ä–Ω–æ–º —Å–ø–∏—Å–∫–µ.
    *   **Rate Limiting Bypass:** –°–µ—Ä–≤–µ—Ä CUB —Ä–æ—Ç–∏—Ä—É–µ—Ç –ø—É–ª API-–∫–ª—é—á–µ–π TMDB, —á—Ç–æ–±—ã –Ω–µ —É–ø–µ—Ä–µ—Ç—å—Å—è –≤ –ª–∏–º–∏—Ç—ã –æ–¥–Ω–æ–≥–æ –∫–ª—é—á–∞.
*   **Image Optimization (wsrv.nl):**
    *   –≠–∫—Å–ø–ª—É–∞—Ç–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–∞ "–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –Ω–∞ –ª–µ—Ç—É".
    *   –ö–ª–∏–µ–Ω—Ç -> `wsrv.nl` (–ª–µ–≥–∏—Ç–∏–º–Ω—ã–π CDN) -> `tmdb.org` (–±—ç–∫–µ–Ω–¥).
    *   –¢—Ä–∞—Ñ–∏–∫ –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ –∑–∞–≥—Ä—É–∑–∫–∞ –ª–µ–≥–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç–∏–Ω–∫–∏ —Å CDN.
*   **Plugins:** JS-–ø–ª–∞–≥–∏–Ω—ã –ø–æ–∑–≤–æ–ª—è—é—Ç —Å–æ–æ–±—â–µ—Å—Ç–≤—É –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –º–µ–Ω—è—Ç—å –∞–¥—Ä–µ—Å–∞ –∑–µ—Ä–∫–∞–ª –±–µ–∑ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è APK.

### 2.2. Vokino (–ù–∞—Ç–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ / BFF)
*   **–°—Ç–µ–∫:** Kotlin + OkHttp.
*   **BFF (Backend for Frontend):** –ö–ª–∏–µ–Ω—Ç —Ö–æ–¥–∏—Ç –Ω–µ –≤ TMDB, –∞ –Ω–∞ —Å–≤–æ–π –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π —Å–µ—Ä–≤–µ—Ä `api.vokino.tv`. –°–µ—Ä–≤–µ—Ä –∫–µ—à–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç—ã TMDB –∏ –æ–±–æ–≥–∞—â–∞–µ—Ç –∏—Ö (–ö–∏–Ω–æ–ø–æ–∏—Å–∫, IMDb).
*   **DDoS Protection & DNS:**
    *   **DoH (DNS over HTTPS):** –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Cloudflare DNS (`1.1.1.1`) –≤–Ω—É—Ç—Ä–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è. –≠—Ç–æ —Å–∫—Ä—ã–≤–∞–µ—Ç DNS-–∑–∞–ø—Ä–æ—Å—ã –æ—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞.
    *   **Remote Config:** –ê–¥—Ä–µ—Å–∞ API –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –ø—Ä–∏–ª–µ—Ç–∞—é—Ç –∏–∑ Firebase. –ï—Å–ª–∏ –æ–¥–∏–Ω –¥–æ–º–µ–Ω –±–∞–Ω—è—Ç, —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ –º–µ–Ω—è—é—Ç –∫–æ–Ω—Ñ–∏–≥, –∏ –∫–ª–∏–µ–Ω—Ç—ã "–ø–µ—Ä–µ–µ–∑–∂–∞—é—Ç" –Ω–∞ –∑–µ—Ä–∫–∞–ª–æ.
*   **–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ —Ç—Ä–∞—Ñ–∏–∫–∞:** "Control Plane" (–º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ) –∏–¥–µ—Ç —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏, "Data Plane" (—Ç–æ—Ä—Ä–µ–Ω—Ç—ã) ‚Äî –Ω–∞–ø—Ä—è–º—É—é P2P.

### 2.3. NUM (Tor & Scraping)
*   **Onion Routing:** –í—à–∏—Ç–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ `libtor.so` –ø–æ–∑–≤–æ–ª—è–µ—Ç –∑–∞–≤–µ—Ä–Ω—É—Ç—å API-–∑–∞–ø—Ä–æ—Å—ã –≤ —Å–µ—Ç—å Tor –≤ —Å–ª—É—á–∞–µ —Ç–æ—Ç–∞–ª—å–Ω–æ–≥–æ —à–∞—Ç–¥–∞—É–Ω–∞.
*   **Web Scraping Fallback:** –ï—Å–ª–∏ API –º–µ—Ä—Ç–≤–æ, –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –ø–∞—Ä—Å–∏—Ç HTML-—Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å–∞–π—Ç–æ–≤-–∞–≥—Ä–µ–≥–∞—Ç–æ—Ä–æ–≤ (Rezka, Kinopoisk), –∏—Å–ø–æ–ª—å–∑—É—è CSS-—Å–µ–ª–µ–∫—Ç–æ—Ä—ã. –≠—Ç–æ –≤—ã–≥–ª—è–¥–∏—Ç –¥–ª—è DPI –∫–∞–∫ –æ–±—ã—á–Ω—ã–π –≤–µ–±-—Å–µ—Ä—Ñ–∏–Ω–≥.

---

## 3. –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –º–µ—Ç–æ–¥—ã –æ–±—Ö–æ–¥–∞ DPI (Deep Packet Inspection)

### 3.1. ClientHello Fragmentation
*   **–°—É—Ç—å:** –†–∞–∑–±–∏–µ–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ TCP-–ø–∞–∫–µ—Ç–∞ (TLS ClientHello) –Ω–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã.
*   **–≠—Ñ—Ñ–µ–∫—Ç:** –î–æ–º–µ–Ω–Ω–æ–µ –∏–º—è (SNI) –æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è "—Ä–∞–∑—Ä–µ–∑–∞–Ω–æ" –º–µ–∂–¥—É –ø–∞–∫–µ—Ç–∞–º–∏. DPI, –Ω–µ —É–º–µ—é—â–∏–π —Å–æ–±–∏—Ä–∞—Ç—å —Å–µ—Å—Å–∏–∏ (Stateful Reassembly) –Ω–∞ –ª–µ—Ç—É, –Ω–µ –≤–∏–¥–∏—Ç –∑–∞–ø—Ä–µ—â–µ–Ω–Ω–æ–≥–æ –¥–æ–º–µ–Ω–∞ –∏ –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç –ø–∞–∫–µ—Ç—ã. –°–µ—Ä–≤–µ—Ä –∂–µ —Å–æ–±–∏—Ä–∞–µ—Ç –∏—Ö –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ.

### 3.2. ECH (Encrypted Client Hello)
*   **–°—É—Ç—å:** –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ SNI –∫–ª—é—á–æ–º, –ø–æ–ª—É—á–µ–Ω–Ω—ã–º —á–µ—Ä–µ–∑ DNS.
*   **–°—Ç–∞—Ç—É—Å:** "–°–µ—Ä–µ–±—Ä—è–Ω–∞—è –ø—É–ª—è". –ï—Å–ª–∏ TMDB –≤–Ω–µ–¥—Ä–∏—Ç ECH + Cloudflare, —Ç–æ—á–µ—á–Ω–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —Å—Ç–∞–Ω–µ—Ç –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ–π –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –≤—Å–µ–≥–æ Cloudflare –ø–æ IP.

### 3.3. QUIC (HTTP/3)
*   **–°—É—Ç—å:** –†–∞–±–æ—Ç–∞ –ø–æ–≤–µ—Ä—Ö UDP.
*   **–≠—Ñ—Ñ–µ–∫—Ç:** –ú–Ω–æ–≥–∏–µ —Å–∏—Å—Ç–µ–º—ã DPI –ø–ª–æ—Ö–æ –∞–Ω–∞–ª–∏–∑–∏—Ä—É—é—Ç UDP –∏–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã —Ç–æ–ª—å–∫–æ –Ω–∞ TCP-—Å–±—Ä–æ—Å—ã.

---

## 4. –í—ã–≤–æ–¥—ã –¥–ª—è PWA-TorServe

1.  **–ù–∞—à–µ —Ç–µ–∫—É—â–µ–µ —Ä–µ—à–µ–Ω–∏–µ (Offline Mode + Gradients)** ‚Äî —ç—Ç–æ –ø—Ä–∏–∑–Ω–∞–Ω–∏–µ "–ø–æ—Ä–∞–∂–µ–Ω–∏—è" –≤ –ø—Ä—è–º–æ–π –±–∏—Ç–≤–µ, –Ω–æ –ø–æ–±–µ–¥–∞ –≤ UX. –ú—ã —É—à–ª–∏ —Å –ø–æ–ª—è –±–æ—è.
2.  **–ü—É—Ç—å —Ä–∞–∑–≤–∏—Ç–∏—è:** –ß—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å –ø–æ—Å—Ç–µ—Ä—ã, –Ω–∞–º –Ω–µ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–æ—Å—Ç–æ `fetch`. –ù–∞–º –Ω—É–∂–Ω–æ:
    *   –õ–∏–±–æ **BFF** (—Å–≤–æ–π —Å–µ—Ä–≤–µ—Ä –≤ –ï–≤—Ä–æ–ø–µ + –ø—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ).
    *   –õ–∏–±–æ **Client-Side Proxy** (wsrv.nl), –Ω–æ –Ω—É–∂–Ω–æ –±—ã—Ç—å –≥–æ—Ç–æ–≤—ã–º –∫ –∫–∞–ø—á–∞–º.
    *   –õ–∏–±–æ **VPN –Ω–∞ —É—Ä–æ–≤–Ω–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞** (—Å–∞–º—ã–π –Ω–∞–¥–µ–∂–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –¥–ª—è –¥–æ–º–∞).

*–ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º. –ê–Ω–∞–ª–∏–∑ –≤—ã–ø–æ–ª–Ω–µ–Ω Antigravity.*

```

---

## docs/claude.md

```markdown
# Code Review: PWA-TorServe
**–î–∞—Ç–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:** 2026-01-16

## –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–æ–µ–∫—Ç–µ
- **–ù–∞–∑–≤–∞–Ω–∏–µ**: PWA-TorServe
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –î–æ–º–∞—à–Ω–∏–π –º–µ–¥–∏–∞-—Å–µ—Ä–≤–µ—Ä –¥–ª—è —Å—Ç—Ä–∏–º–∏–Ω–≥–∞ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤
- **–°—Ç–µ–∫**: Node.js, Express, React 19, torrent-stream, lowdb
- **–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è**: 512MB RAM (—Å–ª–∞–±–æ–µ –∂–µ–ª–µ–∑–æ)
- **–í–µ—Ä—Å–∏—è**: v2.8.0 (Multi-source Architecture)

---

## –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞

```
PWA-TorServe/
‚îú‚îÄ‚îÄ server/                    # Backend (Node.js + Express)
‚îÇ   ‚îú‚îÄ‚îÄ index.js              # –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ —Å–µ—Ä–≤–µ—Ä–∞ (23KB)
‚îÇ   ‚îú‚îÄ‚îÄ torrent.js            # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞–º–∏ (31KB) ‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ù–´–ô
‚îÇ   ‚îú‚îÄ‚îÄ watchdog.js           # Watchdog/–º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ (12KB)
‚îÇ   ‚îú‚îÄ‚îÄ aggregator.js         # –ê–≥—Ä–µ–≥–∞—Ç–æ—Ä –ø–æ–∏—Å–∫–∞ (Multi-source) üÜï
‚îÇ   ‚îú‚îÄ‚îÄ searchCache.js        # –ö–µ—à –ø–æ–∏—Å–∫–∞ (5 min TTL) üÜï
‚îÇ   ‚îú‚îÄ‚îÄ providers/            # –ü—Ä–æ–≤–∞–π–¥–µ—Ä—ã –ø–æ–∏—Å–∫–∞ üÜï
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BaseProvider.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProviderManager.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ JacredProvider.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RuTrackerProvider.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RutorProvider.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TorLookProvider.js
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ logger.js         # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ doh.js            # DNS over HTTPS
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ retry.js          # Retry logic (Exp backoff) üÜï
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ lag-monitor.js    # –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ª–∞–≥–æ–≤
‚îÇ   ‚îú‚îÄ‚îÄ db.js                 # –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö lowdb
‚îÇ   ‚îú‚îÄ‚îÄ autodownloader.js     # –ê–≤—Ç–æ–∑–∞–≥—Ä—É–∑—á–∏–∫ v2.7.0 üÜï
‚îÇ   ‚îî‚îÄ‚îÄ jacred.js             # Legacy wrapper
‚îú‚îÄ‚îÄ client/                    # Frontend (React 19 + Vite)
‚îú‚îÄ‚îÄ roadmap.md                # –°—Ç–∞—Ç—É—Å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–∞–ø–æ–≤
‚îú‚îÄ‚îÄ project-code.md           # –í–µ—Å—å –∫–æ–¥ –¥–ª—è AI
‚îî‚îÄ‚îÄ docker-compose.yml
```

---

## –õ–æ–≥ –∏–∑–º–µ–Ω–µ–Ω–∏–π

### [2026-01-16] - Roadmap & Provider Architecture (v2.8.0)
- **Multi-source**: –ü–µ—Ä–µ—Ö–æ–¥ –æ—Ç –∂–µ—Å—Ç–∫–æ–≥–æ Jacred –∫ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞–º.
- **Aggregator**: –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ —á–µ—Ä–µ–∑ `Promise.allSettled`.
- **Hardening**: Circuit Breaker –∏ 5-–º–∏–Ω –∫–µ—à –ø–æ–∏—Å–∫–∞.
- **RuTracker**: –û–±—Ö–æ–¥ DNS-–±–ª–æ–∫–∏—Ä–æ–≤–æ–∫ —á–µ—Ä–µ–∑ DoH + persisted sessions.
- **AutoDownloader**: –ü–æ–ª–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –∞–≥—Ä–µ–≥–∞—Ç–æ—Ä–æ–º.
- **CI/CD**: –ö–æ–¥ –∑–∞–ø—É—à–µ–Ω –Ω–∞ GitHub, README –æ–±–Ω–æ–≤–ª–µ–Ω.

### [2026-01-16] - Optimization Audit
- –í—ã—è–≤–ª–µ–Ω–æ 5 –∫–ª—é—á–µ–≤—ã—Ö –∑–æ–Ω –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ (—Å–º. `code_review.md`).
- –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω 5s —Å—Ç–∞—Ç—É—Å-–∫–µ—à –¥–ª—è —Å–Ω–∏–∂–µ–Ω–∏—è –Ω–∞–≥—Ä—É–∑–∫–∏ –Ω–∞ ARM CPU.
- –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã persisted cookies –¥–ª—è RuTracker.

### [2026-01-14] - –ù–∞—á–∞–ª–æ –∞–Ω–∞–ª–∏–∑–∞ (v2.3.2)
- –°–æ–∑–¥–∞–Ω —Ñ–∞–π–ª claude.md
- –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ 7 –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–±–ª–µ–º (Memory Leaks, Race Conditions, Stream leaks).
- –î–æ–±–∞–≤–ª–µ–Ω–∞ —Å–∞–Ω–∏—Ç–∏–∑–∞—Ü–∏—è M3U –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ.
- –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞ –≤ Logger.

### [2026-01-14 19:05] - Priority 1: –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏
- –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã —Ñ–∞–π–ª—ã: torrent.js, watchdog.js, db.js, dbQueue.js, index.js
- –ù–∞–π–¥–µ–Ω–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–±–ª–µ–º: **4**

### [2026-01-14 19:10] - Priority 2: –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å
- –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã —Ñ–∞–π–ª—ã: jacred.js, doh.js, rutracker.js, index.js
- –ù–∞–π–¥–µ–Ω–æ –ø—Ä–æ–±–ª–µ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏: **3** (1 –∑–∞–¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω –∫–∞–∫ –æ—Å–æ–∑–Ω–∞–Ω–Ω—ã–π –∫–æ–º–ø—Ä–æ–º–∏—Å—Å)

### [2026-01-14 19:15] - Priority 3: –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
- –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã –≤—Å–µ —Ñ–∞–π–ª—ã
- –ù–∞–π–¥–µ–Ω–æ –ø—Ä–æ–±–ª–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏: **3**

---

## –ù–∞–π–¥–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã

### üõë –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï (Priority 1)

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #1: Memory Leak - –¢–∞–π–º–∞—É—Ç –Ω–µ –æ—á–∏—â–∞–µ—Ç—Å—è –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏

- **–§–∞–π–ª**: `server/torrent.js:268-274`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Memory Leak / Logic Error
- **–û–ø–∏—Å–∞–Ω–∏–µ**: setTimeout –¥–ª—è 90-—Å–µ–∫—É–Ω–¥–Ω–æ–≥–æ —Ç–∞–π–º–∞—É—Ç–∞ —Å–æ–∑–¥–∞—ë—Ç—Å—è, –Ω–æ –ù–ï –æ—á–∏—â–∞–µ—Ç—Å—è –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞. –≠—Ç–æ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ —Ç–æ–º—É, —á—Ç–æ —á–µ—Ä–µ–∑ 90 —Å–µ–∫—É–Ω–¥ –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–æ—Ä—Ä–µ–Ω—Ç–∞ —Ç–∞–π–º–∞—É—Ç –≤—Å—ë —Ä–∞–≤–Ω–æ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –ø–æ–ø—ã—Ç–∞–µ—Ç—Å—è —É–Ω–∏—á—Ç–æ–∂–∏—Ç—å —É–∂–µ —Ä–∞–±–æ—Ç–∞—é—â–∏–π engine.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**:
  - –ß–µ—Ä–µ–∑ 90 —Å–µ–∫—É–Ω–¥ –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–æ—Ä—Ä–µ–Ω—Ç –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω–æ —É–Ω–∏—á—Ç–æ–∂–µ–Ω
  - –£—Ç–µ—á–∫–∞ –ø–∞–º—è—Ç–∏ –æ—Ç –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è —Ç–∞–π–º–∞—É—Ç–æ–≤
  - –ù–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ –≤–∏–¥–µ–æ
- **–†–∏—Å–∫**: üî¥ –í—ã—Å–æ–∫–∏–π

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// torrent.js:267-274
// üî• STRATEGY 3: Increased Timeout (90s)
setTimeout(() => {
    if (!engines.has(magnetURI)) {
        console.warn('[Torrent] Timeout: no peers found')
        engine.destroy()
        reject(new Error('Torrent timeout: no peers found within 90 seconds'))
    }
}, 90000)
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
// –°–æ–∑–¥–∞—ë–º —Ç–∞–π–º–∞—É—Ç –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –µ–≥–æ ID –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–π –æ—á–∏—Å—Ç–∫–∏
const timeoutId = setTimeout(() => {
    if (!engines.has(magnetURI)) {
        console.warn('[Torrent] Timeout: no peers found')
        engine.destroy()
        reject(new Error('Torrent timeout: no peers found within 90 seconds'))
    }
}, 90000)

engine.on('ready', () => {
    // ‚úÖ –û—á–∏—â–∞–µ–º —Ç–∞–π–º–∞—É—Ç –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
    clearTimeout(timeoutId)

    console.log('[Torrent] Engine ready:', engine.infoHash)
    // ... –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥
})

engine.on('error', (err) => {
    // ‚úÖ –û—á–∏—â–∞–µ–º —Ç–∞–π–º–∞—É—Ç –ø—Ä–∏ –æ—à–∏–±–∫–µ
    clearTimeout(timeoutId)

    console.error('[Torrent] Engine error:', err.message)
    engine.destroy()
    reject(err)
})
```

**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**:
1. –î–æ–±–∞–≤–∏—Ç—å —Ç–æ—Ä—Ä–µ–Ω—Ç —Å —Ö–æ—Ä–æ—à–∏–º–∏ —Å–∏–¥–∞–º–∏ (–±—ã—Å—Ç—Ä–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ)
2. –ü–æ–¥–æ–∂–¥–∞—Ç—å 90+ —Å–µ–∫—É–Ω–¥
3. –£–±–µ–¥–∏—Ç—å—Å—è —á—Ç–æ —Ç–æ—Ä—Ä–µ–Ω—Ç –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å (—Ä–∞–Ω—å—à–µ –º–æ–≥ –±—ã—Ç—å —É–Ω–∏—á—Ç–æ–∂–µ–Ω)

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #2: Memory Leak - setInterval –Ω–µ –æ—á–∏—â–∞–µ—Ç—Å—è –ø—Ä–∏ shutdown

- **–§–∞–π–ª**: `server/torrent.js:31-52`, `server/index.js:43-50`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Memory Leak
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –ì–ª–æ–±–∞–ª—å–Ω—ã–µ setInterval –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ frozen torrents –∏ rateLimitMap –Ω–µ –∏–º–µ—é—Ç –º–µ—Ö–∞–Ω–∏–∑–º–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏. –ü—Ä–∏ graceful shutdown –æ–Ω–∏ –ø—Ä–æ–¥–æ–ª–∂–∞—é—Ç —Ä–∞–±–æ—Ç–∞—Ç—å.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**:
  - –£—Ç–µ—á–∫–∞ –ø–∞–º—è—Ç–∏ –ø—Ä–∏ –≥–æ—Ä—è—á–µ–π –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–µ –≤ dev —Ä–µ–∂–∏–º–µ
  - –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã –ø—Ä–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
- **–†–∏—Å–∫**: üü° –°—Ä–µ–¥–Ω–∏–π (–≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ —Å–µ—Ä–≤–µ—Ä –æ–±—ã—á–Ω–æ –Ω–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è —á–∞—Å—Ç–æ)

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// torrent.js:31 - –Ω–µ—Ç —Å–ø–æ—Å–æ–±–∞ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —ç—Ç–æ—Ç –∏–Ω—Ç–µ—Ä–≤–∞–ª
setInterval(() => {
    // cleanup frozen torrents
}, 2 * 60 * 1000)

// index.js:43 - –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ
setInterval(() => {
    // cleanup rate limit map
}, 5 * 60 * 1000)
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
// torrent.js - —Å–æ—Ö—Ä–∞–Ω—è–µ–º ID –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞
let frozenCleanupInterval = null

export function startFrozenCleanup() {
    if (frozenCleanupInterval) return

    frozenCleanupInterval = setInterval(() => {
        // ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–¥ –æ—á–∏—Å—Ç–∫–∏
    }, 2 * 60 * 1000)
}

export function stopFrozenCleanup() {
    if (frozenCleanupInterval) {
        clearInterval(frozenCleanupInterval)
        frozenCleanupInterval = null
    }
}

// –í destroyAllTorrents –¥–æ–±–∞–≤–∏—Ç—å:
export const destroyAllTorrents = () => {
    stopFrozenCleanup()  // ‚úÖ –î–æ–±–∞–≤–∏—Ç—å
    // ... –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥
}
```

**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**:
1. –ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–µ—Ä–≤–µ—Ä
2. –í—ã–ø–æ–ª–Ω–∏—Ç—å graceful shutdown (Ctrl+C)
3. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –≤—Å–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã –æ—á–∏—â–µ–Ω—ã (–≤ –ª–æ–≥–∞—Ö –Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø–æ—Å–ª–µ shutdown)

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #3: Race Condition - –£–¥–∞–ª–µ–Ω–∏–µ –∏–∑ Map –≤–æ –≤—Ä–µ–º—è –∏—Ç–µ—Ä–∞—Ü–∏–∏

- **–§–∞–π–ª**: `server/torrent.js:296-298`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Race Condition
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –í —Ñ—É–Ω–∫—Ü–∏–∏ removeTorrent –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –∏—Ç–µ—Ä–∞—Ü–∏—è –ø–æ Map —Å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–º —É–¥–∞–ª–µ–Ω–∏–µ–º —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –≠—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –ø—Ä–æ–ø—É—Å–∫—É —ç–ª–µ–º–µ–Ω—Ç–æ–≤.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**:
  - –ù–µ –≤—Å–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ engine –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã –∏–∑ Map
  - –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —É—Ç–µ—á–∫–∞ –ø–∞–º—è—Ç–∏
- **–†–∏—Å–∫**: üü° –°—Ä–µ–¥–Ω–∏–π

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// torrent.js:296-298
for (const [key, val] of engines.entries()) {
    if (val === engine) engines.delete(key)  // ‚ùå –£–¥–∞–ª–µ–Ω–∏–µ –≤–æ –≤—Ä–µ–º—è –∏—Ç–µ—Ä–∞—Ü–∏–∏
}
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
// –°–æ–±–∏—Ä–∞–µ–º –∫–ª—é—á–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤
const keysToDelete = []
for (const [key, val] of engines.entries()) {
    if (val === engine) keysToDelete.push(key)
}
// –£–¥–∞–ª—è–µ–º –ø–æ—Å–ª–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏
for (const key of keysToDelete) {
    engines.delete(key)
}
```

**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**:
1. –î–æ–±–∞–≤–∏—Ç—å —Ç–æ—Ä—Ä–µ–Ω—Ç (—Å–æ–∑–¥–∞—ë—Ç—Å—è 2 –∫–ª—é—á–∞: magnetURI –∏ infoHash)
2. –£–¥–∞–ª–∏—Ç—å —Ç–æ—Ä—Ä–µ–Ω—Ç
3. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ engines.size === 0 (–æ–±–∞ –∫–ª—é—á–∞ —É–¥–∞–ª–µ–Ω—ã)

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #4: –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —É—Ç–µ—á–∫–∞ —Å—Ç—Ä–∏–º–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ –¥–æ pipe

- **–§–∞–π–ª**: `server/index.js:512-526`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Resource Leak
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ stream –ø–æ—Å–ª–µ –µ–≥–æ —Å–æ–∑–¥–∞–Ω–∏—è, –Ω–æ –¥–æ pipe(), stream –º–æ–∂–µ—Ç –æ—Å—Ç–∞—Ç—å—Å—è –æ—Ç–∫—Ä—ã—Ç—ã–º. –û–±—Ä–∞–±–æ—Ç—á–∏–∫ `res.on('close')` –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç –µ—Å–ª–∏ –∫–ª–∏–µ–Ω—Ç –Ω–µ –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**:
  - –£—Ç–µ—á–∫–∞ file descriptors –ø—Ä–∏ —á–∞—Å—Ç—ã—Ö –æ—à–∏–±–∫–∞—Ö
  - –í–æ–∑–º–æ–∂–Ω–æ–µ –∏—Å—á–µ—Ä–ø–∞–Ω–∏–µ –ª–∏–º–∏—Ç–∞ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Ñ–∞–π–ª–æ–≤
- **–†–∏—Å–∫**: üü° –°—Ä–µ–¥–Ω–∏–π

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// index.js:512-526
const stream = file.createReadStream({ start, end })

stream.on('error', (err) => {
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏
    stream.destroy()
})

res.on('close', () => {
    stream.destroy()
})
stream.pipe(res)  // –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ –¥–æ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–∏, res.on('close') –º–æ–∂–µ—Ç –Ω–µ —Å—Ä–∞–±–æ—Ç–∞—Ç—å
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
const stream = file.createReadStream({ start, end })

// ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º pipeline –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –æ—á–∏—Å—Ç–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤
const { pipeline } = await import('stream/promises')

try {
    await pipeline(stream, res)
} catch (err) {
    if (!res.headersSent) {
        res.status(500).send('Stream error')
    }
    // pipeline –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–Ω–∏—á—Ç–æ–∂–∞–µ—Ç –≤—Å–µ —Å—Ç—Ä–∏–º—ã –ø—Ä–∏ –æ—à–∏–±–∫–µ
}

// –ò–ª–∏ –±–æ–ª–µ–µ –ø—Ä–æ—Å—Ç–æ–π –≤–∞—Ä–∏–∞–Ω—Ç (–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è):
const stream = file.createReadStream({ start, end })

const cleanup = () => {
    if (!stream.destroyed) stream.destroy()
}

stream.on('error', (err) => {
    console.error(`[Stream] Error:`, err.message)
    cleanup()
    if (!res.headersSent) {
        res.status(500).send('Stream error')
    }
})

res.on('close', cleanup)
res.on('error', cleanup)

stream.pipe(res)
```

**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**:
1. –ù–∞—á–∞—Ç—å —Å—Ç—Ä–∏–º–∏–Ω–≥ —Ñ–∞–π–ª–∞
2. –ü—Ä–µ—Ä–≤–∞—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ –∫–ª–∏–µ–Ω—Ç–∞
3. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤ –ª–æ–≥–∞—Ö —á—Ç–æ stream.destroy() –≤—ã–∑–≤–∞–Ω
4. –ú–æ–Ω–∏—Ç–æ—Ä–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö file descriptors (lsof | wc -l)

---

### üõ° –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨ (Priority 2)

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #5: SSL Validation –æ—Ç–∫–ª—é—á–µ–Ω–∞ (–ó–ê–î–û–ö–£–ú–ï–ù–¢–ò–†–û–í–ê–ù–û)

- **–§–∞–π–ª**: `server/jacred.js:78`, `server/utils/doh.js:13`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: SSL/TLS Security
- **–û–ø–∏—Å–∞–Ω–∏–µ**: `rejectUnauthorized: false` –æ—Ç–∫–ª—é—á–∞–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫—É SSL —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**: –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å MITM-–∞—Ç–∞–∫–∏
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ó–ê–î–û–ö–£–ú–ï–ù–¢–ò–†–û–í–ê–ù–û –∫–∞–∫ –æ—Å–æ–∑–Ω–∞–Ω–Ω—ã–π –∫–æ–º–ø—Ä–æ–º–∏—Å—Å (—Å–º. –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –≤ jacred.js:1-24)
- **–†–∏—Å–∫**: üü° –°—Ä–µ–¥–Ω–∏–π (—Å–º—è–≥—á–µ–Ω–æ: —Ç–æ–ª—å–∫–æ –ø–æ–∏—Å–∫–æ–≤—ã–µ –∑–∞–ø—Ä–æ—Å—ã, –±–µ–∑ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏, magnet-—Å—Å—ã–ª–∫–∏ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ –∑–∞—â–∏—â–µ–Ω—ã)

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è**: –û—Å—Ç–∞–≤–∏—Ç—å –∫–∞–∫ –µ—Å—Ç—å. –≠—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Å–∞–º–æ–ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–º–∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞–º–∏ Jacred-–∑–µ—Ä–∫–∞–ª.

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #6: –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π Path Traversal –≤ TMDB Image Proxy

- **–§–∞–π–ª**: `server/index.js:197-198`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Path Traversal
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –ü–∞—Ä–∞–º–µ—Ç—Ä `imagePath` –∏–∑ URL –Ω–∞–ø—Ä—è–º—É—é –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –±–µ–∑ –≤–∞–ª–∏–¥–∞—Ü–∏–∏. –•–æ—Ç—è —ç—Ç–æ –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –≤ TMDB API (–Ω–µ –≤ —Ñ–∞–π–ª–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É), –∑–ª–æ—É–º—ã—à–ª–µ–Ω–Ω–∏–∫ –º–æ–∂–µ—Ç –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –º–∞–Ω–∏–ø—É–ª–∏—Ä–æ–≤–∞—Ç—å –∑–∞–ø—Ä–æ—Å–∞–º–∏.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ (TMDB API —Å–∞–º –≤–∞–ª–∏–¥–∏—Ä—É–µ—Ç –ø—É—Ç–∏), –Ω–æ –Ω–∞—Ä—É—à–∞–µ—Ç –ø—Ä–∏–Ω—Ü–∏–ø defense in depth
- **–†–∏—Å–∫**: üü¢ –ù–∏–∑–∫–∏–π

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// index.js:197-198
app.get('/api/tmdb/image/:size/:path', async (req, res) => {
    const { size, path: imagePath } = req.params
    const url = `https://image.tmdb.org/t/p/${size}/${imagePath}`
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
app.get('/api/tmdb/image/:size/:path', async (req, res) => {
    const { size, path: imagePath } = req.params

    // ‚úÖ –í–∞–ª–∏–¥–∞—Ü–∏—è size (—Ç–æ–ª—å–∫–æ —Ä–∞–∑—Ä–µ—à—ë–Ω–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã)
    const allowedSizes = ['w92', 'w154', 'w185', 'w342', 'w500', 'w780', 'original']
    if (!allowedSizes.includes(size)) {
        return res.status(400).send('Invalid size')
    }

    // ‚úÖ –í–∞–ª–∏–¥–∞—Ü–∏—è imagePath (—Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã, —Ü–∏—Ñ—Ä—ã, —Ç–æ—á–∫–∏, –¥–µ—Ñ–∏—Å—ã)
    if (!/^[a-zA-Z0-9._-]+$/.test(imagePath)) {
        return res.status(400).send('Invalid path')
    }

    const url = `https://image.tmdb.org/t/p/${size}/${imagePath}`
```

**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**:
1. –ó–∞–ø—Ä–æ—Å–∏—Ç—å `/api/tmdb/image/w500/abc123.jpg` - –¥–æ–ª–∂–µ–Ω —Ä–∞–±–æ—Ç–∞—Ç—å
2. –ó–∞–ø—Ä–æ—Å–∏—Ç—å `/api/tmdb/image/w500/../../../etc/passwd` - –¥–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å 400

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #7: –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π XSS –≤ M3U Playlist

- **–§–∞–π–ª**: `server/index.js:378`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: XSS (Cross-Site Scripting)
- **–û–ø–∏—Å–∞–Ω–∏–µ**: `file.name` –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä–æ–≤–∞–Ω—ã –ø–ª–µ–µ—Ä–æ–º –∏–ª–∏ –±—Ä–∞—É–∑–µ—Ä–æ–º
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –¥–ª—è M3U —Ñ–æ—Ä–º–∞—Ç–∞, –Ω–æ –ª—É—á—à–µ —Å–∞–Ω–∏—Ç–∏–∑–∏—Ä–æ–≤–∞—Ç—å
- **–†–∏—Å–∫**: üü¢ –ù–∏–∑–∫–∏–π

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// index.js:378
m3u += `#EXTINF:-1,${file.name}\n`
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
// –ü—Ä–æ—Å—Ç–∞—è —Å–∞–Ω–∏—Ç–∏–∑–∞—Ü–∏—è –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
const safeName = file.name
    .replace(/[\r\n]/g, ' ')  // –£–±–∏—Ä–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥—ã —Å—Ç—Ä–æ–∫
    .replace(/,/g, ';')        // –ó–∞–º–µ–Ω—è–µ–º –∑–∞–ø—è—Ç—ã–µ (—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –≤ EXTINF)
    .substring(0, 200)         // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É

m3u += `#EXTINF:-1,${safeName}\n`
```

---

### ‚ö° –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–¨ (Priority 3)

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #8: –°–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π fs.existsSync –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ

- **–§–∞–π–ª**: `server/index.js:533`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Event Loop Blocking
- **–û–ø–∏—Å–∞–Ω–∏–µ**: `fs.existsSync()` - –±–ª–æ–∫–∏—Ä—É—é—â–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è. –•–æ—Ç—è –æ–Ω–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ, —ç—Ç–æ –Ω–∞—Ä—É—à–∞–µ—Ç –ø—Ä–∏–Ω—Ü–∏–ø –Ω–µ–±–ª–æ–∫–∏—Ä—É—é—â–µ–≥–æ I/O.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ (—Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ), –Ω–æ –ª—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å async
- **–†–∏—Å–∫**: üü¢ –ù–∏–∑–∫–∏–π

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// index.js:532-534
let indexHtmlExists = false
try {
    indexHtmlExists = fs.existsSync(path.join(distPath, 'index.html'))
} catch (e) { }
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
–û—Å—Ç–∞–≤–∏—Ç—å –∫–∞–∫ –µ—Å—Ç—å - —ç—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ —Å–µ—Ä–≤–µ—Ä–∞ –∏ –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ runtime –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å. –ü–µ—Ä—Ñ–µ–∫—Ü–∏–æ–Ω–∏–∑–º –∑–¥–µ—Å—å –Ω–µ –æ–ø—Ä–∞–≤–¥–∞–Ω.

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #9: Dynamic import –≤ hot path

- **–§–∞–π–ª**: `server/index.js:429`, `server/torrent.js:421`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Performance
- **–û–ø–∏—Å–∞–Ω–∏–µ**: `import('fs/promises')` –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∫–∞–∂–¥—ã–π —Ä–∞–∑ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∫–µ—à–∞. Dynamic import –∫–µ—à–∏—Ä—É–µ—Ç—Å—è Node.js, –Ω–æ –≤—Å—ë —Ä–∞–≤–Ω–æ —Å–æ–∑–¥–∞—ë—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π overhead.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**: –ù–µ–±–æ–ª—å—à–æ–µ –∑–∞–º–µ–¥–ª–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π
- **–†–∏—Å–∫**: üü¢ –ù–∏–∑–∫–∏–π

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// index.js:429 - –∫–∞–∂–¥—ã–π —Ä–∞–∑ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞
import('fs/promises').then(fsPromises => {
    fsPromises.rm(fullPath, { recursive: true, force: true })
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
// –í –Ω–∞—á–∞–ª–µ —Ñ–∞–π–ª–∞ (static import)
import fsPromises from 'fs/promises'

// –í –∫–æ–¥–µ:
fsPromises.rm(fullPath, { recursive: true, force: true })
```

**–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ**: Node.js –∫–µ—à–∏—Ä—É–µ—Ç dynamic imports, –ø–æ—ç—Ç–æ–º—É —ç—Ç–æ —Å–∫–æ—Ä–µ–µ –≤–æ–ø—Ä–æ—Å —á–∏—Å—Ç–æ—Ç—ã –∫–æ–¥–∞, —á–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #10: Logger –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —É—Ä–æ–≤–µ–Ω—å –Ω–µ–æ–ø—Ç–∏–º–∞–ª—å–Ω–æ

- **–§–∞–π–ª**: `server/utils/logger.js:48-51`
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Minor Performance
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –£—Å–ª–æ–≤–∏–µ `LOG_LEVELS.debug >= currentLevel` –≤—Å–µ–≥–¥–∞ false –∫–æ–≥–¥–∞ currentLevel = info (1), –ø–æ—Ç–æ–º—É —á—Ç–æ debug = 0. –õ–æ–≥–∏–∫–∞ –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞.
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**: Debug –ª–æ–≥–∏ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –≤—ã–≤–æ–¥—è—Ç—Å—è –¥–∞–∂–µ —Å LOG_LEVEL=debug
- **–†–∏—Å–∫**: üü° –°—Ä–µ–¥–Ω–∏–π (–≤–ª–∏—è–µ—Ç –Ω–∞ –æ—Ç–ª–∞–¥–∫—É)

**–¢–µ–∫—É—â–∏–π –∫–æ–¥**:
```javascript
// logger.js:47-51
debug: (message, data = {}) => {
    if (LOG_LEVELS.debug >= currentLevel) {  // ‚ùå 0 >= 1 = false
        console.log(formatMessage('debug', moduleName, message, data))
    }
},
```

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
```javascript
debug: (message, data = {}) => {
    if (currentLevel <= LOG_LEVELS.debug) {  // ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞
        console.log(formatMessage('debug', moduleName, message, data))
    }
},
```

---

### üßπ –ö–û–î-–°–¢–ê–ô–õ (Priority 4)

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #11: –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞ –ø–æ–∏—Å–∫–∞ –ø–æ hash –≤ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞—Ö

- **–§–∞–π–ª**: `server/torrent.js` (–Ω–µ—Å–∫–æ–ª—å–∫–æ –º–µ—Å—Ç)
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: DRY Violation
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –ü–æ–∏—Å–∫ —Ç–æ—Ä—Ä–µ–Ω—Ç–∞ –ø–æ hash —Å toLowerCase() –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è –≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –º–µ—Å—Ç–∞—Ö
- **–†–∏—Å–∫**: üü¢ –ù–∏–∑–∫–∏–π

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è**: –°–æ–∑–¥–∞—Ç—å –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é `findTorrentByHash(hash)`.

---

#### –ü—Ä–æ–±–ª–µ–º–∞ #12: Magic Numbers

- **–§–∞–π–ª**: –†–∞–∑–ª–∏—á–Ω—ã–µ —Ñ–∞–π–ª—ã
- **–ö–∞—Ç–µ–≥–æ—Ä–∏—è**: Code Style
- **–û–ø–∏—Å–∞–Ω–∏–µ**: –ß–∏—Å–ª–∞ –∫–∞–∫ 90000, 2 * 60 * 1000 –∏ —Ç.–¥. –ª—É—á—à–µ –≤—ã–Ω–µ—Å—Ç–∏ –≤ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
- **–†–∏—Å–∫**: üü¢ –ù–∏–∑–∫–∏–π

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è**: –£–∂–µ —á–∞—Å—Ç–∏—á–Ω–æ —Å–¥–µ–ª–∞–Ω–æ (CONFIG –≤ watchdog.js). –ú–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å –Ω–∞ –¥—Ä—É–≥–∏–µ –º–æ–¥—É–ª–∏.

---

## –°–≤–æ–¥–∫–∞

**–í—Å–µ–≥–æ –Ω–∞–π–¥–µ–Ω–æ –ø—Ä–æ–±–ª–µ–º**: 12
- üõë –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ: **4**
- üõ° –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å: **3** (1 –∑–∞–¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω –∫–∞–∫ –æ—Å–æ–∑–Ω–∞–Ω–Ω—ã–π –∫–æ–º–ø—Ä–æ–º–∏—Å—Å)
- ‚ö° –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: **3**
- üßπ –ö–æ–¥-—Å—Ç–∞–π–ª: **2**

---

## –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π

### üî¥ –ò–°–ü–†–ê–í–ò–¢–¨ –°–ï–ô–ß–ê–° (–≤–ª–∏—è–µ—Ç –Ω–∞ —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å):

1. **–ü—Ä–æ–±–ª–µ–º–∞ #1**: Memory Leak - –¢–∞–π–º–∞—É—Ç –≤ addTorrent
   - –°–∞–º–∞—è –∫—Ä–∏—Ç–∏—á–Ω–∞—è: –º–æ–∂–µ—Ç —É–Ω–∏—á—Ç–æ–∂–∏—Ç—å —Ä–∞–±–æ—Ç–∞—é—â–∏–π —Ç–æ—Ä—Ä–µ–Ω—Ç —á–µ—Ä–µ–∑ 90 —Å–µ–∫—É–Ω–¥

2. **–ü—Ä–æ–±–ª–µ–º–∞ #3**: Race Condition –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∏–∑ Map
   - –ú–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ —É—Ç–µ—á–∫–µ –ø–∞–º—è—Ç–∏

### üü° –ò–°–ü–†–ê–í–ò–¢–¨ –°–ö–û–†–û (—É–ª—É—á—à–∏—Ç –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç—å):

3. **–ü—Ä–æ–±–ª–µ–º–∞ #4**: –£—Ç–µ—á–∫–∞ —Å—Ç—Ä–∏–º–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ
4. **–ü—Ä–æ–±–ª–µ–º–∞ #10**: –õ–æ–≥–≥–µ—Ä –Ω–µ –≤—ã–≤–æ–¥–∏—Ç debug –ª–æ–≥–∏ (–≤–∞–∂–Ω–æ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏!)

### üü¢ –ò–°–ü–†–ê–í–ò–¢–¨ –ü–û –í–û–ó–ú–û–ñ–ù–û–°–¢–ò:

5. **–ü—Ä–æ–±–ª–µ–º–∞ #2**: setInterval –ø—Ä–∏ shutdown
6. **–ü—Ä–æ–±–ª–µ–º–∞ #6**: –í–∞–ª–∏–¥–∞—Ü–∏—è TMDB –ø—É—Ç–µ–π
7. **–ü—Ä–æ–±–ª–µ–º–∞ #7**: –°–∞–Ω–∏—Ç–∏–∑–∞—Ü–∏—è –∏–º—ë–Ω –≤ M3U
8. **–ü—Ä–æ–±–ª–µ–º–∞ #9**: Static import –≤–º–µ—Å—Ç–æ dynamic

---

## –û–±—â–∏–π —Ä–∏—Å–∫ –∏–∑–º–µ–Ω–µ–Ω–∏–π: üü° –°–†–ï–î–ù–ò–ô

–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ª–æ–∫–∞–ª—å–Ω—ã –∏ –Ω–µ –º–µ–Ω—è—é—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É. –ú–æ–∂–Ω–æ –ø—Ä–∏–º–µ–Ω—è—Ç—å –ø–æ –æ–¥–Ω–æ–º—É —Å —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º.

---

## –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è

**–ù–∞—á–∞—Ç—å —Å –ü—Ä–æ–±–ª–µ–º—ã #1** - –æ–Ω–∞ –Ω–∞–∏–±–æ–ª–µ–µ –∫—Ä–∏—Ç–∏—á–Ω–∞ –∏ –º–æ–∂–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å —Å–ø–æ–Ω—Ç–∞–Ω–Ω—ã–µ –æ–±—Ä—ã–≤—ã –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è.

–ó–∞—Ç–µ–º –∏—Å–ø—Ä–∞–≤–∏—Ç—å **–ü—Ä–æ–±–ª–µ–º—É #10** (–ª–æ–≥–≥–µ—Ä) —á—Ç–æ–±—ã debug –ª–æ–≥–∏ —Ä–∞–±–æ—Ç–∞–ª–∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º.

---

## ‚úÖ –ü–†–ò–ú–ï–ù–Å–ù–ù–´–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø (2026-01-14)

–í—Å–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω—ã. –ù–∏–∂–µ —Å–ø–∏—Å–æ–∫ –∏–∑–º–µ–Ω–µ–Ω–∏–π:

### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ü—Ä–æ–±–ª–µ–º–∞ #1 - Memory Leak –≤ addTorrent
- **–§–∞–π–ª**: `server/torrent.js`
- **–ò–∑–º–µ–Ω–µ–Ω–∏–µ**: –î–æ–±–∞–≤–ª–µ–Ω–æ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ `timeoutId` –∏ `clearTimeout()` –≤ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞—Ö `engine.on('ready')` –∏ `engine.on('error')`
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û

### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ü—Ä–æ–±–ª–µ–º–∞ #2 - setInterval –ø—Ä–∏ shutdown
- **–§–∞–π–ª—ã**: `server/torrent.js`, `server/index.js`
- **–ò–∑–º–µ–Ω–µ–Ω–∏–µ**:
  - torrent.js: –î–æ–±–∞–≤–ª–µ–Ω—ã —Ñ—É–Ω–∫—Ü–∏–∏ `startFrozenCleanup()` –∏ `stopFrozenCleanup()` —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º ID –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞. –í—ã–∑–æ–≤ `stopFrozenCleanup()` –≤ `destroyAllTorrents()`
  - index.js: –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ `rateLimitCleanupId` –∏ –µ–≥–æ –æ—á–∏—Å—Ç–∫–∞ –≤ `gracefulShutdown()`
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û

### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ü—Ä–æ–±–ª–µ–º–∞ #3 - Race Condition –≤ removeTorrent
- **–§–∞–π–ª**: `server/torrent.js`
- **–ò–∑–º–µ–Ω–µ–Ω–∏–µ**: –°–±–æ—Ä –∫–ª—é—á–µ–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤ `keysToDelete` –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û

### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ü—Ä–æ–±–ª–µ–º–∞ #4 - –£—Ç–µ—á–∫–∞ —Å—Ç—Ä–∏–º–∞
- **–§–∞–π–ª**: `server/index.js`
- **–ò–∑–º–µ–Ω–µ–Ω–∏–µ**: –î–æ–±–∞–≤–ª–µ–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è `cleanup()` —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π `stream.destroyed`, –ø–æ–¥–∫–ª—é—á–µ–Ω–∞ –∫ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞–º `res.on('close')` –∏ `res.on('error')`
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û

### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ü—Ä–æ–±–ª–µ–º–∞ #7 - –°–∞–Ω–∏—Ç–∏–∑–∞—Ü–∏—è M3U
- **–§–∞–π–ª**: `server/index.js`
- **–ò–∑–º–µ–Ω–µ–Ω–∏–µ**: –î–æ–±–∞–≤–ª–µ–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è `sanitizeM3U()` –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –∏–º—ë–Ω —Ñ–∞–π–ª–æ–≤ –æ—Ç –ø–µ—Ä–µ–≤–æ–¥–æ–≤ —Å—Ç—Ä–æ–∫ –∏ —É–ø—Ä–∞–≤–ª—è—é—â–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û

### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ü—Ä–æ–±–ª–µ–º–∞ #9 - Static import –≤–º–µ—Å—Ç–æ dynamic
- **–§–∞–π–ª—ã**: `server/torrent.js`, `server/index.js`
- **–ò–∑–º–µ–Ω–µ–Ω–∏–µ**: –ó–∞–º–µ–Ω—ë–Ω `await import('fs/promises')` –Ω–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π `import fsPromises from 'fs/promises'` –≤ –Ω–∞—á–∞–ª–µ —Ñ–∞–π–ª–æ–≤
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û

### –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –ü—Ä–æ–±–ª–µ–º–∞ #10 - –õ–æ–≥–≥–µ—Ä –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞
- **–§–∞–π–ª**: `server/utils/logger.js`
- **–ò–∑–º–µ–Ω–µ–Ω–∏–µ**: –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ª–æ–≤–∏–µ —Å `LOG_LEVELS.debug >= currentLevel` –Ω–∞ `currentLevel <= LOG_LEVELS.debug` –¥–ª—è –≤—Å–µ—Ö —É—Ä–æ–≤–Ω–µ–π –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
- **–°—Ç–∞—Ç—É—Å**: ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û

---

## –ù–ï –ò–°–ü–†–ê–í–õ–ï–ù–û (–æ—Å–æ–∑–Ω–∞–Ω–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è)

### –ü—Ä–æ–±–ª–µ–º–∞ #5 - SSL Validation
- **–ü—Ä–∏—á–∏–Ω–∞**: –î–æ–º–∞—à–Ω–∏–π –ø—Ä–æ–µ–∫—Ç, –∑–µ—Ä–∫–∞–ª–∞ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ
- **–°—Ç–∞—Ç—É—Å**: ‚è≠Ô∏è –ü–†–û–ü–£–©–ï–ù–û (–ø–æ –∑–∞–ø—Ä–æ—Å—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)

### –ü—Ä–æ–±–ª–µ–º–∞ #6 - Path Traversal –≤ TMDB
- **–ü—Ä–∏—á–∏–Ω–∞**: –ù–∏–∑–∫–∏–π —Ä–∏—Å–∫, –¥–æ–º–∞—à–Ω—è—è —Å–µ—Ç—å
- **–°—Ç–∞—Ç—É—Å**: ‚è≠Ô∏è –ü–†–û–ü–£–©–ï–ù–û

### –ü—Ä–æ–±–ª–µ–º–∞ #8 - –°–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π fs.existsSync
- **–ü—Ä–∏—á–∏–Ω–∞**: –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ, –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –≤–ª–∏—è–Ω–∏–µ
- **–°—Ç–∞—Ç—É—Å**: ‚è≠Ô∏è –ü–†–û–ü–£–©–ï–ù–û

### –ü—Ä–æ–±–ª–µ–º—ã #11, #12 - –ö–æ–¥-—Å—Ç–∞–π–ª
- **–ü—Ä–∏—á–∏–Ω–∞**: –ù–µ –≤–ª–∏—è—é—Ç –Ω–∞ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
- **–°—Ç–∞—Ç—É—Å**: ‚è≠Ô∏è –ü–†–û–ü–£–©–ï–ù–û

---

## –ò—Ç–æ–≥–æ–≤—ã–π —Å—Ç–∞—Ç—É—Å

| –ö–∞—Ç–µ–≥–æ—Ä–∏—è | –ù–∞–π–¥–µ–Ω–æ | –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ | –ü—Ä–æ–ø—É—â–µ–Ω–æ |
|-----------|---------|------------|-----------|
| üõë –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ | 4 | 4 | 0 |
| üõ° –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å | 3 | 1 | 2 |
| ‚ö° –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å | 3 | 2 | 1 |
| üßπ –ö–æ–¥-—Å—Ç–∞–π–ª | 2 | 0 | 2 |
| **–í—Å–µ–≥–æ** | **12** | **7** | **5** |

**–í–µ—Ä—Å–∏—è –ø–æ—Å–ª–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π**: v2.3.3 (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)

```

---

## package.json

```json
{
  "name": "pwa-torserve",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node server/index.js",
    "dev": "node server/index.js",
    "client:install": "cd client && npm install",
    "client:build": "cd client && npm run build"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "lowdb": "^7.0.1",
    "torrent-stream": "^1.2.0"
  }
}
```

---

## roadmap.md

```markdown
# üó∫Ô∏è PWA-TorServe ‚Äî ROADMAP

> –≠—Ç–æ—Ç —Ñ–∞–π–ª ‚Äî –Ω–µ –ø—Ä–æ—Å—Ç–æ —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á,  
> –∞ **–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–∞—è –ø–∞–º—è—Ç—å –ø—Ä–æ–µ–∫—Ç–∞**.
>
> –û–Ω —Ñ–∏–∫—Å–∏—Ä—É–µ—Ç:
> - –∑–∞—á–µ–º –±—ã–ª–∏ –ø—Ä–∏–Ω—è—Ç—ã –∫–ª—é—á–µ–≤—ã–µ —Ä–µ—à–µ–Ω–∏—è
> - —á—Ç–æ —É–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ –∏ —Å—Ç–∞–±–∏–ª—å–Ω–æ
> - –∫–∞–∫–∏–µ —à–∞–≥–∏ –ª–æ–≥–∏—á–Ω–æ –¥–µ–ª–∞—Ç—å –¥–∞–ª—å—à–µ
>
> Roadmap –º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä—è—Ç—å,  
> –Ω–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ—Å–æ–∑–Ω–∞–Ω–Ω—ã–º–∏.

---

## üéØ North Star (–¶–µ–ª—å –ø—Ä–æ–µ–∫—Ç–∞)

**PWA-TorServe** ‚Äî self-hosted middleware –¥–ª—è:
- –∞–≥—Ä–µ–≥–∞—Ü–∏–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç-–∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
- –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞ —Ä–µ–ª–∏–∑–æ–≤
- —Å—Ç—Ä–∏–º–∏–Ω–≥–∞ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤ –≤ PWA / Android TV –∫–ª–∏–µ–Ω—Ç

–ü—Ä–æ–µ–∫—Ç:
- ‚ùå –Ω–µ —Ö–æ—Å—Ç–∏—Ç –∫–æ–Ω—Ç–µ–Ω—Ç
- ‚ùå –Ω–µ –∑–∞–º–µ–Ω—è–µ—Ç Jackett / Prowlarr
- ‚úÖ –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω –Ω–∞ —É—Å—Ç–æ–π—á–∏–≤—É—é —Ä–∞–±–æ—Ç—É –≤ —É—Å–ª–æ–≤–∏—è—Ö –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫ (–†–§)
- ‚úÖ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω –Ω–∞ –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–µ —Ä–∞–∑–≤–∏—Ç–∏–µ –±–µ–∑ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–≥–æ –¥–æ–ª–≥–∞

---

## ‚úÖ –≠–¢–ê–ü 1. Unified Network Layer ‚Äî –†–ï–ê–õ–ò–ó–û–í–ê–ù–û

**–°—Ç–∞—Ç—É—Å:** ‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ (MVP)

–†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ:
- –µ–¥–∏–Ω—ã–π —Å–µ—Ç–µ–≤–æ–π —Å–ª–æ–π –¥–ª—è –≤—Å–µ—Ö –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤
- DoH (DNS-over-HTTPS) –¥–ª—è –æ–±—Ö–æ–¥–∞ DNS-–±–ª–æ–∫–∏—Ä–æ–≤–æ–∫
- retry / timeout —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
- mirror rotation
- graceful degradation

---

## ‚úÖ –≠–¢–ê–ü 2. Aggregator + Unified Search Contract ‚Äî –†–ï–ê–õ–ò–ó–û–í–ê–ù–û

**–°—Ç–∞—Ç—É—Å:** ‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ

–†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ:
- `SearchAggregator` –∫–∞–∫ —Ü–µ–Ω—Ç—Ä —Å–∏—Å—Ç–µ–º—ã
- –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–π –æ–ø—Ä–æ—Å –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤ (`Promise.allSettled`)
- partial success –∫–∞–∫ –¥–æ–ø—É—Å—Ç–∏–º–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
- –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏—è –ø–æ infohash

---

## ‚úÖ –≠–¢–ê–ü 3. Provider Architecture + Core Providers ‚Äî –†–ï–ê–õ–ò–ó–û–í–ê–ù–û

**–°—Ç–∞—Ç—É—Å:** ‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ

–†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ:
- `BaseProvider` –∏ `ProviderManager`
- –ò—Å—Ç–æ—á–Ω–∏–∫–∏: Jacred, RuTracker (auth), Rutor, TorLook

---

## ‚úÖ –≠–¢–ê–ü 4. AutoDownloader v2 ‚Äî –†–ï–ê–õ–ò–ó–û–í–ê–ù–û

**–°—Ç–∞—Ç—É—Å:** ‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ

–†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ:
- –æ—Ç–∫–∞–∑ –æ—Ç –ø—Ä–∏–≤—è–∑–∫–∏ –∫ –æ–¥–Ω–æ–º—É –∏—Å—Ç–æ—á–Ω–∏–∫—É
- –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ Aggregator
- –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–æ–∫ –∏ –≤—ã–±–æ—Ä –ª—É—á—à–µ–≥–æ —Ä–µ–ª–∏–∑–∞

---

## ‚úÖ –≠–¢–ê–ü 5. Client / PWA Improvements ‚Äî –†–ï–ê–õ–ò–ó–û–í–ê–ù–û

**–°—Ç–∞—Ç—É—Å:** ‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ

–†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ:
- **Backend API v2:** Envelope pattern, –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö.
- **TV-first UX:** –ù–∞—Ç–∏–≤–Ω–∞—è D-pad –Ω–∞–≤–∏–≥–∞—Ü–∏—è, Focus Trap.
- **Smart UI:** –§–∏–ª—å—Ç—Ä—ã –∫–∞—á–µ—Å—Ç–≤–∞, —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞.
- **Voice Search:** Android Speech Recognition integration.

---

## ‚úÖ –≠–¢–ê–ü 6. Client Architecture Refinement & UX ‚Äî –†–ï–ê–õ–ò–ó–û–í–ê–ù–û

**–°—Ç–∞—Ç—É—Å:** ‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ

**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ (Metadata):** –û—Ç–∫–∞–∑–∞–ª–∏—Å—å –æ—Ç —Å–æ–∑–¥–∞–Ω–∏—è Backend API (`/api/v2/metadata`) –≤ –ø–æ–ª—å–∑—É —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ **"Zero-Cost Frontend Enrichment"**.
–¢–∞–∫ –∫–∞–∫ –∫–ª–∏–µ–Ω—Ç (`Poster.jsx`) —É–∂–µ —Ö–æ–¥–∏—Ç –≤ TMDB/–ö–∏–Ω–æ–ø–æ–∏—Å–∫ —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏ –∑–∞ –∫–∞—Ä—Ç–∏–Ω–∫–∞–º–∏, –æ–Ω –ø–æ–ª—É—á–∞–µ—Ç –ø–æ–ª–Ω—ã–π JSON —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º. –ú—ã –±—É–¥–µ–º —Å–æ—Ö—Ä–∞–Ω—è—Ç—å —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ, –Ω–µ –Ω–∞–≥—Ä—É–∂–∞—è –±—ç–∫–µ–Ω–¥.

### 6.1. Metadata Layer (Frontend Only)
> *–û–ø–∏—Å–∞–Ω–∏—è —Ñ–∏–ª—å–º–æ–≤ –±–µ–∑ –Ω–æ–≤—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤.*

**`Poster.jsx` (Data Ingestion):**
- [ ] –ò–∑–º–µ–Ω–∏—Ç—å –ª–æ–≥–∏–∫—É –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è: —Å–æ—Ö—Ä–∞–Ω—è—Ç—å –≤ `localStorage` —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç.
  - **–í–∞–∂–Ω–æ:** –î–æ–±–∞–≤–∏—Ç—å `timestamp` –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π LRU-–æ—á–∏—Å—Ç–∫–∏.
  ```json
  {
    "poster": "https://...",
    "backdrop": "https://...",
    "overview": "–¢–µ–∫—Å—Ç –æ–ø–∏—Å–∞–Ω–∏—è...",
    "rating": 7.8,
    "year": "2024",
    "title": "–ù–∞–∑–≤–∞–Ω–∏–µ",
    "timestamp": 1704067200000 
  }
[ ] LRU Eviction: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∑–∞—â–∏—Ç—É –æ—Ç –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è (–ª–∏–º–∏—Ç ~300 –∑–∞–ø–∏—Å–µ–π). –£–¥–∞–ª—è—Ç—å —Å–∞–º—ã–µ —Å—Ç–∞—Ä—ã–µ –ø–æ timestamp.

‚ö†Ô∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:

localStorage –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–∞–∫ best-effort cache.

–û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –¥–æ–ª–∂–Ω–æ –ª–æ–º–∞—Ç—å UI (Graceful Degradation).

TorrentModal.jsx (Data Presentation):

[ ] –ß—Ç–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –∏–∑ localStorage –ø–æ –∫–ª—é—á—É.

[ ] UI Update:

–ö—Ä–∞—Å–∏–≤—ã–π Header —Å Backdrop. –í–∞–∂–Ω–æ: –ï—Å–ª–∏ backdrop –Ω–µ—Ç, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫—Ä–∞—Å–∏–≤—ã–π CSS-–≥—Ä–∞–¥–∏–µ–Ω—Ç (Fallback).

–í—ã–≤–æ–¥ —Ä–µ–π—Ç–∏–Ω–≥–∞ (Badge) —Å —Ü–≤–µ—Ç–æ–≤–æ–π –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π (üü¢ >7, üü° >5, üî¥ <5).

–ë–ª–æ–∫ —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º (overview) —Å line-clamp –∏ –∫–Ω–æ–ø–∫–æ–π "–ï—â–µ".

6.2. Refactoring: TV Navigation Hook & Main Grid
–ö–†–ò–¢–ò–ß–ù–û: –û–±–µ—Å–ø–µ—á–∏—Ç—å –Ω–∞–≤–∏–≥–∞—Ü–∏—é —Å –ø—É–ª—å—Ç–∞ –≤–æ –≤—Å–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏.

[ ] useTVNavigation Hook:

–ò–Ω–∫–∞–ø—Å—É–ª—è—Ü–∏—è –ª–æ–≥–∏–∫–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞–∂–∞—Ç–∏–π.

–ü–æ–¥–¥–µ—Ä–∂–∫–∞ Grid Navigation (2D: –≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑ + –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ).

–ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–æ–ª–æ–Ω–æ–∫ (Responsive).

[ ] –í–Ω–µ–¥—Ä–µ–Ω–∏–µ (Refactoring):

SearchPanel.jsx (–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫).

TorrentModal.jsx (–°–ø–∏—Å–æ–∫ —ç–ø–∏–∑–æ–¥–æ–≤).

App.jsx (–ì–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω): ‚ö†Ô∏è –î–æ–±–∞–≤–∏—Ç—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ñ–æ–∫—É—Å–æ–º –¥–ª—è —Å–µ—Ç–∫–∏ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤ (—Å–µ–π—á–∞—Å –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç).

6.3. UX: Enhanced Provider Health & Accessibility
–ü–æ–Ω—è—Ç–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å.

[ ] Interactive Status Chips:

–ö–ª–∏–∫–∞–±–µ–ª—å–Ω—ã–µ –∏–∫–æ–Ω–∫–∏ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤ (Tooltip —Å –æ—à–∏–±–∫–æ–π).

–ë–∞–Ω–Ω–µ—Ä "All Sources Failed", –µ—Å–ª–∏ –≤—Å–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä—ã —É–ø–∞–ª–∏ (—Å –∫–Ω–æ–ø–∫–æ–π "–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞").

–¶–≤–µ—Ç–æ–≤–∞—è –∫–æ–¥–∏—Ä–æ–≤–∫–∞: Error (üî¥) vs Timeout (üü°).

[ ] Accessibility:

–î–æ–±–∞–≤–∏—Ç—å aria-label –¥–ª—è –≤—Å–µ—Ö –∫–Ω–æ–ø–æ–∫-–∏–∫–æ–Ω–æ–∫ (Voice Search, Settings, etc).

### 6.4. TorrentModal TV Optimization
> *–ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –Ω–µ –¥–æ–ª–∂–Ω–æ –≤—ã—Ö–æ–¥–∏—Ç—å –∑–∞ –ø—Ä–µ–¥–µ–ª—ã —ç–∫—Ä–∞–Ω–∞ TV.*

**–ü—Ä–æ–±–ª–µ–º–∞:** –ü—Ä–∏ –±–æ–ª—å—à–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ —Å–µ—Ä–∏–π (>15) —Å–ø–∏—Å–æ–∫ —ç–ø–∏–∑–æ–¥–æ–≤ –≤—ã—Ç–∞–ª–∫–∏–≤–∞–µ—Ç header —Å —Ä–µ–π—Ç–∏–Ω–≥–æ–º –∑–∞ –ø—Ä–µ–¥–µ–ª—ã —ç–∫—Ä–∞–Ω–∞.

**–ü–ª–∞–Ω–∏—Ä—É–µ–º—ã–µ —Ä–µ—à–µ–Ω–∏—è:**
- [ ] **Fixed Header:** –ó–∞–∫—Ä–µ–ø–∏—Ç—å header —Å backdrop/—Ä–µ–π—Ç–∏–Ω–≥–æ–º, —Å–∫—Ä–æ–ª–ª —Ç–æ–ª—å–∫–æ –¥–ª—è —Å–ø–∏—Å–∫–∞ —ç–ø–∏–∑–æ–¥–æ–≤.
- [ ] **–í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π —Å–∫—Ä–æ–ª–ª:** –†–µ–Ω–¥–µ—Ä–∏—Ç—å —Ç–æ–ª—å–∫–æ –≤–∏–¥–∏–º—ã–µ —ç–ø–∏–∑–æ–¥—ã (~10) –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.
- [ ] **Collapse –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é:** –°–∫—Ä—ã–≤–∞—Ç—å —Å–ø–∏—Å–æ–∫ —ç–ø–∏–∑–æ–¥–æ–≤, –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ "‚ñº 25 —ç–ø–∏–∑–æ–¥–æ–≤" (—Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è –ø–æ –∫–ª–∏–∫—É).
- [ ] **Limit Height:** –û–≥—Ä–∞–Ω–∏—á–∏—Ç—å max-height —Å–ø–∏—Å–∫–∞ —ç–ø–∏–∑–æ–¥–æ–≤ –¥–æ `40vh`.

---


–î–æ—Ä–æ–∂–Ω–∞—è –ö–∞—Ä—Ç–∞ PWA-TorServe v3.0 ‚Äî ‚úÖ –†–ï–ê–õ–ò–ó–û–í–ê–ù–û
–¶–µ–ª—å: –°–æ–∑–¥–∞—Ç—å Netflix-like –≥–ª–∞–≤–Ω—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É, –∏—Å–ø–æ–ª—å–∑—É—è –≤–∞—à—É –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—É—é 5-—É—Ä–æ–≤–Ω–µ–≤—É—é —Å–∏—Å—Ç–µ–º—É –æ–±—Ö–æ–¥–∞ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫, –∏ —É—Å—Ç—Ä–∞–Ω–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ "—É–∑–∫–∏–µ –º–µ—Å—Ç–∞" (DNS Poisoning –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ).

üèõÔ∏è –§–∞–∑–∞ 1: –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–π –§—É–Ω–¥–∞–º–µ–Ω—Ç (Refactoring)
–í—ã –ø–æ–±–µ–¥–∏–ª–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫—É –≤ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–µ Poster.jsx, –Ω–æ —Ç–µ–ø–µ—Ä—å —ç—Ç—É –ª–æ–≥–∏–∫—É –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤–µ–∑–¥–µ (–≤ –ø–æ–∏—Å–∫–µ, –≤ –ø–æ–¥–±–æ—Ä–∫–∞—Ö, –≤ –¥–µ—Ç–∞–ª—è—Ö —Ñ–∏–ª—å–º–∞). –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥ –Ω–µ–ª—å–∑—è.

‚úÖ –ó–∞–¥–∞—á–∞ 1.1: –°–æ–∑–¥–∞–Ω–∏–µ tmdbClient.js (Unified Fetcher)
–í—ã–Ω–æ—Å–∏–º –ª–æ–≥–∏–∫—É –∏–∑ Poster.jsx –≤ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —É—Ç–∏–ª–∏—Ç—É.

–§–∞–π–ª: client/src/utils/tmdbClient.js

–õ–æ–≥–∏–∫–∞:

–ü—Ä–∏–Ω–∏–º–∞–µ—Ç endpoint (–Ω–∞–ø—Ä. /trending/all/week).

–ü—Ä–æ–≥–æ–Ω—è–µ—Ç —á–µ—Ä–µ–∑ –∫–∞—Å–∫–∞–¥ (Custom Worker -> Lampa Proxy -> CapacitorHttp -> Corsproxy -> Kinopoisk).

–£–ª—É—á—à–µ–Ω–∏–µ: –î–æ–±–∞–≤–ª—è–µ–º Client-side DoH (—Å–º. –§–∞–∑—É 3), —á—Ç–æ–±—ã –ø–æ—á–∏–Ω–∏—Ç—å CapacitorHttp –≤ –†–§.

–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç { results: [...], source: 'tmdb' | 'kp' }.

‚úÖ –ó–∞–¥–∞—á–∞ 1.2: Hardcoded Genre Map
TMDB –≤ —Å–ø–∏—Å–∫–∞—Ö –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–ª—å–∫–æ ID –∂–∞–Ω—Ä–æ–≤ ([28, 878]), –∞ –Ω–µ –Ω–∞–∑–≤–∞–Ω–∏—è. –ß—Ç–æ–±—ã –Ω–µ –¥–µ–ª–∞—Ç—å –ª–∏—à–Ω–∏–µ –∑–∞–ø—Ä–æ—Å—ã:

–§–∞–π–ª: client/src/utils/genres.js

–î–µ–π—Å—Ç–≤–∏–µ: –°–æ–∑–¥–∞—Ç—å —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π —Å–ª–æ–≤–∞—Ä—å: { 28: "–ë–æ–µ–≤–∏–∫", 878: "–§–∞–Ω—Ç–∞—Å—Ç–∏–∫–∞", ... }.

üì∫ –§–∞–∑–∞ 2: –ì–ª–∞–≤–Ω–∞—è –°—Ç—Ä–∞–Ω–∏—Ü–∞ (Discovery)
–†–µ–∞–ª–∏–∑–∞—Ü–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ "–∫–∞–∫ –≤ Lampa/Netflix" –±–µ–∑ –±—ç–∫–µ–Ω–¥–∞.

‚úÖ –ó–∞–¥–∞—á–∞ 2.1: –ö–ª–∏–µ–Ω—Ç—Å–∫–æ–µ API (discover.js)
–ò–º–ø–æ—Ä—Ç: –ò—Å–ø–æ–ª—å–∑—É–µ—Ç tmdbClient.js –∏–∑ –§–∞–∑—ã 1.

–ö–∞—Ç–µ–≥–æ—Ä–∏–∏:

üî• –¢—Ä–µ–Ω–¥—ã (/trending/all/week)

üé¨ –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ñ–∏–ª—å–º—ã (/movie/popular)

üì∫ –°–µ—Ä–∏–∞–ª—ã (/tv/popular)

‚≠ê –¢–æ–ø —Ä–µ–π—Ç–∏–Ω–≥–∞ (/movie/top_rated)

–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è: –£–¥–∞–ª—è—Ç—å –ª—é–¥–µ–π (media_type: person) –∏ –∫–æ–Ω—Ç–µ–Ω—Ç –±–µ–∑ –ø–æ—Å—Ç–µ—Ä–æ–≤.

‚úÖ –ó–∞–¥–∞—á–∞ 2.2: –ö–æ–º–ø–æ–Ω–µ–Ω—Ç HomeRow.jsx (–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫)
–í–∏—Ä—Ç—É–∞–ª–∏–∑–∞—Ü–∏—è: –†–µ–Ω–¥–µ—Ä–∏—Ç—å —Ç–æ–ª—å–∫–æ –≤–∏–¥–∏–º—ã–µ + 2 —Å–æ—Å–µ–¥–Ω–∏—Ö –ø–æ—Å—Ç–µ—Ä–∞ (–∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è TV —Å –º–∞–ª–æ–π –ø–∞–º—è—Ç—å—é).

–ù–∞–≤–∏–≥–∞—Ü–∏—è:

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å useTVNavigation —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º loop: true.

–ü—Ä–∏ —Ñ–æ–∫—É—Å–µ –Ω–∞ –ø–æ—Å—Ç–µ—Ä–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å Backdrop –Ω–∞ —Ñ–æ–Ω–µ (–∫—Ä–∞—Å–∏–≤—ã–π —ç—Ñ—Ñ–µ–∫—Ç Lampa).

‚úÖ –ó–∞–¥–∞—á–∞ 2.3: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å TorServe
–õ–æ–≥–∏–∫–∞ –∫–ª–∏–∫–∞:

–ï—Å–ª–∏ —Ñ–∏–ª—å–º: –ò—Å–∫–∞—Ç—å –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é + –≥–æ–¥.

–ï—Å–ª–∏ —Å–µ—Ä–∏–∞–ª: –ò—Å–∫–∞—Ç—å –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é + S01 (–∫–∞–∫ –æ–±—Å—É–∂–¥–∞–ª–æ—Å—å, —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ –ø–∞–∫ —Å–µ–∑–æ–Ω–∞).

üõ°Ô∏è –§–∞–∑–∞ 3: Client-Side DNS-over-HTTPS (–ù–æ–≤–∞—è —Ñ–∏—á–∞)
–í –ê–∫—Ç–µ 11 –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –≤—ã –∑–∞–º–µ—Ç–∏–ª–∏, —á—Ç–æ CapacitorHttp –ø–∞–¥–∞–µ—Ç —Å –æ—à–∏–±–∫–æ–π –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ 127.0.0.1 –∏–∑-–∑–∞ DNS Poisoning –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–º. –ú—ã –∏—Å–ø—Ä–∞–≤–∏–ª–∏ —ç—Ç–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ (–ê–∫—Ç 6), —Ç–µ–ø–µ—Ä—å –∏—Å–ø—Ä–∞–≤–∏–º –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ.

‚úÖ –ó–∞–¥–∞—á–∞ 3.1: –†–µ–∞–ª–∏–∑–∞—Ü–∏—è resolveIP –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ
–ò–¥–µ—è: –ü–µ—Ä–µ–¥ –∑–∞–ø—Ä–æ—Å–æ–º CapacitorHttp —É–∑–Ω–∞—Ç—å —Ä–µ–∞–ª—å–Ω—ã–π IP —á–µ—Ä–µ–∑ Google/Cloudflare DNS API (–æ–Ω–∏ –æ–±—ã—á–Ω–æ –Ω–µ –±–ª–æ–∫–∏—Ä—É—é—Ç—Å—è).

–ö–æ–¥ (–ø—Ä–∏–º–µ—Ä):

JavaScript

async function resolveClientIP(hostname) {
   // –ó–∞–ø—Ä–æ—Å –∫ Google DNS API
   const res = await fetch(`https://dns.google/resolve?name=${hostname}&type=A`);
   const data = await res.json();
   return data.Answer?.[0]?.data; // –†–µ–∞–ª—å–Ω—ã–π IP (–Ω–∞–ø—Ä. 65.8.11.22)
}
‚úÖ –ó–∞–¥–∞—á–∞ 3.2: –í–Ω–µ–¥—Ä–µ–Ω–∏–µ –≤ CapacitorHttp
–õ–æ–≥–∏–∫–∞:

–ü–æ–ª—É—á–∞–µ–º IP –¥–ª—è api.themoviedb.org.

–î–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ https://<IP>/3/....

–ü–µ—Ä–µ–¥–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ Host: api.themoviedb.org.

–†–µ–∑—É–ª—å—Ç–∞—Ç: CapacitorHttp –Ω–∞—á–Ω–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –≤ –†–§ –±–µ–∑ VPN (—Ç–∞–∫ –∫–∞–∫ –º—ã –æ–±–æ—à–ª–∏ –æ—Ç—Ä–∞–≤–ª–µ–Ω–Ω—ã–π DNS), —á—Ç–æ –¥–∞—Å—Ç SSL-—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∏ —Å–∫–æ—Ä–æ—Å—Ç—å –Ω–∞—Ç–∏–≤–Ω–æ–≥–æ –∫–æ–¥–∞.

‚ö° –§–∞–∑–∞ 4: –ö–∏–Ω–æ–ø–æ–∏—Å–∫ –∫–∞–∫ –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π Fallback (–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ)
–°–µ–π—á–∞—Å –ö–∏–Ω–æ–ø–æ–∏—Å–∫ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –¥–ª—è –∫–∞—Ä—Ç–∏–Ω–æ–∫. –ù–æ –µ—Å–ª–∏ TMDB –ª—è–∂–µ—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é, –≥–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –±—É–¥–µ—Ç –ø—É—Å—Ç–æ–π.

‚úÖ –ó–∞–¥–∞—á–∞ 4.1: –ê–¥–∞–ø—Ç–µ—Ä Discovery –¥–ª—è –ö–∏–Ω–æ–ø–æ–∏—Å–∫–∞
–í discover.js: –ï—Å–ª–∏ –≤—Å–µ –∑–µ—Ä–∫–∞–ª–∞ TMDB –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã, –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç—å—Å—è –Ω–∞ API –ö–∏–Ω–æ–ø–æ–∏—Å–∫–∞.

–≠–Ω–¥–ø–æ–∏–Ω—Ç—ã KP:

–¢—Ä–µ–Ω–¥—ã -> /api/v2.2/films/collections?type=TOP_POPULAR_ALL

–¢–æ–ø -> /api/v2.2/films/collections?type=TOP_250_MOVIES

–ú–∞–ø–ø–∏–Ω–≥: –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –æ—Ç–≤–µ—Ç KP –≤ —Ñ–æ—Ä–º–∞—Ç TMDB (id, title, poster_path), —á—Ç–æ–±—ã UI –Ω–µ –∑–∞–º–µ—Ç–∏–ª –ø–æ–¥–º–µ–Ω—ã.

üèÅ –ò—Ç–æ–≥–æ–≤–∞—è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ v3.0
–≠—Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç —Ä–∞–±–æ—Ç—É –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –≤ –ª—é–±—ã—Ö —É—Å–ª–æ–≤–∏—è—Ö –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫.

UI Layer: HomePanel -> HomeRow -> Poster

Data Layer: discover.js (–ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ + –õ–æ–≥–∏–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π)

Network Layer (tmdbClient.js):

üîÑ –ü–æ–ø—ã—Ç–∫–∞ 1: Custom Worker (–î–ª—è –∑–∞—Ä—É–±–µ–∂—å—è).

üîÑ –ü–æ–ø—ã—Ç–∫–∞ 2: Lampa Proxy (MVP –¥–ª—è –†–§).

üîÑ –ü–æ–ø—ã—Ç–∫–∞ 3: CapacitorHttp + Client DoH (–ù–∞—Ç–∏–≤–Ω—ã–π –æ–±—Ö–æ–¥ DNS poisoning).

üîÑ –ü–æ–ø—ã—Ç–∫–∞ 4: Corsproxy.io (–ë—Ä–∞—É–∑–µ—Ä–Ω—ã–π fallback).

üîÑ –ü–æ–ø—ã—Ç–∫–∞ 5: –ö–∏–Ω–æ–ø–æ–∏—Å–∫ API (–ü–æ–ª–Ω–∞—è –∑–∞–º–µ–Ω–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –¥–∞–Ω–Ω—ã—Ö).

Fail-safe: –ì—Ä–∞–¥–∏–µ–Ω—Ç—ã (Offline mode).

–ù–Æ–ê–ù–° (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —É—á—Ç–∏)

–ö–æ–≥–¥–∞ —Ç—ã –¥–µ–ª–∞–µ—à—å:

https://<IP>/3/...
Host: api.themoviedb.org


‚ö†Ô∏è –í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã:

TLS SNI

—Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç –º–æ–∂–µ—Ç –Ω–µ —Å–æ–≤–ø–∞—Å—Ç—å

‚úÖ –ö–∞–∫ —Å–¥–µ–ª–∞—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω–æ

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¢–û–õ–¨–ö–û HTTPS

–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ CapacitorHttp:

–Ω–µ –≤–∞–ª–∏–¥–∏—Ä—É–µ—Ç CN —Å—Ç—Ä–æ–≥–æ
(–æ–±—ã—á–Ω–æ –æ–Ω –¥–æ–≤–µ—Ä—è–µ—Ç —Å–∏—Å—Ç–µ–º–µ)

üìå –ü—Ä–∞–≤–∏–ª–æ:

Client DoH ‚Äî —Ç–æ–ª—å–∫–æ –¥–ª—è CapacitorHttp,
‚ùå –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –¥–ª—è browser fetch

–¢—ã —ç—Ç–æ –ª–æ–≥–∏—á–µ—Å–∫–∏ —É–∂–µ —Å–æ–±–ª—é–¥–∞–µ—à—å ‚Äî –ø—Ä–æ—Å—Ç–æ –∑–∞—Ñ–∏–∫—Å–∏—Ä—É–π.
üó∫Ô∏è ROADMAP v3.1: Operation "Unstoppable" & TV Resurrection
Version: 3.1
Status: üö¶ READY FOR DEV
Target Platform: Android TV / Smart TV / PWA
Focus: Resilience (Anti-Censorship), Navigation (D-Pad), UX Performance.

ü§ñ AI AGENT INSTRUCTION: CONTEXT VERIFICATION
STOP! READ THIS BEFORE EXECUTING.
Before implementing any task from this roadmap, you MUST perform a Pre-Work Context Scan:
 * Scan the file structure: Verify if files mentioned (e.g., useTVNavigation.js, server/utils/doh.js) exist or are empty.
 * Check git status or recent commits: Ensure no one else has implemented these features recently.
 * Validate assumptions: If a task says "Code is missing," but you see the code, update the roadmap status and ask the user for a new direction.
 * Propose Improvements: If you see a cleaner architectural solution than described below (e.g., using a newer library or pattern), propose it to the user before writing code.

üìÖ Execution Batches
–ú—ã –≤—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–¥–∞—á–∏ –ø–∞–∫–µ—Ç–∞–º–∏ (Batches) –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ —Å–±–æ—Ä–∫–∏.

üì¶ Batch 1: "Resurrection" (TV Core)
–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π —ç—Ç–∞–ø. –ë–µ–∑ –Ω–µ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –Ω–µ—Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ –Ω–∞ –¢–í.
 * FIX-01a: 1D List Navigation (–ë–∞–∑–æ–≤–∞—è –º–µ—Ö–∞–Ω–∏–∫–∞ + CSS Focus state)
 * FIX-01b: 2D Grid Navigation (–î–ª—è –∫–∞—Ä—Ç–æ—á–µ–∫)
 * FIX-01c: Modal Focus Trap (–£–¥–µ—Ä–∂–∞–Ω–∏–µ —Ñ–æ–∫—É—Å–∞)
 * SEC-01: Global Error Boundary

üì¶ Batch 2: "Unstoppable" (Network Resilience)
–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –≤—ã–∂–∏–≤–∞–Ω–∏—è. –ó–∞—â–∏—Ç–∞ –æ—Ç –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫ CDN –∏ DNS.
 * ARC-01: Server-Side DoH Rotation + Circuit Breaker
 * ARC-02: Client Waterfall Fetching (NAS -> Proxy -> Direct -> Gradient UI)

üì¶ Batch 3: "Polish" (UX & Performance)
–£–ª—É—á—à–µ–Ω–∏–µ –æ—Ç–∑—ã–≤—á–∏–≤–æ—Å—Ç–∏ –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ—Å—Ç–∏.
 * UX-02: Server-Side Badge Parsing (Backend API update)
 * UX-01: SearchPanel Performance (Debounce + Memo)
 * UX-03: Client-Side Sorting & Filtering

üì¶ Batch 4: "Validation"
 * TEST-01: Real Device Testing

üìã Detailed Task List

| ID | Task Name | Priority | Complexity | Description & Tech Stack |
|---|---|---|---|---|
| FIX-01a | 1D List Navigation | MUST | Mid | Stack: React Hook (useTVNavigation). <br>Desc: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É ArrowUp/ArrowDown. **–í–∞–∂–Ω–æ: –î–æ–±–∞–≤–∏—Ç—å CSS-–∫–ª–∞—Å—Å `.focused` –¥–ª—è –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞.** –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Å–∫—Ä–æ–ª–ª–∞ —á–µ—Ä–µ–∑ scrollIntoView. |
| FIX-01b | 2D Grid Navigation | MUST | High | Stack: React Hook. <br>Desc: –î–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É columns > 1. –û–±—Ä–∞–±–æ—Ç–∫–∞ ArrowLeft/ArrowRight. –£–º–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥ –º–µ–∂–¥—É —Å—Ç—Ä–æ–∫–∞–º–∏ (—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—Ç–æ–ª–±—Ü–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –≤–Ω–∏–∑). |
| FIX-01c | Modal Focus Trap | MUST | Mid | Stack: React (useEffect, DOM). <br>Desc: –ü—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –º–æ–¥–∞–ª–∫–∏ (TorrentModal) —Ñ–æ–∫—É—Å –¥–æ–ª–∂–µ–Ω –∑–∞—Ö–≤–∞—Ç—ã–≤–∞—Ç—å—Å—è –≤–Ω—É—Ç—Ä–∏ –Ω–µ—ë –∏ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å—Å—è –Ω–∞ –∫–Ω–æ–ø–∫—É –æ—Ç–∫—Ä—ã—Ç–∏—è –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏. |
| SEC-01 | Error Boundary | SHOULD | Low | Stack: React Class Component. <br>Desc: –û–±–µ—Ä–Ω—É—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, —á—Ç–æ–±—ã –∫—Ä–∞—à –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –Ω–µ –≤–µ—à–∞–ª –≤–µ—Å—å TV-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å (–±–µ–ª—ã–π —ç–∫—Ä–∞–Ω). |
| ARC-01 | Server DoH Rotation | DONE | Mid | Stack: Node.js (fetch). <br>Desc: –í doh.js –≤–Ω–µ–¥—Ä–µ–Ω –º–∞—Å—Å–∏–≤ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤ (Google, Quad9, Cloudflare). –õ–æ–≥–∏–∫–∞ Race —Å —Ç–∞–π–º–∞—É—Ç–æ–º 2—Å–µ–∫ + Circuit Breaker. |
| ARC-02 | Client Waterfall | DONE | High | Stack: React (AbortSignal). <br>Desc: –í tmdbClient.js 5 —É—Ä–æ–≤–Ω–µ–π: Worker -> Lampa Proxy -> CapacitorHttp (DoH) -> Direct -> Gradient. |
| UX-01 | Search Performance | DONE | Low | Stack: React 18 (useDeferredValue) OR use-debounce. <br>Desc: –£–±—Ä–∞—Ç—å –ª–∞–≥–∏ –≤–≤–æ–¥–∞. –û—Ç–ª–æ–∂–µ–Ω–Ω–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å–ø–∏—Å–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤. |
| UX-02 | Backend Badges | DONE | Mid | Stack: Node.js (Express). <br>Desc: –ü–µ—Ä–µ–Ω–µ—Å–µ–Ω –ø–∞—Ä—Å–∏–Ω–≥ (4K, HDR, HEVC) –Ω–∞ —Å–µ—Ä–≤–µ—Ä. /api/v2/search –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–ª–µ badges[] –∏ health. |
| UX-03 | Client Sort/Filter | DONE | Low | Stack: React (useState). <br>Desc: UI –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ (Seeds/Size) –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏. –°–≤—è–∑–∞—Ç—å —Å –¥–∞–Ω–Ω—ã–º–∏ –∏–∑ UX-02. |
| TEST-01 | Device Testing | DONE | Low | Stack: Android TV / FireStick. <br>Desc: –¢–µ—Å—Ç –Ω–∞ —Ä–µ–∞–ª—å–Ω–æ–º –∂–µ–ª–µ–∑–µ. Fix: Navbar access, Focus clipping, Scroll jitter, Back button logic. |
| OPT-01 | List Virtualization | WONT | High | –û—Ç–ª–æ–∂–µ–Ω–æ. react-window –ø–æ–∫–∞ –Ω–µ –≤–Ω–µ–¥—Ä—è–µ–º, —Ä–µ—à–∞–µ–º –ø—Ä–æ–±–ª–µ–º—ã —á–µ—Ä–µ–∑ UX-01. |

üõ†Ô∏è Technical Specifications (Reference for AI)

1. Navigation Logic (FIX-01)
Hook –¥–æ–ª–∂–µ–Ω –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å containerRef –∏ itemSelector.
–í–∏–∑—É–∞–ª: –ò—Å–ø–æ–ª—å–∑—É–π CSS transform (scale) –∏–ª–∏ border –¥–ª—è —Ñ–æ–∫—É—Å–∞.
–°–∫—Ä–æ–ª–ª: `el.scrollIntoView({ behavior: 'smooth', block: 'center' })` —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Å–∫–∞—á–∫–æ–≤.

// Expected Logic Pattern for 2D
const nextIndex = (current, key, cols) => {
   if (key === 'ArrowDown') return current + cols;
   if (key === 'ArrowRight' && (current % cols !== cols - 1)) return current + 1;
   // ... handle boundaries
}

2. Resilience Architecture (ARC-01/02)
Server-Side:
–ù–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ö–∞—Ä–¥–∫–æ–¥ 1.1.1.1. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –º–∞—Å—Å–∏–≤ DOH_PROVIDERS.
Client-Side:
// Waterfall Strategy
try {
  return await fetchLocalNAS(query);
} catch {
  console.warn("NAS unreachable, trying Cloudflare Worker...");
  try {
     return await fetchExternalWorker(query);
  } catch {
     return generateGradientPlaceholder(query); // Final Fallback
  }
}

3. Badge Parsing (UX-02 - Server Side)
–í —Ñ–∞–π–ª–µ server/utils/helpers.js (–∏–ª–∏ server/providers/BaseProvider.js) —Å–æ–∑–¥–∞—Ç—å:
function extractMetadata(title) {
  return {
    badges: [
      /2160p|4k/i.test(title) && '4K',
      /hevc|x265/i.test(title) && 'HEVC'
    ].filter(Boolean),
    // ...
  }
}
---

## üó∫Ô∏è ROADMAP v3.1: Operation "Unstoppable" (Post-Mortem & Status)
**Version:** 3.1 (Legacy)
**Status:** üèÅ ARCHIVED (–ü–µ—Ä–µ—Ö–æ–¥ –∫ v3.2)
**Outcome:** –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ–∏—á–∏ –≤–Ω–µ–¥—Ä–µ–Ω—ã, –Ω–æ –∞—É–¥–∏—Ç –≤—ã—è–≤–∏–ª –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã –∏ "–º–µ—Ä—Ç–≤—ã–π –∫–æ–¥".

| ID | Task Name | Status | Notes |
|---|---|---|---|
| FIX-01a | 1D List Navigation | ‚úÖ DONE | –ë–∞–∑–æ–≤–∞—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç. |
| FIX-01b | 2D Grid Navigation | ‚úÖ DONE | Grid —Ä–∞–±–æ—Ç–∞–µ—Ç. |
| FIX-01c | Modal Focus Trap | ‚ùå FAILED | **Regression:** Escape –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, —Ñ–æ–∫—É—Å —Ç–µ—Ä—è–µ—Ç—Å—è. (–ü–µ—Ä–µ–Ω–µ—Å–µ–Ω–æ –≤ v3.2) |
| ARC-01 | Server DoH Rotation | ‚úÖ DONE | –†–∞–±–æ—Ç–∞–µ—Ç —Å—Ç–∞–±–∏–ª—å–Ω–æ. |
| ARC-02 | Client Waterfall | ‚ö†Ô∏è REOPENED | **Critical:** –õ–æ–≥–∏–∫–∞ –Ω–∞–ø–∏—Å–∞–Ω–∞, –Ω–æ —Ñ–∏–∑–∏—á–µ—Å–∫–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∞ (`resolveClientIP` –Ω–µ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è). |
| UX-01 | Search Performance | ‚úÖ DONE | Debounce –≤–Ω–µ–¥—Ä–µ–Ω. |
| OPT-01 | List Virtualization | üîÑ MOVED | –°—Ç–∞—Ç—É—Å –∏–∑–º–µ–Ω–µ–Ω —Å WONT –Ω–∞ **SHOULD** (—Ç–µ—Å—Ç—ã –Ω–∞ TV Box –ø–æ–∫–∞–∑–∞–ª–∏ —Ñ—Ä–∏–∑—ã). |

---

## üó∫Ô∏è ROADMAP v3.2: Stabilization & The Last Mile
**Version:** 3.2 (Release Candidate)
**Status:** ‚úÖ PHASE 0 COMPLETE (Audit: 2025-01-20)
**Focus:** –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ —É—Ç–µ—á–µ–∫, –≤–∫–ª—é—á–µ–Ω–∏–µ "—Å–ø—è—â–µ–≥–æ" –∫–æ–¥–∞ (Client DoH) –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–æ–¥ —Å–ª–∞–±–æ–µ –∂–µ–ª–µ–∑–æ.

> **üìã AUDIT RESULTS (2025-01-20):**
> - BUG-01, BUG-02, ARC-02 ‚Äî –∫–æ–¥ —É–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω, –∑–∞–¥–∞—á–∏ –∑–∞–∫—Ä—ã—Ç—ã.
> - OPT-01 ‚Äî **–ó–ê–ú–û–†–û–ñ–ï–ù** –∏–∑-–∑–∞ –≤—ã—Å–æ–∫–æ–≥–æ —Ä–∏—Å–∫–∞ –ø–æ–ª–æ–º–∫–∏ TV-–Ω–∞–≤–∏–≥–∞—Ü–∏–∏.

### üìÖ Execution Phases

#### ‚úÖ Phase 0: Critical Hotfixes (Stabilization) ‚Äî DONE
*–†–µ–∑—É–ª—å—Ç–∞—Ç –∞—É–¥–∏—Ç–∞: 3 –∏–∑ 4 –∑–∞–¥–∞—á —É–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã –≤ –∫–æ–¥–µ.*
* ‚úÖ **BUG-01:** Modal Trap & Escape ‚Äî `e.stopPropagation()` –∏ `previouslyFocusedRef` —É–∂–µ –≤ –∫–æ–¥–µ.
* ‚úÖ **BUG-02:** Memory Leak ‚Äî –∑–∞—â–∏—Ç–∞ `if (frozenCleanupIntervalId) return` —É–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞.
* üîÑ **BUG-03:** –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è UI —Å—Ç–∞—Ç—É—Å–∞ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤ (Real-time update). **TODO**
* üîÑ **FIX-01:** –°—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∞—Ü–∏—è `AutoDownloadPanel` (–≤–Ω–µ–¥—Ä–µ–Ω–∏–µ `useTVNavigation`). **TODO**

#### ‚úÖ Phase 1: True Resilience (Operation "Unstoppable") ‚Äî DONE
*–†–µ–∑—É–ª—å—Ç–∞—Ç –∞—É–¥–∏—Ç–∞: Client DoH –∞–∫—Ç–∏–≤–µ–Ω –¥–ª—è APK.*
* ‚úÖ **ARC-02:** Client DoH **–£–ñ–ï –ê–ö–¢–ò–í–ï–ù** ‚Äî `resolveClientIP()` –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –≤ `tryCapacitorWithDoH()`.
* üîÑ **SEC-01:** –í–Ω–µ–¥—Ä–∏—Ç—å Global Error Boundary (–∑–∞—â–∏—Ç–∞ –æ—Ç –±–µ–ª–æ–≥–æ —ç–∫—Ä–∞–Ω–∞). **TODO**

#### ‚ö†Ô∏è Phase 2: Performance & Polish ‚Äî ACTIVE
*–¶–µ–ª—å: –ü–ª–∞–≤–Ω–æ—Å—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –Ω–∞ —Å–ª–∞–±—ã—Ö TV Box –∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ñ–æ–∫—É—Å–∞.*
* ‚úÖ **BUG-04:** Fix Modal Focus Loss ‚Äî –ö—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è TV. –ï—Å–ª–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è, —Ñ–æ–∫—É—Å —Å–ª–µ—Ç–∞–µ—Ç –≤ `body`.
* ‚úÖ **OPT-02:** Torrent Status Cache ‚Äî –ö—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è ARM. –°–Ω–∏–∂–∞–µ—Ç –Ω–∞–≥—Ä—É–∑–∫—É CPU –ø—Ä–∏ –ø–æ–ª–ª–∏–Ω–≥–µ (0ms vs 200ms).
* ‚õî **OPT-01:** –í–∏—Ä—Ç—É–∞–ª–∏–∑–∞—Ü–∏—è —Å–ø–∏—Å–∫–æ–≤ ‚Äî **–ó–ê–ú–û–†–û–ñ–ï–ù**.
* üîÑ **UX-04:** Client-side Debounce –¥–ª—è –∫–Ω–æ–ø–æ–∫. **TODO**

#### üèóÔ∏è Phase 3: Architecture (Post-Release / Backlog)
* **BE-01:** –î–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏—è –º–æ–Ω–æ–ª–∏—Ç–∞ `server/index.js`. **DEFERRED**. (Refactoring is dangerous right now).
* **OPT-01:** –í–∏—Ä—Ç—É–∞–ª–∏–∑–∞—Ü–∏—è —Å —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–æ–º `useTVNavigation`.

---

### üìã Detailed Task List (v3.2)

| ID | Task Name | Status | Priority | Complexity | Description & Tech Stack |
|---|---|---|---|---|---|
| **BUG-01** | **Fix Modal Trap & Escape** | ‚úÖ DONE | ~~MUST~~ | Low | **–ö–æ–¥ —É–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω:** `TorrentModal.jsx` —Å—Ç—Ä–æ–∫–∏ 63-69, 104-106. `e.stopPropagation()` –∏ `previouslyFocusedRef` –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—Ç. |
| **BUG-02** | **Memory Leak Patch** | ‚úÖ DONE | ~~MUST~~ | Low | **–ö–æ–¥ —É–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω:** `server/torrent.js` —Å—Ç—Ä–æ–∫–∏ 32-36. –ó–∞—â–∏—Ç–∞ `if (frozenCleanupIntervalId) return` —Ä–∞–±–æ—Ç–∞–µ—Ç. |
| **BUG-03** | **Search Providers UI Sync** | ‚úÖ DONE | ~~MUST~~ | Mid | **–ö–æ–¥ –¥–æ–±–∞–≤–ª–µ–Ω:** API endpoint `/api/providers/status` + polling –≤ `App.jsx` –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫. |
| **FIX-01** | **Standardize AutoDownload** | ‚è≠Ô∏è WONTFIX | ~~MUST~~ | Mid | **–ü–µ—Ä–µ–æ—Ü–µ–Ω–µ–Ω–æ:** –ö–æ–º–ø–æ–Ω–µ–Ω—Ç —É–∂–µ –∏–º–µ–µ—Ç D-pad –Ω–∞–≤–∏–≥–∞—Ü–∏—é —á–µ—Ä–µ–∑ `getFocusableElements()` + focus trap. –•—É–∫ `useTVNavigation` –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –≥–µ—Ç–µ—Ä–æ–≥–µ–Ω–Ω–æ–≥–æ UI (–∫–Ω–æ–ø–∫–∏ + picker + —Ñ–æ—Ä–º–∞ + —Å–ø–∏—Å–æ–∫). |
| **ARC-02** | **Activate Client DoH** | ‚úÖ DONE | ~~MUST~~ | High | **–ö–æ–¥ —É–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω:** `tmdbClient.js` —Å—Ç—Ä–æ–∫–∏ 254, 262. DoH –∞–∫—Ç–∏–≤–µ–Ω –¥–ª—è –Ω–∞—Ç–∏–≤–Ω–æ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã. |
| **OPT-01** | **List Virtualization** | ‚õî FROZEN | ~~SHOULD~~ | High | **–†–ò–°–ö:** –°–ª–æ–º–∞–µ—Ç `useTVNavigation`. –¢—Ä–µ–±—É–µ—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è. –ü–µ—Ä–µ–Ω–µ—Å–µ–Ω–æ –≤ Phase 3. |
| **SEC-01** | **Global Error Boundary** | ‚úÖ DONE | ~~SHOULD~~ | Low | **–ö–æ–¥ —É–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω:** `components/ErrorBoundary.jsx` (125 —Å—Ç—Ä–æ–∫) + –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω –≤ `main.jsx`. |
| **UX-04** | **Click Debounce** | ‚úÖ DONE | ~~SHOULD~~ | Low | **–ö–æ–¥ –¥–æ–±–∞–≤–ª–µ–Ω:** `App.jsx` —Å—Ç—Ä–æ–∫–∞ 412. Early return `if (searchLoading) return` –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –¥–≤–æ–π–Ω—ã–µ –∫–ª–∏–∫–∏. |
| **UX-05** | **More Button Focus Fix** | ‚úÖ DONE | ~~MUST~~ | Low | **–ö–æ–¥ –¥–æ–±–∞–≤–ª–µ–Ω:** `HomeRow.jsx` —Å—Ç—Ä–æ–∫–∞ 150. –£–≤–µ–ª–∏—á–µ–Ω —Ç–∞–π–º–∞—É—Ç —Ñ–æ–∫—É—Å–∞ —Å 0 –¥–æ 50–º—Å. |
| **UX-06** | **Category Deduplication** | ‚úÖ DONE | ~~MUST~~ | Low | **–ö–æ–¥ –¥–æ–±–∞–≤–ª–µ–Ω:** `discover.js`. –î–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏—è –º–µ–∂–¥—É –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏ —á–µ—Ä–µ–∑ `seenIds` Set. |
| **UX-07** | **SettingsPanel Simplify** | ‚úÖ DONE | ~~SHOULD~~ | Low | **–ö–æ–¥ –¥–æ–±–∞–≤–ª–µ–Ω:** `SettingsPanel.jsx`. Player Selection —Ç–µ–ø–µ—Ä—å —Å–≤–æ—Ä–∞—á–∏–≤–∞–µ–º—ã–π. |
| **UX-08** | **Smooth Poster Scroll** | ‚úÖ DONE | ~~SHOULD~~ | Low | **–ö–æ–¥ –¥–æ–±–∞–≤–ª–µ–Ω:** `HomeRow.jsx` + `index.css`. scrollTo —Å —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ–º, CSS scroll-behavior. |
| **UX-09** | **Extended Movie Card** | ‚úÖ DONE | ~~SHOULD~~ | Medium | **–ö–æ–¥ –¥–æ–±–∞–≤–ª–µ–Ω:** `MovieDetail.jsx` + `tmdbClient.js`. –†–µ–∂–∏—Å—Å—ë—Ä—ã, –∞–∫—Ç—ë—Ä—ã —Å —Ñ–æ—Ç–æ, —Ç—Ä–µ–π–ª–µ—Ä. |
| **TEST-02** | **Client Unit Tests** | ‚úÖ DONE | ~~SHOULD~~ | Low | Vitest –Ω–∞—Å—Ç—Ä–æ–µ–Ω. 30/30 —Ç–µ—Å—Ç–æ–≤: `discover.test.js`, `helpers.test.js`. |
| **BUG-04** | **Modal Focus Fix** | üîÑ TODO | MUST | Mid | **Stability:** –ò—Å–ø—Ä–∞–≤–ª—è–µ—Ç –ø–æ—Ç–µ—Ä—é —Ñ–æ–∫—É—Å–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç `activeElement` capture. |
| **OPT-02** | **Torrent Status Cache** | ‚úÖ DONE | MUST | Mid | **Perf:** –ö—ç—à JSON –æ—Ç–≤–µ—Ç–∞ (5 —Å–µ–∫). –ö–æ–¥ —É–∂–µ –≤ `server/torrent.js`:381. –ò—Å–ø—Ä–∞–≤–ª—è–µ—Ç —Ñ—Ä–∏–∑—ã –Ω–∞ ARM. |

---

### üêõ Backlog ‚Äî –ò–∑–≤–µ—Å—Ç–Ω—ã–µ –±–∞–≥–∏ (2026-01-31)

| ID | –û–ø–∏—Å–∞–Ω–∏–µ | –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç | –î–µ—Ç–∞–ª–∏ |
|----|----------|-----------|--------|
| ~~**BUG-10**~~ | ~~**–ö–Ω–æ–ø–∫–∞ "–°–º–æ—Ç—Ä–µ—Ç—å —Ç—Ä–µ–π–ª–µ—Ä" –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ —Å –ø—É–ª—å—Ç–∞**~~ | ~~HIGH~~ | ‚úÖ **FIXED (2026-01-21):** –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ —á–µ—Ä–µ–∑ `@capacitor/browser`. –¢—Ä–µ–π–ª–µ—Ä—ã YouTube –æ—Ç–∫—Ä—ã–≤–∞—é—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ. |
| ~~**BUG-11**~~ | ~~**–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ —Å –ø—É–ª—å—Ç–∞**~~ | ~~MEDIUM~~ | ‚úÖ **FIXED (2026-01-25):** –ü–µ—Ä–µ–ø–∏—Å–∞–Ω `DiagnosticsPanel` –∫–∞–∫ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–æ–¥–∞–ª —Å Focus Trap. |
| **BUG-FREEZE** | **–ó–∞–≤–∏—Å–∞–Ω–∏–µ My List –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ñ–∏–ª—å–º–∞** | HIGH | **NEW (2026-01-31):** –ü–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ñ–∏–ª—å–º–∞ –∏–∑ –ø–æ–∏—Å–∫–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑, –∑–∞—Ç–µ–º –∑–∞–≤–∏—Å–∞–µ—Ç. –ü—Ä–∏—á–∏–Ω–∞: stale references –≤ SpatialEngine. –ß–∞—Å—Ç–∏—á–Ω–æ —É–ª—É—á—à–µ–Ω–æ —á–µ—Ä–µ–∑ `document.body.contains()` –ø—Ä–æ–≤–µ—Ä–∫—É, –Ω–æ –Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–µ—à–µ–Ω–æ. |

---

## üóìÔ∏è SESSION LOG: 31.01.2026

### üéØ –¶–µ–ª–∏ —Å–µ—Å—Å–∏–∏
1. **–ò—Å–ø—Ä–∞–≤–∏—Ç—å –∑–∞–≤–∏—Å–∞–Ω–∏–µ My List** –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ñ–∏–ª—å–º–∞ –∏–∑ –ø–æ–∏—Å–∫–∞.
2. **–£–ø—Ä–æ—Å—Ç–∏—Ç—å –Ω–∞–≤–∏–≥–∞—Ü–∏—é –≤ –ø–æ–∏—Å–∫–µ** ‚Äî —É–±—Ä–∞—Ç—å –¥–≤–æ–π–Ω—ã–µ focusable —ç–ª–µ–º–µ–Ω—Ç—ã.

### ‚úÖ –ß—Ç–æ –±—ã–ª–æ —Å–¥–µ–ª–∞–Ω–æ

#### 1. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ SpatialEngine (`useSpatialNavigation.js`)
*   –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ `document.body.contains(el)` –≤ –º–µ—Ç–æ–¥—ã `move()` –∏ `recoverFocus()` –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ "–º—ë—Ä—Ç–≤—ã—Ö" —Å—Å—ã–ª–æ–∫ –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω—ã–µ –∏–∑ DOM —ç–ª–µ–º–µ–Ω—Ç—ã.
*   –ü—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏ –∑–æ–Ω—ã (`setActiveZone`) —Ç–µ–ø–µ—Ä—å –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ stale references –∏–∑ –æ–±–µ–∏—Ö –∑–æ–Ω (—Å—Ç–∞—Ä–æ–π –∏ –Ω–æ–≤–æ–π).

#### 2. –£–ø—Ä–æ—â–µ–Ω–∏–µ SearchResultItem (`SearchPanel.jsx`)
*   –£–±—Ä–∞–Ω–∞ –æ—Ç–¥–µ–ª—å–Ω–∞—è –∫–Ω–æ–ø–∫–∞ ¬´‚ûï¬ª (–±—ã–ª–∞ –≤—Ç–æ—Ä—ã–º focusable —ç–ª–µ–º–µ–Ω—Ç–æ–º).
*   –¢–µ–ø–µ—Ä—å –≤—Å—è —Å—Ç—Ä–æ–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ ‚Äî –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π focusable —ç–ª–µ–º–µ–Ω—Ç.
*   –ù–∞–∂–∞—Ç–∏–µ Enter/OK –Ω–∞ —Å—Ç—Ä–æ–∫–µ –¥–æ–±–∞–≤–ª—è–µ—Ç —Ñ–∏–ª—å–º.
*   –ò–∫–æ–Ω–∫–∞ ‚ûï —Ç–µ–ø–µ—Ä—å –ø—Ä–æ—Å—Ç–æ –≤–∏–∑—É–∞–ª—å–Ω–∞—è –ø–æ–¥—Å–∫–∞–∑–∫–∞ (–ø—Ä–∏ —Ñ–æ–∫—É—Å–µ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –∑–µ–ª—ë–Ω–æ–π).

#### 3. –£–ª—É—á—à–µ–Ω–∏–µ addFromSearch (`App.jsx`)
*   –ü—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ñ–∏–ª—å–º–∞ —Ç–µ–ø–µ—Ä—å —Å–Ω–∞—á–∞–ª–∞ –æ—á–∏—â–∞—é—Ç—Å—è `searchResults` –∏ `searchProviders`, —á—Ç–æ–±—ã SearchResultItem –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Ä–∞–∑–º–æ–Ω—Ç–∏—Ä–æ–≤–∞–ª–∏—Å—å –î–û –∑–∞–∫—Ä—ã—Ç–∏—è –ø–∞–Ω–µ–ª–∏.
*   –£–±—Ä–∞–Ω –∫–æ–Ω—Ñ–ª–∏–∫—Ç—É—é—â–∏–π cleanup –∏–∑ `SearchPanel` (–∑–æ–Ω–∞ —Ç–µ–ø–µ—Ä—å —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –∏–∑ `App.jsx`).

### ‚ö†Ô∏è –ù–µ—Ä–µ—à—ë–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã

**BUG-FREEZE** –æ—Å—Ç–∞—ë—Ç—Å—è –æ—Ç–∫—Ä—ã—Ç—ã–º. –ó–∞–≤–∏—Å–∞–Ω–∏–µ —É–º–µ–Ω—å—à–∏–ª–æ—Å—å, –Ω–æ –Ω–µ –∏—Å—á–µ–∑–ª–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é. –¢—Ä–µ–±—É–µ—Ç—Å—è –±–æ–ª–µ–µ –≥–ª—É–±–æ–∫–∏–π –∞–Ω–∞–ª–∏–∑:
*   –í–æ–∑–º–æ–∂–Ω–æ, –ø—Ä–æ–±–ª–µ–º–∞ –≤ polling `fetchStatus()` –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥, –∫–æ—Ç–æ—Ä—ã–π –ø–µ—Ä–µ—Å–æ–∑–¥–∞—ë—Ç Poster –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã.
*   –í–æ–∑–º–æ–∂–Ω–æ, –∫–æ–Ω—Ñ–ª–∏–∫—Ç –º–µ–∂–¥—É React re-render –∏ SpatialEngine registry.
*   –í–æ–∑–º–æ–∂–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ: –ø–µ—Ä–µ—Ö–æ–¥ –Ω–∞ MutationObserver –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è DOM-–∏–∑–º–µ–Ω–µ–Ω–∏–π –≤–º–µ—Å—Ç–æ —Ä—É—á–Ω–æ–π —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.

---

## üóìÔ∏è SESSION LOG: 26.01.2026 (Imported from v3.0.1)

### üéØ –¶–µ–ª–∏ —Å–µ—Å—Å–∏–∏
1. **Backend Fixes**: Kickstart download, Smart Deduplication, Search Providers Fix. (‚úÖ –í–´–ü–û–õ–ù–ï–ù–û)
2. **Frontend Navigation**: –ò—Å–ø—Ä–∞–≤–∏—Ç—å –ø—Ä–æ–±–ª–µ–º—É "–º–µ—Ä—Ç–≤—ã—Ö –∑–æ–Ω" (Search / Magnet / Diagnostics) –¥–ª—è –ø—É–ª—å—Ç–∞. (‚ùå –ù–ï–£–î–ê–ß–ê ‚Üí –†–µ—à–µ–Ω–æ –ø–æ–∑–∂–µ)

### ‚úÖ –ß—Ç–æ –±—ã–ª–æ —Å–¥–µ–ª–∞–Ω–æ (Backend)
–í—Å–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∏–∫—Å—ã –±—ç–∫–µ–Ω–¥–∞ —É—Å–ø–µ—à–Ω–æ –≤–Ω–µ–¥—Ä–µ–Ω—ã:
*   `server/torrent.js`: –î–æ–±–∞–≤–ª–µ–Ω `mainFile.select()` (Kickstart) –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ magnet-—Ö–µ—à–∞ (Deduplication).
*   `server/providers`: –û—Ç–∫–ª—é—á–µ–Ω–∞ —Å–∞–º–æ–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤ –±–µ–∑ Auth.
*   `server/aggregator.js`: –î–æ–±–∞–≤–ª–µ–Ω —Å–±—Ä–æ—Å Circuit Breaker —Ä–∞–∑ –≤ 5 –º–∏–Ω—É—Ç.

### üöß –ë–æ—Ä—å–±–∞ —Å –Ω–∞–≤–∏–≥–∞—Ü–∏–µ–π (–ê—Ä—Ö–∏–≤)
–ë—ã–ª–æ –ø—Ä–µ–¥–ø—Ä–∏–Ω—è—Ç–æ 5 –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ –æ–∂–∏–≤–∏—Ç—å –∫–Ω–æ–ø–∫–∏ Top Bar –¥–ª—è –ø—É–ª—å—Ç–∞:
1. **Smart Focus** ‚Äî –∫–æ–Ω—Ñ–ª–∏–∫—Ç —Å `useEffect`.
2. **Passive Anchor** ‚Äî —Ñ–æ–∫—É—Å –ø–∞–¥–∞–ª –≤ `body`.
3. **Spatial Only** ‚Äî –∫–Ω–æ–ø–∫–∏ –Ω–µ–¥–æ—Å—Ç–∏–∂–∏–º—ã (–≤–Ω–µ —Å–∫—Ä–æ–ª–ª-–∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞).
4. **Section Transitions** ‚Äî –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥.
5. **Master Toolbar** ‚Äî –±–µ–∑—É—Å–ø–µ—à–Ω–æ.

**–ò—Ç–æ–≥:** –ü—Ä–æ–±–ª–µ–º–∞ –±—ã–ª–∞ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–æ–π ‚Äî –∫–æ–Ω—Ñ–ª–∏–∫—Ç React-—Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ –∏ Spatial Graph. –†–µ—à–µ–Ω–∞ –ø–æ–∑–∂–µ —á–µ—Ä–µ–∑ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ `useSpatialNavigation.js` (v3.3+).

### üìã Backlog ‚Äî –£–ª—É—á—à–µ–Ω–∏—è (2026-01-20)

| ID | –û–ø–∏—Å–∞–Ω–∏–µ | –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç | –î–µ—Ç–∞–ª–∏ |
|----|----------|-----------|--------|
| **FEAT-01** | **–†–∞—Å—à–∏—Ä–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —Ñ–∏–ª—å–º–æ–≤ (–∫–∞–∫ –≤ LAMPA)** | MEDIUM | –î–æ–±–∞–≤–∏—Ç—å: –ñ–∞–Ω—Ä—ã, –°—Ç—Ä–∞–Ω—ã, –ì–æ–¥—ã, –°–µ—Ç–∏ (Netflix, HBO), –ü–æ–¥–±–æ—Ä–∫–∏. |

---

## üîß –ß—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–æ—Ä–∞–±–æ—Ç–∞—Ç—å –∏ –∑–∞—á–µ–º (Code Review 2026-01-21)

> –†–µ–∑—É–ª—å—Ç–∞—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–≥–æ –∞—É–¥–∏—Ç–∞. –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã: —Ä–∏—Å–∫ √ó –≤–ª–∏—è–Ω–∏–µ.

### üî¥ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã

| ID | –ü—Ä–æ–±–ª–µ–º–∞ | –†–∏—Å–∫ | –†–µ—à–µ–Ω–∏–µ | –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç |
|----|----------|------|---------|-----------|
| **SEC-01** | TMDB API Key –≤ –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–º bundle (`VITE_TMDB_API_KEY`) | –ö–ª—é—á –º–æ–∂–Ω–æ –∏–∑–≤–ª–µ—á—å –∏–∑ DevTools | –ü–µ—Ä–µ–Ω–µ—Å—Ç–∏ –∑–∞–ø—Ä–æ—Å—ã —á–µ—Ä–µ–∑ `/api/proxy`, –∫–ª—é—á —Ç–æ–ª—å–∫–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ | HIGH |
| **BUG-04** | Modal Focus Loss –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö | –ù–∞ TV –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å "—Ç–µ—Ä—è–µ—Ç—Å—è" | –ó–∞—Ö–≤–∞—Ç—ã–≤–∞—Ç—å `activeElement` –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º | MUST |
| **BUG-11** | DiagnosticsPanel –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ —Å –ø—É–ª—å—Ç–∞ | –ù–µ–ª—å–∑—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ TV | –î–æ–±–∞–≤–∏—Ç—å Focus Trap –∫–∞–∫ –≤ `TorrentModal.jsx` | MEDIUM |

### üü° –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–π –¥–æ–ª–≥

| ID | –ü—Ä–æ–±–ª–µ–º–∞ | –ü–æ—á–µ–º—É –ø–ª–æ—Ö–æ | –†–µ—à–µ–Ω–∏–µ |
|----|----------|--------------|---------|
| **DEBT-01** | `server/index.js` ‚Äî 743 —Å—Ç—Ä–æ–∫–∏ | –°–ª–æ–∂–Ω–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å, merge-–∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã | –î–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏—è: `routes/`, `middleware/` |
| **DEBT-02** | `App.jsx` ‚Äî 867 —Å—Ç—Ä–æ–∫ | –õ–æ–≥–∏–∫–∞ –Ω–µ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è | –í—ã–Ω–µ—Å—Ç–∏ –≤ hooks: `usePlayer`, `useTorrents` |

### üü¢ –£–ª—É—á—à–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–∞

| ID | –ü—Ä–æ–±–ª–µ–º–∞ | –†–µ—à–µ–Ω–∏–µ | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
|----|----------|---------|-----------|
| **QUAL-01** | –ù–µ—Ç E2E —Ç–µ—Å—Ç–æ–≤ –¥–ª—è TV –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ | Playwright + —ç–º—É–ª—è—Ü–∏—è D-pad | Medium |
| **QUAL-02** | Polling —Å—Ç–∞—Ç—É—Å–∞ (5 —Å–µ–∫) –≤–º–µ—Å—Ç–æ push | WebSocket / SSE | Medium |
| **QUAL-03** | localStorage –±–µ–∑ –ª–∏–º–∏—Ç–∞ | IndexedDB + –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ | Low |

### üéØ –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π –ø–æ—Ä—è–¥–æ–∫

```
Sprint 1 (1-2 –¥–Ω—è):  BUG-04, BUG-11, SEC-01
Sprint 2 (3-5 –¥–Ω–µ–π): QUAL-01 (E2E —Ç–µ—Å—Ç—ã)
Sprint 3 (1 –Ω–µ–¥–µ–ª—è): DEBT-01, DEBT-02 (—Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥)
```

---

## üöÄ ROADMAP v4.0: Lampa Architecture Integration (Resurrection)
**Status:** üö¶ PLANNED
**Focus:** –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–∞—è —Å–∏–Ω–≥—É–ª—è—Ä–Ω–æ—Å—Ç—å —Å Lampa. –í–Ω–µ–¥—Ä–µ–Ω–∏–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã—Ö –≥–æ–¥–∞–º–∏ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∏–¥–µ–∞–ª—å–Ω–æ–≥–æ TV-UX.

### üèõÔ∏è Phase 4: Core Lampa Patterns ‚Äî ‚úÖ COMPLETED
**Status:** ‚úÖ ALL SYSTEMS GO (2026-01-21)

#### üß© 4.1. Registry-Based Discovery (Home UI)
**Status:** ‚úÖ DONE
*   **ARC-03:** –°–æ–∑–¥–∞–Ω `ContentRowsRegistry`.
*   **ARC-04:** `HomePanel.jsx` —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω.
*   **FEAT-01:** –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ (Lampa-style) –≤–Ω–µ–¥—Ä–µ–Ω—ã.

#### üéÆ 4.2. Global Spatial Controller (Navigation)
**Status:** ‚úÖ DONE
*   **NAV-01:** `NavigationContext` (useTVNavigation) –ø–µ—Ä–µ–ø–∏—Å–∞–Ω.
*   **NAV-03:** –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å `MutationObserver` (—á–µ—Ä–µ–∑ —Ö—É–∫–∏).

#### üìú 4.3. Transform-Based Scrolling
**Status:** ‚úÖ DONE (Critical Performance Boost)
*   ‚úÖ **UX-10:** –í–Ω–µ–¥—Ä–µ–Ω –¥–≤–∏–∂–æ–∫ `transform: translateX()` –≤–º–µ—Å—Ç–æ `overflow: auto`.
*   ‚úÖ **UX-11:** "Focus Centering" (Apple TV style) ‚Äî –∞–∫—Ç–∏–≤–Ω—ã–π –ø–æ—Å—Ç–µ—Ä –≤—Å–µ–≥–¥–∞ –ø–æ —Ü–µ–Ω—Ç—Ä—É.
*   ‚úÖ **BUG-10:** –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ –∑–∞–≤–∏—Å–∞–Ω–∏–µ —Å–∫—Ä–æ–ª–ª–∞ (—É–±—Ä–∞–Ω—ã –∫–æ–Ω—Ñ–ª–∏–∫—Ç—É—é—â–∏–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏).

#### üåê 4.4. Deep Integration & New Features (v4.1 preview)
**Status:** ‚úÖ DONE
*   ‚úÖ **FEAT-02: Infinite Scroll.** –ë–µ—Å–∫–æ–Ω–µ—á–Ω–∞—è –ø–æ–¥–≥—Ä—É–∑–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü –≤ `CategoryPage.jsx` (IntersectionObserver).
*   ‚úÖ **FEAT-03: Season Selector.** `MovieDetail.jsx` —Ç–µ–ø–µ—Ä—å –≤—ã–≤–æ–¥–∏—Ç —Å–µ–∑–æ–Ω—ã —Å –æ—Ç–¥–µ–ª—å–Ω—ã–º –ø–æ–∏—Å–∫–æ–º.
*   ‚úÖ **PLAYER-01: Deep Integration.** `TVPlayer.java` + `App.jsx`. Two-way communication.
    *   Auto-Play Next Episode (–∞–≤—Ç–æ-–ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ).
    *   Resume Position Saving (—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞).
*   ‚úÖ **BUG-11: YouTube Freeze.** –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ —á–µ—Ä–µ–∑ `@capacitor/browser`.

#### üåê 4.4. Unified Proxy Gateway
**–¶–µ–ª—å:** –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≥–∏–±–∫–æ—Å—Ç—å API.
*   **API-01:** –≠–Ω–¥–ø–æ–∏–Ω—Ç `/api/proxy?url=...` (URL Encapsulation).
*   **API-02:** –ú–∏–≥—Ä–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–∫—Å–∏ (Lampa Pattern).

---

### üõ†Ô∏è Technical Specifications (For AI Context)

#### 1. Memory Leak Fix (BUG-02) ‚Äî ‚úÖ ALREADY IMPLEMENTED
**Problem:** `setInterval` creates duplicates on hot-reload or restart logic.
**Current implementation in `server/torrent.js`:**
```javascript
let frozenCleanupIntervalId = null; // Line 32

function startFrozenCleanup() {
    if (frozenCleanupIntervalId) return; // Line 36 - PROTECTION EXISTS!
    frozenCleanupIntervalId = setInterval(() => { ... }, FROZEN_TTL);
}
---

## üó∫Ô∏è ROADMAP v3.1: Operation "Unstoppable" (Post-Mortem & Status)
**Version:** 3.1 (Legacy)
**Status:** üèÅ ARCHIVED (–ü–µ—Ä–µ—Ö–æ–¥ –∫ v3.2)
**Outcome:** –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ–∏—á–∏ –≤–Ω–µ–¥—Ä–µ–Ω—ã, –Ω–æ –∞—É–¥–∏—Ç –≤—ã—è–≤–∏–ª –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã –∏ "–º–µ—Ä—Ç–≤—ã–π –∫–æ–¥".

| ID | Task Name | Status | Notes |
|---|---|---|---|
| FIX-01a | 1D List Navigation | ‚úÖ DONE | –ë–∞–∑–æ–≤–∞—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç. |
| FIX-01b | 2D Grid Navigation | ‚úÖ DONE | Grid —Ä–∞–±–æ—Ç–∞–µ—Ç. |
| FIX-01c | Modal Focus Trap | ‚úÖ DONE | **Audit 2025-01-20:** –ö–æ–¥ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω –≤ `TorrentModal.jsx`. `e.stopPropagation()` + `previouslyFocusedRef` —Ä–∞–±–æ—Ç–∞—é—Ç. |
| ARC-01 | Server DoH Rotation | ‚úÖ DONE | –†–∞–±–æ—Ç–∞–µ—Ç —Å—Ç–∞–±–∏–ª—å–Ω–æ. |
| ARC-02 | Client Waterfall | ‚úÖ DONE | **Audit 2025-01-20:** `resolveClientIP()` –∞–∫—Ç–∏–≤–µ–Ω –¥–ª—è APK. –ü—Ä–æ–±—Ä–æ—Å `Host` header —Ä–∞–±–æ—Ç–∞–µ—Ç. |
| UX-01 | Search Performance | ‚úÖ DONE | Debounce –≤–Ω–µ–¥—Ä–µ–Ω. |
| OPT-01 | List Virtualization | ‚õî FROZEN | **Audit 2025-01-20:** –í—ã—Å–æ–∫–∏–π —Ä–∏—Å–∫ –¥–ª—è TV-–Ω–∞–≤–∏–≥–∞—Ü–∏–∏. –ü–µ—Ä–µ–Ω–µ—Å–µ–Ω–æ –≤ Phase 3. |

---

## üìå DUPLICATE SECTION REMOVED
> *–≠—Ç–æ—Ç —Ä–∞–∑–¥–µ–ª –±—ã–ª –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω. –ê–∫—Ç—É–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è v3.2 –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤—ã—à–µ (—Å—Ç—Ä–æ–∫–∏ 447+).*
> *–£–¥–∞–ª–µ–Ω–æ –¥–ª—è –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞.*

---

## üîÆ ROADMAP v5.0: Future Development (2026+)
**Status:** üö¶ PLANNED
**Focus:** –¢–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ —Å–æ–≤–µ—Ä—à–µ–Ω—Å—Ç–≤–æ–≤–∞–Ω–∏–µ, –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å, –∫–∞—á–µ—Å—Ç–≤–æ –∫–æ–¥–∞.

> –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ code review –æ—Ç 2026-01-21.

---

### üì¶ Phase 5.1: Code Quality & DX (Developer Experience)
**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** HIGH | **–°–ª–æ–∂–Ω–æ—Å—Ç—å:** Medium

| ID | –ó–∞–¥–∞—á–∞ | –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç | –°–ª–æ–∂–Ω–æ—Å—Ç—å | –û–ø–∏—Å–∞–Ω–∏–µ |
|----|--------|-----------|-----------|----------|
| **DX-01** | **TypeScript Migration** | HIGH | High | –ü–æ—Å—Ç–µ–ø–µ–Ω–Ω–∞—è –º–∏–≥—Ä–∞—Ü–∏—è –Ω–∞ TypeScript. –ù–∞—á–∞—Ç—å —Å `utils/` –∏ `providers/`. –î–æ–±–∞–≤–∏—Ç—å `.d.ts` —Ñ–∞–π–ª—ã –¥–ª—è —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∫–æ–¥–∞. |
| **DX-02** | **–î–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏—è App.jsx** | HIGH | Medium | –í—ã–Ω–µ—Å—Ç–∏ –ª–æ–≥–∏–∫—É –≤ custom hooks: `usePlayer`, `useSearch`, `useTorrents`, `useSettings`. –¶–µ–ª—å: < 300 —Å—Ç—Ä–æ–∫. |
| **DX-03** | **–î–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏—è server/index.js** | MEDIUM | Medium | –í—ã–¥–µ–ª–∏—Ç—å routes: `/routes/search.js`, `/routes/torrents.js`, `/routes/tmdb.js`. |
| **DX-04** | **ESLint + Prettier Config** | LOW | Low | –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ. –î–æ–±–∞–≤–∏—Ç—å pre-commit hooks (husky + lint-staged). |

---

### üì¶ Phase 5.2: Data Layer Modernization
**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** MEDIUM | **–°–ª–æ–∂–Ω–æ—Å—Ç—å:** Medium

| ID | –ó–∞–¥–∞—á–∞ | –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç | –°–ª–æ–∂–Ω–æ—Å—Ç—å | –û–ø–∏—Å–∞–Ω–∏–µ |
|----|--------|-----------|-----------|----------|
| **DATA-01** | **React Query / TanStack Query** | HIGH | Medium | –ó–∞–º–µ–Ω–∏—Ç—å —Ä—É—á–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º –Ω–∞ React Query. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ, retry, stale-while-revalidate. |
| **DATA-02** | **WebSocket –¥–ª—è Real-time** | MEDIUM | Medium | –ó–∞–º–µ–Ω–∏—Ç—å polling `/api/status` –Ω–∞ WebSocket. Instant updates –¥–ª—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤. |
| **DATA-03** | **IndexedDB –¥–ª—è Metadata** | LOW | Low | –ü–µ—Ä–µ–Ω–µ—Å—Ç–∏ –∫—ç—à –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –∏–∑ localStorage –≤ IndexedDB. –ë–æ–ª—å—à–µ –º–µ—Å—Ç–∞, async API. |

---

### üì¶ Phase 5.3: Testing & Reliability
**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** HIGH | **–°–ª–æ–∂–Ω–æ—Å—Ç—å:** Medium

| ID | –ó–∞–¥–∞—á–∞ | –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç | –°–ª–æ–∂–Ω–æ—Å—Ç—å | –û–ø–∏—Å–∞–Ω–∏–µ |
|----|--------|-----------|-----------|----------|
| **TEST-03** | **E2E Tests (Playwright)** | HIGH | Medium | –ö—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è TV UX. –¢–µ—Å—Ç—ã: –Ω–∞–≤–∏–≥–∞—Ü–∏—è D-pad, Focus Trap, –ø–æ–∏—Å–∫, –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ. |
| **TEST-04** | **Integration Tests (Providers)** | MEDIUM | Medium | –ú–æ–∫-—Å–µ—Ä–≤–µ—Ä –¥–ª—è Jacred/RuTracker. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–∞—Ä—Å–∏–Ω–≥ –∏ –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—é. |
| **TEST-05** | **Snapshot Tests (Components)** | LOW | Low | Vitest + @testing-library/react. –ó–∞—â–∏—Ç–∞ –æ—Ç —Ä–µ–≥—Ä–µ—Å—Å–∏–π UI. |
| **TEST-06** | **Load Testing** | LOW | Medium | –¢–µ—Å—Ç –Ω–∞ 50+ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç–æ—Ä—Ä–µ–Ω—Ç–æ–≤. –í—ã—è–≤–∏—Ç—å memory leaks –∏ CPU bottlenecks. |

---

### üì¶ Phase 5.4: PWA & Offline
**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** MEDIUM | **–°–ª–æ–∂–Ω–æ—Å—Ç—å:** High

| ID | –ó–∞–¥–∞—á–∞ | –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç | –°–ª–æ–∂–Ω–æ—Å—Ç—å | –û–ø–∏—Å–∞–Ω–∏–µ |
|----|--------|-----------|-----------|----------|
| **PWA-01** | **Service Worker** | MEDIUM | High | –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç–∏–∫–∏ –∏ API –æ—Ç–≤–µ—Ç–æ–≤. Workbox integration. |
| **PWA-02** | **Offline Catalog** | LOW | High | –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ–∏–ª—å–º—ã/—Å–µ—Ä–∏–∞–ª—ã –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ —Å–µ—Ç–∏. |
| **PWA-03** | **Background Sync** | LOW | Medium | –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ/history —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç—Å—è –ø—Ä–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å–µ—Ç–∏. |

---

### üì¶ Phase 5.5: Advanced Features
**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** LOW | **–°–ª–æ–∂–Ω–æ—Å—Ç—å:** High

| ID | –ó–∞–¥–∞—á–∞ | –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç | –°–ª–æ–∂–Ω–æ—Å—Ç—å | –û–ø–∏—Å–∞–Ω–∏–µ |
|----|--------|-----------|-----------|----------|
| **FEAT-10** | **User Profiles** | LOW | High | –ù–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–æ—Ñ–∏–ª–µ–π —Å –æ—Ç–¥–µ–ª—å–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ –∏ –∏—Å—Ç–æ—Ä–∏–µ–π –ø—Ä–æ—Å–º–æ—Ç—Ä–∞. |
| **FEAT-11** | **Trakt.tv Integration** | LOW | Medium | Sync watch history —Å Trakt.tv. Scrobbling. |
| **FEAT-12** | **Subtitles Search** | MEDIUM | Medium | OpenSubtitles API. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ —Å—É–±—Ç–∏—Ç—Ä–æ–≤ –ø–æ IMDB ID. |
| **FEAT-13** | **Smart Recommendations** | LOW | High | ML-based recommendations –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏—Å—Ç–æ—Ä–∏–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞. |

---

### üéØ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Q1 2026: DX-01 (TypeScript), DX-02 (App.jsx), TEST-03 (E2E) ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Q2 2026: DATA-01 (React Query), DATA-02 (WebSocket)         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Q3 2026: PWA-01 (Service Worker), FEAT-12 (Subtitles)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Q4 2026: FEAT-11 (Trakt.tv), Polish & Stabilization         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```
## üöÄ ROADMAP v3.3: TMDB Rehab & TV Core (Active)
**Status:** üö¶ READY FOR DEV
**Focus:** Fix TV Navigation Graph, Rehabilitate TMDB as a Graph, Stabilize Android Player Lifecycle.

> **Context:**  
> The previous "Discovery" phase is paused. We are focusing on making the **Content Detail** experience (especially for Series) and **Player Experience** rock solid on TV.

### ÔøΩ Batch 1: TV Core & Navigation (The Series Card)
*Fixing the broken focus graph and navigation flow.*

| ID | Task Name | Priority | Complexity | Description |
|---|---|---|---|---|
| **TV-01** | **Series Card Focus Graph** | ‚úÖ DONE | High | **Fix D-Pad Trap.** Implement a strict focus graph: `Header <-> Seasons <-> Episodes <-> Actions`. Prevent focus loss when moving Up/Down between zones. |
| **TV-02** | **Focus Visuals Fix** | ‚úÖ DONE | Low | **Fix Clipped Rings.** Update CSS for Season cards to prevent focus outline clipping (`box-shadow` instead of outline, padding adjustments). |
| **UX-12** | **Season Detail View** | ‚úÖ DONE | Mid | **Logic Change.** Clicking a Season should NOT trigger Search. It must open a `Season Detail` view (list of episodes). Search triggers only on specific episode selection or "Play" button. |
| **UX-13** | **Smart Query Generation** | ‚úÖ DONE | Low | **S02 vs Season 2.** Normalize search queries. Use `Name S02` or `Name S02E03` format for better tracker matching. Remove "Season X" wordy format. |

### ÔøΩ Batch 2: Android Lifecycle (Intent Fixes)
*Stabilizing the external player launch experience.*

| ID | Task Name | Priority | Complexity | Description |
|---|---|---|---|---|
| **AND-01** | **Intent Lifecycle Fix** | ‚úÖ DONE | High | **Stop Double Chooser.** Prevent `chooser` from reappearing after playback. Add `FLAG_ACTIVITY_SINGLE_TOP` / `CLEAR_TOP`. Ensure `onResume` doesn't re-trigger intent. |
| **AND-02** | **Player Preference Verification** | SHOULD | Low | **Verify Persistence.** Ensure "Default Player" setting in `SettingsPanel` is actually respected by the `TVPlayer` plugin intent logic. |
| **AND-03** | **Double Player Launch Guard** | ‚úÖ PARTIAL | Mid | **Race Condition.** Prevent double launch of player due to multiple rapid clicks or rapid state updates. Temporary `isPlaying` guard implemented. Needs more robust lifecycle handling. |

### ÔøΩ Batch 3: TMDB Content Graph (Rehab)
*Turning TMDB from a static data source into a navigable graph.*

| ID | Task Name | Priority | Complexity | Description |
|---|---|---|---|---|
| **TMDB-01** | **Recommendations & Similar** | ‚úÖ DONE | Mid | **Linked Content.** Show "Similar Movies" row in `MovieDetail`. Clicking navigates to new Movie Card (Recursion supported). |
| **TMDB-02** | **Actor Filmography** | ‚úÖ DONE | High | **Person Graph.** Click on Actor -> Show `PersonDetail` (Bio + Filmography Grid). |
| **TMDB-03** | **Clickable Genres** | ‚úÖ DONE | Low | **Genre Discovery.** Click on Genre badge -> Go to Category View filtered by that genre. |
| **TMDB-04** | **Unified Graph Nav** | ‚úÖ DONE | High | **Architecture.** Ensure `Movie -> Actor -> Movie -> Genre -> Movie` flow works without breaking the Back Stack or Focus. |

### üìâ Backlog (De-prioritized)
* **Secondary Metadata Cache:** (SHOULD) Cache filmography/recommendations.
* **Episode Metadata:** (SHOULD) Fetch episode names/descriptions.
* **Discovery Home:** (POSTPONED) Focus on Detail View first.

---

### ‚úÖ Batch 2026-01-23: Discovery & UX Refinement
*   ‚úÖ **UX-14: Infinite Discovery.** –ü–∞–≥–∏–Ω–∞—Ü–∏—è –≤ `CategoryPage.jsx` —Å—Ç–∞–ª–∞ "–±–µ—Å—à–æ–≤–Ω–æ–π" (rootMargin: 500px).
*   ‚úÖ **UX-15: Main Page Load Opt.** –†—è–¥—ã –Ω–∞ –≥–ª–∞–≤–Ω–æ–π –æ–≥—Ä–∞–Ω–∏—á–µ–Ω—ã 20 —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.
*   ‚úÖ **UX-16: Stealth Background.** –£–±—Ä–∞–Ω –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π backdrop (—Ñ–∏–∫—Å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ—Å—Ç–µ—Ä–æ–≤).
*   ‚úÖ **UX-17: Season Poster Recovery.** –ö–∞—Å–∫–∞–¥–Ω—ã–π fallback –¥–ª—è —Å–µ–∑–æ–Ω–æ–≤ (Season -> Series -> Emoji).
### ‚úÖ Batch 2026-01-24: Critical Fixes & UI Polish (v2.9.9)
*   ‚úÖ **FIX-02: Mixed Content & Images** (v2.9.5+). –í–Ω–µ–¥—Ä–µ–Ω `wsrv.nl` + `ssl:` –ø—Ä–µ—Ñ–∏–∫—Å –¥–ª—è –≤—Å–µ—Ö –ø–æ—Å—Ç–µ—Ä–æ–≤. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞—Ä—Ç–∏–Ω–æ–∫ –Ω–∞ Android TV (APK).
*   ‚úÖ **FIX-03: Discovery Logic Sync** (v2.9.6). –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–∞ –Ω–∞ —Å—Ç–∞–±–∏–ª—å–Ω—ã–µ —Ä–µ–ª—å—Å—ã `Poster.jsx` (AbortController, Error Handling).
*   ‚úÖ **UX-18: Sidebar UI Overhaul** (v2.9.9). –£–¥–∞–ª–µ–Ω–∞ —Å–∫—Ä—ã—Ç–∞—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è —Å—Ç—Ä–µ–ª–∫–∞–º–∏.
    *   –î–æ–±–∞–≤–ª–µ–Ω–∞ –∫–Ω–æ–ø–∫–∞ **–ú–µ–Ω—é (‚ò∞)** –Ω–∞ –≥–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω.
    *   –î–æ–±–∞–≤–ª–µ–Ω–∞ –∫–Ω–æ–ø–∫–∞ **–ó–∞–∫—Ä—ã—Ç—å (‚ùå)** –≤–Ω—É—Ç—Ä—å –º–µ–Ω—é.
*   ‚úÖ **UX-19: Sidebar Overlay** (v2.9.4). –°–∞–π–¥–±–∞—Ä —Ç–µ–ø–µ—Ä—å —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ –æ–≤–µ—Ä–ª–µ–π –∏ –Ω–µ —Å–¥–≤–∏–≥–∞–µ—Ç –∫–æ–Ω—Ç–µ–Ω—Ç.
*   ‚úÖ **FIX-04: Critical Import Fix** (v2.9.7). –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ —Ä–µ–≥—Ä–µ—Å—Å–∏—è —Å –ø—É—Å—Ç—ã–º —ç–∫—Ä–∞–Ω–æ–º (discover.js).

### ‚úÖ Batch 2026-01-25: UI Polish & Search Rescue (Operation "Shield")
*   ‚úÖ **UX-20: Settings Redesign.** `SettingsPanel` –∏ `DiagnosticsPanel` –ø–µ—Ä–µ–ø–∏—Å–∞–Ω—ã –∫–∞–∫ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã `z-index` –∏ —Ñ–æ–∫—É—Å–∞.
*   ‚úÖ **FIX-05: Diagnostics Restoration.** –í–æ–∑–≤—Ä–∞—â–µ–Ω–∞ –ø–æ–ª–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ (RAM, Uptime, Torrents) –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ–∫—Å–∏ (Server/Capacitor/WSRV).
*   ‚úÖ **FIX-06: Search Provider Rescue.** –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Ä–µ–º–æ–Ω—Ç –º–µ—Ö–∞–Ω–∏–∑–º–∞ –ø–æ–∏—Å–∫–∞:
    *   **RuTracker:** –ü–µ—Ä–µ–≤–µ–¥–µ–Ω –Ω–∞ `smartFetch` (DoH + SNI). –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ –∫—É–∫–∏ —Å –æ–±—Ö–æ–¥–æ–º –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫.
    *   **Rutor:** –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π HTTPS (SNI Spoofing). –î–æ–±–∞–≤–ª–µ–Ω—ã `Accept`/`Cache-Control` –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è –º–∏–º–∏–∫—Ä–∏–∏ –ø–æ–¥ –±—Ä–∞—É–∑–µ—Ä.
    *   **TorLook:** –í–Ω–µ–¥—Ä–µ–Ω `smartFetch` —Å —É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–º —Ç–∞–π–º–∞—É—Ç–æ–º (45s).
    *   **Network Core:** –£–≤–µ–ª–∏—á–µ–Ω—ã —Ç–∞–π–º–∞—É—Ç—ã DoH Race (5s) –∏ Socket (30-45s) –¥–ª—è —Ä–∞–±–æ—Ç—ã —á–µ—Ä–µ–∑ –º–µ–¥–ª–µ–Ω–Ω—ã–µ VPN/DPI –∫–∞–Ω–∞–ª—ã.

üéØ –¶–µ–ª—å –¥–æ—Ä–∞–±–æ—Ç–∫–∏ (Context & Intent)

–≠—Ç–æ—Ç –±–ª–æ–∫ –∑–∞–¥–∞—á –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω –Ω–µ –Ω–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö —Ñ–∏—á, –∞ –Ω–∞ —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–π –Ω–µ–æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ—Å—Ç–∏ –≤ –∫–ª–∏–µ–Ω—Ç–µ –∏ –¥–æ–≤–µ–¥–µ–Ω–∏–µ –µ–≥–æ –¥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è production-ready –¥–ª—è Android TV / PWA.

–ö–ª—é—á–µ–≤–∞—è –ø—Ä–æ–±–ª–µ–º–∞, –∫–æ—Ç–æ—Ä—É—é –º—ã —Ä–µ—à–∞–µ–º

–¢–µ–∫—É—â–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏ –æ–ø–∏—Ä–∞–ª–∞—Å—å –Ω–∞:

—ç–≤—Ä–∏—Å—Ç–∏–∫–∏ (—É–≥–∞–¥—ã–≤–∞–Ω–∏–µ —Ç–∏–ø–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é),

–Ω–µ—è–≤–Ω—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ (torrent.name ‚Üí metadata),

—Ä–∞–∑–º—ã—Ç—É—é –Ω–∞–≤–∏–≥–∞—Ü–∏—é (–Ω–µ—Å–∫–æ–ª—å–∫–æ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ñ–æ–∫—É—Å–æ–º).

–≠—Ç–æ –ø—Ä–∏–≤–æ–¥–∏–ª–æ –∫:

–ø–æ—Ç–µ—Ä—è–Ω–Ω—ã–º –∏–ª–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º (–æ—Å–æ–±–µ–Ω–Ω–æ –¥–ª—è —Å–µ—Ä–∏–∞–ª–æ–≤ –∏ —Å–µ–∑–æ–Ω–æ–≤),

–Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ–π TV-–Ω–∞–≤–∏–≥–∞—Ü–∏–∏,

—Ä–µ–≥—Ä–µ—Å—Å–∏—è–º –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –Ω–æ–≤—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –¥–∞–Ω–Ω—ã—Ö (TMDB / –ö–∏–Ω–æ–ø–æ–∏—Å–∫).

–¶–µ–ª—å –∏–∑–º–µ–Ω–µ–Ω–∏–π

–ü–µ—Ä–µ–≤–µ—Å—Ç–∏ –∫–ª–∏–µ–Ω—Ç –∏–∑ —Ä–µ–∂–∏–º–∞ ‚Äú—É–≥–∞–¥—ã–≤–∞–Ω–∏—è‚Äù –≤ —Ä–µ–∂–∏–º —Å—Ç—Ä–æ–≥–∏—Ö –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤, –≥–¥–µ:

–ò–¥–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç–∞ —Ñ–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–∞

–ö–∞–∂–¥—ã–π –æ–±—ä–µ–∫—Ç –∑–Ω–∞–µ—Ç:

—Å–≤–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫ (tmdb | kinopoisk)

—Å–≤–æ–π —Ç–∏–ø (movie | tv)

—Å–≤–æ–π —Å—Ç–∞–±–∏–ª—å–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä (tmdbId, –µ—Å–ª–∏ –ø—Ä–∏–º–µ–Ω–∏–º–æ)

–ó–∞–ø—Ä–æ—Å—ã –∫ –≤–Ω–µ—à–Ω–∏–º API –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –≤–∞–ª–∏–¥–Ω–æ–π –∏–¥–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç–∏.

–ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Å–µ—Ä–∏–∞–ª–æ–≤ –æ–±–æ–≥–∞—â–∞—é—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ

–ü–æ—Å—Ç–µ—Ä—ã —Å–µ–∑–æ–Ω–æ–≤ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –ª–µ–Ω–∏–≤–æ, —Ç–æ–ª—å–∫–æ –Ω–∞ —ç–∫—Ä–∞–Ω–µ –¥–µ—Ç–∞–ª–µ–π.

–ù–µ—Ç –ª–∏—à–Ω–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤, –Ω–µ—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ UI, –µ—Å—Ç—å –≤–∏–∑—É–∞–ª—å–Ω—ã–µ fallback‚Äô–∏.

TMDB –∏ –ö–∏–Ω–æ–ø–æ–∏—Å–∫ –∂—ë—Å—Ç–∫–æ —Ä–∞–∑–¥–µ–ª–µ–Ω—ã –∫–∞–∫ –¥–æ–º–µ–Ω—ã –¥–∞–Ω–Ω—ã—Ö.

–ù–∞–≤–∏–≥–∞—Ü–∏—è –Ω–∞ TV —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–π

–í–≤–æ–¥–∏—Ç—Å—è –µ–¥–∏–Ω–∞—è –º–æ–¥–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è (activeArea).

Sidebar –ø–µ—Ä–µ—Å—Ç–∞—ë—Ç –±—ã—Ç—å —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω—ã–º –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã–º —É–∑–ª–æ–º.

–ü–æ–≤–µ–¥–µ–Ω–∏–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–º –ø–∞—Ç—Ç–µ—Ä–Ω–∞–º (NUM / Lampa):

–ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º—ã–π Back,

–æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ ‚Äú–ø—Ä—ã–∂–∫–æ–≤‚Äù —Ñ–æ–∫—É—Å–∞,

–∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º—ã–µ –ø–µ—Ä–µ—Ö–æ–¥—ã –º–µ–∂–¥—É –æ–±–ª–∞—Å—Ç—è–º–∏ UI.

–ß–µ–≥–æ –Ω–µ –Ω—É–∂–Ω–æ –¥–µ–ª–∞—Ç—å

‚ùå –ù–µ –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤—ã–µ API –∏–ª–∏ backend-—ç–Ω–¥–ø–æ–∏–Ω—Ç—ã.

‚ùå –ù–µ —É—Å–ª–æ–∂–Ω—è—Ç—å tmdbClient.js —Å–≤–µ—Ä—Ö —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∫–∞—Å–∫–∞–¥–∞.

‚ùå –ù–µ –≤–Ω–µ–¥—Ä—è—Ç—å –Ω–æ–≤—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –∏–ª–∏ state-–º–µ–Ω–µ–¥–∂–µ—Ä—ã.

‚ùå –ù–µ ‚Äú—á–∏–Ω–∏—Ç—å‚Äù UI –∑–∞ —Å—á—ë—Ç —Ç–∞–π–º–∞—É—Ç–æ–≤ –∏ –∫–æ—Å—Ç—ã–ª–µ–π.

–ö—Ä–∏—Ç–µ—Ä–∏–π —É—Å–ø–µ—à–Ω–æ–≥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è

–†–∞–±–æ—Ç–∞ —Å—á–∏—Ç–∞–µ—Ç—Å—è –∑–∞–≤–µ—Ä—à—ë–Ω–Ω–æ–π, –µ—Å–ª–∏:

–ö–ª–∏–µ–Ω—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Ä–∞–∑–ª–∏—á–∞–µ—Ç —Ñ–∏–ª—å–º—ã, —Å–µ—Ä–∏–∞–ª—ã –∏ —Å–µ–∑–æ–Ω—ã –±–µ–∑ —ç–≤—Ä–∏—Å—Ç–∏–∫.

–ü–æ—Å—Ç–µ—Ä—ã —Å–µ–∑–æ–Ω–æ–≤ —Å—Ç–∞–±–∏–ª—å–Ω–æ –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –¥–∞–Ω–Ω—ã—Ö –∏ gracefully –¥–µ–≥—Ä–∞–¥–∏—Ä—É—é—Ç –ø—Ä–∏ –∏—Ö –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏.

Sidebar –∏ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–Ω—Ç –±–æ–ª—å—à–µ –Ω–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç—É—é—Ç –∑–∞ —Ñ–æ–∫—É—Å.

–ü–æ–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –Ω–∞ TV –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–æ –∏ –ø–æ–≤—Ç–æ—Ä—è–µ–º–æ.

–í–∞–∂–Ω–æ:
–≠—Ç–æ—Ç –±–ª–æ–∫ ‚Äî –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–∞—è —Å—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏—è.
–õ—é–±—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è, –≤—ã—Ö–æ–¥—è—â–∏–µ –∑–∞ —ç—Ç–∏ —Ä–∞–º–∫–∏, –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —è–≤–Ω–æ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω—ã.

–§–∏–Ω–∞–ª—å–Ω—ã–π implementation checklist (Production Ready)
–≠–¢–ê–ü 1. –ò–¥–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç–∞

Data Layer. Blocker.

Poster.jsx
TMDB-–≤–µ—Ç–∫–∞

–í –º–µ—Å—Ç–µ, –≥–¥–µ –Ω–∞–π–¥–µ–Ω result –∏–∑ TMDB:

saveMetadata(cleanedName, {
  tmdbId: result.id,
  mediaType: result.media_type, // 'tv' | 'movie'
  source: 'tmdb',
  poster: directUrl,
  backdrop: backdropUrl,
  overview: result.overview || null,
  rating: result.vote_average || null,
  year: ...,
  title: ...
})

Kinopoisk-–≤–µ—Ç–∫–∞
saveMetadata(cleanedName, {
  tmdbId: null,
  mediaType: kpData?.type === 'TV_SERIES' ? 'tv' : 'movie',
  source: 'kinopoisk',
  poster: kpUrl,
  backdrop: null,
  overview: ...,
  rating: ...,
  year: ...,
  title: ...
})


–ò–Ω–≤–∞—Ä–∏–∞–Ω—Ç:

tmdbId !== null —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ source === 'tmdb'

–Ω–∏–∫–∞–∫–∏—Ö ¬´—É–≥–∞–¥—ã–≤–∞–Ω–∏–π¬ª –¥–∞–ª—å—à–µ –ø–æ –∫–æ–¥—É

–≠–¢–ê–ü 2. –ü–æ—Å—Ç–µ—Ä—ã —Å–µ–∑–æ–Ω–æ–≤
**Status:** ‚úÖ COMPLETED (v2.9.9)

Enrichment Layer. Lazy. Detail-only.

TorrentModal.jsx
2.1 –ß—Ç–µ–Ω–∏–µ metadata —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç race condition
let meta = getMetadata(cleanTitle(torrent.name))

if (!meta?.tmdbId) {
  try {
    meta = JSON.parse(
      localStorage.getItem(`metadata_v1_${cleanTitle(torrent.name)}`)
    )
  } catch {}
}

setMetadata(meta)


–û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –ø—Ä–µ–¥–æ—Ö—Ä–∞–Ω–∏—Ç–µ–ª—å. –ë–µ–∑ –Ω–µ–≥–æ –±—É–¥—É—Ç ¬´–ø—Ä–∏–∑—Ä–∞–∫–∏¬ª.

2.2 Lazy-–∑–∞–≥—Ä—É–∑–∫–∞ —Å–µ–∑–æ–Ω–æ–≤
useEffect(() => {
  if (
    !metadata?.tmdbId ||
    metadata?.mediaType !== 'tv' ||
    metadata?.source !== 'tmdb'
  ) return

  const cached = getSeasons(metadata.tmdbId)
  if (cached) return

  getDetails(metadata.tmdbId, 'tv').then(data => {
    if (data?.seasons?.length) {
      saveSeasons(metadata.tmdbId, data.seasons)
    }
  })
}, [metadata?.tmdbId])


–ù–∏–∫–∞–∫–∏—Ö –¥—Ä—É–≥–∏—Ö –º–µ—Å—Ç.
–ù–∏–∫–∞–∫–∏—Ö –ø–æ–≤—Ç–æ—Ä–æ–≤.
–ù–∏–∫–∞–∫–∏—Ö fetch‚Äô–µ–π ¬´–Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π¬ª.

2.3 –†–µ–Ω–¥–µ—Ä –ø–æ—Å—Ç–µ—Ä–æ–≤ —Å–µ–∑–æ–Ω–æ–≤
const posterUrl = season.poster_path
  ? getImageUrl(season.poster_path, 'w342')
  : metadata.poster


UI –ø—Ä–∞–≤–∏–ª–æ:

–Ω–µ—Ç –ø–æ—Å—Ç–µ—Ä–∞ ‚Üí fallback

–Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –∂–¥–∞—Ç—å

–Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–Ω–¥–µ—Ä

–≠–¢–ê–ü 3. Sidebar / NUM-–º–æ–¥–µ–ª—å

Navigation Layer. –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–∞—Ü–∏—è –≤–ª–∞—Å—Ç–∏.

3.1 Sidebar.jsx ‚Äî –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ —É–ø—Ä–æ—â–µ–Ω–∏–µ

–£–¥–∞–ª–∏—Ç—å:

useTVNavigation

–æ–±—Ä–∞–±–æ—Ç–∫—É –∫–ª–∞–≤–∏—à

–≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ useEffect –Ω–∞–≤–∏–≥–∞—Ü–∏–∏

–û—Å—Ç–∞–≤–∏—Ç—å —Ç–æ–ª—å–∫–æ:

props:
- items
- focusedIndex
- isExpanded
- onSelect(index)


CSS:

isExpanded ? w-64 : w-20

–Ω–∏–∫–∞–∫–∏—Ö side-effect‚Äô–æ–≤

Sidebar —Ç–µ–ø–µ—Ä—å —Ç—É–ø–æ–π. –ò –∏–º–µ–Ω–Ω–æ –ø–æ—ç—Ç–æ–º—É –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π.

3.2 HomePanel.jsx ‚Äî –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä
const [activeArea, setActiveArea] = useState('content')
// 'sidebar' | 'content' | 'overlay'

handleKeyDown (—Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Å–º—ã—Å–ª)
if (activeArea === 'sidebar') {
  // Up / Down ‚Üí focusedIndex
  // Right ‚Üí setActiveArea('content')
  // Back ‚Üí collapse or exit
  return
}

if (activeArea === 'content') {
  // Grid navigation
  // Left –Ω–∞ –∫—Ä–∞–π–Ω–µ–º —ç–ª–µ–º–µ–Ω—Ç–µ ‚Üí setActiveArea('sidebar')
  return
}

if (activeArea === 'overlay') {
  return // –º–æ–¥–∞–ª–∫–∏ —Å–∞–º–∏
}

NUM-–ø–æ–≤–µ–¥–µ–Ω–∏–µ (–∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–æ –∫–∞–∫ –ø—Ä–∞–≤–∏–ª–æ)

Sidebar –º–æ–∂–µ—Ç –±—ã—Ç—å collapsed, –Ω–æ –≤–∏–¥–∏–º

–ö–æ–Ω—Ç–µ–Ω—Ç –Ω–µ —Å–∫—Ä–æ–ª–ª–∏—Ç—Å—è, –µ—Å–ª–∏ –∞–∫—Ç–∏–≤–µ–Ω sidebar

Back:

sidebar expanded ‚Üí sidebar collapsed

sidebar collapsed ‚Üí content

–§–æ–∫—É—Å –≤—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π –∞–∫—Ç–∏–≤–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç, –Ω–µ –≤ –Ω–∞—á–∞–ª–æ
```

---

## server/__tests__/logger.test.js

```javascript
/**
 * Logger Module Tests
 * Tests for server/utils/logger.js
 */

import { test, expect } from './test-runner.js'

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Logger Tests
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

test('logger.child creates module-specific logger', async () => {
    const { logger } = await import('../utils/logger.js')
    const childLogger = logger.child('TestModule')

    expect(childLogger).toBeDefined()
    expect(typeof childLogger.info).toBe('function')
    expect(typeof childLogger.error).toBe('function')
    expect(typeof childLogger.warn).toBe('function')
    expect(typeof childLogger.debug).toBe('function')
})

test('logger has all required methods', async () => {
    const { logger } = await import('../utils/logger.js')

    expect(typeof logger.info).toBe('function')
    expect(typeof logger.error).toBe('function')
    expect(typeof logger.warn).toBe('function')
    expect(typeof logger.debug).toBe('function')
    expect(typeof logger.child).toBe('function')
})

test('logger.info does not throw', async () => {
    const { logger } = await import('../utils/logger.js')

    // Should not throw
    logger.info('Test message', { key: 'value' })
    expect(true).toBe(true)
})

test('logger.error does not throw', async () => {
    const { logger } = await import('../utils/logger.js')

    // Should not throw
    logger.error('Test error', { errorCode: 500 })
    expect(true).toBe(true)
})

```

---

## server/__tests__/run-tests.js

```javascript
/**
 * PWA-TorServe Test Entry Point
 * 
 * Run: node server/__tests__/run-tests.js
 */

import { runTests } from './test-runner.js'

// Import all test files (they register tests on import)
await import('./logger.test.js')
await import('./torrent.test.js')
await import('./watchdog.test.js')

// Run all registered tests
await runTests()

```

---

## server/__tests__/test-runner.js

```javascript
/**
 * Unit Tests for PWA-TorServe Server
 * 
 * Run with: node --experimental-vm-modules server/__tests__/run-tests.js
 * 
 * Note: These are simple assertion-based tests that work without Jest/Vitest
 *       to avoid npm install requirements on NAS
 */

const tests = []
let passed = 0
let failed = 0

// Test registration helper
function test(name, fn) {
    tests.push({ name, fn })
}

// Assertion helpers
function expect(actual) {
    return {
        toBe: (expected) => {
            if (actual !== expected) {
                throw new Error(`Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`)
            }
        },
        toEqual: (expected) => {
            if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                throw new Error(`Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`)
            }
        },
        toBeTruthy: () => {
            if (!actual) {
                throw new Error(`Expected truthy value, got ${JSON.stringify(actual)}`)
            }
        },
        toBeFalsy: () => {
            if (actual) {
                throw new Error(`Expected falsy value, got ${JSON.stringify(actual)}`)
            }
        },
        toContain: (expected) => {
            if (!actual.includes(expected)) {
                throw new Error(`Expected "${actual}" to contain "${expected}"`)
            }
        },
        toBeGreaterThan: (expected) => {
            if (actual <= expected) {
                throw new Error(`Expected ${actual} to be greater than ${expected}`)
            }
        },
        toBeNull: () => {
            if (actual !== null) {
                throw new Error(`Expected null, got ${JSON.stringify(actual)}`)
            }
        },
        toBeDefined: () => {
            if (actual === undefined) {
                throw new Error(`Expected value to be defined`)
            }
        }
    }
}

// Run all tests
async function runTests() {
    console.log('\nüß™ PWA-TorServe Test Suite\n')
    console.log('‚ïê'.repeat(50))

    for (const { name, fn } of tests) {
        try {
            await fn()
            console.log(`‚úÖ ${name}`)
            passed++
        } catch (err) {
            console.log(`‚ùå ${name}`)
            console.log(`   ‚îî‚îÄ ${err.message}`)
            failed++
        }
    }

    console.log('‚ïê'.repeat(50))
    console.log(`\nüìä Results: ${passed} passed, ${failed} failed, ${tests.length} total\n`)

    if (failed > 0) {
        process.exit(1)
    }
}

// Export for test files
export { test, expect, runTests }

```

---

## server/__tests__/torrent.test.js

```javascript
/**
 * Torrent Module Tests
 * Tests for server/torrent.js utilities
 */

import { test, expect } from './test-runner.js'

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Helper Function Tests (can be run without actual torrents)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

test('PUBLIC_TRACKERS should be defined and non-empty', async () => {
    // We test by checking torrent.js exports
    const torrentModule = await import('../torrent.js')

    // Module should export required functions
    expect(typeof torrentModule.addTorrent).toBe('function')
    expect(typeof torrentModule.removeTorrent).toBe('function')
    expect(typeof torrentModule.getTorrent).toBe('function')
    expect(typeof torrentModule.getAllTorrents).toBe('function')
})

test('getAllTorrents returns array', async () => {
    const { getAllTorrents } = await import('../torrent.js')
    const torrents = getAllTorrents()

    expect(Array.isArray(torrents)).toBe(true)
})

test('getTorrent returns null for non-existent hash', async () => {
    const { getTorrent } = await import('../torrent.js')
    const result = getTorrent('nonexistent_hash_123456')

    expect(result).toBeNull()
})

test('removeTorrent returns false for non-existent hash', async () => {
    const { removeTorrent } = await import('../torrent.js')
    const result = removeTorrent('nonexistent_hash_123456')

    expect(result).toBeFalsy()
})

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Magnet URI Parsing (if you have such utilities)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

test('magnet URI format validation', () => {
    const validMagnet = 'magnet:?xt=urn:btih:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
    const invalidMagnet = 'not-a-magnet'

    expect(validMagnet.startsWith('magnet:')).toBe(true)
    expect(invalidMagnet.startsWith('magnet:')).toBe(false)
})

```

---

## server/__tests__/watchdog.test.js

```javascript
/**
 * Watchdog Module Tests
 * Tests for server/watchdog.js
 */

import { test, expect } from './test-runner.js'

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Watchdog API Tests
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

test('watchdog exports required functions', async () => {
    const watchdog = await import('../watchdog.js')

    expect(typeof watchdog.getServerState).toBe('function')
    expect(typeof watchdog.startWatchdog).toBe('function')
    expect(typeof watchdog.stopWatchdog).toBe('function')
})

test('getServerState returns valid state object', async () => {
    const { getServerState } = await import('../watchdog.js')
    const state = getServerState()

    expect(state).toBeDefined()
    expect(typeof state.serverStatus).toBe('string')
    expect(typeof state.lastStateChange).toBe('number')
})

test('serverStatus is valid value', async () => {
    const { getServerState } = await import('../watchdog.js')
    const state = getServerState()

    const validStatuses = ['ok', 'degraded', 'error', 'circuit_open']
    expect(validStatuses.includes(state.serverStatus)).toBe(true)
})

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// RAM Helper Test
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

test('process.memoryUsage returns valid data', () => {
    const mem = process.memoryUsage()

    expect(mem.heapUsed).toBeGreaterThan(0)
    expect(mem.heapTotal).toBeGreaterThan(0)
    expect(mem.rss).toBeGreaterThan(0)
})

```

---

## server/aggregator.js

```javascript
/**
 * Aggregator - Multi-source torrent search aggregation
 * PWA-TorServe Provider Architecture v2.8.0
 * 
 * Combines results from multiple providers using Promise.allSettled
 * Implements:
 * - Parallel search across all enabled providers
 * - Timeout per provider
 * - Deduplication by infohash
 * - Partial success (returns results even if some providers fail)
 * - Search cache (5 min TTL)
 * - Circuit breaker per provider
 */

import { providerManager } from './providers/index.js'
import { searchCache } from './searchCache.js'
import { logger } from './utils/logger.js'

const log = logger.child('Aggregator')

// Search timeout per provider (ms)
const PROVIDER_TIMEOUT = 30000

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üîí Circuit Breaker: Auto-disable failing providers
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const FAILURE_THRESHOLD = 3        // Failures before opening circuit
const RECOVERY_TIMEOUT = 5 * 60000 // 5 minutes before retry

const circuitBreakers = new Map() // provider -> { failures, openedAt }

function getCircuitState(providerName) {
    if (!circuitBreakers.has(providerName)) {
        circuitBreakers.set(providerName, { failures: 0, openedAt: null })
    }
    return circuitBreakers.get(providerName)
}

function isCircuitOpen(providerName) {
    const state = getCircuitState(providerName)
    if (!state.openedAt) return false

    // Check if recovery timeout passed
    if (Date.now() - state.openedAt > RECOVERY_TIMEOUT) {
        state.failures = 0
        state.openedAt = null
        log.info('Circuit closed (recovery)', { provider: providerName })
        return false
    }
    return true
}

function recordSuccess(providerName) {
    const state = getCircuitState(providerName)
    state.failures = 0
    state.openedAt = null
}

function recordFailure(providerName) {
    const state = getCircuitState(providerName)
    state.failures++

    if (state.failures >= FAILURE_THRESHOLD && !state.openedAt) {
        state.openedAt = Date.now()
        log.warn('Circuit opened', { provider: providerName, failures: state.failures })
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// STAB-01: Auto-Reset Failures (Resilience)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
setInterval(() => {
    log.debug('Circuit Breaker: Resetting failure counters')
    for (const [provider, state] of circuitBreakers.entries()) {
        if (state.failures > 0 && !state.openedAt) {
            // Reset failures if circuit is NOT open (transient failures)
            // If circuit is OPEN, we wait for RECOVERY_TIMEOUT (handled in isCircuitOpen)
            state.failures = 0
        }
    }
}, 5 * 60 * 1000) // Every 5 minutes

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Search across all enabled providers (with cache)
 * @param {string} query - Search query
 * @param {Object} options - Search options
 * @param {boolean} options.skipCache - Skip cache lookup
 * @returns {Promise<{results: Array, errors: Array, providers: Object, cached: boolean}>}
 */
export async function search(query, options = {}) {
    // Check cache first
    if (!options.skipCache) {
        const cached = searchCache.get(query)
        if (cached) {
            log.info('üì¶ Cache hit', { query, resultsCount: cached.results.length })
            return { ...cached, errors: [], cached: true }
        }
    }

    const providers = providerManager.getEnabled()
        .filter(p => !isCircuitOpen(p.name))

    if (providers.length === 0) {
        log.warn('No available providers')
        return { results: [], errors: ['No available providers'], providers: {}, cached: false }
    }

    log.info('üîç Aggregated search', { query, providersCount: providers.length })

    // Create search promises with timeout
    const searchPromises = providers.map(async (provider) => {
        const timeoutPromise = new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Timeout')), PROVIDER_TIMEOUT)
        )

        try {
            const results = await Promise.race([
                provider.search(query),
                timeoutPromise
            ])
            recordSuccess(provider.name)
            return { provider: provider.name, results, success: true }
        } catch (error) {
            recordFailure(provider.name)
            return { provider: provider.name, error: error.message, success: false }
        }
    })

    // Wait for all providers (partial success allowed)
    const outcomes = await Promise.allSettled(searchPromises)

    // Collect results and errors
    const allResults = []
    const errors = []
    const providerStats = {}

    for (const outcome of outcomes) {
        if (outcome.status === 'fulfilled') {
            const { provider, results, success, error } = outcome.value

            if (success && results) {
                allResults.push(...results)
                providerStats[provider] = { count: results.length, status: 'ok' }
                log.info(`‚úÖ ${provider}`, { count: results.length })
            } else {
                errors.push({ provider, error })
                providerStats[provider] = { count: 0, status: 'error', error }
                log.warn(`‚ùå ${provider}`, { error })
            }
        } else {
            log.error('Unexpected rejection', outcome.reason)
        }
    }

    // Add skipped providers (circuit open)
    const skipped = providerManager.getEnabled()
        .filter(p => isCircuitOpen(p.name))
    for (const p of skipped) {
        providerStats[p.name] = { count: 0, status: 'circuit_open' }
    }

    // Deduplicate by infohash
    const deduped = deduplicateByInfohash(allResults)

    // Store in cache if we got results
    if (deduped.length > 0) {
        searchCache.set(query, deduped, providerStats)
    }

    log.info('‚úÖ Aggregation complete', {
        totalResults: deduped.length,
        fromProviders: Object.keys(providerStats).length,
        errors: errors.length
    })

    return { results: deduped, errors, providers: providerStats, cached: false }
}

/**
 * Get magnet link for a torrent from specific provider
 */
export async function getMagnet(providerName, id) {
    const provider = providerManager.get(providerName)
    if (!provider) {
        return { error: `Provider not found: ${providerName}` }
    }
    return provider.getMagnet(id)
}

/**
 * Get status of all providers (including circuit state)
 */
export function getProvidersStatus() {
    return providerManager.getAll().map(p => ({
        name: p.name,
        enabled: p.enabled,
        healthy: p.isHealthy(),
        circuitOpen: isCircuitOpen(p.name),
        failures: getCircuitState(p.name).failures
    }))
}

/**
 * Get cache statistics
 */
export function getCacheStats() {
    return searchCache.getStats()
}

/**
 * Reset circuit breaker for a provider
 */
export function resetCircuit(providerName) {
    const state = getCircuitState(providerName)
    state.failures = 0
    state.openedAt = null
    log.info('Circuit reset', { provider: providerName })
}

/**
 * Deduplicate results by infohash
 */
function deduplicateByInfohash(results) {
    const seen = new Map()

    for (const result of results) {
        const hash = extractInfohash(result.magnet)

        if (!hash) {
            seen.set(`nohash_${Math.random()}`, result)
            continue
        }

        const existing = seen.get(hash)
        if (!existing || (result.seeders > existing.seeders)) {
            seen.set(hash, result)
        }
    }

    return Array.from(seen.values())
}

/**
 * Extract infohash from magnet link
 */
function extractInfohash(magnet) {
    if (!magnet) return null

    const hexMatch = magnet.match(/urn:btih:([a-fA-F0-9]{40})/i)
    if (hexMatch) return hexMatch[1].toLowerCase()

    const base32Match = magnet.match(/urn:btih:([A-Z2-7]{32})/i)
    if (base32Match) return base32Match[1].toLowerCase()

    return null
}

```

---

## server/autodownloader.js

```javascript
/**
 * Auto-Downloader Module v2.7.0 - MULTI-SOURCE
 * PWA-TorServe
 *
 * üÜï v2.7.0 FEATURES:
 * - MULTI-SOURCE: Uses Aggregator (Jacred + RuTracker + future providers)
 * - PARTIAL SUCCESS: Works even if some providers fail
 * - DEDUPLICATION: Results deduplicated by infohash across providers
 *
 * üÜï v2.6.7 FIXES:
 * - FIX: Translation now returns ARRAY ["Fallout", "Fallout S02"]
 * - FIX: Base name searched first (finds Russian releases like "–§–æ–ª–ª–∞—É—Ç 2 —Å–µ–∑–æ–Ω")
 *
 * üÜï v2.6.6 FEATURES:
 * - SMART QUERY: Auto-removes quality tags (DV, HDR, HMAX, WEB etc.)
 * - MULTI-VARIANT: Tries multiple query variants for better results
 *
 * üÜï v2.6.3 OPTIMIZATIONS:
 * - ATOMIC WRITES: Grouped DB updates to prevent race conditions & corruption
 * - LOGIC FIX: lastEpisode is no longer updated by REPACK releases
 */

import { db, safeWrite } from './db.js'
import { search as aggregatorSearch } from './aggregator.js'
import { addTorrent } from './torrent.js'
import { logger } from './utils/logger.js'

const log = logger.child('AutoDownloader')

// Runtime DEBUG toggle
const DEBUG = process.env.AUTO_DL_DEBUG === '1'
const MAX_DOWNLOADS_PER_RULE = 1  // Only download the BEST torrent per episode

// Keywords detection
const BATCH_KEYWORDS = /complete|season|batch|pack|collection|ÂÖ®ÈõÜ|box[\s\.]?set/i
const FIX_KEYWORDS = /repack|proper|rerip|real\.proper|internal/i

// Global blacklist (defaults)
const GLOBAL_BLACKLIST = [
    'camrip', 'cam', 'hdcam',
    'ts', 'hdts', 'telesync',
    'tc', 'telecine',
    'workprint', 'screener',
    'hindi', 'tamil', 'telugu', 'dubbed',
    'linedub', 'korean', 'chinese',
    'sample', 'trailer'
]

// REPACK window (hours)
const REPACK_WINDOW_HOURS = 72  // 3 days

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÔøΩ Query Normalization for Better Search Results
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Normalize search query by removing quality tags, codecs, groups etc.
 * This helps find results on jacred.xyz which doesn't parse these tags.
 * 
 * Examples:
 * - "IT Welcome to Derry S01 HMAX DV HDR WEB" ‚Üí "Welcome to Derry S01"
 * - "–§–æ–ª–ª–∞—É—Ç 2" ‚Üí "–§–æ–ª–ª–∞—É—Ç 2" (unchanged, but we'll try English too)
 */
function normalizeQuery(query) {
    let normalized = query.trim()

    // Remove quality/codec tags (case insensitive)
    const removeTags = [
        // Quality
        /\b(2160p|1080p|720p|480p|4k|uhd)\b/gi,
        // HDR variants
        /\b(hdr10\+?|hdr|dv|dolby\s*vision|hlg)\b/gi,
        // Codecs
        /\b(hevc|h\.?265|x\.?265|h\.?264|x\.?264|av1|avc)\b/gi,
        // Audio
        /\b(atmos|truehd|dts-?hd|dts|aac|ac3|eac3|flac)\b/gi,
        // Source tags (including standalone WEB)
        /\b(web-?dl|web-?rip|webrip|web|blu-?ray|bdrip|hdtv|dvdrip|hdrip|remux)\b/gi,
        // Streaming services
        /\b(hmax|hbo|netflix|nf|amzn|amazon|atvp|dsnp|disney\+?|hulu|paramount\+?)\b/gi,
        // Release groups (at end)
        /-[a-z0-9]+$/i,
        // Release groups in brackets
        /\[[^\]]+\]$/g,
        // "IT" prefix (often means International)
        /^IT\s+/i,
    ]

    for (const pattern of removeTags) {
        normalized = normalized.replace(pattern, '')
    }

    // Clean up multiple spaces and trim
    normalized = normalized.replace(/\s+/g, ' ').trim()

    // Remove trailing/leading dashes and dots
    normalized = normalized.replace(/^[\s.\-]+|[\s.\-]+$/g, '').trim()

    return normalized
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üåê RU‚ÜíEN Translation Dictionary for Popular Titles
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const RU_EN_TRANSLATIONS = {
    // Popular series
    '—Ñ–æ–ª–ª–∞—É—Ç': 'Fallout',
    'fallout': 'Fallout',
    '–≤–µ–¥—å–º–∞–∫': 'The Witcher',
    '–∏–≥—Ä–∞ –ø—Ä–µ—Å—Ç–æ–ª–æ–≤': 'Game of Thrones',
    '–¥–æ–º –¥—Ä–∞–∫–æ–Ω–∞': 'House of the Dragon',
    '–º–∞–Ω–¥–∞–ª–æ—Ä–µ—Ü': 'The Mandalorian',
    '–ª–æ–∫–∏': 'Loki',
    '–≤–∞–Ω–¥–∞ –≤–∏–∂–Ω': 'WandaVision',
    '—Å–æ–∫–æ–ª–∏–Ω—ã–π –≥–ª–∞–∑': 'Hawkeye',
    '–ª—É–Ω–Ω—ã–π —Ä—ã—Ü–∞—Ä—å': 'Moon Knight',
    '–º–∏—Å—Å –º–∞—Ä–≤–µ–ª': 'Ms Marvel',
    '–∂–µ–Ω—â–∏–Ω–∞ —Ö–∞–ª–∫': 'She Hulk',
    '—Å–µ–∫—Ä–µ—Ç–Ω–æ–µ –≤—Ç–æ—Ä–∂–µ–Ω–∏–µ': 'Secret Invasion',
    '–∞–≥–∞—Ç–∞': 'Agatha All Along',
    '–∑–≤—ë–∑–¥–Ω—ã–µ –≤–æ–π–Ω—ã': 'Star Wars',
    '–∑–≤–µ–∑–¥–Ω—ã–µ –≤–æ–π–Ω—ã': 'Star Wars',
    '–æ–±–∏ –≤–∞–Ω': 'Obi-Wan Kenobi',
    '–∞—Å–æ–∫–∞': 'Ahsoka',
    '–∞–Ω–¥–æ—Ä': 'Andor',
    '–∞–∫–æ–ª–∏—Ç': 'The Acolyte',
    '—Å–∫–µ–ª–µ—Ç–æ–Ω –∫—Ä—é': 'Skeleton Crew',
    '–∫–æ–ª—å—Ü–∞ –≤–ª–∞—Å—Ç–∏': 'Rings of Power',
    '–≤–ª–∞—Å—Ç–µ–ª–∏–Ω –∫–æ–ª–µ—Ü': 'Lord of the Rings',
    '–ø–æ—Å–ª–µ–¥–Ω–∏–µ –∏–∑ –Ω–∞—Å': 'The Last of Us',
    '–æ–¥–Ω–∏ –∏–∑ –Ω–∞—Å': 'The Last of Us',
    '–ø–æ—Å–ª–µ–¥–Ω–∏–π –∏–∑ –Ω–∞—Å': 'The Last of Us',
    '—Ö–æ–¥—è—á–∏–µ –º–µ—Ä—Ç–≤–µ—Ü—ã': 'The Walking Dead',
    '–æ—á–µ–Ω—å —Å—Ç—Ä–∞–Ω–Ω—ã–µ –¥–µ–ª–∞': 'Stranger Things',
    '—á—ë—Ä–Ω–æ–µ –∑–µ—Ä–∫–∞–ª–æ': 'Black Mirror',
    '—á–µ—Ä–Ω–æ–µ –∑–µ—Ä–∫–∞–ª–æ': 'Black Mirror',
    '–±—É–º–∞–∂–Ω—ã–π –¥–æ–º': 'Money Heist',
    '–ª–∞ –∫–∞—Å–∞ –¥–µ –ø–∞–ø–µ–ª—å': 'Money Heist',
    '–≤–æ –≤—Å–µ —Ç—è–∂–∫–∏–µ': 'Breaking Bad',
    '–ª—É—á—à–µ –∑–≤–æ–Ω–∏—Ç–µ —Å–æ–ª—É': 'Better Call Saul',
    '–æ—Å—Ç—Ä—ã–µ –∫–æ–∑—ã—Ä—å–∫–∏': 'Peaky Blinders',
    '–≤–∏–∫–∏–Ω–≥–∏': 'Vikings',
    '–∫–æ—Ä–æ–Ω–∞': 'The Crown',
    '—ç–π—Ñ–æ—Ä–∏—è': 'Euphoria',
    '—Å—É–∫–∞—Å–∏—è–Ω–∏–µ': 'The Shining', // :)
    '—Å–∏—è–Ω–∏–µ': 'The Shining',
    '–æ–Ω–æ': 'IT',
    '–ø–µ–Ω–Ω–∏—É–∞–π–∑': 'Pennywise',
    '–¥–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –¥–µ—Ä—Ä–∏': 'Welcome to Derry',
    // Movies
    '–¥—é–Ω–∞': 'Dune',
    '–∞–≤–∞—Ç–∞—Ä': 'Avatar',
    '–º—Å—Ç–∏—Ç–µ–ª–∏': 'Avengers',
    '—á–µ–ª–æ–≤–µ–∫ –ø–∞—É–∫': 'Spider-Man',
    '–±—ç—Ç–º–µ–Ω': 'Batman',
    '–¥–∂–æ–∫–µ—Ä': 'Joker',
    '—Å—É–ø–µ—Ä–º–µ–Ω': 'Superman',
    // Add more as needed
}

/**
 * Translate Russian query to English using dictionary
 * üÜï v2.6.7: Returns array of variants (with season AND without)
 */
function translateRuToEn(query) {
    const lowerQuery = query.toLowerCase().trim()
    const variants = []

    // Check for exact match first
    if (RU_EN_TRANSLATIONS[lowerQuery]) {
        variants.push(RU_EN_TRANSLATIONS[lowerQuery])
        return variants
    }

    // Check for partial matches (title + season)
    for (const [ru, en] of Object.entries(RU_EN_TRANSLATIONS)) {
        if (lowerQuery.startsWith(ru)) {
            // Always add base English name first (most likely to find results)
            variants.push(en)

            // Extract season/episode info after the title
            const suffix = lowerQuery.slice(ru.length).trim()
            const seasonMatch = suffix.match(/(?:—Å–µ–∑–æ–Ω\s*)?(\d+)/i)
            if (seasonMatch) {
                // Also add with season format (e.g., "Fallout S02")
                variants.push(`${en} S${seasonMatch[1].padStart(2, '0')}`)
            }

            return variants
        }
    }

    return []  // Return empty array if no translation found
}

/**
 * Generate query variants to try (for better search coverage)
 * Returns array of queries to try in order
 * üÜï v2.6.7: Translation returns array of variants
 */
function generateQueryVariants(query) {
    const variants = []
    const normalized = normalizeQuery(query)

    // 1. Try English translations first (most likely to find results)
    const englishTranslations = translateRuToEn(normalized || query)
    if (englishTranslations.length > 0) {
        variants.push(...englishTranslations)
    }

    // 2. Normalized query (without tags)
    if (normalized && normalized !== query && !variants.includes(normalized)) {
        variants.push(normalized)
    }

    // 3. Original query (might work if user entered it correctly)
    if (!variants.includes(query)) {
        variants.push(query)
    }

    // 4. If query has season info, try without it
    const seasonMatch = query.match(/S(\d{1,2})/i) || query.match(/Season\s*(\d+)/i)
    if (seasonMatch) {
        const withoutSeason = normalized
            .replace(/S\d{1,2}/i, '')
            .replace(/Season\s*\d+/i, '')
            .replace(/\s+/g, ' ')
            .trim()
        if (withoutSeason && !variants.includes(withoutSeason)) {
            // Also try English translation without season
            const enWithoutSeason = translateRuToEn(withoutSeason)
            for (const tr of enWithoutSeason) {
                if (!variants.includes(tr)) {
                    variants.push(tr)
                }
            }
            variants.push(withoutSeason)
        }
    }

    // Remove duplicates while preserving order
    return [...new Set(variants)]
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÔøΩüì∫ Enhanced Title Parser
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export function parseTorrentTitle(title, sizeFromAPI = 0) {
    const result = {
        title: '',
        season: null,
        episode: 0,
        resolution: '',
        group: '',
        qualityScore: 0,
        sizeGB: sizeFromAPI,
        isHevc: false,
        isBatch: false,
        isRepack: false,
        _raw: title
    }

    let cleanTitle = title.trim()

    // Detect REPACK/PROPER
    result.isRepack = FIX_KEYWORDS.test(cleanTitle)

    // Batch detection
    result.isBatch = BATCH_KEYWORDS.test(cleanTitle)

    // Quality score extraction
    if (/2160p|4k|uhd/i.test(cleanTitle)) {
        result.qualityScore = 4
        result.resolution = '2160p'
    } else if (/1080p/i.test(cleanTitle)) {
        result.qualityScore = 3
        result.resolution = '1080p'
    } else if (/720p/i.test(cleanTitle)) {
        result.qualityScore = 2
        result.resolution = '720p'
    } else if (/480p/i.test(cleanTitle)) {
        result.qualityScore = 1
        result.resolution = '480p'
    }

    // HEVC detection
    result.isHevc = /x265|hevc/i.test(cleanTitle)

    // Size extraction
    if (!result.sizeGB) {
        const sizeMatch = cleanTitle.match(/(\d+(?:\.\d+)?)\s*(GB|GiB)/i)
        if (sizeMatch) {
            result.sizeGB = parseFloat(sizeMatch[1])
        }
    }

    // Release group extraction
    const groupBracketMatch = cleanTitle.match(/^\[([^\]]+)\]/)
    const groupDashMatch = cleanTitle.match(/-([A-Za-z0-9]+)(?:\.[a-z]{2,4})?$/)
    if (groupBracketMatch) {
        result.group = groupBracketMatch[1]
    } else if (groupDashMatch) {
        result.group = groupDashMatch[1]
    }

    // Pattern 1: SxxExx
    const sxxexxMatch = cleanTitle.match(/[\.\s]S(\d{1,2})E(\d{1,3})/i)
    if (sxxexxMatch) {
        result.season = parseInt(sxxexxMatch[1], 10)
        result.episode = parseInt(sxxexxMatch[2], 10)
        const titlePart = cleanTitle.split(/S\d{1,2}E\d{1,3}/i)[0]
        result.title = cleanTitlePart(titlePart)
        return result
    }

    // Pattern 2: Season X Episode Y
    const verboseMatch = cleanTitle.match(/Season\s*(\d+)\s*Episode\s*(\d+)/i)
    if (verboseMatch) {
        result.season = parseInt(verboseMatch[1], 10)
        result.episode = parseInt(verboseMatch[2], 10)
        const titlePart = cleanTitle.split(/Season/i)[0]
        result.title = cleanTitlePart(titlePart)
        return result
    }

    // Pattern 3: Anime style
    const animeMatch = cleanTitle.match(/(.+?)\s*[-‚Äì]\s*(\d{1,4})(?:v\d)?(?:\s|$|\[|\()/)
    if (animeMatch) {
        result.episode = parseInt(animeMatch[2], 10)
        result.title = cleanTitlePart(animeMatch[1])
        return result
    }

    // Pattern 4: Episode keyword
    const epMatch = cleanTitle.match(/(.+?)\s*(?:Episode|Ep\.?|E)\s*(\d{1,3})/i)
    if (epMatch) {
        result.episode = parseInt(epMatch[2], 10)
        result.title = cleanTitlePart(epMatch[1])
        return result
    }

    // Pattern 5: Simple number
    const simpleNumberMatch = cleanTitle.match(/(.+?)\s+(\d{1,3})\s+(?:\d{3,4}p|\[|$)/i)
    if (simpleNumberMatch) {
        result.episode = parseInt(simpleNumberMatch[2], 10)
        result.title = cleanTitlePart(simpleNumberMatch[1])
        return result
    }

    // Generic fallback
    result.title = cleanTitlePart(cleanTitle)
    return result
}

function cleanTitlePart(title) {
    return title
        .replace(/^\[([^\]]+)\]\s*/, '')
        .replace(/\./g, ' ')
        .replace(/\s*\([^)]+\)\s*/g, ' ')
        .replace(/\s*\[[^\]]+\]\s*/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üîç Enhanced Rule Matching
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function matchesRule(parsed, rule) {
    // 1. Blacklist Check
    const globalBlacklist = db.data.autoDownloadSettings?.globalBlacklist || GLOBAL_BLACKLIST
    const ruleBlacklist = rule.excludeKeywords || []
    const combinedBlacklist = [...globalBlacklist, ...ruleBlacklist]

    if (combinedBlacklist.length > 0) {
        const lowerTitle = parsed._raw.toLowerCase()
        const blockedKeyword = combinedBlacklist.find(keyword =>
            lowerTitle.includes(keyword.toLowerCase())
        )
        if (blockedKeyword) {
            if (DEBUG) log.debug('‚ùå Excluded by keyword', { keyword: blockedKeyword })
            return false
        }
    }

    // 2. Batch detection
    if (parsed.isBatch && rule.lastEpisode > 0) {
        if (DEBUG) log.debug('‚ùå Batch detected, skipping')
        return false
    }

    // 3. Block REPACKs if no original downloaded yet
    if (parsed.isRepack && rule.lastEpisode === 0) {
        if (DEBUG) log.debug('‚ùå REPACK not allowed (no original downloaded yet)', { episode: parsed.episode })
        return false
    }

    // 4. Title fuzzy matching
    const queryLower = rule.query.toLowerCase()
    const titleLower = parsed.title.toLowerCase()

    const hasExactMatch =
        queryLower.length > 3 &&
        (titleLower.includes(queryLower) || queryLower.includes(titleLower))

    if (!hasExactMatch) {
        const queryWords = queryLower.split(/\s+/).filter(w => w.length > 2)
        const titleWords = titleLower.split(/\s+/).filter(w => w.length > 2)

        if (queryWords.length === 0) {
            if (DEBUG) log.debug('‚ùå Query too short')
            return false
        }

        const matchCount = queryWords.filter(qw =>
            titleWords.some(tw => tw.includes(qw) || qw.includes(tw))
        ).length

        const minMatches = Math.max(1, Math.ceil(queryWords.length * 0.5))

        if (matchCount < minMatches) {
            if (DEBUG) log.debug('‚ùå Title mismatch')
            return false
        }
    }

    // 5. Quality/Resolution Filters
    if (rule.quality && rule.quality !== 'any') {
        const requiredQuality = {
            '4k': 4, '2160p': 4,
            '1080p': 3, '720p': 2, '480p': 1
        }[rule.quality.toLowerCase()]

        // Strict mode: Allow equal or better quality
        if (rule.strictQuality && requiredQuality) {
            if (parsed.qualityScore < requiredQuality) {
                if (DEBUG) log.debug('‚ùå Strict quality filter (below minimum)', {
                    required: rule.quality,
                    requiredScore: requiredQuality,
                    gotScore: parsed.qualityScore
                })
                return false
            }
        }
    }

    // 6. Resolution filter (strict: if rule requires resolution, torrent must have it)
    if (rule.resolution && rule.resolution.trim() !== '') {
        if (!parsed.resolution) {
            if (DEBUG) log.debug('‚ùå Resolution required but not found')
            return false
        }
        if (!parsed.resolution.includes(rule.resolution.toLowerCase())) {
            if (DEBUG) log.debug('‚ùå Resolution mismatch')
            return false
        }
    }

    // 7. Group Filter
    if (rule.group && rule.group.trim() !== '') {
        if (parsed.group && !parsed.group.toLowerCase().includes(rule.group.toLowerCase())) {
            if (DEBUG) log.debug('‚ùå Group mismatch')
            return false
        }
    }

    // 8. Season Filter
    if (rule.season && rule.season > 0) {
        if (parsed.season === null) {
            if (DEBUG) log.debug('‚ùå Season required but not parsed')
            return false
        }
        if (parsed.season !== rule.season) {
            if (DEBUG) log.debug('‚ùå Season mismatch')
            return false
        }
    }

    // 9. Episode Check with Smart REPACK Handling
    if (parsed.episode > 0 && parsed.episode <= rule.lastEpisode) {
        if (parsed.isRepack) {
            const timestampKey = `${rule.id}_${parsed.episode}`
            const lastDownloadTime = db.data.autoDownloadTimestamps?.[timestampKey] || 0
            const hoursSinceDownload = (Date.now() - lastDownloadTime) / (1000 * 60 * 60)

            if (hoursSinceDownload < REPACK_WINDOW_HOURS) {
                if (DEBUG) log.debug('‚úÖ REPACK allowed (within window)', {
                    hoursSince: Math.round(hoursSinceDownload)
                })
                return true
            } else {
                if (DEBUG) log.debug('‚ùå REPACK too old', {
                    hoursSince: Math.round(hoursSinceDownload)
                })
                return false
            }
        }

        if (DEBUG) log.debug('‚ùå Episode too old')
        return false
    }

    if (parsed.episode === 0 && rule.lastEpisode > 0 && !parsed.isBatch) {
        if (DEBUG) log.debug('‚ö†Ô∏è Unknown episode detected, allowing')
    }

    return true
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üèÜ Smart Candidate Selection
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function selectBestCandidate(candidates, rule) {
    if (candidates.length === 0) return null
    if (candidates.length === 1) return candidates[0]

    candidates.sort((a, b) => {
        // 1. Quality
        if (b.parsed.qualityScore !== a.parsed.qualityScore) {
            return b.parsed.qualityScore - a.parsed.qualityScore
        }
        // 2. HEVC Preference
        if (rule.preferHevc) {
            if (b.parsed.isHevc !== a.parsed.isHevc) {
                return (b.parsed.isHevc ? 1 : 0) - (a.parsed.isHevc ? 1 : 0)
            }
        }
        // 3. Size
        if (b.parsed.sizeGB !== a.parsed.sizeGB) {
            return b.parsed.sizeGB - a.parsed.sizeGB
        }
        // 4. Non-HEVC Fallback
        if (!rule.preferHevc) {
            if (a.parsed.isHevc !== b.parsed.isHevc) {
                return (a.parsed.isHevc ? 1 : 0) - (b.parsed.isHevc ? 1 : 0)
            }
        }
        return 0
    })

    return candidates[0]
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üöÄ Main Check Logic
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export async function checkRules() {
    await db.read()

    const settings = db.data.autoDownloadSettings || { enabled: false }
    const rules = db.data.autoDownloadRules || []

    if (!settings.enabled || rules.length === 0) {
        return { checked: 0, downloaded: 0, errors: 0 }
    }

    db.data.autoDownloadTimestamps ||= {}

    log.info('üîç Starting auto-download check', { rulesCount: rules.length })

    let downloaded = 0
    let errors = 0
    let totalTorrentsChecked = 0
    const downloadedHashes = new Set(db.data.autoDownloadHistory || [])

    for (const rule of rules) {
        if (!rule.enabled) continue

        try {
            // Generate query variants (normalized, original, without season)
            const queryVariants = generateQueryVariants(rule.query)

            log.info('üîç Checking rule', {
                query: rule.query,
                variants: queryVariants,
                lastEpisode: rule.lastEpisode
            })

            // Try each query variant until we get results
            let results = []
            let usedQuery = null

            for (const variant of queryVariants) {
                log.info('üîé Trying query variant', { variant })
                const searchResult = await aggregatorSearch(variant)

                if (searchResult.results && searchResult.results.length > 0) {
                    results = searchResult.results
                    usedQuery = variant
                    log.info('‚úÖ Found results with variant', {
                        variant,
                        count: results.length,
                        providers: Object.keys(searchResult.providers || {})
                    })
                    break
                }

                // Small delay between variants to avoid rate limiting
                await new Promise(r => setTimeout(r, 1000))
            }

            if (results.length === 0) {
                log.warn('‚ö†Ô∏è No results found for any variant', {
                    originalQuery: rule.query,
                    triedVariants: queryVariants
                })
                continue
            }

            log.info('üì¶ Search results', { usedQuery, count: results.length })

            // Group candidates
            const episodeCandidates = new Map()
            let unknownEpisodeCounter = 0

            for (const torrent of results) {
                totalTorrentsChecked++

                const magnetHash = extractHash(torrent.magnet)
                if (magnetHash && downloadedHashes.has(magnetHash)) {
                    if (DEBUG) log.debug('‚è≠Ô∏è Already downloaded')
                    continue
                }

                const sizeGB = torrent.Size ? parseFloat(torrent.Size) / (1024 ** 3) : 0
                const parsed = parseTorrentTitle(torrent.title, sizeGB)

                if (matchesRule(parsed, rule)) {
                    let episodeKey
                    if (parsed.episode > 0) {
                        episodeKey = `e${parsed.episode}`
                    } else {
                        episodeKey = `unknown_${unknownEpisodeCounter++}`
                    }

                    if (!episodeCandidates.has(episodeKey)) {
                        episodeCandidates.set(episodeKey, [])
                    }
                    episodeCandidates.get(episodeKey).push({ torrent, parsed })
                }
            }

            // Process best candidates
            let downloadsThisRule = 0

            for (const [episodeKey, candidates] of episodeCandidates.entries()) {
                if (downloadsThisRule >= MAX_DOWNLOADS_PER_RULE) break

                const best = selectBestCandidate(candidates, rule)
                if (!best) continue

                log.info('üéØ MATCH FOUND', {
                    title: best.parsed.title,
                    episode: best.parsed.episode,
                    repack: best.parsed.isRepack
                })

                try {
                    await addTorrent(best.torrent.magnet)
                    downloaded++
                    downloadsThisRule++

                    // üöÄ ATOMIC WRITE BLOCK
                    let dbChanged = false

                    // 1. Update lastEpisode (Only for originals)
                    // Prevents REPACKs from incorrectly advancing the episode counter
                    if (best.parsed.episode > 0 && !best.parsed.isRepack) {
                        rule.lastEpisode = Math.max(rule.lastEpisode, best.parsed.episode)
                        dbChanged = true
                    }

                    // 2. Update Timestamp (Only for originals or safety fill)
                    if (best.parsed.episode > 0 && !best.parsed.isRepack) {
                        const timestampKey = `${rule.id}_${best.parsed.episode}`
                        if (!db.data.autoDownloadTimestamps[timestampKey]) {
                            db.data.autoDownloadTimestamps[timestampKey] = Date.now()
                            dbChanged = true
                        }
                    }

                    // 3. Update History
                    const magnetHash = extractHash(best.torrent.magnet)
                    if (magnetHash) {
                        downloadedHashes.add(magnetHash)
                        db.data.autoDownloadHistory = [...downloadedHashes].slice(-500)
                        dbChanged = true
                    }

                    // 4. Perform Atomic Write
                    if (dbChanged) {
                        await safeWrite(db)
                    }

                    log.info('‚úÖ Download started')
                } catch (err) {
                    log.error('‚ùå Failed to add torrent', { error: err.message })
                    errors++
                }
            }

        } catch (err) {
            log.error('‚ùå Rule check error', { error: err.message })
            errors++
        }
    }

    log.info('‚úÖ Check complete', { downloaded, errors, torrentsChecked: totalTorrentsChecked })
    return { checked: rules.length, downloaded, errors }
}

/**
 * Extract infohash from magnet link
 * Supports both hex (40 chars) and base32 (32 chars) formats
 */
function extractHash(magnet) {
    if (!magnet) return null
    // Try hex format first (40 chars)
    const hexMatch = magnet.match(/urn:btih:([a-fA-F0-9]{40})/i)
    if (hexMatch) return hexMatch[1].toLowerCase()
    // Try base32 format (32 chars)
    const base32Match = magnet.match(/urn:btih:([A-Z2-7]{32})/i)
    if (base32Match) return base32Match[1].toLowerCase()
    return null
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üìã Rule Management API
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export async function getRules() {
    await db.read()
    return {
        settings: db.data.autoDownloadSettings || {
            enabled: false,
            intervalMinutes: 30,
            globalBlacklist: GLOBAL_BLACKLIST
        },
        rules: db.data.autoDownloadRules || []
    }
}

export async function addRule(rule) {
    await db.read()
    db.data.autoDownloadRules ||= []

    const newRule = {
        id: Date.now(),
        query: rule.query,
        quality: rule.quality || '',
        strictQuality: rule.strictQuality || false,
        preferHevc: rule.preferHevc || false,
        excludeKeywords: rule.excludeKeywords || [],
        resolution: rule.resolution || '',
        group: rule.group || '',
        season: rule.season || 0,
        lastEpisode: rule.lastEpisode || 0,
        enabled: true,
        createdAt: Date.now()
    }

    db.data.autoDownloadRules.push(newRule)
    await safeWrite(db)
    return newRule
}

export async function updateRule(id, updates) {
    await db.read()
    const rules = db.data.autoDownloadRules || []
    const index = rules.findIndex(r => r.id === id)

    if (index === -1) throw new Error('Rule not found')

    rules[index] = { ...rules[index], ...updates }
    await safeWrite(db)
    return rules[index]
}

export async function deleteRule(id) {
    await db.read()
    const before = db.data.autoDownloadRules?.length || 0
    db.data.autoDownloadRules = (db.data.autoDownloadRules || []).filter(r => r.id !== id)

    if (db.data.autoDownloadRules.length < before) {
        await safeWrite(db)
        return true
    }
    return false
}

export async function updateSettings(settings) {
    await db.read()
    db.data.autoDownloadSettings = {
        ...db.data.autoDownloadSettings,
        ...settings
    }
    await safeWrite(db)
    return db.data.autoDownloadSettings
}

```

---

## server/db.js

```javascript
import { Low } from 'lowdb'
import { JSONFile } from 'lowdb/node'
import { safeWrite } from './dbQueue.js'

// Initialize DB
const defaultData = {
    serverStatus: 'ok',        // 'ok' | 'degraded' | 'error' | 'circuit_open'
    lastStateChange: Date.now(),
    storageFailures: 0,
    progress: {},
    seenFiles: {},             // { [infoHash]: [fileName1, fileName2, ...] } - for new episode detection
    torrents: [],              // Array of { magnet, name, addedAt } for persistence
    // Auto-Downloader
    autoDownloadSettings: {
        enabled: false,
        intervalMinutes: 720  // 12 hours
    },
    autoDownloadRules: [],     // [{ id, query, resolution, group, season, lastEpisode, enabled }]
    autoDownloadHistory: []    // Array of magnet hashes to prevent duplicates
}
const dbPath = process.env.DB_PATH || 'db.json'
const adapter = new JSONFile(dbPath)
const db = new Low(adapter, defaultData)

// Ensure DB is ready and migrate existing data
await db.read()

// Merge defaults with existing data (handles DB migrations)
db.data = { ...defaultData, ...db.data }

// Ensure nested objects are initialized
db.data.progress ||= {}
db.data.seenFiles ||= {}
db.data.autoDownloadSettings ||= { enabled: false, intervalMinutes: 30 }
db.data.autoDownloadRules ||= []
db.data.autoDownloadHistory ||= []

await db.write()

export { db, safeWrite }


```

---

## server/dbQueue.js

```javascript
/**
 * DB Write Queue - prevents race conditions in LowDB writes
 * 
 * LowDB rewrites entire JSON file on each write.
 * Concurrent writes can corrupt the file.
 * This module serializes all writes through a Promise chain.
 */

let writeQueue = Promise.resolve()
let pendingWrites = 0

/**
 * Safe write to database with serialization
 * @param {object} db - LowDB instance
 * @returns {Promise} - resolves when write is complete
 */
export function safeWrite(db) {
    pendingWrites++

    writeQueue = writeQueue
        .then(() => db.write())
        .then(() => {
            pendingWrites--
        })
        .catch((err) => {
            pendingWrites--
            console.error('[DB] Write failed:', err.message)
            // Don't break the chain - allow subsequent writes
        })

    return writeQueue
}

/**
 * Get number of pending writes (for debugging/monitoring)
 */
export function getPendingWrites() {
    return pendingWrites
}

```

---

## server/index.js

```javascript
// Security: SSL validation enabled globally (see jacred.js for targeted exceptions)

import express from 'express'
import cors from 'cors'
import path from 'path'
import { fileURLToPath } from 'url'
import dotenv from 'dotenv'
import fs from 'fs'
import fsPromises from 'fs/promises'
import { addTorrent, getAllTorrents, getTorrent, getRawTorrent, removeTorrent, restoreTorrents, prioritizeFile, readahead, boostTorrent, destroyAllTorrents, setSpeedMode, getActiveTorrentsCount, getFrozenTorrentsCount } from './torrent.js'
import { db, safeWrite } from './db.js'
import { startWatchdog, stopWatchdog, getServerState } from './watchdog.js'
import { LagMonitor } from './utils/lag-monitor.js'
import { getRules, addRule, updateRule, deleteRule, updateSettings, checkRules } from './autodownloader.js'

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üìä Lag Monitor v2.3: Detect event loop blocking
// Auto-detects production mode for adaptive thresholds
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const lagMonitor = new LagMonitor()  // v2.3: auto-detects prod/dev
lagMonitor.start()

dotenv.config()

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const app = express()
const PORT = process.env.PORT || 3000

// Middleware
app.use(cors())
app.use(express.json())

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üõ°Ô∏è Rate Limiting (Zero-Dependency)
// 30 requests per minute per IP for /api/* routes
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const rateLimitMap = new Map()
const RATE_LIMIT_WINDOW_MS = 60 * 1000 // 1 minute
const RATE_LIMIT_MAX = 300 // üî• v2.4: increased from 60 to handle bulk poster loading

// ‚úÖ FIX: –°–æ—Ö—Ä–∞–Ω—è–µ–º ID –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –ø—Ä–∏ shutdown
let rateLimitCleanupId = null

// Cleanup old entries every 5 minutes
rateLimitCleanupId = setInterval(() => {
    const now = Date.now()
    for (const [ip, data] of rateLimitMap.entries()) {
        if (now - data.windowStart > RATE_LIMIT_WINDOW_MS * 2) {
            rateLimitMap.delete(ip)
        }
    }
}, 5 * 60 * 1000)

app.use('/api/', (req, res, next) => {
    // üî• Skip rate limiting for proxy requests (posters)
    if (req.path.startsWith('/proxy')) {
        return next()
    }

    const ip = req.ip || req.connection.remoteAddress || 'unknown'
    const now = Date.now()

    let entry = rateLimitMap.get(ip)
    if (!entry || now - entry.windowStart > RATE_LIMIT_WINDOW_MS) {
        // New window
        entry = { windowStart: now, count: 1 }
        rateLimitMap.set(ip, entry)
    } else {
        entry.count++
    }

    // Set rate limit headers
    res.set('X-RateLimit-Limit', RATE_LIMIT_MAX)
    res.set('X-RateLimit-Remaining', Math.max(0, RATE_LIMIT_MAX - entry.count))
    res.set('X-RateLimit-Reset', Math.ceil((entry.windowStart + RATE_LIMIT_WINDOW_MS) / 1000))

    if (entry.count > RATE_LIMIT_MAX) {
        console.warn(`[RateLimit] Too many requests from ${ip}: ${entry.count}`)
        return res.status(429).json({
            error: 'Too many requests',
            retryAfter: Math.ceil((entry.windowStart + RATE_LIMIT_WINDOW_MS - now) / 1000)
        })
    }

    next()
})

// DEBUG: Log all non-static requests
app.use((req, res, next) => {
    if (!req.url.match(/\.(js|css|png|jpg|ico|map)$/)) {
        console.log(`[HTTP] ${req.method} ${req.url}`)
    }
    next()
})

// Serve static frontend
const distPath = path.join(__dirname, '../client/dist')
app.use(express.static(distPath))

// API: Health Check (lightweight)
app.get('/api/health', (req, res) => {
    const state = getServerState()
    res.json({
        serverStatus: state.serverStatus,
        lastStateChange: state.lastStateChange
    })
})

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üè• v2.3.3: Health Endpoint for monitoring systems
// Compatible with: Home Assistant, Uptime Robot, Kubernetes
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
app.get('/health', (req, res) => {
    const state = getServerState()
    const memUsage = process.memoryUsage()
    const ramMB = Math.round(memUsage.rss / 1024 / 1024)

    // Determine health status
    const isHealthy = state.serverStatus === 'ok'
    const isDegraded = state.serverStatus === 'degraded'
    const isUnhealthy = state.serverStatus === 'circuit_open' || state.serverStatus === 'error'

    const healthData = {
        status: isHealthy ? 'healthy' : (isDegraded ? 'degraded' : 'unhealthy'),
        timestamp: new Date().toISOString(),
        uptime: Math.round(process.uptime()),
        version: '2.3.3',
        checks: {
            memory: {
                status: ramMB < 800 ? 'pass' : (ramMB < 1000 ? 'warn' : 'fail'),
                rss_mb: ramMB,
                heap_mb: Math.round(memUsage.heapUsed / 1024 / 1024)
            },
            storage: {
                status: state.serverStatus === 'circuit_open' ? 'fail' : 'pass',
                failures: state.storageFailures || 0
            },
            torrents: {
                active: getActiveTorrentsCount(),
                frozen: getFrozenTorrentsCount()
            }
        }
    }

    // Return appropriate HTTP status
    if (isUnhealthy) {
        res.status(503).json(healthData)
    } else if (isDegraded) {
        res.status(200).json(healthData) // 200 with degraded status
    } else {
        res.status(200).json(healthData)
    }
})

// API: Lag Stats (enhanced performance monitoring v2.3)
app.get('/api/lag-stats', (req, res) => {
    const memUsage = process.memoryUsage()
    const stats = lagMonitor.getStats()

    res.json({
        ...stats,
        // üî• v2.3: Enhanced server diagnostics
        server: {
            uptime: Math.round(process.uptime()),
            nodeVersion: process.version,
            platform: process.platform,
            pid: process.pid,
            ram: {
                rss: Math.round(memUsage.rss / 1024 / 1024),
                heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024),
                heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024),
                external: Math.round(memUsage.external / 1024 / 1024)
            },
            torrents: {
                active: getActiveTorrentsCount(),
                frozen: getFrozenTorrentsCount()
            }
        }
    })
})

// API: Speed Mode (eco/balanced/turbo)
app.post('/api/speed-mode', (req, res) => {
    const { mode } = req.body
    if (!['eco', 'balanced', 'turbo'].includes(mode)) {
        return res.status(400).json({ error: 'Invalid mode. Use: eco, balanced, or turbo' })
    }
    const result = setSpeedMode(mode)
    res.json(result)
})

// API: Status (with server state)
app.get('/api/status', (req, res) => {
    const state = getServerState()

    // Return 503 with Retry-After for critical states
    if (state.serverStatus === 'circuit_open' || state.serverStatus === 'error') {
        res.set('Retry-After', '300') // 5 minutes
        return res.status(503).json({
            serverStatus: state.serverStatus,
            lastStateChange: state.lastStateChange,
            torrents: []
        })
    }

    const torrents = getAllTorrents()
    const status = torrents.map(t => ({
        infoHash: t.infoHash,
        name: t.name,
        progress: t.progress,
        isReady: t.isReady,  // ‚úÖ Fix: –ø–µ—Ä–µ–¥–∞—ë–º isReady –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ UI
        downloaded: t.downloaded,
        totalSize: t.totalSize,
        downloadSpeed: t.downloadSpeed,
        numPeers: t.numPeers,
        eta: t.eta,
        files: t.files.map(f => ({
            name: f.name,
            length: f.length,
            index: f.index
        }))
    }))

    res.json({
        serverStatus: state.serverStatus,
        lastStateChange: state.lastStateChange,
        torrents: status
    })
})

// API: TMDB Proxy with DoH bypass
import { smartFetch, insecureAgent } from './utils/doh.js'
import proxyRouter from './routes/proxy.js'

app.use('/api/proxy', proxyRouter)

const TMDB_API_KEY = process.env.TMDB_API_KEY || ''

app.get('/api/tmdb/search', async (req, res) => {
    const { query } = req.query
    if (!query) return res.status(400).json({ error: 'Query required' })

    // Redirect simple search to new proxy if needed, OR keep logic for backward compatibility
    // For now, keeping legacy logic but using smartFetch (which is already implemented)
    try {
        const url = `https://api.themoviedb.org/3/search/multi?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}&language=ru-RU`
        const response = await smartFetch(url)
        res.json(response.data)
    } catch (err) {
        console.error('[TMDB] Search error:', err.message)
        res.status(502).json({ error: 'TMDB API unavailable', details: err.message })
    }
})

app.get('/api/tmdb/image/:size/:path', async (req, res) => {
    // Legacy image proxy - keeping for backward compatibility
    // New code should use /api/proxy?url=...
    const { size, path: imagePath } = req.params
    try {
        const url = `https://image.tmdb.org/t/p/${size}/${imagePath}`
        const response = await smartFetch(url, { responseType: 'arraybuffer' })
        res.set('Content-Type', response.headers['content-type'] || 'image/jpeg')
        res.set('Cache-Control', 'public, max-age=86400')
        res.send(response.data)
    } catch (err) {
        console.error('[TMDB] Image error:', err.message)
        res.status(502).send('Image unavailable')
    }
})
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üîç API v2: Unified Torrent Search (Aggregator + Envelope)
// Stage 5: Client/PWA Improvements
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

import { search as aggregatorSearch, getProvidersStatus } from './aggregator.js'

/**
 * API v2 Search with envelope response pattern
 * Response format:
 * {
 *   meta: { query, cached, ms, providers: { [name]: { status, count, error? } } },
 *   items: AggregatedSearchItem[]
 * }
 */
app.get('/api/v2/search', async (req, res) => {
    const { query, limit = 100 } = req.query
    if (!query) {
        return res.status(400).json({ error: 'Query required' })
    }

    console.log(`[API v2] Search: ${query}`)
    const startTime = Date.now()

    try {
        const { results, errors, providers, cached } = await aggregatorSearch(query)

        // Transform providers to StatusMap with enhanced info
        const providersMeta = {}
        for (const [name, data] of Object.entries(providers)) {
            providersMeta[name] = {
                status: data.status,
                count: data.count || 0,
                error: data.error || null
            }
        }

        const limitedResults = results.slice(0, parseInt(limit, 10))

        res.json({
            meta: {
                query,
                cached,
                ms: Date.now() - startTime,
                totalResults: results.length,
                returnedResults: limitedResults.length,
                providers: providersMeta
            },
            items: limitedResults
        })
    } catch (err) {
        console.error('[API v2] Search error:', err)
        res.status(500).json({
            error: 'Search failed',
            details: err.message,
            meta: { query, ms: Date.now() - startTime, providers: {} },
            items: []
        })
    }
})

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// BUG-03: Provider Status API for real-time UI sync
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
app.get('/api/providers/status', (req, res) => {
    const status = getProvidersStatus()
    res.json({
        providers: status,
        timestamp: Date.now()
    })
})

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üîç API v1: Legacy Jacred Search (DEPRECATED - use /api/v2/search)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

import { searchJacred, getMagnetFromJacred } from './jacred.js'

// DEPRECATED: Search torrents via Jacred only
app.get('/api/rutracker/search', async (req, res) => {
    const { query } = req.query
    if (!query) {
        return res.status(400).json({ error: 'Query required' })
    }

    // Deprecation warning in logs
    console.warn(`[DEPRECATED] /api/rutracker/search called - migrate to /api/v2/search. Query: ${query}`)

    const result = await searchJacred(query)
    res.json(result)
})

// Get magnet link (already in search results, but keeping for compatibility)
app.get('/api/rutracker/magnet/:topicId', async (req, res) => {
    const { topicId } = req.params
    // topicId is actually the magnet URL for Jacred
    const result = await getMagnetFromJacred(decodeURIComponent(topicId))
    res.json(result)
})

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Debug API: View and manage persisted torrents in DB
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// View all torrents saved in db.json
app.get('/api/db/torrents', async (req, res) => {
    await db.read()
    const torrents = db.data.torrents || []
    res.json({
        count: torrents.length,
        torrents: torrents.map(t => ({
            name: t.name,
            addedAt: t.addedAt,
            magnetPreview: t.magnet.substring(0, 80) + '...'
        }))
    })
})

// Force remove a torrent from DB by partial hash match
app.delete('/api/db/torrents/:hash', async (req, res) => {
    const { hash } = req.params
    await db.read()

    const before = db.data.torrents?.length || 0
    const hashLower = hash.toLowerCase()

    db.data.torrents = (db.data.torrents || []).filter(t => {
        const magnetLower = t.magnet.toLowerCase()
        return !magnetLower.includes(hashLower)
    })

    const removed = before - db.data.torrents.length

    if (removed > 0) {
        await safeWrite(db)
        console.log(`[DB API] Force removed ${removed} torrent(s) by hash: ${hash}`)
        res.json({ success: true, removed })
    } else {
        res.status(404).json({ error: 'No matching torrent found in DB', hash })
    }
})

// Clear ALL torrents from DB (nuclear option)
app.delete('/api/db/torrents', async (req, res) => {
    await db.read()
    const count = db.data.torrents?.length || 0
    db.data.torrents = []
    await safeWrite(db)
    console.log(`[DB API] Cleared ALL ${count} torrents from DB`)
    res.json({ success: true, cleared: count })
})

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üì∫ Auto-Downloader API: Manage auto-download rules
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Get all rules and settings
app.get('/api/autodownload/rules', async (req, res) => {
    try {
        const data = await getRules()
        res.json(data)
    } catch (err) {
        res.status(500).json({ error: err.message })
    }
})

// Add new rule
app.post('/api/autodownload/rules', async (req, res) => {
    const { query, resolution, group, season, lastEpisode } = req.body
    if (!query) {
        return res.status(400).json({ error: 'Query (series name) is required' })
    }
    try {
        const rule = await addRule({ query, resolution, group, season, lastEpisode })
        res.json(rule)
    } catch (err) {
        res.status(500).json({ error: err.message })
    }
})

// Update rule
app.put('/api/autodownload/rules/:id', async (req, res) => {
    const id = parseInt(req.params.id, 10)
    try {
        const rule = await updateRule(id, req.body)
        res.json(rule)
    } catch (err) {
        res.status(err.message === 'Rule not found' ? 404 : 500).json({ error: err.message })
    }
})

// Delete rule
app.delete('/api/autodownload/rules/:id', async (req, res) => {
    const id = parseInt(req.params.id, 10)
    const deleted = await deleteRule(id)
    if (deleted) {
        res.json({ success: true })
    } else {
        res.status(404).json({ error: 'Rule not found' })
    }
})

// Update global settings (enable/disable, interval)
app.put('/api/autodownload/settings', async (req, res) => {
    try {
        const settings = await updateSettings(req.body)
        res.json(settings)
    } catch (err) {
        res.status(500).json({ error: err.message })
    }
})

// Trigger manual check
app.post('/api/autodownload/check', async (req, res) => {
    try {
        const result = await checkRules()
        res.json(result)
    } catch (err) {
        res.status(500).json({ error: err.message })
    }
})

// API: Generate M3U Playlist for Video Files
// Helper: sanitize filename for M3U metadata (remove newlines and control chars)
const sanitizeM3U = (str) => str.replace(/[\r\n\x00-\x1f]/g, ' ').trim()

app.get('/playlist.m3u', (req, res) => {
    // 1. Determine Host (Synology IP or Localhost)
    const host = req.get('host') || `localhost:${PORT}`
    const protocol = req.protocol || 'http'

    // 2. Get All Torrents
    const torrents = getAllTorrents()

    let m3u = '#EXTM3U\n'
    const videoExtensions = ['.mp4', '.mkv', '.avi', '.webm', '.mov', '.mpg', '.mpeg']

    // 3. Filter & Generate
    for (const torrent of torrents) {
        if (!torrent.files) continue;

        for (const file of torrent.files) {
            const ext = path.extname(file.name).toLowerCase()
            if (videoExtensions.includes(ext)) {
                // Metadata for player
                // Use -1 for live/unknown duration, or try to guess if available
                m3u += `#EXTINF:-1,${sanitizeM3U(file.name)}\n`

                // Stream URL: http://<NAS_IP>:3000/stream/<HASH>/<INDEX>
                m3u += `${protocol}://${host}/stream/${torrent.infoHash}/${file.index}\n`
            }
        }
    }

    res.set('Content-Type', 'audio/x-mpegurl')
    res.set('Content-Disposition', 'attachment; filename="playlist.m3u"')
    res.send(m3u)
})

// API: Add Torrent
app.post('/api/add', async (req, res) => {
    const { magnet } = req.body
    if (!magnet) return res.status(400).json({ error: 'Magnet URI required' })

    try {
        const torrent = await addTorrent(magnet)
        res.json({ infoHash: torrent.infoHash, name: torrent.name })
    } catch (err) {
        res.status(500).json({ error: err.message })
    }
})

// Map of MIME types
const mimeMap = {
    '.mp4': 'video/mp4',
    '.mkv': 'video/x-matroska',
    '.webm': 'video/webm',
    '.avi': 'video/avi',
    '.mov': 'video/quicktime',
    '.mpg': 'video/mpeg',
    '.mpeg': 'video/mpeg'
}

// API: Remove Torrent (with File Hygiene)
app.delete('/api/delete/:infoHash', async (req, res) => {
    const { infoHash } = req.params
    const torrent = getTorrent(infoHash) // Get info BEFORE deletion

    const success = removeTorrent(infoHash)

    if (success) {
        // üî• PHYSICAL DELETION (FILE HYGIENE - ASYNC) üî•
        if (torrent && torrent.name) {
            const downloadPath = process.env.DOWNLOAD_PATH || './downloads'
            const fullPath = path.join(downloadPath, torrent.name)

            // Fire-and-forget async deletion to avoid blocking the server
            fsPromises.rm(fullPath, { recursive: true, force: true })
                .then(() => console.log(`[File Hygiene] Successfully removed: ${fullPath}`))
                .catch(e => console.error(`[Delete Error] Could not remove ${fullPath}: ${e.message}`))
        }
        res.json({ success: true, message: 'Deletion started asynchronously' })
    } else {
        res.status(404).json({ error: 'Torrent not found' })
    }
})

// API: Stream
app.get('/stream/:infoHash/:fileIndex', async (req, res) => {
    const { infoHash, fileIndex } = req.params
    const range = req.headers.range

    // üî• ACTIVATE TURBO MODE when user starts watching
    boostTorrent(infoHash)

    // Use raw engine to access createReadStream
    const engine = getRawTorrent(infoHash)
    if (!engine) return res.status(404).send('Torrent not found')

    const file = engine.files?.[fileIndex]
    if (!file) return res.status(404).send('File not found')

    // Smart Priority: Prioritize this file's first chunks for instant playback
    prioritizeFile(infoHash, parseInt(fileIndex, 10))

    // Detect Content-Type
    const ext = path.extname(file.name).toLowerCase()
    const contentType = mimeMap[ext] || 'application/octet-stream'

    // Note: Download path check moved to startup (cached)

    if (!range) {
        const head = {
            'Content-Length': file.length,
            'Content-Type': contentType,
        }
        res.writeHead(200, head)
        file.createReadStream().pipe(res)
    } else {
        const parts = range.replace(/bytes=/, "").split("-")
        const start = parseInt(parts[0], 10)
        const end = parts[1] ? parseInt(parts[1], 10) : file.length - 1
        const chunksize = (end - start) + 1

        // üî• READAHEAD: Prioritize chunks starting from seek position
        // This ensures smooth playback after seeking
        readahead(infoHash, parseInt(fileIndex, 10), start)

        // Smart Progress Tracking
        const duration = parseFloat(req.query.duration) || 0
        const progressTime = duration > 0 ? (start / file.length) * duration : 0

        // üî• Debounced DB save (fire-and-forget, no await)
        const trackKey = `${infoHash}_${fileIndex}`
        const now = Date.now()
        const lastUpdate = db.data.progress[trackKey]?.timestamp || 0

        if (now - lastUpdate > 10000) {
            db.data.progress[trackKey] = {
                timestamp: now,
                position: start,
                progressTime: progressTime,
                percentage: (start / file.length) * 100
            }
            // Fire-and-forget: don't block streaming
            safeWrite(db)
        }

        const head = {
            'Content-Range': `bytes ${start}-${end}/${file.length}`,
            'Accept-Ranges': 'bytes',
            'Content-Length': chunksize,
            'Content-Type': contentType,
        }

        res.writeHead(206, head)

        // CRITICAL: Cleanup stream on client disconnect to prevent resource leaks
        const stream = file.createReadStream({ start, end })

        // ‚úÖ FIX: –§—É–Ω–∫—Ü–∏—è –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –æ—á–∏—Å—Ç–∫–∏ —Å—Ç—Ä–∏–º–∞
        const cleanup = () => {
            if (!stream.destroyed) {
                stream.destroy()
            }
        }

        // üî• v2.3: Handle stream errors to prevent hanging responses
        stream.on('error', (err) => {
            console.error(`[Stream] Error for ${infoHash}/${fileIndex}:`, err.message)
            cleanup()
            if (!res.headersSent) {
                res.status(500).send('Stream error')
            }
        })

        // ‚úÖ FIX: –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–æ–º
        res.on('close', cleanup)
        res.on('error', cleanup)

        stream.pipe(res)
    }
})

// Fallback for SPA (index.html existence cached at startup)
let indexHtmlExists = false
try {
    indexHtmlExists = fs.existsSync(path.join(distPath, 'index.html'))
} catch (e) { }

app.get('*', (req, res) => {
    if (indexHtmlExists) {
        res.sendFile(path.join(distPath, 'index.html'))
    } else {
        res.send('Frontend not built. Run npm run client:build')
    }
})

const server = app.listen(PORT, '0.0.0.0', () => {
    console.log(`Server running on http://0.0.0.0:${PORT}`)

    // Restore saved torrents from db.json
    restoreTorrents().catch(err => {
        console.error('[Server] Restore failed:', err.message)
    })

    // Start watchdog in background (non-blocking)
    startWatchdog().catch(err => {
        console.error('[Server] Watchdog failed:', err.message)
    })
})

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üõë Graceful Shutdown
// Handles: Docker stop, NAS restart, Ctrl+C
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let isShuttingDown = false

const gracefulShutdown = async (signal) => {
    if (isShuttingDown) return
    isShuttingDown = true

    console.log(`\n[Shutdown] Received ${signal}, starting graceful shutdown...`)

    // ‚úÖ FIX: –û—á–∏—â–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª rate limit cleanup
    if (rateLimitCleanupId) {
        clearInterval(rateLimitCleanupId)
        rateLimitCleanupId = null
    }

    // 1. Stop accepting new connections
    server.close(() => {
        console.log('[Shutdown] HTTP server closed')
    })

    // 2. Stop watchdog and lag monitor
    stopWatchdog()
    lagMonitor.stop()

    // 3. Destroy all torrent engines
    destroyAllTorrents()

    // 4. Save DB state
    try {
        await safeWrite(db)
        console.log('[Shutdown] Database saved')
    } catch (e) {
        console.error('[Shutdown] DB save failed:', e.message)
    }

    console.log('[Shutdown] Cleanup complete, exiting...')
    process.exit(0)
}

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'))
process.on('SIGINT', () => gracefulShutdown('SIGINT'))

```

---

## server/jacred.js

```javascript
/**
 * Jacred Torrent Search API - LEGACY WRAPPER
 * PWA-TorServe v2.7.0
 * 
 * This module now wraps JacredProvider for backward compatibility.
 * New code should use:
 * - aggregator.search() for multi-source search
 * - JacredProvider directly for Jacred-only access
 * 
 * Security note: SSL validation disabled for Jacred mirrors
 * (see JacredProvider.js for details)
 */

import { JacredProvider } from './providers/JacredProvider.js'

// Singleton provider instance for backward compatibility
const _provider = new JacredProvider()

/**
 * Search torrents via Jacred API
 * @deprecated Use aggregator.search() for multi-source, or JacredProvider for direct
 * @param {string} query
 * @returns {Promise<{results: Array}|{error: string, results: []}>}
 */
export const searchJacred = async (query) => {
    const results = await _provider.search(query)
    if (results.length > 0) {
        return { results }
    }
    return { error: 'No results', results: [] }
}

/**
 * Get magnet from result (already included in search results)
 * @param {string} magnetUrl
 * @returns {Promise<{magnet: string}|{error: string}>}
 */
export const getMagnetFromJacred = async (magnetUrl) => {
    return _provider.getMagnet(magnetUrl)
}

```

---

## server/providers/BaseProvider.js

```javascript
/**
 * BaseProvider - Abstract base class for torrent search providers
 * PWA-TorServe Provider Architecture
 * 
 * All providers must implement:
 * - search(query) ‚Üí Promise<SearchResult[]>
 * - getMagnet(id) ‚Üí Promise<{magnet}|{error}>
 * 
 * SearchResult format:
 * {
 *   id: string,           // Unique identifier (can be guid, topic id, etc.)
 *   title: string,        // Torrent title
 *   size: string,         // Human-readable size (e.g., "1.5 GB")
 *   sizeBytes: number,    // Size in bytes (for sorting/filtering)
 *   seeders: number,      // Number of seeders
 *   tracker: string,      // Tracker name
 *   magnet: string|null,  // Magnet link (if available immediately)
 *   provider: string      // Provider name (for deduplication/logging)
 * }
 */

export class BaseProvider {
    /** Provider name (used in logs and results) */
    name = 'base'

    /** Whether provider is enabled */
    enabled = true

    /** Provider-specific configuration */
    config = {}

    /**
     * Search for torrents
     * @param {string} query - Search query
     * @returns {Promise<Array>} Array of SearchResult objects
     */
    async search(query) {
        throw new Error('search() must be implemented by subclass')
    }

    /**
     * Get magnet link for a specific torrent
     * @param {string} id - Torrent identifier
     * @returns {Promise<{magnet: string}|{error: string}>}
     */
    async getMagnet(id) {
        throw new Error('getMagnet() must be implemented by subclass')
    }

    /**
     * Check if provider is healthy and ready to accept requests
     * @returns {boolean}
     */
    isHealthy() {
        return this.enabled
    }

    /**
     * Normalize result to standard SearchResult format (API v2)
     * @param {Object} raw - Raw result from provider
     * @returns {Object} Normalized SearchResult with dateTs, tags, and health
     */
    normalizeResult(raw) {
        const seeders = raw.seeders || 0
        return {
            id: raw.id || String(Math.random()),
            title: raw.title || 'Unknown',
            size: raw.size || 'N/A',
            sizeBytes: raw.sizeBytes || raw.Size || 0,
            dateTs: this.parseDate(raw.date),
            tags: this.extractQualityTags(raw.title),
            seeders: seeders,
            health: this.calculateHealth(seeders),
            tracker: raw.tracker || this.name,
            magnet: raw.magnet || raw.magnetUrl || null,
            provider: this.name
        }
    }

    /**
     * Calculate torrent health based on seeders count
     * UX-02: Visual indicator for download reliability
     * @param {number} seeders
     * @returns {'excellent'|'good'|'poor'|'dead'}
     */
    calculateHealth(seeders) {
        if (seeders >= 50) return 'excellent'  // üü¢ Fast download
        if (seeders >= 10) return 'good'       // üü° Reliable
        if (seeders >= 1) return 'poor'        // üü† Slow but possible
        return 'dead'                          // üî¥ No sources
    }


    /**
     * Parse various date formats to Unix timestamp (milliseconds)
     * Supports: Unix timestamp (seconds), ISO strings, Date objects
     * @param {number|string|Date|null} dateValue
     * @returns {number|null} Unix timestamp in milliseconds, or null
     */
    parseDate(dateValue) {
        if (!dateValue) return null

        // Unix timestamp in seconds (Jacred API format)
        if (typeof dateValue === 'number') {
            // If it looks like seconds (before year 3000), convert to ms
            return dateValue < 32503680000 ? dateValue * 1000 : dateValue
        }

        // ISO string "2025-01-15T12:30:00Z" or other parseable formats
        if (typeof dateValue === 'string') {
            const parsed = Date.parse(dateValue)
            if (!isNaN(parsed)) return parsed
        }

        // Date object
        if (dateValue instanceof Date) {
            return dateValue.getTime()
        }

        return null
    }

    /**
     * Extract quality tags from torrent title
     * Uses strict regex patterns to minimize false positives
     * @param {string} title
     * @returns {string[]} Array of quality tags: ['2160p', '1080p', '720p', 'hevc', 'hdr', 'cam']
     */
    extractQualityTags(title) {
        if (!title) return []

        const tags = []
        const upper = title.toUpperCase()

        // Resolution detection (mutually exclusive, highest wins)
        if (/\b2160[p—ÄP–†]\b/.test(title) || /\b4K\b/i.test(title) || /\bUHD\b/i.test(title)) {
            tags.push('2160p')
        } else if (/\b1080[p—ÄP–†]\b/.test(title)) {
            tags.push('1080p')
        } else if (/\b720[p—ÄP–†]\b/.test(title)) {
            tags.push('720p')
        }

        // Codec detection
        if (/\b(HEVC|H\.?265|x265)\b/i.test(title)) {
            tags.push('hevc')
        }

        // HDR detection (exclude HDRip which is different)
        if (/\bHDR(10)?(\+|Plus)?\b/i.test(title) && !/\bHDRip\b/i.test(title)) {
            tags.push('hdr')
        }

        // Dolby Vision
        if (/\b(DV|Dolby\s*Vision)\b/i.test(title)) {
            tags.push('dv')
        }

        // Low quality indicators
        if (/\b(CAMRip|CAM|HDTS|TS|Telesync|TC)\b/i.test(title)) {
            tags.push('cam')
        }

        return tags
    }
}

/**
 * Format bytes to human-readable string
 * @param {number} bytes
 * @returns {string}
 */
export function formatSize(bytes) {
    if (!bytes) return 'N/A'
    const units = ['B', 'KB', 'MB', 'GB', 'TB']
    let i = 0
    let size = bytes
    while (size >= 1024 && i < units.length - 1) {
        size /= 1024
        i++
    }
    return `${size.toFixed(1)} ${units[i]}`
}

```

---

## server/providers/JacredProvider.js

```javascript
/**
 * JacredProvider - Jacred torrent search provider
 * PWA-TorServe Provider Architecture
 * 
 * Implements Jacred API search with:
 * - Mirror rotation
 * - User-Agent rotation
 * - Retry with exponential backoff
 * - Rate limiting (429) handling
 * 
 * Security note: SSL validation disabled for Jacred mirrors
 * (see header comments in original jacred.js for explanation)
 */

import https from 'https'
import http from 'http'
import { BaseProvider, formatSize } from './BaseProvider.js'
import { logger } from '../utils/logger.js'
import { withRetry, retryPredicates } from '../utils/retry.js'

const log = logger.child('JacredProvider')

// Jacred mirrors (only working ones)
const JACRED_MIRRORS = [
    { host: 'jacred.xyz', port: 443, protocol: 'https' },
    { host: 'jacred.xyz', port: 80, protocol: 'http' },
]

// User-Agent rotation to avoid rate limiting
const USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1',
]

const getRandomUserAgent = () => USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)]
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms))

export class JacredProvider extends BaseProvider {
    name = 'jacred'

    constructor() {
        super()
        this.currentMirror = JACRED_MIRRORS[0].host
    }

    /**
     * Search torrents via Jacred API
     * @param {string} query
     * @returns {Promise<Array>} Normalized SearchResult[]
     */
    async search(query) {
        log.info('üîç Starting search', { query, mirrorsCount: JACRED_MIRRORS.length })

        for (let i = 0; i < JACRED_MIRRORS.length; i++) {
            const mirror = JACRED_MIRRORS[i]
            const mirrorId = `${mirror.protocol}://${mirror.host}:${mirror.port}`
            log.info('Trying mirror', { mirror: mirrorId, attempt: i + 1 })

            try {
                const data = await withRetry(() => this._doSearch(mirror, query), {
                    maxRetries: 3,
                    baseDelayMs: 5000,
                    shouldRetry: (err) => {
                        if (err.message.includes('Rate limited')) return true
                        return retryPredicates.transient(err)
                    },
                    onRetry: (err, attempt, delay) => {
                        log.warn('Mirror retry', { mirror: mirrorId, attempt, delay: Math.round(delay), error: err.message })
                    }
                })

                if (data && data.length > 0) {
                    this.currentMirror = mirror.host
                    log.info('‚úÖ Mirror connected', { mirror: mirrorId, resultsCount: data.length })
                    return data
                } else {
                    log.warn('Mirror returned empty results', { mirror: mirrorId })
                }
            } catch (err) {
                log.warn('‚ùå Mirror failed', { mirror: mirrorId, error: err.message })
            }

            if (i < JACRED_MIRRORS.length - 1) {
                await sleep(500)
            }
        }

        log.error('‚ùå All mirrors failed', { query, triedMirrors: JACRED_MIRRORS.length })
        return []
    }

    /**
     * Get magnet from result (already included in search results)
     * @param {string} magnetUrl
     * @returns {Promise<{magnet: string}|{error: string}>}
     */
    async getMagnet(magnetUrl) {
        if (magnetUrl && magnetUrl.startsWith('magnet:')) {
            return { magnet: magnetUrl }
        }
        return { error: 'No magnet link' }
    }

    /**
     * Do search request to specific mirror
     * @private
     */
    _doSearch(mirror, query, redirectCount = 0) {
        const MAX_REDIRECTS = 3

        return new Promise((resolve, reject) => {
            const searchPath = `/api/v2.0/indexers/all/results?apikey=&Query=${encodeURIComponent(query)}`

            const options = {
                hostname: mirror.host,
                port: mirror.port,
                path: searchPath,
                method: 'GET',
                rejectUnauthorized: false,
                headers: {
                    'User-Agent': getRandomUserAgent(),
                    'Accept': 'application/json'
                },
                timeout: 15000
            }

            const protocol = mirror.protocol === 'https' ? https : http

            const req = protocol.request(options, (res) => {
                // Handle redirects
                if ([301, 302, 307, 308].includes(res.statusCode) && res.headers.location) {
                    if (redirectCount >= MAX_REDIRECTS) {
                        reject(new Error('Too many redirects'))
                        return
                    }

                    try {
                        const redirectUrl = new URL(res.headers.location, `${mirror.protocol}://${mirror.host}`)
                        const newMirror = {
                            host: redirectUrl.hostname,
                            port: redirectUrl.port || (redirectUrl.protocol === 'https:' ? 443 : 80),
                            protocol: redirectUrl.protocol.replace(':', '')
                        }
                        log.debug('Following redirect', { to: redirectUrl.href })
                        resolve(this._doSearch(newMirror, query, redirectCount + 1))
                    } catch (e) {
                        reject(new Error(`Invalid redirect: ${res.headers.location}`))
                    }
                    return
                }

                // Handle rate limiting
                if (res.statusCode === 429) {
                    const retryAfter = parseInt(res.headers['retry-after'] || '5', 10)
                    reject(new Error(`Rate limited (retry after ${retryAfter}s)`))
                    return
                }

                if (res.statusCode !== 200) {
                    reject(new Error(`HTTP ${res.statusCode}`))
                    return
                }

                let data = ''
                res.setEncoding('utf8')

                res.on('data', chunk => data += chunk)
                res.on('end', () => {
                    try {
                        if (data.trim().startsWith('<')) {
                            reject(new Error('Received HTML instead of JSON (possible Cloudflare block)'))
                            return
                        }

                        const json = JSON.parse(data)
                        const results = (json.Results || json.results || []).slice(0, 50).map(r =>
                            this.normalizeResult({
                                id: r.Guid || r.guid || Math.random().toString(36),
                                title: r.Title || r.title || 'Unknown',
                                size: formatSize(r.Size || r.size || 0),
                                sizeBytes: r.Size || r.size || 0,
                                date: r.PublishDate || r.publishDate || null,  // API v2: date support
                                seeders: r.Seeders || r.seeders || 0,
                                tracker: r.Tracker || r.tracker || 'Unknown',
                                magnet: r.MagnetUri || r.magnetUri || r.Link || r.link || null
                            })
                        )
                        resolve(results)
                    } catch (err) {
                        reject(new Error('Parse error: ' + err.message))
                    }
                })
            })

            req.on('error', reject)
            req.on('timeout', () => {
                req.destroy()
                reject(new Error('Timeout'))
            })

            req.end()
        })
    }
}

```

---

## server/providers/ProviderManager.js

```javascript
/**
 * ProviderManager - Registry and coordinator for torrent providers
 * PWA-TorServe Provider Architecture
 * 
 * Manages provider registration, enables/disables, and health status.
 */

import { logger } from '../utils/logger.js'

const log = logger.child('ProviderManager')

class ProviderManager {
    constructor() {
        /** @type {Map<string, import('./BaseProvider.js').BaseProvider>} */
        this.providers = new Map()
    }

    /**
     * Register a provider instance
     * @param {import('./BaseProvider.js').BaseProvider} provider
     */
    register(provider) {
        if (!provider.name) {
            throw new Error('Provider must have a name')
        }

        this.providers.set(provider.name, provider)
        log.info('Provider registered', {
            name: provider.name,
            enabled: provider.enabled
        })
    }

    /**
     * Get provider by name
     * @param {string} name
     * @returns {import('./BaseProvider.js').BaseProvider|undefined}
     */
    get(name) {
        return this.providers.get(name)
    }

    /**
     * Get all enabled and healthy providers
     * @returns {import('./BaseProvider.js').BaseProvider[]}
     */
    getEnabled() {
        return Array.from(this.providers.values())
            .filter(p => p.enabled && p.isHealthy())
    }

    /**
     * Get all registered providers
     * @returns {import('./BaseProvider.js').BaseProvider[]}
     */
    getAll() {
        return Array.from(this.providers.values())
    }

    /**
     * Enable or disable a provider
     * @param {string} name
     * @param {boolean} enabled
     */
    setEnabled(name, enabled) {
        const provider = this.providers.get(name)
        if (provider) {
            provider.enabled = enabled
            log.info('Provider state changed', { name, enabled })
        }
    }

    /**
     * Get status of all providers
     * @returns {Object[]}
     */
    getStatus() {
        return Array.from(this.providers.values()).map(p => ({
            name: p.name,
            enabled: p.enabled,
            healthy: p.isHealthy()
        }))
    }
}

// Singleton instance
export const providerManager = new ProviderManager()

```

---

## server/providers/RuTrackerProvider.js

```javascript
/**
 * RuTrackerProvider - RuTracker torrent search provider
 * PWA-TorServe Provider Architecture v2.7.2
 * 
 * Implements RuTracker search with:
 * - Mirror rotation (rutracker.org, .nl, .net, .cc)
 * - Smart Fetch (DoH + SNI Bypass) for ISP blocking resilience
 * - Cookie-based authentication
 * - HTML parsing via regex (no external deps)
 * 
 * Requires RUTRACKER_LOGIN and RUTRACKER_PASSWORD in .env
 */

import fs from 'fs'
import path from 'path'
import { BaseProvider } from './BaseProvider.js'
import { logger } from '../utils/logger.js'
import { smartFetch } from '../utils/doh.js'

const log = logger.child('RuTrackerProvider')

// RuTracker mirrors (in order of preference)
const RUTRACKER_MIRRORS = [
    'rutracker.org',   // Primary
    'rutracker.nl',    // Netherlands mirror  
    'rutracker.net',   // Alternative
]

// Session persistence file
const SESSION_FILE = path.join(process.cwd(), 'data', 'rutracker-session.json')

export class RuTrackerProvider extends BaseProvider {
    name = 'rutracker'

    constructor() {
        super()
        this.sessionCookie = null
        this.currentMirror = RUTRACKER_MIRRORS[0]
        this.login = process.env.RUTRACKER_LOGIN || ''
        this.password = process.env.RUTRACKER_PASSWORD || ''

        if (!this.login || !this.password) {
            // FIX-02: Unblock - Warn only, do not disable
            log.warn('RuTracker: RUTRACKER_LOGIN/PASSWORD not set. Search may fail or return empty results.')
        } else {
            // Try to load persisted session
            this._loadSession()
        }
    }

    isHealthy() {
        // FIX-02: Unblock - Provider is healthy even if no credentials (will attempt guest search or fail gracefully)
        return this.enabled
    }

    /**
     * Load session from file
     * @private
     */
    _loadSession() {
        try {
            if (fs.existsSync(SESSION_FILE)) {
                const data = JSON.parse(fs.readFileSync(SESSION_FILE, 'utf8'))
                if (data.cookie && data.expires > Date.now()) {
                    this.sessionCookie = data.cookie
                    this.currentMirror = data.mirror || RUTRACKER_MIRRORS[0]
                    log.info('Session loaded from file', { expires: new Date(data.expires).toISOString() })
                } else {
                    log.debug('Session expired, will re-login')
                }
            }
        } catch (e) {
            log.debug('No saved session', { error: e.message })
        }
    }

    /**
     * Save session to file
     * @private
     */
    _saveSession() {
        try {
            const dir = path.dirname(SESSION_FILE)
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true })
            }
            const data = {
                cookie: this.sessionCookie,
                mirror: this.currentMirror,
                expires: Date.now() + 24 * 60 * 60 * 1000 // 24 hours
            }
            fs.writeFileSync(SESSION_FILE, JSON.stringify(data, null, 2))
            log.debug('Session saved to file')
        } catch (e) {
            log.warn('Failed to save session', { error: e.message })
        }
    }

    /**
     * Search torrents on RuTracker with mirror fallback
     */
    async search(query) {
        if (!this.isHealthy()) {
            log.debug('Skipping search: not healthy')
            return []
        }

        // Try each mirror
        for (const mirror of RUTRACKER_MIRRORS) {
            log.info('Trying mirror', { mirror })
            try {
                // Login if needed
                if (!this.sessionCookie) {
                    log.debug('Logging in...', { mirror })
                    await this._loginToMirror(mirror)
                }

                log.debug('Searching...', { mirror, query })
                const results = await this._searchOnMirror(mirror, query)
                if (results.length > 0) {
                    this.currentMirror = mirror
                    log.info('Search successful', { mirror, count: results.length })
                    return results
                }
                log.warn('Empty results', { mirror })
            } catch (err) {
                log.warn(`Mirror ${mirror} failed`, { error: err.message })
                this.sessionCookie = null // Reset session for next mirror
            }
        }

        log.error('All mirrors failed')
        return []
    }

    /**
     * Get magnet link from topic page
     */
    async getMagnet(topicId) {
        if (!this.sessionCookie) {
            try {
                await this._loginToMirror(this.currentMirror)
            } catch {
                return { error: 'Login failed' }
            }
        }

        try {
            const url = `https://${this.currentMirror}/forum/viewtopic.php?t=${topicId}`
            const response = await smartFetch(url, {
                headers: { 'Cookie': this.sessionCookie },
                timeout: 30000
            })

            const match = response.data.match(/magnet:\?xt=urn:btih:[^"'\s]+/)
            return match ? { magnet: match[0] } : { error: 'Magnet not found' }
        } catch {
            return { error: 'Request failed' }
        }
    }

    /**
     * Login to specific mirror
     * @private
     */
    async _loginToMirror(mirror) {
        const postData = `login_username=${encodeURIComponent(this.login)}&login_password=${encodeURIComponent(this.password)}&login=%C2%F5%EE%E4`

        const url = `https://${mirror}/forum/login.php`

        const response = await smartFetch(url, {
            method: 'POST',
            body: postData,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        })

        const cookies = response.headers['set-cookie']
        if (cookies) {
            this.sessionCookie = cookies.map(c => c.split(';')[0]).join('; ')
            this._saveSession() // Persist session
            log.info('Login successful', { mirror })
            return this.sessionCookie
        } else {
            throw new Error('No cookies received')
        }
    }

    /**
     * Search on specific mirror
     * @private
     */
    async _searchOnMirror(mirror, query) {
        const url = `https://${mirror}/forum/tracker.php?nm=${encodeURIComponent(query)}`

        const response = await smartFetch(url, {
            headers: { 'Cookie': this.sessionCookie },
            timeout: 30000
        })

        return this._parseResults(response.data)
    }

    /**
     * Parse search results HTML
     * @private
     */
    _parseResults(html) {
        const results = []

        const titleRegex = /<a[^>]*class="tLink"[^>]*href="[^"]*t=(\d+)"[^>]*>([^<]+)<\/a>/g
        const sizeRegex = /<td[^>]*class="tor-size"[^>]*>[\s\S]*?<a[^>]*>([^<]+)<\/a>/g
        const seedRegex = /<b class="seedmed">(\d+)<\/b>/g

        const sizes = [], seeds = []
        let match

        while ((match = sizeRegex.exec(html))) sizes.push(match[1].trim())
        while ((match = seedRegex.exec(html))) seeds.push(parseInt(match[1]))

        let i = 0
        while ((match = titleRegex.exec(html)) && i < 20) {
            const topicId = match[1]
            const title = match[2]
                .replace(/&quot;/g, '"')
                .replace(/&amp;/g, '&')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .trim()

            const sizeStr = sizes[i] || 'N/A'
            let sizeBytes = 0
            const sizeMatch = sizeStr.match(/([\d.]+)\s*(GB|MB|KB|TB)/i)
            if (sizeMatch) {
                const num = parseFloat(sizeMatch[1])
                const unit = sizeMatch[2].toUpperCase()
                const mult = { 'KB': 1024, 'MB': 1024 ** 2, 'GB': 1024 ** 3, 'TB': 1024 ** 4 }
                sizeBytes = num * (mult[unit] || 1)
            }

            results.push(this.normalizeResult({
                id: topicId,
                title,
                size: sizeStr,
                sizeBytes,
                seeders: seeds[i] || 0,
                tracker: 'RuTracker',
                magnet: null
            }))
            i++
        }

        return results
    }
}

```

---

## server/providers/RutorProvider.js

```javascript
/**
 * RutorProvider - Rutor.info torrent search provider
 * PWA-TorServe Provider Architecture v2.7.2
 * 
 * Implements Rutor search with:
 * - Mirror rotation (rutor.info, rutor.is)
 * - Smart Fetch (DoH + SNI Bypass) for ISP blocking resilience
 * - HTML parsing via regex (no external deps)
 * - No authentication required (public tracker)
 */

import { BaseProvider, formatSize } from './BaseProvider.js'
import { logger } from '../utils/logger.js'
import { smartFetch } from '../utils/doh.js'

const log = logger.child('RutorProvider')

// Rutor mirrors
const RUTOR_MIRRORS = [
    { host: 'rutor.info', protocol: 'https' },
    { host: 'rutor.is', protocol: 'https' },
]

export class RutorProvider extends BaseProvider {
    name = 'rutor'

    constructor() {
        super()
        this.currentMirror = RUTOR_MIRRORS[0]
    }

    /**
     * Search torrents on Rutor with mirror fallback
     */
    async search(query) {
        log.info('üîç Starting search', { query, mirrorsCount: RUTOR_MIRRORS.length })

        for (const mirror of RUTOR_MIRRORS) {
            const mirrorId = `${mirror.protocol}://${mirror.host}`
            log.info('Trying mirror', { mirror: mirrorId })

            try {
                const results = await this._doSearch(mirror, query)
                if (results.length > 0) {
                    this.currentMirror = mirror
                    log.info('‚úÖ Search successful', { mirror: mirrorId, count: results.length })
                    return results
                }
                log.warn('Empty results', { mirror: mirrorId })
            } catch (err) {
                log.warn(`Mirror failed`, { mirror: mirrorId, error: err.message })
            }
        }

        log.error('All mirrors failed')
        return []
    }

    /**
     * Get magnet (already in search results)
     */
    async getMagnet(magnetUrl) {
        if (magnetUrl && magnetUrl.startsWith('magnet:')) {
            return { magnet: magnetUrl }
        }
        return { error: 'No magnet link' }
    }

    /**
     * Do search request to specific mirror
     * @private
     */
    async _doSearch(mirror, query) {
        const url = `${mirror.protocol}://${mirror.host}/search/0/0/000/0/${encodeURIComponent(query)}`

        const response = await smartFetch(url, {
            headers: {
                'Accept': 'text/html',
                'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7',
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache'
            },
            timeout: 45000
        })

        return this._parseResults(response.data)
    }

    /**
     * Parse Rutor search results HTML
     * @private
     */
    _parseResults(html) {
        const results = []

        // Rutor HTML structure:
        // <tr class="gai"...> or <tr class="tum"...>
        // Contains: magnet link, title, size, seeders

        // Match table rows with torrent data
        const rowRegex = /<tr[^>]*class="(?:gai|tum)"[^>]*>([\s\S]*?)<\/tr>/gi

        let rowMatch
        while ((rowMatch = rowRegex.exec(html)) !== null && results.length < 30) {
            const rowHtml = rowMatch[1]

            // Extract magnet link
            const magnetMatch = rowHtml.match(/href="(magnet:\?xt=urn:btih:[^"]+)"/i)
            if (!magnetMatch) continue

            const magnet = magnetMatch[1]
                .replace(/&amp;/g, '&')

            // Extract title from the last link before size
            // Pattern: <a href="/torrent/...">Title</a>
            const titleMatch = rowHtml.match(/<a[^>]*href="\/torrent\/\d+[^"]*"[^>]*>([^<]+)<\/a>/i)
            if (!titleMatch) continue

            const title = titleMatch[1]
                .replace(/&quot;/g, '"')
                .replace(/&amp;/g, '&')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .trim()

            // Extract size (format: "1.5 GB" or "500 MB")
            const sizeMatch = rowHtml.match(/>(\d+(?:\.\d+)?\s*(?:GB|MB|KB|TB))</i)
            const sizeStr = sizeMatch ? sizeMatch[1] : 'N/A'

            // Parse size to bytes
            let sizeBytes = 0
            const sizeNumMatch = sizeStr.match(/([\d.]+)\s*(GB|MB|KB|TB)/i)
            if (sizeNumMatch) {
                const num = parseFloat(sizeNumMatch[1])
                const unit = sizeNumMatch[2].toUpperCase()
                const mult = { 'KB': 1024, 'MB': 1024 ** 2, 'GB': 1024 ** 3, 'TB': 1024 ** 4 }
                sizeBytes = num * (mult[unit] || 1)
            }

            // Extract seeders (green number in span)
            const seedMatch = rowHtml.match(/<span[^>]*class="[^"]*green[^"]*"[^>]*>(\d+)<\/span>/i)
            const seeders = seedMatch ? parseInt(seedMatch[1]) : 0

            results.push(this.normalizeResult({
                id: magnet, // Use magnet as ID
                title,
                size: sizeStr,
                sizeBytes,
                seeders,
                tracker: 'Rutor',
                magnet
            }))
        }

        return results
    }
}

```

---

## server/providers/TorLookProvider.js

```javascript
/**
 * TorLookProvider - TorLook.info torrent search provider
 * PWA-TorServe Provider Architecture v2.7.2
 * 
 * TorLook is a torrent aggregator/metasearch engine
 * Implements HTML parsing, no authentication required
 * Updated to use Smart Fetch (DoH) for resilience
 */

import { BaseProvider } from './BaseProvider.js'
import { logger } from '../utils/logger.js'
import { smartFetch } from '../utils/doh.js'

const log = logger.child('TorLookProvider')

const TORLOOK_HOST = 'torlook.info'

export class TorLookProvider extends BaseProvider {
    name = 'torlook'

    /**
     * Search torrents on TorLook
     */
    async search(query) {
        log.info('üîç Starting search', { query })

        try {
            const results = await this._doSearch(query)
            if (results.length > 0) {
                log.info('‚úÖ Search successful', { count: results.length })
            } else {
                log.warn('Empty results')
            }
            return results
        } catch (err) {
            log.warn('Search failed', { error: err.message })
            return []
        }
    }

    /**
     * Get magnet (already in search results)
     */
    async getMagnet(magnetUrl) {
        if (magnetUrl && magnetUrl.startsWith('magnet:')) {
            return { magnet: magnetUrl }
        }
        return { error: 'No magnet link' }
    }

    /**
     * Do search request
     * @private
     */
    async _doSearch(query) {
        const url = `https://${TORLOOK_HOST}/search/${encodeURIComponent(query)}/`

        try {
            const response = await smartFetch(url, {
                headers: {
                    'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7'
                },
                timeout: 30000
            })
            return this._parseResults(response.data)
        } catch (e) {
            // TorLook very often redirects 302 to main page on block, which might cause parse error or timeout
            throw e
        }
    }

    /**
     * Parse TorLook search results HTML
     * @private
     */
    _parseResults(html) {
        const results = []

        // TorLook results are in divs with class "item"
        // Each contains: title, size, seeds, magnet link

        // Match torrent items
        const itemRegex = /<div[^>]*class="[^"]*item[^"]*"[^>]*>([\s\S]*?)<\/div>\s*<\/div>/gi

        let itemMatch
        while ((itemMatch = itemRegex.exec(html)) !== null && results.length < 25) {
            const itemHtml = itemMatch[1]

            // Extract magnet link
            const magnetMatch = itemHtml.match(/href="(magnet:\?xt=urn:btih:[^"]+)"/i)
            if (!magnetMatch) continue

            const magnet = magnetMatch[1].replace(/&amp;/g, '&')

            // Extract title
            const titleMatch = itemHtml.match(/<a[^>]*class="[^"]*title[^"]*"[^>]*>([^<]+)<\/a>/i) ||
                itemHtml.match(/<a[^>]*href="[^"]*"[^>]*title="([^"]+)"/i)
            if (!titleMatch) continue

            const title = titleMatch[1]
                .replace(/&quot;/g, '"')
                .replace(/&amp;/g, '&')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .trim()

            // Extract size
            const sizeMatch = itemHtml.match(/>(\d+(?:\.\d+)?\s*(?:GB|MB|KB|TB))</i)
            const sizeStr = sizeMatch ? sizeMatch[1] : 'N/A'

            // Parse size to bytes
            let sizeBytes = 0
            const sizeNumMatch = sizeStr.match(/([\d.]+)\s*(GB|MB|KB|TB)/i)
            if (sizeNumMatch) {
                const num = parseFloat(sizeNumMatch[1])
                const unit = sizeNumMatch[2].toUpperCase()
                const mult = { 'KB': 1024, 'MB': 1024 ** 2, 'GB': 1024 ** 3, 'TB': 1024 ** 4 }
                sizeBytes = num * (mult[unit] || 1)
            }

            // Extract seeders
            const seedMatch = itemHtml.match(/<span[^>]*class="[^"]*seed[^"]*"[^>]*>(\d+)<\/span>/i)
            const seeders = seedMatch ? parseInt(seedMatch[1]) : 0

            results.push(this.normalizeResult({
                id: magnet,
                title,
                size: sizeStr,
                sizeBytes,
                seeders,
                tracker: 'TorLook',
                magnet
            }))
        }

        return results
    }
}

```

---

## server/providers/index.js

```javascript
/**
 * Provider Index - Exports and auto-registers all providers
 * PWA-TorServe Provider Architecture
 */

export { BaseProvider, formatSize } from './BaseProvider.js'
export { providerManager } from './ProviderManager.js'
export { JacredProvider } from './JacredProvider.js'
export { RuTrackerProvider } from './RuTrackerProvider.js'
export { RutorProvider } from './RutorProvider.js'
export { TorLookProvider } from './TorLookProvider.js'

// Auto-registration of providers
import { providerManager } from './ProviderManager.js'
import { JacredProvider } from './JacredProvider.js'
import { RuTrackerProvider } from './RuTrackerProvider.js'
import { RutorProvider } from './RutorProvider.js'
import { TorLookProvider } from './TorLookProvider.js'

// Register providers on module load
providerManager.register(new JacredProvider())
providerManager.register(new RuTrackerProvider())
providerManager.register(new RutorProvider())
providerManager.register(new TorLookProvider())

```

---

## server/routes/proxy.js

```javascript
import express from 'express';
import { getSmartConfig } from '../utils/doh.js';
import https from 'https';
import { URL } from 'url';

const router = express.Router();

// Allowlist for security (SSRF prevention)
const ALLOWED_DOMAINS = [
    'api.themoviedb.org',
    'image.tmdb.org',
    'kinopoiskapiunofficial.tech',
    'avatars.mds.yandex.net',
    'imagetmdb.com',
    'nl.imagetmdb.com',
    'de.imagetmdb.com',
    'pl.imagetmdb.com',
    'lampa.byskaz.ru'
];

router.get('/', async (req, res) => {
    const { url } = req.query;

    if (!url) {
        return res.status(400).json({ error: 'URL parameter is required' });
    }

    try {
        const targetUrl = new URL(url);

        if (!ALLOWED_DOMAINS.includes(targetUrl.hostname)) {
            console.warn(`[Proxy] üö´ Blocked domain: ${targetUrl.hostname}`);
            return res.status(403).json({ error: 'Domain not allowed' });
        }

        console.log(`[Proxy] üîÑ Fetching: ${url}`);

        // Get DoH resolved config
        const config = await getSmartConfig(url);

        const options = {
            method: 'GET',
            headers: config.headers,
            timeout: 20000,
        };

        // üî• CRITICAL FIX: SNI Support
        // If we have a resolved IP, we use it for the connection but keep the hostname for TLS SNI
        if (config.resolvedIP) {
            options.hostname = config.resolvedIP;
            options.servername = config.hostname; // This is the SNI part
            options.path = targetUrl.pathname + targetUrl.search;
        }

        const proxyReq = https.request(config.resolvedIP ? options : url, (proxyRes) => {
            // Forward status
            res.status(proxyRes.statusCode);

            // Forward allowed headers
            const forwardHeaders = ['content-type', 'content-length', 'cache-control', 'expires', 'last-modified', 'src'];
            console.log(`[Proxy] üì• Response ${proxyRes.statusCode}: ${proxyRes.headers['content-type']}`);
            for (const h of forwardHeaders) {
                if (proxyRes.headers[h]) {
                    res.set(h, proxyRes.headers[h]);
                }
            }

            // Pipe data
            proxyRes.pipe(res);
        });

        proxyReq.on('error', (err) => {
            console.error('[Proxy] Request Error:', err.message, url);
            if (!res.headersSent) {
                res.status(502).json({ error: 'Proxy request failed', details: err.message });
            }
        });

        proxyReq.on('timeout', () => {
            console.error('[Proxy] Timeout:', url);
            proxyReq.destroy();
            if (!res.headersSent) {
                res.status(504).json({ error: 'Proxy timeout' });
            }
        });

        proxyReq.end();

    } catch (err) {
        console.error('[Proxy] Fatal Error:', err.message, url);
        if (!res.headersSent) {
            res.status(500).json({ error: 'Internal proxy error', details: err.message });
        }
    }
});

export default router;

```

---

## server/rutracker.js

```javascript
/**
 * RuTracker Search API - LEGACY WRAPPER
 * PWA-TorServe v2.7.0
 * 
 * This module now wraps RuTrackerProvider for backward compatibility.
 * New code should use:
 * - aggregator.search() for multi-source search
 * - RuTrackerProvider directly for RuTracker-only access
 */

import { RuTrackerProvider } from './providers/RuTrackerProvider.js'

// Singleton provider instance for backward compatibility
const _provider = new RuTrackerProvider()

/**
 * Search RuTracker
 * @deprecated Use aggregator.search() for multi-source, or RuTrackerProvider for direct
 * @param {string} query
 * @returns {Promise<{results: Array}|{error: string, results: []}>}
 */
export const searchRuTracker = async (query) => {
    const results = await _provider.search(query)
    if (results.length > 0) {
        return { results }
    }
    return { error: 'No results', results: [] }
}

/**
 * Get magnet link from topic page
 * @param {string} topicId
 * @returns {Promise<{magnet: string}|{error: string}>}
 */
export const getMagnetLink = async (topicId) => {
    return _provider.getMagnet(topicId)
}

```

---

## server/searchCache.js

```javascript
/**
 * Search Cache - Short-lived cache for search results
 * PWA-TorServe Provider Architecture
 * 
 * Reduces load on providers by caching search results for 5-10 minutes.
 * Uses LRU-like eviction when cache is full.
 */

import { logger } from './utils/logger.js'

const log = logger.child('SearchCache')

// Cache configuration
const CACHE_TTL_MS = 5 * 60 * 1000  // 5 minutes
const MAX_CACHE_SIZE = 100          // Max cached queries

class SearchCache {
    constructor() {
        /** @type {Map<string, {results: Array, expires: number, providers: Object}>} */
        this.cache = new Map()
        this.hits = 0
        this.misses = 0
    }

    /**
     * Generate cache key from query
     * @param {string} query
     * @returns {string}
     */
    _key(query) {
        return query.toLowerCase().trim()
    }

    /**
     * Get cached results if available and not expired
     * @param {string} query
     * @returns {{results: Array, providers: Object}|null}
     */
    get(query) {
        const key = this._key(query)
        const cached = this.cache.get(key)

        if (!cached) {
            this.misses++
            return null
        }

        if (Date.now() > cached.expires) {
            this.cache.delete(key)
            this.misses++
            log.debug('Cache expired', { query: key })
            return null
        }

        this.hits++
        log.debug('Cache hit', { query: key, age: Math.round((cached.expires - Date.now()) / 1000) + 's left' })
        return { results: cached.results, providers: cached.providers }
    }

    /**
     * Store search results in cache
     * @param {string} query
     * @param {Array} results
     * @param {Object} providers
     */
    set(query, results, providers) {
        const key = this._key(query)

        // Evict old entries if cache is full
        if (this.cache.size >= MAX_CACHE_SIZE) {
            this._evictOldest()
        }

        this.cache.set(key, {
            results,
            providers,
            expires: Date.now() + CACHE_TTL_MS
        })

        log.debug('Cache set', { query: key, resultsCount: results.length })
    }

    /**
     * Evict oldest entries (LRU-like)
     * @private
     */
    _evictOldest() {
        const now = Date.now()
        let evicted = 0

        // First, remove expired entries
        for (const [key, value] of this.cache) {
            if (now > value.expires) {
                this.cache.delete(key)
                evicted++
            }
        }

        // If still full, remove oldest 10%
        if (this.cache.size >= MAX_CACHE_SIZE) {
            const toRemove = Math.ceil(MAX_CACHE_SIZE * 0.1)
            const keys = Array.from(this.cache.keys()).slice(0, toRemove)
            keys.forEach(k => this.cache.delete(k))
            evicted += toRemove
        }

        if (evicted > 0) {
            log.debug('Cache evicted', { count: evicted })
        }
    }

    /**
     * Clear all cache
     */
    clear() {
        this.cache.clear()
        log.info('Cache cleared')
    }

    /**
     * Get cache statistics
     * @returns {Object}
     */
    getStats() {
        const total = this.hits + this.misses
        return {
            size: this.cache.size,
            maxSize: MAX_CACHE_SIZE,
            hits: this.hits,
            misses: this.misses,
            hitRate: total > 0 ? Math.round((this.hits / total) * 100) + '%' : 'N/A',
            ttlMinutes: CACHE_TTL_MS / 60000
        }
    }
}

// Singleton instance
export const searchCache = new SearchCache()

```

---

## server/torrent.js

```javascript
import torrentStream from 'torrent-stream'
import process from 'process'
import fs from 'fs'
import fsPromises from 'fs/promises'
import path from 'path'
import { db, safeWrite } from './db.js'

const engines = new Map()

// üî• Best Public Trackers (Tier 1 & 2)
const PUBLIC_TRACKERS = [
    'udp://tracker.opentrackr.org:1337/announce',
    'udp://open.stealth.si:80/announce',
    'udp://tracker.torrent.eu.org:451/announce',
    'udp://tracker.tiny-vps.com:6969/announce',
    'udp://tracker.cyberia.is:6969/announce',
    'udp://tracker.moeking.me:6969/announce',
    'udp://p4p.arenabg.com:1337/announce',
    'udp://explodie.org:6969/announce',
    'http://tracker.gbitt.info:80/announce'
]

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Keep-Alive: Frozen torrents for instant resume (5 min TTL)
// üî• Memory fix: reduced from 30min to 5min, max 3 frozen
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const frozenTorrents = new Map() // infoHash -> { engine, frozenAt, magnetURI }
const FROZEN_TTL = 5 * 60 * 1000 // üî• 5 minutes (was 30)
const MAX_FROZEN_TORRENTS = 3    // üî• Limit frozen count

// ‚úÖ FIX: –°–æ—Ö—Ä–∞–Ω—è–µ–º ID –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –ø—Ä–∏ shutdown
let frozenCleanupIntervalId = null

// Cleanup expired frozen torrents every 2 minutes
function startFrozenCleanup() {
    if (frozenCleanupIntervalId) return // –£–∂–µ –∑–∞–ø—É—â–µ–Ω

    frozenCleanupIntervalId = setInterval(() => {
        const now = Date.now()

        // üî• Memory fix: destroy oldest if over limit
        while (frozenTorrents.size > MAX_FROZEN_TORRENTS) {
            const oldest = [...frozenTorrents.entries()]
                .sort((a, b) => a[1].frozenAt - b[1].frozenAt)[0]
            if (oldest) {
                console.log(`[Keep-Alive] Over limit, destroying oldest: ${oldest[0]}`)
                oldest[1].engine.destroy()
                frozenTorrents.delete(oldest[0])
            }
        }

        for (const [hash, frozen] of frozenTorrents.entries()) {
            if (now - frozen.frozenAt > FROZEN_TTL) {
                console.log(`[Keep-Alive] Expired, destroying: ${hash}`)
                frozen.engine.destroy()
                frozenTorrents.delete(hash)
            }
        }
    }, 2 * 60 * 1000) // Check every 2 minutes

    console.log('[Keep-Alive] Cleanup interval started')
}

// ‚úÖ FIX: –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ –ø—Ä–∏ shutdown
function stopFrozenCleanup() {
    if (frozenCleanupIntervalId) {
        clearInterval(frozenCleanupIntervalId)
        frozenCleanupIntervalId = null
        console.log('[Keep-Alive] Cleanup interval stopped')
    }
}

// –ó–∞–ø—É—Å–∫–∞–µ–º –æ—á–∏—Å—Ç–∫—É –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥—É–ª—è
startFrozenCleanup()

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Persistence: Save/Remove torrents to db.json
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function saveTorrentToDB(magnetURI, name) {
    db.data.torrents ||= []
    // Avoid duplicates
    if (!db.data.torrents.find(t => t.magnet === magnetURI)) {
        db.data.torrents.push({ magnet: magnetURI, name, addedAt: Date.now(), completed: false })
        await safeWrite(db)
        console.log('[Persistence] Saved torrent:', name)
    }
}

// Mark torrent as completed in DB (survives restart)
async function markTorrentCompleted(infoHash) {
    const hashLower = infoHash.toLowerCase()
    const torrent = db.data.torrents?.find(t => t.magnet.toLowerCase().includes(hashLower))
    if (torrent && !torrent.completed) {
        torrent.completed = true
        await safeWrite(db)
        console.log('[Persistence] Marked as completed:', torrent.name)
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üì∫ Watchlist: Track seen files to detect new episodes
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function getNewFilesCount(infoHash, currentFiles) {
    const seenFiles = db.data.seenFiles?.[infoHash] || []
    if (seenFiles.length === 0) {
        // First time seeing this torrent, mark all as seen
        updateSeenFiles(infoHash, currentFiles)
        return 0
    }
    // Count files not in seenFiles
    const newFiles = currentFiles.filter(f => !seenFiles.includes(f.name))
    return newFiles.length
}

function updateSeenFiles(infoHash, currentFiles) {
    db.data.seenFiles ||= {}
    db.data.seenFiles[infoHash] = currentFiles.map(f => f.name)
    safeWrite(db).catch(e => console.warn('[Watchlist] Failed to save seenFiles:', e.message))
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üî• v2.3: Cache for isTorrentCompleted (expensive string search)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const completedCache = new Map()  // infoHash -> { value, time }
const COMPLETED_CACHE_TTL = 60000 // 1 minute

// Check if torrent is marked as completed in DB (CACHED)
function isTorrentCompleted(infoHash) {
    const hashLower = infoHash.toLowerCase()

    // Check cache first
    const cached = completedCache.get(hashLower)
    if (cached && Date.now() - cached.time < COMPLETED_CACHE_TTL) {
        return cached.value
    }

    // Expensive search
    const result = db.data.torrents?.some(t =>
        t.magnet.toLowerCase().includes(hashLower) && t.completed === true
    ) || false

    // Cache result
    completedCache.set(hashLower, { value: result, time: Date.now() })

    // üî• Limit cache size
    if (completedCache.size > 100) {
        const firstKey = completedCache.keys().next().value
        completedCache.delete(firstKey)
    }

    return result
}

async function removeTorrentFromDB(infoHash) {
    db.data.torrents ||= []
    const before = db.data.torrents.length
    const hashLower = infoHash.toLowerCase()

    // Case-insensitive match: magnet URI contains infoHash in format urn:btih:HASH
    db.data.torrents = db.data.torrents.filter(t => {
        const magnetLower = t.magnet.toLowerCase()
        const shouldRemove = magnetLower.includes(hashLower)
        if (shouldRemove) {
            console.log('[Persistence] Matching torrent for removal:', t.name)
        }
        return !shouldRemove
    })

    if (db.data.torrents.length < before) {
        await safeWrite(db)
        console.log(`[Persistence] Removed ${before - db.data.torrents.length} torrent(s) from DB:`, infoHash)
    } else {
        console.log('[Persistence] WARNING: No torrent found in DB for hash:', infoHash)
    }
}

// Restore all saved torrents on server startup
export async function restoreTorrents() {
    await db.read()
    const saved = db.data.torrents || []
    console.log(`[Persistence] Restoring ${saved.length} torrents...`)

    for (const { magnet, name } of saved) {
        try {
            await addTorrent(magnet, true) // true = skip saving (already in DB)
            console.log(`[Persistence] Restored: ${name}`)
        } catch (err) {
            console.warn(`[Persistence] Failed to restore ${name}: ${err.message}`)
        }
    }
}

// Helper to extract infoHash (regex from aggregator.js logic)
const extractInfoHash = (magnet) => {
    if (!magnet) return null
    const hexMatch = magnet.match(/urn:btih:([a-fA-F0-9]{40})/i)
    if (hexMatch) return hexMatch[1].toLowerCase()
    const base32Match = magnet.match(/urn:btih:([A-Z2-7]{32})/i)
    if (base32Match) return base32Match[1].toLowerCase()
    return null
}

export const addTorrent = (magnetURI, skipSave = false) => {
    return new Promise((resolve, reject) => {
        // üî• FIX-03: Smart Deduplication by infoHash
        const infoHash = extractInfoHash(magnetURI)
        if (!infoHash) {
            console.warn('[Torrent] Invalid magnet Link or missing infoHash:', magnetURI)
            return reject(new Error('Invalid magnet link: cannot extract infoHash'))
        }

        // Check active engines by infoHash
        for (const engine of engines.values()) {
            if (engine.infoHash?.toLowerCase() === infoHash) {
                 console.log(`[Torrent] Dedup: Engine already exists for hash ${infoHash}`)
                 return resolve(formatEngine(engine))
            }
        }

        // Check frozen torrents (Keep-Alive: instant resume!)
        if (frozenTorrents.has(infoHash)) {
            console.log(`[Keep-Alive] Reusing frozen torrent: ${infoHash}`)
            const frozen = frozenTorrents.get(infoHash)
            const engine = frozen.engine
            frozenTorrents.delete(infoHash)
            engines.set(magnetURI, engine)
            engines.set(engine.infoHash, engine)
            return resolve(formatEngine(engine))
        }

        const path = process.env.DOWNLOAD_PATH || './downloads'
        console.log('[Torrent] Adding magnet, download path:', path)

        // üî• STRATEGY 1: Tracker Injection
        let enrichedMagnet = magnetURI
        if (magnetURI.startsWith('magnet:?')) {
            const extraTr = PUBLIC_TRACKERS
                .filter(tr => !magnetURI.includes(encodeURIComponent(tr)))
                .map(tr => `&tr=${encodeURIComponent(tr)}`)
                .join('')
            enrichedMagnet += extraTr
            console.log('[Torrent] Injected', PUBLIC_TRACKERS.length, 'public trackers')
        }

        let engine
        try {
            // üî• STRATEGY 2: Eco Mode (20 connections) by default
            engine = torrentStream(enrichedMagnet, {
                path: path,
                connections: 20,       // Eco Mode: RAM-safe limit
                uploads: 0,
                dht: true,             // ‚úÖ DHT enabled
                verify: false,
                tracker: true
            })
        } catch (err) {
            console.error('[Torrent] Failed to create engine:', err.message)
            return reject(err)
        }

        engine.on('ready', () => {
            // ‚úÖ FIX: –û—á–∏—â–∞–µ–º —Ç–∞–π–º–∞—É—Ç –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
            if (engine._timeoutId) {
                clearTimeout(engine._timeoutId)
                delete engine._timeoutId
            }

            console.log('[Torrent] Engine ready:', engine.infoHash)

            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // FIX-01: Smart Selection (Video Only, Sort by Size)
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            if (engine.files && engine.files.length > 0) {
                // 1. Filter video extensions
                const videoFiles = engine.files.filter(f => 
                    /\.(mp4|mkv|avi|webm|mov|mpg|mpeg)$/i.test(f.name)
                )

                // 2. Sort by length DESC
                videoFiles.sort((a, b) => b.length - a.length)

                // 3. Select LARGEST video file (if any)
                if (videoFiles.length > 0) {
                    const largestVideo = videoFiles[0]
                    console.log(`[Torrent] Kickstart: Prioritizing largest video: ${largestVideo.name} (${(largestVideo.length / 1024 / 1024).toFixed(1)} MB)`)
                    largestVideo.select()
                    
                    // Also enable priority strategy
                    const idx = engine.files.indexOf(largestVideo)
                    if (idx !== -1) prioritizeFileInternal(engine, idx)
                } else {
                     console.log('[Torrent] IsKickstart: No video files found, nothing selected automatically.')
                }
            }

            engines.set(magnetURI, engine)
            engines.set(engine.infoHash, engine)

            // üîÑ Invalidate status cache on new torrent
            invalidateStatusCache()

            // Save to DB for persistence (unless restoring)
            if (!skipSave) {
                saveTorrentToDB(magnetURI, engine.torrent?.name || 'Unknown')
            }

            resolve(formatEngine(engine))
        })

        engine.on('error', (err) => {
            // ‚úÖ FIX: –û—á–∏—â–∞–µ–º —Ç–∞–π–º–∞—É—Ç –ø—Ä–∏ –æ—à–∏–±–∫–µ
            if (engine._timeoutId) {
                clearTimeout(engine._timeoutId)
                delete engine._timeoutId
            }

            console.error('[Torrent] Engine error:', err.message)
            engine.destroy()
            reject(err)
        })

        // üî• STRATEGY 3: Increased Timeout (90s)
        // ‚úÖ FIX: –°–æ—Ö—Ä–∞–Ω—è–µ–º ID —Ç–∞–π–º–∞—É—Ç–∞ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
        const timeoutId = setTimeout(() => {
            if (!engines.has(magnetURI)) {
                console.warn('[Torrent] Timeout: no peers found')
                engine.destroy()
                reject(new Error('Torrent timeout: no peers found within 90 seconds'))
            }
        }, 90000)

        // ‚úÖ FIX: –û—á–∏—â–∞–µ–º —Ç–∞–π–º–∞—É—Ç –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ (–≤–Ω—É—Ç—Ä–∏ engine.on('ready'))
        engine._timeoutId = timeoutId
    })
}

export const removeTorrent = (infoHash, forceDestroy = false) => {
    const engine = engines.get(infoHash)
    if (!engine) return false

    // üîÑ Invalidate status cache on torrent removal
    invalidateStatusCache()

    // Find magnetURI for this engine
    let magnetURI = null
    for (const [key, val] of engines.entries()) {
        if (val === engine && key.startsWith('magnet:')) {
            magnetURI = key
            break
        }
    }

    // Remove from active map
    engines.delete(infoHash)
    // ‚úÖ FIX: –°–æ–±–∏—Ä–∞–µ–º –∫–ª—é—á–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –æ—Ç–¥–µ–ª—å–Ω–æ, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å race condition
    const keysToDelete = []
    for (const [key, val] of engines.entries()) {
        if (val === engine) keysToDelete.push(key)
    }
    for (const key of keysToDelete) {
        engines.delete(key)
    }

    // Keep-Alive: freeze instead of destroy (unless forced)
    if (!forceDestroy) {
        console.log(`[Keep-Alive] Freezing torrent for 30min: ${infoHash}`)
        frozenTorrents.set(infoHash, {
            engine,
            magnetURI,
            frozenAt: Date.now()
        })
    } else {
        console.log('Destroying torrent:', infoHash)
        engine.destroy(() => {
            console.log('Engine destroyed:', infoHash)
        })
    }

    // üî• Memory fix: clear disk cache for this torrent
    diskDownloadCache.delete(infoHash)

    // Remove from persistent storage
    removeTorrentFromDB(infoHash)

    return true
}

export const getTorrent = (infoHash) => {
    const engine = engines.get(infoHash)
    if (engine) return formatEngine(engine)
    return null
}

// Get raw engine for streaming (with createReadStream)
export const getRawTorrent = (infoHash) => {
    return engines.get(infoHash) || null
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üöÄ Status Cache: Reduce CPU load from frequent polling
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let statusCache = null
let statusCacheTime = 0
const STATUS_CACHE_TTL = 5000 // üî• v2.3: increased from 2s to 5s for ARM CPU optimization

export const getAllTorrents = () => {
    const now = Date.now()

    // Return cached result if fresh
    if (statusCache && now - statusCacheTime < STATUS_CACHE_TTL) {
        return statusCache
    }

    // Recalculate and cache
    const uniqueEngines = new Set(engines.values())
    statusCache = Array.from(uniqueEngines).map(formatEngine)
    statusCacheTime = now

    return statusCache
}

// Invalidate cache when torrents change
export const invalidateStatusCache = () => {
    statusCache = null
    statusCacheTime = 0
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Calculate actual downloaded bytes from disk (CACHED)
// Uses background updates to avoid blocking event loop
// üî• Memory fix: added async dedup to prevent parallel storms
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const diskDownloadCache = new Map() // infoHash -> { bytes, updatedAt, updating }
const DISK_CACHE_TTL = 30000 // 30 seconds

// Non-blocking: returns cached value, schedules background update
function getDownloadedFromDisk(engine) {
    const infoHash = engine.infoHash

    // üî• Memory fix: hard cap on cache size
    if (diskDownloadCache.size > 50) {
        console.log('[Memory] Clearing diskDownloadCache (size exceeded 50)')
        diskDownloadCache.clear()
    }

    const cached = diskDownloadCache.get(infoHash)
    const now = Date.now()

    // Return cached value if fresh
    if (cached && now - cached.updatedAt < DISK_CACHE_TTL) {
        return cached.bytes
    }

    // üî• Memory fix: prevent parallel async updates (async dedup)
    if (!cached?.updating) {
        diskDownloadCache.set(infoHash, {
            bytes: cached?.bytes || 0,
            updatedAt: cached?.updatedAt || 0,
            updating: true
        })

        updateDiskCacheAsync(engine).finally(() => {
            const entry = diskDownloadCache.get(infoHash)
            if (entry) entry.updating = false
        })
    }

    // Return stale cache or 0 while updating
    return cached?.bytes || 0
}

// Background async update (doesn't block event loop)
async function updateDiskCacheAsync(engine) {
    const downloadPath = process.env.DOWNLOAD_PATH || './downloads'
    const infoHash = engine.infoHash

    if (!engine.torrent?.name || !engine.files) {
        diskDownloadCache.set(infoHash, { bytes: 0, updatedAt: Date.now() })
        return
    }

    let totalDownloaded = 0

    // Use async fs for non-blocking I/O (static import at top)

    for (const file of engine.files) {
        try {
            const filePath = path.join(downloadPath, file.path)
            const stats = await fsPromises.stat(filePath)
            const actualBytes = (stats.blocks !== undefined)
                ? stats.blocks * 512
                : stats.size
            totalDownloaded += Math.min(actualBytes, file.length)
        } catch (e) {
            // File doesn't exist or not accessible
        }
    }

    diskDownloadCache.set(infoHash, { bytes: totalDownloaded, updatedAt: Date.now() })
}

const formatEngine = (engine) => {
    const totalSize = engine.files?.reduce((sum, f) => sum + f.length, 0) || 0

    // Get downloaded bytes from different sources
    const diskDownloaded = getDownloadedFromDisk(engine)
    const swarmDownloaded = engine.swarm?.downloaded || 0

    // üî• Check if already marked as completed in DB (survives restart)
    const wasCompleted = isTorrentCompleted(engine.infoHash)

    // Determine downloaded bytes:
    // 1. If marked completed in DB ‚Üí use totalSize
    // 2. If swarm has data ‚Üí use swarm (active download)
    // 3. Otherwise ‚Üí use disk (restart scenario, partial download)
    let downloaded
    if (wasCompleted) {
        downloaded = totalSize
    } else if (swarmDownloaded > 0) {
        downloaded = swarmDownloaded
    } else {
        downloaded = diskDownloaded
    }

    // Calculate progress (0-1)
    const progress = totalSize > 0 ? Math.min(downloaded / totalSize, 1) : 0

    // Check if ready (and save completed status if newly completed)
    const isReady = wasCompleted || progress >= 0.99
    if (isReady && !wasCompleted && progress >= 0.99) {
        // Mark as completed in DB (async, fire-and-forget)
        markTorrentCompleted(engine.infoHash)
    }

    // Get download speed
    const downloadSpeed = engine.swarm?.downloadSpeed() || 0

    // Calculate ETA (seconds remaining)
    let eta = null
    if (downloadSpeed > 0 && progress < 1) {
        const remaining = totalSize - downloaded
        eta = Math.round(remaining / downloadSpeed)
    }

    // üì∫ Watchlist: count new files since last check
    const currentFiles = engine.files || []
    const newFilesCount = getNewFilesCount(engine.infoHash, currentFiles)

    return {
        infoHash: engine.infoHash,
        name: engine.torrent?.name || 'Unknown Torrent',
        progress: progress,
        isReady: isReady,
        downloaded: downloaded,
        totalSize: totalSize,
        downloadSpeed: downloadSpeed,
        uploadSpeed: engine.swarm?.uploadSpeed() || 0,
        numPeers: engine.swarm?.wires?.length || 0,
        eta: eta, // seconds remaining
        newFilesCount: newFilesCount, // üì∫ Watchlist: new episodes since last check
        // üî• Memory fix: only include file count, not full array
        // Full files array available via getTorrent(hash) on demand
        fileCount: engine.files?.length || 0,
        files: engine.files ? engine.files.map((file, index) => ({
            name: file.name,
            length: file.length,
            index: index
            // üî• Removed: path (not needed for UI list)
        })) : []
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Smart Priority: Prioritize specific file for instant playback
// Called when user starts streaming a specific episode
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Internal function (accepts engine directly)
function prioritizeFileInternal(engine, fileIndex, byteOffset = 0) {
    const file = engine.files?.[fileIndex]
    if (!file) {
        console.warn('[Priority] File not found:', fileIndex)
        return false
    }

    const pieceLength = engine.torrent?.pieceLength || 262144 // Default 256KB
    const totalPieces = engine.torrent?.pieces?.length || 0

    if (totalPieces === 0 || pieceLength === 0) {
        console.warn('[Priority] No piece info available')
        return false
    }

    // Calculate piece range for this specific file
    const fileStart = (file.offset || 0) + byteOffset
    const fileEnd = (file.offset || 0) + file.length

    const startPiece = Math.floor(fileStart / pieceLength)
    const endPiece = Math.floor(fileEnd / pieceLength)

    // ‚ö° AGGRESSIVE PRIORITY: 50MB instead of 15MB for 4K content
    const priorityBytes = Math.min(file.length * 0.1, 50 * 1024 * 1024) // 10% or 50MB
    const priorityPieces = Math.max(1, Math.ceil(priorityBytes / pieceLength))
    const priorityEnd = Math.min(startPiece + priorityPieces, endPiece)

    try {
        engine.select(startPiece, priorityEnd, true) // true = high priority
        console.log(`[Priority] File ${fileIndex}: pieces ${startPiece}-${priorityEnd} (${priorityPieces} pieces, ~${Math.round(priorityBytes / 1024 / 1024)}MB)`)
        return true
    } catch (e) {
        console.warn('[Priority] Selection failed:', e.message)
        return false
    }
}

// Public API: prioritize by infoHash
export function prioritizeFile(infoHash, fileIndex) {
    const engine = engines.get(infoHash)
    if (!engine) {
        console.warn('[Priority] Engine not found:', infoHash)
        return false
    }
    return prioritizeFileInternal(engine, fileIndex)
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Readahead: Prioritize chunks ahead of seek position
// Called when player seeks to a new position
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export function readahead(infoHash, fileIndex, byteOffset) {
    const engine = engines.get(infoHash)
    if (!engine) {
        console.warn('[Readahead] Engine not found:', infoHash)
        return false
    }
    console.log(`[Readahead] Seeking to byte ${byteOffset} in file ${fileIndex}`)
    return prioritizeFileInternal(engine, fileIndex, byteOffset)
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üî• Turbo Mode: Boost connections when streaming starts
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export const boostTorrent = (infoHash) => {
    const engine = engines.get(infoHash)

    // Debug: why boost might not work
    if (!engine) {
        console.warn(`[Turbo] Engine not found for: ${infoHash}`)
        return
    }
    if (!engine.swarm) {
        console.warn(`[Turbo] No swarm for: ${infoHash}`)
        return
    }

    const currentMax = engine.swarm.maxConnections || 0
    console.log(`[Turbo] Current connections: ${engine.swarm.wires?.length || 0}/${currentMax}`)

    // If still in Eco Mode (< 65), boost it!
    if (currentMax < 65) {
        console.log(`[Turbo] üöÄ Boosting connections for ${infoHash}: ${currentMax} -> 65`)
        engine.swarm.maxConnections = 65
        if (engine.discover) engine.discover()
        engine.swarm.resume()
    } else {
        console.log(`[Turbo] Already boosted (${currentMax}), skipping`)
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ö° Speed Mode: Eco / Balanced / Turbo
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SPEED_MODES = {
    eco: 20,
    balanced: 40,
    turbo: 65
}

export const setSpeedMode = (mode) => {
    const connections = SPEED_MODES[mode] || SPEED_MODES.balanced
    const uniqueEngines = new Set(engines.values())

    for (const engine of uniqueEngines) {
        if (engine.swarm) {
            engine.swarm.maxConnections = connections
            console.log(`[SpeedMode] Set ${engine.infoHash?.slice(0, 8)} to ${mode} (${connections} connections)`)
        }
    }

    console.log(`[SpeedMode] Applied ${mode} mode to ${uniqueEngines.size} torrents`)
    return { mode, connections, torrentsAffected: uniqueEngines.size }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üõë Graceful Shutdown: Destroy all torrents
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export const destroyAllTorrents = () => {
    // ‚úÖ FIX: –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª –æ—á–∏—Å—Ç–∫–∏ frozen torrents
    stopFrozenCleanup()

    console.log(`[Shutdown] Destroying ${engines.size} active engines...`)

    // Destroy all active engines
    const uniqueEngines = new Set(engines.values())
    for (const engine of uniqueEngines) {
        try {
            engine.destroy()
        } catch (e) {
            console.warn('[Shutdown] Engine destroy failed:', e.message)
        }
    }
    engines.clear()

    // Clear frozen torrents
    console.log(`[Shutdown] Clearing ${frozenTorrents.size} frozen torrents...`)
    for (const [hash, frozen] of frozenTorrents.entries()) {
        try {
            frozen.engine.destroy()
        } catch (e) { }
    }
    frozenTorrents.clear()

    console.log('[Shutdown] All torrents destroyed')
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üìä v2.3: Diagnostics helpers
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export const getActiveTorrentsCount = () => engines.size
export const getFrozenTorrentsCount = () => frozenTorrents.size

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üõ°Ô∏è v2.3.3: Graceful Degradation - Memory pressure handling
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

let isDegradedMode = false

/**
 * Enter degraded mode: reduce memory usage
 * - Pause all frozen torrents (destroy them)
 * - Reduce max connections on active torrents
 * - Disable prefetch buffers
 */
export const enterDegradedMode = () => {
    if (isDegradedMode) return { alreadyDegraded: true }

    isDegradedMode = true
    console.log('[Degradation] Entering degraded mode - reducing memory usage')

    let freedCount = 0

    // 1. Clear all frozen torrents (they're just cache)
    for (const [hash, frozen] of frozenTorrents.entries()) {
        try {
            frozen.engine.destroy()
            freedCount++
        } catch (e) { }
    }
    frozenTorrents.clear()
    console.log(`[Degradation] Freed ${freedCount} frozen torrents`)

    // 2. Reduce connections on active torrents (eco mode)
    const uniqueEngines = new Set(engines.values())
    for (const engine of uniqueEngines) {
        if (engine.swarm) {
            engine.swarm.maxConnections = 30 // Minimal connections
        }
    }
    console.log(`[Degradation] Reduced connections on ${uniqueEngines.size} active torrents`)

    // 3. Force garbage collection if available
    if (global.gc) {
        global.gc()
        console.log('[Degradation] Forced garbage collection')
    }

    return {
        freedFrozen: freedCount,
        reducedConnections: uniqueEngines.size,
        mode: 'degraded'
    }
}

/**
 * Exit degraded mode: restore normal operation
 */
export const exitDegradedMode = () => {
    if (!isDegradedMode) return { alreadyNormal: true }

    isDegradedMode = false
    console.log('[Degradation] Exiting degraded mode - restoring normal operation')

    // Restore normal connections (balanced mode)
    const uniqueEngines = new Set(engines.values())
    for (const engine of uniqueEngines) {
        if (engine.swarm) {
            engine.swarm.maxConnections = 55 // Balanced mode default
        }
    }

    return { restoredConnections: uniqueEngines.size, mode: 'normal' }
}

/**
 * Check if currently in degraded mode
 */
export const isInDegradedMode = () => isDegradedMode

```

---

## server/utils/doh.js

```javascript
import https from 'https';

/**
 * DoH (DNS-over-HTTPS) Module with Provider Rotation + Circuit Breaker
 * ARC-01: Multi-provider resilience for anti-censorship
 *
 * Features:
 * - Multiple DoH providers (Google, Cloudflare, Quad9)
 * - Race strategy with 2s timeout (fastest wins)
 * - Circuit Breaker: auto-disable failing providers
 * - Automatic recovery after cooldown period
 */

// --- CONFIGURATION ---
const CACHE_TTL_MS = 1000 * 60 * 10; // 10 minutes
const RACE_TIMEOUT_MS = 5000; // Increased to 5s for slow networks
const CIRCUIT_BREAKER_THRESHOLD = 3; // Failures before opening circuit
const CIRCUIT_BREAKER_COOLDOWN_MS = 60 * 1000; // 1 minute cooldown
const DEBUG = true; // Force debug logging for investigation

// --- DoH PROVIDERS ---
// ARC-01: Multiple providers for resilience
const DOH_PROVIDERS = [
    {
        name: 'Google',
        url: 'https://dns.google/resolve',
        // Google uses standard JSON format
    },
    {
        name: 'Cloudflare',
        url: 'https://cloudflare-dns.com/dns-query',
        // Cloudflare also supports JSON format with Accept header
    },
    {
        name: 'Quad9',
        url: 'https://dns.quad9.net:5053/dns-query',
        // Quad9 supports JSON with Accept header
    }
];

// --- CIRCUIT BREAKER STATE ---
const providerState = new Map();

function initProviderState(provider) {
    if (!providerState.has(provider.name)) {
        providerState.set(provider.name, {
            failures: 0,
            circuitOpen: false,
            lastFailure: 0,
            lastSuccess: 0
        });
    }
    return providerState.get(provider.name);
}

function recordSuccess(provider) {
    const state = initProviderState(provider);
    state.failures = 0;
    state.circuitOpen = false;
    state.lastSuccess = Date.now();
    if (DEBUG) console.log(`[DoH] ‚úÖ ${provider.name} success`);
}

function recordFailure(provider) {
    const state = initProviderState(provider);
    state.failures++;
    state.lastFailure = Date.now();

    if (state.failures >= CIRCUIT_BREAKER_THRESHOLD) {
        state.circuitOpen = true;
        console.warn(`[DoH] üî¥ Circuit OPEN for ${provider.name} (${state.failures} failures)`);
    } else if (DEBUG) {
        console.log(`[DoH] ‚ö†Ô∏è ${provider.name} failure ${state.failures}/${CIRCUIT_BREAKER_THRESHOLD}`);
    }
}

function isProviderAvailable(provider) {
    const state = initProviderState(provider);

    if (!state.circuitOpen) return true;

    // Check if cooldown has passed (half-open state)
    if (Date.now() - state.lastFailure > CIRCUIT_BREAKER_COOLDOWN_MS) {
        if (DEBUG) console.log(`[DoH] üü° ${provider.name} entering half-open state`);
        return true; // Allow one attempt
    }

    return false;
}

// --- DNS CACHE ---
const dnsCache = new Map();

// --- HTTPS AGENT ---
// Agent with keepAlive and SSL ignore (for self-signed mirrors)
export const insecureAgent = new https.Agent({
    rejectUnauthorized: false,
    keepAlive: true,
    keepAliveMsecs: 10000
});

// --- SINGLE PROVIDER RESOLVE ---
async function resolveWithProvider(hostname, provider) {
    const state = initProviderState(provider);

    // Skip if circuit is open
    if (!isProviderAvailable(provider)) {
        throw new Error(`Circuit open for ${provider.name}`);
    }

    const url = `${provider.url}?name=${encodeURIComponent(hostname)}&type=A`;

    const response = await fetch(url, {
        method: 'GET',
        headers: { 'Accept': 'application/dns-json' },
        signal: AbortSignal.timeout(RACE_TIMEOUT_MS)
    });

    if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
    }

    const data = await response.json();

    if (data.Answer && data.Answer.length > 0) {
        const record = data.Answer.find(r => r.type === 1); // Type A (IPv4)
        if (record) {
            recordSuccess(provider);
            return { ip: record.data, provider: provider.name };
        }
    }

    throw new Error('No A record found');
}

// --- RACE STRATEGY ---
// ARC-01: Race all available providers, fastest wins
async function resolveIP(hostname) {
    // Check cache first
    if (dnsCache.has(hostname)) {
        const cached = dnsCache.get(hostname);
        if (Date.now() < cached.expires) {
            if (DEBUG) console.log(`[DoH] Cache hit: ${hostname} -> ${cached.ip}`);
            return cached.ip;
        }
        dnsCache.delete(hostname);
    }

    // Get available providers
    const availableProviders = DOH_PROVIDERS.filter(isProviderAvailable);

    if (availableProviders.length === 0) {
        // All circuits open - reset all and try again
        console.warn('[DoH] üö® All circuits open! Resetting...');
        DOH_PROVIDERS.forEach(p => {
            const state = providerState.get(p.name);
            if (state) {
                state.circuitOpen = false;
                state.failures = 0;
            }
        });
        availableProviders.push(...DOH_PROVIDERS);
    }

    if (DEBUG) console.log(`[DoH] Racing ${availableProviders.length} providers for ${hostname}`);

    // Race all available providers
    const racePromises = availableProviders.map(provider =>
        resolveWithProvider(hostname, provider).catch(err => {
            recordFailure(provider);
            throw err;
        })
    );

    try {
        const result = await Promise.any(racePromises);

        // Cache the result
        if (dnsCache.size > 1000) dnsCache.clear();
        dnsCache.set(hostname, {
            ip: result.ip,
            expires: Date.now() + CACHE_TTL_MS,
            provider: result.provider
        });

        if (DEBUG) console.log(`[DoH] Resolved ${hostname} -> ${result.ip} (via ${result.provider})`);
        return result.ip;

    } catch (err) {
        // All providers failed
        if (DEBUG) console.error(`[DoH] All providers failed for ${hostname}`);
        return null;
    }
}

// --- SMART CONFIG ---
export async function getSmartConfig(urlStr, baseOptions = {}) {
    let targetUrl;
    try {
        targetUrl = new URL(urlStr);
    } catch (e) {
        throw new Error(`Invalid URL: ${urlStr}`);
    }

    const ip = await resolveIP(targetUrl.hostname);

    // Browser mimicry headers
    const headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        ...(baseOptions.headers || {})
    };

    if (ip) {
        const directUrl = urlStr.replace(targetUrl.hostname, ip);
        headers['Host'] = targetUrl.hostname; // Important for Cloudflare

        return {
            url: directUrl,
            headers,
            hostname: targetUrl.hostname, // For SNI
            resolvedIP: ip
        };
    } else {
        return { url: urlStr, headers, resolvedIP: null };
    }
}

import http from 'http';

// --- SMART FETCH ---
// Universal fetch with DoH resolution and SNI support
export async function smartFetch(urlStr, options = {}) {
    const config = await getSmartConfig(urlStr, options);
    const targetUrl = new URL(config.url);
    const isHttps = targetUrl.protocol === 'https:';
    const transport = isHttps ? https : http;

    return new Promise((resolve, reject) => {
        const requestOptions = {
            method: options.method || 'GET',
            headers: config.headers,
            agent: options.agent || (options.insecure ? insecureAgent : undefined),
        };

        // üî• SNI Support for HTTPS when using resolved IP
        if (config.resolvedIP && isHttps) {
            requestOptions.hostname = config.resolvedIP;
            requestOptions.servername = config.hostname; // Critical for TMDB/Cloudflare
            requestOptions.path = targetUrl.pathname + targetUrl.search;
        }

        const req = transport.request(config.resolvedIP && isHttps ? requestOptions : config.url, (res) => {
            const chunks = [];
            res.on('data', (chunk) => chunks.push(chunk));
            res.on('end', () => {
                const buffer = Buffer.concat(chunks);
                const contentType = res.headers['content-type'] || '';
                const isJson = contentType.includes('application/json');
                const isImage = contentType.startsWith('image/');

                let data;
                try {
                    if (options.responseType === 'arraybuffer' || isImage) {
                        data = buffer;
                    } else if (isJson && buffer.length > 0) {
                        data = JSON.parse(buffer.toString());
                    } else {
                        data = buffer.toString();
                    }

                    resolve({
                        data,
                        status: res.statusCode,
                        headers: res.headers,
                        resolvedIP: config.resolvedIP
                    });
                } catch (e) {
                    // Fallback to text if JSON parse fails
                    resolve({
                        data: buffer.toString(),
                        status: res.statusCode,
                        headers: res.headers,
                        resolvedIP: config.resolvedIP,
                        parseError: e.message
                    });
                }
            });
        });

        req.on('error', (err) => {
            reject(err);
        });

        req.on('timeout', () => {
            req.destroy();
            reject(new Error('Request timeout'));
        });

        const effectiveTimeout = options.timeout || 30000;
        if (DEBUG) console.log(`[SmartFetch] ${new URL(config.url).hostname} timeout set to ${effectiveTimeout}ms`);
        req.setTimeout(effectiveTimeout);

        if (options.body) {
            const body = typeof options.body === 'object' ? JSON.stringify(options.body) : options.body;
            req.write(body);
        }

        req.end();
    });
}

// --- DIAGNOSTIC EXPORT ---
// For debugging/monitoring
export function getProviderStatus() {
    const status = {};
    DOH_PROVIDERS.forEach(p => {
        const state = providerState.get(p.name) || { failures: 0, circuitOpen: false };
        status[p.name] = {
            available: isProviderAvailable(p),
            failures: state.failures,
            circuitOpen: state.circuitOpen,
            lastSuccess: state.lastSuccess || null,
            lastFailure: state.lastFailure || null
        };
    });
    return status;
}

export { resolveIP };

```

---

## server/utils/lag-monitor.js

```javascript
/**
 * Event Loop Lag Monitor v2.3
 * Detects when Node.js event loop is blocked
 * 
 * v2.3: Adaptive settings for production (less sensitive, less overhead)
 * 
 * Usage:
 *   import { LagMonitor } from './utils/lag-monitor.js'
 *   const lagMonitor = new LagMonitor()  // Auto-detects prod/dev
 *   lagMonitor.start()
 */

export class LagMonitor {
    constructor(threshold = null) {
        // üî• v2.3: Adaptive settings based on environment
        const isProd = process.env.NODE_ENV === 'production'
        
        // Production: less sensitive (200ms threshold, 1s interval)
        // Development: more sensitive for debugging (50ms threshold, 250ms interval)
        this.threshold = threshold ?? (isProd ? 200 : 50)
        this.checkInterval = isProd ? 1000 : 250
        
        this.lastCheck = Date.now()
        this.lagEvents = []
        this.intervalId = null
        this.isProd = isProd
    }

    start() {
        if (this.intervalId) return // Already running

        this.intervalId = setInterval(() => {
            const now = Date.now()
            // üî• v2.3: expected = interval + 50ms tolerance for I/O delays
            const expected = this.checkInterval + 50
            const lag = now - this.lastCheck - expected

            if (lag > this.threshold) {
                const event = {
                    timestamp: now,
                    lag: lag,
                    memory: Math.round(process.memoryUsage().rss / 1024 / 1024)
                }

                this.lagEvents.push(event)
                
                // üî• v2.3: Only log warnings in dev, or critical lags (>1s) in prod
                if (!this.isProd || lag > 1000) {
                    console.warn(`[LagMonitor] Event loop lag: ${lag}ms, RAM: ${event.memory}MB`)
                }

                // Keep only last 50 events
                if (this.lagEvents.length > 50) {
                    this.lagEvents.shift()
                }
            }

            this.lastCheck = now
        }, this.checkInterval)

        console.log(`[LagMonitor] Started (${this.isProd ? 'prod' : 'dev'} mode: ${this.checkInterval}ms interval, ${this.threshold}ms threshold)`)
    }

    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId)
            this.intervalId = null
            console.log('[LagMonitor] Stopped')
        }
    }

    getStats() {
        const now = Date.now()
        const recentLags = this.lagEvents.filter(e =>
            now - e.timestamp < 60000
        )

        return {
            totalLags: this.lagEvents.length,
            recentLags: recentLags.length,
            avgLag: recentLags.length > 0
                ? Math.round(recentLags.reduce((sum, e) => sum + e.lag, 0) / recentLags.length)
                : 0,
            maxLag: recentLags.length > 0
                ? Math.max(...recentLags.map(e => e.lag))
                : 0
        }
    }
}

```

---

## server/utils/logger.js

```javascript
/**
 * Simple Structured Logger for PWA-TorServe
 * Zero dependencies - works without npm install!
 * 
 * Features:
 * - Timestamps in ISO format
 * - Log levels (debug/info/warn/error)
 * - Configurable via LOG_LEVEL env variable
 * - Module context support
 * 
 * Usage:
 *   import { logger } from './utils/logger.js'
 *   logger.info('Server started', { port: 3000 })
 *   logger.error('Failed to connect', { error: err.message })
 * 
 * Or with module context:
 *   const log = logger.child('Torrent')
 *   log.info('Added torrent', { hash: '...' })
 */

const LOG_LEVELS = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3
}

const currentLevel = LOG_LEVELS[process.env.LOG_LEVEL || 'info'] || LOG_LEVELS.info

/**
 * Format log message with timestamp and level
 */
const formatMessage = (level, module, message, data) => {
    const timestamp = new Date().toISOString()
    const modulePrefix = module ? `[${module}]` : ''
    const dataStr = data && Object.keys(data).length > 0 
        ? ' ' + JSON.stringify(data) 
        : ''
    
    return `[${timestamp}] [${level.toUpperCase()}]${modulePrefix} ${message}${dataStr}`
}

/**
 * Create logger instance optionally bound to a module name
 * ‚úÖ FIX: –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Ä–æ–≤–Ω–µ–π –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
 */
const createLogger = (moduleName = null) => ({
    debug: (message, data = {}) => {
        if (currentLevel <= LOG_LEVELS.debug) {  // ‚úÖ FIX: –±—ã–ª–æ LOG_LEVELS.debug >= currentLevel
            console.log(formatMessage('debug', moduleName, message, data))
        }
    },

    info: (message, data = {}) => {
        if (currentLevel <= LOG_LEVELS.info) {  // ‚úÖ FIX
            console.log(formatMessage('info', moduleName, message, data))
        }
    },

    warn: (message, data = {}) => {
        if (currentLevel <= LOG_LEVELS.warn) {  // ‚úÖ FIX
            console.warn(formatMessage('warn', moduleName, message, data))
        }
    },

    error: (message, data = {}) => {
        if (currentLevel <= LOG_LEVELS.error) {  // ‚úÖ FIX
            console.error(formatMessage('error', moduleName, message, data))
        }
    },

    /**
     * Create child logger with module context
     * @param {string} module - Module name for log prefix
     * @returns {Object} Logger instance with module context
     */
    child: (module) => createLogger(module)
})

export const logger = createLogger()

```

---

## server/utils/retry.js

```javascript
/**
 * Retry Utility with Exponential Backoff
 * PWA-TorServe v2.3.3
 *
 * Usage:
 *   const result = await withRetry(() => fetchData(), { maxRetries: 3 })
 */

/**
 * Execute async function with retry logic
 * @param {Function} fn - Async function to execute
 * @param {Object} options - Retry options
 * @param {number} options.maxRetries - Maximum retry attempts (default: 3)
 * @param {number} options.baseDelayMs - Base delay in ms (default: 1000)
 * @param {number} options.maxDelayMs - Maximum delay cap (default: 10000)
 * @param {Function} options.shouldRetry - Custom retry condition (default: always retry)
 * @param {Function} options.onRetry - Callback on each retry (optional)
 * @returns {Promise<any>} Result of the function
 */
export const withRetry = async (fn, options = {}) => {
    const {
        maxRetries = 3,
        baseDelayMs = 1000,
        maxDelayMs = 10000,
        shouldRetry = () => true,
        onRetry = null
    } = options

    let lastError

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
            return await fn(attempt)
        } catch (error) {
            lastError = error

            // Check if we should retry
            if (attempt >= maxRetries || !shouldRetry(error, attempt)) {
                throw error
            }

            // Calculate delay with exponential backoff + jitter
            const exponentialDelay = baseDelayMs * Math.pow(2, attempt)
            const jitter = Math.random() * 200 // 0-200ms jitter
            const delay = Math.min(exponentialDelay + jitter, maxDelayMs)

            if (onRetry) {
                onRetry(error, attempt + 1, delay)
            }

            await sleep(delay)
        }
    }

    throw lastError
}

/**
 * Sleep utility
 */
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms))

/**
 * Common retry predicates
 */
export const retryPredicates = {
    // Retry on network errors
    networkError: (error) => {
        const networkCodes = ['ECONNRESET', 'ETIMEDOUT', 'ECONNREFUSED', 'ENOTFOUND', 'EAI_AGAIN']
        return networkCodes.includes(error.code)
    },

    // Retry on HTTP 5xx errors
    serverError: (error) => {
        return error.statusCode >= 500 && error.statusCode < 600
    },

    // Retry on rate limiting (429)
    rateLimited: (error) => {
        return error.statusCode === 429
    },

    // Combined: network + server errors
    transient: (error) => {
        return retryPredicates.networkError(error) ||
               retryPredicates.serverError(error) ||
               retryPredicates.rateLimited(error)
    }
}

```

---

## server/watchdog.js

```javascript
/**
 * Watchdog Module - Self-Healing Architecture
 * PWA-TorServe v2.3.3
 *
 * Features:
 * - Non-blocking async monitoring loop
 * - RAM monitoring with hysteresis (30s delay for degraded)
 * - NFS Circuit Breaker (3 failures ‚Üí 5min pause)
 * - Automatic counter reset on recovery
 * - üÜï Graceful Degradation: auto-reduce memory on pressure
 */

import { db, safeWrite } from './db.js'
import fs from 'fs'
import path from 'path'
import { checkRules } from './autodownloader.js'
import { enterDegradedMode, exitDegradedMode } from './torrent.js'

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Configuration Constants
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const CONFIG = {
    CHECK_INTERVAL_MS: 30000,           // Main loop interval: 30s
    RAM_OK_THRESHOLD_MB: 800,           // ‚¨Ü Relaxed for 100GB files
    RAM_DEGRADED_THRESHOLD_MB: 1000,    // ‚¨Ü Limit increased to 1GB
    HYSTERESIS_DELAY_MS: 30000,         // 30s delay before degraded
    STORAGE_CHECK_TIMEOUT_MS: 5000,     // 5s timeout for storage check
    CIRCUIT_BREAKER_THRESHOLD: 3,       // 3 failures ‚Üí circuit open
    CIRCUIT_BREAKER_COOLDOWN_MS: 300000 // 5 minutes cooldown
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// State Variables
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

let degradedSince = null              // Timestamp when RAM first exceeded threshold
let circuitOpenUntil = null           // Timestamp when circuit breaker will retry
let isWatchdogRunning = false
let lastAutoDownloadCheck = 0         // Timestamp of last auto-download check

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Helper Functions
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms))

const getRAMUsageMB = () => {
    const used = process.memoryUsage()
    // Use RSS (Resident Set Size) instead of heapUsed
    // RSS includes buffers, video data, and system resources
    // This is what Android actually sees and may kill the process for
    return Math.round(used.rss / 1024 / 1024)
}

/**
 * Check storage accessibility with timeout
 * Creates directory if it doesn't exist
 * PHYSICAL WRITE TEST: writes .healthcheck file to verify R/W access
 * @returns {Promise<boolean>} true if storage is accessible
 */
const checkStorage = () => {
    return new Promise((resolve) => {
        // Default to ./downloads (relative to app dir) which works on Android Termux
        const downloadPath = process.env.DOWNLOAD_PATH || './downloads'
        const healthFile = path.join(downloadPath, '.healthcheck')

        const timeout = setTimeout(() => {
            console.warn('[Watchdog] Storage check timeout!')
            resolve(false)
        }, CONFIG.STORAGE_CHECK_TIMEOUT_MS)

        // Ensure directory exists first
        fs.mkdir(downloadPath, { recursive: true }, (mkdirErr) => {
            if (mkdirErr && mkdirErr.code !== 'EEXIST') {
                clearTimeout(timeout)
                console.warn(`[Watchdog] Failed to create directory: ${mkdirErr.message}`)
                resolve(false)
                return
            }

            // PHYSICAL WRITE TEST: write timestamp to .healthcheck file
            const testData = `healthcheck:${Date.now()}`
            fs.writeFile(healthFile, testData, (writeErr) => {
                if (writeErr) {
                    clearTimeout(timeout)
                    console.warn(`[Watchdog] Write test failed: ${writeErr.message}`)
                    resolve(false)
                    return
                }

                // Clean up: delete the test file
                fs.unlink(healthFile, (unlinkErr) => {
                    clearTimeout(timeout)
                    if (unlinkErr) {
                        // Non-critical: file was written successfully
                        console.warn(`[Watchdog] Cleanup failed: ${unlinkErr.message}`)
                    }
                    resolve(true)
                })
            })
        })
    })
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// State Machine
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Update server status with persistence
 * @param {string} newStatus - 'ok' | 'degraded' | 'error' | 'circuit_open'
 */
const updateStatus = async (newStatus) => {
    const currentStatus = db.data.serverStatus

    if (currentStatus !== newStatus) {
        console.log(`[Watchdog] Status change: ${currentStatus} ‚Üí ${newStatus}`)
        db.data.serverStatus = newStatus
        db.data.lastStateChange = Date.now()

        // üÜï v2.3.3: Graceful Degradation - auto-reduce memory on pressure
        if (newStatus === 'degraded') {
            const result = enterDegradedMode()
            console.log(`[Watchdog] Degradation applied:`, result)
        }

        // Reset counters on recovery to OK
        if (newStatus === 'ok') {
            db.data.storageFailures = 0
            degradedSince = null

            // üÜï v2.3.3: Exit degraded mode on recovery
            const result = exitDegradedMode()
            console.log(`[Watchdog] Recovery applied:`, result)
            console.log('[Watchdog] Recovery complete, counters reset')
        }

        await safeWrite(db)
    }
}

/**
 * Main watchdog check cycle
 */
const performCheck = async () => {
    const now = Date.now()
    const ramMB = getRAMUsageMB()

    // ‚îÄ‚îÄ‚îÄ Circuit Breaker Check ‚îÄ‚îÄ‚îÄ
    if (circuitOpenUntil) {
        if (now < circuitOpenUntil) {
            // Still in cooldown, skip all checks
            const remainingMs = circuitOpenUntil - now
            console.log(`[Watchdog] Circuit open, retry in ${Math.round(remainingMs / 1000)}s`)
            return
        }

        // Cooldown expired, attempt recovery
        console.log('[Watchdog] Circuit breaker: attempting recovery...')
        const storageOk = await checkStorage()

        if (storageOk) {
            circuitOpenUntil = null
            await updateStatus('ok')
            console.log('[Watchdog] Circuit breaker: recovery successful!')
        } else {
            // Retry failed, extend cooldown
            circuitOpenUntil = now + CONFIG.CIRCUIT_BREAKER_COOLDOWN_MS
            // Update lastStateChange so client shows correct elapsed time
            db.data.lastStateChange = now
            await safeWrite(db)
            console.warn('[Watchdog] Circuit breaker: recovery failed, extending cooldown')
        }
        return
    }

    // ‚îÄ‚îÄ‚îÄ Storage Check ‚îÄ‚îÄ‚îÄ
    const storageOk = await checkStorage()

    if (!storageOk) {
        db.data.storageFailures = (db.data.storageFailures || 0) + 1
        console.warn(`[Watchdog] Storage failure #${db.data.storageFailures}`)

        if (db.data.storageFailures >= CONFIG.CIRCUIT_BREAKER_THRESHOLD) {
            circuitOpenUntil = now + CONFIG.CIRCUIT_BREAKER_COOLDOWN_MS
            await updateStatus('circuit_open')
            console.error('[Watchdog] Circuit breaker OPEN! Pausing checks for 5 minutes.')
            return
        }
    } else {
        // Storage OK, reset failure counter
        if (db.data.storageFailures > 0) {
            db.data.storageFailures = 0
            await safeWrite(db)
        }
    }

    // ‚îÄ‚îÄ‚îÄ RAM Check with Hysteresis ‚îÄ‚îÄ‚îÄ
    if (ramMB > CONFIG.RAM_DEGRADED_THRESHOLD_MB) {
        if (!degradedSince) {
            degradedSince = now
            console.log(`[Watchdog] RAM ${ramMB}MB > threshold, starting hysteresis timer`)
        } else if (now - degradedSince >= CONFIG.HYSTERESIS_DELAY_MS) {
            await updateStatus('degraded')
        }
    } else if (ramMB < CONFIG.RAM_OK_THRESHOLD_MB) {
        // RAM is OK
        if (db.data.serverStatus === 'degraded') {
            await updateStatus('ok')
        }
        degradedSince = null
    }

    // Log current state
    console.log(`[Watchdog] RAM: ${ramMB}MB | Status: ${db.data.serverStatus} | Storage Failures: ${db.data.storageFailures}`)

    // ‚îÄ‚îÄ‚îÄ Auto-Downloader Check ‚îÄ‚îÄ‚îÄ
    await runAutoDownloadCheck()
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üì∫ Auto-Downloader Integration
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const runAutoDownloadCheck = async () => {
    const settings = db.data.autoDownloadSettings || { enabled: false, intervalMinutes: 30 }

    if (!settings.enabled) return

    const intervalMs = (settings.intervalMinutes || 30) * 60 * 1000
    const now = Date.now()

    if (now - lastAutoDownloadCheck < intervalMs) return

    lastAutoDownloadCheck = now

    try {
        console.log('[Watchdog] Running auto-download check...')
        const result = await checkRules()
        if (result.downloaded > 0) {
            console.log(`[Watchdog] Auto-downloaded ${result.downloaded} new episode(s)`)
        }
    } catch (err) {
        console.error('[Watchdog] Auto-download check failed:', err.message)
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Public API
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Start the async watchdog loop
 */
export const startWatchdog = async () => {
    if (isWatchdogRunning) {
        console.warn('[Watchdog] Already running!')
        return
    }

    isWatchdogRunning = true
    console.log('[Watchdog] Starting async monitoring loop...')

    // üî• v2.3.2: Reset circuit_open on startup (it persisted from previous session)
    if (db.data.serverStatus === 'circuit_open') {
        console.log('[Watchdog] Detected persisted circuit_open, checking storage...')
        const storageOk = await checkStorage()
        if (storageOk) {
            db.data.serverStatus = 'ok'
            db.data.storageFailures = 0
            circuitOpenUntil = null
            await safeWrite(db)
            console.log('[Watchdog] Storage OK, reset to normal status')
        } else {
            // Storage still broken, keep circuit open with fresh cooldown
            circuitOpenUntil = Date.now() + CONFIG.CIRCUIT_BREAKER_COOLDOWN_MS
            db.data.lastStateChange = Date.now()
            await safeWrite(db)
            console.warn('[Watchdog] Storage still unavailable, circuit remains open')
        }
    }

    // Initial check
    try {
        await performCheck()
    } catch (err) {
        console.error('[Watchdog] Initial check failed:', err.message)
    }

    // Non-blocking loop with error recovery
    while (isWatchdogRunning) {
        await sleep(CONFIG.CHECK_INTERVAL_MS)
        try {
            await performCheck()
        } catch (err) {
            // Log error but DON'T crash - watchdog must survive
            console.error('[Watchdog] Check failed, will retry:', err.message)
        }
    }
}

/**
 * Stop the watchdog loop
 */
export const stopWatchdog = () => {
    isWatchdogRunning = false
    console.log('[Watchdog] Stopped')
}

/**
 * Get current server state for API responses
 */
export const getServerState = () => {
    return {
        serverStatus: db.data.serverStatus,
        lastStateChange: db.data.lastStateChange,
        storageFailures: db.data.storageFailures
    }
}

```

---

## skills/capacitor-bridge/SKILL.md

```markdown
---
name: capacitor-bridge
description: Specialist in Android Intents, Java-JS bridging, and External Player integration.
---

# Capacitor Bridge Skill

This skill handles the communication between the React Frontend and the Native Android layer (`TVPlayer.java`).
**Primary Goal:** Launch external players (VLC, MX Player, Vimu) correctly and handle their return results (resume position).

## Ê°• API Contract

### `TVPlayer.play(options)`
Launches a single video file. **Must return a Promise that resolves only after the player closes.**

**Options:**
*   `url` (string, required): Direct link to the video stream.
*   `package` (string, optional): Specific player package name (e.g., `net.gtvbox.videoplayer`). If null, opens system chooser.
*   `title` (string): Title to display in the player.
*   `position` (number): Resume position in milliseconds.

**Java Extras (What actually gets sent):**
*   `Intent.ACTION_VIEW`
*   `return_result`: `true`
*   **Flags:** `FLAG_ACTIVITY_CLEAR_TOP`, `FLAG_ACTIVITY_SINGLE_TOP` (Crucial for preventing double rendering).

### `TVPlayer.playList(options)`
Launches a playlist (Season/Series).

**Options:**
*   `urls` (string[]): Array of video URLs.
*   `names` (string[]): Array of episode titles.
*   `startIndex` (number): Which index to start playing.
*   `position` (number): Resume position for the *started* episode.

## üì± Supported Players & Extras

### Vimu Player (`net.gtvbox.videoplayer`)
*   **Single:** `forcename` (Title), `forcedirect` (No buffer), `startfrom` (Position).
*   **Playlist:** Uses `application/vnd.gtvbox.filelist` MIME type.
    *   `asusfilelist` (URLs)
    *   `asusnamelist` (Names)

### MX Player (`com.mxtech.videoplayer.ad` / `.pro`)
*   **Single:** `title`, `position`.
*   **Playlist:** Uses standard `video/*` with extras.
    *   `video_list` (Parcelable Uri[])
    *   `video_list.name` (String[])

### VLC (`org.videolan.vlc`)
*   **Single:** `title`, `from_start` (false).
*   **Playlist:** *Not fully supported via Intent extras, falls back to acting as single file player currently.*

## ‚ö†Ô∏è Critical Rules
1.  **Do NOT change `FLAG_ACTIVITY_SINGLE_TOP`.** This prevents the app from restarting or opening a second instance of the intent chooser.
2.  **RESTRICTED: `FLAG_ACTIVITY_NEW_TASK` and `FLAG_ACTIVITY_CLEAR_TOP`**. These flags are essential for correct stack manipulation between PWA and Native Player. Removing them breaks the return journey.
3.  **Lifecycle:** The promise resolves when `onActivityResult` fires (i.e., user closes the player).
    *   **Requirement:** `play()` method MUST return a Promise resolving with `{ position, duration }`.
4.  **Resume Logic:** The result object contains `{ position: number, duration: number, finished: boolean }`. You MUST save this to `localStorage` immediately.

```

---

## skills/capacitor-bridge/references/TVPlayer.java

```java
package com.torserve.pwa;

import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import androidx.activity.result.ActivityResult;
import com.getcapacitor.Plugin;
import com.getcapacitor.PluginCall;
import com.getcapacitor.PluginMethod;
import com.getcapacitor.annotation.ActivityCallback;
import com.getcapacitor.annotation.CapacitorPlugin;
import com.getcapacitor.JSObject;
import java.util.ArrayList;
import org.json.JSONArray;

@CapacitorPlugin(name = "TVPlayer")
public class TVPlayer extends Plugin {

    /**
     * Check if a package (player app) is installed
     */
    @PluginMethod
    public void isPackageInstalled(PluginCall call) {
        String packageName = call.getString("package");
        if (packageName == null) {
            call.reject("Package name required");
            return;
        }
        try {
            getContext().getPackageManager().getPackageInfo(packageName, 0);
            JSObject result = new JSObject();
            result.put("installed", true);
            call.resolve(result);
        } catch (PackageManager.NameNotFoundException e) {
            JSObject result = new JSObject();
            result.put("installed", false);
            call.resolve(result);
        }
    }

    /**
     * Play a single video file with player-specific extras
     * Based on MatriX Vimu.kt and MX.kt implementations
     */
    @PluginMethod
    public void play(PluginCall call) {
        String url = call.getString("url");
        String packageName = call.getString("package");
        String title = call.getString("title", "Video");
        int position = call.getInt("position", 0); // Resume position

        if (url == null) {
            call.reject("URL is required");
            return;
        }

        try {
            Intent intent = new Intent(Intent.ACTION_VIEW);
            intent.setDataAndType(Uri.parse(url), "video/*");
            // AND-01: Prevent double chooser and activity stacking
            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
            intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);

            if (packageName != null && !packageName.isEmpty()) {
                intent.setPackage(packageName);

                // Common extras for result
                intent.putExtra("return_result", true);

                // Vimu Player extras (net.gtvbox.videoplayer)
                if (packageName.contains("gtvbox")) {
                    intent.putExtra("forcename", title); // Show title instead of URL
                    intent.putExtra("forcedirect", true); // Direct access without buffering
                    if (position > 0)
                        intent.putExtra("startfrom", position); // Resume Vimu
                }

                // MX Player extras (com.mxtech.videoplayer)
                if (packageName.contains("mxtech")) {
                    intent.putExtra("title", title);
                    intent.putExtra("sticky", false);
                    if (position > 0)
                        intent.putExtra("position", position); // Resume MX
                }

                // VLC extras
                if (packageName.contains("videolan")) {
                    intent.putExtra("title", title);
                    if (position > 0)
                        intent.putExtra("from_start", false); // VLC specific?
                    // VLC doesn't support standard position extra well, depends on version
                }
            }

            startActivityForResult(call, intent, "playerResult");
        } catch (Exception e) {
            call.reject("Error launching player: " + e.getMessage());
        }
    }

    /**
     * Play a playlist of video files (for series/multi-file torrents)
     * Vimu uses: asusfilelist, asusnamelist, startindex
     * MX uses: video_list, video_list.name
     */
    @PluginMethod
    public void playList(PluginCall call) {
        String packageName = call.getString("package");
        String title = call.getString("title", "Playlist");
        JSONArray urlsJson = call.getArray("urls");
        JSONArray namesJson = call.getArray("names");
        int startIndex = call.getInt("startIndex", 0);
        int position = call.getInt("position", 0);

        if (urlsJson == null || urlsJson.length() == 0) {
            call.reject("URLs array is required");
            return;
        }

        try {
            ArrayList<String> urls = new ArrayList<>();
            ArrayList<String> names = new ArrayList<>();

            for (int i = 0; i < urlsJson.length(); i++) {
                urls.add(urlsJson.getString(i));
                names.add(namesJson != null && i < namesJson.length()
                        ? namesJson.getString(i)
                        : "File " + (i + 1));
            }

            Intent intent = new Intent(Intent.ACTION_VIEW);
            // AND-01: Prevent double chooser
            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
            intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
            intent.putExtra("return_result", true); // Request result

            if (packageName != null && packageName.contains("gtvbox")) {
                // Vimu playlist format (from Vimu.kt)
                intent.setPackage(packageName);
                intent.setDataAndType(Uri.parse(urls.get(startIndex)),
                        "application/vnd.gtvbox.filelist");
                intent.putExtra("forcename", title);
                intent.putStringArrayListExtra("asusfilelist", urls);
                intent.putStringArrayListExtra("asusnamelist", names);
                intent.putExtra("startindex", startIndex);
                if (position > 0 && startIndex >= 0)
                    intent.putExtra("startfrom", position);
            } else if (packageName != null && packageName.contains("mxtech")) {
                // MX Player playlist format (from MX.kt)
                intent.setPackage(packageName);
                intent.setDataAndType(Uri.parse(urls.get(startIndex)), "video/*");
                intent.putExtra("title", title);
                Uri[] uriArray = new Uri[urls.size()];
                for (int i = 0; i < urls.size(); i++) {
                    uriArray[i] = Uri.parse(urls.get(i));
                }
                intent.putExtra("video_list", uriArray);
                intent.putExtra("video_list.name", names.toArray(new String[0]));
                intent.putExtra("video_list.filename", names.toArray(new String[0]));
                intent.putExtra("video_list_is_explicit", true);
                if (position > 0)
                    intent.putExtra("position", position);
            } else {
                // Fallback: play single file from startIndex
                intent.setDataAndType(Uri.parse(urls.get(startIndex)), "video/*");
                if (packageName != null) {
                    intent.setPackage(packageName);
                }
            }

            startActivityForResult(call, intent, "playerResult");
        } catch (Exception e) {
            call.reject("Error launching playlist: " + e.getMessage());
        }
    }

    @ActivityCallback
    private void playerResult(PluginCall call, ActivityResult result) {
        if (call == null)
            return;

        Intent data = result.getData();
        JSObject ret = new JSObject();

        if (data != null) {
            // MX Player / Vimu standard return keys
            int position = data.getIntExtra("position", -1);
            int duration = data.getIntExtra("duration", -1);
            String endBy = data.getStringExtra("end_by"); // user, playback_completion

            // Try distinct known keys if standard fail
            if (position == -1)
                position = data.getIntExtra("current_position", -1);

            ret.put("position", position);
            ret.put("duration", duration);
            ret.put("endBy", endBy);

            // Mark as finished if endBy is completion OR position is near duration (95%)
            boolean finished = "playback_completion".equals(endBy);
            if (!finished && duration > 0 && position > duration * 0.95) {
                finished = true;
            }
            ret.put("finished", finished);
        } else {
            ret.put("position", -1);
            ret.put("message", "No data returned");
        }

        call.resolve(ret);
    }
}

```

---

## skills/resilience-core/SKILL.md

```markdown
---
name: resilience-core
description: Specialist in network resilience, anti-censorship, and TMDB access in restricted regions.
---

# Resilience Core Skill

This skill ensures 100% uptime for metadata fetching by using a multi-layer fallback strategy.
**Metric:** The user must NEVER see a blank poster or missing description due to a network error.

## üåê The Multi-Level Resilience Cascade
Every external request (especially to TMDB) MUST go through `tmdbClient.js`.
NEVER use `fetch()` directly for metadata.

**Cascade Order:**
1.  **Custom Cloudflare Worker:** First line of defense.
2.  **Lampa Proxy:** Public mirror (apn-latest.onrender.com).
3.  **Server Proxy:** Self-hosted proxy (`/api/proxy?url=...`).
4.  **CapacitorHttp + Client DoH (Native Only):**
    *   Uses `dns.google` API to resolve IP, bypassing ISP DNS Poisoning.
    *   Sends direct HTTPS requests to IP with `Host` header.
5.  **Corsproxy.io:** Browser-based fallback.
6.  **Kinopoisk (Out-of-band Fallback):**
    *   Used ONLY for text data (titles, descriptions).
    *   Triggered ONLY if TMDB is completely unreachable via all above levels.

### üö¶ Traffic Isolation Rule
**RULE:** DoH (DNS-over-HTTPS) and IP-direct requests are used **TOKYO for API data (JSON)**.
*   **NEVER** use DoH mechanisms for loading images/posters.
*   Images have their own resilience logic (Mirrors -> WSRV.NL).

## üõ°Ô∏è Image Resilience
Images use a separate logic:
*   **Mirrors:** `imagetmdb.com`, `nl.imagetmdb.com`, etc.
*   **Auto-Ban:** If a mirror fails 20 times in 10s, it's banned.
*   **WSRV.NL:** If all mirrors fail, we switch to `wsrv.nl` proxying.

## üíª Usage Example
```javascript
import tmdbClient from '../utils/tmdbClient';

// BAD ‚ùå
// const res = await fetch('https://api.themoviedb.org/3/movie/550');

// GOOD ‚úÖ
const data = await tmdbClient('/movie/550');
if (data.source === 'kinopoisk') {
    // Handle specific KP logic if needed
}
```

```

---

## skills/resilience-core/references/doh_guide.md

```markdown
# Client-Side DNS-over-HTTPS (DoH) Guide

## Problem
In some regions (e.g., Russia), ISPs perform **DNS Poisoning** for `api.themoviedb.org`, returning `127.0.0.1` or blocking the DNS lookup entirely.
Standard `fetch` or `CapacitorHttp` fails because it relies on the system DNS.

## Solution
We perform valid DNS resolution manually via a trusted DoH provider (Google) and then connect directly to the resolved IP.

## Implementation Details

### 1. Resolve IP
We use Google's JSON API: `https://dns.google/resolve?name=api.themoviedb.org&type=A`

```javascript
// Returns e.g., "65.8.11.22"
const ip = await resolveClientIP('api.themoviedb.org');
```

### 2. Direct Connection (SNI Trick)
We cannot just access `https://65.8.11.22/` because the SSL certificate is invalid for the IP address.
However, `CapacitorHttp` (native implementation) allows us to send the `Host` header which some servers accept, or strictly speaking, we rely on the fact that if we use the IP in the URL, we must accept that SSL verification *might* fail or we rely on SNI being set correctly if the library supports it.

*Correction:* In our implementation, we use `CapacitorHttp`.
Target: `https://<IP>/3/...`
Header: `Host: api.themoviedb.org`

**Note:** This only works because we trust the resolved IP from Google. 

### 3. Caching
DoH results are cached for 10 minutes (`dohCache`) to minimize latency.

```

---

## skills/tv-navigator/SKILL.md

```markdown
---
name: tv-navigator
description: Specialist in Android TV D-Pad navigation and React focus management.
---

# TV Navigator Skill

This skill provides expertise in creating "TV-First" interfaces using the `useTVNavigation` hook.
Your goal is to ensure every component is accessible via D-Pad (Arrow Keys) and handles focus states correctly.

## üß† Core Concepts

### 1. `useTVNavigation` Hook
Located in: `client/src/hooks/useTVNavigation.js`

**Signature:**
```javascript
const { 
  focusedIndex,    // Current active index (0..N)
  setFocusedIndex, // Manually set focus
  containerProps,  // { onKeyDown, tabIndex } - spreads to parent container
  isFocused        // Helper: (index) => boolean
} = useTVNavigation({
  itemCount: number,      // Total items
  columns: number,        // 1 for List, >1 for Grid
  itemRefs: React.RefObject, // { current: { [index]: HTMLElement } }
  onSelect: (index) => void, // Enter/OK press
  onBack: () => void,     // Escape/Back press
  loop: boolean,          // Default: false
  trapFocus: boolean,     // true = Isolated (Modals), false = Global (HomeRow)
  isActive: boolean       // External control. If false, ignores all input.
})
```

### 2. Focus Visualization
- NEVER use `:hover` for TV interfaces.
- ALWAYS use the `.focused` state logic or conditional rendering based on `focusedIndex`.
- For `focused` items, apply: `border`, `transform: scale(1.05)`, or `box-shadow`.

### 3. Scroll Management
The hook automatically handles scrolling using `scrollIntoView({ behavior: 'smooth', block: 'center' })`.
You must attach refs to items:
```javascript
<div ref={el => itemRefs.current[index] = el} ... >
```

### 4. Integration with `activeArea`
The hook must respect the `isActive` flag.
*   If `isActive === false`: The hook ignores ALL key presses.
*   This allows other UI areas (like the Sidebar) to take over control without unmounting the grid.

## üõ† Common Patterns

### Vertical List (Menu)
```javascript
const { containerProps, isFocused } = useTVNavigation({ 
  itemCount: items.length, 
  columns: 1 
});
```

### Grid (Posters)
```javascript
const { containerProps } = useTVNavigation({ 
  itemCount: items.length, 
  columns: 4 // or dynamic based on width
});
```

## ‚ö†Ô∏è Anti-Patterns to Avoid
1. **Hidden Overflow:** Avoid `overflow: hidden` on containers that need to scroll, unless you are implementing virtualized scrolling.
2. **Missing TabIndex:** The container MUST have `tabIndex={0}` (provided by `containerProps`) to capture keyboard events.
3. **Mouse Dependency:** Do not rely on `onClick`. Always map `onSelect` (Enter key) to the same handler.

```

---

## skills/tv-navigator/assets/FocusableGrid.jsx

```javascript
// REFERENCE IMPLEMENTATION: Use for isolated grids. 
// WARNING: For global home rows, ensure trapFocus is FALSE.
import React, { useRef, useEffect } from 'react';
import useTVNavigation from '../../client/src/hooks/useTVNavigation';

const FocusableGrid = ({ items, onSelect }) => {
    const itemRefs = useRef({});
    
    const { focusedIndex, containerProps, isFocused } = useTVNavigation({
        itemCount: items.length,
        columns: 4, // Example: 4 columns
        itemRefs,
        onSelect: (index) => onSelect(items[index]),
        trapFocus: true
    });

    // Auto-focus container on mount if needed
    // useEffect(() => { itemRefs.current[0]?.focus(); }, []);

    return (
        <div 
            className="grid grid-cols-4 gap-4 p-4"
            {...containerProps} // Captures ArrowKeys
        >
            {items.map((item, index) => (
                <div
                    key={item.id}
                    ref={el => itemRefs.current[index] = el}
                    className={`
                        p-4 rounded-lg transition-transform duration-200
                        ${isFocused(index) ? 'scale-105 border-2 border-white shadow-lg' : 'opacity-80'}
                    `}
                    // Optional: Support mouse overlap
                    onClick={() => onSelect(item)} 
                >
                    <img src={item.poster} alt={item.title} />
                    <p>{item.name}</p>
                </div>
            ))}
        </div>
    );
};

export default FocusableGrid;

```

---

